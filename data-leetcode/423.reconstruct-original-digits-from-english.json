[
    {
        "title": "Reconstruct Original Digits from English",
        "question_content": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\n&nbsp;\nExample 1:\nInput: s = \"owoztneoer\"\nOutput: \"012\"\nExample 2:\nInput: s = \"fviefuro\"\nOutput: \"45\"\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts[i] is one of the characters [\"e\",\"g\",\"f\",\"i\",\"h\",\"o\",\"n\",\"s\",\"r\",\"u\",\"t\",\"w\",\"v\",\"x\",\"z\"].\n\ts is guaranteed to be valid.",
        "solutions": [
            {
                "id": 91207,
                "title": "one-pass-o-n-java-solution-simple-and-clear",
                "content": "The idea is:\\n\\nfor zero, it's the only word has letter 'z',\\nfor two, it's the only word has letter 'w',\\n......\\nso we only need to count the unique letter of each word, Coz the input is always valid.\\n\\nCode:\\n\\n    public String originalDigits(String s) {\\n        int[] count = new int[10];\\n        for (int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if (c == 'z') count[0]++;\\n            if (c == 'w') count[2]++;\\n            if (c == 'x') count[6]++;\\n            if (c == 's') count[7]++; //7-6\\n            if (c == 'g') count[8]++;\\n            if (c == 'u') count[4]++; \\n            if (c == 'f') count[5]++; //5-4\\n            if (c == 'h') count[3]++; //3-8\\n            if (c == 'i') count[9]++; //9-8-5-6\\n            if (c == 'o') count[1]++; //1-0-2-4\\n        }\\n        count[7] -= count[6];\\n        count[5] -= count[4];\\n        count[3] -= count[8];\\n        count[9] = count[9] - count[8] - count[5] - count[6];\\n        count[1] = count[1] - count[0] - count[2] - count[4];\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <= 9; i++){\\n            for (int j = 0; j < count[i]; j++){\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "The idea is:\\n\\nfor zero, it's the only word has letter 'z',\\nfor two, it's the only word has letter 'w',\\n......\\nso we only need to count the unique letter of each word, Coz the input is always valid.\\n\\nCode:\\n\\n    public String originalDigits(String s) {\\n        int[] count = new int[10];\\n        for (int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if (c == 'z') count[0]++;\\n            if (c == 'w') count[2]++;\\n            if (c == 'x') count[6]++;\\n            if (c == 's') count[7]++; //7-6\\n            if (c == 'g') count[8]++;\\n            if (c == 'u') count[4]++; \\n            if (c == 'f') count[5]++; //5-4\\n            if (c == 'h') count[3]++; //3-8\\n            if (c == 'i') count[9]++; //9-8-5-6\\n            if (c == 'o') count[1]++; //1-0-2-4\\n        }\\n        count[7] -= count[6];\\n        count[5] -= count[4];\\n        count[3] -= count[8];\\n        count[9] = count[9] - count[8] - count[5] - count[6];\\n        count[1] = count[1] - count[0] - count[2] - count[4];\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <= 9; i++){\\n            for (int j = 0; j < count[i]; j++){\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1131046,
                "title": "python-linear-solution-using-counters-explained",
                "content": "Actually what is asked in this problem is to solve linear system of equations: imagine that we have `f0, ... f9` frequencies of words `zero, ... nine`, then we need to solve `10` equations with `10` variables. We can look at this at slightly different angle:\\n1. Let us look at word `zero`: we meet symbol `z` only in this word, so total number of times we have `z` in string is number of times we have word `zero` inside. So, what we do: we keep global counter `cnt` and subtract all frequencies, corresponding to letters `z`, `e`, `r`, `o`.\\n2. Look at word `two`, we have symbol `w` only in this word, remove all words `two`.\\n3. Look at word `four`, we have symbol `u` only in this word, remove all words `four`.\\n4. Look at word `six`, we have symbol `x` only in this word, remove all words `six`.\\n5. Look at word `eight`, we have symbol `g` only in this word, remove all words `eight`.\\n6. Look at word `one`, we have symbol `o` only in this word if we look at words we still have, remove all words `one`.\\n7. Look at word `three`, we have symbol `t` only in this word if we look at words we still have, remove all words `three`.\\n8. Look at word `five`, we have symbol `f` only in this word if we look at words we still have, remove all words `five`.\\n9. Look at word `seven`, we have symbol `s` only in this word if we look at words we still have, remove all words `seven`.\\n10. Look at word `nine`, we have symbol `n` only in this word if we look at words we still have, remove all words `nine`.\\n\\n**Complexity**: time complexity is just `O(n)`, where `n` is length of `s`, because first we create counter and then we iterate over `10` digits and update `cnt` in `O(1)` time. Space complexity is `O(n)` as well to format our answer.\\n\\n```\\nclass Solution:\\n    def originalDigits(self, s):\\n        cnt = Counter(s)\\n        Digits = [\"zero\",\"two\",\"four\",\"six\",\"eight\",\"one\",\"three\",\"five\",\"seven\",\"nine\"]\\n        Corresp = [0,2,4,6,8,1,3,5,7,9]\\n        Counters = [Counter(digit) for digit in Digits]\\n        Found = [0]*10\\n        for it, C in enumerate(Counters):\\n            k = min(cnt[x]//C[x] for x in C)\\n            for i in C.keys(): C[i] *= k\\n            cnt -= C\\n            Found[Corresp[it]] = k\\n            \\n        return \"\".join([str(i)*Found[i] for i in range(10)])     \\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s):\\n        cnt = Counter(s)\\n        Digits = [\"zero\",\"two\",\"four\",\"six\",\"eight\",\"one\",\"three\",\"five\",\"seven\",\"nine\"]\\n        Corresp = [0,2,4,6,8,1,3,5,7,9]\\n        Counters = [Counter(digit) for digit in Digits]\\n        Found = [0]*10\\n        for it, C in enumerate(Counters):\\n            k = min(cnt[x]//C[x] for x in C)\\n            for i in C.keys(): C[i] *= k\\n            cnt -= C\\n            Found[Corresp[it]] = k\\n            \\n        return \"\".join([str(i)*Found[i] for i in range(10)])     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 91191,
                "title": "python-solution-that-beats-100",
                "content": "```\\nclass Solution:\\n    def originalDigits(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        res += \"0\"*s.count('z')\\n        res += \"1\"*(s.count('o')-s.count('z')-s.count('w')-s.count('u'))\\n        res += \"2\"*s.count('w')\\n        res += \"3\"*(s.count('h') - s.count('g'))\\n        res += \"4\"*s.count('u')\\n        res += \"5\"*(s.count('f') - s.count('u'))\\n        res += \"6\"*s.count('x')\\n        res += \"7\"*(s.count('s')-s.count('x'))\\n        res += \"8\"*s.count(\"g\")\\n        res += \"9\"*(s.count('i') - s.count('x') - s.count(\"g\") - s.count('f') + s.count('u'))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        res += \"0\"*s.count('z')\\n        res += \"1\"*(s.count('o')-s.count('z')-s.count('w')-s.count('u'))\\n        res += \"2\"*s.count('w')\\n        res += \"3\"*(s.count('h') - s.count('g'))\\n        res += \"4\"*s.count('u')\\n        res += \"5\"*(s.count('f') - s.count('u'))\\n        res += \"6\"*s.count('x')\\n        res += \"7\"*(s.count('s')-s.count('x'))\\n        res += \"8\"*s.count(\"g\")\\n        res += \"9\"*(s.count('i') - s.count('x') - s.count(\"g\") - s.count('f') + s.count('u'))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91195,
                "title": "straightforward-c-accepted-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<string> words = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n        vector<int> nums = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};\\n        vector<int> distinct_char = {'z', 'w', 'u', 'x', 'g', 'o', 'r', 'f', 'v', 'i'};\\n        vector<int> counts(26, 0);\\n        string result;\\n        for(auto ch : s){ counts[ch-'a']++;}\\n        for(int i = 0; i < 10; i++){\\n            int count = counts[distinct_char[i]-'a'];\\n            for(int j = 0; j < words[i].size(); j++)\\n                counts[words[i][j]-'a'] -= count;\\n            while(count--)\\n                result += to_string(nums[i]);\\n        }\\n        sort(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<string> words = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n        vector<int> nums = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};\\n        vector<int> distinct_char = {'z', 'w', 'u', 'x', 'g', 'o', 'r', 'f', 'v', 'i'};\\n        vector<int> counts(26, 0);\\n        string result;\\n        for(auto ch : s){ counts[ch-'a']++;}\\n        for(int i = 0; i < 10; i++){\\n            int count = counts[distinct_char[i]-'a'];\\n            for(int j = 0; j < words[i].size(); j++)\\n                counts[words[i][j]-'a'] -= count;\\n            while(count--)\\n                result += to_string(nums[i]);\\n        }\\n        sort(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131491,
                "title": "java-explained-solution",
                "content": "**EXPLANATION AND IDEA:**\\n```\\nzero = 0\\n one  = 1\\n two  = 2\\n three= 3\\n four = 4\\n five = 5\\n six  = 6\\n seven= 7\\n eight= 8\\n nine = 9\\n \\n We can observe that some characters are only present in some words only like :\\n z(zero) -> 0\\n x(six)  -> 6\\n u(four) -> 4\\n w(two)  -> 2\\n g(eigth)-> 8\\n f(five+four) -> 5 && 4\\n O(one +two + four + zero) -> 1 && 2 && 4 && 0\\n t(three + eight + two) -> 3 && 8 && 2\\n s(seven + six) -> 7 && 6\\n i(nine + five + six + eight) -> 9 && 5 && 6 && 8\\n```\\nif x present its mean that it is from 6. so we can find occurance of 6 through x. and we know that \\ns is present in both 6 and 7 . i.e digit[6] + digit[7]=map[s] ( frequency of s in given string). we can easily figure out frequency of 6 through x and frequency of s (map[s]) through string . so we can find frequency of 7 easily by:\\ndigit[7]=map[s]-digit[6].\\nsimilarly for other combinations .\\n\\n**CODE:**\\n```\\npublic String originalDigits(String s) {\\n        int[] map=new int[26]; //frequency of characters\\n        for(char ch:s.toCharArray()) map[ch-\\'a\\']++;\\n        \\n        int[] digit=new int[10]; //frequency of numbers\\n        \\n        digit[0]=map[\\'z\\'-\\'a\\'];\\n        digit[6]=map[\\'x\\'-\\'a\\'];\\n        digit[4]=map[\\'u\\'-\\'a\\'];\\n        digit[2]=map[\\'w\\'-\\'a\\'];\\n        digit[8]=map[\\'g\\'-\\'a\\'];\\n        digit[5]=map[\\'f\\'-\\'a\\'] - digit[4];\\n        digit[7]=map[\\'s\\'-\\'a\\'] - digit[6];\\n        digit[3]=map[\\'t\\'-\\'a\\'] - digit[8] - digit[2];\\n        digit[1]=map[\\'o\\'-\\'a\\']-digit[2]-digit[4]-digit[0];\\n        digit[9]=map[\\'i\\'-\\'a\\']-digit[5]-digit[6]-digit[8];\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(int i=0;i<10;i++){\\n            int freq=digit[i];\\n            while(freq-->0){\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n**Complexity:**\\n`Time:O(n) and Space:O(1) [Big O Notation]`\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nzero = 0\\n one  = 1\\n two  = 2\\n three= 3\\n four = 4\\n five = 5\\n six  = 6\\n seven= 7\\n eight= 8\\n nine = 9\\n \\n We can observe that some characters are only present in some words only like :\\n z(zero) -> 0\\n x(six)  -> 6\\n u(four) -> 4\\n w(two)  -> 2\\n g(eigth)-> 8\\n f(five+four) -> 5 && 4\\n O(one +two + four + zero) -> 1 && 2 && 4 && 0\\n t(three + eight + two) -> 3 && 8 && 2\\n s(seven + six) -> 7 && 6\\n i(nine + five + six + eight) -> 9 && 5 && 6 && 8\\n```\n```\\npublic String originalDigits(String s) {\\n        int[] map=new int[26]; //frequency of characters\\n        for(char ch:s.toCharArray()) map[ch-\\'a\\']++;\\n        \\n        int[] digit=new int[10]; //frequency of numbers\\n        \\n        digit[0]=map[\\'z\\'-\\'a\\'];\\n        digit[6]=map[\\'x\\'-\\'a\\'];\\n        digit[4]=map[\\'u\\'-\\'a\\'];\\n        digit[2]=map[\\'w\\'-\\'a\\'];\\n        digit[8]=map[\\'g\\'-\\'a\\'];\\n        digit[5]=map[\\'f\\'-\\'a\\'] - digit[4];\\n        digit[7]=map[\\'s\\'-\\'a\\'] - digit[6];\\n        digit[3]=map[\\'t\\'-\\'a\\'] - digit[8] - digit[2];\\n        digit[1]=map[\\'o\\'-\\'a\\']-digit[2]-digit[4]-digit[0];\\n        digit[9]=map[\\'i\\'-\\'a\\']-digit[5]-digit[6]-digit[8];\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(int i=0;i<10;i++){\\n            int freq=digit[i];\\n            while(freq-->0){\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91203,
                "title": "share-my-simple-and-easy-o-n-solution",
                "content": "```\\npublic class Solution {\\n    public String originalDigits(String s) {\\n        if(s==null || s.length()==0) return \"\";\\n        int[] count = new int[128];\\n        for(int i=0;i<s.length();i++)  count[s.charAt(i)]++;\\n        int[] num = new int[10];\\n        num[0] = count['z'];\\n        num[2] = count['w'];\\n        num[4] = count['u'];\\n        num[6] = count['x'];\\n        num[8] = count['g'];\\n        num[1] = count['o']-count['z']-count['w']-count['u'];\\n        num[3] = count['h']-count['g'];\\n        num[5] = count['v']-count['s']+count['x'];\\n        num[7] = count['s']-count['x'];\\n        num[9] = count['i']-count['x']-count['g']-count['v']+count['s']-count['x'];\\n        String ret = new String();\\n        for(int i=0;i<10;i++)\\n            for(int j=num[i];j>0;j--) ret += String.valueOf(i);\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String originalDigits(String s) {\\n        if(s==null || s.length()==0) return \"\";\\n        int[] count = new int[128];\\n        for(int i=0;i<s.length();i++)  count[s.charAt(i)]++;\\n        int[] num = new int[10];\\n        num[0] = count['z'];\\n        num[2] = count['w'];\\n        num[4] = count['u'];\\n        num[6] = count['x'];\\n        num[8] = count['g'];\\n        num[1] = count['o']-count['z']-count['w']-count['u'];\\n        num[3] = count['h']-count['g'];\\n        num[5] = count['v']-count['s']+count['x'];\\n        num[7] = count['s']-count['x'];\\n        num[9] = count['i']-count['x']-count['g']-count['v']+count['s']-count['x'];\\n        String ret = new String();\\n        for(int i=0;i<10;i++)\\n            for(int j=num[i];j>0;j--) ret += String.valueOf(i);\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131064,
                "title": "js-python-java-c-simple-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe most important thing we have to realize here is that some of the characters that make up the input string (**S**) can only belong to one possible word. This will immediately tell us how many of that digit should belong in our answer (**ans**).\\n\\nThe first thing we should do, then, is to create a **frequency map** (**fmap**) of all the characters in **S**. Since we\\'re dealing with characters here, we have the option to use an **arraymap** with **26** elements corresponding to the **0-index** code of each character rather than using a normal map object, which should speed up the processing.\\n\\nSome of the words, however, use only characters that can be found in more than one word, so we\\'ll have to carefully pick the order in which we figure out the frequency of each word, so that we can simplify later checks.\\n\\nFor example, the digits in the word forms of the digits **0**, **2**, **4**, **6**, and **8** all contain a character unique to that word, so we could iterate through those words and update the **fmap** entries for each of their characters to represent the removal of those words.\\n\\nBut we don\\'t really need to update the frequency of every character, only the ones that will be useful for isolating the remaining five words.\\n\\nTo keep track of the proper word order, the special character for each word, and the required characters to remove, we can declare a constant lookup array (**DIGITS**).\\n\\nIn order to keep **ans** in the proper order, we should initially put the individual digit strings in a temporary array and then **join ans** before we **return** it.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Python, using **count()** is actually faster than using a **frequency map**, so we can reverse a bit of the process and remove the common letter results at the later word, rather than the earlier one.\\n\\nJava should split **S** into a **charArray** before iteration, and should use a **StringBuilder()** to concatenate **ans** before **return**ing it.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **84ms / 41.4MB** (beats 100% / 100%).\\n```javascript\\nconst DIGITS = [\\n    [\"0\",25,[14]],\\n    [\"2\",22,[14]],\\n    [\"4\",20,[5,14]],\\n    [\"6\",23,[18,8]],\\n    [\"8\",6,[8,7]],\\n    [\"5\",5,[8]],\\n    [\"7\",18,[]],\\n    [\"3\",7,[]],\\n    [\"9\",8,[]],\\n    [\"1\",14,[]]\\n]\\nvar originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.8MB** (beats 100% / 27%).\\n```python\\nDIGITS = [\\n    [0,\\'z\\',[]],\\n    [2,\\'w\\',[]],\\n    [4,\\'u\\',[]],\\n    [6,\\'x\\',[]],\\n    [8,\\'g\\',[]],\\n    [5,\\'f\\',[4]],\\n    [7,\\'s\\',[6]],\\n    [3,\\'h\\',[8]],\\n    [9,\\'i\\',[6,8,5]],\\n    [1,\\'o\\',[0,2,4]]\\n]\\nclass Solution:\\n    def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 39.3MB** (beats 100% / 90%).\\n```java\\nclass Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}, CHARS = {25,22,20,23,6,5,18,7,8,14};\\n    static final int[][] REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\n    public String originalDigits(String S) {\\n        int[] fmap = new int[26], ans = new int[10];\\n        char[] SCA = S.toCharArray();\\n        for (char c : SCA) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = 0; j < ans[i]; j++)\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **8ms / 8.8MB** (beats 100% / 70%).\\n```c++\\nclass Solution {\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S) {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst DIGITS = [\\n    [\"0\",25,[14]],\\n    [\"2\",22,[14]],\\n    [\"4\",20,[5,14]],\\n    [\"6\",23,[18,8]],\\n    [\"8\",6,[8,7]],\\n    [\"5\",5,[8]],\\n    [\"7\",18,[]],\\n    [\"3\",7,[]],\\n    [\"9\",8,[]],\\n    [\"1\",14,[]]\\n]\\nvar originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};\\n```\n```python\\nDIGITS = [\\n    [0,\\'z\\',[]],\\n    [2,\\'w\\',[]],\\n    [4,\\'u\\',[]],\\n    [6,\\'x\\',[]],\\n    [8,\\'g\\',[]],\\n    [5,\\'f\\',[4]],\\n    [7,\\'s\\',[6]],\\n    [3,\\'h\\',[8]],\\n    [9,\\'i\\',[6,8,5]],\\n    [1,\\'o\\',[0,2,4]]\\n]\\nclass Solution:\\n    def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```\n```java\\nclass Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}, CHARS = {25,22,20,23,6,5,18,7,8,14};\\n    static final int[][] REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\n    public String originalDigits(String S) {\\n        int[] fmap = new int[26], ans = new int[10];\\n        char[] SCA = S.toCharArray();\\n        for (char c : SCA) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = 0; j < ans[i]; j++)\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S) {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131066,
                "title": "reconstruct-original-digits-from-english-js-python-java-c-simple-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe most important thing we have to realize here is that some of the characters that make up the input string (**S**) can only belong to one possible word. This will immediately tell us how many of that digit should belong in our answer (**ans**).\\n\\nThe first thing we should do, then, is to create a **frequency map** (**fmap**) of all the characters in **S**. Since we\\'re dealing with characters here, we have the option to use an **arraymap** with **26** elements corresponding to the **0-index** code of each character rather than using a normal map object, which should speed up the processing.\\n\\nSome of the words, however, use only characters that can be found in more than one word, so we\\'ll have to carefully pick the order in which we figure out the frequency of each word, so that we can simplify later checks.\\n\\nFor example, the digits in the word forms of the digits **0**, **2**, **4**, **6**, and **8** all contain a character unique to that word, so we could iterate through those words and update the **fmap** entries for each of their characters to represent the removal of those words.\\n\\nBut we don\\'t really need to update the frequency of every character, only the ones that will be useful for isolating the remaining five words.\\n\\nTo keep track of the proper word order, the special character for each word, and the required characters to remove, we can declare a constant lookup array (**DIGITS**).\\n\\nIn order to keep **ans** in the proper order, we should initially put the individual digit strings in a temporary array and then **join ans** before we **return** it.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Python, using **count()** is actually faster than using a **frequency map**, so we can reverse a bit of the process and remove the common letter results at the later word, rather than the earlier one.\\n\\nJava should split **S** into a **charArray** before iteration, and should use a **StringBuilder()** to concatenate **ans** before **return**ing it.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **84ms / 41.4MB** (beats 100% / 100%).\\n```javascript\\nconst DIGITS = [\\n    [\"0\",25,[14]],\\n    [\"2\",22,[14]],\\n    [\"4\",20,[5,14]],\\n    [\"6\",23,[18,8]],\\n    [\"8\",6,[8,7]],\\n    [\"5\",5,[8]],\\n    [\"7\",18,[]],\\n    [\"3\",7,[]],\\n    [\"9\",8,[]],\\n    [\"1\",14,[]]\\n]\\nvar originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.8MB** (beats 100% / 27%).\\n```python\\nDIGITS = [\\n    [0,\\'z\\',[]],\\n    [2,\\'w\\',[]],\\n    [4,\\'u\\',[]],\\n    [6,\\'x\\',[]],\\n    [8,\\'g\\',[]],\\n    [5,\\'f\\',[4]],\\n    [7,\\'s\\',[6]],\\n    [3,\\'h\\',[8]],\\n    [9,\\'i\\',[6,8,5]],\\n    [1,\\'o\\',[0,2,4]]\\n]\\nclass Solution:\\n    def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 39.3MB** (beats 100% / 90%).\\n```java\\nclass Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}, CHARS = {25,22,20,23,6,5,18,7,8,14};\\n    static final int[][] REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\n    public String originalDigits(String S) {\\n        int[] fmap = new int[26], ans = new int[10];\\n        char[] SCA = S.toCharArray();\\n        for (char c : SCA) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = 0; j < ans[i]; j++)\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **8ms / 8.8MB** (beats 100% / 70%).\\n```c++\\nclass Solution {\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S) {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst DIGITS = [\\n    [\"0\",25,[14]],\\n    [\"2\",22,[14]],\\n    [\"4\",20,[5,14]],\\n    [\"6\",23,[18,8]],\\n    [\"8\",6,[8,7]],\\n    [\"5\",5,[8]],\\n    [\"7\",18,[]],\\n    [\"3\",7,[]],\\n    [\"9\",8,[]],\\n    [\"1\",14,[]]\\n]\\nvar originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};\\n```\n```python\\nDIGITS = [\\n    [0,\\'z\\',[]],\\n    [2,\\'w\\',[]],\\n    [4,\\'u\\',[]],\\n    [6,\\'x\\',[]],\\n    [8,\\'g\\',[]],\\n    [5,\\'f\\',[4]],\\n    [7,\\'s\\',[6]],\\n    [3,\\'h\\',[8]],\\n    [9,\\'i\\',[6,8,5]],\\n    [1,\\'o\\',[0,2,4]]\\n]\\nclass Solution:\\n    def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```\n```java\\nclass Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}, CHARS = {25,22,20,23,6,5,18,7,8,14};\\n    static final int[][] REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\n    public String originalDigits(String S) {\\n        int[] fmap = new int[26], ans = new int[10];\\n        char[] SCA = S.toCharArray();\\n        for (char c : SCA) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = 0; j < ans[i]; j++)\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S) {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91232,
                "title": "c-o-n-solution",
                "content": "    class Solution {\\n    public:\\n        string originalDigits(string s) {\\n            vector<int> a(10, 0);\\n            vector<int> alpha(128, 0);\\n            for (char c : s)\\n                alpha[c]++;\\n            a[0] = alpha['z'];\\n            a[2] = alpha['w'];\\n            a[4] = alpha['u'];\\n            a[6] = alpha['x'];\\n            a[8] = alpha['g'];\\n            a[3] = alpha['h'] - a[8];\\n            a[5] = alpha['f'] - a[4];\\n            a[7] = alpha['v'] - a[5];\\n            a[1] = alpha['o'] - a[0] - a[2] - a[4];\\n            a[9] = alpha['i'] - a[5] - a[6] - a[8];\\n            string ans;\\n            for (int i = 0; i < 10; i++) {\\n                if (a[i] > 0)\\n                    ans += string(a[i], '0' + i);\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string originalDigits(string s) {\\n            vector<int> a(10, 0);\\n            vector<int> alpha(128, 0);\\n            for (char c : s)\\n                alpha[c]++;\\n            a[0] = alpha['z'];\\n            a[2] = alpha['w'];\\n            a[4] = alpha['u'];\\n            a[6] = alpha['x'];\\n            a[8] = alpha['g'];\\n            a[3] = alpha['h'] - a[8];\\n            a[5] = alpha['f'] - a[4];\\n            a[7] = alpha['v'] - a[5];\\n            a[1] = alpha['o'] - a[0] - a[2] - a[4];\\n            a[9] = alpha['i'] - a[5] - a[6] - a[8];\\n            string ans;\\n            for (int i = 0; i < 10; i++) {\\n                if (a[i] > 0)\\n                    ans += string(a[i], '0' + i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1131114,
                "title": "python-go-o-n-by-dictionary-w-diagram",
                "content": "**Hint**:\\n\\n1. Rebuild **even digits** first, becuase each even digit has corresponding **unique character** naturally\\n\\n1. Then rebuild **odd digits** from observed character-occurrence mapping.\\n\\n---\\n\\n**Diagram** for even digits (i.e., 0, 2, 4, 6, 8 ) rebuilding based on character-occurrence mapping\\n\\n![image](https://assets.leetcode.com/users/images/8e82022a-6ef6-4988-ba10-ea51d75c4f65_1616923974.735313.png)\\n\\n---\\n\\n**Diagram** for odd digits (i.e., 1, 3, 5, 7, 9 ) rebuilding based on character-occurrence mapping\\n\\n![image](https://assets.leetcode.com/users/images/c894f2e1-f477-4c87-9161-0182021d968e_1616924060.264607.png)\\n\\n\\n---\\n\\n**Implementation** by dictioanry in Python:\\n\\n```\\n\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n\\n        \\n        # ----------------------------------------------------------\\n        \\n        def mapping_rebuild( digit_occ_dict , char_occ_dict ):\\n            \\n            \\n            ## Rebuild the number and its occurrence from character frequency analysis\\n            \\n            \\n            # \"z\" only shows up in \"zero\"\\n            digit_occ_dict [0] = char_occ_dict[\\'z\\']\\n\\n            # \"w\" only shows up in \"two\"\\n            digit_occ_dict [2] = char_occ_dict[\\'w\\']\\n\\n            # \"u\" only shows up in \"four\"\\n            digit_occ_dict [4] = char_occ_dict[\\'u\\']\\n\\n            # \"x\" only shows up in \"six\"\\n            digit_occ_dict [6] = char_occ_dict[\\'x\\']\\n\\n            # \"g\" only shows up in \"eight\"\\n            digit_occ_dict [8] = char_occ_dict[\\'g\\']\\n\\n            # \"o\" only shows up in \"zero\", \"one\", \"two\", \"four\"\\n            digit_occ_dict [1] = char_occ_dict[\\'o\\'] - digit_occ_dict [0] - digit_occ_dict [2] - digit_occ_dict [4]\\n\\n            # \"h\" only shows up in \"three\", \"eight\"\\n            digit_occ_dict [3] = char_occ_dict[\\'h\\'] - digit_occ_dict [8]\\n\\n            # \"f\" only shows up in \"four\", \"five\"\\n            digit_occ_dict [5] = char_occ_dict[\\'f\\'] - digit_occ_dict [4]\\n\\n            # \"s\" only shows up in \"six\", \"seven\"\\n            digit_occ_dict [7] = char_occ_dict[\\'s\\'] - digit_occ_dict [6]\\n\\n            # \"i\" only shows up in \"five\", \"six\", \"eight\", \"nine\"\\n            digit_occ_dict [9] = char_occ_dict[\\'i\\'] - digit_occ_dict [5] - digit_occ_dict [6] - digit_occ_dict [8]\\n\\n            return\\n        # ----------------------------------------------------------\\n        \\n        ## dictionary of input s\\n        # key: ascii character\\n        # value: occurrence of ascii character\\n        char_occ_dict = Counter(s)\\n        \\n        ## dictionary\\n        # key: digit\\n        # value: occurrence of digit\\n        digit_occ_dict = defaultdict( int )\\n        \\n        # rebuild digit-occurrence mapping from input s and its char-occurrence mapping\\n        mapping_rebuild( digit_occ_dict , char_occ_dict)\\n        \\n        # rebuild digit string in ascending order\\n        digit_string = \"\".join( (str(digit) * digit_occ_dict [digit]) for digit in range(0, 10) )\\n        \\n        return digit_string\\n                \\n            \\n```\\n\\n---\\n\\n\\n\\n**Implementation** by dictiaonry in Golang:\\n\\n```\\n\\nimport (\\n\\t\"strings\"\\n\\t\"strconv\"\\n)\\n\\nfunc originalDigits(s string) string {\\n    \\n    //// dictionary of input s\\n    // key: ascii character\\n    // value: occurrence of ascii character\\n    charOccDict := make( map[rune]int )\\n    \\n    for _, char := range s{\\n        charOccDict[char] += 1\\n    }\\n    \\n    //// dictionary\\n    // key: digit\\n    // value: occurrence of digit    \\n    digitOccDict := make( map[int]int )\\n    \\n    // rebuild digit-occurrence mapping from input s and its char-occurrence mapping\\n    mapping_rebuild( &digitOccDict, &charOccDict )\\n    \\n    \\n    // rebuild digit string in ascending order\\n    outputString := \"\"\\n    \\n    for digit := 0 ; digit <= 9 ; digit++{\\n     \\n        occurrence := digitOccDict[digit]\\n        outputString += strings.Repeat( strconv.Itoa(digit), occurrence)\\n    }\\n    \\n    return outputString\\n}\\n\\n\\nfunc mapping_rebuild( digitMap *map[int]int, letterMap *map[rune]int){\\n    // Rebuild the number and its occurrence from character frequency analysis\\n    \\n    // \"z\" only shows up in \"zero\"\\n    (*digitMap)[0] = (*letterMap)[\\'z\\']\\n    \\n    // \"w\" only shows up in \"two\"\\n    (*digitMap)[2] = (*letterMap)[\\'w\\']\\n    \\n    // \"u\" only shows up in \"four\"\\n    (*digitMap)[4] = (*letterMap)[\\'u\\']\\n    \\n    // \"x\" only shows up in \"six\"\\n    (*digitMap)[6] = (*letterMap)[\\'x\\']\\n    \\n    // \"g\" only shows up in \"eight\"\\n    (*digitMap)[8] = (*letterMap)[\\'g\\']\\n    \\n    // \"o\" only shows up in \"zero\", \"one\", \"two\", \"four\"\\n    (*digitMap)[1] = (*letterMap)[\\'o\\'] - (*digitMap)[0] - (*digitMap)[2] - (*digitMap)[4] \\n    \\n    // \"h\" only shows up in \"three\", \"eight\"\\n    (*digitMap)[3] = (*letterMap)[\\'h\\'] - (*digitMap)[8]\\n    \\n    // \"f\" only shows up in \"four\", \"five\"\\n    (*digitMap)[5] = (*letterMap)[\\'f\\'] - (*digitMap)[4] \\n    \\n    // \"s\" only shows up in \"six\", \"seven\"\\n    (*digitMap)[7] = (*letterMap)[\\'s\\'] - (*digitMap)[6]\\n    \\n    // \"i\" only shows up in \"five\", \"six\", \"eight\", \"nine\"\\n    (*digitMap)[9] = (*letterMap)[\\'i\\'] - (*digitMap)[5] - (*digitMap)[6] - (*digitMap)[8]     \\n\\n}\\n\\n```\\n\\n---\\n\\n\\nReference:\\n\\n[1] [Python official docs about specialized dictionary Counter( ... )](https://docs.python.org/3/library/collections.html#collections.Counter)\\n\\n[2] [Golang official docs about dictionary map[]](https://blog.golang.org/maps)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n\\n        \\n        # ----------------------------------------------------------\\n        \\n        def mapping_rebuild( digit_occ_dict , char_occ_dict ):\\n            \\n            \\n            ## Rebuild the number and its occurrence from character frequency analysis\\n            \\n            \\n            # \"z\" only shows up in \"zero\"\\n            digit_occ_dict [0] = char_occ_dict[\\'z\\']\\n\\n            # \"w\" only shows up in \"two\"\\n            digit_occ_dict [2] = char_occ_dict[\\'w\\']\\n\\n            # \"u\" only shows up in \"four\"\\n            digit_occ_dict [4] = char_occ_dict[\\'u\\']\\n\\n            # \"x\" only shows up in \"six\"\\n            digit_occ_dict [6] = char_occ_dict[\\'x\\']\\n\\n            # \"g\" only shows up in \"eight\"\\n            digit_occ_dict [8] = char_occ_dict[\\'g\\']\\n\\n            # \"o\" only shows up in \"zero\", \"one\", \"two\", \"four\"\\n            digit_occ_dict [1] = char_occ_dict[\\'o\\'] - digit_occ_dict [0] - digit_occ_dict [2] - digit_occ_dict [4]\\n\\n            # \"h\" only shows up in \"three\", \"eight\"\\n            digit_occ_dict [3] = char_occ_dict[\\'h\\'] - digit_occ_dict [8]\\n\\n            # \"f\" only shows up in \"four\", \"five\"\\n            digit_occ_dict [5] = char_occ_dict[\\'f\\'] - digit_occ_dict [4]\\n\\n            # \"s\" only shows up in \"six\", \"seven\"\\n            digit_occ_dict [7] = char_occ_dict[\\'s\\'] - digit_occ_dict [6]\\n\\n            # \"i\" only shows up in \"five\", \"six\", \"eight\", \"nine\"\\n            digit_occ_dict [9] = char_occ_dict[\\'i\\'] - digit_occ_dict [5] - digit_occ_dict [6] - digit_occ_dict [8]\\n\\n            return\\n        # ----------------------------------------------------------\\n        \\n        ## dictionary of input s\\n        # key: ascii character\\n        # value: occurrence of ascii character\\n        char_occ_dict = Counter(s)\\n        \\n        ## dictionary\\n        # key: digit\\n        # value: occurrence of digit\\n        digit_occ_dict = defaultdict( int )\\n        \\n        # rebuild digit-occurrence mapping from input s and its char-occurrence mapping\\n        mapping_rebuild( digit_occ_dict , char_occ_dict)\\n        \\n        # rebuild digit string in ascending order\\n        digit_string = \"\".join( (str(digit) * digit_occ_dict [digit]) for digit in range(0, 10) )\\n        \\n        return digit_string\\n                \\n            \\n```\n```\\n\\nimport (\\n\\t\"strings\"\\n\\t\"strconv\"\\n)\\n\\nfunc originalDigits(s string) string {\\n    \\n    //// dictionary of input s\\n    // key: ascii character\\n    // value: occurrence of ascii character\\n    charOccDict := make( map[rune]int )\\n    \\n    for _, char := range s{\\n        charOccDict[char] += 1\\n    }\\n    \\n    //// dictionary\\n    // key: digit\\n    // value: occurrence of digit    \\n    digitOccDict := make( map[int]int )\\n    \\n    // rebuild digit-occurrence mapping from input s and its char-occurrence mapping\\n    mapping_rebuild( &digitOccDict, &charOccDict )\\n    \\n    \\n    // rebuild digit string in ascending order\\n    outputString := \"\"\\n    \\n    for digit := 0 ; digit <= 9 ; digit++{\\n     \\n        occurrence := digitOccDict[digit]\\n        outputString += strings.Repeat( strconv.Itoa(digit), occurrence)\\n    }\\n    \\n    return outputString\\n}\\n\\n\\nfunc mapping_rebuild( digitMap *map[int]int, letterMap *map[rune]int){\\n    // Rebuild the number and its occurrence from character frequency analysis\\n    \\n    // \"z\" only shows up in \"zero\"\\n    (*digitMap)[0] = (*letterMap)[\\'z\\']\\n    \\n    // \"w\" only shows up in \"two\"\\n    (*digitMap)[2] = (*letterMap)[\\'w\\']\\n    \\n    // \"u\" only shows up in \"four\"\\n    (*digitMap)[4] = (*letterMap)[\\'u\\']\\n    \\n    // \"x\" only shows up in \"six\"\\n    (*digitMap)[6] = (*letterMap)[\\'x\\']\\n    \\n    // \"g\" only shows up in \"eight\"\\n    (*digitMap)[8] = (*letterMap)[\\'g\\']\\n    \\n    // \"o\" only shows up in \"zero\", \"one\", \"two\", \"four\"\\n    (*digitMap)[1] = (*letterMap)[\\'o\\'] - (*digitMap)[0] - (*digitMap)[2] - (*digitMap)[4] \\n    \\n    // \"h\" only shows up in \"three\", \"eight\"\\n    (*digitMap)[3] = (*letterMap)[\\'h\\'] - (*digitMap)[8]\\n    \\n    // \"f\" only shows up in \"four\", \"five\"\\n    (*digitMap)[5] = (*letterMap)[\\'f\\'] - (*digitMap)[4] \\n    \\n    // \"s\" only shows up in \"six\", \"seven\"\\n    (*digitMap)[7] = (*letterMap)[\\'s\\'] - (*digitMap)[6]\\n    \\n    // \"i\" only shows up in \"five\", \"six\", \"eight\", \"nine\"\\n    (*digitMap)[9] = (*letterMap)[\\'i\\'] - (*digitMap)[5] - (*digitMap)[6] - (*digitMap)[8]     \\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131953,
                "title": "c-4ms-fastest-to-date-solution-explained-100-time-96-space",
                "content": "Great problem today! You might be tempted to use some graph-like approach to decide if, say, a \"f\" should go to compose a \"five\" or \"four\", but there is a smarter way around it.\\n\\nFor example `\\'z\\'`s are used only in `\"zero\"`s and `\\'x\\'` are used only `\"six\"`es; and after you remove `\"six\"`es, you know that the only `\\'s\\'`es left are in `\"seven\"`s; same with `\\'g\\'`: they are only in `eight`s and once you remove them, the only other `h`s left are in `three`; and once you remove them, the only `\\'r\\'`s left are in `\"four\"`s - and so on, you get the gist of it.\\n\\nNow, in order to code this logic down, we will declare a couple of support variables as `static constexpr`s:\\n* `digChars` will store all the unique letters and the matching numbers in pairs (their order reflects the logic states above: first unique letters and then going down removing only the ones that are now left as uniques and so on;\\n* `digWord` is an array containing the name of each number in the `0 - 9` range in letters.\\n\\nIn the main function, we will define 2 more arrays and one other variable:\\n* `digits` will store how many digits are actually present in our final solution - all elements set to `0`;\\n* `alpha` will store the frequency of each character (the array is sized to be `123` in order to avoid somehow expensive subtractions of `0` at each step) - all elements set to `0` again;\\n* `tot` will store the total number of characters in our response string (declare only later, to optimise).\\n\\nWe will then first of all populate `alpha`, iterating through each character `c` of `s` and increasing the matching cell by `1`.\\n\\nTime to actually figure out what numbers we have there next and for each element `d` in `digChars`, we will:\\n* assign the number of occurrences of its unique character `d.first` to `n`;\\n* increase `tot` by `n`;\\n* remove all the characters matching that digits from `alpha` (I know I might have optimised removing only needed characters, but it would have made little difference and made the code more complex, needing another array and less intuitive logic).\\n\\nNow, last steps and we will start compoising a result creating a string `res` already of the right size (`tot`) to avoid reallocations.\\n\\nWe will then loop with `i` from `0` to `9` and, while we still have any of that number to insert (`digits[i] > 0`), we will add that character to the next slot in the final result: `res[j++] = i + \\'0\\'`.\\n\\nOnce done, we can just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nstatic constexpr pair<char, int> digChars[10] = {{\\'z\\', 0}, {\\'w\\', 2}, {\\'x\\', 6}, {\\'s\\', 7}, {\\'g\\', 8}, {\\'h\\', 3}, {\\'v\\', 5}, {\\'f\\', 4}, {\\'o\\', 1}, {\\'e\\', 9}};\\n\\nstatic string digWord[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        // support variables\\n\\t\\tint digits[10], tot = 0, alpha[123] = {};\\n        // populating alpha\\n        for (char c: s) alpha[c]++;\\n        for (auto d: digChars) {\\n            // getting the number of matches\\n            int n = alpha[d.first];\\n            // updating digits with the number of matches\\n            digits[d.second] = n;\\n            // updating tot by the number of needed characters\\n            tot += n;\\n            // clearing up alpha accordingly\\n            for (char c: digWord[d.second]) alpha[c] -= n;\\n        }\\n        //  creating and populating res\\n        string res(tot, \\'*\\');\\n        for (int i = 0, j = 0; i < 10; i++) {\\n            while(digits[i]--) {\\n                res[j++] = i + \\'0\\';\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/992d2c4d-152e-4fbc-86f0-4a5024e0c65c_1616967433.9745965.png)\\n\\n\\nExtra goodie, variant to get you the solution with words - because, yes: I did it this morning and being half-asleep I just came up wtih a needlessly more complex logic \\uD83E\\uDD26\\u200D:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        // support variables\\n        int digits[10], tot = 0;\\n        char alpha[123] = {};\\n        // populating alpha\\n        for (char c: s) alpha[c]++;\\n        for (auto d: digChars) {\\n            // getting the number of matches\\n            int n = alpha[d.first];\\n            // updating digits with the number of matches\\n            digits[d.second] = n;\\n            // updating tot by the number of needed characters\\n            tot += n * digWord[d.second].size();\\n            // clearing up alpha accordingly\\n            for (char c: digWord[d.second]) alpha[c] -= n;\\n        }\\n        // creating and populating res\\n        string res(tot, \\'*\\');\\n        for (int i = 0, j = 0; i < 10; i++) {\\n            while(digits[i]--) {\\n                for (char c: digWord[i]) res[j++] = c;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics"
                ],
                "code": "```cpp\\nstatic constexpr pair<char, int> digChars[10] = {{\\'z\\', 0}, {\\'w\\', 2}, {\\'x\\', 6}, {\\'s\\', 7}, {\\'g\\', 8}, {\\'h\\', 3}, {\\'v\\', 5}, {\\'f\\', 4}, {\\'o\\', 1}, {\\'e\\', 9}};\\n\\nstatic string digWord[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        // support variables\\n\\t\\tint digits[10], tot = 0, alpha[123] = {};\\n        // populating alpha\\n        for (char c: s) alpha[c]++;\\n        for (auto d: digChars) {\\n            // getting the number of matches\\n            int n = alpha[d.first];\\n            // updating digits with the number of matches\\n            digits[d.second] = n;\\n            // updating tot by the number of needed characters\\n            tot += n;\\n            // clearing up alpha accordingly\\n            for (char c: digWord[d.second]) alpha[c] -= n;\\n        }\\n        //  creating and populating res\\n        string res(tot, \\'*\\');\\n        for (int i = 0, j = 0; i < 10; i++) {\\n            while(digits[i]--) {\\n                res[j++] = i + \\'0\\';\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        // support variables\\n        int digits[10], tot = 0;\\n        char alpha[123] = {};\\n        // populating alpha\\n        for (char c: s) alpha[c]++;\\n        for (auto d: digChars) {\\n            // getting the number of matches\\n            int n = alpha[d.first];\\n            // updating digits with the number of matches\\n            digits[d.second] = n;\\n            // updating tot by the number of needed characters\\n            tot += n * digWord[d.second].size();\\n            // clearing up alpha accordingly\\n            for (char c: digWord[d.second]) alpha[c] -= n;\\n        }\\n        // creating and populating res\\n        string res(tot, \\'*\\');\\n        for (int i = 0, j = 0; i < 10; i++) {\\n            while(digits[i]--) {\\n                for (char c: digWord[i]) res[j++] = c;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91192,
                "title": "short-matrix-solution",
                "content": "**Solution**\\n```\\ndef original_digits(s)\\n  require 'matrix'\\n  a = ('a'..'z').map { |c| \"zero one two three four five six seven eight nine\".split.map { |w| w.count(c) } }\\n  b = ('a'..'z').map { |c| s.count(c) }\\n  x = Matrix[*a].lup.solve(b)\\n  (0..9).map { |i| i.to_s * x[i] }.join\\nend\\n```\\n**Explanation**\\n\\nUsing Ruby's `Matrix` class to solve the system of equations. We have one equation for each letter. For example, consider the letter 'n'. If the unknown digits are x<sub>0</sub> zeros, x<sub>1</sub> ones, etc, then the letter 'n' appears x<sub>1</sub> + x<sub>7</sub> + 2x<sub>9</sub> times. Each \"one\" or \"seven\" contributes one 'n', each \"nine\" contributes two 'n', and the other digits don't contribute any 'n'. Now for example if the input is `s = \"owoztneoer\"` then we have one 'n' and thus we have the equation **x<sub>1</sub> + x<sub>7</sub> + 2x<sub>9</sub> = 1**. Doing this for all 26 letters gives us 26 equations which we can write as a matrix equation `Ax = b`.\\n\\n- `A` is the 26&times;10 matrix with a<sub>i,j</sub> telling how often the i-th alphabet letter appears in the j-th digit name.\\n- `b` is the vector of size 26 with b<sub>i</sub> telling how often the i-th alphabet letter appears in the given `s`.\\n- `x` is the vector of size 10 with x<sub>i</sub> telling how often the i-th digit is encoded in the given `s`.\\n\\n---\\n\\n**Alternatives**\\n\\nSince `A` is always the same (doesn't depend on `s`), we can precompute it so it doesn't get computed every time our function is called:\\n```\\nrequire 'matrix'\\nA = ('a'..'z').map { |c| \"zero one two three four five six seven eight nine\".split.map { |w| w.count(c) } }\\nSolve = Matrix[*A].lup.method(:solve)\\n\\ndef original_digits(s)\\n  x = Solve[('a'..'z').map { |c| s.count(c) }]\\n  (0..9).map { |i| i.to_s * x[i] }.join\\nend\\n```\\nCould even make the actual function a one-liner then:\\n```\\ndef original_digits(s)\\n  Solve[('a'..'z').map { |c| s.count(c) }][0..9].map.with_index { |x, i| i.to_s * x }.join\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef original_digits(s)\\n  require 'matrix'\\n  a = ('a'..'z').map { |c| \"zero one two three four five six seven eight nine\".split.map { |w| w.count(c) } }\\n  b = ('a'..'z').map { |c| s.count(c) }\\n  x = Matrix[*a].lup.solve(b)\\n  (0..9).map { |i| i.to_s * x[i] }.join\\nend\\n```\n```\\nrequire 'matrix'\\nA = ('a'..'z').map { |c| \"zero one two three four five six seven eight nine\".split.map { |w| w.count(c) } }\\nSolve = Matrix[*A].lup.method(:solve)\\n\\ndef original_digits(s)\\n  x = Solve[('a'..'z').map { |c| s.count(c) }]\\n  (0..9).map { |i| i.to_s * x[i] }.join\\nend\\n```\n```\\ndef original_digits(s)\\n  Solve[('a'..'z').map { |c| s.count(c) }][0..9].map.with_index { |x, i| i.to_s * x }.join\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 458655,
                "title": "linear-algebra-as-a-solution-o-n",
                "content": "One thing I like about leetcode is how there seems to be a problem for every sort of solution imaginable.\\n\\nE.g., if you want to practice solving an overdetermined system of linear equations, then this is the perfect problem.\\n\\nLet `M` be a 26x10 matrix and `M[r][c]` = (1 if the English word for number `c` contains letter `\\'a\\' + r`, otherwise 0 ) -- and  `r`, `c` both starting from 0 of course\\n\\nLet `A` be the total number of \\'a\\'s in the input, ..., `Z` be the total number of \\'z\\'s in the input, and let `x[0]` be the total number of 0s that could be reconstructued, ..., `x[9]` be the total number of 9s reconstructed, then one would end up with the following system of linear equations\\n\\n```\\n _                     _    _    _           _ _\\n| M[0][0]  ...  M[0][9] |  | x[0] |         | A |\\n| .                     |  |  .   |         | . |\\n| .                     |  |  .   |    =    | . |\\n| .                     |  |  .   |         | . |\\n| M[25][0] ... M[25][9] |  | x[9] |         | Z |\\n|_                     _|  |_    _|         |_ _|\\n```\\nand the goal is to solve for `x[0]`, ..., `x[9]`.\\n\\nBecause the system of equations is overdetermined (as it as 26 equations and 10 unknowns) there will be at most 1 solution, and given that the input can be reconstructed into valid words for numbers, there also must be at least 1 solution -- so taking both into account, one can conclude there will be exactly 1 solution.\\n\\nThe rest is just an exercise in linear algebra where one could get the following solution by solving for `x[0]`, ..., `x[9]` iteratively in some order, e.g.,:\\n\\n```\\nx[0] = Z          // \"[z]ero\"\\nx[2] = W      // \"t[w]o\"\\nx[4] = U      // \"fo[u]r\"\\nx[6] = X      // \"si[x]\"\\nx[8] = G      // \"ei[g]ht\"\\nx[1] = O - x[0] - x[2] - x[4]    // \"[o]ne\"\\nx[5] = F - x[4]  // \"[f]ive\"\\nx[7] = S - x[6]  // \"[s]even\"\\nx[3] = T - x[2] - x[8]  // \"[t]hree\"\\nx[9] = I - x[5] - x[6] - x[8]  // \"n[i]ne\"\\n```\\n\\nFinally, time complexity of this solution will be O(N) (i.e., proportional to size of input) because one needs to scan though input to count number of \\'a\\'s, number of \\'b\\'s, ..., number of \\'z\\'s (which are denoted as constants `A`, `B`, ..., `Z` above).",
                "solutionTags": [],
                "code": "```\\n _                     _    _    _           _ _\\n| M[0][0]  ...  M[0][9] |  | x[0] |         | A |\\n| .                     |  |  .   |         | . |\\n| .                     |  |  .   |    =    | . |\\n| .                     |  |  .   |         | . |\\n| M[25][0] ... M[25][9] |  | x[9] |         | Z |\\n|_                     _|  |_    _|         |_ _|\\n```\n```\\nx[0] = Z          // \"[z]ero\"\\nx[2] = W      // \"t[w]o\"\\nx[4] = U      // \"fo[u]r\"\\nx[6] = X      // \"si[x]\"\\nx[8] = G      // \"ei[g]ht\"\\nx[1] = O - x[0] - x[2] - x[4]    // \"[o]ne\"\\nx[5] = F - x[4]  // \"[f]ive\"\\nx[7] = S - x[6]  // \"[s]even\"\\nx[3] = T - x[2] - x[8]  // \"[t]hree\"\\nx[9] = I - x[5] - x[6] - x[8]  // \"n[i]ne\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131239,
                "title": "choose-numbers-having-unique-digits-first-easy-solution-explained",
                "content": "***Wrong Approach***\\n\\nA common mistake many would make is jumping to a similar code implementation as follows -\\n\\n```\\nstring originalDigits(string s) {\\n\\tstring digits[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\tint freq[26] = {0};\\n\\t// count frequency of each character in given string\\n\\tfor(auto& c : s) freq[c - \\'a\\']++;\\n\\tstring ans = \"\";\\n\\t// start from one till nine\\n\\t// if frequency is enough to produce the current word, then product it till possible\\n\\tfor(int i = 0; i <= 9; i++){\\n\\t\\tint MIN = INT_MAX;\\n\\t\\t // find min frequency of character among needed characters to product digit[i]\\n\\t\\tfor(auto& digit : digits[i]) MIN = min(MIN, freq[digit - \\'a\\']);  \\n\\t\\tfor(auto& digit : digits[i]) freq[digit - \\'a\\'] -= MIN; // subtract characters that will be used to product current digit\\n\\t\\tfor(int j = 0; j < MIN; j++) ans += to_string(i); // append MIN number of digits\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nUnfortunately, the above code doesn\\'t work. It prints `01113356` for the input **`\"zeroonetwothreefourfivesixseveneightnine\"`**, while the expected output is `0123456789`.\\n\\nThe observation we must make is that the string is always valid and **all characters must be used to produce the final output.**\\n\\n\\n----------\\n\\n***Correct Approach -***\\n\\nIn the correct approach, we must start with the digits whose words have atleast one unique character not occuring in others. The digits **`zero`** (z), **`two`**(w), **`four`**(u), **`six`**(x), **`eight`**(g) all even digits have unique characters. So, we must find the number of words that we can form for these digits first. Then we can choose the rest of the digits.\\n\\nThis approach will ensure that if a valid string consisting of out-of-order English representation of digits `0-9` is given, we will be using all the characters present in the string and product the correct output.\\n\\n```\\nstring originalDigits(string s) {\\n\\tstring ans = \"\", digits[] = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n\\tint freq[26] = {0}, occurence[10] = {0}, d[10] = {0,2,4,6,8,1,3,5,7,9}, MIN = 50000;\\n\\tfor(auto& c : s) freq[c - \\'a\\']++;        \\n\\tfor(int i = 0; i <= 9; i++, MIN = 50000){            \\n\\t\\tfor(auto& digit : digits[i]) MIN = min(MIN, freq[digit - \\'a\\']); \\n\\t\\tfor(auto& digit : digits[i]) freq[digit - \\'a\\'] -= MIN;\\n\\t\\toccurence[d[i]] = MIN;\\n\\t}\\n\\tfor(int i = 0; i <= 9; i++) for(int j = 0; j < occurence[i]; j++) ans += to_string(i);\\n\\treturn ans;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring originalDigits(string s) {\\n\\tstring digits[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\tint freq[26] = {0};\\n\\t// count frequency of each character in given string\\n\\tfor(auto& c : s) freq[c - \\'a\\']++;\\n\\tstring ans = \"\";\\n\\t// start from one till nine\\n\\t// if frequency is enough to produce the current word, then product it till possible\\n\\tfor(int i = 0; i <= 9; i++){\\n\\t\\tint MIN = INT_MAX;\\n\\t\\t // find min frequency of character among needed characters to product digit[i]\\n\\t\\tfor(auto& digit : digits[i]) MIN = min(MIN, freq[digit - \\'a\\']);  \\n\\t\\tfor(auto& digit : digits[i]) freq[digit - \\'a\\'] -= MIN; // subtract characters that will be used to product current digit\\n\\t\\tfor(int j = 0; j < MIN; j++) ans += to_string(i); // append MIN number of digits\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nstring originalDigits(string s) {\\n\\tstring ans = \"\", digits[] = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n\\tint freq[26] = {0}, occurence[10] = {0}, d[10] = {0,2,4,6,8,1,3,5,7,9}, MIN = 50000;\\n\\tfor(auto& c : s) freq[c - \\'a\\']++;        \\n\\tfor(int i = 0; i <= 9; i++, MIN = 50000){            \\n\\t\\tfor(auto& digit : digits[i]) MIN = min(MIN, freq[digit - \\'a\\']); \\n\\t\\tfor(auto& digit : digits[i]) freq[digit - \\'a\\'] -= MIN;\\n\\t\\toccurence[d[i]] = MIN;\\n\\t}\\n\\tfor(int i = 0; i <= 9; i++) for(int j = 0; j < occurence[i]; j++) ans += to_string(i);\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131237,
                "title": "reconstruct-original-digits-from-english-short-easy-w-explanation",
                "content": "***Wrong Approach***\\n\\nA common mistake many would make is jumping to a similar code implementation as follows -\\n\\n```\\nstring originalDigits(string s) {\\n\\tstring digits[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\tint freq[26] = {0};\\n\\t// count frequency of each character in given string\\n\\tfor(auto& c : s) freq[c - \\'a\\']++;\\n\\tstring ans = \"\";\\n\\t// start from one till nine\\n\\t// if frequency is enough to produce the current word, then product it till possible\\n\\tfor(int i = 0; i <= 9; i++){\\n\\t\\tint MIN = INT_MAX;\\n\\t\\t // find min frequency of character among needed characters to product digit[i]\\n\\t\\tfor(auto& digit : digits[i]) MIN = min(MIN, freq[digit - \\'a\\']);  \\n\\t\\tfor(auto& digit : digits[i]) freq[digit - \\'a\\'] -= MIN; // subtract characters that will be used to product current digit\\n\\t\\tfor(int j = 0; j < MIN; j++) ans += to_string(i); // append MIN number of digits\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nUnfortunately, the above code doesn\\'t work. It prints `01113356` for the input **`\"zeroonetwothreefourfivesixseveneightnine\"`**, while the expected output is `0123456789`.\\n\\nThe observation we must make is that the string is always valid and **all characters must be used to produce the final output.**\\n\\n\\n----------\\n\\n***Correct Approach -***\\n\\nIn the correct approach, we must start with the digits whose words have atleast one unique character not occuring in others. The digits **`zero`** (z), **`two`**(w), **`four`**(u), **`six`**(x), **`eight`**(g) all even digits have unique characters. So, we must find the number of words that we can form for these digits first. Then we can choose the rest of the digits.\\n\\nThis approach will ensure that if a valid string consisting of out-of-order English representation of digits `0-9` is given, we will be using all the characters present in the string and product the correct output.\\n\\n```\\nstring originalDigits(string s) {\\n\\tstring ans = \"\", digits[] = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n\\tint freq[26] = {0}, occurence[10] = {0}, d[10] = {0,2,4,6,8,1,3,5,7,9}, MIN = 50000;\\n\\tfor(auto& c : s) freq[c - \\'a\\']++;        \\n\\tfor(int i = 0; i <= 9; i++, MIN = 50000){            \\n\\t\\tfor(auto& digit : digits[i]) MIN = min(MIN, freq[digit - \\'a\\']); \\n\\t\\tfor(auto& digit : digits[i]) freq[digit - \\'a\\'] -= MIN;\\n\\t\\toccurence[d[i]] = MIN;\\n\\t}\\n\\tfor(int i = 0; i <= 9; i++) for(int j = 0; j < occurence[i]; j++) ans += to_string(i);\\n\\treturn ans;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring originalDigits(string s) {\\n\\tstring digits[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\tint freq[26] = {0};\\n\\t// count frequency of each character in given string\\n\\tfor(auto& c : s) freq[c - \\'a\\']++;\\n\\tstring ans = \"\";\\n\\t// start from one till nine\\n\\t// if frequency is enough to produce the current word, then product it till possible\\n\\tfor(int i = 0; i <= 9; i++){\\n\\t\\tint MIN = INT_MAX;\\n\\t\\t // find min frequency of character among needed characters to product digit[i]\\n\\t\\tfor(auto& digit : digits[i]) MIN = min(MIN, freq[digit - \\'a\\']);  \\n\\t\\tfor(auto& digit : digits[i]) freq[digit - \\'a\\'] -= MIN; // subtract characters that will be used to product current digit\\n\\t\\tfor(int j = 0; j < MIN; j++) ans += to_string(i); // append MIN number of digits\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nstring originalDigits(string s) {\\n\\tstring ans = \"\", digits[] = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n\\tint freq[26] = {0}, occurence[10] = {0}, d[10] = {0,2,4,6,8,1,3,5,7,9}, MIN = 50000;\\n\\tfor(auto& c : s) freq[c - \\'a\\']++;        \\n\\tfor(int i = 0; i <= 9; i++, MIN = 50000){            \\n\\t\\tfor(auto& digit : digits[i]) MIN = min(MIN, freq[digit - \\'a\\']); \\n\\t\\tfor(auto& digit : digits[i]) freq[digit - \\'a\\'] -= MIN;\\n\\t\\toccurence[d[i]] = MIN;\\n\\t}\\n\\tfor(int i = 0; i <= 9; i++) for(int j = 0; j < occurence[i]; j++) ans += to_string(i);\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131112,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let counts = s.as_bytes().iter().fold([0; 26], |mut acc, x| {\\n            acc[(x - b\\'a\\') as usize] += 1;\\n            acc\\n        });\\n        let mut answer = [0; 10];\\n        answer[0] = counts[(b\\'z\\' - b\\'a\\') as usize];\\n        answer[2] = counts[(b\\'w\\' - b\\'a\\') as usize];\\n        answer[4] = counts[(b\\'u\\' - b\\'a\\') as usize];\\n        answer[6] = counts[(b\\'x\\' - b\\'a\\') as usize];\\n        answer[8] = counts[(b\\'g\\' - b\\'a\\') as usize];\\n        answer[3] = counts[(b\\'h\\' - b\\'a\\') as usize] - answer[8];\\n        answer[5] = counts[(b\\'f\\' - b\\'a\\') as usize] - answer[4];\\n        answer[7] = counts[(b\\'s\\' - b\\'a\\') as usize] - answer[6];\\n        answer[1] = counts[(b\\'o\\' - b\\'a\\') as usize] - answer[0] - answer[2] - answer[4];\\n        answer[9] = counts[(b\\'i\\' - b\\'a\\') as usize] - answer[5] - answer[6] - answer[8];\\n        (0..10)\\n            .flat_map(|i| std::iter::repeat((i as u8 + b\\'0\\') as char).take(answer[i]))\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let counts = s.as_bytes().iter().fold([0; 26], |mut acc, x| {\\n            acc[(x - b\\'a\\') as usize] += 1;\\n            acc\\n        });\\n        let mut answer = [0; 10];\\n        answer[0] = counts[(b\\'z\\' - b\\'a\\') as usize];\\n        answer[2] = counts[(b\\'w\\' - b\\'a\\') as usize];\\n        answer[4] = counts[(b\\'u\\' - b\\'a\\') as usize];\\n        answer[6] = counts[(b\\'x\\' - b\\'a\\') as usize];\\n        answer[8] = counts[(b\\'g\\' - b\\'a\\') as usize];\\n        answer[3] = counts[(b\\'h\\' - b\\'a\\') as usize] - answer[8];\\n        answer[5] = counts[(b\\'f\\' - b\\'a\\') as usize] - answer[4];\\n        answer[7] = counts[(b\\'s\\' - b\\'a\\') as usize] - answer[6];\\n        answer[1] = counts[(b\\'o\\' - b\\'a\\') as usize] - answer[0] - answer[2] - answer[4];\\n        answer[9] = counts[(b\\'i\\' - b\\'a\\') as usize] - answer[5] - answer[6] - answer[8];\\n        (0..10)\\n            .flat_map(|i| std::iter::repeat((i as u8 + b\\'0\\') as char).take(answer[i]))\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269686,
                "title": "423-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an empty dictionary called char_counts to keep track of the count of each character in the input string s.\\n2. Iterate over each character c in the input string s.\\n3. For each character c, update its count in char_counts by either incrementing its count if it already exists in the dictionary or adding it to the dictionary with a count of 1.\\n4. Create an empty list called digit_counts of length 10 to keep track of the count of each digit in the final output.\\n5. Use the get method of char_counts with a default value of 0 to update the counts of digits 0, 2, 4, 6, and 8 in digit_counts based on the counts of their corresponding characters \\'z\\', \\'w\\', \\'u\\', \\'x\\', and \\'g\\' in char_counts.\\n6. Calculate the count of digit 1 in digit_counts by subtracting the counts of digits 0, 2, and 4 from the count of character \\'o\\' in char_counts.\\n7. Calculate the count of digit 3 in digit_counts by subtracting the count of digit 8 from the count of character \\'h\\' in char_counts.\\n8. Calculate the count of digit 5 in digit_counts by subtracting the count of digit 4 from the count of character \\'f\\' in char_counts.\\n9. Calculate the count of digit 7 in digit_counts by subtracting the count of digit 6 from the count of character \\'s\\' in char_counts.\\n10. Calculate the count of digit 9 in digit_counts by subtracting the counts of digits 5, 6, and 8 from the count of character \\'i\\' in char_counts.\\n11. Use a list comprehension to create a string that concatenates the digits in digit_counts based on their counts. Return this string as the final output.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        char_counts = {}\\n        for c in s:\\n            if c in char_counts:\\n                char_counts[c] += 1\\n            else:\\n                char_counts[c] = 1\\n                \\n        digit_counts = [0] * 10\\n        \\n        digit_counts[0] = char_counts.get(\\'z\\', 0)\\n        digit_counts[2] = char_counts.get(\\'w\\', 0)\\n        digit_counts[4] = char_counts.get(\\'u\\', 0)\\n        digit_counts[6] = char_counts.get(\\'x\\', 0)\\n        digit_counts[8] = char_counts.get(\\'g\\', 0)\\n        \\n        digit_counts[1] = char_counts.get(\\'o\\', 0) - digit_counts[0] - digit_counts[2] - digit_counts[4]\\n        digit_counts[3] = char_counts.get(\\'h\\', 0) - digit_counts[8]\\n        digit_counts[5] = char_counts.get(\\'f\\', 0) - digit_counts[4]\\n        digit_counts[7] = char_counts.get(\\'s\\', 0) - digit_counts[6]\\n        digit_counts[9] = char_counts.get(\\'i\\', 0) - digit_counts[5] - digit_counts[6] - digit_counts[8]\\n        \\n        return \\'\\'.join(str(i) * digit_counts[i] for i in range(10))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        char_counts = {}\\n        for c in s:\\n            if c in char_counts:\\n                char_counts[c] += 1\\n            else:\\n                char_counts[c] = 1\\n                \\n        digit_counts = [0] * 10\\n        \\n        digit_counts[0] = char_counts.get(\\'z\\', 0)\\n        digit_counts[2] = char_counts.get(\\'w\\', 0)\\n        digit_counts[4] = char_counts.get(\\'u\\', 0)\\n        digit_counts[6] = char_counts.get(\\'x\\', 0)\\n        digit_counts[8] = char_counts.get(\\'g\\', 0)\\n        \\n        digit_counts[1] = char_counts.get(\\'o\\', 0) - digit_counts[0] - digit_counts[2] - digit_counts[4]\\n        digit_counts[3] = char_counts.get(\\'h\\', 0) - digit_counts[8]\\n        digit_counts[5] = char_counts.get(\\'f\\', 0) - digit_counts[4]\\n        digit_counts[7] = char_counts.get(\\'s\\', 0) - digit_counts[6]\\n        digit_counts[9] = char_counts.get(\\'i\\', 0) - digit_counts[5] - digit_counts[6] - digit_counts[8]\\n        \\n        return \\'\\'.join(str(i) * digit_counts[i] for i in range(10))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918295,
                "title": "unique-characters-in-every-number-short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        unordered_map<char, int> m;\\n        for(char c : s) m[c]++;\\n\\n        string ans;\\n        vector<pair<pair<char, char>, string>> v = {{{\\'z\\', \\'0\\'}, \"zero\"}, {{\\'w\\', \\'2\\'}, \"two\"}, {{\\'u\\', \\'4\\'}, \"four\"}, \\n                                                    {{\\'x\\', \\'6\\'}, \"six\"}, {{\\'g\\', \\'8\\'}, \"eight\"}, {{\\'o\\', \\'1\\'}, \"one\"}, \\n                                                    {{\\'t\\', \\'3\\'}, \"three\"}, {{\\'f\\', \\'5\\'}, \"five\"}, {{\\'s\\', \\'7\\'}, \"seven\"}, \\n                                                    {{\\'i\\', \\'9\\'}, \"nine\"}};\\n        for(auto p : v) {\\n            int n = m[p.first.first];\\n            for(int i=0; i<n; i++) ans += p.first.second;\\n            for(char c : p.second) m[c] -= n;\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n/*\\nUnique & Single Characters\\n\\none, two, three, four, five, six, seven, eight, nine\\nz - zero\\nw - two\\nu - four\\nx - six\\ng - eight\\n\\none, three, five, seven, nine\\no - one\\nt - three\\nf - five\\ns - seven\\ni - nine\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        unordered_map<char, int> m;\\n        for(char c : s) m[c]++;\\n\\n        string ans;\\n        vector<pair<pair<char, char>, string>> v = {{{\\'z\\', \\'0\\'}, \"zero\"}, {{\\'w\\', \\'2\\'}, \"two\"}, {{\\'u\\', \\'4\\'}, \"four\"}, \\n                                                    {{\\'x\\', \\'6\\'}, \"six\"}, {{\\'g\\', \\'8\\'}, \"eight\"}, {{\\'o\\', \\'1\\'}, \"one\"}, \\n                                                    {{\\'t\\', \\'3\\'}, \"three\"}, {{\\'f\\', \\'5\\'}, \"five\"}, {{\\'s\\', \\'7\\'}, \"seven\"}, \\n                                                    {{\\'i\\', \\'9\\'}, \"nine\"}};\\n        for(auto p : v) {\\n            int n = m[p.first.first];\\n            for(int i=0; i<n; i++) ans += p.first.second;\\n            for(char c : p.second) m[c] -= n;\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n/*\\nUnique & Single Characters\\n\\none, two, three, four, five, six, seven, eight, nine\\nz - zero\\nw - two\\nu - four\\nx - six\\ng - eight\\n\\none, three, five, seven, nine\\no - one\\nt - three\\nf - five\\ns - seven\\ni - nine\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092055,
                "title": "c-o-n-time-complexity-o-1-space-soultion",
                "content": "\\n\\n\\n    string originalDigits(string s) {\\n       vector<int>num(10,0);\\n       vector<int>count(26,0);\\n\\t   \\n        for(auto c : s)\\n            count[c-\\'a\\']++;\\n        /*\\n         * zero: Only digit with z\\n         * two: Only digit with w\\n         * four: Only digit with u\\n         * six: Only digit with x\\n         * eight: Only digit with g\\n         */\\n\\t\\t \\n        // direcct calculation\\n\\t\\t\\n        num[0] = count[\\'z\\'-\\'a\\'];\\n        num[2] = count[\\'w\\'-\\'a\\'];\\n        num[4] = count[\\'u\\'-\\'a\\'];\\n        num[6] = count[\\'x\\'-\\'a\\'];\\n        num[8] = count[\\'g\\'-\\'a\\'];\\n\\t\\t\\n        //derived calculation\\n\\t\\t\\n        num[1] = count[\\'o\\'-\\'a\\'] - num[0] - num[2] - num[4];\\n        num[3] = count[\\'h\\'-\\'a\\'] - num[8];\\n        num[5] = count[\\'f\\'-\\'a\\'] - num[4];\\n        num[7] = count[\\'s\\'-\\'a\\'] - num[6];\\n        num[9] = count[\\'i\\'-\\'a\\'] - num[5] - num[6] - num[8];\\n        \\n        string res ;\\n        for(int i=0;i<10;i++){\\n            int c = num[i];\\n            while(c>0){\\n                res += to_string(i);\\n                c--;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "\\n\\n\\n    string originalDigits(string s) {\\n       vector<int>num(10,0);\\n       vector<int>count(26,0);\\n\\t   \\n        for(auto c : s)\\n            count[c-\\'a\\']++;\\n        /*\\n         * zero: Only digit with z\\n         * two: Only digit with w\\n         * four: Only digit with u\\n         * six: Only digit with x\\n         * eight: Only digit with g\\n         */\\n\\t\\t \\n        // direcct calculation\\n\\t\\t\\n        num[0] = count[\\'z\\'-\\'a\\'];\\n        num[2] = count[\\'w\\'-\\'a\\'];\\n        num[4] = count[\\'u\\'-\\'a\\'];\\n        num[6] = count[\\'x\\'-\\'a\\'];\\n        num[8] = count[\\'g\\'-\\'a\\'];\\n\\t\\t\\n        //derived calculation\\n\\t\\t\\n        num[1] = count[\\'o\\'-\\'a\\'] - num[0] - num[2] - num[4];\\n        num[3] = count[\\'h\\'-\\'a\\'] - num[8];\\n        num[5] = count[\\'f\\'-\\'a\\'] - num[4];\\n        num[7] = count[\\'s\\'-\\'a\\'] - num[6];\\n        num[9] = count[\\'i\\'-\\'a\\'] - num[5] - num[6] - num[8];\\n        \\n        string res ;\\n        for(int i=0;i<10;i++){\\n            int c = num[i];\\n            while(c>0){\\n                res += to_string(i);\\n                c--;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1131087,
                "title": "javascript-python-easy-to-understand",
                "content": "**javascript:**\\n```\\nvar originalDigits = function(s) {\\n    const arr = new Array(10).fill(0);\\n    for (const c of s) {\\n        if (c === \\'z\\') arr[0]++\\n        else if (c === \\'x\\') arr[6]++\\n        else if (c === \\'w\\') arr[2]++\\n        else if (c === \\'u\\') arr[4]++\\n        else if (c === \\'g\\') arr[8]++\\n        else if (c === \\'s\\') arr[7]++    //6, 7\\n        else if (c === \\'v\\') arr[5]++    //5, 7\\n        else if (c === \\'r\\') arr[3]++    //0, 3, 4\\n        else if (c === \\'o\\') arr[1]++    //0, 1, 2, 4\\n        else if (c === \\'i\\') arr[9]++    //5, 6, 8, 9\\n    }\\n    arr[7] -= arr[6];\\n    arr[5] -= arr[7];\\n    arr[3] -= arr[0] + arr[4];\\n    arr[1] -= arr[0] + arr[2] + arr[4];\\n    arr[9] -= arr[5] + arr[6] + arr[8];\\n    let res = \"\";\\n    for (let i = 0; i <=9; i++) {\\n        for (let j = 0; j < arr[i]; j++) {\\n            res += i;\\n        }\\n    }\\n    return res;\\n};\\n```\\n\\n\\n**Python:**\\n```\\nclass Solution(object):\\n    def originalDigits(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        arr = [0] *10\\n        map = {\\n            \\'z\\': [0],\\n            \\'x\\': [6],\\n            \\'w\\': [2],\\n            \\'u\\': [4],\\n            \\'g\\': [8],\\n            \\'s\\': [6, 7],\\n            \\'v\\': [7, 5],\\n            \\'r\\': [0, 4, 3],\\n            \\'o\\': [0, 2, 4, 1],\\n            \\'i\\': [5, 6, 8, 9]\\n        }\\n        for c in s:\\n            if c in map:\\n                arr[map[c][-1]] += 1\\n        for c in \\'svroi\\':\\n            arr[map[c][-1]] -= sum(arr[i] for i in map[c][:-1])\\n        return \\'\\'.join([str(i) * c for i, c in enumerate(arr) if c])\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar originalDigits = function(s) {\\n    const arr = new Array(10).fill(0);\\n    for (const c of s) {\\n        if (c === \\'z\\') arr[0]++\\n        else if (c === \\'x\\') arr[6]++\\n        else if (c === \\'w\\') arr[2]++\\n        else if (c === \\'u\\') arr[4]++\\n        else if (c === \\'g\\') arr[8]++\\n        else if (c === \\'s\\') arr[7]++    //6, 7\\n        else if (c === \\'v\\') arr[5]++    //5, 7\\n        else if (c === \\'r\\') arr[3]++    //0, 3, 4\\n        else if (c === \\'o\\') arr[1]++    //0, 1, 2, 4\\n        else if (c === \\'i\\') arr[9]++    //5, 6, 8, 9\\n    }\\n    arr[7] -= arr[6];\\n    arr[5] -= arr[7];\\n    arr[3] -= arr[0] + arr[4];\\n    arr[1] -= arr[0] + arr[2] + arr[4];\\n    arr[9] -= arr[5] + arr[6] + arr[8];\\n    let res = \"\";\\n    for (let i = 0; i <=9; i++) {\\n        for (let j = 0; j < arr[i]; j++) {\\n            res += i;\\n        }\\n    }\\n    return res;\\n};\\n```\n```\\nclass Solution(object):\\n    def originalDigits(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        arr = [0] *10\\n        map = {\\n            \\'z\\': [0],\\n            \\'x\\': [6],\\n            \\'w\\': [2],\\n            \\'u\\': [4],\\n            \\'g\\': [8],\\n            \\'s\\': [6, 7],\\n            \\'v\\': [7, 5],\\n            \\'r\\': [0, 4, 3],\\n            \\'o\\': [0, 2, 4, 1],\\n            \\'i\\': [5, 6, 8, 9]\\n        }\\n        for c in s:\\n            if c in map:\\n                arr[map[c][-1]] += 1\\n        for c in \\'svroi\\':\\n            arr[map[c][-1]] -= sum(arr[i] for i in map[c][:-1])\\n        return \\'\\'.join([str(i) * c for i, c in enumerate(arr) if c])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472311,
                "title": "c",
                "content": "```\\npublic string OriginalDigits(string s) {\\n\\tvar freqs = s.ToCharArray().GroupBy(c => c).ToDictionary(c => c.Key, c => c.Count());\\n\\tvar zero = Freq(freqs, \\'z\\');\\n\\tvar two = Freq(freqs, \\'w\\');\\n\\tvar four = Freq(freqs, \\'u\\');\\n\\tvar six = Freq(freqs, \\'x\\');\\n\\tvar eight = Freq(freqs, \\'g\\');\\n\\tvar three = Freq(freqs, \\'h\\') - eight;\\n\\tvar five = Freq(freqs, \\'f\\') - four;\\n\\tvar seven = Freq(freqs, \\'v\\') - five;\\n\\tvar one = Freq(freqs, \\'o\\') - (zero + two + four);\\n\\tvar nine = (Freq(freqs, \\'n\\') - (one + seven)) / 2;\\n\\tvar digs = new[] { zero, one, two, three, four, five, six, seven, eight, nine };\\n\\n\\tvar str = new StringBuilder();\\n\\tfor (var i = 0; i < digs.Length; i++)\\n\\t\\tfor (var j = 0; j < digs[i]; j++)\\n\\t\\t\\tstr.Append(i);\\n\\n\\treturn str.ToString();\\n\\n\\tint Freq(Dictionary<char, int> dict, char c) => dict.ContainsKey(c) ? dict[c] : 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string OriginalDigits(string s) {\\n\\tvar freqs = s.ToCharArray().GroupBy(c => c).ToDictionary(c => c.Key, c => c.Count());\\n\\tvar zero = Freq(freqs, \\'z\\');\\n\\tvar two = Freq(freqs, \\'w\\');\\n\\tvar four = Freq(freqs, \\'u\\');\\n\\tvar six = Freq(freqs, \\'x\\');\\n\\tvar eight = Freq(freqs, \\'g\\');\\n\\tvar three = Freq(freqs, \\'h\\') - eight;\\n\\tvar five = Freq(freqs, \\'f\\') - four;\\n\\tvar seven = Freq(freqs, \\'v\\') - five;\\n\\tvar one = Freq(freqs, \\'o\\') - (zero + two + four);\\n\\tvar nine = (Freq(freqs, \\'n\\') - (one + seven)) / 2;\\n\\tvar digs = new[] { zero, one, two, three, four, five, six, seven, eight, nine };\\n\\n\\tvar str = new StringBuilder();\\n\\tfor (var i = 0; i < digs.Length; i++)\\n\\t\\tfor (var j = 0; j < digs[i]; j++)\\n\\t\\t\\tstr.Append(i);\\n\\n\\treturn str.ToString();\\n\\n\\tint Freq(Dictionary<char, int> dict, char c) => dict.ContainsKey(c) ? dict[c] : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131165,
                "title": "python-simple",
                "content": "# Idea\\nCertain chars are unique to some strings, like \\'w\\' in \\'two\\' or \\'z\\' in \\'zero\\'. As we process the digits other chars become unique, for example \\'r\\' is unique to \\'three\\' after we\\'ve removed all \\'four\\'s and \\'zero\\'s. In python3 the dictionary is ordered by key insertion time by default, so the solution below works:\\n```\\ndef originalDigits(self, s: str) -> str:\\n\\tcnt = Counter(s)\\n\\tidchars = \\\\\\n\\t{\\n\\t\\t\\'w\\': (\\'two\\', \\'2\\'),\\n\\t\\t\\'u\\': (\\'four\\', \\'4\\'),\\n\\t\\t\\'x\\': (\\'six\\', \\'6\\'),\\n\\t\\t\\'f\\': (\\'five\\', \\'5\\'),\\n\\t\\t\\'z\\': (\\'zero\\', \\'0\\'),\\n\\t\\t\\'r\\': (\\'three\\', \\'3\\'), \\n\\t\\t\\'t\\': (\\'eight\\', \\'8\\'),\\n\\t\\t\\'s\\': (\\'seven\\', \\'7\\'),\\n\\t\\t\\'i\\': (\\'nine\\', \\'9\\'),\\n\\t\\t\\'n\\': (\\'one\\', \\'1\\')\\n\\t}\\n\\tdigits = []\\n\\tfor ch, (word, digit) in idchars.items():\\n\\t\\tdigit_count = cnt[ch]\\n\\t\\tdigits.append(digit * digit_count)\\n\\t\\tfor c in word: cnt[c] -= digit_count\\n\\treturn \\'\\'.join(sorted(digits))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef originalDigits(self, s: str) -> str:\\n\\tcnt = Counter(s)\\n\\tidchars = \\\\\\n\\t{\\n\\t\\t\\'w\\': (\\'two\\', \\'2\\'),\\n\\t\\t\\'u\\': (\\'four\\', \\'4\\'),\\n\\t\\t\\'x\\': (\\'six\\', \\'6\\'),\\n\\t\\t\\'f\\': (\\'five\\', \\'5\\'),\\n\\t\\t\\'z\\': (\\'zero\\', \\'0\\'),\\n\\t\\t\\'r\\': (\\'three\\', \\'3\\'), \\n\\t\\t\\'t\\': (\\'eight\\', \\'8\\'),\\n\\t\\t\\'s\\': (\\'seven\\', \\'7\\'),\\n\\t\\t\\'i\\': (\\'nine\\', \\'9\\'),\\n\\t\\t\\'n\\': (\\'one\\', \\'1\\')\\n\\t}\\n\\tdigits = []\\n\\tfor ch, (word, digit) in idchars.items():\\n\\t\\tdigit_count = cnt[ch]\\n\\t\\tdigits.append(digit * digit_count)\\n\\t\\tfor c in word: cnt[c] -= digit_count\\n\\treturn \\'\\'.join(sorted(digits))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2140645,
                "title": "python-straight-forward-clean-code",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        counters = Counter(s)\\n        \\n        digits = dict()\\n        \\n        digits[\\'0\\'] = counters[\\'z\\']\\n        digits[\\'2\\'] = counters[\\'w\\']\\n        digits[\\'4\\'] = counters[\\'u\\']\\n        digits[\\'6\\'] = counters[\\'x\\']\\n        digits[\\'8\\'] = counters[\\'g\\']\\n        digits[\\'3\\'] = counters[\\'h\\'] - digits[\\'8\\']\\n        digits[\\'5\\'] = counters[\\'f\\'] - digits[\\'4\\']\\n        digits[\\'7\\'] = counters[\\'s\\'] - digits[\\'6\\']\\n        digits[\\'9\\'] = counters[\\'i\\'] - digits[\\'5\\'] - digits[\\'6\\'] - digits[\\'8\\']\\n        digits[\\'1\\'] = counters[\\'n\\'] - digits[\\'7\\'] - 2 * digits[\\'9\\']\\n        \\n        result = [key * digits[key] for key in sorted(digits.keys())]\\n\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        counters = Counter(s)\\n        \\n        digits = dict()\\n        \\n        digits[\\'0\\'] = counters[\\'z\\']\\n        digits[\\'2\\'] = counters[\\'w\\']\\n        digits[\\'4\\'] = counters[\\'u\\']\\n        digits[\\'6\\'] = counters[\\'x\\']\\n        digits[\\'8\\'] = counters[\\'g\\']\\n        digits[\\'3\\'] = counters[\\'h\\'] - digits[\\'8\\']\\n        digits[\\'5\\'] = counters[\\'f\\'] - digits[\\'4\\']\\n        digits[\\'7\\'] = counters[\\'s\\'] - digits[\\'6\\']\\n        digits[\\'9\\'] = counters[\\'i\\'] - digits[\\'5\\'] - digits[\\'6\\'] - digits[\\'8\\']\\n        digits[\\'1\\'] = counters[\\'n\\'] - digits[\\'7\\'] - 2 * digits[\\'9\\']\\n        \\n        result = [key * digits[key] for key in sorted(digits.keys())]\\n\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983766,
                "title": "python3-easy-one-pass-solution-o-n",
                "content": "Based on the fact that all even numbers have unique characters, and after removing even numbers, all the odd numbers now also have unique characters.\\n\\n\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        c = Counter(s)\\n        d = {0:\\'zero\\', 1:\\'one\\', 2:\\'two\\', 3:\\'three\\', 4:\\'four\\', 5:\\'five\\', 6:\\'six\\', 7:\\'seven\\', 8:\\'eight\\', 9:\\'nine\\'}\\n        \\n        res = [\\'\\'] * 10\\n        for i in chain(range(0,10,2), range(1,10,2)):\\n            cur = Counter(d[i])\\n            if not cur - c:\\n                k = min(c[x] for x in cur)\\n                res[i] = str(i) * k\\n                for x in cur: c[x] -= k                  \\n\\n        return \\'\\'.join(res)",
                "solutionTags": [],
                "code": "class Solution:\\n    def originalDigits(self, s: str) -> str:\\n        c = Counter(s)\\n        d = {0:\\'zero\\', 1:\\'one\\', 2:\\'two\\', 3:\\'three\\', 4:\\'four\\', 5:\\'five\\', 6:\\'six\\', 7:\\'seven\\', 8:\\'eight\\', 9:\\'nine\\'}",
                "codeTag": "Java"
            },
            {
                "id": 3052323,
                "title": "fast-python-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the unique digits in the given string by counting the number of occurrences of each letter in the string and using that information to deduce the number of each digit.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a counter to count the number of occurrences of each letter in the string. We can then use this information to deduce the number of each digit by subtracting the number of occurrences of other letters that are used in the formation of that digit. For example, the number of occurrences of the letter \\'o\\' can be used to deduce the number of occurrences of the digit \\'1\\' and \\'0\\' since \\'1\\' and \\'0\\' both use the letter \\'o\\'. We can then construct the final string by concatenating the digit with the number of occurrences of that digit.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the length of the input string. We are iterating through the string once to count the occurrences of each letter and then again to construct the final string.\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe only need a fixed number of variables to store the occurrences of each digit and the counter.\\n# Code\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        from collections import Counter\\n        c = Counter(s)\\n        nums = [0] * 10\\n        nums[0] = c[\\'z\\']\\n        nums[2] = c[\\'w\\']\\n        nums[4] = c[\\'u\\']\\n        nums[6] = c[\\'x\\']\\n        nums[8] = c[\\'g\\']\\n        nums[1] = c[\\'o\\'] - nums[0] - nums[2] - nums[4]\\n        nums[3] = c[\\'h\\'] - nums[8]\\n        nums[5] = c[\\'f\\'] - nums[4]\\n        nums[7] = c[\\'s\\'] - nums[6]\\n        nums[9] = c[\\'i\\'] - nums[5] - nums[6] - nums[8]\\n        return \\'\\'.join(str(i) * n for i, n in enumerate(nums))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        from collections import Counter\\n        c = Counter(s)\\n        nums = [0] * 10\\n        nums[0] = c[\\'z\\']\\n        nums[2] = c[\\'w\\']\\n        nums[4] = c[\\'u\\']\\n        nums[6] = c[\\'x\\']\\n        nums[8] = c[\\'g\\']\\n        nums[1] = c[\\'o\\'] - nums[0] - nums[2] - nums[4]\\n        nums[3] = c[\\'h\\'] - nums[8]\\n        nums[5] = c[\\'f\\'] - nums[4]\\n        nums[7] = c[\\'s\\'] - nums[6]\\n        nums[9] = c[\\'i\\'] - nums[5] - nums[6] - nums[8]\\n        return \\'\\'.join(str(i) * n for i, n in enumerate(nums))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773641,
                "title": "very-very-easy-explained-faster-than-65-10-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> count(26);\\n        for(auto c: s){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        vector<int> nums(10);\\n        //         Unique cases \\n        nums[0] = count[\\'z\\' - \\'a\\'];\\n        nums[2] = count[\\'w\\' - \\'a\\'];\\n        nums[4] = count[\\'u\\' - \\'a\\'];\\n        nums[6] = count[\\'x\\' - \\'a\\'];\\n        nums[8] = count[\\'g\\' - \\'a\\'];\\n        //         Derived Cases\\n        nums[1] = count[\\'o\\' - \\'a\\'] - nums[0] -nums[2] - nums[4];\\n        nums[3] = count[\\'h\\' - \\'a\\'] - nums[8];\\n        nums[5] = count[\\'f\\' - \\'a\\'] - nums[4];\\n        nums[7] = count[\\'s\\' - \\'a\\'] - nums[6];\\n        nums[9] = count[\\'i\\' - \\'a\\'] - nums[5] - nums[6] - nums[8];\\n        //         Resultant String\\n        string str;\\n        for(int i =0; i < 10 ; i++){\\n            while(nums[i]--){\\n                str+= to_string(i);\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> count(26);\\n        for(auto c: s){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        vector<int> nums(10);\\n        //         Unique cases \\n        nums[0] = count[\\'z\\' - \\'a\\'];\\n        nums[2] = count[\\'w\\' - \\'a\\'];\\n        nums[4] = count[\\'u\\' - \\'a\\'];\\n        nums[6] = count[\\'x\\' - \\'a\\'];\\n        nums[8] = count[\\'g\\' - \\'a\\'];\\n        //         Derived Cases\\n        nums[1] = count[\\'o\\' - \\'a\\'] - nums[0] -nums[2] - nums[4];\\n        nums[3] = count[\\'h\\' - \\'a\\'] - nums[8];\\n        nums[5] = count[\\'f\\' - \\'a\\'] - nums[4];\\n        nums[7] = count[\\'s\\' - \\'a\\'] - nums[6];\\n        nums[9] = count[\\'i\\' - \\'a\\'] - nums[5] - nums[6] - nums[8];\\n        //         Resultant String\\n        string str;\\n        for(int i =0; i < 10 ; i++){\\n            while(nums[i]--){\\n                str+= to_string(i);\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740729,
                "title": "c-straightforward",
                "content": "```c++\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        int n=s.length();\\n        if(!n)return \"\";\\n        int num[]={0,2,4,6,8,1,3,5,7,9};\\n        string word[]={\"zero\",\"two\",\"four\",\"six\",\"eight\",\"one\",\"three\",\"five\",\"seven\",\"nine\"};\\n        char hint[]={\\'z\\',\\'w\\',\\'u\\',\\'x\\',\\'g\\',\\'o\\',\\'h\\',\\'f\\',\\'s\\',\\'i\\'};\\n        vector<int> cnt(26,0);\\n        string ans=\"\";\\n        for(auto it:s)cnt[it-\\'a\\']++;\\n        for(int i=0;i<=9;i++){\\n            int idx=hint[i]-\\'a\\';\\n            int count=cnt[idx];\\n            // cout<<\"i= \"<<i<<\" count=\"<<count<<endl;\\n            for(int j=0;j<word[i].length();j++)\\n                cnt[word[i][j]-\\'a\\']-=count;\\n            while(count--)\\n                ans+=to_string(num[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        int n=s.length();\\n        if(!n)return \"\";\\n        int num[]={0,2,4,6,8,1,3,5,7,9};\\n        string word[]={\"zero\",\"two\",\"four\",\"six\",\"eight\",\"one\",\"three\",\"five\",\"seven\",\"nine\"};\\n        char hint[]={\\'z\\',\\'w\\',\\'u\\',\\'x\\',\\'g\\',\\'o\\',\\'h\\',\\'f\\',\\'s\\',\\'i\\'};\\n        vector<int> cnt(26,0);\\n        string ans=\"\";\\n        for(auto it:s)cnt[it-\\'a\\']++;\\n        for(int i=0;i<=9;i++){\\n            int idx=hint[i]-\\'a\\';\\n            int count=cnt[idx];\\n            // cout<<\"i= \"<<i<<\" count=\"<<count<<endl;\\n            for(int j=0;j<word[i].length();j++)\\n                cnt[word[i][j]-\\'a\\']-=count;\\n            while(count--)\\n                ans+=to_string(num[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 255827,
                "title": "super-easy-beta-100-c",
                "content": "very simple solution:\\nhint:\\nalpha:   numbers contain this alpha\\ne: 0 1 3 5 7 8 9\\nf: 4 5\\ng: 8\\nh: 3 8\\ni:  5 6 8 9\\nn: 1 7 9\\no: 0 1 2 4\\nr: 0 3 4\\ns: 6 7\\nt: 2 3 8\\nu: 4\\nv: 5 7\\nw: 2\\nx: 6\\nz: 0\\n\\nAs the list shows, we can determin the number of 4s by the number of \\'u\\', 0s by the number of \\'z\\', 6s by \\'x\\' ...\\nwhen we know how many 4s there are, we can determin the nuber of 5s by the number of \\'f\\' and 4. \\nand so on ....\\n\\n\\n\\n    string originalDigits(string s) {\\n        vector<int> count(26, 0); \\n        for (auto c: s)\\n            count[c - \\'a\\'] ++;\\t\\n        vector<int> num(10, 0);\\n      \\n        num[0] = count[\\'z\\' - \\'a\\'];\\n        num[2] = count[\\'w\\' - \\'a\\'];\\n        num[4] = count[\\'u\\' - \\'a\\'];\\n        num[8] = count[\\'g\\' - \\'a\\'];\\n        num[5] = count[\\'f\\' - \\'a\\'] - num[4];\\n        num[7] = count[\\'v\\' - \\'a\\'] - num[5];\\n        num[3] = count[\\'t\\' - \\'a\\'] - num[2] - num[8];\\n        \\n        num[6] = count[\\'s\\' - \\'a\\'] - num[7];\\n        num[1] = count[\\'o\\' - \\'a\\'] - num[0] - num[2] - num[4];\\n        num[9] = count[\\'i\\' - \\'a\\'] - num[5] - num[6] - num[8];\\n        string ans = \"\";\\n        for (int i = 0; i < 10; i ++) {\\n            ans.append(num[i], \\'0\\' + i);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "very simple solution:\\nhint:\\nalpha:   numbers contain this alpha\\ne: 0 1 3 5 7 8 9\\nf: 4 5\\ng: 8\\nh: 3 8\\ni:  5 6 8 9\\nn: 1 7 9\\no: 0 1 2 4\\nr: 0 3 4\\ns: 6 7\\nt: 2 3 8\\nu: 4\\nv: 5 7\\nw: 2\\nx: 6\\nz: 0\\n\\nAs the list shows, we can determin the number of 4s by the number of \\'u\\', 0s by the number of \\'z\\', 6s by \\'x\\' ...\\nwhen we know how many 4s there are, we can determin the nuber of 5s by the number of \\'f\\' and 4. \\nand so on ....\\n\\n\\n\\n    string originalDigits(string s) {\\n        vector<int> count(26, 0); \\n        for (auto c: s)\\n            count[c - \\'a\\'] ++;\\t\\n        vector<int> num(10, 0);\\n      \\n        num[0] = count[\\'z\\' - \\'a\\'];\\n        num[2] = count[\\'w\\' - \\'a\\'];\\n        num[4] = count[\\'u\\' - \\'a\\'];\\n        num[8] = count[\\'g\\' - \\'a\\'];\\n        num[5] = count[\\'f\\' - \\'a\\'] - num[4];\\n        num[7] = count[\\'v\\' - \\'a\\'] - num[5];\\n        num[3] = count[\\'t\\' - \\'a\\'] - num[2] - num[8];\\n        \\n        num[6] = count[\\'s\\' - \\'a\\'] - num[7];\\n        num[1] = count[\\'o\\' - \\'a\\'] - num[0] - num[2] - num[4];\\n        num[9] = count[\\'i\\' - \\'a\\'] - num[5] - num[6] - num[8];\\n        string ans = \"\";\\n        for (int i = 0; i < 10; i ++) {\\n            ans.append(num[i], \\'0\\' + i);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 91233,
                "title": "jave-find-unique-char-in-each-number-and-remove",
                "content": "```\\npublic class Solution {\\n    public String originalDigits(String s) {\\n        int[] frequency = new int[26];\\n        for (char c : s.toCharArray()) {\\n            frequency[c - 'a']++;\\n        }\\n        List<Character> list = new ArrayList<>();\\n        removeDigit('z', '0', \"zero\", list, frequency);\\n        removeDigit('w', '2', \"two\", list, frequency);\\n        removeDigit('u', '4', \"four\", list, frequency);\\n        removeDigit('x', '6', \"six\", list, frequency);\\n        removeDigit('g', '8', \"eight\", list, frequency);\\n        removeDigit('o', '1', \"one\", list, frequency);\\n        removeDigit('h', '3', \"three\", list, frequency);\\n        removeDigit('f', '5', \"five\", list, frequency);\\n        removeDigit('s', '7', \"seven\", list, frequency);\\n        removeDigit('n', '9', \"nine\", list, frequency);\\n        \\n        Collections.sort(list);\\n        StringBuilder result = new StringBuilder();\\n        for (char c : list) {\\n            result.append(c);\\n        }\\n        return new String(result);\\n    }\\n    \\n    private void removeDigit(char symbol, char digit, String number, List<Character> list, int[] frequency) {\\n        while (frequency[symbol - 'a'] > 0) {\\n            list.add(digit);\\n            for (char c : number.toCharArray()) {\\n                frequency[c - 'a']--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String originalDigits(String s) {\\n        int[] frequency = new int[26];\\n        for (char c : s.toCharArray()) {\\n            frequency[c - 'a']++;\\n        }\\n        List<Character> list = new ArrayList<>();\\n        removeDigit('z', '0', \"zero\", list, frequency);\\n        removeDigit('w', '2', \"two\", list, frequency);\\n        removeDigit('u', '4', \"four\", list, frequency);\\n        removeDigit('x', '6', \"six\", list, frequency);\\n        removeDigit('g', '8', \"eight\", list, frequency);\\n        removeDigit('o', '1', \"one\", list, frequency);\\n        removeDigit('h', '3', \"three\", list, frequency);\\n        removeDigit('f', '5', \"five\", list, frequency);\\n        removeDigit('s', '7', \"seven\", list, frequency);\\n        removeDigit('n', '9', \"nine\", list, frequency);\\n        \\n        Collections.sort(list);\\n        StringBuilder result = new StringBuilder();\\n        for (char c : list) {\\n            result.append(c);\\n        }\\n        return new String(result);\\n    }\\n    \\n    private void removeDigit(char symbol, char digit, String number, List<Character> list, int[] frequency) {\\n        while (frequency[symbol - 'a'] > 0) {\\n            list.add(digit);\\n            for (char c : number.toCharArray()) {\\n                frequency[c - 'a']--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91214,
                "title": "stupid-but-easy-understanding-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> res(10, 0);\\n        vector<int> cache(26, 0);\\n        for (auto ch : s) \\n            cache[ch - 'a']++;\\n        res[0] = cache['z' - 'a'];\\n        res[2] = cache['w' - 'a'];\\n        res[4] = cache['u' - 'a'];\\n        res[6] = cache['x' - 'a'];\\n        res[8] = cache['g' - 'a'];\\n        res[3] = cache['h' - 'a'] - res[8];\\n        res[7] = cache['s' - 'a'] - res[6];\\n        res[5] = cache['v' - 'a'] - res[7];\\n        res[1] = cache['o' - 'a'] - (res[0] + res[2] + res[4]);\\n        res[9] = (cache['n' - 'a'] - (res[1] + res[7])) / 2;\\n        string str = \"\";\\n        for (int i = 0; i < 10; i++) \\n            if (res[i]) \\n                str += string(res[i], i + '0');\\n        return str;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> res(10, 0);\\n        vector<int> cache(26, 0);\\n        for (auto ch : s) \\n            cache[ch - 'a']++;\\n        res[0] = cache['z' - 'a'];\\n        res[2] = cache['w' - 'a'];\\n        res[4] = cache['u' - 'a'];\\n        res[6] = cache['x' - 'a'];\\n        res[8] = cache['g' - 'a'];\\n        res[3] = cache['h' - 'a'] - res[8];\\n        res[7] = cache['s' - 'a'] - res[6];\\n        res[5] = cache['v' - 'a'] - res[7];\\n        res[1] = cache['o' - 'a'] - (res[0] + res[2] + res[4]);\\n        res[9] = (cache['n' - 'a'] - (res[1] + res[7])) / 2;\\n        string str = \"\";\\n        for (int i = 0; i < 10; i++) \\n            if (res[i]) \\n                str += string(res[i], i + '0');\\n        return str;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332819,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S)\\n     {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) \\n        {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++)\\n         {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S)\\n     {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) \\n        {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++)\\n         {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911174,
                "title": "easy-c-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int z=0,w=0,u=0,f=0,x=0,g=0;\\n        if(mp.find(\\'z\\')!=mp.end())\\n        {\\n            z=mp[\\'z\\'];\\n            for(int i=0;i<z;i++)\\n            {\\n                ans.push_back(\\'0\\');\\n            }\\n        }\\n        if(mp.find(\\'w\\')!=mp.end())\\n        {\\n            w=mp[\\'w\\'];\\n            for(int i=0;i<w;i++)\\n            {\\n                ans.push_back(\\'2\\');\\n            }\\n        }\\n        if(mp.find(\\'u\\')!=mp.end())\\n        {\\n            u=mp[\\'u\\'];\\n            for(int i=0;i<u;i++)\\n            {\\n                ans.push_back(\\'4\\');\\n            }\\n        }\\n        if(mp.find(\\'x\\')!=mp.end())\\n        {\\n            x=mp[\\'x\\'];\\n            for(int i=0;i<x;i++)\\n            {\\n                ans.push_back(\\'6\\');\\n            }\\n        }\\n        if(mp.find(\\'g\\')!=mp.end())\\n        {\\n            g=mp[\\'g\\'];\\n            for(int i=0;i<g;i++)\\n            {\\n                ans.push_back(\\'8\\');\\n            }\\n        }\\n        if(mp.find(\\'f\\')!=mp.end())\\n        {\\n            f=mp[\\'f\\']-u;\\n            for(int i=0;i<f;i++)\\n            {\\n                ans.push_back(\\'5\\');\\n            }\\n        }\\n        if(mp.find(\\'o\\')!=mp.end())\\n        {\\n            int t=mp[\\'o\\']-(z+u+w);\\n            for(int i=0;i<t;i++)\\n            {\\n                ans.push_back(\\'1\\');\\n            }\\n        }\\n        if(mp.find(\\'r\\')!=mp.end())\\n        {\\n            int r=mp[\\'r\\']-(u+z);\\n            for(int i=0;i<r;i++)\\n            {\\n                ans.push_back(\\'3\\');\\n            }\\n        }\\n        if(mp.find(\\'s\\')!=mp.end())\\n        {\\n            int s=mp[\\'s\\']-x;\\n            for(int i=0;i<s;i++)\\n            {\\n                ans.push_back(\\'7\\');\\n            }\\n        }\\n        if(mp.find(\\'i\\')!=mp.end())\\n        {\\n            int i=mp[\\'i\\']-(x+f+g);\\n            for(int k=0;k<i;k++)\\n            {\\n                ans.push_back(\\'9\\');\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int z=0,w=0,u=0,f=0,x=0,g=0;\\n        if(mp.find(\\'z\\')!=mp.end())\\n        {\\n            z=mp[\\'z\\'];\\n            for(int i=0;i<z;i++)\\n            {\\n                ans.push_back(\\'0\\');\\n            }\\n        }\\n        if(mp.find(\\'w\\')!=mp.end())\\n        {\\n            w=mp[\\'w\\'];\\n            for(int i=0;i<w;i++)\\n            {\\n                ans.push_back(\\'2\\');\\n            }\\n        }\\n        if(mp.find(\\'u\\')!=mp.end())\\n        {\\n            u=mp[\\'u\\'];\\n            for(int i=0;i<u;i++)\\n            {\\n                ans.push_back(\\'4\\');\\n            }\\n        }\\n        if(mp.find(\\'x\\')!=mp.end())\\n        {\\n            x=mp[\\'x\\'];\\n            for(int i=0;i<x;i++)\\n            {\\n                ans.push_back(\\'6\\');\\n            }\\n        }\\n        if(mp.find(\\'g\\')!=mp.end())\\n        {\\n            g=mp[\\'g\\'];\\n            for(int i=0;i<g;i++)\\n            {\\n                ans.push_back(\\'8\\');\\n            }\\n        }\\n        if(mp.find(\\'f\\')!=mp.end())\\n        {\\n            f=mp[\\'f\\']-u;\\n            for(int i=0;i<f;i++)\\n            {\\n                ans.push_back(\\'5\\');\\n            }\\n        }\\n        if(mp.find(\\'o\\')!=mp.end())\\n        {\\n            int t=mp[\\'o\\']-(z+u+w);\\n            for(int i=0;i<t;i++)\\n            {\\n                ans.push_back(\\'1\\');\\n            }\\n        }\\n        if(mp.find(\\'r\\')!=mp.end())\\n        {\\n            int r=mp[\\'r\\']-(u+z);\\n            for(int i=0;i<r;i++)\\n            {\\n                ans.push_back(\\'3\\');\\n            }\\n        }\\n        if(mp.find(\\'s\\')!=mp.end())\\n        {\\n            int s=mp[\\'s\\']-x;\\n            for(int i=0;i<s;i++)\\n            {\\n                ans.push_back(\\'7\\');\\n            }\\n        }\\n        if(mp.find(\\'i\\')!=mp.end())\\n        {\\n            int i=mp[\\'i\\']-(x+f+g);\\n            for(int k=0;k<i;k++)\\n            {\\n                ans.push_back(\\'9\\');\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995547,
                "title": "java-c-python-javascript-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}, CHARS = {25,22,20,23,6,5,18,7,8,14};\\n    static final int[][] REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\n    public String originalDigits(String S) {\\n        int[] fmap = new int[26], ans = new int[10];\\n        char[] SCA = S.toCharArray();\\n        for (char c : SCA) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = 0; j < ans[i]; j++)\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S) {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nDIGITS = [\\n    [0,\\'z\\',[]],\\n    [2,\\'w\\',[]],\\n    [4,\\'u\\',[]],\\n    [6,\\'x\\',[]],\\n    [8,\\'g\\',[]],\\n    [5,\\'f\\',[4]],\\n    [7,\\'s\\',[6]],\\n    [3,\\'h\\',[8]],\\n    [9,\\'i\\',[6,8,5]],\\n    [1,\\'o\\',[0,2,4]]\\n]\\nclass Solution:\\n    def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst DIGITS = [\\n    [\"0\",25,[14]],\\n    [\"2\",22,[14]],\\n    [\"4\",20,[5,14]],\\n    [\"6\",23,[18,8]],\\n    [\"8\",6,[8,7]],\\n    [\"5\",5,[8]],\\n    [\"7\",18,[]],\\n    [\"3\",7,[]],\\n    [\"9\",8,[]],\\n    [\"1\",14,[]]\\n]\\nvar originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func originalDigits(_ s: String) -> String {\\n        let s = Array(s).map({ Int($0.asciiValue ?? 97) - 97 }), alphabet = 26, digits = 10\\n        var a = [Int](repeating: 0, count: alphabet), d = [Int](repeating: 0, count: digits), result = [Int]()\\n        for char in s { a[char] += 1 } // count all characters in source string\\n\\t\\t// z is unique char, count all zero\\n        while a[25] > 0 { d[0] += 1; a[25] -= 1; a[4] -= 1; a[17] -= 1; a[14] -= 1 }\\n\\t\\t// w is unique char, count all two\\n        while a[22] > 0 { d[2] += 1; a[19] -= 1; a[22] -= 1; a[14] -= 1 }\\n\\t\\t// u is unique char, count all four\\n        while a[20] > 0 { d[4] += 1; a[5] -= 1; a[14] -= 1; a[20] -= 1; a[17] -= 1 }\\n\\t\\t// x is unique char, count all six\\n        while a[23] > 0 { d[6] += 1; a[18] -= 1; a[8] -= 1; a[23] -= 1 }\\n\\t\\t// g is unique char, count all eight\\n        while a[6] > 0 { d[8] += 1; a[4] -= 1; a[8] -= 1; a[6] -= 1; a[7] -= 1; a[19] -= 1 }\\n\\t\\t// now r is unique char, count all three\\n        while a[17] > 0 { d[3] += 1; a[19] -= 1; a[7] -= 1; a[17] -= 1; a[4] -= 2 }\\n\\t\\t// now f is unique char, count all five\\n        while a[5] > 0 { d[5] += 1; a[5] -= 1; a[8] -= 1; a[21] -= 1; a[4] -= 1 }\\n\\t\\t// now s is unique char, count all seven\\n        while a[18] > 0 { d[7] += 1; a[18] -= 1; a[4] -= 2; a[21] -= 1; a[13] -= 1 }\\n\\t\\t// now o is unique char, count all one\\n        while a[14] > 0 { d[1] += 1; a[14] -= 1; a[13] -= 1; a[4] -= 1 }\\n\\t\\t// now i is unique char, count all nine\\n        while a[8] > 0 { d[9] += 1; a[13] -= 2; a[8] -= 1; a[4] -= 1 }\\n\\t\\t// make result\\n        for i in 0..<digits { for j in 0..<d[i] { result.append(i) } }\\n        return result.map({ \"\\\\($0)\" }).joined(separator: \"\")\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}, CHARS = {25,22,20,23,6,5,18,7,8,14};\\n    static final int[][] REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\n    public String originalDigits(String S) {\\n        int[] fmap = new int[26], ans = new int[10];\\n        char[] SCA = S.toCharArray();\\n        for (char c : SCA) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = 0; j < ans[i]; j++)\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S) {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nDIGITS = [\\n    [0,\\'z\\',[]],\\n    [2,\\'w\\',[]],\\n    [4,\\'u\\',[]],\\n    [6,\\'x\\',[]],\\n    [8,\\'g\\',[]],\\n    [5,\\'f\\',[4]],\\n    [7,\\'s\\',[6]],\\n    [3,\\'h\\',[8]],\\n    [9,\\'i\\',[6,8,5]],\\n    [1,\\'o\\',[0,2,4]]\\n]\\nclass Solution:\\n    def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```\n```\\n```\n```\\n```\n```\\nconst DIGITS = [\\n    [\"0\",25,[14]],\\n    [\"2\",22,[14]],\\n    [\"4\",20,[5,14]],\\n    [\"6\",23,[18,8]],\\n    [\"8\",6,[8,7]],\\n    [\"5\",5,[8]],\\n    [\"7\",18,[]],\\n    [\"3\",7,[]],\\n    [\"9\",8,[]],\\n    [\"1\",14,[]]\\n]\\nvar originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func originalDigits(_ s: String) -> String {\\n        let s = Array(s).map({ Int($0.asciiValue ?? 97) - 97 }), alphabet = 26, digits = 10\\n        var a = [Int](repeating: 0, count: alphabet), d = [Int](repeating: 0, count: digits), result = [Int]()\\n        for char in s { a[char] += 1 } // count all characters in source string\\n\\t\\t// z is unique char, count all zero\\n        while a[25] > 0 { d[0] += 1; a[25] -= 1; a[4] -= 1; a[17] -= 1; a[14] -= 1 }\\n\\t\\t// w is unique char, count all two\\n        while a[22] > 0 { d[2] += 1; a[19] -= 1; a[22] -= 1; a[14] -= 1 }\\n\\t\\t// u is unique char, count all four\\n        while a[20] > 0 { d[4] += 1; a[5] -= 1; a[14] -= 1; a[20] -= 1; a[17] -= 1 }\\n\\t\\t// x is unique char, count all six\\n        while a[23] > 0 { d[6] += 1; a[18] -= 1; a[8] -= 1; a[23] -= 1 }\\n\\t\\t// g is unique char, count all eight\\n        while a[6] > 0 { d[8] += 1; a[4] -= 1; a[8] -= 1; a[6] -= 1; a[7] -= 1; a[19] -= 1 }\\n\\t\\t// now r is unique char, count all three\\n        while a[17] > 0 { d[3] += 1; a[19] -= 1; a[7] -= 1; a[17] -= 1; a[4] -= 2 }\\n\\t\\t// now f is unique char, count all five\\n        while a[5] > 0 { d[5] += 1; a[5] -= 1; a[8] -= 1; a[21] -= 1; a[4] -= 1 }\\n\\t\\t// now s is unique char, count all seven\\n        while a[18] > 0 { d[7] += 1; a[18] -= 1; a[4] -= 2; a[21] -= 1; a[13] -= 1 }\\n\\t\\t// now o is unique char, count all one\\n        while a[14] > 0 { d[1] += 1; a[14] -= 1; a[13] -= 1; a[4] -= 1 }\\n\\t\\t// now i is unique char, count all nine\\n        while a[8] > 0 { d[9] += 1; a[13] -= 2; a[8] -= 1; a[4] -= 1 }\\n\\t\\t// make result\\n        for i in 0..<digits { for j in 0..<d[i] { result.append(i) } }\\n        return result.map({ \"\\\\($0)\" }).joined(separator: \"\")\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817500,
                "title": "pseudoinverse-using-numpy",
                "content": "Assuming that the solution **exists and is unique**, we can find the number of occurrences of each character using linear algebra.\\n\\nFirst, construct an `15x10` array `A` where the `d`-th column of `A` records the frequency of occurence of every letter in the string representation of `d`. We do this for all `10` numbers (hence `10` columns), and there are `15` unique letters. Note that which row represents which letter must be consistent across all columns.\\n\\nNext, using the same mapping from row index to letter (as used when filling in the rows of `A`), create a 15-dimensional vector `b` that records the frequency of occurrence of each letter in `s`.\\n\\nUsing the language of linear algebra, the goal of finding the correct number of occurrences of each digit so that the frequencies of letters match that given in `b` is nothing but finding an vector `x` so that `Ax=b`. This has the solution of `x=Ub` where `U` is the pseudo-inverse of `A` (defined through SVD).\\n\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        chars = sorted(list(set(\\'zeroonetwothreefourfivesixseveneightnine\\')))\\n        m = {0:\\'zero\\', 1:\\'one\\', 2:\\'two\\', 3:\\'three\\', 4:\\'four\\', 5:\\'five\\',\\n             6:\\'six\\', 7:\\'seven\\', 8:\\'eight\\', 9:\\'nine\\'}\\n        \\n        cmap = {chars[i]:i for i in range(len(chars))}  # Mapping from character to row index\\n        \\n        A = np.zeros((len(chars), 10))\\n        for d in range(10):\\n            srep = m[d]\\n            for c in srep:\\n                A[cmap[c], d] += 1\\n        \\n        b = np.zeros(len(chars))\\n        for c in s:\\n            b[cmap[c]] += 1\\n            \\n        v = np.round(np.linalg.pinv(A) @ b)\\n        res = \\'\\'\\n        for d in range(10):\\n            res += str(d) * int(v[d])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```python\\nimport numpy as np\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        chars = sorted(list(set(\\'zeroonetwothreefourfivesixseveneightnine\\')))\\n        m = {0:\\'zero\\', 1:\\'one\\', 2:\\'two\\', 3:\\'three\\', 4:\\'four\\', 5:\\'five\\',\\n             6:\\'six\\', 7:\\'seven\\', 8:\\'eight\\', 9:\\'nine\\'}\\n        \\n        cmap = {chars[i]:i for i in range(len(chars))}  # Mapping from character to row index\\n        \\n        A = np.zeros((len(chars), 10))\\n        for d in range(10):\\n            srep = m[d]\\n            for c in srep:\\n                A[cmap[c], d] += 1\\n        \\n        b = np.zeros(len(chars))\\n        for c in s:\\n            b[cmap[c]] += 1\\n            \\n        v = np.round(np.linalg.pinv(A) @ b)\\n        res = \\'\\'\\n        for d in range(10):\\n            res += str(d) * int(v[d])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230192,
                "title": "c-check-the-presence-of-digits-in-a-specific-order",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        string number_to_spelling[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\",\\n                                         \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n        int char_count[26] = {0};\\n        for (const auto& c: s) char_count[c - \\'a\\']++;\\n        vector<pair<int, int>> order{{\\'z\\', 0}, {\\'w\\', 2}, {\\'u\\', 4}, {\\'x\\', 6}, {\\'g\\', 8},\\n                                     {\\'o\\', 1}, {\\'t\\', 3}, {\\'f\\', 5}, {\\'s\\', 7}, {\\'e\\', 9}};\\n        int number_count[10] = {0};\\n        for (const auto& e: order) {\\n            int number = e.second;\\n            auto count = char_count[e.first - \\'a\\'];\\n            for (const auto& c: number_to_spelling[number]) {\\n                char_count[c - \\'a\\'] -= count;\\n            }\\n            number_count[number] = count;\\n        }\\n        string result;\\n        for (int i = 0; i < 10; i++) {\\n            while(number_count[i]--) {\\n                result.push_back(i + \\'0\\');\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        string number_to_spelling[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\",\\n                                         \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n        int char_count[26] = {0};\\n        for (const auto& c: s) char_count[c - \\'a\\']++;\\n        vector<pair<int, int>> order{{\\'z\\', 0}, {\\'w\\', 2}, {\\'u\\', 4}, {\\'x\\', 6}, {\\'g\\', 8},\\n                                     {\\'o\\', 1}, {\\'t\\', 3}, {\\'f\\', 5}, {\\'s\\', 7}, {\\'e\\', 9}};\\n        int number_count[10] = {0};\\n        for (const auto& e: order) {\\n            int number = e.second;\\n            auto count = char_count[e.first - \\'a\\'];\\n            for (const auto& c: number_to_spelling[number]) {\\n                char_count[c - \\'a\\'] -= count;\\n            }\\n            number_count[number] = count;\\n        }\\n        string result;\\n        for (int i = 0; i < 10; i++) {\\n            while(number_count[i]--) {\\n                result.push_back(i + \\'0\\');\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131735,
                "title": "c-i-have-written-the-biggest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> A(26,0);\\n        for(auto i:s){\\n            A[i-\\'a\\']+=1;\\n        }\\n        int e=0;\\n        vector<int> ans;\\n        // simple checking\\n        if(A[\\'z\\'-\\'a\\']>0){\\n            e=A[\\'z\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n      \\n                A[\\'z\\'-\\'a\\']--;\\n                A[\\'e\\'-\\'a\\']--;\\n                A[\\'r\\'-\\'a\\']--;\\n                A[\\'o\\'-\\'a\\']--;\\n                ans.push_back(0);\\n            }\\n        }\\n        if(A[\\'w\\'-\\'a\\']>0){\\n            e=A[\\'w\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n                \\n                A[\\'t\\'-\\'a\\']--;\\n                A[\\'w\\'-\\'a\\']--;\\n                A[\\'o\\'-\\'a\\']--;\\n                ans.push_back(2);\\n            }\\n        }\\n        cout<<A[\\'u\\'-\\'a\\'];\\n        if(A[\\'u\\'-\\'a\\']>0){\\n            e=A[\\'u\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n              \\n                A[\\'f\\'-\\'a\\']--;\\n                A[\\'o\\'-\\'a\\']--;\\n                A[\\'u\\'-\\'a\\']--;\\n                A[\\'r\\'-\\'a\\']--;\\n                ans.push_back(4);\\n            }\\n        }\\n        if(A[\\'x\\'-\\'a\\']>0){\\n            e=A[\\'x\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n                \\n                A[\\'s\\'-\\'a\\']--;\\n                A[\\'i\\'-\\'a\\']--;\\n                A[\\'x\\'-\\'a\\']--;\\n                ans.push_back(6);\\n            }\\n        }\\n        if(A[\\'g\\'-\\'a\\']>0){\\n            e=A[\\'g\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n               \\n                A[\\'e\\'-\\'a\\']--;\\n                A[\\'i\\'-\\'a\\']--;\\n                A[\\'g\\'-\\'a\\']--;\\n                A[\\'h\\'-\\'a\\']--;\\n                A[\\'t\\'-\\'a\\']--;\\n                ans.push_back(8);\\n            }\\n        }\\n        \\n        if(A[\\'s\\'-\\'a\\']>0 ){\\n            e=A[\\'s\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n                \\n                A[\\'s\\'-\\'a\\']--;\\n                A[\\'e\\'-\\'a\\']--;\\n                A[\\'v\\'-\\'a\\']--;\\n                A[\\'e\\'-\\'a\\']--;\\n                A[\\'n\\'-\\'a\\']--;\\n                ans.push_back(7);\\n            }\\n        }\\n        if(A[\\'v\\'-\\'a\\']>0){\\n            e=A[\\'v\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n                \\n                A[\\'f\\'-\\'a\\']--;\\n                A[\\'i\\'-\\'a\\']--;\\n                A[\\'v\\'-\\'a\\']--;\\n                A[\\'e\\'-\\'a\\']--;\\n                ans.push_back(5);\\n            }\\n        }\\n        if(A[\\'r\\'-\\'a\\']>0){\\n            e=A[\\'r\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n                \\n                A[\\'t\\'-\\'a\\']--;\\n                A[\\'h\\'-\\'a\\']--;\\n                A[\\'r\\'-\\'a\\']--;\\n                A[\\'e\\'-\\'a\\']--;\\n                A[\\'e\\'-\\'a\\']--;\\n                ans.push_back(3);\\n            }\\n        }\\n        if(A[\\'o\\'-\\'a\\']>0){\\n            e=A[\\'o\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n                \\n                A[\\'o\\'-\\'a\\']--;\\n                A[\\'n\\'-\\'a\\']--;\\n                A[\\'e\\'-\\'a\\']--;\\n                ans.push_back(1);\\n            }\\n        }\\n        if(A[\\'e\\'-\\'a\\']>0){\\n            e=A[\\'e\\'-\\'a\\'];\\n            for(int i=0;i<e;i++){\\n                \\n                A[\\'n\\'-\\'a\\']--;\\n                A[\\'i\\'-\\'a\\']--;\\n                A[\\'n\\'-\\'a\\']--;\\n                A[\\'e\\'-\\'a\\']--;\\n                ans.push_back(9);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        string answer=\"\";\\n        for(int i=0;i<ans.size();i++){\\n            answer+=to_string(ans[i]);\\n        }\\n        return answer;\\n            \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> A(26,0);\\n        for(auto i:s){\\n            A[i-\\'a\\']+=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1131614,
                "title": "easy-solution-92-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        int n = s.size();\\n        vector<string> words = {\"zero\",\"two\",\"four\",\"six\",\"eight\",\"one\",\"three\",\"five\",\"seven\",\"nine\"};\\n        vector<char>num = {\\'0\\', \\'2\\', \\'4\\', \\'6\\', \\'8\\', \\'1\\', \\'3\\', \\'5\\', \\'7\\', \\'9\\'};\\n        vector<char>identity = {\\'z\\', \\'w\\', \\'u\\', \\'x\\', \\'g\\', \\'o\\', \\'r\\', \\'f\\', \\'v\\', \\'i\\'};\\n        vector<int>count(26,0);\\n        \\n        for(int i = 0; i < n; i++)\\n            count[s[i] - \\'a\\']++;\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < 10; i++)\\n        {\\n            int cnt = count[identity[i] - \\'a\\'];\\n            for(int j = 0; j < words[i].size(); j++)\\n                count[words[i][j] - \\'a\\'] -= cnt;\\n            while(cnt--)\\n                ans.push_back(num[i]);\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        int n = s.size();\\n        vector<string> words = {\"zero\",\"two\",\"four\",\"six\",\"eight\",\"one\",\"three\",\"five\",\"seven\",\"nine\"};\\n        vector<char>num = {\\'0\\', \\'2\\', \\'4\\', \\'6\\', \\'8\\', \\'1\\', \\'3\\', \\'5\\', \\'7\\', \\'9\\'};\\n        vector<char>identity = {\\'z\\', \\'w\\', \\'u\\', \\'x\\', \\'g\\', \\'o\\', \\'r\\', \\'f\\', \\'v\\', \\'i\\'};\\n        vector<int>count(26,0);\\n        \\n        for(int i = 0; i < n; i++)\\n            count[s[i] - \\'a\\']++;\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < 10; i++)\\n        {\\n            int cnt = count[identity[i] - \\'a\\'];\\n            for(int j = 0; j < words[i].size(); j++)\\n                count[words[i][j] - \\'a\\'] -= cnt;\\n            while(cnt--)\\n                ans.push_back(num[i]);\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131312,
                "title": "reconstruct-original-digits-from-english-4-msec-how-to-make-it-fast",
                "content": "My first submission to this problem was correct, but at 56 msec it was very slow. After some experimentation, I found that the bottleneck was in building the final string that is returned. In Golang, just concatenating the digit strings is slow, because as the final string gets larger and larger it is copied to a new location in memory many times. \\n\\nNext I tried using strings.Builder, and that got my runtime down to 12 msec.\\n\\nBut I got the best result by preallocating a byte array to its final size, filling it in one character at a time, and then converting it to a string. This got me down to 4 msec which is currently the fastest Golang solution.\\n\\n```\\ntype letterCounts [26]int\\n\\nfunc (letCnts *letterCounts) AddToCounts(s string) {\\n\\tfor _, ch := range s {\\n\\t\\t(*letCnts)[ch-\\'a\\']++\\n\\t}\\n}\\nfunc (letCnts letterCounts) GetCount(ch byte) int {\\n\\treturn letCnts[ch-\\'a\\']\\n}\\nfunc (letCnts *letterCounts) Remove(count int, s string) {\\n\\tfor _, ch := range s {\\n\\t\\t(*letCnts)[ch-\\'a\\'] -= count\\n\\t}\\n}\\n\\nfunc originalDigits(s string) string {\\n\\tvar letCnts letterCounts\\n\\tletCnts.AddToCounts(s)\\n\\n\\twordStrings := [10]string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\\n\\tkeyLetter := [10]byte{\\'z\\', \\'w\\', \\'u\\', \\'o\\', \\'r\\', \\'f\\', \\'x\\', \\'v\\', \\'g\\', \\'i\\'}\\n\\tcheckOrder := [10]int{0, 2, 4, 1, 3, 5, 6, 7, 8, 9}\\n\\tvar results [10]int\\n\\n\\ttotalResults := 0\\n\\tfor index, chk := range checkOrder {\\n\\t\\tcnt := letCnts.GetCount(keyLetter[index])\\n\\t\\tresults[chk] = cnt\\n\\t\\ttotalResults += cnt\\n\\t\\tletCnts.Remove(cnt, wordStrings[chk])\\n\\t}\\n\\n\\tbytesResult := make([]byte, totalResults)\\n\\tbigIndex := 0\\n\\tfor index, result := range results {\\n\\t\\tfor n := 0; n < result; n++ {\\n\\t\\t\\tbytesResult[bigIndex] = byte(index + \\'0\\')\\n\\t\\t\\tbigIndex++\\n\\t\\t}\\n\\t}\\n\\tstrResult := string(bytesResult)\\n\\treturn strResult\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype letterCounts [26]int\\n\\nfunc (letCnts *letterCounts) AddToCounts(s string) {\\n\\tfor _, ch := range s {\\n\\t\\t(*letCnts)[ch-\\'a\\']++\\n\\t}\\n}\\nfunc (letCnts letterCounts) GetCount(ch byte) int {\\n\\treturn letCnts[ch-\\'a\\']\\n}\\nfunc (letCnts *letterCounts) Remove(count int, s string) {\\n\\tfor _, ch := range s {\\n\\t\\t(*letCnts)[ch-\\'a\\'] -= count\\n\\t}\\n}\\n\\nfunc originalDigits(s string) string {\\n\\tvar letCnts letterCounts\\n\\tletCnts.AddToCounts(s)\\n\\n\\twordStrings := [10]string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\\n\\tkeyLetter := [10]byte{\\'z\\', \\'w\\', \\'u\\', \\'o\\', \\'r\\', \\'f\\', \\'x\\', \\'v\\', \\'g\\', \\'i\\'}\\n\\tcheckOrder := [10]int{0, 2, 4, 1, 3, 5, 6, 7, 8, 9}\\n\\tvar results [10]int\\n\\n\\ttotalResults := 0\\n\\tfor index, chk := range checkOrder {\\n\\t\\tcnt := letCnts.GetCount(keyLetter[index])\\n\\t\\tresults[chk] = cnt\\n\\t\\ttotalResults += cnt\\n\\t\\tletCnts.Remove(cnt, wordStrings[chk])\\n\\t}\\n\\n\\tbytesResult := make([]byte, totalResults)\\n\\tbigIndex := 0\\n\\tfor index, result := range results {\\n\\t\\tfor n := 0; n < result; n++ {\\n\\t\\t\\tbytesResult[bigIndex] = byte(index + \\'0\\')\\n\\t\\t\\tbigIndex++\\n\\t\\t}\\n\\t}\\n\\tstrResult := string(bytesResult)\\n\\treturn strResult\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131302,
                "title": "c-8ms-100-iteratively-with-comments",
                "content": "\\nRuntime: 8 ms, faster than 100.00% of C++ online submissions for Reconstruct Original Digits from English.\\nMemory Usage: 8.9 MB, less than 70.43% of C++ online submissions for Reconstruct Original Digits from English.\\n```\\nclass Solution {\\npublic:\\n  string originalDigits(string S) {\\n    int o = 0, u = 0, i = 0, z = 0, t = 0, w = 0, f = 0, g = 0, s = 0, x = 0;\\n    \\n    for(int k = 0; k != S.size(); k++)              //fetch this letters from string\\n      switch(S[k]){\\n        case \\'o\\': o++; break;\\n        case \\'i\\': i++; break;\\n        case \\'u\\': u++; break;\\n        case \\'z\\': z++; break;\\n        case \\'t\\': t++; break;\\n        case \\'w\\': w++; break;\\n        case \\'f\\': f++; break;\\n        case \\'g\\': g++; break;\\n        case \\'s\\': s++; break;\\n        case \\'x\\': x++; break;\\n      }\\n   \\n    int digits[10] = {0};                             //for count of digits\\n    \\n    if(z) o -= z,         digits[0] = z;              //for zero (unique z)\\n    if(w) o -= w, t -= w, digits[2] = w;              //for two  (unique w)\\n    if(u) o -= u, f -= u, digits[4] = u;              //for four (unique u)\\n    if(x) i -= x, s -= x, digits[6] = x;              //for six  (unique x)\\n    if(g) i -= g, t -= g, digits[8] = g;              //for eight(unique g)\\n    \\n    digits[1] = o;                             //for one    (single with o)     \\n    digits[3] = t;                             //for three  (single with t)\\n    if(f) i -= f,         digits[5] = f;       //for five   (single with f)\\n    digits[7] = s;                             //for seven  (single with s)\\n    digits[9] = i;                             //for nine   (single with i) \\n    \\n    string ans = \"\"; char ch = \\'0\\';\\n    \\n    for(int k = 0; k != 10; k++, ch++)         //construct answer \\n      for(int j = 0; j < digits[k]; j++) ans.push_back(ch);\\n    \\n    return ans;\\n  }\\n};\\n```\\n\\non first I wrote this (below) , but I think that it less readable.   =)\\n```\\nclass Solution {\\npublic:\\n  string originalDigits(string S) {\\n     int digits[10] = {0};                             //for count of digits\\n    \\n    for(int k = 0; k != S.size(); k++)                 //fetch this letters from string\\n      switch(S[k]){\\n        case \\'o\\': digits[1]++; break;\\n        case \\'i\\': digits[9]++; break;\\n        case \\'u\\': digits[4]++; break;\\n        case \\'z\\': digits[0]++; break;\\n        case \\'t\\': digits[3]++; break;\\n        case \\'w\\': digits[2]++; break;\\n        case \\'f\\': digits[5]++; break;\\n        case \\'g\\': digits[8]++; break;\\n        case \\'s\\': digits[7]++; break;\\n        case \\'x\\': digits[6]++; break;\\n      }\\n    \\n    if(digits[0]) digits[1] -= digits[0];\\n    if(digits[2]) digits[1] -= digits[2], digits[3] -= digits[2];\\n    if(digits[4]) digits[1] -= digits[4], digits[5] -= digits[4];\\n    if(digits[6]) digits[9] -= digits[6], digits[7] -= digits[6];\\n    if(digits[8]) digits[9] -= digits[8], digits[3] -= digits[8];\\n    if(digits[5]) digits[9] -= digits[5];\\n    \\n    string ans = \"\"; char ch = \\'0\\';\\n    \\n    for(int k = 0; k != 10; k++, ch++)                   //construct answer \\n      for(int j = 0; j < digits[k]; j++) ans.push_back(ch);\\n    \\n    return ans;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string originalDigits(string S) {\\n    int o = 0, u = 0, i = 0, z = 0, t = 0, w = 0, f = 0, g = 0, s = 0, x = 0;\\n    \\n    for(int k = 0; k != S.size(); k++)              //fetch this letters from string\\n      switch(S[k]){\\n        case \\'o\\': o++; break;\\n        case \\'i\\': i++; break;\\n        case \\'u\\': u++; break;\\n        case \\'z\\': z++; break;\\n        case \\'t\\': t++; break;\\n        case \\'w\\': w++; break;\\n        case \\'f\\': f++; break;\\n        case \\'g\\': g++; break;\\n        case \\'s\\': s++; break;\\n        case \\'x\\': x++; break;\\n      }\\n   \\n    int digits[10] = {0};                             //for count of digits\\n    \\n    if(z) o -= z,         digits[0] = z;              //for zero (unique z)\\n    if(w) o -= w, t -= w, digits[2] = w;              //for two  (unique w)\\n    if(u) o -= u, f -= u, digits[4] = u;              //for four (unique u)\\n    if(x) i -= x, s -= x, digits[6] = x;              //for six  (unique x)\\n    if(g) i -= g, t -= g, digits[8] = g;              //for eight(unique g)\\n    \\n    digits[1] = o;                             //for one    (single with o)     \\n    digits[3] = t;                             //for three  (single with t)\\n    if(f) i -= f,         digits[5] = f;       //for five   (single with f)\\n    digits[7] = s;                             //for seven  (single with s)\\n    digits[9] = i;                             //for nine   (single with i) \\n    \\n    string ans = \"\"; char ch = \\'0\\';\\n    \\n    for(int k = 0; k != 10; k++, ch++)         //construct answer \\n      for(int j = 0; j < digits[k]; j++) ans.push_back(ch);\\n    \\n    return ans;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  string originalDigits(string S) {\\n     int digits[10] = {0};                             //for count of digits\\n    \\n    for(int k = 0; k != S.size(); k++)                 //fetch this letters from string\\n      switch(S[k]){\\n        case \\'o\\': digits[1]++; break;\\n        case \\'i\\': digits[9]++; break;\\n        case \\'u\\': digits[4]++; break;\\n        case \\'z\\': digits[0]++; break;\\n        case \\'t\\': digits[3]++; break;\\n        case \\'w\\': digits[2]++; break;\\n        case \\'f\\': digits[5]++; break;\\n        case \\'g\\': digits[8]++; break;\\n        case \\'s\\': digits[7]++; break;\\n        case \\'x\\': digits[6]++; break;\\n      }\\n    \\n    if(digits[0]) digits[1] -= digits[0];\\n    if(digits[2]) digits[1] -= digits[2], digits[3] -= digits[2];\\n    if(digits[4]) digits[1] -= digits[4], digits[5] -= digits[4];\\n    if(digits[6]) digits[9] -= digits[6], digits[7] -= digits[6];\\n    if(digits[8]) digits[9] -= digits[8], digits[3] -= digits[8];\\n    if(digits[5]) digits[9] -= digits[5];\\n    \\n    string ans = \"\"; char ch = \\'0\\';\\n    \\n    for(int k = 0; k != 10; k++, ch++)                   //construct answer \\n      for(int j = 0; j < digits[k]; j++) ans.push_back(ch);\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130979,
                "title": "reconstruct-original-digits-from-english-easy-solution-explained",
                "content": "The main idea is, we need to make sure that the whole string must be reconstructed as digits, so we 1st we find the words which have unique char from all the words. \\n\\n```\\nFor example : \"zero\" - unique char is \\'z\\' i.e, if we find \\'z\\' in our string then, it is sure that our res includes \\'0\\'. \\nsimilarly with \\n\"two\"- unique char \\'w\\' \\n\"four\"- unique char \\'u\\'\\n\"six\" - unique char \\'x\\'\\n\"eight\" - unique char \\'g\\'\\nAfter reconstructing the digits containing these chars, we then move to other digits.\\n```\\n\\nFinally we return the sorted string `res` .  \\n\\n**Do upvote** if you find it helpful !!!\\n\\n\\n```\\nstring originalDigits(string s) {\\n       vector<string> words = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n        vector<int> nums = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};\\n        vector<int> dChar = {\\'z\\', \\'w\\', \\'u\\', \\'x\\', \\'g\\', \\'o\\', \\'r\\', \\'f\\', \\'v\\', \\'i\\'};\\n        vector<int> cnt(26, 0);\\n        string res=\"\";\\n        for(char ch : s){ cnt[ch-\\'a\\']++;}\\n        for(int i = 0; i < 10; i++){\\n            int count = cnt[dChar[i]-\\'a\\'];\\n            for(char c: words[i])\\n                cnt[c-\\'a\\'] -= count;\\n            while(count--)\\n                res += to_string(nums[i]);\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nFor example : \"zero\" - unique char is \\'z\\' i.e, if we find \\'z\\' in our string then, it is sure that our res includes \\'0\\'. \\nsimilarly with \\n\"two\"- unique char \\'w\\' \\n\"four\"- unique char \\'u\\'\\n\"six\" - unique char \\'x\\'\\n\"eight\" - unique char \\'g\\'\\nAfter reconstructing the digits containing these chars, we then move to other digits.\\n```\n```\\nstring originalDigits(string s) {\\n       vector<string> words = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n        vector<int> nums = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};\\n        vector<int> dChar = {\\'z\\', \\'w\\', \\'u\\', \\'x\\', \\'g\\', \\'o\\', \\'r\\', \\'f\\', \\'v\\', \\'i\\'};\\n        vector<int> cnt(26, 0);\\n        string res=\"\";\\n        for(char ch : s){ cnt[ch-\\'a\\']++;}\\n        for(int i = 0; i < 10; i++){\\n            int count = cnt[dChar[i]-\\'a\\'];\\n            for(char c: words[i])\\n                cnt[c-\\'a\\'] -= count;\\n            while(count--)\\n                res += to_string(nums[i]);\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91220,
                "title": "javascript-beats-91",
                "content": "```\\n\\nvar originalDigits = function(s) {\\n    var count = Array(10);\\n    count.fill(0);\\n        for(var i = 0; i < s.length; i++) {\\n            var c = s[i];\\n            if (c == 'z') count[0]++;\\n            if (c == 'w') count[2]++;\\n            if (c == 'x') count[6]++;\\n            if (c == 's') count[7]++; //7-6\\n            if (c == 'g') count[8]++;\\n            if (c == 'u') count[4]++; \\n            if (c == 'f') count[5]++; //5-4\\n            if (c == 'h') count[3]++; //3-8\\n            if (c == 'i') count[9]++; //9-8-5-6\\n            if (c == 'o') count[1]++; //1-0-2-4\\n        }\\n        \\n        count[7] -= count[6];\\n        count[5] -= count[4];\\n        count[3] -= count[8];\\n        count[9] = count[9] - count[8] - count[5] - count[6];\\n        count[1] = count[1] - count[0] - count[2] - count[4];\\n        \\n        var sb = \"\";\\n        for(var i = 0; i <= 9; i++) {\\n            for(var j = 0; j < count[i]; j++) {\\n                sb+= i;\\n            }\\n        }\\n        return sb;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar originalDigits = function(s) {\\n    var count = Array(10);\\n    count.fill(0);\\n        for(var i = 0; i < s.length; i++) {\\n            var c = s[i];\\n            if (c == 'z') count[0]++;\\n            if (c == 'w') count[2]++;\\n            if (c == 'x') count[6]++;\\n            if (c == 's') count[7]++; //7-6\\n            if (c == 'g') count[8]++;\\n            if (c == 'u') count[4]++; \\n            if (c == 'f') count[5]++; //5-4\\n            if (c == 'h') count[3]++; //3-8\\n            if (c == 'i') count[9]++; //9-8-5-6\\n            if (c == 'o') count[1]++; //1-0-2-4\\n        }\\n        \\n        count[7] -= count[6];\\n        count[5] -= count[4];\\n        count[3] -= count[8];\\n        count[9] = count[9] - count[8] - count[5] - count[6];\\n        count[1] = count[1] - count[0] - count[2] - count[4];\\n        \\n        var sb = \"\";\\n        for(var i = 0; i <= 9; i++) {\\n            for(var j = 0; j < count[i]; j++) {\\n                sb+= i;\\n            }\\n        }\\n        return sb;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761753,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string originalDigits(string s) {\\n   vector<int>num(10,0);\\n   vector<int>count(26,0);\\n   \\n    for(auto c : s)\\n        count[c-\\'a\\']++;\\n\\n\\t\\n    num[0] = count[\\'z\\'-\\'a\\'];\\n    num[2] = count[\\'w\\'-\\'a\\'];\\n    num[4] = count[\\'u\\'-\\'a\\'];\\n    num[6] = count[\\'x\\'-\\'a\\'];\\n    num[8] = count[\\'g\\'-\\'a\\'];\\n\\t\\n\\t\\n    num[1] = count[\\'o\\'-\\'a\\'] - num[0] - num[2] - num[4];\\n    num[3] = count[\\'h\\'-\\'a\\'] - num[8];\\n    num[5] = count[\\'f\\'-\\'a\\'] - num[4];\\n    num[7] = count[\\'s\\'-\\'a\\'] - num[6];\\n    num[9] = count[\\'i\\'-\\'a\\'] - num[5] - num[6] - num[8];\\n    \\n    string res ;\\n    for(int i=0;i<10;i++){\\n        int c = num[i];\\n        while(c>0){\\n            res += to_string(i);\\n            c--;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string originalDigits(string s) {\\n   vector<int>num(10,0);\\n   vector<int>count(26,0);\\n   \\n    for(auto c : s)\\n        count[c-\\'a\\']++;\\n\\n\\t\\n    num[0] = count[\\'z\\'-\\'a\\'];\\n    num[2] = count[\\'w\\'-\\'a\\'];\\n    num[4] = count[\\'u\\'-\\'a\\'];\\n    num[6] = count[\\'x\\'-\\'a\\'];\\n    num[8] = count[\\'g\\'-\\'a\\'];\\n\\t\\n\\t\\n    num[1] = count[\\'o\\'-\\'a\\'] - num[0] - num[2] - num[4];\\n    num[3] = count[\\'h\\'-\\'a\\'] - num[8];\\n    num[5] = count[\\'f\\'-\\'a\\'] - num[4];\\n    num[7] = count[\\'s\\'-\\'a\\'] - num[6];\\n    num[9] = count[\\'i\\'-\\'a\\'] - num[5] - num[6] - num[8];\\n    \\n    string res ;\\n    for(int i=0;i<10;i++){\\n        int c = num[i];\\n        while(c>0){\\n            res += to_string(i);\\n            c--;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483060,
                "title": "c-solution-using-hash-table-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        string k=\"\";\\n    unordered_map<char,int> m;\\n        int arr[10]={0};\\n        for(int i=0;i<s.length();i++)\\n            m[s[i]]++;\\n        /*\\n        if w is present then 2\\n        if u is present then 4\\n        if x is present then 6\\n        if g is present then 8\\n        if z is present then 0\\n        */\\n   arr[2]=m[\\'w\\'];\\n   arr[4]=m[\\'u\\'];\\n   arr[6]=m[\\'x\\'];\\n   arr[8]=m[\\'g\\'];\\n   arr[0]=m[\\'z\\'];\\n        \\n    /* To identify other numbers remove the common characters if they are present else 0 \\n    will get subtracted if character is not present \\n    */\\n   arr[1]=m[\\'o\\']-arr[2]-arr[4]-arr[0];\\n   arr[3]=m[\\'h\\']-arr[8];\\n   arr[5]=m[\\'f\\']-arr[4];\\n   arr[7]=m[\\'s\\']-arr[6];\\n   arr[9]=m[\\'i\\']-arr[5]-arr[8]-arr[6]; \\n    for(int i=0;i<10;i++){\\n        while(arr[i]--)\\n       k+=to_string(i);  \\n    }\\n        \\n        sort(k.begin(),k.end());\\n      return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        string k=\"\";\\n    unordered_map<char,int> m;\\n        int arr[10]={0};\\n        for(int i=0;i<s.length();i++)\\n            m[s[i]]++;\\n        /*\\n        if w is present then 2\\n        if u is present then 4\\n        if x is present then 6\\n        if g is present then 8\\n        if z is present then 0\\n        */\\n   arr[2]=m[\\'w\\'];\\n   arr[4]=m[\\'u\\'];\\n   arr[6]=m[\\'x\\'];\\n   arr[8]=m[\\'g\\'];\\n   arr[0]=m[\\'z\\'];\\n        \\n    /* To identify other numbers remove the common characters if they are present else 0 \\n    will get subtracted if character is not present \\n    */\\n   arr[1]=m[\\'o\\']-arr[2]-arr[4]-arr[0];\\n   arr[3]=m[\\'h\\']-arr[8];\\n   arr[5]=m[\\'f\\']-arr[4];\\n   arr[7]=m[\\'s\\']-arr[6];\\n   arr[9]=m[\\'i\\']-arr[5]-arr[8]-arr[6]; \\n    for(int i=0;i<10;i++){\\n        while(arr[i]--)\\n       k+=to_string(i);  \\n    }\\n        \\n        sort(k.begin(),k.end());\\n      return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134938,
                "title": "python-solution-with-cool-followup-as-a-side-effect",
                "content": "A cool follow up would be to find any reminder rubbish text that no more digits can be formed from.\\nMy code does that as a side effect.\\n\\n```python\\n    def originalDigits(self, s: str) -> str:\\n        words = (\\n            (0, \"zero\"),  # unique z\\n            (2, \"two\"),   # unique w\\n            (4, \"four\"),  # unique u\\n            (6, \"six\"),   # unique x\\n            (1, \"one\"),   # unique o after 0,2,4\\n            (3, \"three\"), # unique r after 0,4\\n            (5, \"five\"),  # unique f after 4\\n            (7, \"seven\"), # unique s after 6\\n            (8, \"eight\"), # unique g\\n            (9, \"nine\")   # last\\n        )\\n        word_cnts = []\\n        cnt = Counter(s)\\n        ans = []\\n        for i, word in words:\\n            wc = Counter(word)\\n            times = min(cnt[letter] // wc[letter] for letter in wc)\\n            ans.append(str(i) * times)\\n            for l in wc:\\n                wc[l] *= times\\n            cnt -= wc\\n\\t\\t# print(\"reminder:\", cnt)\\n        return \"\".join(sorted(ans))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def originalDigits(self, s: str) -> str:\\n        words = (\\n            (0, \"zero\"),  # unique z\\n            (2, \"two\"),   # unique w\\n            (4, \"four\"),  # unique u\\n            (6, \"six\"),   # unique x\\n            (1, \"one\"),   # unique o after 0,2,4\\n            (3, \"three\"), # unique r after 0,4\\n            (5, \"five\"),  # unique f after 4\\n            (7, \"seven\"), # unique s after 6\\n            (8, \"eight\"), # unique g\\n            (9, \"nine\")   # last\\n        )\\n        word_cnts = []\\n        cnt = Counter(s)\\n        ans = []\\n        for i, word in words:\\n            wc = Counter(word)\\n            times = min(cnt[letter] // wc[letter] for letter in wc)\\n            ans.append(str(i) * times)\\n            for l in wc:\\n                wc[l] *= times\\n            cnt -= wc\\n\\t\\t# print(\"reminder:\", cnt)\\n        return \"\".join(sorted(ans))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1556493,
                "title": "python3-one-pass-solution",
                "content": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        c = collections.Counter(s)\\n        \\n        digit_count = [0] * 10\\n        digit_count[0] = c[\\'z\\']\\n        digit_count[2] = c[\\'w\\']\\n        digit_count[4] = c[\\'u\\']\\n        digit_count[6] = c[\\'x\\']\\n        digit_count[8] = c[\\'g\\']\\n        \\n        digit_count[3] = c[\\'h\\'] - digit_count[8]\\n        digit_count[5] = c[\\'f\\'] - digit_count[4]\\n        digit_count[7] = c[\\'s\\'] - digit_count[6]\\n        \\n        digit_count[9] = c[\\'i\\'] - digit_count[5] - digit_count[6] - digit_count[8]\\n        digit_count[1] = c[\\'n\\'] - digit_count[9] * 2 - digit_count[7]\\n        \\n        return \"\".join([str(idx) * cnt for idx, cnt in enumerate(digit_count) if cnt > 0])\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        c = collections.Counter(s)\\n        \\n        digit_count = [0] * 10\\n        digit_count[0] = c[\\'z\\']\\n        digit_count[2] = c[\\'w\\']\\n        digit_count[4] = c[\\'u\\']\\n        digit_count[6] = c[\\'x\\']\\n        digit_count[8] = c[\\'g\\']\\n        \\n        digit_count[3] = c[\\'h\\'] - digit_count[8]\\n        digit_count[5] = c[\\'f\\'] - digit_count[4]\\n        digit_count[7] = c[\\'s\\'] - digit_count[6]\\n        \\n        digit_count[9] = c[\\'i\\'] - digit_count[5] - digit_count[6] - digit_count[8]\\n        digit_count[1] = c[\\'n\\'] - digit_count[9] * 2 - digit_count[7]\\n        \\n        return \"\".join([str(idx) * cnt for idx, cnt in enumerate(digit_count) if cnt > 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549699,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        /*\\n        zero one two three four five six seven eight nine ten\\n        e: zero, seven, eight, three, nine, ten, one\\n        g: eight\\n        f: five four\\n        i: five, six, eight, nine\\n        h: three, eight\\n        o: one, two, four, zero\\n        n: one, seven, nine, ten\\n        s: six,seven\\n        r: three, four, zero\\n        u: four\\n        t: two, three, eight, ten\\n        w: two\\n        v: five, seven\\n        x: six\\n        z: zero\\n        */\\n        vector<int> char_counts(26,0);\\n        for (char c:s){\\n            char_counts[c-\\'a\\'] +=1;\\n        }\\n        vector <int> out(10);\\n        out[0] = char_counts[\\'z\\' - \\'a\\'];\\n        out[2] = char_counts[\\'w\\' - \\'a\\'];\\n        out[4] = char_counts[\\'u\\' - \\'a\\'];\\n        out[6] = char_counts[\\'x\\' - \\'a\\'];\\n        out[8] = char_counts[\\'g\\' - \\'a\\'];\\n        out[3] = char_counts[\\'h\\' - \\'a\\'] - out[8];\\n        out[5] = char_counts[\\'f\\' - \\'a\\'] - out[4];\\n        out[7] = char_counts[\\'s\\' - \\'a\\'] - out[6];\\n        out[9] = char_counts[\\'i\\' - \\'a\\'] - out[5] - out[6] - out[8];\\n        out[1] = char_counts[\\'n\\' - \\'a\\'] - out[7] - 2*out[9];\\n        string ans;\\n        for (int i=0;i<10;i++)\\n            for (int j=0;j<out[i];j++)\\n                ans += to_string(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        /*\\n        zero one two three four five six seven eight nine ten\\n        e: zero, seven, eight, three, nine, ten, one\\n        g: eight\\n        f: five four\\n        i: five, six, eight, nine\\n        h: three, eight\\n        o: one, two, four, zero\\n        n: one, seven, nine, ten\\n        s: six,seven\\n        r: three, four, zero\\n        u: four\\n        t: two, three, eight, ten\\n        w: two\\n        v: five, seven\\n        x: six\\n        z: zero\\n        */\\n        vector<int> char_counts(26,0);\\n        for (char c:s){\\n            char_counts[c-\\'a\\'] +=1;\\n        }\\n        vector <int> out(10);\\n        out[0] = char_counts[\\'z\\' - \\'a\\'];\\n        out[2] = char_counts[\\'w\\' - \\'a\\'];\\n        out[4] = char_counts[\\'u\\' - \\'a\\'];\\n        out[6] = char_counts[\\'x\\' - \\'a\\'];\\n        out[8] = char_counts[\\'g\\' - \\'a\\'];\\n        out[3] = char_counts[\\'h\\' - \\'a\\'] - out[8];\\n        out[5] = char_counts[\\'f\\' - \\'a\\'] - out[4];\\n        out[7] = char_counts[\\'s\\' - \\'a\\'] - out[6];\\n        out[9] = char_counts[\\'i\\' - \\'a\\'] - out[5] - out[6] - out[8];\\n        out[1] = char_counts[\\'n\\' - \\'a\\'] - out[7] - 2*out[9];\\n        string ans;\\n        for (int i=0;i<10;i++)\\n            for (int j=0;j<out[i];j++)\\n                ans += to_string(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501499,
                "title": "python-easy-to-understand-and-clear",
                "content": "```\\n# Approach 1: \\n# time complexity: O(n)\\n# space complexity: O(n)\\n\\ndef originalDigits(s):\\n    \"\"\"\\n    :type s: str\\n    :rtype: str\\n    \"\"\"\\n    digitCounts = [0]*10\\n    for i in s:\\n        if i==\"z\": digitCounts[0]+=1\\n        if i==\"w\": digitCounts[2]+=1\\n        if i==\"u\": digitCounts[4]+=1\\n        if i==\"x\": digitCounts[6]+=1\\n        if i==\"g\": digitCounts[8]+=1\\n        if i==\"s\": digitCounts[7]+=1 #7-6\\n        if i==\"f\": digitCounts[5]+=1 #5-4\\n        if i==\"h\": digitCounts[3]+=1 #3-8\\n        if i==\"i\": digitCounts[9]+=1 #9-8-5-6\\n        if i==\"o\": digitCounts[1]+=1 #1-0-2-4\\n        \\n    digitCounts[7] -= digitCounts[6]\\n    digitCounts[5] -= digitCounts[4]\\n    digitCounts[3] -= digitCounts[8]\\n    digitCounts[9] -= digitCounts[8]+digitCounts[5]+digitCounts[6]\\n    digitCounts[1] -= digitCounts[0]+digitCounts[2]+digitCounts[4]\\n\\n    answer = \"\"\\n    for i in range(len(digitCounts)):\\n        for j in range(digitCounts[i]):\\n            answer += str(i)\\n\\n    return answer\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Approach 1: \\n# time complexity: O(n)\\n# space complexity: O(n)\\n\\ndef originalDigits(s):\\n    \"\"\"\\n    :type s: str\\n    :rtype: str\\n    \"\"\"\\n    digitCounts = [0]*10\\n    for i in s:\\n        if i==\"z\": digitCounts[0]+=1\\n        if i==\"w\": digitCounts[2]+=1\\n        if i==\"u\": digitCounts[4]+=1\\n        if i==\"x\": digitCounts[6]+=1\\n        if i==\"g\": digitCounts[8]+=1\\n        if i==\"s\": digitCounts[7]+=1 #7-6\\n        if i==\"f\": digitCounts[5]+=1 #5-4\\n        if i==\"h\": digitCounts[3]+=1 #3-8\\n        if i==\"i\": digitCounts[9]+=1 #9-8-5-6\\n        if i==\"o\": digitCounts[1]+=1 #1-0-2-4\\n        \\n    digitCounts[7] -= digitCounts[6]\\n    digitCounts[5] -= digitCounts[4]\\n    digitCounts[3] -= digitCounts[8]\\n    digitCounts[9] -= digitCounts[8]+digitCounts[5]+digitCounts[6]\\n    digitCounts[1] -= digitCounts[0]+digitCounts[2]+digitCounts[4]\\n\\n    answer = \"\"\\n    for i in range(len(digitCounts)):\\n        for j in range(digitCounts[i]):\\n            answer += str(i)\\n\\n    return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1468525,
                "title": "words-are-intersting",
                "content": "**Solution1**\\nThere is an intersting thing with the 0-9 words is:\\n\\nzero can be distinguish by \"z\"\\ntwo can be distinguish by \"w\"\\nfour can be distinguish by \"u\"\\nsix can be distinguish by \"x\"\\neight can be distinguish by \"g\"\\n\\nand once you removed the words using above conditions then only after that with the odd number also,\\none can be distinguish by \"o\"\\nthree can be distinguish by \"t\"\\nfive can be distinguish by \"f\"\\nseven can be distinguish by \"s\"\\n\\nand at the end, whatever left is for nine\\n\\nBelow is my code for the same:\\n\\n```\\nfrom collections import defaultdict\\nunique_number = {0: [\"zero\", \"z\"],\\n                2 : [\"two\", \"w\"],\\n                4 : [\"four\",\"u\"],\\n                6 : [\"six\", \"x\"],\\n                8 : [\"eight\", \"g\"],\\n                }\\nnu_number = {\\n    1:[\"one\",\"o\"],\\n    3:[\"three\",\"t\"],\\n    5:[\"five\",\"f\"],\\n    7:[\"seven\",\"s\"],\\n}\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        graph = defaultdict(int)\\n        for x in s:\\n            graph[x] += 1\\n        \\n        ans = [0]*10\\n        for map_ in [unique_number, nu_number]:\\n            for index, lst in map_.items():\\n                count = graph.get(lst[1], 0)\\n                if count > 0:\\n                    # print(count, lst[1], graph)\\n                    for x in lst[0]:\\n                        graph[x] -= count\\n                        if graph[x] == 0:\\n                            graph.pop(x)\\n                    ans[index] += count\\n        \\n        if graph:\\n            ans[9] += graph[\\'i\\'] # nine\\n        return \\'\\'.join([x*str(i) for i, x in enumerate(ans) if x>0])\\n\\n```\\n**Solution2**\\nAs we know, if we remove the even term then we can distinguish odd term easily so instead of creating two map we can create a list contain even element at first and then odd.\\ni.e = \\n```\\n[[0,\"zero\",\"z],[2, \"two\",\"w\"]......[8, \"eight\", \"g\"], [1,\"one\",\"o\"],....,[7,\"seven\", \"s\"], [9,\"nine\",\"i\"]]\\n```\\nCode for the same:\\n```\\nfrom collections import defaultdict\\nnumbers = [[0, \"zero\", \"z\"],\\n            [2 , \"two\", \"w\"],\\n            [4 , \"four\",\"u\"],\\n            [6 , \"six\", \"x\"],\\n            [8 , \"eight\", \"g\"],\\n            [1 , \"one\",\"o\"],\\n            [3 , \"three\",\"t\"],\\n            [5 , \"five\",\"f\"], \\n            [7 , \"seven\",\"s\"],\\n            [9 , \"nine\",\"i\"]\\n            ]\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        graph = defaultdict(int)\\n        for x in s:\\n            graph[x] += 1\\n        \\n        ans = [0]*10\\n        for index, word, identifier in numbers:\\n            count = graph.get(identifier, 0)\\n            if count > 0:\\n                for x in word:\\n                    graph[x] -= count\\n                    if graph[x] == 0:\\n                        graph.pop(x)\\n                ans[index] += count\\n    \\n        return \\'\\'.join([x*str(i) for i, x in enumerate(ans) if x>0])\\n \\n ```\\n \\n Upvote if you like it, and in case of any clarification comment here !\\nThanks",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nunique_number = {0: [\"zero\", \"z\"],\\n                2 : [\"two\", \"w\"],\\n                4 : [\"four\",\"u\"],\\n                6 : [\"six\", \"x\"],\\n                8 : [\"eight\", \"g\"],\\n                }\\nnu_number = {\\n    1:[\"one\",\"o\"],\\n    3:[\"three\",\"t\"],\\n    5:[\"five\",\"f\"],\\n    7:[\"seven\",\"s\"],\\n}\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        graph = defaultdict(int)\\n        for x in s:\\n            graph[x] += 1\\n        \\n        ans = [0]*10\\n        for map_ in [unique_number, nu_number]:\\n            for index, lst in map_.items():\\n                count = graph.get(lst[1], 0)\\n                if count > 0:\\n                    # print(count, lst[1], graph)\\n                    for x in lst[0]:\\n                        graph[x] -= count\\n                        if graph[x] == 0:\\n                            graph.pop(x)\\n                    ans[index] += count\\n        \\n        if graph:\\n            ans[9] += graph[\\'i\\'] # nine\\n        return \\'\\'.join([x*str(i) for i, x in enumerate(ans) if x>0])\\n\\n```\n```\\n[[0,\"zero\",\"z],[2, \"two\",\"w\"]......[8, \"eight\", \"g\"], [1,\"one\",\"o\"],....,[7,\"seven\", \"s\"], [9,\"nine\",\"i\"]]\\n```\n```\\nfrom collections import defaultdict\\nnumbers = [[0, \"zero\", \"z\"],\\n            [2 , \"two\", \"w\"],\\n            [4 , \"four\",\"u\"],\\n            [6 , \"six\", \"x\"],\\n            [8 , \"eight\", \"g\"],\\n            [1 , \"one\",\"o\"],\\n            [3 , \"three\",\"t\"],\\n            [5 , \"five\",\"f\"], \\n            [7 , \"seven\",\"s\"],\\n            [9 , \"nine\",\"i\"]\\n            ]\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        graph = defaultdict(int)\\n        for x in s:\\n            graph[x] += 1\\n        \\n        ans = [0]*10\\n        for index, word, identifier in numbers:\\n            count = graph.get(identifier, 0)\\n            if count > 0:\\n                for x in word:\\n                    graph[x] -= count\\n                    if graph[x] == 0:\\n                        graph.pop(x)\\n                ans[index] += count\\n    \\n        return \\'\\'.join([x*str(i) for i, x in enumerate(ans) if x>0])\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1413449,
                "title": "python-92-space-hashmap-counting-sort",
                "content": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        \\n        # zero - U (z) \\n        # one - count (o) - 0,2,4\\n        # two - U (w) \\n        # three - count (h) - 8 \\n        # four 0 U (u)\\n        # five - count (f) - 4 \\n        # six - U (x)\\n        # seven - count (s) - 6\\n        # eight - U (g)\\n        # nine - count (i) - 5,6,8\\n        \\n        chars = Counter(s)\\n        res = [0]*10\\n        \\n        res[0] = chars[\"z\"]\\n        res[2] = chars[\"w\"]\\n        res[4] = chars[\"u\"]\\n        res[6] = chars[\"x\"]\\n        res[8] = chars[\"g\"]\\n        \\n        res[3] = chars[\"h\"]-res[8]\\n        res[5] = chars[\"f\"]-res[4]\\n        res[7] = chars[\"s\"]-res[6]\\n        \\n        res[9] = chars[\"i\"]-(res[5]+res[6]+res[8])\\n        res[1] = chars[\"o\"]-(res[0]+res[2]+res[4])\\n\\n        result = []\\n        for pos, val in enumerate(res):\\n            if val > 0:\\n                result.append(str(pos)*val)\\n        \\n        return \"\".join(result)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        \\n        # zero - U (z) \\n        # one - count (o) - 0,2,4\\n        # two - U (w) \\n        # three - count (h) - 8 \\n        # four 0 U (u)\\n        # five - count (f) - 4 \\n        # six - U (x)\\n        # seven - count (s) - 6\\n        # eight - U (g)\\n        # nine - count (i) - 5,6,8\\n        \\n        chars = Counter(s)\\n        res = [0]*10\\n        \\n        res[0] = chars[\"z\"]\\n        res[2] = chars[\"w\"]\\n        res[4] = chars[\"u\"]\\n        res[6] = chars[\"x\"]\\n        res[8] = chars[\"g\"]\\n        \\n        res[3] = chars[\"h\"]-res[8]\\n        res[5] = chars[\"f\"]-res[4]\\n        res[7] = chars[\"s\"]-res[6]\\n        \\n        res[9] = chars[\"i\"]-(res[5]+res[6]+res[8])\\n        res[1] = chars[\"o\"]-(res[0]+res[2]+res[4])\\n\\n        result = []\\n        for pos, val in enumerate(res):\\n            if val > 0:\\n                result.append(str(pos)*val)\\n        \\n        return \"\".join(result)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174761,
                "title": "fastest-python-solution",
                "content": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        most_important_char = [\\n            (\\'x\\', \\'six\\', 6),\\n            (\\'s\\', \\'seven\\', 7),\\n            (\\'v\\', \\'five\\', 5),\\n            (\\'f\\', \\'four\\', 4),\\n            (\\'w\\', \\'two\\', 2),\\n            (\\'z\\', \\'zero\\', 0),\\n            (\\'g\\', \\'eight\\', 8),\\n            (\\'o\\', \\'one\\', 1),\\n            (\\'t\\', \\'three\\', 3),\\n            (\\'e\\', \\'nine\\', 9),\\n        ]\\n        output = [\\'\\'] * 10\\n        counter = collections.Counter(s)\\n        for char, number, index in most_important_char:\\n            number_of_occurences = counter.get(char, 0)\\n            if number_of_occurences > 0:\\n                for char in number:\\n                    counter[char] -= number_of_occurences\\n                output[index] = number_of_occurences * str(index)\\n        \\n        return \\'\\'.join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        most_important_char = [\\n            (\\'x\\', \\'six\\', 6),\\n            (\\'s\\', \\'seven\\', 7),\\n            (\\'v\\', \\'five\\', 5),\\n            (\\'f\\', \\'four\\', 4),\\n            (\\'w\\', \\'two\\', 2),\\n            (\\'z\\', \\'zero\\', 0),\\n            (\\'g\\', \\'eight\\', 8),\\n            (\\'o\\', \\'one\\', 1),\\n            (\\'t\\', \\'three\\', 3),\\n            (\\'e\\', \\'nine\\', 9),\\n        ]\\n        output = [\\'\\'] * 10\\n        counter = collections.Counter(s)\\n        for char, number, index in most_important_char:\\n            number_of_occurences = counter.get(char, 0)\\n            if number_of_occurences > 0:\\n                for char in number:\\n                    counter[char] -= number_of_occurences\\n                output[index] = number_of_occurences * str(index)\\n        \\n        return \\'\\'.join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156901,
                "title": "java-clean-concise-code-3ms-time-100-easy-faster-solution",
                "content": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        \\n        int[] count = new int[26];\\n        int[] digits = new int[10];\\n        StringBuilder str = new StringBuilder ();\\n        \\n        for (char c : s.toCharArray ()) {\\n            ++count[c - \\'a\\'];\\n        }\\n        \\n        digits[0] = count[25];\\n        digits[2] = count[22];\\n        digits[4] = count[20];\\n        digits[6] = count[23];\\n        digits[8] = count[6];\\n        digits[1] = count[14] - digits[0] - digits[2] - digits[4];\\n        digits[3] = count[7] - digits[8];\\n        digits[5] = count[5] - digits[4];\\n        digits[7] = count[18] - digits[6];\\n        digits[9] = count[8] - digits[5] - digits[6] - digits[8];\\n        \\n        for (int i = 0; i < 10; i++) {\\n            while (digits[i]-- != 0) {\\n                str.append ((char) (i + 48));\\n            }\\n        }\\n        \\n        return str.toString ();\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        \\n        int[] count = new int[26];\\n        int[] digits = new int[10];\\n        StringBuilder str = new StringBuilder ();\\n        \\n        for (char c : s.toCharArray ()) {\\n            ++count[c - \\'a\\'];\\n        }\\n        \\n        digits[0] = count[25];\\n        digits[2] = count[22];\\n        digits[4] = count[20];\\n        digits[6] = count[23];\\n        digits[8] = count[6];\\n        digits[1] = count[14] - digits[0] - digits[2] - digits[4];\\n        digits[3] = count[7] - digits[8];\\n        digits[5] = count[5] - digits[4];\\n        digits[7] = count[18] - digits[6];\\n        digits[9] = count[8] - digits[5] - digits[6] - digits[8];\\n        \\n        for (int i = 0; i < 10; i++) {\\n            while (digits[i]-- != 0) {\\n                str.append ((char) (i + 48));\\n            }\\n        }\\n        \\n        return str.toString ();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131641,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        int count[26]={};\\n        for(int c : s){\\n            count[c-\\'a\\']++;\\n        }\\n        char arr[10]={\\'z\\',\\'x\\',\\'w\\',\\'u\\',\\'r\\',\\'f\\',\\'t\\',\\'i\\',\\'s\\',\\'o\\'};\\n        string digit[10]={\"zero\",\"six\",\"two\",\"four\",\"three\",\"five\",\"eight\",\"nine\",\"seven\",\"one\"};\\n        int numeric[10]={0,6,2,4,3,5,8,9,7,1};\\n        \\n        string ans;\\n        for(int i=0;i<10;i++){\\n            int freq=count[arr[i]-\\'a\\'];\\n            if(freq==0)\\n                continue;\\n            for(int j=0;j<freq;j++){\\n                ans+=to_string(numeric[i]);\\n            }\\n            string word=digit[i];\\n            for(int c: word){\\n                count[c-\\'a\\']-=freq;\\n            }\\n            \\n        }\\n        sort(begin(ans),end(ans));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        int count[26]={};\\n        for(int c : s){\\n            count[c-\\'a\\']++;\\n        }\\n        char arr[10]={\\'z\\',\\'x\\',\\'w\\',\\'u\\',\\'r\\',\\'f\\',\\'t\\',\\'i\\',\\'s\\',\\'o\\'};\\n        string digit[10]={\"zero\",\"six\",\"two\",\"four\",\"three\",\"five\",\"eight\",\"nine\",\"seven\",\"one\"};\\n        int numeric[10]={0,6,2,4,3,5,8,9,7,1};\\n        \\n        string ans;\\n        for(int i=0;i<10;i++){\\n            int freq=count[arr[i]-\\'a\\'];\\n            if(freq==0)\\n                continue;\\n            for(int j=0;j<freq;j++){\\n                ans+=to_string(numeric[i]);\\n            }\\n            string word=digit[i];\\n            for(int c: word){\\n                count[c-\\'a\\']-=freq;\\n            }\\n            \\n        }\\n        sort(begin(ans),end(ans));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131336,
                "title": "rust-solution",
                "content": "Fix based on grokus\\'s comments\\n\\n```\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let len: usize = (26 + \\'a\\' as u32) as usize;\\n        let mut vec: Vec<u32> = vec![0; len];\\n        for c in s.chars() {\\n            vec[c as usize] += 1;\\n        }\\n        let mut res = [0; 10];\\n        res[0] = vec[\\'z\\' as usize];\\n        res[2] = vec[\\'w\\' as usize];\\n        res[4] = vec[\\'u\\' as usize];\\n        res[6] = vec[\\'x\\' as usize];\\n        res[8] = vec[\\'g\\' as usize];\\n        res[3] = vec[\\'h\\' as usize] - res[8];\\n        res[5] = vec[\\'f\\' as usize] - res[4];\\n        res[7] = vec[\\'s\\' as usize] - res[6];\\n        res[9] = vec[\\'i\\' as usize] - res[5] - res[6] - res[8];\\n        res[1] = vec[\\'o\\' as usize] - res[0] - res[2] - res[4];\\n        \\n        let mut result: String = \"\".to_string();\\n        for i in 0..10 {\\n            result.push_str(&i.to_string().repeat(res[i] as usize))\\n        }\\n        result\\n    }\\n}\\n```\\nPrevious:\\n```\\n// zero, one, two, three, four, five, six, seven, eight, nine\\n// z -> 0, w -> 2, u -> 4, x -> 6, g -> 8\\n// 1, 3, 5, 7, 9\\n// 3, 8 -> share h\\n// 4, 5 -> share f\\n// 6, 7 -> share s\\n// 5, 6, 8, 9 -> share i\\n// 0, 1, 2, 4 -> share o\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let len: usize = (26 + \\'a\\' as u32) as usize;\\n        let mut vec: Vec<u32> = vec![0; len];\\n        for c in s.chars() {\\n            vec[c as usize] = vec[c as usize] + 1;\\n        }\\n        let mut res: Vec<u32> = vec![0; 10];\\n        res[0] = vec[\\'z\\' as usize];\\n        res[2] = vec[\\'w\\' as usize];\\n        res[4] = vec[\\'u\\' as usize];\\n        res[6] = vec[\\'x\\' as usize];\\n        res[8] = vec[\\'g\\' as usize];\\n        res[3] = vec[\\'h\\' as usize] - res[8];\\n        res[5] = vec[\\'f\\' as usize] - res[4];\\n        res[7] = vec[\\'s\\' as usize] - res[6];\\n        res[9] = vec[\\'i\\' as usize] - res[5] - res[6] - res[8];\\n        res[1] = vec[\\'o\\' as usize] - res[0] - res[2] - res[4];\\n        \\n        let mut result: String = \"\".to_string();\\n        for i in 0..10 {\\n            let c: &str = &(i.to_string());\\n            for j in 0..res[i] {\\n                result.push_str(c);\\n            }\\n        }\\n        \\n        result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let len: usize = (26 + \\'a\\' as u32) as usize;\\n        let mut vec: Vec<u32> = vec![0; len];\\n        for c in s.chars() {\\n            vec[c as usize] += 1;\\n        }\\n        let mut res = [0; 10];\\n        res[0] = vec[\\'z\\' as usize];\\n        res[2] = vec[\\'w\\' as usize];\\n        res[4] = vec[\\'u\\' as usize];\\n        res[6] = vec[\\'x\\' as usize];\\n        res[8] = vec[\\'g\\' as usize];\\n        res[3] = vec[\\'h\\' as usize] - res[8];\\n        res[5] = vec[\\'f\\' as usize] - res[4];\\n        res[7] = vec[\\'s\\' as usize] - res[6];\\n        res[9] = vec[\\'i\\' as usize] - res[5] - res[6] - res[8];\\n        res[1] = vec[\\'o\\' as usize] - res[0] - res[2] - res[4];\\n        \\n        let mut result: String = \"\".to_string();\\n        for i in 0..10 {\\n            result.push_str(&i.to_string().repeat(res[i] as usize))\\n        }\\n        result\\n    }\\n}\\n```\n```\\n// zero, one, two, three, four, five, six, seven, eight, nine\\n// z -> 0, w -> 2, u -> 4, x -> 6, g -> 8\\n// 1, 3, 5, 7, 9\\n// 3, 8 -> share h\\n// 4, 5 -> share f\\n// 6, 7 -> share s\\n// 5, 6, 8, 9 -> share i\\n// 0, 1, 2, 4 -> share o\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let len: usize = (26 + \\'a\\' as u32) as usize;\\n        let mut vec: Vec<u32> = vec![0; len];\\n        for c in s.chars() {\\n            vec[c as usize] = vec[c as usize] + 1;\\n        }\\n        let mut res: Vec<u32> = vec![0; 10];\\n        res[0] = vec[\\'z\\' as usize];\\n        res[2] = vec[\\'w\\' as usize];\\n        res[4] = vec[\\'u\\' as usize];\\n        res[6] = vec[\\'x\\' as usize];\\n        res[8] = vec[\\'g\\' as usize];\\n        res[3] = vec[\\'h\\' as usize] - res[8];\\n        res[5] = vec[\\'f\\' as usize] - res[4];\\n        res[7] = vec[\\'s\\' as usize] - res[6];\\n        res[9] = vec[\\'i\\' as usize] - res[5] - res[6] - res[8];\\n        res[1] = vec[\\'o\\' as usize] - res[0] - res[2] - res[4];\\n        \\n        let mut result: String = \"\".to_string();\\n        for i in 0..10 {\\n            let c: &str = &(i.to_string());\\n            for j in 0..res[i] {\\n                result.push_str(c);\\n            }\\n        }\\n        \\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131324,
                "title": "java-solution-beats-100-with-explanation",
                "content": "**Intuition:**\\n1) Remember that input is always valid.\\n2) Some characters are unique for some digits. Use that to identify them. i.e. only zero includes character of `z` .\\n3) Some digits does not have unique characters. Use the information at step 2 to find them. \\n4) Use a 26 length character array instead of using if/else blocks to check characters of the given string. This speeds up at test cases since there may be many if/else controls (performance difference is 1 ms. vs 3 ms.).\\n\\n```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] chars = new int[26];\\n        for (char c : s.toCharArray()) {\\n            chars[c - \\'a\\']++;\\n        }\\n        \\n        int[] result = new int[10];\\n        result[0] = chars[\\'z\\' - \\'a\\'];\\n        result[2] = chars[\\'w\\' - \\'a\\'];\\n        result[6] = chars[\\'x\\' - \\'a\\'];\\n        result[8] = chars[\\'g\\' - \\'a\\'];\\n        result[4] = chars[\\'u\\' - \\'a\\'];\\n        result[7] = chars[\\'s\\' - \\'a\\'];\\n        result[5] = chars[\\'f\\' - \\'a\\'];\\n        result[3] = chars[\\'h\\' - \\'a\\'];\\n        result[9] = chars[\\'i\\' - \\'a\\'];\\n        result[1] = chars[\\'o\\' - \\'a\\'];\\n        \\n        result[7] -= result[6];\\n        result[5] -= result[4];\\n        result[3] -= result[8];\\n        result[9] -= result[8] + result[5] + result[6];\\n        result[1] -= result[0] + result[2] + result[4];\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            for (int j = 0; j < result[i]; j++) {\\n                sb.append(i);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] chars = new int[26];\\n        for (char c : s.toCharArray()) {\\n            chars[c - \\'a\\']++;\\n        }\\n        \\n        int[] result = new int[10];\\n        result[0] = chars[\\'z\\' - \\'a\\'];\\n        result[2] = chars[\\'w\\' - \\'a\\'];\\n        result[6] = chars[\\'x\\' - \\'a\\'];\\n        result[8] = chars[\\'g\\' - \\'a\\'];\\n        result[4] = chars[\\'u\\' - \\'a\\'];\\n        result[7] = chars[\\'s\\' - \\'a\\'];\\n        result[5] = chars[\\'f\\' - \\'a\\'];\\n        result[3] = chars[\\'h\\' - \\'a\\'];\\n        result[9] = chars[\\'i\\' - \\'a\\'];\\n        result[1] = chars[\\'o\\' - \\'a\\'];\\n        \\n        result[7] -= result[6];\\n        result[5] -= result[4];\\n        result[3] -= result[8];\\n        result[9] -= result[8] + result[5] + result[6];\\n        result[1] -= result[0] + result[2] + result[4];\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            for (int j = 0; j < result[i]; j++) {\\n                sb.append(i);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131072,
                "title": "java-beats-100-comments-explained",
                "content": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n       //create the freq map\\n       int[] freq = new int[26];\\n       for(char c: s.toCharArray()) freq[c-\\'a\\']++;\\n       \\n       // String builder to create the result\\n       StringBuilder sb = new StringBuilder();\\n       \\n       int[] nums = new int[10];\\n       nums[0] = freq[\\'z\\'-\\'a\\']; // zero, only for 0\\n       nums[2] = freq[\\'w\\'-\\'a\\']; // two, only for 2\\n       nums[4] = freq[\\'u\\'-\\'a\\']; // four, only for 4\\n       nums[6] = freq[\\'x\\'-\\'a\\']; // siz, only for 6\\n       nums[8] = freq[\\'g\\'-\\'a\\']; // eight, only for 8\\n       //remaining \\n       nums[1] = freq[\\'o\\'-\\'a\\'] - nums[0] - nums[2] - nums[4]; //for one, common eo in 0, o in 2 & 4 \\n       nums[5] = freq[\\'f\\'-\\'a\\'] - nums[4]; //for five, f occurs in 4\\n       nums[3] = freq[\\'t\\'-\\'a\\'] - nums[2] - nums[8]; //for three, common e in 2 & 8\\n       nums[7] = freq[\\'s\\'-\\'a\\'] - nums[6]; // for seven, common s in 6\\n       nums[9] = freq[\\'i\\'-\\'a\\'] - nums[5] - nums[6] - nums[8]; //nine, i in 5,6,8\\n        \\n       for(int i = 0; i < 10; i++)\\n            for(int j = 0; j < nums[i]; j++) sb.append(i);\\n       return sb.toString();\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n       //create the freq map\\n       int[] freq = new int[26];\\n       for(char c: s.toCharArray()) freq[c-\\'a\\']++;\\n       \\n       // String builder to create the result\\n       StringBuilder sb = new StringBuilder();\\n       \\n       int[] nums = new int[10];\\n       nums[0] = freq[\\'z\\'-\\'a\\']; // zero, only for 0\\n       nums[2] = freq[\\'w\\'-\\'a\\']; // two, only for 2\\n       nums[4] = freq[\\'u\\'-\\'a\\']; // four, only for 4\\n       nums[6] = freq[\\'x\\'-\\'a\\']; // siz, only for 6\\n       nums[8] = freq[\\'g\\'-\\'a\\']; // eight, only for 8\\n       //remaining \\n       nums[1] = freq[\\'o\\'-\\'a\\'] - nums[0] - nums[2] - nums[4]; //for one, common eo in 0, o in 2 & 4 \\n       nums[5] = freq[\\'f\\'-\\'a\\'] - nums[4]; //for five, f occurs in 4\\n       nums[3] = freq[\\'t\\'-\\'a\\'] - nums[2] - nums[8]; //for three, common e in 2 & 8\\n       nums[7] = freq[\\'s\\'-\\'a\\'] - nums[6]; // for seven, common s in 6\\n       nums[9] = freq[\\'i\\'-\\'a\\'] - nums[5] - nums[6] - nums[8]; //nine, i in 5,6,8\\n        \\n       for(int i = 0; i < 10; i++)\\n            for(int j = 0; j < nums[i]; j++) sb.append(i);\\n       return sb.toString();\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711424,
                "title": "c-key-is-observation",
                "content": "**Status**: Accepted \\n**Explanation:**\\n* Wrote a code using loops to check whether we can form numbers! It gave me a TLE.\\n* Then observed that we can find there are some characters unique to each element.\\n1. Zero -> z\\n2. Two -> w\\n3. Four -> u\\n4. Six -> x\\n5. Eight -> g\\n* But can find for other elements! Then read some posts in discuss section and wrote this.\\n* There is no single code or logic. Observation is the key.\\n* I explain for a number. Let\\'s take one. If you take \\'o\\' to represent one, then \\'o\\' also exists in zero, two and four. We already the know the count of two, one, four. \\n\\n**Time Complexity Analysis:**\\n1. Time: O(N)\\n2. Space: O(N)\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> freq(26,0);\\n        \\n        for(char c : s){\\n            freq[c - \\'a\\']++;\\n        }\\n        vector<int> count(10, 0);\\n        count[0] = freq[\\'z\\' - \\'a\\'];\\n        count[2] = freq[\\'w\\' - \\'a\\'];\\n        count[4] = freq[\\'u\\' - \\'a\\'];\\n        count[6] = freq[\\'x\\' - \\'a\\'];\\n        count[8] = freq[\\'g\\' - \\'a\\'];\\n        count[5] = freq[\\'f\\' - \\'a\\'] - count[4];\\n        count[7] = freq[\\'v\\' - \\'a\\'] - count[5];\\n        count[6] = freq[\\'s\\' - \\'a\\'] - count[7];\\n        count[3] = freq[\\'t\\' - \\'a\\'] - count[2] - count[8];\\n        count[1] = freq[\\'o\\' - \\'a\\'] - count[0] - count[2] - count[4];\\n        count[9] = freq[\\'i\\' - \\'a\\'] - count[5] - count[6] - count[8];\\n\\n        string res = \"\"; \\n        int no = 0;\\n        for(int i = 0; i < 10; i++){\\n            res += string(count[i], i + \\'0\\');\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> freq(26,0);\\n        \\n        for(char c : s){\\n            freq[c - \\'a\\']++;\\n        }\\n        vector<int> count(10, 0);\\n        count[0] = freq[\\'z\\' - \\'a\\'];\\n        count[2] = freq[\\'w\\' - \\'a\\'];\\n        count[4] = freq[\\'u\\' - \\'a\\'];\\n        count[6] = freq[\\'x\\' - \\'a\\'];\\n        count[8] = freq[\\'g\\' - \\'a\\'];\\n        count[5] = freq[\\'f\\' - \\'a\\'] - count[4];\\n        count[7] = freq[\\'v\\' - \\'a\\'] - count[5];\\n        count[6] = freq[\\'s\\' - \\'a\\'] - count[7];\\n        count[3] = freq[\\'t\\' - \\'a\\'] - count[2] - count[8];\\n        count[1] = freq[\\'o\\' - \\'a\\'] - count[0] - count[2] - count[4];\\n        count[9] = freq[\\'i\\' - \\'a\\'] - count[5] - count[6] - count[8];\\n\\n        string res = \"\"; \\n        int no = 0;\\n        for(int i = 0; i < 10; i++){\\n            res += string(count[i], i + \\'0\\');\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330720,
                "title": "share-my-java-solution-that-beats-100-time-and-100-space",
                "content": "The core of this algorithm is to find out the unique character of each number. An initial look at the number: \"zero\", \"two\", \"four\", \"five\", \"one\", \"six\", \"seven\", \"eight\", \"three\", \"nine\"\\n\\nz -> zero\\nw -> two\\nu -> four\\nf -> five **(f is not unique to five, but since we have already checked four, then it becomes unique to five)**\\no -> one **(o is not unique to one because zero, two, four they all have \\'o\\', but we have already checked them, then it becomes unique to one)**\\nx -> six\\ns -> seven **(six and seven both have \\'s\\', but we have already checked six, then it becomes unique to seven)**\\ng -> eight\\nt -> three **(two, eight, three have \\'t\\', but we have already checked two and eight, then it becomes unique to three)**\\ni -> nine **(five, six, eight, nine have \\'i\\', but we have already checked five, six and eight, then it becomes unique to nine)**\\n\\nI believe there are other sequences to check these unique identifiers. The core idea is that try to find out unique identifier for each number and count the frequency of them to came up with the solution.\\n\\n```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] table = new int[26];\\n        for (char c : s.toCharArray()) {\\n            table[c - \\'a\\']++;\\n        }\\n        int[] temp = new int[10];\\n        char[] identifiers = new char[] {\\'z\\', \\'w\\', \\'u\\', \\'f\\', \\'o\\', \\'x\\', \\'s\\', \\'g\\', \\'t\\', \\'i\\'};\\n        int[] indexes = new int[] {0, 2, 4, 5, 1, 6, 7, 8, 3, 9};\\n        String[] strs = new String[] {\"zero\", \"two\", \"four\", \"five\", \"one\", \"six\", \"seven\", \"eight\", \"three\", \"nine\"};\\n        for (int i = 0; i < 10; i++) {\\n            char iden = identifiers[i];\\n            int index = indexes[i];\\n            String str = strs[i];\\n            int fre = table[iden - \\'a\\'];\\n            if (fre > 0) {\\n                temp[index] = fre;\\n                for (char c : str.toCharArray()) {\\n                    table[c - \\'a\\'] -= fre;\\n                }\\n            }\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            for (int j = 0; j < temp[i]; j++) {\\n                result.append(i);\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] table = new int[26];\\n        for (char c : s.toCharArray()) {\\n            table[c - \\'a\\']++;\\n        }\\n        int[] temp = new int[10];\\n        char[] identifiers = new char[] {\\'z\\', \\'w\\', \\'u\\', \\'f\\', \\'o\\', \\'x\\', \\'s\\', \\'g\\', \\'t\\', \\'i\\'};\\n        int[] indexes = new int[] {0, 2, 4, 5, 1, 6, 7, 8, 3, 9};\\n        String[] strs = new String[] {\"zero\", \"two\", \"four\", \"five\", \"one\", \"six\", \"seven\", \"eight\", \"three\", \"nine\"};\\n        for (int i = 0; i < 10; i++) {\\n            char iden = identifiers[i];\\n            int index = indexes[i];\\n            String str = strs[i];\\n            int fre = table[iden - \\'a\\'];\\n            if (fre > 0) {\\n                temp[index] = fre;\\n                for (char c : str.toCharArray()) {\\n                    table[c - \\'a\\'] -= fre;\\n                }\\n            }\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            for (int j = 0; j < temp[i]; j++) {\\n                result.append(i);\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118777,
                "title": "the-essence-of-this-item-i-guess-may-be",
                "content": "```\\n\\n```In general situation, it should be transformed into a problem to calculate A from AX=B, matrix X is formed as follows,\\n         //                                             /// efghinorstuvwxz ///\\n        // 0 z e r o        e         o  r            z    100000110000001      \\n        // 1 o n e          e        no                    100001100000000                      \\n        // 2 t w o                    o      t    w         000000100100100        \\n        // 3 t h r e e      e    h       r   t              200100010100000            \\n        // 4 f o u r          f       o  r     u             010000110010000   \\n        // 5 f i v e        e f    i             v            110010000001000                   \\n        // 6 s i x                 i       s        x          000010001000010           \\n        // 7 s e v e n      e        n     s     v        200001001001000        \\n        // 8 e i g h t      e  g h i         t              101110000100000   \\n        // 9 n i n e        e      i n                       100012000000000\\n\\t\\t\\t\\tThen we can use math or back tarce method to figure A out.",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91211,
                "title": "javascript-o-n-solution",
                "content": "```\\nvar originalDigits = function(s) {\\n    const words = { 'z': 'zero', 'x': 'six', 'w': 'two', 'u': 'four', 'g': 'eight', 's': 'seven', 'v': 'five', 'r': 'three', 'o': 'one', 'n': 'nine' };\\n    const nums = { 'z': 0, 'x': 6, 'w': 2, 'u': 4, 'g': 8, 's': 7, 'v': 5, 'r': 3, 'o': 1, 'n': 9 };\\n    let order = 'zxwugsvron';\\n    const counts = {};\\n    for (let c of s) {\\n        counts[c] = (counts[c] || 0) + 1;\\n    }\\n    const res = new Array(10);\\n    for (let key of order) {\\n        while (counts[key]) {\\n            for (let w of words[key]) {\\n                counts[w]--;\\n            }\\n            res[nums[key]] = (res[nums[key]] || '') + nums[key];\\n        }\\n    }\\n    return res.join('');\\n};\\n```\\nNot particularly fast on the OJ histogram but does the job in linear time and space.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar originalDigits = function(s) {\\n    const words = { 'z': 'zero', 'x': 'six', 'w': 'two', 'u': 'four', 'g': 'eight', 's': 'seven', 'v': 'five', 'r': 'three', 'o': 'one', 'n': 'nine' };\\n    const nums = { 'z': 0, 'x': 6, 'w': 2, 'u': 4, 'g': 8, 's': 7, 'v': 5, 'r': 3, 'o': 1, 'n': 9 };\\n    let order = 'zxwugsvron';\\n    const counts = {};\\n    for (let c of s) {\\n        counts[c] = (counts[c] || 0) + 1;\\n    }\\n    const res = new Array(10);\\n    for (let key of order) {\\n        while (counts[key]) {\\n            for (let w of words[key]) {\\n                counts[w]--;\\n            }\\n            res[nums[key]] = (res[nums[key]] || '') + nums[key];\\n        }\\n    }\\n    return res.join('');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91247,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def originalDigits(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        mp = {}\\n        for c in s:\\n           mp.setdefault(c, 0)\\n           mp[c] += 1\\n           \\n        ans = [0] * 10\\n        self.dfs(mp, ans)\\n        return \"\".join([str(num) * ans[num] for num, count in enumerate(ans)])\\n        \\n    def dfs(self, mp, ans):\\n        str_to_digit = [ 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine' ]\\n        while mp != {}:\\n            if 'z' in mp:\\n                t = 0\\n            elif 'w' in mp:\\n                t = 2\\n            elif 'u' in mp:\\n                t = 4\\n            elif 'f' in mp:\\n                t = 5\\n            elif 'x' in mp:\\n                t = 6\\n            elif 'g' in mp:\\n                t = 8\\n            elif 'v' in mp:\\n                t = 7\\n            elif 'o' in mp:\\n                t = 1\\n            elif 't' in mp:\\n                t = 3\\n            else:\\n                t = 9\\n            for c in str_to_digit[t]:\\n                mp[c] -= 1\\n                if mp[c] == 0:\\n                    del mp[c]\\n            ans[t] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def originalDigits(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        mp = {}\\n        for c in s:\\n           mp.setdefault(c, 0)\\n           mp[c] += 1\\n           \\n        ans = [0] * 10\\n        self.dfs(mp, ans)\\n        return \"\".join([str(num) * ans[num] for num, count in enumerate(ans)])\\n        \\n    def dfs(self, mp, ans):\\n        str_to_digit = [ 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine' ]\\n        while mp != {}:\\n            if 'z' in mp:\\n                t = 0\\n            elif 'w' in mp:\\n                t = 2\\n            elif 'u' in mp:\\n                t = 4\\n            elif 'f' in mp:\\n                t = 5\\n            elif 'x' in mp:\\n                t = 6\\n            elif 'g' in mp:\\n                t = 8\\n            elif 'v' in mp:\\n                t = 7\\n            elif 'o' in mp:\\n                t = 1\\n            elif 't' in mp:\\n                t = 3\\n            else:\\n                t = 9\\n            for c in str_to_digit[t]:\\n                mp[c] -= 1\\n                if mp[c] == 0:\\n                    del mp[c]\\n            ans[t] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91249,
                "title": "java-easy-to-understand-explanation",
                "content": "Digits are uniquely identified by their letters as follows: first we eliminate the numbers **z**ero, t**w**o, fo**u**r, si**x,** ei**g**ht which are uniquely identified by their bolded character from all the possible digit strings. Next we  eliminate all occurences of digits: **o**ne, t**h**ree, **f**ive  cause out of the remaining digits these are uniquely identified by their respective bold characters. Lastly we are left with n**i**ne and se**v**en which are again identified by their i and v respectively.\\n\\n\\n\\n\\n                         \\n\\n\\n\\n    \\n    void getDigitByChar(char c, String digitString, int digit,  HashMap<Character,Integer> hm, List<Integer> ret)\\n    {\\n        if(hm.containsKey(c)){\\n            int nr=hm.get(c);\\n            for(char x : digitString.toCharArray()){\\n                hm.put(x, hm.get(x)-nr);\\n                if(hm.get(x)==0) hm.remove(x);\\n            }\\n             while(nr>0){\\n                 ret.add(digit); \\n                 nr--;\\n             }\\n        }\\n    }\\n    \\n    public String originalDigits(String s) \\n    {\\n        List<Integer> ret = new LinkedList<Integer>();\\n        HashMap<Character,Integer> hm = new HashMap<Character,Integer>();\\n        for(char c : s.toCharArray()){\\n            if(!hm.containsKey(c)) hm.put(c,0);\\n            hm.put(c,hm.get(c)+1);\\n        }\\n        getDigitByChar('z',\"zero\",0,hm,ret);\\n        getDigitByChar('w',\"two\",2,hm,ret);\\n        getDigitByChar('u',\"four\",4,hm,ret);\\n        getDigitByChar('x',\"six\",6,hm,ret);\\n        getDigitByChar('g',\"eight\",8,hm,ret);\\n        getDigitByChar('o',\"one\",1,hm,ret);\\n        getDigitByChar('h',\"three\",3,hm,ret);\\n        getDigitByChar('f',\"five\",5,hm,ret);\\n        getDigitByChar('v',\"seven\",7,hm,ret);\\n        getDigitByChar('i',\"nine\",9,hm,ret);\\n    \\n        Collections.sort(ret);\\n        String result=\"\";\\n        for(int x: ret) result+=x;\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Digits are uniquely identified by their letters as follows: first we eliminate the numbers **z**ero, t**w**o, fo**u**r, si**x,** ei**g**ht which are uniquely identified by their bolded character from all the possible digit strings. Next we  eliminate all occurences of digits: **o**ne, t**h**ree, **f**ive  cause out of the remaining digits these are uniquely identified by their respective bold characters. Lastly we are left with n**i**ne and se**v**en which are again identified by their i and v respectively.\\n\\n\\n\\n\\n                         \\n\\n\\n\\n    \\n    void getDigitByChar(char c, String digitString, int digit,  HashMap<Character,Integer> hm, List<Integer> ret)\\n    {\\n        if(hm.containsKey(c)){\\n            int nr=hm.get(c);\\n            for(char x : digitString.toCharArray()){\\n                hm.put(x, hm.get(x)-nr);\\n                if(hm.get(x)==0) hm.remove(x);\\n            }\\n             while(nr>0){\\n                 ret.add(digit); \\n                 nr--;\\n             }\\n        }\\n    }\\n    \\n    public String originalDigits(String s) \\n    {\\n        List<Integer> ret = new LinkedList<Integer>();\\n        HashMap<Character,Integer> hm = new HashMap<Character,Integer>();\\n        for(char c : s.toCharArray()){\\n            if(!hm.containsKey(c)) hm.put(c,0);\\n            hm.put(c,hm.get(c)+1);\\n        }\\n        getDigitByChar('z',\"zero\",0,hm,ret);\\n        getDigitByChar('w',\"two\",2,hm,ret);\\n        getDigitByChar('u',\"four\",4,hm,ret);\\n        getDigitByChar('x',\"six\",6,hm,ret);\\n        getDigitByChar('g',\"eight\",8,hm,ret);\\n        getDigitByChar('o',\"one\",1,hm,ret);\\n        getDigitByChar('h',\"three\",3,hm,ret);\\n        getDigitByChar('f',\"five\",5,hm,ret);\\n        getDigitByChar('v',\"seven\",7,hm,ret);\\n        getDigitByChar('i',\"nine\",9,hm,ret);\\n    \\n        Collections.sort(ret);\\n        String result=\"\";\\n        for(int x: ret) result+=x;\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 91266,
                "title": "simple-o-n-c-made-maths-more-explicit",
                "content": "Each ```unique```'s character corresponds to unique character in the corresponding ```nums``` string and the strings on the right of it.\\n\\n*For example:*\\n&nbsp;&nbsp;3rd character in ```unique``` is ```s```\\n&nbsp;&nbsp;3rd string and strings on the right are \\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```\"seven\", \"eight\", \"five\", \"four\", \"two\", \"three\", \"nine\", \"one\"``` \\n&nbsp;&nbsp;and only ```seven``` has ```s```\\n&nbsp;&nbsp;And so on...\\n\\nThis method is analogous to the *one pass* solution that was posted. Makes the *maths* more explicit is all.\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<string> nums = {\"zero\", \"six\", \"seven\", \"eight\", \"five\", \"four\", \"two\", \"three\", \"nine\", \"one\"};\\n        string unique = \"zxsgvuwtio\";\\n        vector<int> digits = {0, 6, 7, 8, 5, 4, 2, 3, 9, 1};\\n        vector<int> c(10, 0);\\n        string res = \"\";\\n        vector<int> m(26, 0);\\n        for (char ch : s) {\\n            ++m[ch - 'a'];\\n        }\\n        for (int n = 0; n < nums.size(); ++n) {\\n            int count = c[digits[n]] = m[unique[n] - 'a'];\\n            for (auto ch : nums[n]) {\\n                m[ch - 'a'] -= count;\\n            }\\n            \\n        }\\n        \\n        for (int i = 0; i < 10; ++i) {\\n            for (int k = 0; k < c[i]; ++k) {\\n                res += to_string(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```unique```\n```nums```\n```unique```\n```s```\n```\"seven\", \"eight\", \"five\", \"four\", \"two\", \"three\", \"nine\", \"one\"```\n```seven```\n```s```\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<string> nums = {\"zero\", \"six\", \"seven\", \"eight\", \"five\", \"four\", \"two\", \"three\", \"nine\", \"one\"};\\n        string unique = \"zxsgvuwtio\";\\n        vector<int> digits = {0, 6, 7, 8, 5, 4, 2, 3, 9, 1};\\n        vector<int> c(10, 0);\\n        string res = \"\";\\n        vector<int> m(26, 0);\\n        for (char ch : s) {\\n            ++m[ch - 'a'];\\n        }\\n        for (int n = 0; n < nums.size(); ++n) {\\n            int count = c[digits[n]] = m[unique[n] - 'a'];\\n            for (auto ch : nums[n]) {\\n                m[ch - 'a'] -= count;\\n            }\\n            \\n        }\\n        \\n        for (int i = 0; i < 10; ++i) {\\n            for (int k = 0; k < c[i]; ++k) {\\n                res += to_string(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814870,
                "title": "javascript-423-reconstruct-original-digits-from-english",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nEvery number has a unique letter\\n. for two, there is \\'w\\' in it\\n. for four, three is \\'u\\' in it\\nEspecially true, if you do in sequence ( given below )\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar originalDigits = function (s) {\\n  let arr = [\\n    // from top to bottom\\n    // [digit, digit in words,  \\'unique letter\\' in \\'digit in words\\'  ]\\n    [0, \"zero\", \"z\"], // z is unique letter in zero - if we see from top to bottom of this list\\n    [6, \"six\", \"x\"], //  x is unique letter in six - if we see from top to bottom\\n    [2, \"two\", \"w\"], //  w is unique letter in two\\n    [8, \"eight\", \"g\"],\\n    [4, \"four\", \"u\"],\\n    [3, \"three\", \"r\"],\\n    [5, \"five\", \"f\"],\\n    [7, \"seven\", \"v\"],\\n    [9, \"nine\", \"i\"],\\n    [1, \"one\", \"o\"],\\n  ];\\n\\n  let f = {} // frequency of every char\\n  for (let ch of s)\\n    f[ch] = (f[ch] || 0) + 1    // calc frequency of every char of every word\\n\\n  let an = [];\\n  for (let [n, w, uniq_char_in_w] of arr) {\\n\\n    // while a new next digit is repeatedly found\\n    while (f[uniq_char_in_w]) {\\n      // found this digit ( again )\\n      an.push(n);\\n\\n      // remove this digit\\'s word frequency\\n      for (let ch of w)\\n        f[ch] = (f[ch] || 0) - 1\\n    }\\n  }\\n\\n  // all digits found\\n  an.sort((a, b) => a - b);\\n\\n  return an.join(\"\"); // return as string\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar originalDigits = function (s) {\\n  let arr = [\\n    // from top to bottom\\n    // [digit, digit in words,  \\'unique letter\\' in \\'digit in words\\'  ]\\n    [0, \"zero\", \"z\"], // z is unique letter in zero - if we see from top to bottom of this list\\n    [6, \"six\", \"x\"], //  x is unique letter in six - if we see from top to bottom\\n    [2, \"two\", \"w\"], //  w is unique letter in two\\n    [8, \"eight\", \"g\"],\\n    [4, \"four\", \"u\"],\\n    [3, \"three\", \"r\"],\\n    [5, \"five\", \"f\"],\\n    [7, \"seven\", \"v\"],\\n    [9, \"nine\", \"i\"],\\n    [1, \"one\", \"o\"],\\n  ];\\n\\n  let f = {} // frequency of every char\\n  for (let ch of s)\\n    f[ch] = (f[ch] || 0) + 1    // calc frequency of every char of every word\\n\\n  let an = [];\\n  for (let [n, w, uniq_char_in_w] of arr) {\\n\\n    // while a new next digit is repeatedly found\\n    while (f[uniq_char_in_w]) {\\n      // found this digit ( again )\\n      an.push(n);\\n\\n      // remove this digit\\'s word frequency\\n      for (let ch of w)\\n        f[ch] = (f[ch] || 0) - 1\\n    }\\n  }\\n\\n  // all digits found\\n  an.sort((a, b) => a - b);\\n\\n  return an.join(\"\"); // return as string\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683847,
                "title": "easy-to-understand-c-solution-using-maps",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        map<char,int> m;\\n        int n = s.size();\\n        string ans = \"\";\\n        map<int,char> temp;\\n    \\n        for(int i=0; i<n; i++)\\n        {\\n            m[s[i]]++;\\n        }\\n\\n        vector<int> nums_total(10); //contains frequency of 0-9\\n\\n        nums_total[0] = m[\\'z\\'];\\n        m[\\'e\\'] -= m[\\'z\\'];\\n        m[\\'r\\'] -= m[\\'z\\'];\\n        m[\\'o\\'] -= m[\\'z\\'];\\n        m[\\'z\\'] -= m[\\'z\\'];\\n\\n        nums_total[2] = m[\\'w\\'];\\n        m[\\'t\\'] -= m[\\'w\\'];\\n        m[\\'o\\'] -= m[\\'w\\'];\\n        m[\\'w\\'] -= m[\\'w\\'];\\n    \\n        nums_total[4] = m[\\'u\\'];\\n        m[\\'f\\'] -= m[\\'u\\'];\\n        m[\\'o\\'] -= m[\\'u\\'];\\n        m[\\'r\\'] -= m[\\'u\\']; \\n        m[\\'u\\'] -= m[\\'u\\'];\\n\\n        nums_total[6] = m[\\'x\\'];\\n        m[\\'s\\'] -= m[\\'x\\'];\\n        m[\\'i\\'] -= m[\\'x\\'];\\n        m[\\'x\\'] -= m[\\'x\\'];\\n\\n        nums_total[8] = m[\\'g\\'];\\n        m[\\'e\\'] -= m[\\'g\\'];\\n        m[\\'i\\'] -= m[\\'g\\'];\\n        m[\\'h\\'] -= m[\\'g\\'];\\n        m[\\'t\\'] -= m[\\'g\\'];\\n        m[\\'g\\'] -= m[\\'g\\'];\\n    \\n        nums_total[3] = m[\\'h\\'];    //now remaining h is for three\\n        m[\\'t\\'] -= m[\\'h\\'];\\n        m[\\'r\\'] -= m[\\'h\\'];\\n        m[\\'e\\'] -= m[\\'h\\'];\\n        m[\\'e\\'] -= m[\\'h\\'];\\n        m[\\'h\\'] -= m[\\'h\\'];\\n     \\n        nums_total[5] = m[\\'f\\'];     //now remaining f is for five\\n        m[\\'i\\'] -= m[\\'f\\'];\\n        m[\\'v\\'] -= m[\\'f\\'];\\n        m[\\'e\\'] -= m[\\'f\\'];\\n        m[\\'f\\'] -= m[\\'f\\'];\\n\\n        nums_total[9] = m[\\'i\\'];\\n        m[\\'n\\'] -= m[\\'i\\'];\\n        m[\\'n\\'] -= m[\\'i\\'];\\n        m[\\'e\\'] -= m[\\'i\\'];\\n        m[\\'i\\'] -= m[\\'i\\'];\\n\\n        nums_total[1] = m[\\'o\\'];\\n        m[\\'n\\'] -= m[\\'o\\'];\\n        m[\\'e\\'] -= m[\\'o\\'];\\n        m[\\'o\\'] -= m[\\'o\\'];\\n\\n        nums_total[7] = m[\\'v\\'];\\n        m[\\'s\\'] -= m[\\'v\\'];\\n        m[\\'e\\'] -= m[\\'v\\'];\\n        m[\\'n\\'] -= m[\\'v\\'];\\n        m[\\'v\\'] -= m[\\'v\\'];\\n\\n        temp[0] = \\'0\\';\\n        temp[1] = \\'1\\';\\n        temp[2] = \\'2\\';\\n        temp[3] = \\'3\\';\\n        temp[4] = \\'4\\';\\n        temp[5] = \\'5\\';\\n        temp[6] = \\'6\\';\\n        temp[7] = \\'7\\';\\n        temp[8] = \\'8\\';\\n        temp[9] = \\'9\\';\\n\\n        for(int i=0; i<=9; i++)\\n        {\\n            for(int j=0; j<nums_total[i]; j++)\\n            {\\n                ans += temp[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        map<char,int> m;\\n        int n = s.size();\\n        string ans = \"\";\\n        map<int,char> temp;\\n    \\n        for(int i=0; i<n; i++)\\n        {\\n            m[s[i]]++;\\n        }\\n\\n        vector<int> nums_total(10); //contains frequency of 0-9\\n\\n        nums_total[0] = m[\\'z\\'];\\n        m[\\'e\\'] -= m[\\'z\\'];\\n        m[\\'r\\'] -= m[\\'z\\'];\\n        m[\\'o\\'] -= m[\\'z\\'];\\n        m[\\'z\\'] -= m[\\'z\\'];\\n\\n        nums_total[2] = m[\\'w\\'];\\n        m[\\'t\\'] -= m[\\'w\\'];\\n        m[\\'o\\'] -= m[\\'w\\'];\\n        m[\\'w\\'] -= m[\\'w\\'];\\n    \\n        nums_total[4] = m[\\'u\\'];\\n        m[\\'f\\'] -= m[\\'u\\'];\\n        m[\\'o\\'] -= m[\\'u\\'];\\n        m[\\'r\\'] -= m[\\'u\\']; \\n        m[\\'u\\'] -= m[\\'u\\'];\\n\\n        nums_total[6] = m[\\'x\\'];\\n        m[\\'s\\'] -= m[\\'x\\'];\\n        m[\\'i\\'] -= m[\\'x\\'];\\n        m[\\'x\\'] -= m[\\'x\\'];\\n\\n        nums_total[8] = m[\\'g\\'];\\n        m[\\'e\\'] -= m[\\'g\\'];\\n        m[\\'i\\'] -= m[\\'g\\'];\\n        m[\\'h\\'] -= m[\\'g\\'];\\n        m[\\'t\\'] -= m[\\'g\\'];\\n        m[\\'g\\'] -= m[\\'g\\'];\\n    \\n        nums_total[3] = m[\\'h\\'];    //now remaining h is for three\\n        m[\\'t\\'] -= m[\\'h\\'];\\n        m[\\'r\\'] -= m[\\'h\\'];\\n        m[\\'e\\'] -= m[\\'h\\'];\\n        m[\\'e\\'] -= m[\\'h\\'];\\n        m[\\'h\\'] -= m[\\'h\\'];\\n     \\n        nums_total[5] = m[\\'f\\'];     //now remaining f is for five\\n        m[\\'i\\'] -= m[\\'f\\'];\\n        m[\\'v\\'] -= m[\\'f\\'];\\n        m[\\'e\\'] -= m[\\'f\\'];\\n        m[\\'f\\'] -= m[\\'f\\'];\\n\\n        nums_total[9] = m[\\'i\\'];\\n        m[\\'n\\'] -= m[\\'i\\'];\\n        m[\\'n\\'] -= m[\\'i\\'];\\n        m[\\'e\\'] -= m[\\'i\\'];\\n        m[\\'i\\'] -= m[\\'i\\'];\\n\\n        nums_total[1] = m[\\'o\\'];\\n        m[\\'n\\'] -= m[\\'o\\'];\\n        m[\\'e\\'] -= m[\\'o\\'];\\n        m[\\'o\\'] -= m[\\'o\\'];\\n\\n        nums_total[7] = m[\\'v\\'];\\n        m[\\'s\\'] -= m[\\'v\\'];\\n        m[\\'e\\'] -= m[\\'v\\'];\\n        m[\\'n\\'] -= m[\\'v\\'];\\n        m[\\'v\\'] -= m[\\'v\\'];\\n\\n        temp[0] = \\'0\\';\\n        temp[1] = \\'1\\';\\n        temp[2] = \\'2\\';\\n        temp[3] = \\'3\\';\\n        temp[4] = \\'4\\';\\n        temp[5] = \\'5\\';\\n        temp[6] = \\'6\\';\\n        temp[7] = \\'7\\';\\n        temp[8] = \\'8\\';\\n        temp[9] = \\'9\\';\\n\\n        for(int i=0; i<=9; i++)\\n        {\\n            for(int j=0; j<nums_total[i]; j++)\\n            {\\n                ans += temp[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000399,
                "title": "python-solution-using-gaussian-elimination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can list 15 equations and use Gaussian Elimination to solve them.\\n\\nThe matrix M in the code is the coefficient matrix. It represents `i-th` charactor occurs `M[i][j]` times in digit `j`. For example, M[0][7] = 2, means the 0-th charactor `\\'e\\'` occurs 2 times in the digit 7 (`seven`).\\n\\nThen we can have:\\n```\\nM[0][0] * X0 + M[0][1] * X1 + ... M[0][9] * X9 = Count(\\'e\\')\\nM[1][0] * X0 + M[1][1] * X1 + ... M[1][9] * X9 = Count(\\'g\\')\\n...\\nM[14][0] * X0 + M[14][1] * X1 + ... M[14][9] * X9 = Count(\\'z\\')\\n\\n```\\nIn which the `Xi` is how many times the digit `i` occur.\\n\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nM = [\\n#    0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\n    [1, 1, 0, 2, 0, 1, 0, 2, 1, 1], # e\\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], # g\\n    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], # f\\n    [0, 0, 0, 0, 0, 1, 1, 0, 1, 1], # i\\n    [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], # h\\n    [1, 1, 1, 0, 1, 0, 0, 0, 0, 0], # o\\n    [0, 1, 0, 0, 0, 0, 0, 1, 0, 2], # n\\n    [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], # s\\n    [1, 0, 0, 1, 1, 0, 0, 0, 0, 0], # r\\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], # u\\n    [0, 0, 1, 1, 0, 0, 0, 0, 1, 0], # t\\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], # w\\n    [0, 0, 0, 0, 0, 1, 0, 1, 0, 0], # v\\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], # x\\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0], # z\\n]\\n\\ndef gauss(mx):\\n    n, m = len(mx), len(mx[0])\\n    for i in range(m-1):\\n        for j in range(i+1, n):\\n            if mx[j][i] != 0:\\n                mx[i], mx[j] = mx[j], mx[i]\\n                break\\n        if mx[i][i] == 0:\\n            return \"\"\\n        for j in range(n):\\n            if j == i: continue\\n            d = - mx[j][i] / mx[i][i]\\n            for k in range(m):\\n                mx[j][k] += d * mx[i][k]\\n    return [(mx[i][-1] / mx[i][i]) for i in range(m-1)]\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        chSet = \"egfihonsrutwvxz\"\\n        cc = Counter(s)\\n        mx = [M[i][::] + [cc.get(chSet[i], 0)]for i in range(15)]\\n        res = gauss(mx)\\n        # res[i] need to be rounded to nearest integer.\\n        return \\'\\'.join([str(i) * int(res[i]+0.5) for i in range(10)])\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nM[0][0] * X0 + M[0][1] * X1 + ... M[0][9] * X9 = Count(\\'e\\')\\nM[1][0] * X0 + M[1][1] * X1 + ... M[1][9] * X9 = Count(\\'g\\')\\n...\\nM[14][0] * X0 + M[14][1] * X1 + ... M[14][9] * X9 = Count(\\'z\\')\\n\\n```\n```\\nfrom collections import Counter\\n\\nM = [\\n#    0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\n    [1, 1, 0, 2, 0, 1, 0, 2, 1, 1], # e\\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], # g\\n    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], # f\\n    [0, 0, 0, 0, 0, 1, 1, 0, 1, 1], # i\\n    [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], # h\\n    [1, 1, 1, 0, 1, 0, 0, 0, 0, 0], # o\\n    [0, 1, 0, 0, 0, 0, 0, 1, 0, 2], # n\\n    [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], # s\\n    [1, 0, 0, 1, 1, 0, 0, 0, 0, 0], # r\\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], # u\\n    [0, 0, 1, 1, 0, 0, 0, 0, 1, 0], # t\\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], # w\\n    [0, 0, 0, 0, 0, 1, 0, 1, 0, 0], # v\\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], # x\\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0], # z\\n]\\n\\ndef gauss(mx):\\n    n, m = len(mx), len(mx[0])\\n    for i in range(m-1):\\n        for j in range(i+1, n):\\n            if mx[j][i] != 0:\\n                mx[i], mx[j] = mx[j], mx[i]\\n                break\\n        if mx[i][i] == 0:\\n            return \"\"\\n        for j in range(n):\\n            if j == i: continue\\n            d = - mx[j][i] / mx[i][i]\\n            for k in range(m):\\n                mx[j][k] += d * mx[i][k]\\n    return [(mx[i][-1] / mx[i][i]) for i in range(m-1)]\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        chSet = \"egfihonsrutwvxz\"\\n        cc = Counter(s)\\n        mx = [M[i][::] + [cc.get(chSet[i], 0)]for i in range(15)]\\n        res = gauss(mx)\\n        # res[i] need to be rounded to nearest integer.\\n        return \\'\\'.join([str(i) * int(res[i]+0.5) for i in range(10)])\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750201,
                "title": "python-dictionaries-function-beats-60",
                "content": "Here\\'s my solution that uses two dictionaries and a re-usable function. It has lots of comments and explanations to make it easier to understand. I\\'m new to LeetCode and trying to get more interactions here. What did you think of my code? Suggestions for improvements? Thanks!\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str\\n\\n\\t\\t# Iterate through string s\\n\\t\\t# to build up dictionary of keys: letter, values: how many occurrences\\n\\t\\tletters_frequencies = dict() # initialize dictionary\\n\\n\\t\\tfor character in s:\\n\\t\\t\\tif character not in letters_frequencies.keys(): # has not counted it before\\n\\t\\t\\t\\tletters_frequencies[character] = 1\\n\\t\\t\\telse: # it already showed up at least once, so add 1 to the total count\\n\\t\\t\\t\\tletters_frequencies[character] += 1\\n\\n\\t\\t# We will build the answer from a second dictioary:\\n\\t\\t# keys: number words, values: how many times they are found in s\\n\\t\\twords_frequencies = dict()\\n\\n\\t\\t# Make a reusable function that removes a given number from the string s \\n\\t\\t# in terms of all of its letters, adjusting how many of those letters still\\n\\t\\t# remain, and storing how many times that number appeared\\n\\n\\t\\tdef remove_number(letter: str, word: str, value: int):\\n\\t\\t\\t\\'\\'\\' This function will take note of a letter that can uniquely identify\\n\\t\\t\\thow many times a given number word occurs in string s, at that point in \\n\\t\\t\\tthe program\\'s operation. (Specifity improves as this function is used more times)\\n\\n\\t\\t\\tThis \\'letter\\' is a one character string. This function will also account for \\n\\t\\t\\tremoving all the other letters (associated with that number word) from the \\n\\t\\t\\tstring s, in terms of updating the dictionary counts for how many times a\\n\\t\\t\\tgiven letter still occurs in string s (with its number word source not yet \\n\\t\\t\\taccounted for and removed as of yet)\\n\\n\\t\\t\\tThis function does this by iterating through the multi character string\\n\\t\\t\\t\\'word\\'. It also stores how many times the number word occurred in the \\n\\t\\t\\tstring s. It stores this in the words_frequencies dictionary with the key\\n\\t\\t\\tas the integer value of the word. \\n\\n\\t\\t\\tFor instance, for the actual parameters (\\'z\\', \\'zero\\', 0) it works like these\\n\\t\\t\\tactions as the following code (original attempt before using this function):\\n\\t\\t\\tNOTE that it also checks if the letter is there (matters at Part 2 and later)\\n\\n\\t\\t\\tif \\'z\\' in letters_frequencies.keys():\\n\\t\\t\\t\\t how_many_zeroes = letters_frequencies[\\'z\\']\\n\\t\\t\\t# make sure that letters used up in \\'zero\\' appearances are not counted later (e,r,o)\\n\\t\\t\\t\\t letters_frequencies[\\'z\\'] -= how_many_zeroes \\n\\t\\t\\t# not necessary since z truly unique, never seen elsewhere, but illustrates the process\\n\\t\\t\\t\\t# note that removing non-unique letters can matter later on\\n\\t\\t\\t\\t# we don\\'t want to double count letters (used up by zero)\\n\\t\\t\\t\\t letters_frequencies[\\'e\\'] -= how_many_zeroes \\n\\t\\t\\t\\t letters_frequencies[\\'r\\'] -= how_many_zeroes \\n\\t\\t\\t\\t letters_frequencies[\\'o\\'] -= how_many_zeroes\\n\\t\\t\\t\\t words_frequencies[0] = how_many_zeroes # record how many times zero appeared   \\n\\t\\t\\t \\'\\'\\'\\n\\t\\t\\tif letter in letters_frequencies.keys(): \\n\\t\\t\\t\\t# important since in some strings s a number word and its characteristic letter never appear\\n\\t\\t\\t\\thow_many_number_words = letters_frequencies[letter] # uniquely identifying letter\\n\\t\\t\\t\\tfor character in word:\\n\\t\\t\\t\\t\\tif character in letters_frequencies:\\n\\t\\t\\t\\t\\t# updates letter frequencies\\n\\t\\t\\t\\t\\t\\tletters_frequencies[character] -= how_many_number_words \\n\\t\\t\\t\\t\\t# how many times number word appears, key: int\\n\\t\\t\\t\\t\\t\\twords_frequencies[value] = how_many_number_words \\n\\n\\t\\t# First note that since s is guaranteed to be valid, we start by looking for truly unique letters\\n\\t\\t# where unique letters are letters that only appear in a single number word no matter what\\n\\n\\t\\t# Part 1: Deal with number words identifiable by unique letters\\n\\t\\t# zero: z, two: w, six: x, eight: g\\n\\t\\tremove_number(\\'z\\', \\'zero\\', 0)\\n\\t\\tremove_number(\\'w\\', \\'two\\', 2)\\n\\t\\tremove_number(\\'x\\', \\'six\\', 6)\\n\\t\\tremove_number(\\'g\\', \\'eight\\', 8)\\n\\n\\t\\t# Part 2: now the only remaining letters in s are resulting from one,three,four,five,seven,nine\\n\\t\\t# meaning that three is the only source of remaining letter h found in string s\\n\\t\\t# and that seven is the only source of remaining letter s found in string s\\n\\t\\tremove_number(\\'h\\', \\'three\\', 3)\\n\\t\\tremove_number(\\'s\\', \\'seven\\', 7)\\n\\n\\t\\t# Part 3: now the only remaining letters in s are resulting from one,four,five,nine\\n\\t\\t# meaning that four is the only remaining source of letter r found in string s\\n\\t\\t# and that five is the only source of remianing letter v found in string s\\n\\t\\tremove_number(\\'r\\', \\'four\\', 4)\\n\\t\\tremove_number(\\'v\\', \\'five\\', 5)\\n\\n\\t\\t# Part 4: now the only remaining letters in s are resulting from one,nine\\n\\t\\t# meaning that one is the only source of the remaining letter o found in string s \\n\\t\\t# and that nine is the only source of the remaining letter i found in string s\\n\\t\\tremove_number(\\'o\\', \\'one\\', 1)\\n\\t\\tremove_number(\\'i\\', \\'nine\\', 9)\\n\\n\\t\\t# Part 5: Now the dictionary words_frequencies with integer digits as keys and \\n\\t\\t# number word frequencies as values is used to build the output in ascending order\\n\\t\\tascending_digits = sorted(words_frequencies.keys()) # get integers low to high\\n\\t\\tanswer = \\'\\' # build answer string from concatenation starting with empty string\\n\\t\\tfor digit in ascending_digits:\\n\\t\\t\\thow_many_of_digit = words_frequencies[digit]\\n\\t\\t\\tanswer += how_many_of_digit * str(digit) # need answer as a string\\n\\t\\treturn answer",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here\\'s my solution that uses two dictionaries and a re-usable function. It has lots of comments and explanations to make it easier to understand. I\\'m new to LeetCode and trying to get more interactions here. What did you think of my code? Suggestions for improvements? Thanks!\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str\\n\\n\\t\\t# Iterate through string s\\n\\t\\t# to build up dictionary of keys: letter, values: how many occurrences\\n\\t\\tletters_frequencies = dict() # initialize dictionary\\n\\n\\t\\tfor character in s:\\n\\t\\t\\tif character not in letters_frequencies.keys(): # has not counted it before\\n\\t\\t\\t\\tletters_frequencies[character] = 1\\n\\t\\t\\telse: # it already showed up at least once, so add 1 to the total count\\n\\t\\t\\t\\tletters_frequencies[character] += 1\\n\\n\\t\\t# We will build the answer from a second dictioary:\\n\\t\\t# keys: number words, values: how many times they are found in s\\n\\t\\twords_frequencies = dict()\\n\\n\\t\\t# Make a reusable function that removes a given number from the string s \\n\\t\\t# in terms of all of its letters, adjusting how many of those letters still\\n\\t\\t# remain, and storing how many times that number appeared\\n\\n\\t\\tdef remove_number(letter: str, word: str, value: int):\\n\\t\\t\\t\\'\\'\\' This function will take note of a letter that can uniquely identify\\n\\t\\t\\thow many times a given number word occurs in string s, at that point in \\n\\t\\t\\tthe program\\'s operation. (Specifity improves as this function is used more times)\\n\\n\\t\\t\\tThis \\'letter\\' is a one character string. This function will also account for \\n\\t\\t\\tremoving all the other letters (associated with that number word) from the \\n\\t\\t\\tstring s, in terms of updating the dictionary counts for how many times a\\n\\t\\t\\tgiven letter still occurs in string s (with its number word source not yet \\n\\t\\t\\taccounted for and removed as of yet)\\n\\n\\t\\t\\tThis function does this by iterating through the multi character string\\n\\t\\t\\t\\'word\\'. It also stores how many times the number word occurred in the \\n\\t\\t\\tstring s. It stores this in the words_frequencies dictionary with the key\\n\\t\\t\\tas the integer value of the word. \\n\\n\\t\\t\\tFor instance, for the actual parameters (\\'z\\', \\'zero\\', 0) it works like these\\n\\t\\t\\tactions as the following code (original attempt before using this function):\\n\\t\\t\\tNOTE that it also checks if the letter is there (matters at Part 2 and later)\\n\\n\\t\\t\\tif \\'z\\' in letters_frequencies.keys():\\n\\t\\t\\t\\t how_many_zeroes = letters_frequencies[\\'z\\']\\n\\t\\t\\t# make sure that letters used up in \\'zero\\' appearances are not counted later (e,r,o)\\n\\t\\t\\t\\t letters_frequencies[\\'z\\'] -= how_many_zeroes \\n\\t\\t\\t# not necessary since z truly unique, never seen elsewhere, but illustrates the process\\n\\t\\t\\t\\t# note that removing non-unique letters can matter later on\\n\\t\\t\\t\\t# we don\\'t want to double count letters (used up by zero)\\n\\t\\t\\t\\t letters_frequencies[\\'e\\'] -= how_many_zeroes \\n\\t\\t\\t\\t letters_frequencies[\\'r\\'] -= how_many_zeroes \\n\\t\\t\\t\\t letters_frequencies[\\'o\\'] -= how_many_zeroes\\n\\t\\t\\t\\t words_frequencies[0] = how_many_zeroes # record how many times zero appeared   \\n\\t\\t\\t \\'\\'\\'\\n\\t\\t\\tif letter in letters_frequencies.keys(): \\n\\t\\t\\t\\t# important since in some strings s a number word and its characteristic letter never appear\\n\\t\\t\\t\\thow_many_number_words = letters_frequencies[letter] # uniquely identifying letter\\n\\t\\t\\t\\tfor character in word:\\n\\t\\t\\t\\t\\tif character in letters_frequencies:\\n\\t\\t\\t\\t\\t# updates letter frequencies\\n\\t\\t\\t\\t\\t\\tletters_frequencies[character] -= how_many_number_words \\n\\t\\t\\t\\t\\t# how many times number word appears, key: int\\n\\t\\t\\t\\t\\t\\twords_frequencies[value] = how_many_number_words \\n\\n\\t\\t# First note that since s is guaranteed to be valid, we start by looking for truly unique letters\\n\\t\\t# where unique letters are letters that only appear in a single number word no matter what\\n\\n\\t\\t# Part 1: Deal with number words identifiable by unique letters\\n\\t\\t# zero: z, two: w, six: x, eight: g\\n\\t\\tremove_number(\\'z\\', \\'zero\\', 0)\\n\\t\\tremove_number(\\'w\\', \\'two\\', 2)\\n\\t\\tremove_number(\\'x\\', \\'six\\', 6)\\n\\t\\tremove_number(\\'g\\', \\'eight\\', 8)\\n\\n\\t\\t# Part 2: now the only remaining letters in s are resulting from one,three,four,five,seven,nine\\n\\t\\t# meaning that three is the only source of remaining letter h found in string s\\n\\t\\t# and that seven is the only source of remaining letter s found in string s\\n\\t\\tremove_number(\\'h\\', \\'three\\', 3)\\n\\t\\tremove_number(\\'s\\', \\'seven\\', 7)\\n\\n\\t\\t# Part 3: now the only remaining letters in s are resulting from one,four,five,nine\\n\\t\\t# meaning that four is the only remaining source of letter r found in string s\\n\\t\\t# and that five is the only source of remianing letter v found in string s\\n\\t\\tremove_number(\\'r\\', \\'four\\', 4)\\n\\t\\tremove_number(\\'v\\', \\'five\\', 5)\\n\\n\\t\\t# Part 4: now the only remaining letters in s are resulting from one,nine\\n\\t\\t# meaning that one is the only source of the remaining letter o found in string s \\n\\t\\t# and that nine is the only source of the remaining letter i found in string s\\n\\t\\tremove_number(\\'o\\', \\'one\\', 1)\\n\\t\\tremove_number(\\'i\\', \\'nine\\', 9)\\n\\n\\t\\t# Part 5: Now the dictionary words_frequencies with integer digits as keys and \\n\\t\\t# number word frequencies as values is used to build the output in ascending order\\n\\t\\tascending_digits = sorted(words_frequencies.keys()) # get integers low to high\\n\\t\\tanswer = \\'\\' # build answer string from concatenation starting with empty string\\n\\t\\tfor digit in ascending_digits:\\n\\t\\t\\thow_many_of_digit = words_frequencies[digit]\\n\\t\\t\\tanswer += how_many_of_digit * str(digit) # need answer as a string\\n\\t\\treturn answer",
                "codeTag": "Java"
            },
            {
                "id": 2684369,
                "title": "python-o-n-ugly-solution",
                "content": "Ugly brute force solution\\n\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        dic = {}\\n        nums = {}\\n        \\n        for i in s:\\n            if i in dic:\\n                dic[i]+= 1\\n            else:\\n                dic[i] = 1\\n        \\n        # in this dictionary we need to search for all possible 1-9\\n        #get all 0s out\\n        n = dic.get(\\'z\\', 0)\\n        if n > 0:\\n            nums[0] = n\\n            dic[\\'z\\'] -= n\\n            dic[\\'e\\'] -= n\\n            dic[\\'r\\'] -= n\\n            dic[\\'o\\'] -= n\\n        \\n        #get all 2s out\\n        n = dic.get(\\'w\\', 0)\\n        if n > 0:\\n            nums[2] = n\\n            dic[\\'t\\'] -= n\\n            dic[\\'w\\'] -= n\\n            dic[\\'o\\'] -= n\\n        \\n        #get all 6s out\\n        n = dic.get(\\'x\\', 0)\\n        if n > 0:\\n            nums[6] = n\\n            dic[\\'s\\'] -= n\\n            dic[\\'i\\'] -= n\\n            dic[\\'x\\'] -= n\\n        \\n        #get all 7s out\\n        n = dic.get(\\'s\\', 0)\\n        if n > 0:\\n            nums[7] = n\\n            dic[\\'s\\'] -= n\\n            dic[\\'e\\'] -= n\\n            dic[\\'v\\'] -= n\\n            dic[\\'e\\'] -= n\\n            dic[\\'n\\'] -= n\\n        \\n        #get all 8s out\\n        n = dic.get(\\'g\\', 0)\\n        if n > 0:\\n            nums[8] = n\\n            dic[\\'e\\'] -= n\\n            dic[\\'i\\'] -= n\\n            dic[\\'g\\'] -= n\\n            dic[\\'h\\'] -= n\\n            dic[\\'t\\'] -= n\\n        \\n        #get all 4s out\\n        n = dic.get(\\'u\\', 0)\\n        if n > 0:\\n            nums[4] = n\\n            dic[\\'f\\'] -= n\\n            dic[\\'o\\'] -= n\\n            dic[\\'u\\'] -= n\\n            dic[\\'r\\'] -= n\\n            \\n        #get all 5s out\\n        n = dic.get(\\'f\\', 0)\\n        if n > 0:\\n            nums[5] = n\\n            dic[\\'f\\'] -= n\\n            dic[\\'i\\'] -= n\\n            dic[\\'v\\'] -= n\\n            dic[\\'e\\'] -= n\\n        \\n        #get all 3s out\\n        n = dic.get(\\'r\\', 0)\\n        if n > 0:\\n            nums[3] = n\\n            dic[\\'t\\'] -= n\\n            dic[\\'h\\'] -= n\\n            dic[\\'r\\'] -= n\\n            dic[\\'e\\'] -= n\\n            dic[\\'e\\'] -= n \\n\\n        #get all 1s out\\n        n = dic.get(\\'o\\', 0)\\n        if n > 0:\\n            nums[1] = n\\n            dic[\\'o\\'] -= n\\n            dic[\\'n\\'] -= n\\n            dic[\\'e\\'] -= n\\n        \\n        #get all 9s out\\n        n = dic.get(\\'e\\', 0)\\n        if n > 0:\\n            nums[9] = n\\n            dic[\\'n\\'] -= n\\n            dic[\\'i\\'] -= n\\n            dic[\\'n\\'] -= n\\n            dic[\\'e\\'] -= n\\n        \\n        s = \\'\\'\\n        for i in range(10):\\n            if i in nums:\\n                s += str(i)*nums[i]\\n        \\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        dic = {}\\n        nums = {}\\n        \\n        for i in s:\\n            if i in dic:\\n                dic[i]+= 1\\n            else:\\n                dic[i] = 1\\n        \\n        # in this dictionary we need to search for all possible 1-9\\n        #get all 0s out\\n        n = dic.get(\\'z\\', 0)\\n        if n > 0:\\n            nums[0] = n\\n            dic[\\'z\\'] -= n\\n            dic[\\'e\\'] -= n\\n            dic[\\'r\\'] -= n\\n            dic[\\'o\\'] -= n\\n        \\n        #get all 2s out\\n        n = dic.get(\\'w\\', 0)\\n        if n > 0:\\n            nums[2] = n\\n            dic[\\'t\\'] -= n\\n            dic[\\'w\\'] -= n\\n            dic[\\'o\\'] -= n\\n        \\n        #get all 6s out\\n        n = dic.get(\\'x\\', 0)\\n        if n > 0:\\n            nums[6] = n\\n            dic[\\'s\\'] -= n\\n            dic[\\'i\\'] -= n\\n            dic[\\'x\\'] -= n\\n        \\n        #get all 7s out\\n        n = dic.get(\\'s\\', 0)\\n        if n > 0:\\n            nums[7] = n\\n            dic[\\'s\\'] -= n\\n            dic[\\'e\\'] -= n\\n            dic[\\'v\\'] -= n\\n            dic[\\'e\\'] -= n\\n            dic[\\'n\\'] -= n\\n        \\n        #get all 8s out\\n        n = dic.get(\\'g\\', 0)\\n        if n > 0:\\n            nums[8] = n\\n            dic[\\'e\\'] -= n\\n            dic[\\'i\\'] -= n\\n            dic[\\'g\\'] -= n\\n            dic[\\'h\\'] -= n\\n            dic[\\'t\\'] -= n\\n        \\n        #get all 4s out\\n        n = dic.get(\\'u\\', 0)\\n        if n > 0:\\n            nums[4] = n\\n            dic[\\'f\\'] -= n\\n            dic[\\'o\\'] -= n\\n            dic[\\'u\\'] -= n\\n            dic[\\'r\\'] -= n\\n            \\n        #get all 5s out\\n        n = dic.get(\\'f\\', 0)\\n        if n > 0:\\n            nums[5] = n\\n            dic[\\'f\\'] -= n\\n            dic[\\'i\\'] -= n\\n            dic[\\'v\\'] -= n\\n            dic[\\'e\\'] -= n\\n        \\n        #get all 3s out\\n        n = dic.get(\\'r\\', 0)\\n        if n > 0:\\n            nums[3] = n\\n            dic[\\'t\\'] -= n\\n            dic[\\'h\\'] -= n\\n            dic[\\'r\\'] -= n\\n            dic[\\'e\\'] -= n\\n            dic[\\'e\\'] -= n \\n\\n        #get all 1s out\\n        n = dic.get(\\'o\\', 0)\\n        if n > 0:\\n            nums[1] = n\\n            dic[\\'o\\'] -= n\\n            dic[\\'n\\'] -= n\\n            dic[\\'e\\'] -= n\\n        \\n        #get all 9s out\\n        n = dic.get(\\'e\\', 0)\\n        if n > 0:\\n            nums[9] = n\\n            dic[\\'n\\'] -= n\\n            dic[\\'i\\'] -= n\\n            dic[\\'n\\'] -= n\\n            dic[\\'e\\'] -= n\\n        \\n        s = \\'\\'\\n        for i in range(10):\\n            if i in nums:\\n                s += str(i)*nums[i]\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418168,
                "title": "c-simple-c-code-o-n",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> alphabet(26,0);\\n        for(char &ch : s){\\n            alphabet[ch-\\'a\\']++;\\n        }\\n        vector<pair<char,pair<string,int>>> word =  {{\\'z\\', {\"zero\", 0}}, {\\'x\\', {\"six\", 6}}, {\\'s\\', {\"seven\", 7}}, \\n\\t\\t{\\'w\\', {\"two\", 2}}, {\\'u\\', {\"four\", 4}}, {\\'o\\', {\"one\", 1}}, {\\'r\\', {\"three\", 3}}, {\\'f\\', {\"five\", 5}}, \\n\\t\\t{\\'h\\', {\"eight\", 8}}, {\\'i\\', {\"nine\", 9}}};\\n        \\n        int i = 0; string ans = \"\";\\n        while(i < 10)\\n        {\\n            pair<char,pair<string,int>> tp = word[i];\\n            char ch = tp.first;\\n            if(alphabet[ch-\\'a\\'] == 0)\\n            {\\n                i++;\\n                continue;\\n            }\\n            string str = tp.second.first;\\n            int num = tp.second.second;\\n            for(int j = 0; j < str.size(); j++)\\n            {\\n                alphabet[str[j]-\\'a\\']--;\\n            }\\n            ans += to_string(num);\\n        }\\n        vector<int> srt(10,0);\\n        for(char &val : ans)\\n        {\\n            srt[val-\\'0\\']++;\\n        }\\n        ans = \"\";\\n        for(int k = 0; k < 10; k++)\\n        {\\n            if(srt[k] == 0) continue;\\n            while(srt[k]--)\\n                ans += to_string(k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int> alphabet(26,0);\\n        for(char &ch : s){\\n            alphabet[ch-\\'a\\']++;\\n        }\\n        vector<pair<char,pair<string,int>>> word =  {{\\'z\\', {\"zero\", 0}}, {\\'x\\', {\"six\", 6}}, {\\'s\\', {\"seven\", 7}}, \\n\\t\\t{\\'w\\', {\"two\", 2}}, {\\'u\\', {\"four\", 4}}, {\\'o\\', {\"one\", 1}}, {\\'r\\', {\"three\", 3}}, {\\'f\\', {\"five\", 5}}, \\n\\t\\t{\\'h\\', {\"eight\", 8}}, {\\'i\\', {\"nine\", 9}}};\\n        \\n        int i = 0; string ans = \"\";\\n        while(i < 10)\\n        {\\n            pair<char,pair<string,int>> tp = word[i];\\n            char ch = tp.first;\\n            if(alphabet[ch-\\'a\\'] == 0)\\n            {\\n                i++;\\n                continue;\\n            }\\n            string str = tp.second.first;\\n            int num = tp.second.second;\\n            for(int j = 0; j < str.size(); j++)\\n            {\\n                alphabet[str[j]-\\'a\\']--;\\n            }\\n            ans += to_string(num);\\n        }\\n        vector<int> srt(10,0);\\n        for(char &val : ans)\\n        {\\n            srt[val-\\'0\\']++;\\n        }\\n        ans = \"\";\\n        for(int k = 0; k < 10; k++)\\n        {\\n            if(srt[k] == 0) continue;\\n            while(srt[k]--)\\n                ans += to_string(k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408486,
                "title": "c-solution",
                "content": "class Solution {\\n# public:\\n    string originalDigits(string s) {\\n        unordered_map<char,int>m;\\n        string k;\\n      for(int i=0;i<s.size();i++){\\n          m[s[i]]++;\\n      }\\n            while(m.find(\\'z\\')!=m.end()){\\n                k+=\\'0\\';\\n                m[\\'z\\']--;\\n                if(m[\\'z\\']==0){\\n                    m.erase(\\'z\\');\\n                }\\n                m[\\'e\\']--;\\n                if(m[\\'e\\']==0){\\n                    m.erase(\\'e\\');\\n                }\\n                m[\\'r\\']--;\\n                if(m[\\'r\\']==0){\\n                    m.erase(\\'r\\');\\n                }\\n                m[\\'o\\']--;\\n                if(m[\\'o\\']==0){\\n                    m.erase(\\'o\\');\\n                }\\n            }\\n        while( m.find(\\'w\\')!=m.end()){\\n                k+=\\'2\\';\\n                m[\\'t\\']--;\\n                if(m[\\'t\\']==0){\\n                    m.erase(\\'t\\');\\n                }\\n                m[\\'w\\']--;\\n                if(m[\\'w\\']==0){\\n                    m.erase(\\'w\\');\\n                }\\n                m[\\'o\\']--;\\n                if(m[\\'o\\']==0){\\n                    m.erase(\\'o\\');\\n                }\\n               \\n            }while(m.find(\\'x\\')!=m.end()){\\n                k+=\\'6\\';\\n                m[\\'s\\']--;\\n                if(m[\\'s\\']==0){\\n                    m.erase(\\'s\\');\\n                }\\n                m[\\'i\\']--;\\n                if(m[\\'i\\']==0){\\n                    m.erase(\\'i\\');\\n                }\\n                m[\\'x\\']--;\\n                if(m[\\'x\\']==0){\\n                    m.erase(\\'x\\');\\n                }\\n                \\n            }\\n        while( m.find(\\'u\\')!=m.end()){\\n                k+=\\'4\\';\\n                m[\\'f\\']--;\\n                if(m[\\'f\\']==0){\\n                    m.erase(\\'f\\');\\n                }\\n                m[\\'o\\']--;\\n                if(m[\\'o\\']==0){\\n                    m.erase(\\'o\\');\\n                }\\n                m[\\'u\\']--;\\n                if(m[\\'u\\']==0){\\n                    m.erase(\\'u\\');\\n                }\\n                m[\\'r\\']--;\\n                if(m[\\'r\\']==0){\\n                    m.erase(\\'r\\');\\n                }\\n            }\\n        \\n        while(m.find(\\'f\\')!=m.end()){\\n                k+=\\'5\\';\\n                m[\\'f\\']--;\\n                if(m[\\'f\\']==0){\\n                    m.erase(\\'f\\');\\n                }\\n                m[\\'i\\']--;\\n                if(m[\\'i\\']==0){\\n                    m.erase(\\'i\\');\\n                }\\n                m[\\'v\\']--;\\n                if(m[\\'v\\']==0){\\n                    m.erase(\\'v\\');\\n                }\\n                m[\\'e\\']--;\\n                if(m[\\'e\\']==0){\\n                    m.erase(\\'e\\');\\n                }\\n            }\\n        while(m.find(\\'g\\')!=m.end()){\\n                k+=\\'8\\';\\n                m[\\'e\\']--;\\n                if(m[\\'e\\']==0){\\n                    m.erase(\\'e\\');\\n                }\\n                m[\\'i\\']--;\\n                if(m[\\'i\\']==0){\\n                    m.erase(\\'i\\');\\n                }\\n                m[\\'g\\']--;\\n                if(m[\\'g\\']==0){\\n                    m.erase(\\'g\\');\\n                }\\n                m[\\'h\\']--;\\n                if(m[\\'h\\']==0){\\n                    m.erase(\\'h\\');\\n                }\\n                m[\\'t\\']--;\\n                if(m[\\'t\\']==0){\\n                    m.erase(\\'t\\');\\n                }\\n            }\\n        while(m.find(\\'s\\')!=m.end()){\\n                k+=\\'7\\';\\n                m[\\'s\\']--;\\n                if(m[\\'s\\']==0){\\n                    m.erase(\\'s\\');\\n                }\\n                m[\\'e\\']--;\\n                m[\\'e\\']--;\\n                if(m[\\'e\\']==0){\\n                    m.erase(\\'e\\');\\n                }\\n                m[\\'v\\']--;\\n                if(m[\\'v\\']==0){\\n                    m.erase(\\'v\\');\\n                }\\n                m[\\'n\\']--;\\n                if(m[\\'n\\']==0){\\n                    m.erase(\\'n\\');\\n                }\\n            }\\n            while(m.find(\\'o\\')!=m.end()){\\n                k+=\\'1\\';\\n                m[\\'o\\']--;\\n                if(m[\\'o\\']==0){\\n                    m.erase(\\'o\\');\\n                }\\n                m[\\'n\\']--;\\n                if(m[\\'n\\']==0){\\n                    m.erase(\\'n\\');\\n                }\\n                m[\\'e\\']--;\\n                if(m[\\'e\\']==0){\\n                    m.erase(\\'e\\');\\n                }\\n                \\n            }\\n            while(m.find(\\'h\\')!=m.end()){\\n                k+=\\'3\\';\\n                m[\\'t\\']--;\\n                if(m[\\'t\\']==0){\\n                    m.erase(\\'t\\');\\n                }\\n                m[\\'h\\']--;\\n                if(m[\\'h\\']==0){\\n                    m.erase(\\'h\\');\\n                }\\n                m[\\'r\\']--;\\n                if(m[\\'r\\']==0){\\n                    m.erase(\\'r\\');\\n                }\\n                m[\\'e\\']--;\\n                m[\\'e\\']--;\\n                if(m[\\'e\\']==0){\\n                    m.erase(\\'e\\');\\n                }\\n            }\\n            while(m.find(\\'n\\')!=m.end()){\\n                k+=\\'9\\';\\n                m[\\'n\\']--;\\n                m[\\'n\\']--;\\n                if(m[\\'n\\']==0){\\n                    m.erase(\\'n\\');\\n                }\\n                m[\\'e\\']--;\\n                if(m[\\'e\\']==0){\\n                    m.erase(\\'e\\');\\n                }\\n                m[\\'i\\']--;\\n                if(m[\\'i\\']==0){\\n                    m.erase(\\'i\\');\\n                }\\n                \\n            }\\n        sort(k.begin(),k.end());\\n        return k;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    string originalDigits(string s) {\\n        unordered_map<char,int>m;\\n        string k;\\n      for(int i=0;i<s.size();i++){\\n          m[s[i]]++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2362140,
                "title": "careful-character-queries",
                "content": "![image](https://assets.leetcode.com/users/images/52f4d046-751e-4a82-8c26-58282c378626_1659523829.2077942.png)\\n\\nMind the order of the queries for the \"duplicates\"!\\n\\n```\\nstring originalDigits(string s) \\n{\\n\\tint D[256]{};\\n\\tfor(const auto & c : s) ++D[c];\\n\\n\\tstring v[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\tpair<char, int> queries[]{{\\'z\\',0},{\\'w\\',2},{\\'u\\',4},{\\'x\\',6},{\\'g\\',8},{\\'s\\',7},{\\'f\\',5},{\\'i\\',9},{\\'n\\',1},{\\'h\\',3}};\\n\\tint d[10]{};\\n\\tfor(const auto & [c,i] : queries)\\n\\t{\\n\\t\\td[i] = D[c];\\n\\t\\tfor(const auto & ch : v[i]) D[ch] -= d[i];\\n\\t}\\n\\n\\tstring out;\\n\\tfor(int i{}; i<size(d); ++i)\\n\\t\\tout.append(string(d[i],\\'0\\'+i));\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring originalDigits(string s) \\n{\\n\\tint D[256]{};\\n\\tfor(const auto & c : s) ++D[c];\\n\\n\\tstring v[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\tpair<char, int> queries[]{{\\'z\\',0},{\\'w\\',2},{\\'u\\',4},{\\'x\\',6},{\\'g\\',8},{\\'s\\',7},{\\'f\\',5},{\\'i\\',9},{\\'n\\',1},{\\'h\\',3}};\\n\\tint d[10]{};\\n\\tfor(const auto & [c,i] : queries)\\n\\t{\\n\\t\\td[i] = D[c];\\n\\t\\tfor(const auto & ch : v[i]) D[ch] -= d[i];\\n\\t}\\n\\n\\tstring out;\\n\\tfor(int i{}; i<size(d); ++i)\\n\\t\\tout.append(string(d[i],\\'0\\'+i));\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2327722,
                "title": "python-simplest-using-diictionary",
                "content": "Create a cnt_map/list for each digit\\n\\nFirst check which nums have a unique character :-\\n0 - z\\n2 - w\\n4 - u\\n6 - x\\n8 - h\\n\\nIncrement the freq of each digit by the number of occurences of the unique element.\\n\\nNow for the remaining digits, try finding the freq using the digits already done\\nfor e.g. - 1 has **o** common with zer**o**, tw**o** , f**o**ur \\n\\nSo :- \\n```Python\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        cnt = collections.Counter(s)\\n        \\n        res = [0 for _ in range(10)]\\n        \\n        res[0] = cnt[\\'z\\']\\n        res[2] = cnt[\\'w\\']\\n        res[4] = cnt[\\'u\\']\\n        res[6] = cnt[\\'x\\']\\n        res[8] = cnt[\\'g\\']\\n        \\n        res[1] = cnt[\\'o\\'] - (res[0] + res[2] + res[4])\\n        res[3] = cnt[\\'t\\'] - (res[2] + res[8])\\n        res[5] = cnt[\\'f\\'] - res[4]\\n        res[7] = cnt[\\'s\\'] - res[6]\\n        res[9] = cnt[\\'i\\'] - (res[5] + res[6] + res[8])\\n        \\n        return \\'\\'.join(str(i)*f for i, f in enumerate(res))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        cnt = collections.Counter(s)\\n        \\n        res = [0 for _ in range(10)]\\n        \\n        res[0] = cnt[\\'z\\']\\n        res[2] = cnt[\\'w\\']\\n        res[4] = cnt[\\'u\\']\\n        res[6] = cnt[\\'x\\']\\n        res[8] = cnt[\\'g\\']\\n        \\n        res[1] = cnt[\\'o\\'] - (res[0] + res[2] + res[4])\\n        res[3] = cnt[\\'t\\'] - (res[2] + res[8])\\n        res[5] = cnt[\\'f\\'] - res[4]\\n        res[7] = cnt[\\'s\\'] - res[6]\\n        res[9] = cnt[\\'i\\'] - (res[5] + res[6] + res[8])\\n        \\n        return \\'\\'.join(str(i)*f for i, f in enumerate(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274274,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public String originalDigits(String s) {\\n\\n        int[] count = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n            char curr = s.charAt(i);\\n            count[curr-\\'a\\']+=1;\\n        }                                           //unique characters\\n                                                    //zero - z\\n        //one -o(zero,two,four)\\n                                                    //two - w\\n                                //three -h(four)\\n                                                    //four - u\\n                                //five -f(four)\\n                                                    //six -x\\n                                //seven - s(six)\\n                                                    //eight -g\\n        //nine - i (six,five,eight);\\n        \\n        int[] nums = new int[10];\\n        //unique\\n        nums[0] = count[\\'z\\'-\\'a\\'];\\n        nums[2] = count[\\'w\\'-\\'a\\'];\\n        nums[4] = count[\\'u\\'-\\'a\\'];\\n        nums[6] = count[\\'x\\'-\\'a\\'];\\n        nums[8] = count[\\'g\\'-\\'a\\'];\\n        \\n        //unique to 2 numbers\\n        nums[3] = count[\\'h\\'-\\'a\\'] - nums[8];\\n        nums[5] = count[\\'f\\'-\\'a\\'] - nums[4];\\n        nums[7] = count[\\'s\\'-\\'a\\'] - nums[6];\\n        \\n        //unique to 3 numbers\\n        nums[1] = count[\\'o\\'-\\'a\\'] - nums[0] - nums[2] - nums[4];\\n        nums[9] = count[\\'i\\'-\\'a\\'] - nums[6] - nums[8] - nums[5];\\n        \\n        String result = \"\";\\n        for(int i =0;i<nums.length;i++){\\n            for(int j=0;j<nums[i];j++){\\n                result+=\"\"+i;\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public String originalDigits(String s) {\\n\\n        int[] count = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n            char curr = s.charAt(i);\\n            count[curr-\\'a\\']+=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2237548,
                "title": "skip-this-funny-rubbish-and-enjoy-your-life",
                "content": "\\nThe most popular **bad question** with the almost highest downvote/upvote (**2182/631**, by July 4th) rate!\\n\\nLife is too short to waste a second!\\nWhy not throw it away and enjoy your life?",
                "solutionTags": [],
                "code": "\\nThe most popular **bad question** with the almost highest downvote/upvote (**2182/631**, by July 4th) rate!\\n\\nLife is too short to waste a second!\\nWhy not throw it away and enjoy your life?",
                "codeTag": "Unknown"
            },
            {
                "id": 2091907,
                "title": "easiest-solution-to-understand-faster-than-84-python-dictionary",
                "content": "```\\n# Time complexity = n + 10 = O(n)\\n# Space complexity = 15 = O(1)\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        count_letters = collections.Counter(s)\\n        mapping = {}\\n        \\n        mapping[\"0\"] = count_letters[\"z\"]\\n        mapping[\"2\"] = count_letters[\"w\"]\\n        mapping[\"4\"] = count_letters[\"u\"]\\n        mapping[\"6\"] = count_letters[\"x\"]\\n        mapping[\"8\"] = count_letters[\"g\"]\\n        mapping[\"3\"] = count_letters[\"h\"] - mapping[\"8\"]\\n        mapping[\"5\"] = count_letters[\"f\"] - mapping[\"4\"]\\n        mapping[\"7\"] = count_letters[\"s\"] - mapping[\"6\"]\\n        mapping[\"9\"] = count_letters[\"i\"] - mapping[\"5\"] - mapping[\"6\"] - mapping[\"8\"]\\n        mapping[\"1\"] = count_letters[\"n\"] - mapping[\"7\"] - 2 * mapping[\"9\"]\\n\\n        result = [key * mapping[key] for key in sorted(mapping.keys())]\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Time complexity = n + 10 = O(n)\\n# Space complexity = 15 = O(1)\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        count_letters = collections.Counter(s)\\n        mapping = {}\\n        \\n        mapping[\"0\"] = count_letters[\"z\"]\\n        mapping[\"2\"] = count_letters[\"w\"]\\n        mapping[\"4\"] = count_letters[\"u\"]\\n        mapping[\"6\"] = count_letters[\"x\"]\\n        mapping[\"8\"] = count_letters[\"g\"]\\n        mapping[\"3\"] = count_letters[\"h\"] - mapping[\"8\"]\\n        mapping[\"5\"] = count_letters[\"f\"] - mapping[\"4\"]\\n        mapping[\"7\"] = count_letters[\"s\"] - mapping[\"6\"]\\n        mapping[\"9\"] = count_letters[\"i\"] - mapping[\"5\"] - mapping[\"6\"] - mapping[\"8\"]\\n        mapping[\"1\"] = count_letters[\"n\"] - mapping[\"7\"] - 2 * mapping[\"9\"]\\n\\n        result = [key * mapping[key] for key in sorted(mapping.keys())]\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079750,
                "title": "simple-intuitive-python-using-dict-operator",
                "content": "This is the simple solution that I came up with for the problem. The order in which we need to process the digits is important, as is lined out in the official problem solution. However, using the dict \"<=\" operator makes it more intuitive, but computationally less efficient than the official solution. But, coming from here to the official solution with the help of an interviewer should be fairly straightforward. Unfortunately, we can\\'t just multiply the all values in a dict by the same factor, otherwise we could get rid of the while loop in the for loop, which would make it a lot more efficient. Well, it still passes all tests though ;)\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        # (z)ero, one, t(w)o, three, fo(u)r, five, si(x), seven, ei(g)ht, nine\\n        from collections import Counter\\n        sc = Counter(s)\\n        digits = {0: Counter(\"zero\"), 1: Counter(\"one\"), 2:Counter(\"two\"), 3:Counter(\"three\"), 4:Counter(\"four\"), 5:Counter(\"five\"), 6:Counter(\"six\"), 7: Counter(\"seven\"), 8: Counter(\"eight\"), 9: Counter(\"nine\")}\\n        counts = [0]*10\\n        \\n        for i in [0, 2, 4, 6, 8, 3, 1, 7, 5, 9]:\\n            digit = digits[i]\\n            while digit <= sc:\\n                sc -= digit\\n                counts[i] += 1\\n                \\n        return \"\".join([str(i)*c for i, c in enumerate(counts)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        # (z)ero, one, t(w)o, three, fo(u)r, five, si(x), seven, ei(g)ht, nine\\n        from collections import Counter\\n        sc = Counter(s)\\n        digits = {0: Counter(\"zero\"), 1: Counter(\"one\"), 2:Counter(\"two\"), 3:Counter(\"three\"), 4:Counter(\"four\"), 5:Counter(\"five\"), 6:Counter(\"six\"), 7: Counter(\"seven\"), 8: Counter(\"eight\"), 9: Counter(\"nine\")}\\n        counts = [0]*10\\n        \\n        for i in [0, 2, 4, 6, 8, 3, 1, 7, 5, 9]:\\n            digit = digits[i]\\n            while digit <= sc:\\n                sc -= digit\\n                counts[i] += 1\\n                \\n        return \"\".join([str(i)*c for i, c in enumerate(counts)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052455,
                "title": "best-detailed-explanation-you-can-find-100-faster",
                "content": "//here we dont have direct names of digits like \"0\"=\"zero\" they are in merged position \\nso to differentiate we need to find pattern that will help us to separate them\\n\\npatterns                        \\n\"0\"=\"(z)ero\"          \\n\"1\"=\"one\"   \\n\"2\"=\"(t)wo\"\\n\"3\"=\"three\"\\n\"4\"=\"fo(u)r\"\\n\"5\"=\"five\"\\n\"6\"=\"si(x)\"\\n\"7\"=\"seven\"\\n\"8\"=\"ei(g)ht\"\\n\"9\"=\"nine\"\\n\\nunique digits\\n\"0\",\"2\",\"4\",\"6\",\"8\" \\nderived digits\\nFor \"1\" it have \"o\" so we will count all o that comes and subtract with digits count that have o character=> \\nnum[\"1\"]=count[\"o\"]-num[\"0\"]-num[\"2\"]-num[\"4\"]\\nnum[\"3\"]=count[\"h\"]-num[\"8\"]\\nnum[\"5\"]=count[\"f\"]-num[\"4\"]\\nnum[\"7\"]=count[\"s\"]-num[\"6\"]\\nnum[\"9\"]=count[\"i\"]-num[\"0\"]-num[\"5\"]-num[\"8\"]\\n\\n{1}.=> Find pattern single pass\\n\\n1. we first find pattern and differentiate uniqueness\\n2. make a map of char and array of 10 digits\\n3. Store count of each char then count of digit\\n\\n#Time Complexity: O(n)\\n#Space Complexity: O(1)\\n\\n```\\n string originalDigits(string s) {\\n         \\n        int count[256]={0};\\n        for(char c : s) count[c]++;\\n        \\n        int num[10]={0};\\n        \\n        //Unique Cases\\n        num[0] = count[\\'z\\'];\\n        num[2] = count[\\'w\\'];\\n        num[4] = count[\\'u\\'];\\n        num[6] = count[\\'x\\'];\\n        num[8] = count[\\'g\\'];\\n        \\n        //Derived Cases\\n        num[1] = count[\\'o\\']-num[0]-num[2]-num[4];\\n        num[3] = count[\\'h\\']-num[8];\\n        num[5] = count[\\'f\\']-num[4];\\n        num[7] = count[\\'s\\']-num[6];\\n        num[9] = count[\\'i\\']-num[5]-num[6]-num[8];\\n        string sb;\\n        for(int i = 0; i < 10; i++){\\n            while(num[i]-- > 0)\\n                sb.push_back(i+\\'0\\');\\n        }\\n        return sb;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n string originalDigits(string s) {\\n         \\n        int count[256]={0};\\n        for(char c : s) count[c]++;\\n        \\n        int num[10]={0};\\n        \\n        //Unique Cases\\n        num[0] = count[\\'z\\'];\\n        num[2] = count[\\'w\\'];\\n        num[4] = count[\\'u\\'];\\n        num[6] = count[\\'x\\'];\\n        num[8] = count[\\'g\\'];\\n        \\n        //Derived Cases\\n        num[1] = count[\\'o\\']-num[0]-num[2]-num[4];\\n        num[3] = count[\\'h\\']-num[8];\\n        num[5] = count[\\'f\\']-num[4];\\n        num[7] = count[\\'s\\']-num[6];\\n        num[9] = count[\\'i\\']-num[5]-num[6]-num[8];\\n        string sb;\\n        for(int i = 0; i < 10; i++){\\n            while(num[i]-- > 0)\\n                sb.push_back(i+\\'0\\');\\n        }\\n        return sb;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033578,
                "title": "java-frequencies-and-unique-letters-with-intuition-and-comments",
                "content": "**Intuition**: We can do a frequency analysis to determine digits starting from unique letters.  For example, \\'zero\\' has the only \\'z\\'.  And we then remve the other letters, too, so that eventually, we always have at least one unique letter to check.  Will this work, we may wonder?  Well, let\\'s do some analysis.\\n\\n`z`: unique for `zero`, also remove an equal number of `e`, `r` and `o` - we spell this as `zero` (unique letter first)\\n`w`: unique for `two`, also remove an equal number of `t` and `o` - we spell this as `wto` (unique letter first)\\n`g`: unique for `eight`, also remove an equal number of `e`, `i`, `h`, `t` - spell as `geiht`, and now `h` becomes unique to `three`\\n`x`: unique for `six`, also remove an equal number of `s` and `i` - spell as `xsi`, and now `s` becomes unique to `seven`\\n`h`: unique for `three`, also remove an equal number of `t`, `r`, `e` and again `e` - spell as `htree`m and now `r` becomes unique to `four`\\n`s`: unique for `seven`, also remove an equal number of `e`, `v`, `e` and `n` - spell as `seven` and now `v` becomes unique to `five`\\n`r`: unique for `four`, also remove an equal number of `f`, `o`, and `u` - spell as `rfou` and now `o` becomes unique to `one`\\n`o`: unique for `one`, also remove an equal number of `n` and `e` - spell as `one` and now `n` becomes unique to `nine`\\n`v`: unique for `five`, also remove an equal number of `f`, `i` and `e` - spell as `vfie` and now `i` also becomes unique to `nine`\\n`i`: unique for `nine`, also remove an equal number of `n`, `n` and `e` - spell as `inne` and now all frequencies should be 0.\\n\\nWhy do we spell `four` as `rfou` or `two` as `wto`?  We\\'ll do it so the first character is the one to check for uniqueness - then we can create an array.  We\\'ll also need a corresponding array of values: `0, 2, 8, 6, 3, 7, 4, 1, 5, 9`.  And then we can group these into a more usable map form.  For example, we want to convert letters to 0-25 (a = 0, z = 25) for easy frequency lookup.\\n\\nLet\\'s give it a whirl!\\n\\n```\\nclass Solution {\\n\\n    // First letter is unique after previous entries have been handled:\\n    static final String[] UNIQUES = new String[] {\\n        \"zero\", \"wto\", \"geiht\", \"xsi\", \"htree\",\\n        \"seven\", \"rfou\", \"one\", \"vfie\", \"inne\"\\n    };\\n\\n    // Values corresponding to order of uniqueness checks:\\n    static final int[] VALS = new int[] { 0, 2, 8, 6, 3, 7, 4, 1, 5, 9 };\\n    \\n\\t// Maps for checking uniqueness more conveniently:\\n    static final Map<Integer, List<Integer>> ORDERED_FREQ_MAP;\\n    static final Map<Integer, Integer> ORDERED_DIGIT_MAP;\\n    \\n    static {\\n\\t    // Initialize our ordered frequency map: 0-25 key to 0-25 values finishing the word:\\n        final LinkedHashMap<Integer, List<Integer>> orderedFreqMap = new LinkedHashMap<>();\\n\\t\\t// Also initialize a digit lookup map, e.g. \\'g\\' becomes 6 maps to 8 for ei[g]ht:\\n        final LinkedHashMap<Integer, Integer> orderedDigitMap = new LinkedHashMap<>();\\n        for (int i = 0; i < 10; ++i) {\\n            final char unique = UNIQUES[i].charAt(0);\\n            final int ui = convert(unique);\\n            orderedFreqMap.put(ui, converting(UNIQUES[i].substring(1).toCharArray()));\\n            orderedDigitMap.put(ui, VALS[i]);\\n        }\\n\\t\\t// Let\\'s make sure we aren\\'t tempted to modify these since they\\'re static.\\n        ORDERED_FREQ_MAP = Collections.unmodifiableMap(orderedFreqMap);\\n        ORDERED_DIGIT_MAP = Collections.unmodifiableMap(orderedDigitMap);\\n    }\\n\\n    public String originalDigits(String s) {\\n\\t    // count frequencies of each letter in s:\\n        final int[] freqs = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            freqs[convert(s.charAt(i))]++;\\n        }\\n\\t\\t// Crate an array to store digit strings in order, e.g. \\'00000\\', \\'11, \\'2222222\\', etc.\\n        final String[] strings = new String[10];\\n\\t\\t// Iterate through uniqueness checks in order:\\n        for (Map.Entry<Integer, List<Integer>> entry : ORDERED_FREQ_MAP.entrySet()) {\\n            final int index = entry.getKey(); // unique letter in 0-25 form\\n            final int value = ORDERED_DIGIT_MAP.get(index); // corresponding digit, e.g. 8 for \\'g\\', 0 for \\'z\\', etc.\\n            final int count = freqs[index]; // frequency of unique letter = frequency of corresponding digit\\n            if (count > 0) {\\n\\t\\t\\t    // update frequencies to remove the digit\\'s word count times:\\n                freqs[index] -= count;\\n                for (int idx : entry.getValue()) {\\n                    freqs[idx] -= count;\\n                }\\n\\t\\t\\t\\t// now create the digit string for the unique digit: the digit count times:\\n                strings[value] = String.valueOf(value).repeat(count);\\n            } else {\\n\\t\\t\\t    // count 0 - empty strring for this digit\\n                strings[value] = \"\";\\n            }\\n        }\\n\\t\\t// append the digit strings in order\\n        final StringBuilder sb = new StringBuilder();\\n        for (String str : strings) {\\n            sb.append(str);\\n        }\\n\\t\\t// and we are done!\\n        return sb.toString();\\n    }\\n\\n    // Converts a character array into a list of 0-25 frequency values.\\n    private static final List<Integer> converting(char... carr) {\\n        final List<Integer> list = new ArrayList<>();\\n        for (char ch : carr) {\\n            list.add(convert(ch)); // converts each to 0-25\\n        }\\n        return Collections.unmodifiableList(list);\\n    }\\n\\n    // Converts a-z to 0-26.  Bitwise AND with 31 gives a=1, z=26, so then subtract one.\\n    private static final Integer convert(char ch) {\\n        return (ch & 0x1f) - 1; // a->0, z->25\\n    }\\n\\n}\\n```\\nTime: O(n) for frequency count.  Also there\\'s an O(10) factor for digits but negligible compared to n.\\nSpace: O(n) for array where we assemble the digit strings for the answer.\\n\\nIf you found the intuition and/or commented code helpful or interesting, **please upvote**.  If you did not, **please comment** - your constructive feedback is most welcome - it may help me learn to write better solutions.\\n\\nThanks and happy coding!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // First letter is unique after previous entries have been handled:\\n    static final String[] UNIQUES = new String[] {\\n        \"zero\", \"wto\", \"geiht\", \"xsi\", \"htree\",\\n        \"seven\", \"rfou\", \"one\", \"vfie\", \"inne\"\\n    };\\n\\n    // Values corresponding to order of uniqueness checks:\\n    static final int[] VALS = new int[] { 0, 2, 8, 6, 3, 7, 4, 1, 5, 9 };\\n    \\n\\t// Maps for checking uniqueness more conveniently:\\n    static final Map<Integer, List<Integer>> ORDERED_FREQ_MAP;\\n    static final Map<Integer, Integer> ORDERED_DIGIT_MAP;\\n    \\n    static {\\n\\t    // Initialize our ordered frequency map: 0-25 key to 0-25 values finishing the word:\\n        final LinkedHashMap<Integer, List<Integer>> orderedFreqMap = new LinkedHashMap<>();\\n\\t\\t// Also initialize a digit lookup map, e.g. \\'g\\' becomes 6 maps to 8 for ei[g]ht:\\n        final LinkedHashMap<Integer, Integer> orderedDigitMap = new LinkedHashMap<>();\\n        for (int i = 0; i < 10; ++i) {\\n            final char unique = UNIQUES[i].charAt(0);\\n            final int ui = convert(unique);\\n            orderedFreqMap.put(ui, converting(UNIQUES[i].substring(1).toCharArray()));\\n            orderedDigitMap.put(ui, VALS[i]);\\n        }\\n\\t\\t// Let\\'s make sure we aren\\'t tempted to modify these since they\\'re static.\\n        ORDERED_FREQ_MAP = Collections.unmodifiableMap(orderedFreqMap);\\n        ORDERED_DIGIT_MAP = Collections.unmodifiableMap(orderedDigitMap);\\n    }\\n\\n    public String originalDigits(String s) {\\n\\t    // count frequencies of each letter in s:\\n        final int[] freqs = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            freqs[convert(s.charAt(i))]++;\\n        }\\n\\t\\t// Crate an array to store digit strings in order, e.g. \\'00000\\', \\'11, \\'2222222\\', etc.\\n        final String[] strings = new String[10];\\n\\t\\t// Iterate through uniqueness checks in order:\\n        for (Map.Entry<Integer, List<Integer>> entry : ORDERED_FREQ_MAP.entrySet()) {\\n            final int index = entry.getKey(); // unique letter in 0-25 form\\n            final int value = ORDERED_DIGIT_MAP.get(index); // corresponding digit, e.g. 8 for \\'g\\', 0 for \\'z\\', etc.\\n            final int count = freqs[index]; // frequency of unique letter = frequency of corresponding digit\\n            if (count > 0) {\\n\\t\\t\\t    // update frequencies to remove the digit\\'s word count times:\\n                freqs[index] -= count;\\n                for (int idx : entry.getValue()) {\\n                    freqs[idx] -= count;\\n                }\\n\\t\\t\\t\\t// now create the digit string for the unique digit: the digit count times:\\n                strings[value] = String.valueOf(value).repeat(count);\\n            } else {\\n\\t\\t\\t    // count 0 - empty strring for this digit\\n                strings[value] = \"\";\\n            }\\n        }\\n\\t\\t// append the digit strings in order\\n        final StringBuilder sb = new StringBuilder();\\n        for (String str : strings) {\\n            sb.append(str);\\n        }\\n\\t\\t// and we are done!\\n        return sb.toString();\\n    }\\n\\n    // Converts a character array into a list of 0-25 frequency values.\\n    private static final List<Integer> converting(char... carr) {\\n        final List<Integer> list = new ArrayList<>();\\n        for (char ch : carr) {\\n            list.add(convert(ch)); // converts each to 0-25\\n        }\\n        return Collections.unmodifiableList(list);\\n    }\\n\\n    // Converts a-z to 0-26.  Bitwise AND with 31 gives a=1, z=26, so then subtract one.\\n    private static final Integer convert(char ch) {\\n        return (ch & 0x1f) - 1; // a->0, z->25\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895807,
                "title": "back-tracking-solution-exceeding-time-limit-but-is-more-general-than-the-selected-solution",
                "content": "can\\'t stand the tricky solution and spend quite some time coming up with this back tracking solution\\n\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        from functools import lru_cache\\n        from copy import copy  # needed for the subtract function, dict is mutable, make a copy to avoid changing the input\\n        \\n        # make a hashable dict so lru_cache will work\\n        class HashableDict(dict):\\n            def __hash__(self):\\n                return hash(tuple(sorted(self.items())))        \\n        \\n        def contains(count1, count2): \\n            for c in count2: \\n                if (c not in count1) or (count1[c] < count2[c]): \\n                    return False\\n            else: \\n                return True\\n        \\n        def subtract(count1, count2): \\n            count = copy(count1) # avoid modifying the input dict\\n            for c in count1: \\n                if c in count2: \\n                    count[c] -= count2[c]\\n                    if count[c] <= 0: \\n                        del count[c]\\n            return count\\n                \\n        @lru_cache()\\n        def helper(count): \\n            nonlocal path\\n            \\n            if sum(count.values()) <= 5: \\n                for i in range(10): \\n                    if count == digit_to_count[i]: \\n                        path.append(i)\\n                        return True\\n                return False\\n\\n            for i in range(10): \\n                if contains(count, digit_to_count[i]) and helper(subtract(count, digit_to_count[i])): \\n                    path.append(i)\\n                    return True\\n            return False\\n        \\n        \\n        digit_to_count = dict()\\n        words = [\\'zero\\', \\'one\\', \\'two\\', \\'three\\', \\'four\\', \\'five\\', \\'six\\', \\'seven\\', \\'eight\\', \\'nine\\']\\n        for digit, word in enumerate(words): \\n            tmp = HashableDict()\\n            for c in set(word): \\n                tmp[c] = word.count(c)\\n            digit_to_count[digit] = tmp\\n\\n            \\n        count = HashableDict()\\n        for c in set(s): \\n            count[c] = s.count(c)\\n        \\n        path = []\\n        feasible = helper(count)\\n        \\n        if feasible: \\n            return \\'\\'.join([str(i) for i in sorted(path)])\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        from functools import lru_cache\\n        from copy import copy  # needed for the subtract function, dict is mutable, make a copy to avoid changing the input\\n        \\n        # make a hashable dict so lru_cache will work\\n        class HashableDict(dict):\\n            def __hash__(self):\\n                return hash(tuple(sorted(self.items())))        \\n        \\n        def contains(count1, count2): \\n            for c in count2: \\n                if (c not in count1) or (count1[c] < count2[c]): \\n                    return False\\n            else: \\n                return True\\n        \\n        def subtract(count1, count2): \\n            count = copy(count1) # avoid modifying the input dict\\n            for c in count1: \\n                if c in count2: \\n                    count[c] -= count2[c]\\n                    if count[c] <= 0: \\n                        del count[c]\\n            return count\\n                \\n        @lru_cache()\\n        def helper(count): \\n            nonlocal path\\n            \\n            if sum(count.values()) <= 5: \\n                for i in range(10): \\n                    if count == digit_to_count[i]: \\n                        path.append(i)\\n                        return True\\n                return False\\n\\n            for i in range(10): \\n                if contains(count, digit_to_count[i]) and helper(subtract(count, digit_to_count[i])): \\n                    path.append(i)\\n                    return True\\n            return False\\n        \\n        \\n        digit_to_count = dict()\\n        words = [\\'zero\\', \\'one\\', \\'two\\', \\'three\\', \\'four\\', \\'five\\', \\'six\\', \\'seven\\', \\'eight\\', \\'nine\\']\\n        for digit, word in enumerate(words): \\n            tmp = HashableDict()\\n            for c in set(word): \\n                tmp[c] = word.count(c)\\n            digit_to_count[digit] = tmp\\n\\n            \\n        count = HashableDict()\\n        for c in set(s): \\n            count[c] = s.count(c)\\n        \\n        path = []\\n        feasible = helper(count)\\n        \\n        if feasible: \\n            return \\'\\'.join([str(i) for i in sorted(path)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823351,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        unordered_map<char, int> umap;\\n        for(auto ch : s) umap[ch]++;\\n        \\n        vector<int> out(10, 0);\\n        out[0] = umap[\\'z\\'];\\n        out[2] = umap[\\'w\\'];\\n        out[4] = umap[\\'u\\'];\\n        out[6] = umap[\\'x\\'];\\n        out[8] = umap[\\'g\\'];\\n        out[3] = umap[\\'h\\']-out[8];\\n        out[5] = umap[\\'f\\']-out[4];\\n        out[7] = umap[\\'s\\']-out[6];\\n        out[9] = umap[\\'i\\']-out[8]-out[6]-out[5];\\n        out[1] = umap[\\'n\\']-out[7]-2*out[9];\\n        \\n        string ans = \"\";\\n        for(int i=0; i<10; i++) {\\n            ans+=string(out[i], \\'0\\' + i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        unordered_map<char, int> umap;\\n        for(auto ch : s) umap[ch]++;\\n        \\n        vector<int> out(10, 0);\\n        out[0] = umap[\\'z\\'];\\n        out[2] = umap[\\'w\\'];\\n        out[4] = umap[\\'u\\'];\\n        out[6] = umap[\\'x\\'];\\n        out[8] = umap[\\'g\\'];\\n        out[3] = umap[\\'h\\']-out[8];\\n        out[5] = umap[\\'f\\']-out[4];\\n        out[7] = umap[\\'s\\']-out[6];\\n        out[9] = umap[\\'i\\']-out[8]-out[6]-out[5];\\n        out[1] = umap[\\'n\\']-out[7]-2*out[9];\\n        \\n        string ans = \"\";\\n        for(int i=0; i<10; i++) {\\n            ans+=string(out[i], \\'0\\' + i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808681,
                "title": "python3-straight-forward-solution-o-n",
                "content": "We can erase each num by finding a character which is uniquely used to only one number.\\nFor example, \\'w\\' is only used for \\'two\\'. So if we find \\'w\\' in given string, we could know that string contains \\'two\\'.\\nLikewise, we can use \\'u\\' for erasing \\'four\\', \\'x\\' for \\'six\\', \\'g\\' for \\'eight\\', \\'z\\' for \\'zero\\'.\\n\\nAfter erasing, above numbers from string, now we can erase next numbers.\\n\\'h\\' is used for both \\'three\\' and \\'eight\\', but \\'eight\\' is already deleted, we can erase \\'three\\' if \\'h\\' remained in string\\n\\nConsquently, we can erase numbers from string in order 24680 -> 357 -> 9 -> 1.\\n\\n\\n```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        # a\\n        # b\\n        # c\\n        # d\\n        # e -> one, three, five, seven, eight, nine, zero\\n        # f -> four, five\\n        # g -> eight\\n        # h -> three, eight\\n        # i -> five, six, eight, nine\\n        # j\\n        # k\\n        # l\\n        # m \\n        # n -> one, seven, nine\\n        # o -> one, two, four, zero\\n        # p\\n        # q\\n        # r -> three, four, zero\\n        # s -> six, seven\\n        # t -> two, three, eight\\n        # u -> four\\n        # v -> five, seven\\n        # w -> two\\n        # x -> six\\n        # y\\n        # z -> zero\\n        \\n        # erasing order\\n        # 1. two(w), four(u), six(x), eight(g), zero(z)\\n        # 2. three(h), five(f), seven(s)\\n        # 3. nine(i)\\n        # 4. one(o)\\n        \\n        def countCharacters(s):\\n            counter = defaultdict(int)\\n            for c in s:\\n                counter[c] += 1\\n            return counter\\n        \\n        def delete(counter, mapper):\\n            for c, (s, num) in mapper.items():\\n                while counter[c]:\\n                    for ss in s:\\n                        counter[ss] -= 1\\n                    origin[num] += 1\\n        \\n        def delete24680(counter):\\n            mapper = {\\n                \\'w\\': (\\'two\\', 2),\\n                \\'u\\': (\\'four\\', 4),\\n                \\'x\\': (\\'six\\', 6),\\n                \\'g\\': (\\'eight\\', 8),\\n                \\'z\\': (\\'zero\\', 0),\\n            }\\n            delete(counter, mapper)\\n\\n        def delete357(counter):\\n            mapper = {\\n                \\'h\\': (\\'three\\', 3),\\n                \\'f\\': (\\'five\\', 5),\\n                \\'s\\': (\\'seven\\', 7),\\n            }\\n            delete(counter, mapper)\\n            \\n        def delete9(counter):\\n            mapper = {\\n                \\'i\\': (\\'nine\\', 9),\\n            }\\n            delete(counter, mapper)\\n            \\n        def delete1(counter):\\n            mapper = {\\n                \\'o\\': (\\'one\\', 1),\\n            }\\n            delete(counter, mapper)\\n        \\n        counter = countCharacters(s)\\n        origin = [0]*10\\n        \\n        delete24680(counter)\\n        delete357(counter)\\n        delete9(counter)\\n        delete1(counter)\\n        \\n        result = \\'\\'\\n        print(origin)\\n        for idx, num in enumerate(origin):\\n            result += str(idx)*num\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        # a\\n        # b\\n        # c\\n        # d\\n        # e -> one, three, five, seven, eight, nine, zero\\n        # f -> four, five\\n        # g -> eight\\n        # h -> three, eight\\n        # i -> five, six, eight, nine\\n        # j\\n        # k\\n        # l\\n        # m \\n        # n -> one, seven, nine\\n        # o -> one, two, four, zero\\n        # p\\n        # q\\n        # r -> three, four, zero\\n        # s -> six, seven\\n        # t -> two, three, eight\\n        # u -> four\\n        # v -> five, seven\\n        # w -> two\\n        # x -> six\\n        # y\\n        # z -> zero\\n        \\n        # erasing order\\n        # 1. two(w), four(u), six(x), eight(g), zero(z)\\n        # 2. three(h), five(f), seven(s)\\n        # 3. nine(i)\\n        # 4. one(o)\\n        \\n        def countCharacters(s):\\n            counter = defaultdict(int)\\n            for c in s:\\n                counter[c] += 1\\n            return counter\\n        \\n        def delete(counter, mapper):\\n            for c, (s, num) in mapper.items():\\n                while counter[c]:\\n                    for ss in s:\\n                        counter[ss] -= 1\\n                    origin[num] += 1\\n        \\n        def delete24680(counter):\\n            mapper = {\\n                \\'w\\': (\\'two\\', 2),\\n                \\'u\\': (\\'four\\', 4),\\n                \\'x\\': (\\'six\\', 6),\\n                \\'g\\': (\\'eight\\', 8),\\n                \\'z\\': (\\'zero\\', 0),\\n            }\\n            delete(counter, mapper)\\n\\n        def delete357(counter):\\n            mapper = {\\n                \\'h\\': (\\'three\\', 3),\\n                \\'f\\': (\\'five\\', 5),\\n                \\'s\\': (\\'seven\\', 7),\\n            }\\n            delete(counter, mapper)\\n            \\n        def delete9(counter):\\n            mapper = {\\n                \\'i\\': (\\'nine\\', 9),\\n            }\\n            delete(counter, mapper)\\n            \\n        def delete1(counter):\\n            mapper = {\\n                \\'o\\': (\\'one\\', 1),\\n            }\\n            delete(counter, mapper)\\n        \\n        counter = countCharacters(s)\\n        origin = [0]*10\\n        \\n        delete24680(counter)\\n        delete357(counter)\\n        delete9(counter)\\n        delete1(counter)\\n        \\n        result = \\'\\'\\n        print(origin)\\n        for idx, num in enumerate(origin):\\n            result += str(idx)*num\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791335,
                "title": "c-master-solution-commented",
                "content": "**Clear Solution**\\n```\\nclass Solution {\\n\\t// \"zero\" ,\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"\\n\\t/*\\n\\t\\t\\'e\\' : 0 1 3 5 7 8 9\\n\\t\\t\\'f\\' : 4 5\\n\\t\\t\\'g\\' : 8\\n\\t\\t\\'h\\' : 3 8\\n\\t\\t\\'i\\' : 5 6 8 9\\n\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\'r\\' : 0 3 4\\n\\t\\t\\'s\\' : 6 7\\n\\t\\t\\'t\\' : 2 3 8\\n\\t\\t\\'u\\' : 4\\n\\t\\t\\'v\\' : 5 7\\n\\t\\t\\'w\\' : 2\\n\\t\\t\\'x\\' : 6\\n\\t\\t\\'z\\' : 0\\n\\t*/\\n\\npublic:\\n\\tstring originalDigits(string s) {\\n\\t\\tunordered_map<char, int>mp;\\n\\t\\tfor (auto c : s)\\n\\t\\t{\\n\\t\\t\\tmp[c]++;\\n\\t\\t}\\n\\t\\tvector<int>count(10, 0);\\n\\t\\t//8\\n\\t\\twhile (mp[\\'g\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'e\\']--; mp[\\'i\\']--; mp[\\'g\\']--; mp[\\'h\\']--; mp[\\'t\\']--;\\n\\t\\t\\tcount[8]++;\\n\\t\\t}\\n\\t\\t//3\\n\\t\\twhile (mp[\\'h\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'t\\']--; mp[\\'h\\']--; mp[\\'r\\']--; mp[\\'e\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[3]++;\\n\\t\\t}\\n\\t\\t//2\\n\\t\\twhile (mp[\\'t\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'t\\']--; mp[\\'w\\']--; mp[\\'o\\']--;\\n\\t\\t\\tcount[2]++;\\n\\t\\t}\\n\\t\\t//4\\n\\t\\twhile (mp[\\'u\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'f\\']--; mp[\\'o\\']--; mp[\\'u\\']--; mp[\\'r\\']--;\\n\\t\\t\\tcount[4]++;\\n\\t\\t}\\n\\t\\t//5\\n\\t\\twhile (mp[\\'f\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'f\\']--; mp[\\'i\\']--; mp[\\'v\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[5]++;\\n\\t\\t}\\n\\t\\t//0\\n\\t\\twhile (mp[\\'r\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'z\\']--; mp[\\'e\\']--; mp[\\'r\\']--; mp[\\'o\\']--;\\n\\t\\t\\tcount[0]++;\\n\\t\\t}\\n\\t\\t//1\\n\\t\\twhile (mp[\\'o\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'o\\']--; mp[\\'n\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[1]++;\\n\\t\\t}\\n\\t\\t//7\\n\\t\\twhile (mp[\\'v\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'s\\']--; mp[\\'e\\']--; mp[\\'v\\']--; mp[\\'e\\']--; mp[\\'n\\']--;\\n\\t\\t\\tcount[7]++;\\n\\t\\t}\\n\\t\\t//9\\n\\t\\twhile (mp[\\'e\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'n\\']--; mp[\\'i\\']--; mp[\\'n\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[9]++;\\n\\t\\t}\\n\\t\\t//6\\n\\t\\twhile (mp[\\'i\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'s\\']--; mp[\\'i\\']--; mp[\\'x\\']--;\\n\\t\\t\\tcount[6]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tstring ans = \"\";\\n\\t\\tfor (int i = 0; i <= 9; i++)\\n\\t\\t{\\n\\t\\t\\tif (count[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans += string(count[i], char(i + \\'0\\'));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n**Solution with comment**\\n```\\nclass Solution {\\n\\t// \"zero\" ,\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"\\n\\t/*\\n\\t\\t\\'e\\' : 0 1 3 5 7 8 9\\n\\t\\t\\'f\\' : 4 5\\n\\t\\t\\'g\\' : 8\\n\\t\\t\\'h\\' : 3 8\\n\\t\\t\\'i\\' : 5 6 8 9\\n\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\'r\\' : 0 3 4\\n\\t\\t\\'s\\' : 6 7\\n\\t\\t\\'t\\' : 2 3 8\\n\\t\\t\\'u\\' : 4\\n\\t\\t\\'v\\' : 5 7\\n\\t\\t\\'w\\' : 2\\n\\t\\t\\'x\\' : 6\\n\\t\\t\\'z\\' : 0\\n\\t*/\\n\\npublic:\\n\\tstring originalDigits(string s) {\\n\\t\\tunordered_map<char, int>mp;\\n\\t\\tfor (auto c : s)\\n\\t\\t{\\n\\t\\t\\tmp[c]++;\\n\\t\\t}\\n\\t\\tvector<int>count(10, 0);\\n\\n\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 3 5 7 8 9\\n\\t\\t\\t\\'f\\' : 4 5\\n\\t\\t\\t\\'g\\' : 8\\n\\t\\t\\t\\'h\\' : 3 8\\n\\t\\t\\t\\'i\\' : 5 6 8 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\t\\'r\\' : 0 3 4\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'t\\' : 2 3 8\\n\\t\\t\\t\\'u\\' : 4\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'w\\' : 2\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//8\\n\\t\\t// How Many \\'g\\' that many 8 in string\\n\\t\\twhile (mp[\\'g\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'e\\']--; mp[\\'i\\']--; mp[\\'g\\']--; mp[\\'h\\']--; mp[\\'t\\']--;\\n\\t\\t\\tcount[8]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 3 5 7 9\\n\\t\\t\\t\\'f\\' : 4 5\\n\\t\\t\\t\\'h\\' : 3\\n\\t\\t\\t\\'i\\' : 5 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\t\\'r\\' : 0 3 4\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'t\\' : 2 3\\n\\t\\t\\t\\'u\\' : 4\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'w\\' : 2\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//3\\n\\t\\t// How Many \\'h\\' that many 3 in string\\n\\t\\twhile (mp[\\'h\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'t\\']--; mp[\\'h\\']--; mp[\\'r\\']--; mp[\\'e\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[3]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 5 7 9\\n\\t\\t\\t\\'f\\' : 4 5\\n\\t\\t\\t\\'i\\' : 5 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\t\\'r\\' : 0 4\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'t\\' : 2\\n\\t\\t\\t\\'u\\' : 4\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'w\\' : 2\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//2\\n\\t\\t// How Many \\'t\\' that many 2 in string\\n\\t\\twhile (mp[\\'t\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'t\\']--; mp[\\'w\\']--; mp[\\'o\\']--;\\n\\t\\t\\tcount[2]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 5 7 9\\n\\t\\t\\t\\'f\\' : 4 5\\n\\t\\t\\t\\'i\\' : 5 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1 4\\n\\t\\t\\t\\'r\\' : 0 4\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'u\\' : 4\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//4\\n\\t\\t// How Many \\'u\\' that many 4 in string\\n\\t\\twhile (mp[\\'u\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'f\\']--; mp[\\'o\\']--; mp[\\'u\\']--; mp[\\'r\\']--;\\n\\t\\t\\tcount[4]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 5 7 9\\n\\t\\t\\t\\'f\\' : 5\\n\\t\\t\\t\\'i\\' : 5 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1\\n\\t\\t\\t\\'r\\' : 0\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//5\\n\\t\\t// How Many \\'f\\' that many 5 in string\\n\\t\\twhile (mp[\\'f\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'f\\']--; mp[\\'i\\']--; mp[\\'v\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[5]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 7 9\\n\\t\\t\\t\\'i\\' : 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1\\n\\t\\t\\t\\'r\\' : 0\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'v\\' : 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//0\\n\\t\\t// How Many \\'r\\' that many 0 in string\\n\\t\\twhile (mp[\\'r\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'z\\']--; mp[\\'e\\']--; mp[\\'r\\']--; mp[\\'o\\']--;\\n\\t\\t\\tcount[0]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 1 7 9\\n\\t\\t\\t\\'i\\' : 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 1\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'v\\' : 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t*/\\n\\n\\t\\t//1\\n\\t\\t// How Many \\'o\\' that many 1 in string\\n\\t\\twhile (mp[\\'o\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'o\\']--; mp[\\'n\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[1]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 7 9\\n\\t\\t\\t\\'i\\' : 6 9\\n\\t\\t\\t\\'n\\' : 7 9\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'v\\' : 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t*/\\n\\n\\t\\t//7\\n\\t\\t// How Many \\'v\\' that many 7 in string\\n\\t\\twhile (mp[\\'v\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'s\\']--; mp[\\'e\\']--; mp[\\'v\\']--; mp[\\'e\\']--; mp[\\'n\\']--;\\n\\t\\t\\tcount[7]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 9\\n\\t\\t\\t\\'i\\' : 6 9\\n\\t\\t\\t\\'n\\' : 9\\n\\t\\t\\t\\'s\\' : 6\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t*/\\n\\n\\t\\t//9\\n\\t\\t// How Many \\'e\\' that many 9 in string\\n\\t\\twhile (mp[\\'e\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'n\\']--; mp[\\'i\\']--; mp[\\'n\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[9]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'i\\' : 6\\n\\t\\t\\t\\'s\\' : 6\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t*/\\n\\n\\t\\t//6\\n\\t\\t// How Many \\'i\\' that many 6 in string\\n\\t\\twhile (mp[\\'i\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'s\\']--; mp[\\'i\\']--; mp[\\'x\\']--;\\n\\t\\t\\tcount[6]++;\\n\\t\\t}\\n\\t\\t/*\\n\\n\\t\\t*/\\n\\n\\t\\tstring ans = \"\";\\n\\t\\tfor (int i = 0; i <= 9; i++)\\n\\t\\t{\\n\\t\\t\\tif (count[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans += string(count[i], char(i + \\'0\\'));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t// \"zero\" ,\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"\\n\\t/*\\n\\t\\t\\'e\\' : 0 1 3 5 7 8 9\\n\\t\\t\\'f\\' : 4 5\\n\\t\\t\\'g\\' : 8\\n\\t\\t\\'h\\' : 3 8\\n\\t\\t\\'i\\' : 5 6 8 9\\n\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\'r\\' : 0 3 4\\n\\t\\t\\'s\\' : 6 7\\n\\t\\t\\'t\\' : 2 3 8\\n\\t\\t\\'u\\' : 4\\n\\t\\t\\'v\\' : 5 7\\n\\t\\t\\'w\\' : 2\\n\\t\\t\\'x\\' : 6\\n\\t\\t\\'z\\' : 0\\n\\t*/\\n\\npublic:\\n\\tstring originalDigits(string s) {\\n\\t\\tunordered_map<char, int>mp;\\n\\t\\tfor (auto c : s)\\n\\t\\t{\\n\\t\\t\\tmp[c]++;\\n\\t\\t}\\n\\t\\tvector<int>count(10, 0);\\n\\t\\t//8\\n\\t\\twhile (mp[\\'g\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'e\\']--; mp[\\'i\\']--; mp[\\'g\\']--; mp[\\'h\\']--; mp[\\'t\\']--;\\n\\t\\t\\tcount[8]++;\\n\\t\\t}\\n\\t\\t//3\\n\\t\\twhile (mp[\\'h\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'t\\']--; mp[\\'h\\']--; mp[\\'r\\']--; mp[\\'e\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[3]++;\\n\\t\\t}\\n\\t\\t//2\\n\\t\\twhile (mp[\\'t\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'t\\']--; mp[\\'w\\']--; mp[\\'o\\']--;\\n\\t\\t\\tcount[2]++;\\n\\t\\t}\\n\\t\\t//4\\n\\t\\twhile (mp[\\'u\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'f\\']--; mp[\\'o\\']--; mp[\\'u\\']--; mp[\\'r\\']--;\\n\\t\\t\\tcount[4]++;\\n\\t\\t}\\n\\t\\t//5\\n\\t\\twhile (mp[\\'f\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'f\\']--; mp[\\'i\\']--; mp[\\'v\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[5]++;\\n\\t\\t}\\n\\t\\t//0\\n\\t\\twhile (mp[\\'r\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'z\\']--; mp[\\'e\\']--; mp[\\'r\\']--; mp[\\'o\\']--;\\n\\t\\t\\tcount[0]++;\\n\\t\\t}\\n\\t\\t//1\\n\\t\\twhile (mp[\\'o\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'o\\']--; mp[\\'n\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[1]++;\\n\\t\\t}\\n\\t\\t//7\\n\\t\\twhile (mp[\\'v\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'s\\']--; mp[\\'e\\']--; mp[\\'v\\']--; mp[\\'e\\']--; mp[\\'n\\']--;\\n\\t\\t\\tcount[7]++;\\n\\t\\t}\\n\\t\\t//9\\n\\t\\twhile (mp[\\'e\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'n\\']--; mp[\\'i\\']--; mp[\\'n\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[9]++;\\n\\t\\t}\\n\\t\\t//6\\n\\t\\twhile (mp[\\'i\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'s\\']--; mp[\\'i\\']--; mp[\\'x\\']--;\\n\\t\\t\\tcount[6]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tstring ans = \"\";\\n\\t\\tfor (int i = 0; i <= 9; i++)\\n\\t\\t{\\n\\t\\t\\tif (count[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans += string(count[i], char(i + \\'0\\'));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\n\\t// \"zero\" ,\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"\\n\\t/*\\n\\t\\t\\'e\\' : 0 1 3 5 7 8 9\\n\\t\\t\\'f\\' : 4 5\\n\\t\\t\\'g\\' : 8\\n\\t\\t\\'h\\' : 3 8\\n\\t\\t\\'i\\' : 5 6 8 9\\n\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\'r\\' : 0 3 4\\n\\t\\t\\'s\\' : 6 7\\n\\t\\t\\'t\\' : 2 3 8\\n\\t\\t\\'u\\' : 4\\n\\t\\t\\'v\\' : 5 7\\n\\t\\t\\'w\\' : 2\\n\\t\\t\\'x\\' : 6\\n\\t\\t\\'z\\' : 0\\n\\t*/\\n\\npublic:\\n\\tstring originalDigits(string s) {\\n\\t\\tunordered_map<char, int>mp;\\n\\t\\tfor (auto c : s)\\n\\t\\t{\\n\\t\\t\\tmp[c]++;\\n\\t\\t}\\n\\t\\tvector<int>count(10, 0);\\n\\n\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 3 5 7 8 9\\n\\t\\t\\t\\'f\\' : 4 5\\n\\t\\t\\t\\'g\\' : 8\\n\\t\\t\\t\\'h\\' : 3 8\\n\\t\\t\\t\\'i\\' : 5 6 8 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\t\\'r\\' : 0 3 4\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'t\\' : 2 3 8\\n\\t\\t\\t\\'u\\' : 4\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'w\\' : 2\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//8\\n\\t\\t// How Many \\'g\\' that many 8 in string\\n\\t\\twhile (mp[\\'g\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'e\\']--; mp[\\'i\\']--; mp[\\'g\\']--; mp[\\'h\\']--; mp[\\'t\\']--;\\n\\t\\t\\tcount[8]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 3 5 7 9\\n\\t\\t\\t\\'f\\' : 4 5\\n\\t\\t\\t\\'h\\' : 3\\n\\t\\t\\t\\'i\\' : 5 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\t\\'r\\' : 0 3 4\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'t\\' : 2 3\\n\\t\\t\\t\\'u\\' : 4\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'w\\' : 2\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//3\\n\\t\\t// How Many \\'h\\' that many 3 in string\\n\\t\\twhile (mp[\\'h\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'t\\']--; mp[\\'h\\']--; mp[\\'r\\']--; mp[\\'e\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[3]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 5 7 9\\n\\t\\t\\t\\'f\\' : 4 5\\n\\t\\t\\t\\'i\\' : 5 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1 2 4\\n\\t\\t\\t\\'r\\' : 0 4\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'t\\' : 2\\n\\t\\t\\t\\'u\\' : 4\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'w\\' : 2\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//2\\n\\t\\t// How Many \\'t\\' that many 2 in string\\n\\t\\twhile (mp[\\'t\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'t\\']--; mp[\\'w\\']--; mp[\\'o\\']--;\\n\\t\\t\\tcount[2]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 5 7 9\\n\\t\\t\\t\\'f\\' : 4 5\\n\\t\\t\\t\\'i\\' : 5 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1 4\\n\\t\\t\\t\\'r\\' : 0 4\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'u\\' : 4\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//4\\n\\t\\t// How Many \\'u\\' that many 4 in string\\n\\t\\twhile (mp[\\'u\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'f\\']--; mp[\\'o\\']--; mp[\\'u\\']--; mp[\\'r\\']--;\\n\\t\\t\\tcount[4]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 5 7 9\\n\\t\\t\\t\\'f\\' : 5\\n\\t\\t\\t\\'i\\' : 5 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1\\n\\t\\t\\t\\'r\\' : 0\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'v\\' : 5 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//5\\n\\t\\t// How Many \\'f\\' that many 5 in string\\n\\t\\twhile (mp[\\'f\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'f\\']--; mp[\\'i\\']--; mp[\\'v\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[5]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 0 1 7 9\\n\\t\\t\\t\\'i\\' : 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 0 1\\n\\t\\t\\t\\'r\\' : 0\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'v\\' : 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t\\t\\'z\\' : 0\\n\\t\\t*/\\n\\n\\t\\t//0\\n\\t\\t// How Many \\'r\\' that many 0 in string\\n\\t\\twhile (mp[\\'r\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'z\\']--; mp[\\'e\\']--; mp[\\'r\\']--; mp[\\'o\\']--;\\n\\t\\t\\tcount[0]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 1 7 9\\n\\t\\t\\t\\'i\\' : 6 9\\n\\t\\t\\t\\'n\\' : 1 7 9\\n\\t\\t\\t\\'o\\' : 1\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'v\\' : 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t*/\\n\\n\\t\\t//1\\n\\t\\t// How Many \\'o\\' that many 1 in string\\n\\t\\twhile (mp[\\'o\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'o\\']--; mp[\\'n\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[1]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 7 9\\n\\t\\t\\t\\'i\\' : 6 9\\n\\t\\t\\t\\'n\\' : 7 9\\n\\t\\t\\t\\'s\\' : 6 7\\n\\t\\t\\t\\'v\\' : 7\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t*/\\n\\n\\t\\t//7\\n\\t\\t// How Many \\'v\\' that many 7 in string\\n\\t\\twhile (mp[\\'v\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'s\\']--; mp[\\'e\\']--; mp[\\'v\\']--; mp[\\'e\\']--; mp[\\'n\\']--;\\n\\t\\t\\tcount[7]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'e\\' : 9\\n\\t\\t\\t\\'i\\' : 6 9\\n\\t\\t\\t\\'n\\' : 9\\n\\t\\t\\t\\'s\\' : 6\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t*/\\n\\n\\t\\t//9\\n\\t\\t// How Many \\'e\\' that many 9 in string\\n\\t\\twhile (mp[\\'e\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'n\\']--; mp[\\'i\\']--; mp[\\'n\\']--; mp[\\'e\\']--;\\n\\t\\t\\tcount[9]++;\\n\\t\\t}\\n\\t\\t/*\\n\\t\\t\\t\\'i\\' : 6\\n\\t\\t\\t\\'s\\' : 6\\n\\t\\t\\t\\'x\\' : 6\\n\\t\\t*/\\n\\n\\t\\t//6\\n\\t\\t// How Many \\'i\\' that many 6 in string\\n\\t\\twhile (mp[\\'i\\'] > 0)\\n\\t\\t{\\n\\t\\t\\tmp[\\'s\\']--; mp[\\'i\\']--; mp[\\'x\\']--;\\n\\t\\t\\tcount[6]++;\\n\\t\\t}\\n\\t\\t/*\\n\\n\\t\\t*/\\n\\n\\t\\tstring ans = \"\";\\n\\t\\tfor (int i = 0; i <= 9; i++)\\n\\t\\t{\\n\\t\\t\\tif (count[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans += string(count[i], char(i + \\'0\\'));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755358,
                "title": "c-96-o-n-explained-for-each-digit",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n\\t\\t// ASCII mapping\\n        vector<int> freq(128,0);\\n        vector<int> count(10,0);\\n        for(char c : s) {\\n            freq[c]++;\\n        }\\n        // EVEN HAVE UNIQUE ELEMENTS 0,2,4,6,8 have z w u x g characters as id\\n        count[0] = freq[\\'z\\'];\\n        count[2] = freq[\\'w\\'];\\n        count[4] = freq[\\'u\\'];\\n        count[6] = freq[\\'x\\'];\\n        count[8] = freq[\\'g\\'];\\n        \\n        // ODD WILL BE BOROWWED FROM EACH OTHER and EVEN\\n    \\n        // one has o has the id i.e 0 2 4 have to subtracted\\n        count[1] = freq[\\'o\\'] - count[0] - count[2] - count[4];\\n        \\n        // five has f which will be borrowed from remaining fs from four\\n        count[5] = freq[\\'f\\'] - count[4];\\n        \\n        // seven has NO unique elemnts therefore using v and subtracting 5 has v is common in them from it\\n        count[7] = freq[\\'v\\'] - count[5];\\n        \\n        // three has h as unique so remaining h\\'s left from eight\\n        count[3] = freq[\\'h\\'] - count[8];\\n        \\n        // nine has i as unique so remaining i\\'s from five, six, eight\\n        count[9] = freq[\\'i\\'] - count[5] - count[6] - count[8]; \\n        \\n        string output;\\n        for(int i = 0; i < 10; i++) {\\n            for(int f = count[i]; f > 0; f--) {\\n                output += i + \\'0\\';\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n\\t\\t// ASCII mapping\\n        vector<int> freq(128,0);\\n        vector<int> count(10,0);\\n        for(char c : s) {\\n            freq[c]++;\\n        }\\n        // EVEN HAVE UNIQUE ELEMENTS 0,2,4,6,8 have z w u x g characters as id\\n        count[0] = freq[\\'z\\'];\\n        count[2] = freq[\\'w\\'];\\n        count[4] = freq[\\'u\\'];\\n        count[6] = freq[\\'x\\'];\\n        count[8] = freq[\\'g\\'];\\n        \\n        // ODD WILL BE BOROWWED FROM EACH OTHER and EVEN\\n    \\n        // one has o has the id i.e 0 2 4 have to subtracted\\n        count[1] = freq[\\'o\\'] - count[0] - count[2] - count[4];\\n        \\n        // five has f which will be borrowed from remaining fs from four\\n        count[5] = freq[\\'f\\'] - count[4];\\n        \\n        // seven has NO unique elemnts therefore using v and subtracting 5 has v is common in them from it\\n        count[7] = freq[\\'v\\'] - count[5];\\n        \\n        // three has h as unique so remaining h\\'s left from eight\\n        count[3] = freq[\\'h\\'] - count[8];\\n        \\n        // nine has i as unique so remaining i\\'s from five, six, eight\\n        count[9] = freq[\\'i\\'] - count[5] - count[6] - count[8]; \\n        \\n        string output;\\n        for(int i = 0; i < 10; i++) {\\n            for(int f = count[i]; f > 0; f--) {\\n                output += i + \\'0\\';\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737899,
                "title": "python-solution-31ms-14-3mb",
                "content": "class Solution:\\n    def originalDigits(self, s: str) -> str:\\n        \\n        output = \"\"\\n        countNums = [0] * 10\\n        \\n        # z -> zero \\n        countNums[0] += s.count(\\'z\\')\\n            \\n        # w -> two\\n        countNums[2] += s.count(\\'w\\')\\n        \\n        # x -> six\\n        countNums[6] += s.count(\\'x\\')\\n         \\n        # g -> eight\\n        countNums[8] += s.count(\\'g\\')\\n        \\n        # u -> four\\n        countNums[4] += s.count(\\'u\\')\\n        \\n        # r -> can only be three, after four and zero\\n        countNums[3] += s.count(\\'r\\') - countNums[4] - countNums[0]\\n            \\n        # f -> can only be five , after four\\n        countNums[5] += s.count(\\'f\\') - countNums[4]\\n        \\n        # v -> seven, after five \\n        countNums[7] += s.count(\\'v\\') - countNums[5]\\n        \\n        # o -> one, after zero,two,four\\n        countNums[1] += s.count(\\'o\\') - countNums[0] - countNums[2] - countNums[4]\\n        \\n        # n -> nine, after one and seven\\n        countNums[9] += int((s.count(\\'n\\') - countNums[1] - countNums[7])/2)\\n        \\n        for i in range(len(countNums)):\\n            if(countNums[i]>0):\\n                output += str(i) * countNums[i]\\n        return output\\n\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def originalDigits(self, s: str) -> str:\\n        \\n        output = \"\"\\n        countNums = [0] * 10\\n        \\n        # z -> zero \\n        countNums[0] += s.count(\\'z\\')\\n            \\n        # w -> two\\n        countNums[2] += s.count(\\'w\\')\\n        \\n        # x -> six\\n        countNums[6] += s.count(\\'x\\')\\n         \\n        # g -> eight\\n        countNums[8] += s.count(\\'g\\')\\n        \\n        # u -> four\\n        countNums[4] += s.count(\\'u\\')\\n        \\n        # r -> can only be three, after four and zero\\n        countNums[3] += s.count(\\'r\\') - countNums[4] - countNums[0]\\n            \\n        # f -> can only be five , after four\\n        countNums[5] += s.count(\\'f\\') - countNums[4]\\n        \\n        # v -> seven, after five \\n        countNums[7] += s.count(\\'v\\') - countNums[5]\\n        \\n        # o -> one, after zero,two,four\\n        countNums[1] += s.count(\\'o\\') - countNums[0] - countNums[2] - countNums[4]\\n        \\n        # n -> nine, after one and seven\\n        countNums[9] += int((s.count(\\'n\\') - countNums[1] - countNums[7])/2)\\n        \\n        for i in range(len(countNums)):\\n            if(countNums[i]>0):\\n                output += str(i) * countNums[i]\\n        return output\\n\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1715675,
                "title": "python-5-backtracking-solution-because-i-wasn-t-smart-enough-to-figure-out-the-linear-solution",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        numberMap = {\\n            0: \"zero\",\\n            1: \"one\",\\n            2: \"two\",\\n            3: \"three\",\\n            4: \"four\",\\n            5: \"five\",\\n            6: \"six\",\\n            7: \"seven\",\\n            8: \"eight\",\\n            9: \"nine\"\\n        }\\n        \\n\\t\\t# Construct a dictionary of letters with the digits who have the letter in it\\n        letterMap = {}\\n        for number in numberMap:\\n            for c in set(numberMap[number]):\\n                if c in letterMap:\\n                    letterMap[c].append(number)\\n                else:\\n                    letterMap[c] = [number]\\n        letters = [l for l in letterMap]\\n\\t\\t\\n\\t\\t# Sort the letters which occurs the least times in digit strings\\n\\t\\t# It will improve the performance by picking digits with unique letters first\\n        letters.sort(key = lambda c: len(letterMap[c]))\\n        \\n\\t\\t# Convert the input string to a counter for O(1) updates\\n        inputStr = Counter(s)\\n        \\n\\t\\t# If some key has negative value, it isn\\'t valid\\n        def isValid():\\n            for key in inputStr:\\n                if inputStr[key] < 0:\\n                    return False\\n            return True\\n        \\n        def getTotal():\\n            return sum(inputStr.values())\\n        \\n\\t\\t# Pick the next letter which is in the input string\\n        def getNext():\\n            for letter in letters:\\n                if letter in inputStr and inputStr[letter] > 0:\\n                    return letter\\n            return None\\n        \\n\\t\\t# Backtracking function\\n        def getDigits():\\n            if not isValid():\\n                return None\\n            if getTotal() == 0:\\n                return []\\n            \\n            nextItem = getNext()\\n            \\n            for number in letterMap[nextItem]:\\n\\t\\t\\t\\t# pick a digit and try to remove it from input\\n                word = numberMap[number]\\n                inputStr.subtract(word)\\n                \\n                if not isValid():\\n\\t\\t\\t\\t\\t# not valid, try the next one\\n                    inputStr.update(word)\\n                    continue\\n                nextDigits = getDigits()\\n                if nextDigits != None:\\n\\t\\t\\t\\t\\t# Backtracking success! Return\\n                    return [number] + nextDigits\\n\\t\\t\\t\\t# not valid, try the next digit\\n                inputStr.update(word)\\n            return None\\n        \\n        digits = getDigits()\\n        digits.sort()\\n        \\n        return \"\".join([str(d) for d in digits])\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        numberMap = {\\n            0: \"zero\",\\n            1: \"one\",\\n            2: \"two\",\\n            3: \"three\",\\n            4: \"four\",\\n            5: \"five\",\\n            6: \"six\",\\n            7: \"seven\",\\n            8: \"eight\",\\n            9: \"nine\"\\n        }\\n        \\n\\t\\t# Construct a dictionary of letters with the digits who have the letter in it\\n        letterMap = {}\\n        for number in numberMap:\\n            for c in set(numberMap[number]):\\n                if c in letterMap:\\n                    letterMap[c].append(number)\\n                else:\\n                    letterMap[c] = [number]\\n        letters = [l for l in letterMap]\\n\\t\\t\\n\\t\\t# Sort the letters which occurs the least times in digit strings\\n\\t\\t# It will improve the performance by picking digits with unique letters first\\n        letters.sort(key = lambda c: len(letterMap[c]))\\n        \\n\\t\\t# Convert the input string to a counter for O(1) updates\\n        inputStr = Counter(s)\\n        \\n\\t\\t# If some key has negative value, it isn\\'t valid\\n        def isValid():\\n            for key in inputStr:\\n                if inputStr[key] < 0:\\n                    return False\\n            return True\\n        \\n        def getTotal():\\n            return sum(inputStr.values())\\n        \\n\\t\\t# Pick the next letter which is in the input string\\n        def getNext():\\n            for letter in letters:\\n                if letter in inputStr and inputStr[letter] > 0:\\n                    return letter\\n            return None\\n        \\n\\t\\t# Backtracking function\\n        def getDigits():\\n            if not isValid():\\n                return None\\n            if getTotal() == 0:\\n                return []\\n            \\n            nextItem = getNext()\\n            \\n            for number in letterMap[nextItem]:\\n\\t\\t\\t\\t# pick a digit and try to remove it from input\\n                word = numberMap[number]\\n                inputStr.subtract(word)\\n                \\n                if not isValid():\\n\\t\\t\\t\\t\\t# not valid, try the next one\\n                    inputStr.update(word)\\n                    continue\\n                nextDigits = getDigits()\\n                if nextDigits != None:\\n\\t\\t\\t\\t\\t# Backtracking success! Return\\n                    return [number] + nextDigits\\n\\t\\t\\t\\t# not valid, try the next digit\\n                inputStr.update(word)\\n            return None\\n        \\n        digits = getDigits()\\n        digits.sort()\\n        \\n        return \"\".join([str(d) for d in digits])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688339,
                "title": "speed-98-29-and-memory-62-85",
                "content": "+ Memoize the *occurrence count* of uniquely spelled numbers (naturally all of the even numbers).\\n\\t+ This is done by storing `number_here: s.count(\\'unique_letter_here\\')` in a dictionary.\\n+ Memoize other spelled numbers (all of the odds).\\n\\t+ Since the odds are not unique, we must derive their value by subtracting every overlapping, uniquely spelled number count.\\n\\t+ Since we\\'ve already memoized the counts for the evens, we can reference them while subtracting.\\n+ Create the list that will be extended based on each discovered word.\\n\\t+ This is done by `if \\'unique_letter\\' in s: str_list.extend([\\'number_here\\'] * even[number_here])`.\\n\\t+ This will add the number\\'s numerical representation (still in string form) to the `str_list` we created, the appropriate number of times.\\n+ Sort and join.\\n\\t+ One now has a string of ordered numbers that can be returned to satisfy the question.\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        str_list = []\\n        \\n        even = { 0: s.count(\\'z\\'), 2: s.count(\\'w\\'), 4: s.count(\\'u\\'), 6: s.count(\\'x\\'), 8: s.count(\\'g\\') } \\n        \\n        odd = { \\n                1: s.count(\\'o\\') - even[0] - even[2] - even[4], \\n                3: s.count(\\'t\\') - even[2] - even[8], \\n                5: s.count(\\'f\\') - even[4], \\n                7: s.count(\\'s\\') - even[6], \\n                9: s.count(\\'i\\') - even[6] - even[8] - (s.count(\\'f\\') - even[4]) \\n        }\\n        \\n        if \\'z\\' in s: str_list.extend([\\'0\\'] * even[0])\\n        if \\'w\\' in s: str_list.extend([\\'2\\'] * even[2])\\n        if \\'u\\' in s: str_list.extend([\\'4\\'] * even[4])    \\n        if \\'x\\' in s: str_list.extend([\\'6\\'] * even[6])\\n        if \\'g\\' in s: str_list.extend([\\'8\\'] * even[8])\\n        if \\'o\\' in s: str_list.extend([\\'1\\'] * odd[1])\\n        if \\'t\\' in s: str_list.extend([\\'3\\'] * odd[3])\\n        if \\'f\\' in s: str_list.extend([\\'5\\'] * odd[5])\\n        if \\'s\\' in s: str_list.extend([\\'7\\'] * odd[7])\\n        if \\'i\\' in s: str_list.extend([\\'9\\'] * odd[9])\\n        \\n        str_list.sort()\\n        return \\'\\'.join(str_list)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        str_list = []\\n        \\n        even = { 0: s.count(\\'z\\'), 2: s.count(\\'w\\'), 4: s.count(\\'u\\'), 6: s.count(\\'x\\'), 8: s.count(\\'g\\') } \\n        \\n        odd = { \\n                1: s.count(\\'o\\') - even[0] - even[2] - even[4], \\n                3: s.count(\\'t\\') - even[2] - even[8], \\n                5: s.count(\\'f\\') - even[4], \\n                7: s.count(\\'s\\') - even[6], \\n                9: s.count(\\'i\\') - even[6] - even[8] - (s.count(\\'f\\') - even[4]) \\n        }\\n        \\n        if \\'z\\' in s: str_list.extend([\\'0\\'] * even[0])\\n        if \\'w\\' in s: str_list.extend([\\'2\\'] * even[2])\\n        if \\'u\\' in s: str_list.extend([\\'4\\'] * even[4])    \\n        if \\'x\\' in s: str_list.extend([\\'6\\'] * even[6])\\n        if \\'g\\' in s: str_list.extend([\\'8\\'] * even[8])\\n        if \\'o\\' in s: str_list.extend([\\'1\\'] * odd[1])\\n        if \\'t\\' in s: str_list.extend([\\'3\\'] * odd[3])\\n        if \\'f\\' in s: str_list.extend([\\'5\\'] * odd[5])\\n        if \\'s\\' in s: str_list.extend([\\'7\\'] * odd[7])\\n        if \\'i\\' in s: str_list.extend([\\'9\\'] * odd[9])\\n        \\n        str_list.sort()\\n        return \\'\\'.join(str_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645286,
                "title": "python-every-number-has-its-specials-char-in-order",
                "content": "Now python dictionary is keeping order.\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        ct = Counter(s)\\n        d2 = {\\n            \\'z\\': (\\'0\\', \\'zero\\'),\\n            \\'x\\': (\\'6\\', \\'six\\'),\\n            \\'w\\': (\\'2\\', \\'two\\'),\\n            \\'u\\': (\\'4\\', \\'four\\'),\\n            \\'o\\': (\\'1\\', \\'one\\'),\\n            \\'r\\': (\\'3\\', \\'three\\'),\\n            \\'h\\': (\\'8\\', \\'eight\\'),\\n            \\'f\\': (\\'5\\', \\'five\\'),\\n            \\'v\\': (\\'7\\', \\'seven\\'),\\n            \\'i\\': (\\'9\\', \\'nine\\')}\\n        ans=[]\\n        for k,v in d2.items():\\n            if k in ct:\\n                times= ct[k]\\n                ans += times*[v[0]]\\n                for c in v[1]:\\n                    ct[c]-=times\\n                    if ct[c]==0: del(ct[c])\\n        ans.sort()\\n        return \"\".join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        ct = Counter(s)\\n        d2 = {\\n            \\'z\\': (\\'0\\', \\'zero\\'),\\n            \\'x\\': (\\'6\\', \\'six\\'),\\n            \\'w\\': (\\'2\\', \\'two\\'),\\n            \\'u\\': (\\'4\\', \\'four\\'),\\n            \\'o\\': (\\'1\\', \\'one\\'),\\n            \\'r\\': (\\'3\\', \\'three\\'),\\n            \\'h\\': (\\'8\\', \\'eight\\'),\\n            \\'f\\': (\\'5\\', \\'five\\'),\\n            \\'v\\': (\\'7\\', \\'seven\\'),\\n            \\'i\\': (\\'9\\', \\'nine\\')}\\n        ans=[]\\n        for k,v in d2.items():\\n            if k in ct:\\n                times= ct[k]\\n                ans += times*[v[0]]\\n                for c in v[1]:\\n                    ct[c]-=times\\n                    if ct[c]==0: del(ct[c])\\n        ans.sort()\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601985,
                "title": "python3-simple-o-n-via-ruleset",
                "content": "```python\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        c = Counter(s)\\n        \\n        c0 = c[\"z\"]\\n        c2 = c[\"w\"]\\n        c4 = c[\"u\"]\\n        c5 = c[\"f\"] - c4\\n        c6 = c[\"x\"]\\n        c7 = c[\"s\"] - c6\\n        c8 = c[\"g\"]\\n        c3 = c[\"h\"] - c8\\n        c9 = c[\"i\"] - (c5 + c6 + c8)\\n        c1 = c[\"o\"] - (c0 + c2 + c4)\\n        \\n        return \\'\\'.join(chain(str(i) * x for i, x in enumerate((c0, c1, c2, c3, c4, c5, c6, c7, c8, c9)) if x))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        c = Counter(s)\\n        \\n        c0 = c[\"z\"]\\n        c2 = c[\"w\"]\\n        c4 = c[\"u\"]\\n        c5 = c[\"f\"] - c4\\n        c6 = c[\"x\"]\\n        c7 = c[\"s\"] - c6\\n        c8 = c[\"g\"]\\n        c3 = c[\"h\"] - c8\\n        c9 = c[\"i\"] - (c5 + c6 + c8)\\n        c1 = c[\"o\"] - (c0 + c2 + c4)\\n        \\n        return \\'\\'.join(chain(str(i) * x for i, x in enumerate((c0, c1, c2, c3, c4, c5, c6, c7, c8, c9)) if x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494745,
                "title": "counting-char-frequency",
                "content": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] count = new int[26];\\n        \\n        for(char c : s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        int[] times = new int[10];\\n        times[6] = count[\\'x\\' - \\'a\\'];\\n        times[8] = count[\\'g\\' - \\'a\\'];\\n        times[0] = count[\\'z\\' - \\'a\\'];\\n        times[4] = count[\\'u\\' - \\'a\\'];\\n        times[2] = count[\\'w\\' - \\'a\\'];\\n        \\n        times[7] = count[\\'s\\' - \\'a\\'] - times[6];\\n        times[5] = count[\\'v\\' - \\'a\\'] - times[7];\\n        times[3] = count[\\'h\\' - \\'a\\'] - times[8];\\n        times[1] = count[\\'o\\' - \\'a\\'] - times[0] - times[2] - times[4];\\n        times[9] = (count[\\'n\\' - \\'a\\'] - times[7] - times[1]) / 2;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i <= 9; i++){\\n            while(times[i] > 0){\\n                sb.append(i);\\n                times[i]--;\\n            }\\n        }\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] count = new int[26];\\n        \\n        for(char c : s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        int[] times = new int[10];\\n        times[6] = count[\\'x\\' - \\'a\\'];\\n        times[8] = count[\\'g\\' - \\'a\\'];\\n        times[0] = count[\\'z\\' - \\'a\\'];\\n        times[4] = count[\\'u\\' - \\'a\\'];\\n        times[2] = count[\\'w\\' - \\'a\\'];\\n        \\n        times[7] = count[\\'s\\' - \\'a\\'] - times[6];\\n        times[5] = count[\\'v\\' - \\'a\\'] - times[7];\\n        times[3] = count[\\'h\\' - \\'a\\'] - times[8];\\n        times[1] = count[\\'o\\' - \\'a\\'] - times[0] - times[2] - times[4];\\n        times[9] = (count[\\'n\\' - \\'a\\'] - times[7] - times[1]) / 2;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i <= 9; i++){\\n            while(times[i] > 0){\\n                sb.append(i);\\n                times[i]--;\\n            }\\n        }\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465393,
                "title": "python-trickey",
                "content": "```python\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        map_1 = {\\n            \\'z\\': [\\'0\\', \\'e\\', \\'r\\', \\'o\\'],\\n            \\'w\\': [\\'2\\', \\'t\\', \\'o\\'],\\n            \\'u\\': [\\'4\\', \\'f\\', \\'o\\', \\'r\\'],\\n            \\'x\\': [\\'6\\', \\'s\\', \\'i\\'],\\n            \\'g\\': [\\'8\\', \\'e\\', \\'i\\', \\'h\\', \\'t\\'],\\n            \\'o\\': [\\'1\\', \\'n\\', \\'e\\'],\\n            \\'r\\': [\\'3\\', \\'t\\', \\'h\\', \\'e\\', \\'e\\'],\\n            \\'s\\': [\\'7\\', \\'e\\', \\'v\\', \\'e\\', \\'n\\'],\\n            \\'v\\': [\\'5\\', \\'f\\', \\'i\\', \\'e\\'],\\n            \\'i\\': [\\'9\\', \\'n\\', \\'n\\', \\'e\\']\\n        }\\n        \\n        map_3 = {}\\n        ans = []\\n        for c in s:\\n            if not c in map_3:\\n                map_3[c] = 1\\n            else:\\n                map_3[c] += 1\\n                \\n        for k in map_1.keys():\\n            if k in map_3 and map_3[k]>0:\\n                ans.append(map_1[k][0]*map_3[k])\\n                for i in range(1, len(map_1[k])): \\n                    map_3[map_1[k][i]] -= map_3[k]\\n                map_3[k] = 0\\n        ans.sort()\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        map_1 = {\\n            \\'z\\': [\\'0\\', \\'e\\', \\'r\\', \\'o\\'],\\n            \\'w\\': [\\'2\\', \\'t\\', \\'o\\'],\\n            \\'u\\': [\\'4\\', \\'f\\', \\'o\\', \\'r\\'],\\n            \\'x\\': [\\'6\\', \\'s\\', \\'i\\'],\\n            \\'g\\': [\\'8\\', \\'e\\', \\'i\\', \\'h\\', \\'t\\'],\\n            \\'o\\': [\\'1\\', \\'n\\', \\'e\\'],\\n            \\'r\\': [\\'3\\', \\'t\\', \\'h\\', \\'e\\', \\'e\\'],\\n            \\'s\\': [\\'7\\', \\'e\\', \\'v\\', \\'e\\', \\'n\\'],\\n            \\'v\\': [\\'5\\', \\'f\\', \\'i\\', \\'e\\'],\\n            \\'i\\': [\\'9\\', \\'n\\', \\'n\\', \\'e\\']\\n        }\\n        \\n        map_3 = {}\\n        ans = []\\n        for c in s:\\n            if not c in map_3:\\n                map_3[c] = 1\\n            else:\\n                map_3[c] += 1\\n                \\n        for k in map_1.keys():\\n            if k in map_3 and map_3[k]>0:\\n                ans.append(map_1[k][0]*map_3[k])\\n                for i in range(1, len(map_1[k])): \\n                    map_3[map_1[k][i]] -= map_3[k]\\n                map_3[k] = 0\\n        ans.sort()\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444699,
                "title": "java-13ms-sol-and-python-90ms-sol",
                "content": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        /*characters in s put together form digits from 0-9. \\n\\t\\tThe count array stores occurence count of these digits. \\n\\t\\tWhen we iterate over it at the end it helps return digits in ascending order.*/\\n        int[] count = new int[10];\\n        /*Hashmap to store count of each occuring character*/\\n        Map<Character, Integer> hm = new HashMap<>();\\n        for (char c : s.toCharArray()){\\n            hm.put(c, hm.getOrDefault(c, 0) + 1);\\n        }\\n        //System.out.println(\"hm is \" + hm);\\n        //fillup even index in count since they have unique chars.\\n        /*zero will have \\'z\\' as unique when compared with other strings \\n\\t\\trepresenting numbers between 0-9 eg: two, three, six etc.*/\\n        count[0] = hm.getOrDefault(\\'z\\', 0);\\n\\t\\t/*two has \\'w\\' as unique*/\\n        count[2] = hm.getOrDefault(\\'w\\', 0);\\n\\t\\t/*four has \\'u\\' as unique*/\\n        count[4] = hm.getOrDefault(\\'u\\', 0);\\n\\t\\t/*six has \\'x\\' as unique*/\\n        count[6] = hm.getOrDefault(\\'x\\', 0);\\n\\t\\t/*eight has \\'g\\' as unique*/\\n        count[8] = hm.getOrDefault(\\'g\\', 0);\\n        /*fillup odd indexes now using the even counts. \\n\\t\\tWe chose letters for the odd number(three, five, seven etc) that occur \\n\\t\\tin the least even numbers. eg for three we chose \\'h\\' over \\'t\\' as it occurs only once \\n\\t\\tmore in eight compared to t occuring in two and eight.*/\\n        \\n        /*since \\'h\\' occurs in three and eight only.*/\\n        count[3] = hm.getOrDefault(\\'h\\', 0) - count[8];\\n        /*since \\'f\\' occurs in five and four only.*/\\n        count[5] = hm.getOrDefault(\\'f\\', 0) - count[4];\\n        /*since \\'s\\' occurs in six and seven only.*/\\n        count[7] = hm.getOrDefault(\\'s\\', 0) - count[6];\\n        /*since \\'i\\' occurs in eight, six, five and nine only.*/\\n        count[9] = hm.getOrDefault(\\'i\\', 0) - count[8] - count[6] - count[5];\\n        /*since \\'n\\' occurs once in seven and one and twice in nine.*/ \\n        count[1] = hm.getOrDefault(\\'n\\', 0) - count[7] - 2* count[9];\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i=0; i < 10; i++){\\n            while (count[i] > 0){\\n                res.append(i);\\n                count[i]--;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```\\n\\n#### python sol\\n\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        count  = [0]*10\\n        counter = defaultdict(int)\\n        for c in s: \\n            counter[c] += 1\\n        count[0] = counter[\\'z\\']\\n        count[2] = counter[\\'w\\']\\n        count[4] = counter[\\'u\\']\\n        count[6] = counter[\\'x\\']\\n        count[8] = counter[\\'g\\']\\n        \\n        count[3] = counter[\\'h\\'] - count[8]\\n        count[5] = counter[\\'f\\'] - count[4]\\n        count[7] = counter[\\'s\\'] - count[6]\\n        count[9] = counter[\\'i\\'] - count[5] - count[6] - count[8]\\n        count[1]  = counter[\\'n\\'] - count[7] -  2*count[9]\\n        \\n        res =\\'\\'\\n        for i in range(len(count)):\\n            if count[i]:\\n                res+= (str(i)* count[i])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        /*characters in s put together form digits from 0-9. \\n\\t\\tThe count array stores occurence count of these digits. \\n\\t\\tWhen we iterate over it at the end it helps return digits in ascending order.*/\\n        int[] count = new int[10];\\n        /*Hashmap to store count of each occuring character*/\\n        Map<Character, Integer> hm = new HashMap<>();\\n        for (char c : s.toCharArray()){\\n            hm.put(c, hm.getOrDefault(c, 0) + 1);\\n        }\\n        //System.out.println(\"hm is \" + hm);\\n        //fillup even index in count since they have unique chars.\\n        /*zero will have \\'z\\' as unique when compared with other strings \\n\\t\\trepresenting numbers between 0-9 eg: two, three, six etc.*/\\n        count[0] = hm.getOrDefault(\\'z\\', 0);\\n\\t\\t/*two has \\'w\\' as unique*/\\n        count[2] = hm.getOrDefault(\\'w\\', 0);\\n\\t\\t/*four has \\'u\\' as unique*/\\n        count[4] = hm.getOrDefault(\\'u\\', 0);\\n\\t\\t/*six has \\'x\\' as unique*/\\n        count[6] = hm.getOrDefault(\\'x\\', 0);\\n\\t\\t/*eight has \\'g\\' as unique*/\\n        count[8] = hm.getOrDefault(\\'g\\', 0);\\n        /*fillup odd indexes now using the even counts. \\n\\t\\tWe chose letters for the odd number(three, five, seven etc) that occur \\n\\t\\tin the least even numbers. eg for three we chose \\'h\\' over \\'t\\' as it occurs only once \\n\\t\\tmore in eight compared to t occuring in two and eight.*/\\n        \\n        /*since \\'h\\' occurs in three and eight only.*/\\n        count[3] = hm.getOrDefault(\\'h\\', 0) - count[8];\\n        /*since \\'f\\' occurs in five and four only.*/\\n        count[5] = hm.getOrDefault(\\'f\\', 0) - count[4];\\n        /*since \\'s\\' occurs in six and seven only.*/\\n        count[7] = hm.getOrDefault(\\'s\\', 0) - count[6];\\n        /*since \\'i\\' occurs in eight, six, five and nine only.*/\\n        count[9] = hm.getOrDefault(\\'i\\', 0) - count[8] - count[6] - count[5];\\n        /*since \\'n\\' occurs once in seven and one and twice in nine.*/ \\n        count[1] = hm.getOrDefault(\\'n\\', 0) - count[7] - 2* count[9];\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i=0; i < 10; i++){\\n            while (count[i] > 0){\\n                res.append(i);\\n                count[i]--;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        count  = [0]*10\\n        counter = defaultdict(int)\\n        for c in s: \\n            counter[c] += 1\\n        count[0] = counter[\\'z\\']\\n        count[2] = counter[\\'w\\']\\n        count[4] = counter[\\'u\\']\\n        count[6] = counter[\\'x\\']\\n        count[8] = counter[\\'g\\']\\n        \\n        count[3] = counter[\\'h\\'] - count[8]\\n        count[5] = counter[\\'f\\'] - count[4]\\n        count[7] = counter[\\'s\\'] - count[6]\\n        count[9] = counter[\\'i\\'] - count[5] - count[6] - count[8]\\n        count[1]  = counter[\\'n\\'] - count[7] -  2*count[9]\\n        \\n        res =\\'\\'\\n        for i in range(len(count)):\\n            if count[i]:\\n                res+= (str(i)* count[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345519,
                "title": "423-reconstruct-original-digits-from-english-c-cpp-using-counters",
                "content": "/**\\nFirst consider the digits that have an unqiue alphabet bet in their spelling.\\ni.e. that character is only appearing in that digit.\\nFor example: \\n0 : Zero\\n2 : tWo\\n4 : foUr\\n6 : siX\\n8 : eiGht\\nNotice the caps.It means that \\'Z\\' only appears in zero,\\n\\'W\\' only appears in two, \\'U\\' only appears in four, \\n\\'x\\' only appears in six and \\'g\\' only appears in eight.\\n\\nIf we find \\'z\\' in input string then it means zero appears.\\nSimlarly if we found \\'z\\' n times then it means the zero has appeared has n times\\nin the input string. Simlarly we conclude for other numbers.\\n\\nFirst we will find how many times each even number occurs. Then we will move\\ntowards finding odd numbers except 9 which is special case. Now that we know we\\nare left odd numbers we derive unique character pattern for odd numbers too.\\n1 : One\\n3 : Three\\n5 : fiVe\\n7 : Seven\\n Working of algorithm:\\n 1. An unordered_map is used to calculate the frequency of each character.\\n 2. Next we initalize an array(digit_info_arr) of 10 length with \\'digit_info\\' type. Which \\n    stores info about each digit(unique char, integer value, spelling).\\n    For instance:\\n    for zero it would be {\\'z\\', 0, \"zero\"}\\n    for two it would be  {\\'w\\', 2, \"two\"}\\n    unique character pattern is described above\\n    Note: order in which elements are defined in the array is important\\n3. Next we initalize a counters array(counters), which stores how many time \\n   each digit appears in the input string.\\n\\n4. Next we traverse digit_info_arr, count the occurrence of each unique_char\\n   in char_counter map (mentioned in step 1).\\n   4.1 if unqiue character appears more than 0 times:\\n   4.1.1 then we increment counters array value at idx position\\n   4.1.2 then decrement the count of character from map while doing so\\n         if count of char in map goes to 0 we delete it from the map.\\n5. Now we are done finding all digits from 0 to 8 inclusive. Since \\'nine\\'\\n   contains \\'n\\' two times in itself and atleast once it other digits.\\n   Now count \\'n\\' in the map divide the count by 2, giving the total number\\n   of time 9 appears in the input string and updates its count in counters array\\n   at index 9.\\n6. Now we generate string from counters array. We start traversing\\n   the counters array from left and insert count[idx] copies of idx in\\n   resultant string.\\n*/\\n\\nclass Solution {\\n    struct digit_info\\n    {\\n        char ch;\\n        int idx;\\n        const char* alpha;\\n    };\\npublic:\\n    string originalDigits(string s) \\n    {\\n        std::unordered_map<char, int> char_counter{generate_frequency_counter(s)};\\n        const std::array<digit_info, 10> digit_info_arr{{\\n            {\\'z\\', 0, \"zero\"},\\n            {\\'w\\', 2, \"two\"},\\n            {\\'u\\', 4, \"four\"},\\n            {\\'x\\', 6, \"six\"},\\n            {\\'g\\', 8, \"eight\"},\\n            {\\'o\\', 1, \"one\"},\\n            {\\'t\\', 3, \"three\"},\\n            {\\'f\\', 5, \"five\"},\\n            {\\'s\\', 7, \"seven\"}\\n        }};\\n        std::array<int, 10> counter{};\\n        std::fill(counter.begin(), counter.end(), 0);\\n\\n        for (const auto &[unique_ch, idx, alpha] : digit_info_arr)\\n        {\\n            if (char_counter.empty()) { break; }\\n            if (int total_ocurrences{ char_counter[unique_ch] }; total_ocurrences > 0)\\n            {\\n                counter[idx] += total_ocurrences;\\n                remove_string_from_map_n(char_counter, alpha, total_ocurrences);\\n            }\\n        }\\n        if (char_counter.find(\\'n\\') != char_counter.cend() && char_counter[\\'n\\'] > 0)\\n        {\\n            counter[9] = char_counter[\\'n\\'] / 2;\\n        }\\n        return string_from_counters(counter);\\n    }\\nprivate:\\n    string string_from_counters(const std::array<int, 10>& counters)\\n    {\\n        int total_lenght{ std::accumulate(counters.cbegin(), counters.cend(), 0) };\\n        string str;\\n        str.reserve(total_lenght);\\n        for (size_t idx{ 0 }, sz{ counters.size() }; idx < sz ;++idx)\\n        {\\n            if (counters[idx] > 0)\\n            {\\n                str.insert(str.end(), counters[idx], \\'0\\' + idx);\\n            }\\n        }\\n    return str;\\n    }\\n    void remove_string_from_map_n(std::unordered_map<char, int>& char_counter, const string& str, int no_of_time_to_delete)\\n    {\\n        for (const char& ch : str)\\n        {\\n            char_counter[ch] -= no_of_time_to_delete;\\n            if (char_counter[ch] <= 0)\\n            {\\n                char_counter.erase(ch);\\n            }\\n        }\\n    }\\n    std::unordered_map<char, int> generate_frequency_counter(const string &str)\\n    {\\n        std::unordered_map<char, int> counter;\\n        for (const auto& ch : str)\\n        {\\n            ++counter[ch];\\n        }\\n        return counter;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    struct digit_info\\n    {\\n        char ch;\\n        int idx;\\n        const char* alpha;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1171021,
                "title": "c-solution",
                "content": "```\\n    string originalDigits(string s) {\\n        std::vector<int>freqV(26,0);\\n        for (char c:s)\\n            freqV[c-\\'a\\']++;\\n        std::vector<int>digitCountV(10);\\n        digitCountV[0] = freqV[\\'z\\'-\\'a\\'];\\n        digitCountV[2] = freqV[\\'w\\'-\\'a\\'];\\n        digitCountV[4] = freqV[\\'u\\'-\\'a\\'];\\n        digitCountV[6] = freqV[\\'x\\'-\\'a\\'];\\n        digitCountV[8] = freqV[\\'g\\'-\\'a\\'];\\n        digitCountV[3] = freqV[\\'h\\'-\\'a\\']-digitCountV[8];\\n        digitCountV[5] = freqV[\\'f\\'-\\'a\\']-digitCountV[4];\\n        digitCountV[7] = freqV[\\'s\\'-\\'a\\']-digitCountV[6];\\n        digitCountV[9] = freqV[\\'i\\'-\\'a\\']-digitCountV[5]-digitCountV[6]-digitCountV[8];\\n        digitCountV[1] = freqV[\\'o\\'-\\'a\\']-digitCountV[0]-digitCountV[2]-digitCountV[4];\\n        \\n        string res;\\n        for (int i = 0; i < 10; i++)\\n            for (int j = 0; j < digitCountV[i]; j++)\\n                res.push_back(i+\\'0\\');\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string originalDigits(string s) {\\n        std::vector<int>freqV(26,0);\\n        for (char c:s)\\n            freqV[c-\\'a\\']++;\\n        std::vector<int>digitCountV(10);\\n        digitCountV[0] = freqV[\\'z\\'-\\'a\\'];\\n        digitCountV[2] = freqV[\\'w\\'-\\'a\\'];\\n        digitCountV[4] = freqV[\\'u\\'-\\'a\\'];\\n        digitCountV[6] = freqV[\\'x\\'-\\'a\\'];\\n        digitCountV[8] = freqV[\\'g\\'-\\'a\\'];\\n        digitCountV[3] = freqV[\\'h\\'-\\'a\\']-digitCountV[8];\\n        digitCountV[5] = freqV[\\'f\\'-\\'a\\']-digitCountV[4];\\n        digitCountV[7] = freqV[\\'s\\'-\\'a\\']-digitCountV[6];\\n        digitCountV[9] = freqV[\\'i\\'-\\'a\\']-digitCountV[5]-digitCountV[6]-digitCountV[8];\\n        digitCountV[1] = freqV[\\'o\\'-\\'a\\']-digitCountV[0]-digitCountV[2]-digitCountV[4];\\n        \\n        string res;\\n        for (int i = 0; i < 10; i++)\\n            for (int j = 0; j < digitCountV[i]; j++)\\n                res.push_back(i+\\'0\\');\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132393,
                "title": "python-count-in-order",
                "content": "The idea is to leave ambiguous cases to the end where they are no longer so. For example `0` is to only digit to contain letter `z`, 6 is the only digit to contain `x`. You can do these first. Both `4` and `5` contain `f` but only `4` contains `ou`. So after you eliminate `4`, `5` is the only one with letter `f`. So on and so forth. There are multiple ways you can go; but not any arbitrary order works. Below is one that works.\\n\\n```python\\nfrom collections import Counter\\nclass Solution:\\n    def originalDigits(self, s):\\n        parts = []\\n        s_count = Counter(s)\\n        \\n        #count 0\\'s\\n        count0 = s_count[\\'z\\']\\n        for c in \\'zero\\': \\n            s_count[c] -= count0\\n        parts += [\\'0\\']*count0\\n        \\n        #count 4\\'s\\n        count4 = min(s_count[\\'o\\'], s_count[\\'u\\'])\\n        for c in \\'four\\':\\n            s_count[c] -= count4\\n        parts += [\\'4\\']*count4\\n        \\n        #count 5\\'s\\n        count5 = s_count[\\'f\\']\\n        for c in \\'five\\':\\n            s_count[c] -= count5\\n        parts += [\\'5\\']*count5\\n            \\n        #count 6\\'s\\n        count6 = s_count[\\'x\\']\\n        for c in \\'six\\':\\n            s_count[c] -= count6\\n        parts += [\\'6\\']*count6\\n        \\n        #count 8\\'s\\n        count8 = s_count[\\'g\\']\\n        for c in \\'eight\\':\\n            s_count[c] -= count8\\n        parts += [\\'8\\']*count8\\n        \\n        #count 9\\'s\\n        count9 = s_count[\\'i\\']\\n        for c in \\'nine\\':\\n            s_count[c] -= count9\\n        parts += [\\'9\\']*count9\\n        \\n        #count 7\\'s\\n        count7 = s_count[\\'v\\']\\n        for c in \\'seven\\':\\n            s_count[c] -= count7\\n        parts += [\\'7\\']*count7\\n        \\n        #count 3\\'s\\n        count3 = s_count[\\'h\\']\\n        for c in \\'three\\':\\n            s_count[c] -= count3\\n        parts += [\\'3\\']*count3\\n        \\n        #count 2\\'s\\n        count2 = s_count[\\'w\\']\\n        for c in \\'two\\':\\n            s_count[c] -= count2\\n        parts += [\\'2\\']*count2\\n        \\n        #count 1\\'s\\n        count1 = s_count[\\'o\\']\\n        for c in \\'one\\':\\n            s_count[c] -= count1\\n        parts += [\\'1\\']*count1\\n        \\n        return \\'\\'.join(sorted(parts))\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter\\nclass Solution:\\n    def originalDigits(self, s):\\n        parts = []\\n        s_count = Counter(s)\\n        \\n        #count 0\\'s\\n        count0 = s_count[\\'z\\']\\n        for c in \\'zero\\': \\n            s_count[c] -= count0\\n        parts += [\\'0\\']*count0\\n        \\n        #count 4\\'s\\n        count4 = min(s_count[\\'o\\'], s_count[\\'u\\'])\\n        for c in \\'four\\':\\n            s_count[c] -= count4\\n        parts += [\\'4\\']*count4\\n        \\n        #count 5\\'s\\n        count5 = s_count[\\'f\\']\\n        for c in \\'five\\':\\n            s_count[c] -= count5\\n        parts += [\\'5\\']*count5\\n            \\n        #count 6\\'s\\n        count6 = s_count[\\'x\\']\\n        for c in \\'six\\':\\n            s_count[c] -= count6\\n        parts += [\\'6\\']*count6\\n        \\n        #count 8\\'s\\n        count8 = s_count[\\'g\\']\\n        for c in \\'eight\\':\\n            s_count[c] -= count8\\n        parts += [\\'8\\']*count8\\n        \\n        #count 9\\'s\\n        count9 = s_count[\\'i\\']\\n        for c in \\'nine\\':\\n            s_count[c] -= count9\\n        parts += [\\'9\\']*count9\\n        \\n        #count 7\\'s\\n        count7 = s_count[\\'v\\']\\n        for c in \\'seven\\':\\n            s_count[c] -= count7\\n        parts += [\\'7\\']*count7\\n        \\n        #count 3\\'s\\n        count3 = s_count[\\'h\\']\\n        for c in \\'three\\':\\n            s_count[c] -= count3\\n        parts += [\\'3\\']*count3\\n        \\n        #count 2\\'s\\n        count2 = s_count[\\'w\\']\\n        for c in \\'two\\':\\n            s_count[c] -= count2\\n        parts += [\\'2\\']*count2\\n        \\n        #count 1\\'s\\n        count1 = s_count[\\'o\\']\\n        for c in \\'one\\':\\n            s_count[c] -= count1\\n        parts += [\\'1\\']*count1\\n        \\n        return \\'\\'.join(sorted(parts))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132381,
                "title": "c-long-but-easy-to-understand-approach-explained",
                "content": "Zero = \\'z\\', Two-\\'w\\', Four -\\'u\\', Six -\\'x\\', Eight-\\'g\\' unique letters\\nOnce Four is processed and any more \\'r\\' left... that is Three\\nAny more \\'f\\' left, that is Five\\nAfter Six is processed and any more \\'v\\' left, that is Seven\\nAny more \\'o\\' left is One and after one is processed if any more \\'n\\' left, that is Nine.\\nSort the final string . \\n```\\n string originalDigits(string s) {\\n        string main, str;\\n        vector<int> vec(26,0);\\n        int i,j, count, val, size;\\n        size = s.size();\\n        for(i=0; i<s.size(); i++)\\n            vec[s[i]-\\'a\\']++;\\n      \\n        while(size>0)\\n        {\\n            while(size && vec[\\'z\\'-\\'a\\'])\\n            {\\n                str.append(\"0\");\\n                vec[\\'z\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                vec[\\'r\\'-\\'a\\']--;\\n                vec[\\'o\\'-\\'a\\']--;\\n                size = size-4;\\n            }\\n            while(size && vec[\\'w\\'-\\'a\\'])\\n            {\\n                str.append(\"2\");\\n                vec[\\'t\\'-\\'a\\']--;\\n                vec[\\'w\\'-\\'a\\']--;\\n                vec[\\'o\\'-\\'a\\']--;\\n                size = size-3;\\n            }\\n            while(size && vec[\\'u\\'-\\'a\\'])\\n            {\\n                str.append(\"4\");\\n                vec[\\'f\\'-\\'a\\']--;\\n                vec[\\'o\\'-\\'a\\']--;\\n                vec[\\'u\\'-\\'a\\']--;\\n                vec[\\'r\\'-\\'a\\']--;\\n                size = size-4;\\n            }\\n             while(size && vec[\\'r\\'-\\'a\\'])\\n            {\\n                str.append(\"3\");\\n                 vec[\\'t\\'-\\'a\\']--;\\n                 vec[\\'h\\'-\\'a\\']--;\\n                 vec[\\'r\\'-\\'a\\']--;\\n                 vec[\\'e\\'-\\'a\\']--;\\n                 vec[\\'e\\'-\\'a\\']--;\\n                 size = size-5;\\n            }\\n            while(size && vec[\\'f\\'-\\'a\\'])\\n            {\\n                str.append(\"5\");\\n                vec[\\'f\\'-\\'a\\']--;\\n                vec[\\'i\\'-\\'a\\']--;\\n                vec[\\'v\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                size = size-4;\\n            }\\n            while(size && vec[\\'x\\'-\\'a\\'] )\\n            {\\n                str.append(\"6\");\\n                vec[\\'s\\'-\\'a\\']--;\\n                vec[\\'i\\'-\\'a\\']--;\\n                vec[\\'x\\'-\\'a\\']--;\\n                size= size-3;\\n            }\\n            while(size && vec[\\'v\\'-\\'a\\'])\\n            {\\n                str.append(\"7\");\\n                vec[\\'s\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                vec[\\'v\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                vec[\\'n\\'-\\'a\\']--;\\n                size = size-5;\\n            }\\n            while(size && vec[\\'g\\'-\\'a\\'])\\n            {\\n                str.append(\"8\");\\n                vec[\\'e\\'-\\'a\\']--;\\n                vec[\\'i\\'-\\'a\\']--;\\n                vec[\\'g\\'-\\'a\\']--;\\n                vec[\\'h\\'-\\'a\\']--;\\n                vec[\\'t\\'-\\'a\\']--;\\n                size = size-5;\\n            }\\n            while(size && vec[\\'o\\'-\\'a\\'])\\n            {\\n                str.append(\"1\");\\n                vec[\\'o\\'-\\'a\\']--;\\n                vec[\\'n\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                size = size-3;\\n            }\\n            while(size && vec[\\'n\\'-\\'a\\'])\\n            {\\n                str.append(\"9\");\\n                vec[\\'n\\'-\\'a\\']--;\\n                vec[\\'i\\'-\\'a\\']--;\\n                vec[\\'n\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                size = size-4;\\n            }\\n        }\\n        \\n        sort(str.begin(), str.end());\\n        return str;\\n    }\\n```\\n\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n string originalDigits(string s) {\\n        string main, str;\\n        vector<int> vec(26,0);\\n        int i,j, count, val, size;\\n        size = s.size();\\n        for(i=0; i<s.size(); i++)\\n            vec[s[i]-\\'a\\']++;\\n      \\n        while(size>0)\\n        {\\n            while(size && vec[\\'z\\'-\\'a\\'])\\n            {\\n                str.append(\"0\");\\n                vec[\\'z\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                vec[\\'r\\'-\\'a\\']--;\\n                vec[\\'o\\'-\\'a\\']--;\\n                size = size-4;\\n            }\\n            while(size && vec[\\'w\\'-\\'a\\'])\\n            {\\n                str.append(\"2\");\\n                vec[\\'t\\'-\\'a\\']--;\\n                vec[\\'w\\'-\\'a\\']--;\\n                vec[\\'o\\'-\\'a\\']--;\\n                size = size-3;\\n            }\\n            while(size && vec[\\'u\\'-\\'a\\'])\\n            {\\n                str.append(\"4\");\\n                vec[\\'f\\'-\\'a\\']--;\\n                vec[\\'o\\'-\\'a\\']--;\\n                vec[\\'u\\'-\\'a\\']--;\\n                vec[\\'r\\'-\\'a\\']--;\\n                size = size-4;\\n            }\\n             while(size && vec[\\'r\\'-\\'a\\'])\\n            {\\n                str.append(\"3\");\\n                 vec[\\'t\\'-\\'a\\']--;\\n                 vec[\\'h\\'-\\'a\\']--;\\n                 vec[\\'r\\'-\\'a\\']--;\\n                 vec[\\'e\\'-\\'a\\']--;\\n                 vec[\\'e\\'-\\'a\\']--;\\n                 size = size-5;\\n            }\\n            while(size && vec[\\'f\\'-\\'a\\'])\\n            {\\n                str.append(\"5\");\\n                vec[\\'f\\'-\\'a\\']--;\\n                vec[\\'i\\'-\\'a\\']--;\\n                vec[\\'v\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                size = size-4;\\n            }\\n            while(size && vec[\\'x\\'-\\'a\\'] )\\n            {\\n                str.append(\"6\");\\n                vec[\\'s\\'-\\'a\\']--;\\n                vec[\\'i\\'-\\'a\\']--;\\n                vec[\\'x\\'-\\'a\\']--;\\n                size= size-3;\\n            }\\n            while(size && vec[\\'v\\'-\\'a\\'])\\n            {\\n                str.append(\"7\");\\n                vec[\\'s\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                vec[\\'v\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                vec[\\'n\\'-\\'a\\']--;\\n                size = size-5;\\n            }\\n            while(size && vec[\\'g\\'-\\'a\\'])\\n            {\\n                str.append(\"8\");\\n                vec[\\'e\\'-\\'a\\']--;\\n                vec[\\'i\\'-\\'a\\']--;\\n                vec[\\'g\\'-\\'a\\']--;\\n                vec[\\'h\\'-\\'a\\']--;\\n                vec[\\'t\\'-\\'a\\']--;\\n                size = size-5;\\n            }\\n            while(size && vec[\\'o\\'-\\'a\\'])\\n            {\\n                str.append(\"1\");\\n                vec[\\'o\\'-\\'a\\']--;\\n                vec[\\'n\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                size = size-3;\\n            }\\n            while(size && vec[\\'n\\'-\\'a\\'])\\n            {\\n                str.append(\"9\");\\n                vec[\\'n\\'-\\'a\\']--;\\n                vec[\\'i\\'-\\'a\\']--;\\n                vec[\\'n\\'-\\'a\\']--;\\n                vec[\\'e\\'-\\'a\\']--;\\n                size = size-4;\\n            }\\n        }\\n        \\n        sort(str.begin(), str.end());\\n        return str;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132276,
                "title": "python-solution-beats-99-4-no-map-or-counter",
                "content": "We really only care about 10 letters, so Counter/mapping is a little excessive on both complexity and memory. \\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        A = [s.count(x) for x in(\\'zowtufxvgi\\')]\\n        A[1]-=(A[0]+A[4]+A[2])\\n        A[3]-=(A[2]+A[8])\\n        A[5]-=A[4]\\n        A[7]-=A[5]\\n        A[9]-=(A[8]+A[6]+A[5])\\n        return \"\".join([str(i)*A[i] for i in range(10)])     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        A = [s.count(x) for x in(\\'zowtufxvgi\\')]\\n        A[1]-=(A[0]+A[4]+A[2])\\n        A[3]-=(A[2]+A[8])\\n        A[5]-=A[4]\\n        A[7]-=A[5]\\n        A[9]-=(A[8]+A[6]+A[5])\\n        return \"\".join([str(i)*A[i] for i in range(10)])     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132154,
                "title": "reconstruct-original-digits-from-english-c-simple-unique-keys-solution",
                "content": "```\\npublic class Solution {\\n    public string OriginalDigits(string str) {\\n        var count = new int[26];\\n        var len = str.Length;\\n        \\n        for (int j = 0; j < len; j++)\\n            count[str[j]-\\'a\\']++;\\n        \\n        int z = \\'z\\'-\\'a\\';\\n        int e = \\'e\\'-\\'a\\';\\n        int r = \\'r\\'-\\'a\\';\\n        int o = \\'o\\'-\\'a\\';\\n        int n = \\'n\\'-\\'a\\';\\n        int t = \\'t\\'-\\'a\\';\\n        int w = \\'w\\'-\\'a\\';\\n        int h = \\'h\\'-\\'a\\';\\n        int f = \\'f\\'-\\'a\\';\\n        int u = \\'u\\'-\\'a\\';\\n        int i = \\'i\\'-\\'a\\';\\n        int v = \\'v\\'-\\'a\\';\\n        int s = \\'s\\'-\\'a\\';\\n        int x = \\'x\\'-\\'a\\';\\n        int g = \\'g\\'-\\'a\\';\\n        \\n        var digits = new int[10];        \\n        digits[0] = GetNumber(z, new [] { z,e,r,o });\\n        digits[2] = GetNumber(w, new [] { t,w,o });\\n        digits[4] = GetNumber(u, new [] { f,o,u,r });        \\n        digits[1] = GetNumber(o, new [] { o,n,e });        \\n        digits[3] = GetNumber(r, new [] { t,h,r,e,e });        \\n        digits[5] = GetNumber(f, new [] { f,i,v,e });\\n        digits[6] = GetNumber(x, new [] { s,i,x });\\n        digits[7] = GetNumber(v, new [] { s,e,v,e,n });\\n        digits[8] = GetNumber(g, new [] { e,i,g,h,t });\\n        digits[9] = GetNumber(i, new [] { n,i,n,e } );\\n        \\n        var sb = new StringBuilder();\\n        for (int j = 0; j < digits.Length; j++)            \\n            sb.Append(new string((char)(j+\\'0\\'), digits[j]));\\n        \\n        return sb.ToString();\\n        \\n        int GetNumber(int key, int[] chars)\\n        {\\n            var freq = count[key];\\n            \\n            foreach (var c in chars)\\n                count[c] -= freq;\\n            \\n            return freq;\\n        }       \\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public string OriginalDigits(string str) {\\n        var count = new int[26];\\n        var len = str.Length;\\n        \\n        for (int j = 0; j < len; j++)\\n            count[str[j]-\\'a\\']++;\\n        \\n        int z = \\'z\\'-\\'a\\';\\n        int e = \\'e\\'-\\'a\\';\\n        int r = \\'r\\'-\\'a\\';\\n        int o = \\'o\\'-\\'a\\';\\n        int n = \\'n\\'-\\'a\\';\\n        int t = \\'t\\'-\\'a\\';\\n        int w = \\'w\\'-\\'a\\';\\n        int h = \\'h\\'-\\'a\\';\\n        int f = \\'f\\'-\\'a\\';\\n        int u = \\'u\\'-\\'a\\';\\n        int i = \\'i\\'-\\'a\\';\\n        int v = \\'v\\'-\\'a\\';\\n        int s = \\'s\\'-\\'a\\';\\n        int x = \\'x\\'-\\'a\\';\\n        int g = \\'g\\'-\\'a\\';\\n        \\n        var digits = new int[10];        \\n        digits[0] = GetNumber(z, new [] { z,e,r,o });\\n        digits[2] = GetNumber(w, new [] { t,w,o });\\n        digits[4] = GetNumber(u, new [] { f,o,u,r });        \\n        digits[1] = GetNumber(o, new [] { o,n,e });        \\n        digits[3] = GetNumber(r, new [] { t,h,r,e,e });        \\n        digits[5] = GetNumber(f, new [] { f,i,v,e });\\n        digits[6] = GetNumber(x, new [] { s,i,x });\\n        digits[7] = GetNumber(v, new [] { s,e,v,e,n });\\n        digits[8] = GetNumber(g, new [] { e,i,g,h,t });\\n        digits[9] = GetNumber(i, new [] { n,i,n,e } );\\n        \\n        var sb = new StringBuilder();\\n        for (int j = 0; j < digits.Length; j++)            \\n            sb.Append(new string((char)(j+\\'0\\'), digits[j]));\\n        \\n        return sb.ToString();\\n        \\n        int GetNumber(int key, int[] chars)\\n        {\\n            var freq = count[key];\\n            \\n            foreach (var c in chars)\\n                count[c] -= freq;\\n            \\n            return freq;\\n        }       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131783,
                "title": "java-using-frequency-count-of-letters-and-explained",
                "content": "```\\nclass Solution {\\n    // take letters in this specific order because they have atleast one character unique than any number which has to come.\\n\\t//Example : zero have \\'z\\', two have \\'w\\', six have \\'x\\'...we can have seven after five as once \\'v\\' have already comes in the list it becomes unique. \\n    char[][] arr = new char[][]{{\\'z\\',\\'e\\',\\'r\\',\\'o\\'},\\n                               {\\'t\\',\\'w\\',\\'o\\'},\\n                               {\\'s\\',\\'i\\',\\'x\\'},\\n                               {\\'f\\',\\'o\\',\\'u\\',\\'r\\'},\\n                               {\\'e\\',\\'i\\',\\'g\\',\\'h\\',\\'t\\'},\\n                               {\\'t\\',\\'h\\',\\'r\\',\\'e\\',\\'e\\'},\\n                               {\\'f\\',\\'i\\',\\'v\\',\\'e\\'},\\n                               {\\'s\\',\\'e\\',\\'v\\',\\'e\\',\\'n\\'},\\n                                {\\'o\\',\\'n\\',\\'e\\'},\\n                               {\\'n\\',\\'i\\',\\'n\\',\\'e\\'}}; \\n    \\n    public String originalDigits(String s) {\\n        int n = s.length();\\n        int[] freq = new int[26];\\n        StringBuilder out = new StringBuilder();\\n        int i = 0;\\n        for(i=0;i<n;i++){\\n            char c = s.charAt(i);\\n            freq[c-\\'a\\']++;\\n        }\\n        int t = 0;\\n        int[] map = new int[]{0,2,6,4,8,3,5,7,1,9}; //mapping of index and number\\n        int[] outArr = new int[10];\\n        for(char[] c :  arr){\\n            int min = Integer.MAX_VALUE;\\n            for(char ch: c){\\n                min = Math.min(min, freq[ch-\\'a\\']);\\n            }\\n            if(min>0 && min!=Integer.MAX_VALUE){ \\n\\t\\t\\t// if we have all the characters present in the digit so we can append it same number of times it has the minimum count of each character.\\n\\t\\t\\t//example: 22 will have minimum 2 times \\'t\\', \\'w\\' and \\'o\\'\\n                for(char ch: c){\\n                    freq[ch-\\'a\\'] = freq[ch-\\'a\\'] - min;\\n                }\\n                outArr[map[t]]=min;\\n            }\\n            t++;\\n        }   \\n        \\n        for(i=0;i<10;i++){\\n            while(outArr[i]-->0){\\n                out.append(i);\\n            }\\n        }\\n        return out.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    // take letters in this specific order because they have atleast one character unique than any number which has to come.\\n\\t//Example : zero have \\'z\\', two have \\'w\\', six have \\'x\\'...we can have seven after five as once \\'v\\' have already comes in the list it becomes unique. \\n    char[][] arr = new char[][]{{\\'z\\',\\'e\\',\\'r\\',\\'o\\'},\\n                               {\\'t\\',\\'w\\',\\'o\\'},\\n                               {\\'s\\',\\'i\\',\\'x\\'},\\n                               {\\'f\\',\\'o\\',\\'u\\',\\'r\\'},\\n                               {\\'e\\',\\'i\\',\\'g\\',\\'h\\',\\'t\\'},\\n                               {\\'t\\',\\'h\\',\\'r\\',\\'e\\',\\'e\\'},\\n                               {\\'f\\',\\'i\\',\\'v\\',\\'e\\'},\\n                               {\\'s\\',\\'e\\',\\'v\\',\\'e\\',\\'n\\'},\\n                                {\\'o\\',\\'n\\',\\'e\\'},\\n                               {\\'n\\',\\'i\\',\\'n\\',\\'e\\'}}; \\n    \\n    public String originalDigits(String s) {\\n        int n = s.length();\\n        int[] freq = new int[26];\\n        StringBuilder out = new StringBuilder();\\n        int i = 0;\\n        for(i=0;i<n;i++){\\n            char c = s.charAt(i);\\n            freq[c-\\'a\\']++;\\n        }\\n        int t = 0;\\n        int[] map = new int[]{0,2,6,4,8,3,5,7,1,9}; //mapping of index and number\\n        int[] outArr = new int[10];\\n        for(char[] c :  arr){\\n            int min = Integer.MAX_VALUE;\\n            for(char ch: c){\\n                min = Math.min(min, freq[ch-\\'a\\']);\\n            }\\n            if(min>0 && min!=Integer.MAX_VALUE){ \\n\\t\\t\\t// if we have all the characters present in the digit so we can append it same number of times it has the minimum count of each character.\\n\\t\\t\\t//example: 22 will have minimum 2 times \\'t\\', \\'w\\' and \\'o\\'\\n                for(char ch: c){\\n                    freq[ch-\\'a\\'] = freq[ch-\\'a\\'] - min;\\n                }\\n                outArr[map[t]]=min;\\n            }\\n            t++;\\n        }   \\n        \\n        for(i=0;i<10;i++){\\n            while(outArr[i]-->0){\\n                out.append(i);\\n            }\\n        }\\n        return out.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131738,
                "title": "php-frequency-mapping-unique-letters",
                "content": "24 ms 16.1 MB\\n\\nCertain digits, like 2 have a name containing a letter appearing in no other digit name (t*w*o).  Other digits, like 3 (t*h*ree) have a letter which is unique after another digit (in this case: 8, eig*h*t) has been removed.  These unique letters I call *markers*.  The number of occurrences of each marker indicate the number of occurrences of it\\'s associated digit.\\n\\nBased on that:\\n- Generate a frequency map of the letters in `s`.\\n- Run through the markers in order.\\n\\t- If a marker characters occurs `n` times in the frequency map, record that # of occurrences for the corresponding digit, and remove `n` times the letters in the corresponding digit name.  For example, if (fter removing all the 8,s)  you find 4 *h*\\'s, record the presence of 4 *3*\\'s. and remove 4 *t*\\'s, 4 *h*\\'s, 4 *r*\\'s, and 8 *e*\\'s.\\n- Print out the found digits in the quantity observed, in order.\\n\\n```\\nclass Solution \\n{\\n        /* \"Marker\" letters which, if taken in order must indicate the presence of the # pointed to. */\\n        const MARKERS =\\n        [\\n                \\'z\\'=>0,\\'w\\'=>2,\\'x\\'=>6,\\'g\\'=>8,\\'u\\'=>4,\\n                \\'h\\'=>3,\\'o\\'=>1,\\'f\\'=>5,\\'v\\'=>7,\\'i\\'=>9\\n        ];\\n        const NUMBER_NAMES =\\n        [\\n                0 => [\\'z\\'=>1,\\'e\\'=>1,\\'r\\'=>1,\\'o\\'=>1],\\n                1 => [\\'o\\'=>1,\\'n\\'=>1,\\'e\\'=>1],\\n                2 => [\\'t\\'=>1,\\'w\\'=>1,\\'o\\'=>1],\\n                3 => [\\'t\\'=>1,\\'h\\'=>1,\\'r\\'=>1,\\'e\\'=>2],\\n                4 => [\\'f\\'=>1,\\'o\\'=>1,\\'u\\'=>1,\\'r\\'=>1],\\n                5 => [\\'f\\'=>1,\\'i\\'=>1,\\'v\\'=>1,\\'e\\'=>1],\\n                6 => [\\'s\\'=>1,\\'i\\'=>1,\\'x\\'=>1],\\n                7 => [\\'s\\'=>1,\\'e\\'=>2,\\'v\\'=>1,\\'n\\'=>1],\\n                8 => [\\'e\\'=>1,\\'i\\'=>1,\\'g\\'=>1,\\'h\\'=>1,\\'t\\'=>1],\\n                9 => [\\'n\\'=>2,\\'i\\'=>1,\\'e\\'=>1]\\n        ];\\n        \\n        /**\\n        * @param String $s\\n        * @return String\\n        */\\n        function originalDigits($s) \\n        {\\n                $len = strlen($s);\\n                \\n                /* Count the letters. */\\n                $letterCounts = [];\\n                for($i=0; $i<$len; $i++)\\n                {\\n                        if(!array_key_exists($s[$i], $letterCounts))\\n                                $letterCounts[$s[$i]] = 0;\\n                        $letterCounts[$s[$i]]++;\\n                }\\n    \\n                /* Extract the corresponding numbers by looking at the \"marker\" characters in order. */\\n                $numberCounts = [0,0,0,0,0,0,0,0,0,0];\\n                foreach(self::MARKERS as $k=>$digit)\\n                {\\n                        if(($occurrences = $letterCounts[$k]) == 0)\\n                                continue;\\n                        $numberCounts[$digit] = $occurrences;\\n                        foreach(self::NUMBER_NAMES[$digit] as $k2=>$v)\\n                                $letterCounts[$k2] -= $v * $occurrences;\\n                }\\n                \\n                /* Print out the numbers in order. */\\n                $result = \\'\\';\\n                foreach($numberCounts as $k=>$v)\\n                {\\n                        if($v > 0)\\n                                $result .= str_repeat($k,$v);\\n                }\\n\\n                return $result;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n        /* \"Marker\" letters which, if taken in order must indicate the presence of the # pointed to. */\\n        const MARKERS =\\n        [\\n                \\'z\\'=>0,\\'w\\'=>2,\\'x\\'=>6,\\'g\\'=>8,\\'u\\'=>4,\\n                \\'h\\'=>3,\\'o\\'=>1,\\'f\\'=>5,\\'v\\'=>7,\\'i\\'=>9\\n        ];\\n        const NUMBER_NAMES =\\n        [\\n                0 => [\\'z\\'=>1,\\'e\\'=>1,\\'r\\'=>1,\\'o\\'=>1],\\n                1 => [\\'o\\'=>1,\\'n\\'=>1,\\'e\\'=>1],\\n                2 => [\\'t\\'=>1,\\'w\\'=>1,\\'o\\'=>1],\\n                3 => [\\'t\\'=>1,\\'h\\'=>1,\\'r\\'=>1,\\'e\\'=>2],\\n                4 => [\\'f\\'=>1,\\'o\\'=>1,\\'u\\'=>1,\\'r\\'=>1],\\n                5 => [\\'f\\'=>1,\\'i\\'=>1,\\'v\\'=>1,\\'e\\'=>1],\\n                6 => [\\'s\\'=>1,\\'i\\'=>1,\\'x\\'=>1],\\n                7 => [\\'s\\'=>1,\\'e\\'=>2,\\'v\\'=>1,\\'n\\'=>1],\\n                8 => [\\'e\\'=>1,\\'i\\'=>1,\\'g\\'=>1,\\'h\\'=>1,\\'t\\'=>1],\\n                9 => [\\'n\\'=>2,\\'i\\'=>1,\\'e\\'=>1]\\n        ];\\n        \\n        /**\\n        * @param String $s\\n        * @return String\\n        */\\n        function originalDigits($s) \\n        {\\n                $len = strlen($s);\\n                \\n                /* Count the letters. */\\n                $letterCounts = [];\\n                for($i=0; $i<$len; $i++)\\n                {\\n                        if(!array_key_exists($s[$i], $letterCounts))\\n                                $letterCounts[$s[$i]] = 0;\\n                        $letterCounts[$s[$i]]++;\\n                }\\n    \\n                /* Extract the corresponding numbers by looking at the \"marker\" characters in order. */\\n                $numberCounts = [0,0,0,0,0,0,0,0,0,0];\\n                foreach(self::MARKERS as $k=>$digit)\\n                {\\n                        if(($occurrences = $letterCounts[$k]) == 0)\\n                                continue;\\n                        $numberCounts[$digit] = $occurrences;\\n                        foreach(self::NUMBER_NAMES[$digit] as $k2=>$v)\\n                                $letterCounts[$k2] -= $v * $occurrences;\\n                }\\n                \\n                /* Print out the numbers in order. */\\n                $result = \\'\\';\\n                foreach($numberCounts as $k=>$v)\\n                {\\n                        if($v > 0)\\n                                $result .= str_repeat($k,$v);\\n                }\\n\\n                return $result;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131719,
                "title": "java-solution-with-explanation-o-n",
                "content": "```\\nclass Solution {\\n    String[] digits = new String[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\n    public String originalDigits(String s) {\\n        int[] arr = new int[26];\\n        for (char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        int[] count = new int[10];\\n        count[0] = arr[\\'z\\' - \\'a\\'];\\n        count[2] = arr[\\'w\\' - \\'a\\'];\\n        count[4] = arr[\\'u\\' - \\'a\\'];\\n        count[6] = arr[\\'x\\' - \\'a\\'];\\n        count[8] = arr[\\'g\\' - \\'a\\'];\\n\\n        count[7] = arr[\\'s\\' - \\'a\\'] - count[6];\\n        count[5] = arr[\\'v\\' - \\'a\\'] - count[7];\\n        count[3] = arr[\\'h\\' - \\'a\\'] - count[8];\\n        count[1] = arr[\\'o\\' - \\'a\\'] - count[0] - count[2] - count[4];\\n        count[9] = arr[\\'i\\' - \\'a\\'] - count[5] - count[6] - count[8];\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            while (count[i] > 0) {\\n                sb.append(i);\\n                count[i]--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nAt first glance, we observe some characters appear in only some numbers (in String). Then we can write a simple Program to check that.\\n\\n```\\nclass Program {\\n    public static void main(String[] args) {\\n        String[] digits = new String[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            System.out.print(\"Char \" + c + \": \");\\n            for (String digit : digits) {\\n                if (digit.contains(c + \"\")) {\\n                    System.out.print(digit + \" \");\\n                }\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n```\\nAnd we got the output:\\n```\\nChar a: \\nChar b: \\nChar c: \\nChar d: \\nChar e: zero one three five seven eight nine \\nChar f: four five \\nChar g: eight \\nChar h: three eight \\nChar i: five six eight nine \\nChar j: \\nChar k: \\nChar l: \\nChar m: \\nChar n: one seven nine \\nChar o: zero one two four \\nChar p: \\nChar q: \\nChar r: zero three four \\nChar s: six seven \\nChar t: two three eight \\nChar u: four \\nChar v: five seven \\nChar w: two \\nChar x: six \\nChar y: \\nChar z: zero \\n\\nProcess finished with exit code 0\\n```\\nBased on the output, we can deduce the formular:\\n```\\ncount[0] = arr[\\'z\\' - \\'a\\'];\\ncount[2] = arr[\\'w\\' - \\'a\\'];\\ncount[4] = arr[\\'u\\' - \\'a\\'];\\ncount[6] = arr[\\'x\\' - \\'a\\'];\\ncount[8] = arr[\\'g\\' - \\'a\\'];\\n\\ncount[7] = arr[\\'s\\' - \\'a\\'] - count[6];\\ncount[5] = arr[\\'v\\' - \\'a\\'] - count[7];\\ncount[3] = arr[\\'h\\' - \\'a\\'] - count[8];\\ncount[1] = arr[\\'o\\' - \\'a\\'] - count[0] - count[2] - count[4];\\ncount[9] = arr[\\'i\\' - \\'a\\'] - count[5] - count[6] - count[8];\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String[] digits = new String[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\n    public String originalDigits(String s) {\\n        int[] arr = new int[26];\\n        for (char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        int[] count = new int[10];\\n        count[0] = arr[\\'z\\' - \\'a\\'];\\n        count[2] = arr[\\'w\\' - \\'a\\'];\\n        count[4] = arr[\\'u\\' - \\'a\\'];\\n        count[6] = arr[\\'x\\' - \\'a\\'];\\n        count[8] = arr[\\'g\\' - \\'a\\'];\\n\\n        count[7] = arr[\\'s\\' - \\'a\\'] - count[6];\\n        count[5] = arr[\\'v\\' - \\'a\\'] - count[7];\\n        count[3] = arr[\\'h\\' - \\'a\\'] - count[8];\\n        count[1] = arr[\\'o\\' - \\'a\\'] - count[0] - count[2] - count[4];\\n        count[9] = arr[\\'i\\' - \\'a\\'] - count[5] - count[6] - count[8];\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            while (count[i] > 0) {\\n                sb.append(i);\\n                count[i]--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Program {\\n    public static void main(String[] args) {\\n        String[] digits = new String[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            System.out.print(\"Char \" + c + \": \");\\n            for (String digit : digits) {\\n                if (digit.contains(c + \"\")) {\\n                    System.out.print(digit + \" \");\\n                }\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n```\n```\\nChar a: \\nChar b: \\nChar c: \\nChar d: \\nChar e: zero one three five seven eight nine \\nChar f: four five \\nChar g: eight \\nChar h: three eight \\nChar i: five six eight nine \\nChar j: \\nChar k: \\nChar l: \\nChar m: \\nChar n: one seven nine \\nChar o: zero one two four \\nChar p: \\nChar q: \\nChar r: zero three four \\nChar s: six seven \\nChar t: two three eight \\nChar u: four \\nChar v: five seven \\nChar w: two \\nChar x: six \\nChar y: \\nChar z: zero \\n\\nProcess finished with exit code 0\\n```\n```\\ncount[0] = arr[\\'z\\' - \\'a\\'];\\ncount[2] = arr[\\'w\\' - \\'a\\'];\\ncount[4] = arr[\\'u\\' - \\'a\\'];\\ncount[6] = arr[\\'x\\' - \\'a\\'];\\ncount[8] = arr[\\'g\\' - \\'a\\'];\\n\\ncount[7] = arr[\\'s\\' - \\'a\\'] - count[6];\\ncount[5] = arr[\\'v\\' - \\'a\\'] - count[7];\\ncount[3] = arr[\\'h\\' - \\'a\\'] - count[8];\\ncount[1] = arr[\\'o\\' - \\'a\\'] - count[0] - count[2] - count[4];\\ncount[9] = arr[\\'i\\' - \\'a\\'] - count[5] - count[6] - count[8];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131689,
                "title": "c-solution-with-comments-for-better-idea",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    // Time: O(len of string) and Space: O(1) \\n    string originalDigits(string s) {\\n        \\n//         For counting the letters in original string\\n        int count[26] = {0};\\n        \\n        for(char ch : s)\\n            count[ch - \\'a\\']++;\\n        \\n//         Digit count arr\\n        int digitCount[10] = {0};\\n        \\n//         Some special cases handling like 0,2,4,6,8\\n        digitCount[0] = count[\\'z\\' - \\'a\\']; // count of \\'z\\'\\n        digitCount[2] = count[\\'w\\' - \\'a\\']; // count of \\'w\\'\\n        digitCount[4] = count[\\'u\\' - \\'a\\']; // count of \\'u\\'\\n        digitCount[6] = count[\\'x\\' - \\'a\\']; // count of \\'x\\'\\n        digitCount[8] = count[\\'g\\' - \\'a\\']; // count of \\'g\\'\\n        \\n        // Rest can be counted as\\n        digitCount[1] = count[\\'o\\' - \\'a\\'] - digitCount[0] - digitCount[2] - digitCount[4]; // Why?-> beacuse \\'o\\' occurs in these numbers 0,2,4 therefore count of 1 will be count of \\'o\\' - (digitCount of 0,2,4);  \\n        // similarily for others\\n        digitCount[3] = count[\\'h\\' - \\'a\\'] - digitCount[8];\\n        digitCount[5] = count[\\'f\\' - \\'a\\'] - digitCount[4];\\n        digitCount[7] = count[\\'s\\' - \\'a\\'] - digitCount[6];\\n        digitCount[9] = count[\\'i\\' - \\'a\\'] - digitCount[5] - digitCount[6] - digitCount[8];\\n        \\n        \\n        // Now finally forming the number string using digitCount arr\\n        \\n        string ans = \"\";\\n        for(int i=0; i<10; i++){\\n            \\n            while(digitCount[i]--)\\n                ans += i + \\'0\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // Time: O(len of string) and Space: O(1) \\n    string originalDigits(string s) {\\n        \\n//         For counting the letters in original string\\n        int count[26] = {0};\\n        \\n        for(char ch : s)\\n            count[ch - \\'a\\']++;\\n        \\n//         Digit count arr\\n        int digitCount[10] = {0};\\n        \\n//         Some special cases handling like 0,2,4,6,8\\n        digitCount[0] = count[\\'z\\' - \\'a\\']; // count of \\'z\\'\\n        digitCount[2] = count[\\'w\\' - \\'a\\']; // count of \\'w\\'\\n        digitCount[4] = count[\\'u\\' - \\'a\\']; // count of \\'u\\'\\n        digitCount[6] = count[\\'x\\' - \\'a\\']; // count of \\'x\\'\\n        digitCount[8] = count[\\'g\\' - \\'a\\']; // count of \\'g\\'\\n        \\n        // Rest can be counted as\\n        digitCount[1] = count[\\'o\\' - \\'a\\'] - digitCount[0] - digitCount[2] - digitCount[4]; // Why?-> beacuse \\'o\\' occurs in these numbers 0,2,4 therefore count of 1 will be count of \\'o\\' - (digitCount of 0,2,4);  \\n        // similarily for others\\n        digitCount[3] = count[\\'h\\' - \\'a\\'] - digitCount[8];\\n        digitCount[5] = count[\\'f\\' - \\'a\\'] - digitCount[4];\\n        digitCount[7] = count[\\'s\\' - \\'a\\'] - digitCount[6];\\n        digitCount[9] = count[\\'i\\' - \\'a\\'] - digitCount[5] - digitCount[6] - digitCount[8];\\n        \\n        \\n        // Now finally forming the number string using digitCount arr\\n        \\n        string ans = \"\";\\n        for(int i=0; i<10; i++){\\n            \\n            while(digitCount[i]--)\\n                ans += i + \\'0\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131679,
                "title": "java-easiest-solution",
                "content": "```\\nclass Solution {\\n    StringBuilder sb = new StringBuilder();\\n    int[] letter = new int[26];\\n    int[] nums = new int[10];\\n    \\n    public String originalDigits(String s) {\\n        for(char c: s.toCharArray()){\\n            letter[c - \\'a\\']++;\\n        }\\n\\n        addAndRemove(2, \\'w\\', \"two\");\\n        addAndRemove(6, \\'x\\', \"six\");\\n        addAndRemove(7, \\'s\\', \"seven\");\\n        addAndRemove(5, \\'v\\', \"five\");\\n        addAndRemove(4, \\'f\\', \"four\");\\n        addAndRemove(0, \\'z\\', \"zero\");\\n        addAndRemove(3, \\'r\\', \"three\");\\n        addAndRemove(8, \\'t\\', \"eight\");\\n        addAndRemove(1, \\'o\\', \"one\");\\n        addAndRemove(9, \\'i\\', \"two\");\\n\\n        appendAll();\\n        return sb.toString();\\n    }\\n\\n    private void appendAll() {\\n        for (int i = 0; i < 10; i++) {\\n            sb.append(String.valueOf(i).repeat(nums[i]));\\n        }\\n    }\\n\\n    private void addAndRemove(int num, char unique, String str) {\\n        int repeatTimes = letter[unique - \\'a\\'];\\n        nums[num] = repeatTimes;\\n        for(char c: str.toCharArray()){\\n            letter[c - \\'a\\'] -= repeatTimes;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    StringBuilder sb = new StringBuilder();\\n    int[] letter = new int[26];\\n    int[] nums = new int[10];\\n    \\n    public String originalDigits(String s) {\\n        for(char c: s.toCharArray()){\\n            letter[c - \\'a\\']++;\\n        }\\n\\n        addAndRemove(2, \\'w\\', \"two\");\\n        addAndRemove(6, \\'x\\', \"six\");\\n        addAndRemove(7, \\'s\\', \"seven\");\\n        addAndRemove(5, \\'v\\', \"five\");\\n        addAndRemove(4, \\'f\\', \"four\");\\n        addAndRemove(0, \\'z\\', \"zero\");\\n        addAndRemove(3, \\'r\\', \"three\");\\n        addAndRemove(8, \\'t\\', \"eight\");\\n        addAndRemove(1, \\'o\\', \"one\");\\n        addAndRemove(9, \\'i\\', \"two\");\\n\\n        appendAll();\\n        return sb.toString();\\n    }\\n\\n    private void appendAll() {\\n        for (int i = 0; i < 10; i++) {\\n            sb.append(String.valueOf(i).repeat(nums[i]));\\n        }\\n    }\\n\\n    private void addAndRemove(int num, char unique, String str) {\\n        int repeatTimes = letter[unique - \\'a\\'];\\n        nums[num] = repeatTimes;\\n        for(char c: str.toCharArray()){\\n            letter[c - \\'a\\'] -= repeatTimes;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131578,
                "title": "python-intuitive-documented-solution-explained-why-problem-is-actually-good",
                "content": "The problem is actually very good, read to find out why!\\n\\nHere is the two real insights this problem requies. This is my train of thought:\\n(1) First think of backtracking, DP as you are brainstroming.\\n(2) Create a histogram, ie. count of occurrence of each character; do this for digits as well as the input string\\n(3) Realize that some digits has unique characters, so removing them upfront would simplify my Backtracking/DP approach.\\n(4) Then Realize that some shared characters, become unique after removing the first set of unique characters. (This is the key breakthough insight in this problem).\\n(5) Then realize that, more shared characters became unique after removing previously unique digits. This progressively continues for all the digits. In the end, no backtracking is actually required (Which is just us getting lucky)\\n\\nIn tiers of progressive uniqueness:\\n1 :  z , w , u, x, g\\n2:  r, s\\n3: v\\n4: o, i/e\\n\\nWhere: {\\'z\\': 0, \\'w\\':2, \\'u\\':4, \\'x\\': 6, \\'g\\':8, \\'r\\':3, \\'s\\':7, \\'v\\':5, \\'o\\': 1, \\'i\\': 9}\\nEach of these corresponds to a digit, so we progressively prune out digits:\\n\\n(6) Each unique character occurs once in the digits (we just makes code even simpler).\\n(7) Once we have removed letters for the 1st tier unique digits, the count of the 2nd tier unique characters will be exactly what we need. Great we can create a loop now!\\n\\n\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        # index of alphabet (0-25)\\n        def indexOf(c):\\n            return ord(c)-ord(\\'a\\')\\n        \\n        self.result = []\\n        # this is the first half of this problem: figuring out the sequence\\n        self.dc = {\\'z\\': 0, \\'w\\':2, \\'u\\':4, \\'x\\': 6, \\'g\\':8, \\'r\\':3, \\'s\\':7, \\'v\\':5, \\'o\\': 1, \\'i\\': 9}\\n        \\n        \"\"\"\\n        I am computing two occurrence dictionaries. One for the digits and the other for the input string.\\n        This tells me how many characters of a digit to remove from the string\\n        \"\"\"\\n        digits = [\\'zero\\', \\'one\\', \\'two\\', \\'three\\', \\'four\\', \\'five\\', \\'six\\', \\'seven\\', \\'eigth\\', \\'nine\\']\\n        ds = [0]*26\\n        for c in s: ds[indexOf(c)]+=1\\n        \\n        dd = [[0]*26 for _ in range(10)]\\n        for i, digit in enumerate(digits):\\n            for c in digit:\\n                dd[i][indexOf(c)]+=1\\n        \\n        \"\"\"\\n        I remove the unique occurrence letters; next the letters shared by two numbers \\n        (one of which was previously unique) now become unique. \\n        This is the other half of this problem: making letters progressively unique.        \\n        \"\"\"\\n        def removeLetter(letter):\\n            idx = indexOf(letter)\\n            count = ds[idx]\\n            if count > 0:\\n                self.result += [self.dc[letter]]*count      # record the digit being removed and its count\\n                d = dd[self.dc[letter]]\\n                for i in range(26):\\n                    ds[i] -= count*d[i]\\n        \\n        for k in self.dc:\\n            removeLetter(k)\\n        \\n        return \\'\\'.join([str(i) for i in sorted(self.result)])\\n```\\n\\nThis is actually a good question, but in a different spirit. It requires you to work through the problem and the key point is that the solution is \"Emergent\". You find your way as you go along. Most research and real-world problem solving requires a healthy dose of exploration: a combination of curiosity, logic and programming tools. You almost always have to break the problem into parts and try and simplify some parts before throwing a heavy-hitting algorithm at it. I felt this problem provided that very nice.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        # index of alphabet (0-25)\\n        def indexOf(c):\\n            return ord(c)-ord(\\'a\\')\\n        \\n        self.result = []\\n        # this is the first half of this problem: figuring out the sequence\\n        self.dc = {\\'z\\': 0, \\'w\\':2, \\'u\\':4, \\'x\\': 6, \\'g\\':8, \\'r\\':3, \\'s\\':7, \\'v\\':5, \\'o\\': 1, \\'i\\': 9}\\n        \\n        \"\"\"\\n        I am computing two occurrence dictionaries. One for the digits and the other for the input string.\\n        This tells me how many characters of a digit to remove from the string\\n        \"\"\"\\n        digits = [\\'zero\\', \\'one\\', \\'two\\', \\'three\\', \\'four\\', \\'five\\', \\'six\\', \\'seven\\', \\'eigth\\', \\'nine\\']\\n        ds = [0]*26\\n        for c in s: ds[indexOf(c)]+=1\\n        \\n        dd = [[0]*26 for _ in range(10)]\\n        for i, digit in enumerate(digits):\\n            for c in digit:\\n                dd[i][indexOf(c)]+=1\\n        \\n        \"\"\"\\n        I remove the unique occurrence letters; next the letters shared by two numbers \\n        (one of which was previously unique) now become unique. \\n        This is the other half of this problem: making letters progressively unique.        \\n        \"\"\"\\n        def removeLetter(letter):\\n            idx = indexOf(letter)\\n            count = ds[idx]\\n            if count > 0:\\n                self.result += [self.dc[letter]]*count      # record the digit being removed and its count\\n                d = dd[self.dc[letter]]\\n                for i in range(26):\\n                    ds[i] -= count*d[i]\\n        \\n        for k in self.dc:\\n            removeLetter(k)\\n        \\n        return \\'\\'.join([str(i) for i in sorted(self.result)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131419,
                "title": "c-simple-o-n-90-84ms",
                "content": "```\\npublic class Solution {\\n    public string OriginalDigits(string s) {\\n        int[] counts = new int[26 + \\'a\\'];\\n        for(int i =0; i< s.Length;i++)\\n            counts[s[i]]++;\\n        var ans = new StringBuilder();\\n        ans.Append(\\'0\\', counts[\\'z\\']);\\n        ans.Append(\\'1\\', counts[\\'o\\'] - counts[\\'z\\'] - counts[\\'u\\'] - counts[\\'w\\']);\\n        ans.Append(\\'2\\', counts[\\'w\\']);\\n        ans.Append(\\'3\\', counts[\\'h\\'] - counts[\\'g\\']);\\n        ans.Append(\\'4\\', counts[\\'u\\']);\\n        ans.Append(\\'5\\', counts[\\'f\\'] - counts[\\'u\\']);\\n        ans.Append(\\'6\\', counts[\\'x\\']);\\n        ans.Append(\\'7\\', counts[\\'v\\'] - (counts[\\'f\\'] - counts[\\'u\\']));\\n        ans.Append(\\'8\\', counts[\\'g\\']);\\n        ans.Append(\\'9\\', counts[\\'i\\'] - counts[\\'g\\'] - counts[\\'x\\'] - (counts[\\'f\\'] - counts[\\'u\\']));\\n        \\n        return ans.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string OriginalDigits(string s) {\\n        int[] counts = new int[26 + \\'a\\'];\\n        for(int i =0; i< s.Length;i++)\\n            counts[s[i]]++;\\n        var ans = new StringBuilder();\\n        ans.Append(\\'0\\', counts[\\'z\\']);\\n        ans.Append(\\'1\\', counts[\\'o\\'] - counts[\\'z\\'] - counts[\\'u\\'] - counts[\\'w\\']);\\n        ans.Append(\\'2\\', counts[\\'w\\']);\\n        ans.Append(\\'3\\', counts[\\'h\\'] - counts[\\'g\\']);\\n        ans.Append(\\'4\\', counts[\\'u\\']);\\n        ans.Append(\\'5\\', counts[\\'f\\'] - counts[\\'u\\']);\\n        ans.Append(\\'6\\', counts[\\'x\\']);\\n        ans.Append(\\'7\\', counts[\\'v\\'] - (counts[\\'f\\'] - counts[\\'u\\']));\\n        ans.Append(\\'8\\', counts[\\'g\\']);\\n        ans.Append(\\'9\\', counts[\\'i\\'] - counts[\\'g\\'] - counts[\\'x\\'] - (counts[\\'f\\'] - counts[\\'u\\']));\\n        \\n        return ans.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131269,
                "title": "rust-0ms-o-n",
                "content": "We can actually `collect()` this into the correct order without needing to store the output\\'s digit frequencies beforehand:\\n\\n```\\nuse std::iter::repeat;\\n\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let mut sc = [0; 26];\\n        s.chars().for_each(|c| sc[c as usize - \\'a\\' as usize] += 1);\\n        let sc = |c| sc[c as usize - \\'a\\' as usize];\\n\\n        (repeat(\\'0\\').take(sc(\\'z\\')))\\n            .chain(repeat(\\'1\\').take(sc(\\'o\\') - sc(\\'z\\') - sc(\\'w\\') - sc(\\'u\\')))\\n            .chain(repeat(\\'2\\').take(sc(\\'w\\')))\\n            .chain(repeat(\\'3\\').take(sc(\\'h\\') - sc(\\'g\\')))\\n            .chain(repeat(\\'4\\').take(sc(\\'u\\')))\\n            .chain(repeat(\\'5\\').take(sc(\\'f\\') - sc(\\'u\\')))\\n            .chain(repeat(\\'6\\').take(sc(\\'x\\')))\\n            .chain(repeat(\\'7\\').take(sc(\\'v\\') - sc(\\'f\\') + sc(\\'u\\')))\\n            .chain(repeat(\\'8\\').take(sc(\\'g\\')))\\n            .chain(repeat(\\'9\\').take(sc(\\'i\\') - sc(\\'x\\') - sc(\\'g\\') - sc(\\'f\\') + sc(\\'u\\')))\\n            .collect()\\n    }\\n}\\n```\\n\\n---\\n\\nThis was my original solution before I realized that simplification:\\n\\n```\\nstatic UNIQ_MAP: [(&str, usize); 10] = [\\n    (\"zero\", 0), (\"two\", 2), (\"four\", 4), (\"six\", 6), (\"eight\", 8), (\"one\", 1), (\"thre\", 3),\\n    (\"five\", 5), (\"sevn\", 7), (\"nie\", 9),\\n];\\n\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let (mut sc, ci) = ([0; 26], |c| c as usize - \\'a\\' as usize);\\n        s.chars().for_each(|c| sc[ci(c)] += 1);\\n\\n        let rc = UNIQ_MAP.iter().fold([0; 10], |mut a, &(w, i)| {\\n            let n = w.chars().map(|c| sc[ci(c)]).min().unwrap();\\n            w.chars().for_each(|c| sc[ci(c)] -= n);\\n            a[i] += n;\\n            a\\n        });\\n\\n        rc.iter()\\n            .enumerate()\\n            .flat_map(|(i, &n)| std::iter::repeat((b\\'0\\' + i as u8) as char).take(n))\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::iter::repeat;\\n\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let mut sc = [0; 26];\\n        s.chars().for_each(|c| sc[c as usize - \\'a\\' as usize] += 1);\\n        let sc = |c| sc[c as usize - \\'a\\' as usize];\\n\\n        (repeat(\\'0\\').take(sc(\\'z\\')))\\n            .chain(repeat(\\'1\\').take(sc(\\'o\\') - sc(\\'z\\') - sc(\\'w\\') - sc(\\'u\\')))\\n            .chain(repeat(\\'2\\').take(sc(\\'w\\')))\\n            .chain(repeat(\\'3\\').take(sc(\\'h\\') - sc(\\'g\\')))\\n            .chain(repeat(\\'4\\').take(sc(\\'u\\')))\\n            .chain(repeat(\\'5\\').take(sc(\\'f\\') - sc(\\'u\\')))\\n            .chain(repeat(\\'6\\').take(sc(\\'x\\')))\\n            .chain(repeat(\\'7\\').take(sc(\\'v\\') - sc(\\'f\\') + sc(\\'u\\')))\\n            .chain(repeat(\\'8\\').take(sc(\\'g\\')))\\n            .chain(repeat(\\'9\\').take(sc(\\'i\\') - sc(\\'x\\') - sc(\\'g\\') - sc(\\'f\\') + sc(\\'u\\')))\\n            .collect()\\n    }\\n}\\n```\n```\\nstatic UNIQ_MAP: [(&str, usize); 10] = [\\n    (\"zero\", 0), (\"two\", 2), (\"four\", 4), (\"six\", 6), (\"eight\", 8), (\"one\", 1), (\"thre\", 3),\\n    (\"five\", 5), (\"sevn\", 7), (\"nie\", 9),\\n];\\n\\nimpl Solution {\\n    pub fn original_digits(s: String) -> String {\\n        let (mut sc, ci) = ([0; 26], |c| c as usize - \\'a\\' as usize);\\n        s.chars().for_each(|c| sc[ci(c)] += 1);\\n\\n        let rc = UNIQ_MAP.iter().fold([0; 10], |mut a, &(w, i)| {\\n            let n = w.chars().map(|c| sc[ci(c)]).min().unwrap();\\n            w.chars().for_each(|c| sc[ci(c)] -= n);\\n            a[i] += n;\\n            a\\n        });\\n\\n        rc.iter()\\n            .enumerate()\\n            .flat_map(|(i, &n)| std::iter::repeat((b\\'0\\' + i as u8) as char).take(n))\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131175,
                "title": "faster-than-100-00-using-the-unique-chars",
                "content": "```\\npublic class Solution\\n{\\n    private List<(int digit, string word, char key)> digitDatas =\\n        new List<(int digit, string word, char key)>\\n        {\\n            (0, \"zero\", \\'z\\'),\\n            (2, \"two\", \\'w\\'),\\n            (4, \"four\", \\'u\\'),\\n            (6, \"six\", \\'x\\'),\\n            (7, \"seven\", \\'s\\'),\\n            (1, \"one\", \\'o\\'),\\n            (3, \"three\", \\'r\\'),\\n            (5, \"five\", \\'f\\'),\\n            (8, \"eight\", \\'h\\'),\\n            (9, \"nine\", \\'i\\')\\n        };\\n        \\n    public string OriginalDigits(string s)\\n    {\\n        int[] charCounter = new int[26];\\n        foreach(char c in s) charCounter[c-\\'a\\']++;\\n        \\n        int[] digitCounter = new int[10];\\n        foreach((int digit, string word, char key) data in digitDatas)\\n        {\\n            int count = charCounter[data.key-\\'a\\'];\\n            digitCounter[data.digit] = count;\\n            foreach(char c in data.word)\\n                charCounter[c-\\'a\\'] -= count;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < 10; i++)\\n        {\\n            int count = digitCounter[i];\\n            string c = i.ToString();\\n            for(int j = 0; j < count; j++)\\n                sb.Append(c);\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private List<(int digit, string word, char key)> digitDatas =\\n        new List<(int digit, string word, char key)>\\n        {\\n            (0, \"zero\", \\'z\\'),\\n            (2, \"two\", \\'w\\'),\\n            (4, \"four\", \\'u\\'),\\n            (6, \"six\", \\'x\\'),\\n            (7, \"seven\", \\'s\\'),\\n            (1, \"one\", \\'o\\'),\\n            (3, \"three\", \\'r\\'),\\n            (5, \"five\", \\'f\\'),\\n            (8, \"eight\", \\'h\\'),\\n            (9, \"nine\", \\'i\\')\\n        };\\n        \\n    public string OriginalDigits(string s)\\n    {\\n        int[] charCounter = new int[26];\\n        foreach(char c in s) charCounter[c-\\'a\\']++;\\n        \\n        int[] digitCounter = new int[10];\\n        foreach((int digit, string word, char key) data in digitDatas)\\n        {\\n            int count = charCounter[data.key-\\'a\\'];\\n            digitCounter[data.digit] = count;\\n            foreach(char c in data.word)\\n                charCounter[c-\\'a\\'] -= count;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < 10; i++)\\n        {\\n            int count = digitCounter[i];\\n            string c = i.ToString();\\n            for(int j = 0; j < count; j++)\\n                sb.Append(c);\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131124,
                "title": "one-pass-o-n-simple-typescript-solution",
                "content": "https://leetcode.com/problems/reconstruct-original-digits-from-english/discuss/91207/one-pass-O(n)-JAVA-Solution-Simple-and-Clear\\nThe idea is:\\n\\nfor zero, it\\'s the only word has letter \\'z\\',\\nfor two, it\\'s the only word has letter \\'w\\',\\n......\\nso we only need to count the unique letter of each word, Coz the input is always valid.\\n```\\nconst originalDigits = (s: string): string => {\\n  const counter = new Array<number>(10).fill(0);\\n  for (const c of s) {\\n    if (c === \\'z\\') counter[0]++;\\n    if (c === \\'w\\') counter[2]++;\\n    if (c === \\'x\\') counter[6]++;\\n    if (c === \\'s\\') counter[7]++; //7-6\\n    if (c === \\'g\\') counter[8]++;\\n    if (c === \\'u\\') counter[4]++;\\n    if (c === \\'f\\') counter[5]++; //5-4\\n    if (c === \\'h\\') counter[3]++; //3-8\\n    if (c === \\'i\\') counter[9]++; //9-8-5-6\\n    if (c === \\'o\\') counter[1]++; //1-0-2-4\\n  }\\n  counter[7] -= counter[6];\\n  counter[5] -= counter[4];\\n  counter[3] -= counter[8];\\n  counter[9] = counter[9] - counter[8] - counter[5] - counter[6];\\n  counter[1] = counter[1] - counter[0] - counter[2] - counter[4];\\n  const res = [] as string[];\\n  for (let i = 0; i <= 9; i++) {\\n    for (let j = 0; j < counter[i]; j++) {\\n      res.push(i.toString());\\n    }\\n  }\\n  return res.join(\\'\\');\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst originalDigits = (s: string): string => {\\n  const counter = new Array<number>(10).fill(0);\\n  for (const c of s) {\\n    if (c === \\'z\\') counter[0]++;\\n    if (c === \\'w\\') counter[2]++;\\n    if (c === \\'x\\') counter[6]++;\\n    if (c === \\'s\\') counter[7]++; //7-6\\n    if (c === \\'g\\') counter[8]++;\\n    if (c === \\'u\\') counter[4]++;\\n    if (c === \\'f\\') counter[5]++; //5-4\\n    if (c === \\'h\\') counter[3]++; //3-8\\n    if (c === \\'i\\') counter[9]++; //9-8-5-6\\n    if (c === \\'o\\') counter[1]++; //1-0-2-4\\n  }\\n  counter[7] -= counter[6];\\n  counter[5] -= counter[4];\\n  counter[3] -= counter[8];\\n  counter[9] = counter[9] - counter[8] - counter[5] - counter[6];\\n  counter[1] = counter[1] - counter[0] - counter[2] - counter[4];\\n  const res = [] as string[];\\n  for (let i = 0; i <= 9; i++) {\\n    for (let j = 0; j < counter[i]; j++) {\\n      res.push(i.toString());\\n    }\\n  }\\n  return res.join(\\'\\');\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131110,
                "title": "simple-js-solution-unique-letters-faster-than-100-smaller-than-75",
                "content": "After my first recursive attempt failed with very large strings ~50,000 characters, I decided to put on the thinking cap for a minute, and came to realize that not only is there the (somewhat) obvious list of numbers that have unique characters (**z**ero, t**w**o, si**x**, ei**g**ht, fo**u**r), but, that the remaining numbers have only to be unique among the other remainders. \\nFor example, after removing the 5 digits above, one is the only digit with an **o**, three with a **t** or **h** or **r**, for that matter. So, armed with this knowledge, we can complete everything in a single pass per digit if we are removing the counts of the previous letters, but I am getting ahead of myself.\\n\\nFirst we begin with creating an array of every possible letter (26 length) and keep a count of every appearance of each letter.\\n```\\nvar originalDigits = function(s) {\\n    const letters = new Array(26).fill(0);\\n    for(let i = 0; i < s.length; i++){\\n        letters[s.charCodeAt(i)-97]++;\\n    }\\n}\\n```\\nNow we have a count of the frequency of each letter, and we know that we have unique letters to each digit, so we create a list of all those, with the unique charcter first (to make look-up faster, later):\\n```\\n    const optumNumStr = [\\'zero\\',\\'wto\\',\\'xsi\\',\\'geiht\\',\\'ufor\\',\\'one\\',\\'three\\',\\'five\\',\\'seven\\',\\'enin\\'];\\n```\\nNote that I placed the e first in \\'nine\\' even though all the letters are unique... if you leave the 9 first, there are 2 for every occurance of the word.\\n\\nNow this list is good to find the frequency of each number, like so:\\n```\\nvar originalDigits = function(s) {\\n    const letters = new Array(26).fill(0);\\n    const optumNumStr = [\\'zero\\',\\'wto\\',\\'xsi\\',\\'geiht\\',\\'ufor\\',\\'one\\',\\'three\\',\\'five\\',\\'seven\\',\\'enin\\'];\\n    let output = \\'\\'; // initializing the output string\\n    for(let i = 0; i < s.length; i++){\\n        letters[s.charCodeAt(i)-97]++;\\n    }\\n    checker(0);\\n    return output;\\n    function checker(pos){ \\n        if(pos === 10){return}\\n        let count = letters[optumNumStr[pos].charCodeAt(0)-97];\\n        if(count > 0){\\n            for(let i = 0 ; i < optumNumStr[pos].length; i++){\\n                letters[optumNumStr[pos].charCodeAt(i)-97] -= count;\\n            }\\n        }\\n\\t\\twhile(count > 0){\\n\\t\\t\\toutput += pos;\\n\\t\\t}\\n        checker(pos+1);\\n    }\\n};\\n```\\nNow we\\'re counting up from the string, counting down as we pull out digits, and outputing! Excellent!\\nOnly problem is, we\\'re looking at the digits by their uniqueness, not their position on a number line...\\neg: *zeroonetwo => 021*\\n\\nThis won\\'t do, but it does get us most of the way there. Let\\'s set up a map(numMap) to point our **pos** argument to the correct value, then keep track of that value(numCount), as we\\'re looking at the digits all out of order:\\n```\\nvar originalDigits = function(s) {\\n    const letters = new Array(26).fill(0);\\n    const optumNumStr = [\\'zero\\',\\'wto\\',\\'xsi\\',\\'geiht\\',\\'ufor\\',\\'one\\',\\'three\\',\\'five\\',\\'seven\\',\\'enin\\'];\\n    const numMap = {0:0,1:2,2:6,3:8,4:4,5:1,6:3,7:5,8:7,9:9};\\n    const numCount = new Array(9).fill(0);\\n    let output = \\'\\';\\n    for(let i = 0; i < s.length; i++){\\n        letters[s.charCodeAt(i)-97]++;\\n    }\\n    checker(0);\\n    return output;\\n    function checker(pos){\\n        if(pos === 10){return}\\n        let count = letters[optumNumStr[pos].charCodeAt(0)-97];\\n        numCount[numMap[pos]] = count;\\n        if(count > 0){\\n            for(let i = 0 ; i < optumNumStr[pos].length; i++){\\n                letters[optumNumStr[pos].charCodeAt(i)-97] -= count;\\n            }\\n        }\\n        checker(pos+1);\\n    }\\n};\\n```\\nLooks good! Now we just need to iterate over our numCount array, and we\\'re set!\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar originalDigits = function(s) {\\n    const letters = new Array(26).fill(0);\\n    const optumNumStr = [\\'zero\\',\\'wto\\',\\'xsi\\',\\'geiht\\',\\'ufor\\',\\'one\\',\\'three\\',\\'five\\',\\'seven\\',\\'enin\\'];\\n    const numMap = {0:0,1:2,2:6,3:8,4:4,5:1,6:3,7:5,8:7,9:9};\\n    const numCount = new Array(9).fill(0);\\n    let output = \\'\\';\\n    for(let i = 0; i < s.length; i++){\\n        letters[s.charCodeAt(i)-97]++;\\n    }\\n    checker(0);\\n    for(let i = 0; i < 10; i++){\\n        for(let j = numCount[i]; j > 0; j--){\\n            output += i;\\n        }\\n    }\\n    return output;\\n    function checker(pos){\\n        if(pos === 10){return}\\n        let count = letters[optumNumStr[pos].charCodeAt(0)-97];\\n        numCount[numMap[pos]] = count;\\n        if(count > 0){\\n            for(let i = 0 ; i < optumNumStr[pos].length; i++){\\n                letters[optumNumStr[pos].charCodeAt(i)-97] -= count;\\n            }\\n        }\\n        checker(pos+1);\\n    }\\n};\\n```\\n\\nCouple thoughts that might make this a *bit* faster, sexier, etc... keep track of only the values we are using as unique keys (z,w,x,g,u,o,t,f,s,e) and maybe find better keys; maybe even:\\n```\\n    for(let i = 0; i < 10; i++){\\n        output += Array(numCount[i]).fill((i).toString()).join(\\'\\')\\n    }\\n```\\nOr some other clever idea floating out there...\\n\\nPlease let me know if this has been helpful, you have any questions, or you see a better way to do something here! Trying to get better about uploading my solutions and would love any feedback!\\n\\nCheers.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar originalDigits = function(s) {\\n    const letters = new Array(26).fill(0);\\n    for(let i = 0; i < s.length; i++){\\n        letters[s.charCodeAt(i)-97]++;\\n    }\\n}\\n```\n```\\n    const optumNumStr = [\\'zero\\',\\'wto\\',\\'xsi\\',\\'geiht\\',\\'ufor\\',\\'one\\',\\'three\\',\\'five\\',\\'seven\\',\\'enin\\'];\\n```\n```\\nvar originalDigits = function(s) {\\n    const letters = new Array(26).fill(0);\\n    const optumNumStr = [\\'zero\\',\\'wto\\',\\'xsi\\',\\'geiht\\',\\'ufor\\',\\'one\\',\\'three\\',\\'five\\',\\'seven\\',\\'enin\\'];\\n    let output = \\'\\'; // initializing the output string\\n    for(let i = 0; i < s.length; i++){\\n        letters[s.charCodeAt(i)-97]++;\\n    }\\n    checker(0);\\n    return output;\\n    function checker(pos){ \\n        if(pos === 10){return}\\n        let count = letters[optumNumStr[pos].charCodeAt(0)-97];\\n        if(count > 0){\\n            for(let i = 0 ; i < optumNumStr[pos].length; i++){\\n                letters[optumNumStr[pos].charCodeAt(i)-97] -= count;\\n            }\\n        }\\n\\t\\twhile(count > 0){\\n\\t\\t\\toutput += pos;\\n\\t\\t}\\n        checker(pos+1);\\n    }\\n};\\n```\n```\\nvar originalDigits = function(s) {\\n    const letters = new Array(26).fill(0);\\n    const optumNumStr = [\\'zero\\',\\'wto\\',\\'xsi\\',\\'geiht\\',\\'ufor\\',\\'one\\',\\'three\\',\\'five\\',\\'seven\\',\\'enin\\'];\\n    const numMap = {0:0,1:2,2:6,3:8,4:4,5:1,6:3,7:5,8:7,9:9};\\n    const numCount = new Array(9).fill(0);\\n    let output = \\'\\';\\n    for(let i = 0; i < s.length; i++){\\n        letters[s.charCodeAt(i)-97]++;\\n    }\\n    checker(0);\\n    return output;\\n    function checker(pos){\\n        if(pos === 10){return}\\n        let count = letters[optumNumStr[pos].charCodeAt(0)-97];\\n        numCount[numMap[pos]] = count;\\n        if(count > 0){\\n            for(let i = 0 ; i < optumNumStr[pos].length; i++){\\n                letters[optumNumStr[pos].charCodeAt(i)-97] -= count;\\n            }\\n        }\\n        checker(pos+1);\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar originalDigits = function(s) {\\n    const letters = new Array(26).fill(0);\\n    const optumNumStr = [\\'zero\\',\\'wto\\',\\'xsi\\',\\'geiht\\',\\'ufor\\',\\'one\\',\\'three\\',\\'five\\',\\'seven\\',\\'enin\\'];\\n    const numMap = {0:0,1:2,2:6,3:8,4:4,5:1,6:3,7:5,8:7,9:9};\\n    const numCount = new Array(9).fill(0);\\n    let output = \\'\\';\\n    for(let i = 0; i < s.length; i++){\\n        letters[s.charCodeAt(i)-97]++;\\n    }\\n    checker(0);\\n    for(let i = 0; i < 10; i++){\\n        for(let j = numCount[i]; j > 0; j--){\\n            output += i;\\n        }\\n    }\\n    return output;\\n    function checker(pos){\\n        if(pos === 10){return}\\n        let count = letters[optumNumStr[pos].charCodeAt(0)-97];\\n        numCount[numMap[pos]] = count;\\n        if(count > 0){\\n            for(let i = 0 ; i < optumNumStr[pos].length; i++){\\n                letters[optumNumStr[pos].charCodeAt(i)-97] -= count;\\n            }\\n        }\\n        checker(pos+1);\\n    }\\n};\\n```\n```\\n    for(let i = 0; i < 10; i++){\\n        output += Array(numCount[i]).fill((i).toString()).join(\\'\\')\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131055,
                "title": "java-easy-to-understand-use-unique-letter-z-w-u-x-g-etc",
                "content": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] f = new int[26];\\n        for(char c : s.toCharArray())\\n            f[c - \\'a\\']++;\\n        \\n        String[] digits = new String[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n        char[] ids = new char[]{\\'z\\', \\'o\\', \\'w\\', \\'h\\', \\'u\\', \\'f\\', \\'x\\', \\'s\\', \\'g\\', \\'i\\'};\\n        int[] order = new int[]{0, 2, 4, 6, 8, 1, 3, 5, 7, 9};\\n        \\n        int[] digitCount = new int[10];\\n        for(int i : order) {\\n            int count = f[ids[i] - \\'a\\'];\\n            for(char d : digits[i].toCharArray()) \\n                f[d - \\'a\\'] -= count;\\n            digitCount[i] = count;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < 10; i++)\\n            for(int j = 0; j < digitCount[i]; j++)\\n                sb.append(i);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] f = new int[26];\\n        for(char c : s.toCharArray())\\n            f[c - \\'a\\']++;\\n        \\n        String[] digits = new String[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n        char[] ids = new char[]{\\'z\\', \\'o\\', \\'w\\', \\'h\\', \\'u\\', \\'f\\', \\'x\\', \\'s\\', \\'g\\', \\'i\\'};\\n        int[] order = new int[]{0, 2, 4, 6, 8, 1, 3, 5, 7, 9};\\n        \\n        int[] digitCount = new int[10];\\n        for(int i : order) {\\n            int count = f[ids[i] - \\'a\\'];\\n            for(char d : digits[i].toCharArray()) \\n                f[d - \\'a\\'] -= count;\\n            digitCount[i] = count;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < 10; i++)\\n            for(int j = 0; j < digitCount[i]; j++)\\n                sb.append(i);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131036,
                "title": "simple-solution-in-python3-by-taking-the-count-of-the-unique-characters",
                "content": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        c = dict()\\n        \\n        c[0] = s.count(\"z\")\\n        c[2] = s.count(\"w\")\\n        c[4] = s.count(\"u\")\\n        c[6] = s.count(\"x\")\\n        c[8] = s.count(\"g\")\\n        \\n        c[3] = s.count(\"h\") - c[8]\\n        c[5] = s.count(\"f\") - c[4]\\n        c[7] = s.count(\"s\") - c[6]\\n        \\n        c[9] = s.count(\"i\") - (c[8] + c[5] + c[6])\\n        c[1] = s.count(\"o\") - (c[0] + c[2] + c[4])\\n        \\n        c = sorted(c.items(), key = lambda x: x[0])\\n        ans = \"\"\\n        for k, v in c:\\n            ans += (str(k) * v)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        c = dict()\\n        \\n        c[0] = s.count(\"z\")\\n        c[2] = s.count(\"w\")\\n        c[4] = s.count(\"u\")\\n        c[6] = s.count(\"x\")\\n        c[8] = s.count(\"g\")\\n        \\n        c[3] = s.count(\"h\") - c[8]\\n        c[5] = s.count(\"f\") - c[4]\\n        c[7] = s.count(\"s\") - c[6]\\n        \\n        c[9] = s.count(\"i\") - (c[8] + c[5] + c[6])\\n        c[1] = s.count(\"o\") - (c[0] + c[2] + c[4])\\n        \\n        c = sorted(c.items(), key = lambda x: x[0])\\n        ans = \"\"\\n        for k, v in c:\\n            ans += (str(k) * v)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130984,
                "title": "java-straightforward-identify-unique-character-of-each-digit-with-comments",
                "content": "```\\n\\tpublic String originalDigits(String s) {\\n\\t\\t/* 1. Determine count of each letter in s */\\n        int[] charCount = new int[26];\\n        for(int i = 0; i < s.length(); i++){\\n            charCount[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int[] digitCount = new int[10];\\n\\t\\t/* 2. Identify the unique character in the English\\n\\t\\t   representation of each digit step by step */\\n        digitCount[0] = process(charCount, \"zero\", \\'z\\');\\n        digitCount[2] = process(charCount, \"two\", \\'w\\');\\n        digitCount[6] = process(charCount, \"six\", \\'x\\');\\n        digitCount[8] = process(charCount, \"eight\", \\'g\\');\\n        digitCount[7] = process(charCount, \"seven\", \\'s\\');\\n        digitCount[5] = process(charCount, \"five\", \\'v\\');\\n        digitCount[4] = process(charCount, \"four\", \\'f\\');\\n        digitCount[1] = process(charCount, \"one\", \\'o\\');\\n        digitCount[3] = process(charCount, \"three\", \\'t\\');\\n        digitCount[9] = process(charCount, \"nine\", \\'i\\');\\n        \\n\\t\\t/* 3. Build the result string from the frequency of the digits */\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < 10; i++){\\n            for(int j = 0; j < digitCount[i]; j++) sb.append(i);\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n\\t/* Helper function to unambigously determine the frequency of\\n\\t   a digit from its unique character */\\n    private int process(int[] charCount, String digit, char unique){\\n        int result = charCount[unique - \\'a\\'];\\n\\t\\t/* Subtract the frequency of the unique character from\\n\\t\\t   that of each of the characters of the digit. */\\n        if(charCount[unique - \\'a\\'] > 0){\\n            for(int i = 0; i < digit.length(); i++){\\n                charCount[digit.charAt(i) - \\'a\\'] -= result;\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic String originalDigits(String s) {\\n\\t\\t/* 1. Determine count of each letter in s */\\n        int[] charCount = new int[26];\\n        for(int i = 0; i < s.length(); i++){\\n            charCount[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int[] digitCount = new int[10];\\n\\t\\t/* 2. Identify the unique character in the English\\n\\t\\t   representation of each digit step by step */\\n        digitCount[0] = process(charCount, \"zero\", \\'z\\');\\n        digitCount[2] = process(charCount, \"two\", \\'w\\');\\n        digitCount[6] = process(charCount, \"six\", \\'x\\');\\n        digitCount[8] = process(charCount, \"eight\", \\'g\\');\\n        digitCount[7] = process(charCount, \"seven\", \\'s\\');\\n        digitCount[5] = process(charCount, \"five\", \\'v\\');\\n        digitCount[4] = process(charCount, \"four\", \\'f\\');\\n        digitCount[1] = process(charCount, \"one\", \\'o\\');\\n        digitCount[3] = process(charCount, \"three\", \\'t\\');\\n        digitCount[9] = process(charCount, \"nine\", \\'i\\');\\n        \\n\\t\\t/* 3. Build the result string from the frequency of the digits */\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < 10; i++){\\n            for(int j = 0; j < digitCount[i]; j++) sb.append(i);\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n\\t/* Helper function to unambigously determine the frequency of\\n\\t   a digit from its unique character */\\n    private int process(int[] charCount, String digit, char unique){\\n        int result = charCount[unique - \\'a\\'];\\n\\t\\t/* Subtract the frequency of the unique character from\\n\\t\\t   that of each of the characters of the digit. */\\n        if(charCount[unique - \\'a\\'] > 0){\\n            for(int i = 0; i < digit.length(); i++){\\n                charCount[digit.charAt(i) - \\'a\\'] -= result;\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 958752,
                "title": "java-simulation-with-explaination",
                "content": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n//         one two three four five six seven eight nine zero\\n//             z only for zero\\n//             x only for six\\n//             u only for four\\n//             w only for two\\n//             g only eight\\n//             five f - four\\n//             one o - two - four - zero\\n//             three t - eight - two\\n//             seven s -six\\n//             nine i - five - six - eight\\n        int[] chars = new int[26];\\n        for(char c: s.toCharArray()){\\n            chars[c - \\'a\\']++;\\n        }\\n        int[] digits = new int[10];\\n        digits[0] = chars[\\'z\\' - \\'a\\'];\\n        digits[6] = chars[\\'x\\' - \\'a\\'];\\n        digits[4] = chars[\\'u\\' - \\'a\\'];\\n        digits[2] = chars[\\'w\\' - \\'a\\'];\\n        digits[8] = chars[\\'g\\' - \\'a\\'];\\n        digits[5] = chars[\\'f\\' - \\'a\\'] - digits[4];\\n        digits[1] = chars[\\'o\\' - \\'a\\'] - digits[2] - digits[4] - digits[0];;\\n        digits[3] = chars[\\'t\\' - \\'a\\'] - digits[2] - digits[8];\\n        digits[7] = chars[\\'s\\' - \\'a\\'] - digits[6];\\n        digits[9] = chars[\\'i\\' - \\'a\\'] - digits[5] - digits[6] - digits[8];\\n        StringBuilder res = new StringBuilder();\\n        for(int i = 0; i < 10; i++){\\n            for(int j = 0; j < digits[i]; j++){\\n                res.append(i);\\n            }\\n        }\\n        return res.toString();\\n                \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n//         one two three four five six seven eight nine zero\\n//             z only for zero\\n//             x only for six\\n//             u only for four\\n//             w only for two\\n//             g only eight\\n//             five f - four\\n//             one o - two - four - zero\\n//             three t - eight - two\\n//             seven s -six\\n//             nine i - five - six - eight\\n        int[] chars = new int[26];\\n        for(char c: s.toCharArray()){\\n            chars[c - \\'a\\']++;\\n        }\\n        int[] digits = new int[10];\\n        digits[0] = chars[\\'z\\' - \\'a\\'];\\n        digits[6] = chars[\\'x\\' - \\'a\\'];\\n        digits[4] = chars[\\'u\\' - \\'a\\'];\\n        digits[2] = chars[\\'w\\' - \\'a\\'];\\n        digits[8] = chars[\\'g\\' - \\'a\\'];\\n        digits[5] = chars[\\'f\\' - \\'a\\'] - digits[4];\\n        digits[1] = chars[\\'o\\' - \\'a\\'] - digits[2] - digits[4] - digits[0];;\\n        digits[3] = chars[\\'t\\' - \\'a\\'] - digits[2] - digits[8];\\n        digits[7] = chars[\\'s\\' - \\'a\\'] - digits[6];\\n        digits[9] = chars[\\'i\\' - \\'a\\'] - digits[5] - digits[6] - digits[8];\\n        StringBuilder res = new StringBuilder();\\n        for(int i = 0; i < 10; i++){\\n            for(int j = 0; j < digits[i]; j++){\\n                res.append(i);\\n            }\\n        }\\n        return res.toString();\\n                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956471,
                "title": "python-numpy-solving-ax-b",
                "content": "```\\nimport numpy as np\\n\\n# Solving X for AX=B\\ndef originalDigits(self, s: str) -> str:\\n\\tnum_list = [\\'zero\\', \\'one\\', \\'two\\', \\'three\\', \\'four\\', \\'five\\', \\'six\\', \\'seven\\', \\'eight\\', \\'nine\\']\\n\\tA = np.zeros((26, 10), dtype = np.int)\\n\\t# X = np.zeros(10)\\n\\tB = np.zeros(26, dtype=np.int)\\n\\n\\tfor c in s:\\n\\t\\tB[ord(c) - ord(\\'a\\')] += 1\\n\\n\\tfor i, num in enumerate(num_list):\\n\\t\\tfor c in num:\\n\\t\\t\\tA[ord(c) - ord(\\'a\\')][i] += 1;\\n\\n\\t# X = np.linalg.solve(A, B)\\n\\tX,_,_,_ = np.linalg.lstsq(A, B);\\n\\tX = np.array(X)\\n\\tX = np.rint(X)\\n\\tX = X.astype(np.int)\\n\\n\\tres = \"\"\\n\\tfor i, cnt in enumerate(X):\\n\\t\\tres += chr(ord(\\'0\\') + i) * cnt\\n\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\n\\n# Solving X for AX=B\\ndef originalDigits(self, s: str) -> str:\\n\\tnum_list = [\\'zero\\', \\'one\\', \\'two\\', \\'three\\', \\'four\\', \\'five\\', \\'six\\', \\'seven\\', \\'eight\\', \\'nine\\']\\n\\tA = np.zeros((26, 10), dtype = np.int)\\n\\t# X = np.zeros(10)\\n\\tB = np.zeros(26, dtype=np.int)\\n\\n\\tfor c in s:\\n\\t\\tB[ord(c) - ord(\\'a\\')] += 1\\n\\n\\tfor i, num in enumerate(num_list):\\n\\t\\tfor c in num:\\n\\t\\t\\tA[ord(c) - ord(\\'a\\')][i] += 1;\\n\\n\\t# X = np.linalg.solve(A, B)\\n\\tX,_,_,_ = np.linalg.lstsq(A, B);\\n\\tX = np.array(X)\\n\\tX = np.rint(X)\\n\\tX = X.astype(np.int)\\n\\n\\tres = \"\"\\n\\tfor i, cnt in enumerate(X):\\n\\t\\tres += chr(ord(\\'0\\') + i) * cnt\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 903575,
                "title": "swift-solution-beats-100",
                "content": "Swift solution beats 100%\\n```\\nclass Solution {\\n    func originalDigits(_ s: String) -> String {\\n        let s = Array(s).map({ Int($0.asciiValue ?? 97) - 97 }), alphabet = 26, digits = 10\\n        var a = [Int](repeating: 0, count: alphabet), d = [Int](repeating: 0, count: digits), result = [Int]()\\n        for char in s { a[char] += 1 } // count all characters in source string\\n\\t\\t// z is unique char, count all zero\\n        while a[25] > 0 { d[0] += 1; a[25] -= 1; a[4] -= 1; a[17] -= 1; a[14] -= 1 }\\n\\t\\t// w is unique char, count all two\\n        while a[22] > 0 { d[2] += 1; a[19] -= 1; a[22] -= 1; a[14] -= 1 }\\n\\t\\t// u is unique char, count all four\\n        while a[20] > 0 { d[4] += 1; a[5] -= 1; a[14] -= 1; a[20] -= 1; a[17] -= 1 }\\n\\t\\t// x is unique char, count all six\\n        while a[23] > 0 { d[6] += 1; a[18] -= 1; a[8] -= 1; a[23] -= 1 }\\n\\t\\t// g is unique char, count all eight\\n        while a[6] > 0 { d[8] += 1; a[4] -= 1; a[8] -= 1; a[6] -= 1; a[7] -= 1; a[19] -= 1 }\\n\\t\\t// now r is unique char, count all three\\n        while a[17] > 0 { d[3] += 1; a[19] -= 1; a[7] -= 1; a[17] -= 1; a[4] -= 2 }\\n\\t\\t// now f is unique char, count all five\\n        while a[5] > 0 { d[5] += 1; a[5] -= 1; a[8] -= 1; a[21] -= 1; a[4] -= 1 }\\n\\t\\t// now s is unique char, count all seven\\n        while a[18] > 0 { d[7] += 1; a[18] -= 1; a[4] -= 2; a[21] -= 1; a[13] -= 1 }\\n\\t\\t// now o is unique char, count all one\\n        while a[14] > 0 { d[1] += 1; a[14] -= 1; a[13] -= 1; a[4] -= 1 }\\n\\t\\t// now i is unique char, count all nine\\n        while a[8] > 0 { d[9] += 1; a[13] -= 2; a[8] -= 1; a[4] -= 1 }\\n\\t\\t// make result\\n        for i in 0..<digits { for j in 0..<d[i] { result.append(i) } }\\n        return result.map({ \"\\\\($0)\" }).joined(separator: \"\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func originalDigits(_ s: String) -> String {\\n        let s = Array(s).map({ Int($0.asciiValue ?? 97) - 97 }), alphabet = 26, digits = 10\\n        var a = [Int](repeating: 0, count: alphabet), d = [Int](repeating: 0, count: digits), result = [Int]()\\n        for char in s { a[char] += 1 } // count all characters in source string\\n\\t\\t// z is unique char, count all zero\\n        while a[25] > 0 { d[0] += 1; a[25] -= 1; a[4] -= 1; a[17] -= 1; a[14] -= 1 }\\n\\t\\t// w is unique char, count all two\\n        while a[22] > 0 { d[2] += 1; a[19] -= 1; a[22] -= 1; a[14] -= 1 }\\n\\t\\t// u is unique char, count all four\\n        while a[20] > 0 { d[4] += 1; a[5] -= 1; a[14] -= 1; a[20] -= 1; a[17] -= 1 }\\n\\t\\t// x is unique char, count all six\\n        while a[23] > 0 { d[6] += 1; a[18] -= 1; a[8] -= 1; a[23] -= 1 }\\n\\t\\t// g is unique char, count all eight\\n        while a[6] > 0 { d[8] += 1; a[4] -= 1; a[8] -= 1; a[6] -= 1; a[7] -= 1; a[19] -= 1 }\\n\\t\\t// now r is unique char, count all three\\n        while a[17] > 0 { d[3] += 1; a[19] -= 1; a[7] -= 1; a[17] -= 1; a[4] -= 2 }\\n\\t\\t// now f is unique char, count all five\\n        while a[5] > 0 { d[5] += 1; a[5] -= 1; a[8] -= 1; a[21] -= 1; a[4] -= 1 }\\n\\t\\t// now s is unique char, count all seven\\n        while a[18] > 0 { d[7] += 1; a[18] -= 1; a[4] -= 2; a[21] -= 1; a[13] -= 1 }\\n\\t\\t// now o is unique char, count all one\\n        while a[14] > 0 { d[1] += 1; a[14] -= 1; a[13] -= 1; a[4] -= 1 }\\n\\t\\t// now i is unique char, count all nine\\n        while a[8] > 0 { d[9] += 1; a[13] -= 2; a[8] -= 1; a[4] -= 1 }\\n\\t\\t// make result\\n        for i in 0..<digits { for j in 0..<d[i] { result.append(i) } }\\n        return result.map({ \"\\\\($0)\" }).joined(separator: \"\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839022,
                "title": "python3-via-counter",
                "content": "Order is the key to uniquely identify the digits with available info. \\n\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        freq = Counter(s)\\n        nums = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n        \\n        ans = [0]*10\\n        for c, i in (\"g\", 8), (\"u\", 4), (\"w\", 2), (\"x\", 6), (\"z\", 0), (\"s\", 7), (\"v\", 5), (\"h\", 3), (\"i\", 9), (\"o\", 1): \\n            ans[i] = freq[c]\\n            freq -= Counter(nums[i]*freq[c])\\n        return \"\".join(sorted(str(i)*x for i, x in enumerate(ans)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        freq = Counter(s)\\n        nums = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n        \\n        ans = [0]*10\\n        for c, i in (\"g\", 8), (\"u\", 4), (\"w\", 2), (\"x\", 6), (\"z\", 0), (\"s\", 7), (\"v\", 5), (\"h\", 3), (\"i\", 9), (\"o\", 1): \\n            ans[i] = freq[c]\\n            freq -= Counter(nums[i]*freq[c])\\n        return \"\".join(sorted(str(i)*x for i, x in enumerate(ans)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823078,
                "title": "go",
                "content": "```\\nfunc originalDigits(s string) string {\\n    dict := make([]int, 26)\\n    for i := 0; i < len(s); i++ {\\n        dict[int(s[i] - \\'a\\')]++\\n    }\\n    \\n    res := make([]string, 10)\\n    res[0] = helper(\\'z\\', dict, \"zero\", \"0\")\\n    res[6] = helper(\\'x\\', dict, \"six\", \"6\")\\n    res[2] = helper(\\'w\\', dict, \"two\", \"2\")\\n    res[4] = helper(\\'u\\', dict, \"four\", \"4\")\\n    res[5] = helper(\\'f\\', dict, \"five\", \"5\")\\n    res[1] = helper(\\'o\\', dict, \"one\", \"1\")\\n    res[7] = helper(\\'s\\', dict, \"seven\", \"7\")\\n    res[3] = helper(\\'r\\', dict, \"three\", \"3\")\\n    res[8] = helper(\\'t\\', dict, \"eight\", \"8\")\\n    res[9] = helper(\\'i\\', dict, \"nine\", \"9\")\\n    \\n    return strings.Join(res, \"\")\\n}\\n\\nfunc helper(b byte, dict []int, s string, num string) string {\\n    v := dict[int(b - \\'a\\')]\\n    for i := 0; i < len(s); i++ {\\n        dict[int(s[i] - \\'a\\')] -= v\\n    }\\n    return strings.Repeat(num, v)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc originalDigits(s string) string {\\n    dict := make([]int, 26)\\n    for i := 0; i < len(s); i++ {\\n        dict[int(s[i] - \\'a\\')]++\\n    }\\n    \\n    res := make([]string, 10)\\n    res[0] = helper(\\'z\\', dict, \"zero\", \"0\")\\n    res[6] = helper(\\'x\\', dict, \"six\", \"6\")\\n    res[2] = helper(\\'w\\', dict, \"two\", \"2\")\\n    res[4] = helper(\\'u\\', dict, \"four\", \"4\")\\n    res[5] = helper(\\'f\\', dict, \"five\", \"5\")\\n    res[1] = helper(\\'o\\', dict, \"one\", \"1\")\\n    res[7] = helper(\\'s\\', dict, \"seven\", \"7\")\\n    res[3] = helper(\\'r\\', dict, \"three\", \"3\")\\n    res[8] = helper(\\'t\\', dict, \"eight\", \"8\")\\n    res[9] = helper(\\'i\\', dict, \"nine\", \"9\")\\n    \\n    return strings.Join(res, \"\")\\n}\\n\\nfunc helper(b byte, dict []int, s string, num string) string {\\n    v := dict[int(b - \\'a\\')]\\n    for i := 0; i < len(s); i++ {\\n        dict[int(s[i] - \\'a\\')] -= v\\n    }\\n    return strings.Repeat(num, v)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 694919,
                "title": "python3-math-solution-reconstruct-original-digits-from-english",
                "content": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        digits = {\\n         \\'z\\': [0],\\n         \\'w\\': [2],\\n         \\'u\\': [4],\\n         \\'x\\': [6],\\n         \\'g\\': [8],\\n         \\'h\\': [8, 3],\\n         \\'f\\': [4, 5],\\n         \\'s\\': [6, 7],\\n         \\'o\\': [0, 2, 4, 1],\\n         \\'i\\': [5, 6, 8, 9],\\n        }\\n        counts = [0] * 10\\n        for c in s:\\n            if c in digits:\\n                counts[digits[c][-1]] += 1\\n        for c in \\'hfsoi\\':\\n            counts[digits[c][-1]] -= sum(counts[i] for i in digits[c][:-1])\\n        return \\'\\'.join([str(i) * c for i, c in enumerate(counts) if c])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        digits = {\\n         \\'z\\': [0],\\n         \\'w\\': [2],\\n         \\'u\\': [4],\\n         \\'x\\': [6],\\n         \\'g\\': [8],\\n         \\'h\\': [8, 3],\\n         \\'f\\': [4, 5],\\n         \\'s\\': [6, 7],\\n         \\'o\\': [0, 2, 4, 1],\\n         \\'i\\': [5, 6, 8, 9],\\n        }\\n        counts = [0] * 10\\n        for c in s:\\n            if c in digits:\\n                counts[digits[c][-1]] += 1\\n        for c in \\'hfsoi\\':\\n            counts[digits[c][-1]] -= sum(counts[i] for i in digits[c][:-1])\\n        return \\'\\'.join([str(i) * c for i, c in enumerate(counts) if c])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684730,
                "title": "generalized-method-that-identifies-unique-characters-automatically",
                "content": "At first I was temptated to hard code the unique characters like top-voted posts do. Then I realize that there\\'s no need to identify the unique characters ourselves. Process each representation in a queue and if it contains a unique character, count it and update the letter pools and character counts. Then try to identify the next unique character.\\n\\n```\\nstring originalDigits(string s) {\\n\\tvector<string> reps{\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"};\\n\\tunordered_map<char,int> letters;\\n\\tfor(int i=0; i<reps.size(); i++){\\n\\t\\tfor(auto c : reps[i]){\\n\\t\\t\\tif(letters.find(c)==letters.end()) letters[c]=1;\\n\\t\\t\\telse letters[c]++;\\n\\t\\t}\\n\\t}\\n\\tqueue<int> proc;\\n\\tfor(int i=0; i<10; i++) proc.push(i);\\n\\n\\tvector<int> nums(10,0), chars(26,0);\\n\\tfor(auto c: s) chars[c-\\'a\\']++;\\n\\n\\twhile(!proc.empty()){\\n\\t\\tint cur = proc.front();\\n\\t\\tproc.pop();\\n\\t\\tint i=0;\\n\\t\\twhile(i < reps[cur].size() && (letters.find(reps[cur][i])==letters.end() || letters[reps[cur][i]]!=1)) i++;\\n\\t\\tif(i==reps[cur].size()){\\n\\t\\t\\tproc.push(cur);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tint count = chars[reps[cur][i]-\\'a\\'];\\n\\t\\tfor(int j=0; j<reps[cur].size(); j++){\\n\\t\\t\\tchars[reps[cur][j]-\\'a\\'] -= count;\\n\\t\\t\\tletters[reps[cur][j]]--;\\n\\t\\t}\\n\\t\\tnums[cur] = count;\\n\\t}\\n\\n\\tstring res;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tres.append(nums[i], \\'0\\'+i);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring originalDigits(string s) {\\n\\tvector<string> reps{\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"};\\n\\tunordered_map<char,int> letters;\\n\\tfor(int i=0; i<reps.size(); i++){\\n\\t\\tfor(auto c : reps[i]){\\n\\t\\t\\tif(letters.find(c)==letters.end()) letters[c]=1;\\n\\t\\t\\telse letters[c]++;\\n\\t\\t}\\n\\t}\\n\\tqueue<int> proc;\\n\\tfor(int i=0; i<10; i++) proc.push(i);\\n\\n\\tvector<int> nums(10,0), chars(26,0);\\n\\tfor(auto c: s) chars[c-\\'a\\']++;\\n\\n\\twhile(!proc.empty()){\\n\\t\\tint cur = proc.front();\\n\\t\\tproc.pop();\\n\\t\\tint i=0;\\n\\t\\twhile(i < reps[cur].size() && (letters.find(reps[cur][i])==letters.end() || letters[reps[cur][i]]!=1)) i++;\\n\\t\\tif(i==reps[cur].size()){\\n\\t\\t\\tproc.push(cur);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tint count = chars[reps[cur][i]-\\'a\\'];\\n\\t\\tfor(int j=0; j<reps[cur].size(); j++){\\n\\t\\t\\tchars[reps[cur][j]-\\'a\\'] -= count;\\n\\t\\t\\tletters[reps[cur][j]]--;\\n\\t\\t}\\n\\t\\tnums[cur] = count;\\n\\t}\\n\\n\\tstring res;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tres.append(nums[i], \\'0\\'+i);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 542810,
                "title": "java-using-topological-sort",
                "content": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        String[] digits = new String[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"};\\n        \\n        Set<Integer>[] set = new Set[256];\\n        for (int i = 0; i < 256; i++) \\n            set[i] = new HashSet<Integer>();\\n        \\n        for (int i = 0; i < 10; i++)\\n            for (char c: digits[i].toCharArray())\\n                set[c].add(i);\\n        \\n        Map<Character, Integer> map = new HashMap();  // count letters in s\\n        for (char c: s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\n        int[] res = new int[10];\\n        \\n        for (int i = 0 ; i < 10; i++) {\\n            int j = 0;\\n            while (set[j].size() != 1) j++;  //find the first letter wchih is used in only one digit\\n            int d = set[j].iterator().next();\\n            \\n            for (Set<Integer> st : set) // remove this digit from the sets\\n                if (st.contains(d))\\n                    st.remove(d);\\n            \\n            int count = map.getOrDefault((char)j, 0);\\n            \\n            if (count > 0)\\n                for (char c : digits[d].toCharArray())\\n                    map.put(c, map.get(c) - count);\\n            res[d] = count;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++)\\n            while (res[i]-- > 0)\\n                sb.append(i);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        String[] digits = new String[]{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"};\\n        \\n        Set<Integer>[] set = new Set[256];\\n        for (int i = 0; i < 256; i++) \\n            set[i] = new HashSet<Integer>();\\n        \\n        for (int i = 0; i < 10; i++)\\n            for (char c: digits[i].toCharArray())\\n                set[c].add(i);\\n        \\n        Map<Character, Integer> map = new HashMap();  // count letters in s\\n        for (char c: s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\n        int[] res = new int[10];\\n        \\n        for (int i = 0 ; i < 10; i++) {\\n            int j = 0;\\n            while (set[j].size() != 1) j++;  //find the first letter wchih is used in only one digit\\n            int d = set[j].iterator().next();\\n            \\n            for (Set<Integer> st : set) // remove this digit from the sets\\n                if (st.contains(d))\\n                    st.remove(d);\\n            \\n            int count = map.getOrDefault((char)j, 0);\\n            \\n            if (count > 0)\\n                for (char c : digits[d].toCharArray())\\n                    map.put(c, map.get(c) - count);\\n            res[d] = count;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++)\\n            while (res[i]-- > 0)\\n                sb.append(i);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538923,
                "title": "go-0ms-solution-with-comment",
                "content": "```go\\nfunc originalDigits(s string) string {\\n\\tcounter := [26]int{}\\n\\tfor _, v := range s {\\n\\t\\tcounter[v-\\'a\\']++\\n\\t}\\n\\tnumberCounter := [10]int{}\\n\\tnumberCounter[0] = counter[\\'z\\'-\\'a\\'] // zero - z\\n\\tnumberCounter[2] = counter[\\'w\\'-\\'a\\'] // two - w\\n\\tnumberCounter[4] = counter[\\'u\\'-\\'a\\'] // four - u\\n\\tnumberCounter[6] = counter[\\'x\\'-\\'a\\'] // six - x\\n\\tnumberCounter[8] = counter[\\'g\\'-\\'a\\'] // eight - g\\n\\n\\tnumberCounter[3] = counter[\\'h\\'-\\'a\\'] - numberCounter[8] // eight & three - h\\n\\tnumberCounter[5] = counter[\\'f\\'-\\'a\\'] - numberCounter[4] // four & five - f\\n\\tnumberCounter[7] = counter[\\'v\\'-\\'a\\'] - numberCounter[5] // five & seven - v\\n\\tnumberCounter[1] = counter[\\'o\\'-\\'a\\'] - numberCounter[0] - numberCounter[2] - numberCounter[4] // zero & one & two & four - o\\n\\tnumberCounter[9] = counter[\\'i\\'-\\'a\\'] - numberCounter[5] - numberCounter[6] - numberCounter[8] // five & six & eight & nine - i\\n\\tbb := bytes.Buffer{}\\n\\tfor i := 0; i <= 9; i++ {\\n\\t\\tfor j := 0; j < numberCounter[i]; j++ {\\n\\t\\t\\t_ = bb.WriteByte(\\'0\\' + byte(i))\\n\\t\\t}\\n\\t}\\n\\treturn bb.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc originalDigits(s string) string {\\n\\tcounter := [26]int{}\\n\\tfor _, v := range s {\\n\\t\\tcounter[v-\\'a\\']++\\n\\t}\\n\\tnumberCounter := [10]int{}\\n\\tnumberCounter[0] = counter[\\'z\\'-\\'a\\'] // zero - z\\n\\tnumberCounter[2] = counter[\\'w\\'-\\'a\\'] // two - w\\n\\tnumberCounter[4] = counter[\\'u\\'-\\'a\\'] // four - u\\n\\tnumberCounter[6] = counter[\\'x\\'-\\'a\\'] // six - x\\n\\tnumberCounter[8] = counter[\\'g\\'-\\'a\\'] // eight - g\\n\\n\\tnumberCounter[3] = counter[\\'h\\'-\\'a\\'] - numberCounter[8] // eight & three - h\\n\\tnumberCounter[5] = counter[\\'f\\'-\\'a\\'] - numberCounter[4] // four & five - f\\n\\tnumberCounter[7] = counter[\\'v\\'-\\'a\\'] - numberCounter[5] // five & seven - v\\n\\tnumberCounter[1] = counter[\\'o\\'-\\'a\\'] - numberCounter[0] - numberCounter[2] - numberCounter[4] // zero & one & two & four - o\\n\\tnumberCounter[9] = counter[\\'i\\'-\\'a\\'] - numberCounter[5] - numberCounter[6] - numberCounter[8] // five & six & eight & nine - i\\n\\tbb := bytes.Buffer{}\\n\\tfor i := 0; i <= 9; i++ {\\n\\t\\tfor j := 0; j < numberCounter[i]; j++ {\\n\\t\\t\\t_ = bb.WriteByte(\\'0\\' + byte(i))\\n\\t\\t}\\n\\t}\\n\\treturn bb.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 505751,
                "title": "c-easy-to-understand-beats-50-100",
                "content": "I take a new order to find the unique number on the rest of the letters.\\nFor example, the first number \"six\", with the unique letter \"x\", we can find all the \"six\"s because only \"six\" contain \"x\" and every other letter has no \"x\".\\nThen, all the \"z\" are from \"zero\", \"w\" are from \"two\",...\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<string> dic={\"six\",\"zero\",\"two\",\"seven\",\"five\",\"four\",\"one\",\"eight\",\"three\",\"nine\"};\\n        vector<int> dic_index={2,0,1,0,2,2,0,2,2,1};\\n        vector<char> num={\\'6\\',\\'0\\',\\'2\\',\\'7\\',\\'5\\',\\'4\\',\\'1\\',\\'8\\',\\'3\\',\\'9\\'};\\n        vector<int> letter(26,0);\\n        string res;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            letter[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n            while(letter[dic[i][dic_index[i]]-\\'a\\']>0)\\n            {\\n                for(int j=0;j<dic[i].size();j++)\\n                {\\n                    letter[dic[i][j]-\\'a\\']--;\\n                }\\n                res.push_back(num[i]);\\n            }\\n        }\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<string> dic={\"six\",\"zero\",\"two\",\"seven\",\"five\",\"four\",\"one\",\"eight\",\"three\",\"nine\"};\\n        vector<int> dic_index={2,0,1,0,2,2,0,2,2,1};\\n        vector<char> num={\\'6\\',\\'0\\',\\'2\\',\\'7\\',\\'5\\',\\'4\\',\\'1\\',\\'8\\',\\'3\\',\\'9\\'};\\n        vector<int> letter(26,0);\\n        string res;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            letter[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n            while(letter[dic[i][dic_index[i]]-\\'a\\']>0)\\n            {\\n                for(int j=0;j<dic[i].size();j++)\\n                {\\n                    letter[dic[i][j]-\\'a\\']--;\\n                }\\n                res.push_back(num[i]);\\n            }\\n        }\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359214,
                "title": "interesting",
                "content": "For each digits, I print the number it has... And I found:\\nFirst, only 0 has \\'z\\', only 6 has \\'x\\', only 2 has \\'w\\', only 4 has \\'u\\'.\\nThen, I removed 0, 2, 4, 6, and for the left: only 7 has \\'s\\', only 1 has \\'o\\', only 8 has \\'g\\', only 5 has \\'f\\'\\nAnd so on...\\nSo I wrote the solution\\n```python\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        # z -> 0\\n        # x -> 6\\n        # w -> 2\\n        # u -> 4\\n        \\n        \\n        # s -> 7\\n        # o -> 1\\n        # g -> 8\\n        # f -> 5\\n        \\n        # h -> 3\\n        # i -> 9\\n        pattern = [[0 for _ in range(26)] for _ in range(10)]\\n        digits = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n        for i in range(10):\\n            for d in digits[i]:\\n                pattern[i][ord(d) - ord(\\'a\\')] += 1\\n        num = [0 for _ in range(10)]\\n        total = [0 for _ in range(26)]\\n        for c in s:\\n            total[ord(c) - ord(\\'a\\')] += 1\\n        #for i in range(10):\\n        #    if i not in (0, 6, 2, 4):\\n        #        print(i, pattern[i])\\n        #return\\n            \\n        def identify(i, char):\\n            num[i] = total[ord(char)-ord(\\'a\\')]\\n            for idx, p in enumerate(pattern[i]):\\n                total[idx] -= p * num[i]\\n        \\n        identify(0, \\'z\\')\\n        identify(6, \\'x\\')\\n        identify(2, \\'w\\')\\n        identify(4, \\'u\\')\\n        \\n        identify(7, \\'s\\')\\n        identify(1, \\'o\\')\\n        identify(8, \\'g\\')\\n        identify(5, \\'f\\')\\n        identify(3, \\'h\\')\\n        identify(9, \\'i\\')\\n        ret = \"\"\\n        for i in range(10):\\n            ret += str(i) * num[i]\\n        return ret\\n            \\n       \\n\\t  ```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        # z -> 0\\n        # x -> 6\\n        # w -> 2\\n        # u -> 4\\n        \\n        \\n        # s -> 7\\n        # o -> 1\\n        # g -> 8\\n        # f -> 5\\n        \\n        # h -> 3\\n        # i -> 9\\n        pattern = [[0 for _ in range(26)] for _ in range(10)]\\n        digits = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n        for i in range(10):\\n            for d in digits[i]:\\n                pattern[i][ord(d) - ord(\\'a\\')] += 1\\n        num = [0 for _ in range(10)]\\n        total = [0 for _ in range(26)]\\n        for c in s:\\n            total[ord(c) - ord(\\'a\\')] += 1\\n        #for i in range(10):\\n        #    if i not in (0, 6, 2, 4):\\n        #        print(i, pattern[i])\\n        #return\\n            \\n        def identify(i, char):\\n            num[i] = total[ord(char)-ord(\\'a\\')]\\n            for idx, p in enumerate(pattern[i]):\\n                total[idx] -= p * num[i]\\n        \\n        identify(0, \\'z\\')\\n        identify(6, \\'x\\')\\n        identify(2, \\'w\\')\\n        identify(4, \\'u\\')\\n        \\n        identify(7, \\'s\\')\\n        identify(1, \\'o\\')\\n        identify(8, \\'g\\')\\n        identify(5, \\'f\\')\\n        identify(3, \\'h\\')\\n        identify(9, \\'i\\')\\n        ret = \"\"\\n        for i in range(10):\\n            ret += str(i) * num[i]\\n        return ret\\n            \\n       \\n\\t  ```",
                "codeTag": "Java"
            },
            {
                "id": 277458,
                "title": "simple-character-counting-solution",
                "content": "The idea is to systematically count the characters. We first count characters that appear uniquely in the string representation of numbers (such as \\'z\\' in \\'zero), then use the information to count other numbers. \\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        nums = [0] * 10\\n        nums[0] = s.count(\\'z\\')\\n        nums[2] = s.count(\\'w\\')\\n        nums[4] = s.count(\\'u\\')\\n        nums[8] = s.count(\\'g\\')\\n        nums[3] = s.count(\\'h\\') - nums[8]\\n        nums[5] = s.count(\\'f\\') - nums[4]\\n        nums[6] = s.count(\\'x\\')\\n        nums[7] = s.count(\\'v\\') - nums[5]\\n        nums[1] = s.count(\\'o\\') - nums[2] - nums[4] - nums[0]\\n        nums[9] = s.count(\\'i\\') - nums[5] - nums[6] - nums[8]\\n        out = \\'\\'\\n        print(nums)\\n        for i in range(len(nums)):\\n            out += str(i) * nums[i]\\n        return out\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        nums = [0] * 10\\n        nums[0] = s.count(\\'z\\')\\n        nums[2] = s.count(\\'w\\')\\n        nums[4] = s.count(\\'u\\')\\n        nums[8] = s.count(\\'g\\')\\n        nums[3] = s.count(\\'h\\') - nums[8]\\n        nums[5] = s.count(\\'f\\') - nums[4]\\n        nums[6] = s.count(\\'x\\')\\n        nums[7] = s.count(\\'v\\') - nums[5]\\n        nums[1] = s.count(\\'o\\') - nums[2] - nums[4] - nums[0]\\n        nums[9] = s.count(\\'i\\') - nums[5] - nums[6] - nums[8]\\n        out = \\'\\'\\n        print(nums)\\n        for i in range(len(nums)):\\n            out += str(i) * nums[i]\\n        return out\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 206874,
                "title": "c-method",
                "content": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<string> temp{\"zero\",\"two\",\"four\",\"six\",\"eight\",\"one\",\"three\",\"seven\",\"five\",\"nine\"};\\n        vector<char> key_word{\\'z\\',\\'w\\',\\'u\\',\\'x\\',\\'g\\',\\'o\\',\\'r\\',\\'s\\',\\'v\\',\\'i\\'};\\n        unordered_map<char,int> val;\\n        val[\\'z\\'] = \\'0\\';\\n        val[\\'w\\'] = \\'2\\';\\n        val[\\'u\\'] = \\'4\\';\\n        val[\\'x\\'] = \\'6\\';\\n        val[\\'g\\'] = \\'8\\';\\n        val[\\'o\\'] = \\'1\\';\\n        val[\\'r\\'] = \\'3\\';\\n        val[\\'v\\'] = \\'5\\';\\n        val[\\'s\\'] = \\'7\\';\\n        val[\\'i\\'] = \\'9\\';\\n        unordered_map<char,int> sets;\\n        string retv;\\n        for(auto e:s)\\n        {\\n            sets[e]++;\\n        }\\n        for(int i =0;i<10;i++)\\n        {\\n            if(sets.count(key_word[i])&&sets[key_word[i]]!=0)\\n            {\\n               int cnt = sets[key_word[i]];\\n                for(auto c: temp[i])\\n                {\\n                    sets[c] -=cnt;\\n                }\\n                while(cnt--)\\n                    retv+=val[key_word[i]];\\n            }\\n        }\\n        sort(retv.begin(),retv.end());\\n        return retv;\\n \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<string> temp{\"zero\",\"two\",\"four\",\"six\",\"eight\",\"one\",\"three\",\"seven\",\"five\",\"nine\"};\\n        vector<char> key_word{\\'z\\',\\'w\\',\\'u\\',\\'x\\',\\'g\\',\\'o\\',\\'r\\',\\'s\\',\\'v\\',\\'i\\'};\\n        unordered_map<char,int> val;\\n        val[\\'z\\'] = \\'0\\';\\n        val[\\'w\\'] = \\'2\\';\\n        val[\\'u\\'] = \\'4\\';\\n        val[\\'x\\'] = \\'6\\';\\n        val[\\'g\\'] = \\'8\\';\\n        val[\\'o\\'] = \\'1\\';\\n        val[\\'r\\'] = \\'3\\';\\n        val[\\'v\\'] = \\'5\\';\\n        val[\\'s\\'] = \\'7\\';\\n        val[\\'i\\'] = \\'9\\';\\n        unordered_map<char,int> sets;\\n        string retv;\\n        for(auto e:s)\\n        {\\n            sets[e]++;\\n        }\\n        for(int i =0;i<10;i++)\\n        {\\n            if(sets.count(key_word[i])&&sets[key_word[i]]!=0)\\n            {\\n               int cnt = sets[key_word[i]];\\n                for(auto c: temp[i])\\n                {\\n                    sets[c] -=cnt;\\n                }\\n                while(cnt--)\\n                    retv+=val[key_word[i]];\\n            }\\n        }\\n        sort(retv.begin(),retv.end());\\n        return retv;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111982,
                "title": "straightforward-solution-playing-with-letters",
                "content": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        std::vector<int> v(26, 0);    \\n        for (int i = 0; i < s.size(); i++) {\\n            v[s[i] - '0' - 49]++;\\n        }\\n        std::string res;\\n        while (v[25]-- > 0) { res += '0'; v[4]-=1;  v[17]-=1; v[14]-=1; }\\n        while (v[22]-- > 0) { res += '2'; v[19]-=1; v[14]-=1; }\\n        while (v[20]-- > 0) { res += '4'; v[5]-=1;  v[14]-=1; v[17]-=1; }\\n        while (v[23]-- > 0) { res += '6'; v[18]-=1; v[8]-=1;  }\\n        while (v[6]--  > 0) { res += '8'; v[4]-=1;  v[8]-=1;  v[7]-=1;  v[19]-=1; }\\n        while (v[14]-- > 0) { res += \"1\"; v[13]-=1; v[4]-=1;  }\\n        while (v[7]--  > 0) { res += \"3\"; v[19]-=1; v[17]-=1; v[4]-=2;  }\\n        while (v[5]--  > 0) { res += \"5\"; v[8]-=1;  v[21]-=1; v[4]-=1;  }\\n        while (v[21]-- > 0) { res += \"7\"; v[18]-=1; v[4]-=2;  v[13]-=1; }\\n        while (v[8]--  > 0) { res += \"9\"; }\\n        std::sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        std::vector<int> v(26, 0);    \\n        for (int i = 0; i < s.size(); i++) {\\n            v[s[i] - '0' - 49]++;\\n        }\\n        std::string res;\\n        while (v[25]-- > 0) { res += '0'; v[4]-=1;  v[17]-=1; v[14]-=1; }\\n        while (v[22]-- > 0) { res += '2'; v[19]-=1; v[14]-=1; }\\n        while (v[20]-- > 0) { res += '4'; v[5]-=1;  v[14]-=1; v[17]-=1; }\\n        while (v[23]-- > 0) { res += '6'; v[18]-=1; v[8]-=1;  }\\n        while (v[6]--  > 0) { res += '8'; v[4]-=1;  v[8]-=1;  v[7]-=1;  v[19]-=1; }\\n        while (v[14]-- > 0) { res += \"1\"; v[13]-=1; v[4]-=1;  }\\n        while (v[7]--  > 0) { res += \"3\"; v[19]-=1; v[17]-=1; v[4]-=2;  }\\n        while (v[5]--  > 0) { res += \"5\"; v[8]-=1;  v[21]-=1; v[4]-=1;  }\\n        while (v[21]-- > 0) { res += \"7\"; v[18]-=1; v[4]-=2;  v[13]-=1; }\\n        while (v[8]--  > 0) { res += \"9\"; }\\n        std::sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91196,
                "title": "java-o-n-verbose-easy-well-commented-explained",
                "content": "First, the code:\\n```java\\nclass Solution {\\n    public String originalDigits(String s) {\\n        String[] digits = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n        char[] chs = s.toCharArray();\\n        if (s.length() < 3)\\n            return \"\";\\n        int[] counts = new int[26];     //counts of chars in s\\n        int[] order = {0,2,4,6,8,   3,5,7,      1,9};   //array of indices of digits to visit, ordered based on rarity of chars\\n        int[] res = new int[10];    //array to store and sort the result\\n        for (char c : chs)          //count chars in s\\n            counts[c - 'a']++;\\n        for (int i = 0; i < 10; i++) {\\n            int index = order[i];\\n            char[] chd = digits[index].toCharArray();\\n            int min = 50000;\\n            for (char c : chd) {\\n                int count = counts[c - 'a'];\\n                if ((i == 3 && c == 'e') ||\\n                    (i == 7 && c == 'e') ||\\n                    (i == 9 && c == 'n'))\\n                    count /= 2;\\n                if (count < min)\\n                    min = count;\\n            }   //count is now the maximum number of copies of word_for_index we can extract from s\\n            if (min <= 0)   //abort if no copies available\\n                continue;\\n            for (char c : chd)  //subtract char counts to reflect `min` copies extracted\\n                counts[c - 'a'] -= min;\\n            res[index] += min;  //output to res\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            for (int j = 0; j < res[i]; j++) {\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\nThe idea is simple, consider one copy of each of the `0~9` words: `\"zeroonetwothreefourfivesixseveneightnine\"`, we can counts the occurrence of each char and find out that:\\n* `z,x,w,u,g` appears only 1 time;\\n* `v,s,h,f` appears 2 times;\\n* and the rest;\\n\\nWe try to extract one word as many times as possible out of `s` (by subtracting this word's char counts out of `s`'s counts) in each iteration. \\n\\nThe key point is that, the ordering of the words to extract matters. We have to extract words with the rarest characters, i.e. the first case above first, and then words containing the second tier letters, then the rest. The array `order` is used for this purpose. With this idea in mind the code should be easy to relate to. The final loop does something you see in a bucket sort to pour out all the beans in order.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String originalDigits(String s) {\\n        String[] digits = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n        char[] chs = s.toCharArray();\\n        if (s.length() < 3)\\n            return \"\";\\n        int[] counts = new int[26];     //counts of chars in s\\n        int[] order = {0,2,4,6,8,   3,5,7,      1,9};   //array of indices of digits to visit, ordered based on rarity of chars\\n        int[] res = new int[10];    //array to store and sort the result\\n        for (char c : chs)          //count chars in s\\n            counts[c - 'a']++;\\n        for (int i = 0; i < 10; i++) {\\n            int index = order[i];\\n            char[] chd = digits[index].toCharArray();\\n            int min = 50000;\\n            for (char c : chd) {\\n                int count = counts[c - 'a'];\\n                if ((i == 3 && c == 'e') ||\\n                    (i == 7 && c == 'e') ||\\n                    (i == 9 && c == 'n'))\\n                    count /= 2;\\n                if (count < min)\\n                    min = count;\\n            }   //count is now the maximum number of copies of word_for_index we can extract from s\\n            if (min <= 0)   //abort if no copies available\\n                continue;\\n            for (char c : chd)  //subtract char counts to reflect `min` copies extracted\\n                counts[c - 'a'] -= min;\\n            res[index] += min;  //output to res\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            for (int j = 0; j < res[i]; j++) {\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91225,
                "title": "7-liner-in-python-one-pass",
                "content": "Unique identifiers exist if we check all 10 digits in this order```[0, 2, 4, 6, 8, 1, 3, 5, 7, 9]```.\\n```\\nclass Solution(object):\\n    def originalDigits(self, s):\\n        l, cnt, ret = [('zero','z'),('one','o'),('two','w'),('three','h'),('four','u'),('five','f'),('six','x'),('seven','s'),('eight','g'),('nine','i')], collections.Counter(s), []\\n        for i in [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]:\\n            n = cnt[l[i][1]]\\n            for c in l[i][0]:\\n                cnt[c] -= n\\n            ret += [str(i)]*n\\n        return ''.join(sorted(ret))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```[0, 2, 4, 6, 8, 1, 3, 5, 7, 9]```\n```\\nclass Solution(object):\\n    def originalDigits(self, s):\\n        l, cnt, ret = [('zero','z'),('one','o'),('two','w'),('three','h'),('four','u'),('five','f'),('six','x'),('seven','s'),('eight','g'),('nine','i')], collections.Counter(s), []\\n        for i in [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]:\\n            n = cnt[l[i][1]]\\n            for c in l[i][0]:\\n                cnt[c] -= n\\n            ret += [str(i)]*n\\n        return ''.join(sorted(ret))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91226,
                "title": "beat-96-37-eazy-java-solution-use-pre-defined-array-for-looking-up",
                "content": "\\t    public String originalDigits(String s) {\\n\\t        int[] table = new int[26];\\n\\t        for(char c : s.toCharArray())table[c - 'a']++;\\n\\t        int[] res = new int[10];\\n\\t        String[] num = {\"zro\",\"o\",\"wo\",\"h\",\"fou\",\"fi\",\"six\",\"sv\",\"igh\",\"i\"};\\n\\t        char[] identity = {'z','w','x','g','h','u','f','s','i','o'};\\n\\t        int [] order = {0,2,6,8,3,4,5,7,9,1};\\n\\t        for(int i = 0; i < 10; i++){\\n\\t        \\tres[order[i]] = table[identity[i] - 'a'];\\n\\t        \\tfor(char n : num[order[i]].toCharArray()){\\n\\t\\t\\t\\t\\ttable[n - 'a'] -= res[order[i]];\\n\\t\\t\\t\\t}\\n\\t        }\\n\\t        StringBuilder sb = new StringBuilder();\\n\\t        for(int i = 0; i < 10; i++){\\n\\t        \\tfor(int j = 0; j < res[i]; j++) sb.append(i);\\n\\t        }\\n\\t        return sb.toString();\\n\\t    }",
                "solutionTags": [],
                "code": "\\t    public String originalDigits(String s) {\\n\\t        int[] table = new int[26];\\n\\t        for(char c : s.toCharArray())table[c - 'a']++;\\n\\t        int[] res = new int[10];\\n\\t        String[] num = {\"zro\",\"o\",\"wo\",\"h\",\"fou\",\"fi\",\"six\",\"sv\",\"igh\",\"i\"};\\n\\t        char[] identity = {'z','w','x','g','h','u','f','s','i','o'};\\n\\t        int [] order = {0,2,6,8,3,4,5,7,9,1};\\n\\t        for(int i = 0; i < 10; i++){\\n\\t        \\tres[order[i]] = table[identity[i] - 'a'];\\n\\t        \\tfor(char n : num[order[i]].toCharArray()){\\n\\t\\t\\t\\t\\ttable[n - 'a'] -= res[order[i]];\\n\\t\\t\\t\\t}\\n\\t        }\\n\\t        StringBuilder sb = new StringBuilder();\\n\\t        for(int i = 0; i < 10; i++){\\n\\t        \\tfor(int j = 0; j < res[i]; j++) sb.append(i);\\n\\t        }\\n\\t        return sb.toString();\\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 91230,
                "title": "python-solution",
                "content": "    class Solution(object):\\n        def originalDigits(self, s):\\n            f = [0] * 26\\n            for c in s:\\n                f[ord(c)-ord('a')] += 1\\n            h = {'z': ('zero','0'), 'w': ('two','2'), 'x' : ('six','6'), 'g': ('eight','8'), 'h': ('three','3'), 's': ('seven','7'), 'v': ('five','5'), 'f': ('four','4'), 'o': ('one', '1'), 'i': ('nine','9')}\\n            ans = []\\n            for x in ['z','w','x','g','h','s','v','f','o','i']:\\n                word ,num = h[x]\\n                n = f[ord(x)-ord('a')]\\n                if n <= 0:\\n                    continue\\n                ans += [num] * n\\n                for c in word:\\n                    f[ord(c)-ord('a')] -= n\\n            return ''.join(sorted(ans))",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def originalDigits(self, s):\\n            f = [0] * 26\\n            for c in s:\\n                f[ord(c)-ord('a')] += 1\\n            h = {'z': ('zero','0'), 'w': ('two','2'), 'x' : ('six','6'), 'g': ('eight','8'), 'h': ('three','3'), 's': ('seven','7'), 'v': ('five','5'), 'f': ('four','4'), 'o': ('one', '1'), 'i': ('nine','9')}",
                "codeTag": "Java"
            },
            {
                "id": 91235,
                "title": "o-n-solution-by-ordering-digits-in-specific-order",
                "content": "To solve this problem we should order words in some order that this order will help to not stole the chars of another word.\\nAt the beginning we have words {\"zero\", \"one\", \"two\", \"three\", \"four\" , \"five\", \"six\", \"seven\", \"eigth\", \"nine\"};\\nFirst we can take all words with unique char amoung all words. They are: Zero, eiGht, tWo, foUr, siX and remove them from the list.\\nafter, there will left  {\"one\", \"three\", \"five\", \"seven\", \"nine\"}. For this words we can again take words with unique char amoung all words: One, tHree, Five, seVen. After that there will be left only one word \"nine\". Now we have sorted order {\"zero\", \"eight\", \"two\", \"four\" , \"six\", \"one\", \"three\", \"five\", \"seven\", \"nine\"} which will use chars in effective way; \\nWhen order is random some words can stole chars of another word. For example if the input is \"nineoneonesix\" and we first calculate for word nine then we can get 2 nines. By this we stoled the chars of oNe, oNe and sIx. \\n\\nAt the beginning we can count each char's occurences(charCounter) in string. Then we can remove word's chars from charCounter if we can build a word from chars in charCounter. We should process words in ordered way\\n\\n```\\npublic class Solution {\\n\\n    String digits[] = {\"zero\", \"eight\", \"two\", \"four\" , \"six\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n    int digitNumber[] = {0,8,2,4,6,1,3,5,7,9};\\n        \\n    public String originalDigits(String s) {\\n        HashMap<Character, Integer> totalCharCounter = countChars(s);\\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        \\n        for (int i=0; i<digits.length; i++) {\\n            String digit = digits[i];\\n            boolean allCharExists = true;\\n            while (allCharExists) {\\n                allCharExists &= checkWordFromMap(countChars(digit), totalCharCounter);\\n                if (allCharExists) {\\n                    deleteWordCharsFromCounter(digit, totalCharCounter);\\n                    ansList.add(digitNumber[i]);\\n                }\\n            }\\n        }\\n        \\n        return sortAndConvert(ansList);\\n    }\\n    \\n    private HashMap<Character, Integer> countChars(String s) {\\n         HashMap<Character, Integer> charCounter = new HashMap<>();\\n         for (int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            charCounter.put(c, charCounter.getOrDefault(c, 0) + 1);\\n        }\\n        return charCounter;\\n    }\\n    \\n    private boolean checkWordFromMap(HashMap<Character, Integer> digitCharCounter, HashMap<Character, Integer> totalCharCounter) {\\n        boolean allCharExists = true;\\n        for (Map.Entry<Character, Integer> entry: digitCharCounter.entrySet()) {\\n            char key = entry.getKey();\\n            int counter = entry.getValue();\\n            allCharExists &= (totalCharCounter.containsKey(key) && totalCharCounter.get(key)>=counter);\\n        }\\n        return allCharExists;\\n    }\\n    \\n    private void deleteWordCharsFromCounter(String digit, HashMap<Character, Integer> totalCharCounter) {\\n        for (int i=0; i<digit.length(); i++) {\\n            char c = digit.charAt(i);\\n            totalCharCounter.put(c, totalCharCounter.get(c)-1);\\n            if (totalCharCounter.get(c)<=0) {\\n                totalCharCounter.remove(c);\\n            }\\n        }\\n    }\\n    \\n    private String sortAndConvert(ArrayList<Integer> ansList) {\\n        Collections.sort(ansList);\\n        StringBuilder digitsString = new StringBuilder();\\n        for (int val: ansList) {\\n            digitsString .append(val);\\n        }\\n        return digitsString.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    String digits[] = {\"zero\", \"eight\", \"two\", \"four\" , \"six\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n    int digitNumber[] = {0,8,2,4,6,1,3,5,7,9};\\n        \\n    public String originalDigits(String s) {\\n        HashMap<Character, Integer> totalCharCounter = countChars(s);\\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        \\n        for (int i=0; i<digits.length; i++) {\\n            String digit = digits[i];\\n            boolean allCharExists = true;\\n            while (allCharExists) {\\n                allCharExists &= checkWordFromMap(countChars(digit), totalCharCounter);\\n                if (allCharExists) {\\n                    deleteWordCharsFromCounter(digit, totalCharCounter);\\n                    ansList.add(digitNumber[i]);\\n                }\\n            }\\n        }\\n        \\n        return sortAndConvert(ansList);\\n    }\\n    \\n    private HashMap<Character, Integer> countChars(String s) {\\n         HashMap<Character, Integer> charCounter = new HashMap<>();\\n         for (int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            charCounter.put(c, charCounter.getOrDefault(c, 0) + 1);\\n        }\\n        return charCounter;\\n    }\\n    \\n    private boolean checkWordFromMap(HashMap<Character, Integer> digitCharCounter, HashMap<Character, Integer> totalCharCounter) {\\n        boolean allCharExists = true;\\n        for (Map.Entry<Character, Integer> entry: digitCharCounter.entrySet()) {\\n            char key = entry.getKey();\\n            int counter = entry.getValue();\\n            allCharExists &= (totalCharCounter.containsKey(key) && totalCharCounter.get(key)>=counter);\\n        }\\n        return allCharExists;\\n    }\\n    \\n    private void deleteWordCharsFromCounter(String digit, HashMap<Character, Integer> totalCharCounter) {\\n        for (int i=0; i<digit.length(); i++) {\\n            char c = digit.charAt(i);\\n            totalCharCounter.put(c, totalCharCounter.get(c)-1);\\n            if (totalCharCounter.get(c)<=0) {\\n                totalCharCounter.remove(c);\\n            }\\n        }\\n    }\\n    \\n    private String sortAndConvert(ArrayList<Integer> ansList) {\\n        Collections.sort(ansList);\\n        StringBuilder digitsString = new StringBuilder();\\n        for (int val: ansList) {\\n            digitsString .append(val);\\n        }\\n        return digitsString.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91237,
                "title": "beat-90-easy-java-solution",
                "content": "```\\npublic class Solution {\\n    public String originalDigits(String s) {\\n        int[] count = new int[128];\\n        for (char c : s.toCharArray()) {\\n            count[c]++;\\n        }\\n        int[] res = new int[10];\\n        char[] idx = {'z', 'x','s','v','f','r','w','g','o','i'};\\n        for (char i : idx) {\\n            while (count[i] > 0) {\\n                count[i]--;\\n                switch (i) {\\n                    case 'z':\\n                        res[0]++; count['o']--; count['r']--; break;\\n                    case 'x':\\n                        res[6]++; count['s']--; count['i']--; break;\\n                    case 's':\\n                        res[7]++; count['v']--; break;\\n                    case 'v':\\n                        res[5]++; count['f']--; count['i']--; break;\\n                    case 'f':\\n                        res[4]++; count['r']--; count['o']--; break;\\n                    case 'r':\\n                        res[3]++; break;\\n                    case 'w':\\n                        res[2]++; count['o']--; break;\\n                    case 'g':\\n                        res[8]++; count['i']--; break;\\n                    case 'o':\\n                        res[1]++; break;\\n                    case 'i':\\n                        res[9]++; break;\\n                    default: break;\\n                }\\n            }\\n        }\\n        System.out.print(res[0]);\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <= 9; i++) {\\n            for (int j = 0; j < res[i]; j++) {\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String originalDigits(String s) {\\n        int[] count = new int[128];\\n        for (char c : s.toCharArray()) {\\n            count[c]++;\\n        }\\n        int[] res = new int[10];\\n        char[] idx = {'z', 'x','s','v','f','r','w','g','o','i'};\\n        for (char i : idx) {\\n            while (count[i] > 0) {\\n                count[i]--;\\n                switch (i) {\\n                    case 'z':\\n                        res[0]++; count['o']--; count['r']--; break;\\n                    case 'x':\\n                        res[6]++; count['s']--; count['i']--; break;\\n                    case 's':\\n                        res[7]++; count['v']--; break;\\n                    case 'v':\\n                        res[5]++; count['f']--; count['i']--; break;\\n                    case 'f':\\n                        res[4]++; count['r']--; count['o']--; break;\\n                    case 'r':\\n                        res[3]++; break;\\n                    case 'w':\\n                        res[2]++; count['o']--; break;\\n                    case 'g':\\n                        res[8]++; count['i']--; break;\\n                    case 'o':\\n                        res[1]++; break;\\n                    case 'i':\\n                        res[9]++; break;\\n                    default: break;\\n                }\\n            }\\n        }\\n        System.out.print(res[0]);\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i <= 9; i++) {\\n            for (int j = 0; j < res[i]; j++) {\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91221,
                "title": "python-solve-valid-equation-problem",
                "content": "There may be similar idea. Just post for share.\\nMy solution can not verify the validness of input.\\n\\n```\\nclass Solution(object):\\n    def originalDigits(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        dic = {}\\n        for ch in s:\\n            dic[ch] = dic.get(ch, 0) + 1\\n        ret = []\\n        ret.extend( ['0'] * dic.get('z', 0) )\\n        ret.extend( ['1'] * (dic.get('o', 0)-dic.get('z', 0)-dic.get('w', 0)-dic.get('u', 0)) )\\n        ret.extend( ['2'] * dic.get('w', 0) )\\n        ret.extend( ['3'] * (dic.get('h', 0)-dic.get('g', 0)) )\\n        ret.extend( ['4'] * dic.get('u', 0) )\\n        ret.extend( ['5'] * (dic.get('f', 0)-dic.get('u', 0)) )\\n        ret.extend( ['6'] * dic.get('x', 0) )\\n        ret.extend( ['7'] * (dic.get('s', 0)-dic.get('x', 0)) )\\n        ret.extend( ['8'] * dic.get('g', 0) )\\n        ret.extend( ['9'] * (dic.get('i', 0)-dic.get('g', 0)-dic.get('x', 0)-dic.get('f', 0)+dic.get('u', 0) ) )\\n        return ''.join( ret )\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def originalDigits(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        dic = {}\\n        for ch in s:\\n            dic[ch] = dic.get(ch, 0) + 1\\n        ret = []\\n        ret.extend( ['0'] * dic.get('z', 0) )\\n        ret.extend( ['1'] * (dic.get('o', 0)-dic.get('z', 0)-dic.get('w', 0)-dic.get('u', 0)) )\\n        ret.extend( ['2'] * dic.get('w', 0) )\\n        ret.extend( ['3'] * (dic.get('h', 0)-dic.get('g', 0)) )\\n        ret.extend( ['4'] * dic.get('u', 0) )\\n        ret.extend( ['5'] * (dic.get('f', 0)-dic.get('u', 0)) )\\n        ret.extend( ['6'] * dic.get('x', 0) )\\n        ret.extend( ['7'] * (dic.get('s', 0)-dic.get('x', 0)) )\\n        ret.extend( ['8'] * dic.get('g', 0) )\\n        ret.extend( ['9'] * (dic.get('i', 0)-dic.get('g', 0)-dic.get('x', 0)-dic.get('f', 0)+dic.get('u', 0) ) )\\n        return ''.join( ret )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91246,
                "title": "java-naive-solution",
                "content": "A naive solution:  O(n)\\n```\\npublic class Solution {\\n    public String originalDigits(String s) {\\n        char[] dic = {'z','w','g','x','u','s','v','o','t','i'};\\n        String[] digits = {\"zero\",\"two\",\"eight\",\"six\",\"four\",\"seven\",\"five\",\"one\",\"three\",\"nine\"};\\n        int[] index = {0,2,8,6,4,7,5,1,3,9};\\n        int[] map = new int[26];\\n        int[] arr = new int[10];\\n        for(int i=0; i<s.length(); i++){\\n            map[s.charAt(i)-'a']++;\\n        }\\n        for(int i=0; i<10; i++){\\n            getNum(map, dic[i], digits[i], arr, index[i]);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<10; i++){\\n            for(int t=0; t<arr[i]; t++){\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    private void getNum(int[] map, char c, String s, int[] arr, int index){\\n        int dup = map[c-'a'];\\n        for(int i=0; i<dup; i++){\\n            arr[index]++;\\n            for(int j=0; j<s.length(); j++){\\n                map[s.charAt(j)-'a']--;\\n            }\\n        }\\n    }\\n}\\n\\n```\\nThere is a smart solution:  \\nhttps://discuss.leetcode.com/topic/63386/one-pass-o-n-java-solution-simple-and-clear by markieff",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public String originalDigits(String s) {\\n        char[] dic = {'z','w','g','x','u','s','v','o','t','i'};\\n        String[] digits = {\"zero\",\"two\",\"eight\",\"six\",\"four\",\"seven\",\"five\",\"one\",\"three\",\"nine\"};\\n        int[] index = {0,2,8,6,4,7,5,1,3,9};\\n        int[] map = new int[26];\\n        int[] arr = new int[10];\\n        for(int i=0; i<s.length(); i++){\\n            map[s.charAt(i)-'a']++;\\n        }\\n        for(int i=0; i<10; i++){\\n            getNum(map, dic[i], digits[i], arr, index[i]);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<10; i++){\\n            for(int t=0; t<arr[i]; t++){\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    private void getNum(int[] map, char c, String s, int[] arr, int index){\\n        int dup = map[c-'a'];\\n        for(int i=0; i<dup; i++){\\n            arr[index]++;\\n            for(int j=0; j<s.length(); j++){\\n                map[s.charAt(j)-'a']--;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91260,
                "title": "share-my-clear-java-solution",
                "content": "    public String originalDigits(String s) {\\n        int[] wordCount = new int[26];\\n        //check order because of some digit include unique char, eg only '0' include 'z', '2'-'w', '4'-'u' and so on.\\n        String[] digits = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n        int[] number = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};\\n        int[] result = new int[10];\\n        for (int i = 0; i < s.length(); i++)\\n\\t\\t\\twordCount[s.charAt(i) - 'a']++;        \\n        for (int i = 0; i < 10; ) {\\n\\t\\t\\tif(createDigit(wordCount, digits[i]))\\n\\t\\t\\t\\tresult[number[i]]++;\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n        StringBuffer strRes = new StringBuffer();\\n        for (int i = 0; i < result.length; ) {\\n\\t\\t\\tif(result[i]-- != 0)\\n\\t\\t\\t\\tstrRes.append(i);\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n        return strRes.toString();\\n    }\\n    private boolean hasDigit(int[] wordCount, String digit){\\n    \\tfor (int i = 0; i < digit.length(); i++)\\n\\t\\t\\tif(wordCount[digit.charAt(i) - 'a'] == 0)\\n\\t\\t\\t\\treturn false;\\n    \\treturn true;\\n    }\\n    private boolean createDigit(int[] wordCount, String digit){\\n    \\tif(hasDigit(wordCount, digit)){\\n    \\t\\tfor (int i = 0; i < digit.length(); i++)\\n    \\t\\t\\twordCount[digit.charAt(i) - 'a']--;\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "solutionTags": [],
                "code": "    public String originalDigits(String s) {\\n        int[] wordCount = new int[26];\\n        //check order because of some digit include unique char, eg only '0' include 'z', '2'-'w', '4'-'u' and so on.\\n        String[] digits = {\"zero\", \"two\", \"four\", \"six\", \"eight\", \"one\", \"three\", \"five\", \"seven\", \"nine\"};\\n        int[] number = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};\\n        int[] result = new int[10];\\n        for (int i = 0; i < s.length(); i++)\\n\\t\\t\\twordCount[s.charAt(i) - 'a']++;        \\n        for (int i = 0; i < 10; ) {\\n\\t\\t\\tif(createDigit(wordCount, digits[i]))\\n\\t\\t\\t\\tresult[number[i]]++;\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n        StringBuffer strRes = new StringBuffer();\\n        for (int i = 0; i < result.length; ) {\\n\\t\\t\\tif(result[i]-- != 0)\\n\\t\\t\\t\\tstrRes.append(i);\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n        return strRes.toString();\\n    }\\n    private boolean hasDigit(int[] wordCount, String digit){\\n    \\tfor (int i = 0; i < digit.length(); i++)\\n\\t\\t\\tif(wordCount[digit.charAt(i) - 'a'] == 0)\\n\\t\\t\\t\\treturn false;\\n    \\treturn true;\\n    }\\n    private boolean createDigit(int[] wordCount, String digit){\\n    \\tif(hasDigit(wordCount, digit)){\\n    \\t\\tfor (int i = 0; i < digit.length(); i++)\\n    \\t\\t\\twordCount[digit.charAt(i) - 'a']--;\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4088122,
                "title": "c-solution",
                "content": "# Code\\n```\\nchar * originalDigits(char * s){\\n    // char digit[10][10]={\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"};\\n    // z - 0\\n    // x - 6\\n    // w - 2\\n    // s - 6 7\\n    // u - 4\\n    // v - 5 7\\n    // n - 1 7 9\\n    // t - 2 3 8\\n    // r - 0 3 4 \\n    // e -0 1 3 5 7 8 9\\n    // o - 0 1 2 4\\n    // g - 8\\n    // f - 4 5 \\n    // i - 5 6 8 9\\n    // h - 3 8\\n    int n=strlen(s);\\n    int *map=calloc(10,sizeof(int));\\n    char *res=calloc(n/3+1,sizeof(char));\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'z\\')map[0]++;\\n        if(s[i]==\\'x\\')map[6]++;\\n        if(s[i]==\\'w\\')map[2]++;\\n        if(s[i]==\\'u\\')map[4]++;\\n        if(s[i]==\\'g\\')map[8]++;\\n        if(s[i]==\\'h\\')map[3]++; // 3 8\\n        if(s[i]==\\'f\\')map[5]++; // 5 4\\n        if(s[i]==\\'s\\')map[7]++; // 6 7\\n        if(s[i]==\\'i\\')map[9]++; // 5 6 8 9\\n        if(s[i]==\\'o\\')map[1]++; // 0 1 2 4 \\n    }\\n    map[3]=map[3]-map[8];\\n    map[5]=map[5]-map[4];\\n    map[7]=map[7]-map[6];\\n    map[9]=map[9]-(map[5]+map[6]+map[8]);\\n    map[1]=map[1]-(map[0]+map[2]+map[4]);\\n    int idx=0;\\n    for(int i=0;i<10;i++) printf(\"%d \",map[i]);\\n    for(int i=0;i<10;i++){\\n        printf(\"s : %s\\\\n\",res);\\n        while(map[i]-->0){\\n            res[idx++]=\\'0\\'+i;\\n        }\\n    }\\n    // res=realloc(res,sizeof(char)*(idx));\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * originalDigits(char * s){\\n    // char digit[10][10]={\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"};\\n    // z - 0\\n    // x - 6\\n    // w - 2\\n    // s - 6 7\\n    // u - 4\\n    // v - 5 7\\n    // n - 1 7 9\\n    // t - 2 3 8\\n    // r - 0 3 4 \\n    // e -0 1 3 5 7 8 9\\n    // o - 0 1 2 4\\n    // g - 8\\n    // f - 4 5 \\n    // i - 5 6 8 9\\n    // h - 3 8\\n    int n=strlen(s);\\n    int *map=calloc(10,sizeof(int));\\n    char *res=calloc(n/3+1,sizeof(char));\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'z\\')map[0]++;\\n        if(s[i]==\\'x\\')map[6]++;\\n        if(s[i]==\\'w\\')map[2]++;\\n        if(s[i]==\\'u\\')map[4]++;\\n        if(s[i]==\\'g\\')map[8]++;\\n        if(s[i]==\\'h\\')map[3]++; // 3 8\\n        if(s[i]==\\'f\\')map[5]++; // 5 4\\n        if(s[i]==\\'s\\')map[7]++; // 6 7\\n        if(s[i]==\\'i\\')map[9]++; // 5 6 8 9\\n        if(s[i]==\\'o\\')map[1]++; // 0 1 2 4 \\n    }\\n    map[3]=map[3]-map[8];\\n    map[5]=map[5]-map[4];\\n    map[7]=map[7]-map[6];\\n    map[9]=map[9]-(map[5]+map[6]+map[8]);\\n    map[1]=map[1]-(map[0]+map[2]+map[4]);\\n    int idx=0;\\n    for(int i=0;i<10;i++) printf(\"%d \",map[i]);\\n    for(int i=0;i<10;i++){\\n        printf(\"s : %s\\\\n\",res);\\n        while(map[i]-->0){\\n            res[idx++]=\\'0\\'+i;\\n        }\\n    }\\n    // res=realloc(res,sizeof(char)*(idx));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087423,
                "title": "python3-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : using hashmap \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        char = Counter(s)\\n        count = [0] * 10\\n        count[0] = char[\\'z\\']\\n        count[2] = char[\\'w\\']\\n        count[4] = char[\\'u\\']\\n        count[6] = char[\\'x\\']\\n        count[7] = char[\\'s\\'] - count[6]\\n        count[8] = char[\\'g\\']\\n        count[1] = char[\\'o\\'] - count[0] - count[2] - count[4]\\n        count[3] = char[\\'h\\'] - count[8]\\n        count[5] = char[\\'v\\'] - count[7]\\n        count[9] = char[\\'i\\'] - count[5] - count[6] - count[8]\\n        result = \"\"\\n        for i in range(10):\\n            result += str(i) * count[i]\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        char = Counter(s)\\n        count = [0] * 10\\n        count[0] = char[\\'z\\']\\n        count[2] = char[\\'w\\']\\n        count[4] = char[\\'u\\']\\n        count[6] = char[\\'x\\']\\n        count[7] = char[\\'s\\'] - count[6]\\n        count[8] = char[\\'g\\']\\n        count[1] = char[\\'o\\'] - count[0] - count[2] - count[4]\\n        count[3] = char[\\'h\\'] - count[8]\\n        count[5] = char[\\'v\\'] - count[7]\\n        count[9] = char[\\'i\\'] - count[5] - count[6] - count[8]\\n        result = \"\"\\n        for i in range(10):\\n            result += str(i) * count[i]\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034216,
                "title": "c-detailed-code-hash-table-clean-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**CHECK COMMENTS**\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        // Create a map to count the frequency of each character in the input string \\'s\\'.\\n        unordered_map<char, int> m;\\n        for (char c : s) {\\n            m[c]++;\\n        }\\n\\n        string ans; // Initialize the result string.\\n        \\n        // Define a vector of pairs, where each pair contains a mapping from a character to a digit\\n        // and the corresponding word for that digit.\\n        vector<pair<pair<char, char>, string>> v = {\\n            {{\\'z\\', \\'0\\'}, \"zero\"},   // \\'z\\' in \"zero\"\\n            {{\\'w\\', \\'2\\'}, \"two\"},    // \\'w\\' in \"two\"\\n            {{\\'u\\', \\'4\\'}, \"four\"},   // \\'u\\' in \"four\"\\n            {{\\'x\\', \\'6\\'}, \"six\"},    // \\'x\\' in \"six\"\\n            {{\\'g\\', \\'8\\'}, \"eight\"},  // \\'g\\' in \"eight\"\\n            {{\\'o\\', \\'1\\'}, \"one\"},    // \\'o\\' in \"one\"\\n            {{\\'t\\', \\'3\\'}, \"three\"},  // \\'t\\' in \"three\"\\n            {{\\'f\\', \\'5\\'}, \"five\"},   // \\'f\\' in \"five\"\\n            {{\\'s\\', \\'7\\'}, \"seven\"},  // \\'s\\' in \"seven\"\\n            {{\\'i\\', \\'9\\'}, \"nine\"}    // \\'i\\' in \"nine\"\\n        };\\n\\n        // Iterate through the vector of pairs and process each mapping.\\n        for (auto p : v) {\\n            int n = m[p.first.first]; // Get the frequency of the character associated with the digit.\\n            \\n            // Append the digit \\'n\\' times to the result string.\\n            for (int i = 0; i < n; i++) {\\n                ans += p.first.second;\\n            }\\n            \\n            // Update the character frequencies in the map by subtracting \\'n\\' times.\\n            for (char c : p.second) {\\n                m[c] -= n;\\n            }\\n        }\\n\\n        // Sort the result string to obtain the original digits in ascending order.\\n        sort(ans.begin(), ans.end());\\n\\n        return ans; // Return the original digits as a string.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        // Create a map to count the frequency of each character in the input string \\'s\\'.\\n        unordered_map<char, int> m;\\n        for (char c : s) {\\n            m[c]++;\\n        }\\n\\n        string ans; // Initialize the result string.\\n        \\n        // Define a vector of pairs, where each pair contains a mapping from a character to a digit\\n        // and the corresponding word for that digit.\\n        vector<pair<pair<char, char>, string>> v = {\\n            {{\\'z\\', \\'0\\'}, \"zero\"},   // \\'z\\' in \"zero\"\\n            {{\\'w\\', \\'2\\'}, \"two\"},    // \\'w\\' in \"two\"\\n            {{\\'u\\', \\'4\\'}, \"four\"},   // \\'u\\' in \"four\"\\n            {{\\'x\\', \\'6\\'}, \"six\"},    // \\'x\\' in \"six\"\\n            {{\\'g\\', \\'8\\'}, \"eight\"},  // \\'g\\' in \"eight\"\\n            {{\\'o\\', \\'1\\'}, \"one\"},    // \\'o\\' in \"one\"\\n            {{\\'t\\', \\'3\\'}, \"three\"},  // \\'t\\' in \"three\"\\n            {{\\'f\\', \\'5\\'}, \"five\"},   // \\'f\\' in \"five\"\\n            {{\\'s\\', \\'7\\'}, \"seven\"},  // \\'s\\' in \"seven\"\\n            {{\\'i\\', \\'9\\'}, \"nine\"}    // \\'i\\' in \"nine\"\\n        };\\n\\n        // Iterate through the vector of pairs and process each mapping.\\n        for (auto p : v) {\\n            int n = m[p.first.first]; // Get the frequency of the character associated with the digit.\\n            \\n            // Append the digit \\'n\\' times to the result string.\\n            for (int i = 0; i < n; i++) {\\n                ans += p.first.second;\\n            }\\n            \\n            // Update the character frequencies in the map by subtracting \\'n\\' times.\\n            for (char c : p.second) {\\n                m[c] -= n;\\n            }\\n        }\\n\\n        // Sort the result string to obtain the original digits in ascending order.\\n        sort(ans.begin(), ans.end());\\n\\n        return ans; // Return the original digits as a string.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018903,
                "title": "simple-intuition-easy-to-understand",
                "content": "# Intuition\\nWe need to identify the order in which we can uniquely create a number.\\nFor example, only zero has z, two has w, four has u, and six has x.\\n\\nonce we have built six then only seven has s in it.\\nonce we build all the sevens then only five has v in it\\nAlso we can observe only three has r in it and once we build all 3s then eight has h and t\\nand after we build all 8s then only nine has i in it and after that last number remaining is one.\\n\\nAnd since the string is randomly ordered we need a dictionary to store the char count and keep reducing it as we are building the numbers.\\n\\nThere would be further optimisations that can be done but this is easy to understand.\\n\\nEDIT - I have added the fastest method as well.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n) \\n\\n# Code\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        d = {}\\n        for i in s:\\n            d[i] = d.setdefault(i, 0) + 1\\n        ls = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n\\n\\n        ans = \\'\\'\\n\\n\\n        for i in [0, 2, 4, 6, 7, 5, 3, 8, 9, 1]:\\n            if all(i == 0 for i in d.values()):\\n                return ans\\n\\n            while all(j in d and d[j] > 0 for j in ls[i]):\\n                ans += str(i)\\n                for j in ls[i]:\\n                    d[j] -= 1\\n\\n        return \\'\\'.join(sorted(ans))\\n```\\n\\nOptimisation 1\\n\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        d = {}\\n        for i in s:\\n            d[i] = d.setdefault(i, 0) + 1\\n        ls = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n\\n\\n        ans = \\'\\'\\n\\n\\n        for i in [0, 2, 4, 6, 7, 5, 3, 8, 9, 1]:\\n            if all(i == 0 for i in d.values()):\\n                return ans\\n            if all(j in d and d[j] > 0 for j in ls[i]):\\n                nums_possible = min(d[j] for j in ls[i])\\n                ans += str(i)*nums_possible\\n                for j in ls[i]:\\n                    d[j] -= nums_possible\\n            # while all(j in d and d[j] > 0 for j in ls[i]):\\n            #     ans += str(i)\\n            #     for j in ls[i]:\\n            #         d[j] -= 1\\n\\n        return \\'\\'.join(sorted(ans))\\n```\\n\\nOptimisation 2\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        d = {}\\n        for i in s:\\n            d[i] = d.setdefault(i, 0) + 1\\n        ls = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n\\n\\n        ans = \\'\\'\\n        counts = [0 for i in range(0, 10)]\\n        \\n        for i in [0, 2, 4, 6, 7, 5, 3, 8, 9, 1]:\\n            if all(j in d and d[j] > 0 for j in ls[i]):\\n                nums_possible = min(d[j] for j in ls[i])\\n                for j in ls[i]:\\n                    d[j] -= nums_possible\\n                counts[i] = nums_possible\\n        for i in range(10):\\n            ans += str(i)*counts[i]\\n        return ans\\n        # return \\'\\'.join(sorted(ans))\\n```\\n\\nFastest\\n\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        d = {}\\n        for i in s:\\n            d[i] = d.setdefault(i, 0) + 1\\n\\n\\n        ans = \\'\\'\\n        counts = [0 for i in range(0, 10)]\\n        counts[0] = d.setdefault(\\'z\\', 0)\\n        counts[2] = d.setdefault(\\'w\\', 0)\\n        counts[4] = d.setdefault(\\'u\\', 0)\\n        counts[6] = d.setdefault(\\'x\\', 0)\\n        counts[8] = d.setdefault(\\'g\\', 0)\\n        counts[7] = d.setdefault(\\'s\\', 0) - counts[6]\\n        counts[5] = d.setdefault(\\'v\\', 0) - counts[7]\\n        counts[3] = d.setdefault(\\'r\\', 0) - counts[4] - counts[0]\\n        \\n        counts[9] = d.setdefault(\\'i\\', 0) - counts[5] - counts[6] - counts[8]\\n        counts[1] = d.setdefault(\\'o\\', 0) - counts[0] - counts[2] - counts[4]\\n        \\n        for i in range(10):\\n            ans += str(i)*counts[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        d = {}\\n        for i in s:\\n            d[i] = d.setdefault(i, 0) + 1\\n        ls = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n\\n\\n        ans = \\'\\'\\n\\n\\n        for i in [0, 2, 4, 6, 7, 5, 3, 8, 9, 1]:\\n            if all(i == 0 for i in d.values()):\\n                return ans\\n\\n            while all(j in d and d[j] > 0 for j in ls[i]):\\n                ans += str(i)\\n                for j in ls[i]:\\n                    d[j] -= 1\\n\\n        return \\'\\'.join(sorted(ans))\\n```\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        d = {}\\n        for i in s:\\n            d[i] = d.setdefault(i, 0) + 1\\n        ls = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n\\n\\n        ans = \\'\\'\\n\\n\\n        for i in [0, 2, 4, 6, 7, 5, 3, 8, 9, 1]:\\n            if all(i == 0 for i in d.values()):\\n                return ans\\n            if all(j in d and d[j] > 0 for j in ls[i]):\\n                nums_possible = min(d[j] for j in ls[i])\\n                ans += str(i)*nums_possible\\n                for j in ls[i]:\\n                    d[j] -= nums_possible\\n            # while all(j in d and d[j] > 0 for j in ls[i]):\\n            #     ans += str(i)\\n            #     for j in ls[i]:\\n            #         d[j] -= 1\\n\\n        return \\'\\'.join(sorted(ans))\\n```\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        d = {}\\n        for i in s:\\n            d[i] = d.setdefault(i, 0) + 1\\n        ls = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\\n\\n\\n        ans = \\'\\'\\n        counts = [0 for i in range(0, 10)]\\n        \\n        for i in [0, 2, 4, 6, 7, 5, 3, 8, 9, 1]:\\n            if all(j in d and d[j] > 0 for j in ls[i]):\\n                nums_possible = min(d[j] for j in ls[i])\\n                for j in ls[i]:\\n                    d[j] -= nums_possible\\n                counts[i] = nums_possible\\n        for i in range(10):\\n            ans += str(i)*counts[i]\\n        return ans\\n        # return \\'\\'.join(sorted(ans))\\n```\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        d = {}\\n        for i in s:\\n            d[i] = d.setdefault(i, 0) + 1\\n\\n\\n        ans = \\'\\'\\n        counts = [0 for i in range(0, 10)]\\n        counts[0] = d.setdefault(\\'z\\', 0)\\n        counts[2] = d.setdefault(\\'w\\', 0)\\n        counts[4] = d.setdefault(\\'u\\', 0)\\n        counts[6] = d.setdefault(\\'x\\', 0)\\n        counts[8] = d.setdefault(\\'g\\', 0)\\n        counts[7] = d.setdefault(\\'s\\', 0) - counts[6]\\n        counts[5] = d.setdefault(\\'v\\', 0) - counts[7]\\n        counts[3] = d.setdefault(\\'r\\', 0) - counts[4] - counts[0]\\n        \\n        counts[9] = d.setdefault(\\'i\\', 0) - counts[5] - counts[6] - counts[8]\\n        counts[1] = d.setdefault(\\'o\\', 0) - counts[0] - counts[2] - counts[4]\\n        \\n        for i in range(10):\\n            ans += str(i)*counts[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973297,
                "title": "java-straighforward-using-frequency-tracker",
                "content": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] count = new int[10];\\n        int[] fre = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'z\\') count[0]++;\\n            else if (ch == \\'w\\') count[2]++;\\n            else if (ch == \\'u\\') count[4]++;\\n            else if (ch == \\'x\\') count[6]++;\\n            else if (ch == \\'g\\') count[8]++;\\n            fre[ch - \\'a\\']++;\\n        }\\n        count[1] = fre[\\'o\\' - \\'a\\'] - (count[0] + count[2] + count[4]);\\n        count[3] = fre[\\'h\\' - \\'a\\'] - count[8];\\n        count[5] = fre[\\'f\\' - \\'a\\'] - count[4];\\n        count[7] = fre[\\'s\\' - \\'a\\'] - count[6];\\n        count[9] = fre[\\'i\\' - \\'a\\'] - (count[8] + count[6] + count[5]);\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            ans.append(String.valueOf(i).repeat(Math.max(0, count[i])));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] count = new int[10];\\n        int[] fre = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'z\\') count[0]++;\\n            else if (ch == \\'w\\') count[2]++;\\n            else if (ch == \\'u\\') count[4]++;\\n            else if (ch == \\'x\\') count[6]++;\\n            else if (ch == \\'g\\') count[8]++;\\n            fre[ch - \\'a\\']++;\\n        }\\n        count[1] = fre[\\'o\\' - \\'a\\'] - (count[0] + count[2] + count[4]);\\n        count[3] = fre[\\'h\\' - \\'a\\'] - count[8];\\n        count[5] = fre[\\'f\\' - \\'a\\'] - count[4];\\n        count[7] = fre[\\'s\\' - \\'a\\'] - count[6];\\n        count[9] = fre[\\'i\\' - \\'a\\'] - (count[8] + count[6] + count[5]);\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            ans.append(String.valueOf(i).repeat(Math.max(0, count[i])));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972864,
                "title": "easy-python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        from collections import Counter\\n        maps_l = [{\\'z\\': 0, \"w\": 2, \\'u\\': 4, \"x\": 6, \"g\": 8}, {\\'o\\': 1, \\'t\\':3, \\'f\\': 5, \\'s\\': 7}]\\n        map_d = {0:\\'zero\\', 1: \\'one\\', 2 :\\'two\\', 3: \\'three\\', 4: \\'four\\', 5: \\'five\\', 6: \\'six\\', 7:\\'seven\\', 8:\\'eight\\', 9: \\'nine\\'}\\n        res = []\\n        s = Counter(s)\\n\\n        # appear once\\n        for maps in maps_l:\\n            for l in maps:\\n                while l in s:\\n                    res.append(maps[l])\\n                    word = map_d[maps[l]]\\n                    for w in word:\\n                        s[w] -= 1\\n                        if not s[w]:\\n                            del s[w]\\n        if s:\\n            res += [9 for _ in range(s[\\'e\\'])]\\n\\n        return \\'\\'.join([str(_s) for _s in sorted(res)])\\n                \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        from collections import Counter\\n        maps_l = [{\\'z\\': 0, \"w\": 2, \\'u\\': 4, \"x\": 6, \"g\": 8}, {\\'o\\': 1, \\'t\\':3, \\'f\\': 5, \\'s\\': 7}]\\n        map_d = {0:\\'zero\\', 1: \\'one\\', 2 :\\'two\\', 3: \\'three\\', 4: \\'four\\', 5: \\'five\\', 6: \\'six\\', 7:\\'seven\\', 8:\\'eight\\', 9: \\'nine\\'}\\n        res = []\\n        s = Counter(s)\\n\\n        # appear once\\n        for maps in maps_l:\\n            for l in maps:\\n                while l in s:\\n                    res.append(maps[l])\\n                    word = map_d[maps[l]]\\n                    for w in word:\\n                        s[w] -= 1\\n                        if not s[w]:\\n                            del s[w]\\n        if s:\\n            res += [9 for _ in range(s[\\'e\\'])]\\n\\n        return \\'\\'.join([str(_s) for _s in sorted(res)])\\n                \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872029,
                "title": "c-char-counters-with-removing-unique-step-by-step-73ms-100",
                "content": "In the first stage there are only unique chars to remove from counters (for example \\'z\\' is only occured in \\'zero\\' number). After processing first stage there will be other unique chars in leftovers - second stage. After second stage there will be only one leftover - \\'nine\\'.\\n# Code\\n```\\npublic class Solution\\n{\\n    public string OriginalDigits(string s)\\n    {\\n        var counters = new int[128];\\n\\n        foreach (var ch in s) counters[ch]++;\\n\\n        var steps = new List<(char ch, int digit, string str)>\\n        {\\n            /* first stage */\\n            { (\\'z\\', 0, \"zero\") },\\n            { (\\'w\\', 2, \"two\") },\\n            { (\\'u\\', 4, \"four\") },\\n            { (\\'x\\', 6, \"six\") },\\n            { (\\'g\\', 8, \"eight\") },\\n            /* second stage */\\n            { (\\'o\\', 1, \"one\") },\\n            { (\\'t\\', 3, \"three\") },\\n            { (\\'f\\', 5, \"five\") },\\n            { (\\'s\\', 7, \"seven\") },\\n            /* third stage */\\n            { (\\'i\\', 9, \"nine\") }\\n        };\\n\\n        var digitsCounters = new int[10];\\n\\n        foreach (var step in steps)\\n        {\\n            if (counters[step.ch] == 0) continue;\\n\\n            digitsCounters[step.digit] = counters[step.ch];\\n\\n            foreach (var ch in step.str)\\n                counters[ch] -= digitsCounters[step.digit];\\n        }\\n\\n        var sb = new StringBuilder();\\n\\n        for (var i = 0; i < 10; i++)\\n            sb.Append((char)(\\'0\\' + i), digitsCounters[i]);\\n\\n        return sb.ToString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string OriginalDigits(string s)\\n    {\\n        var counters = new int[128];\\n\\n        foreach (var ch in s) counters[ch]++;\\n\\n        var steps = new List<(char ch, int digit, string str)>\\n        {\\n            /* first stage */\\n            { (\\'z\\', 0, \"zero\") },\\n            { (\\'w\\', 2, \"two\") },\\n            { (\\'u\\', 4, \"four\") },\\n            { (\\'x\\', 6, \"six\") },\\n            { (\\'g\\', 8, \"eight\") },\\n            /* second stage */\\n            { (\\'o\\', 1, \"one\") },\\n            { (\\'t\\', 3, \"three\") },\\n            { (\\'f\\', 5, \"five\") },\\n            { (\\'s\\', 7, \"seven\") },\\n            /* third stage */\\n            { (\\'i\\', 9, \"nine\") }\\n        };\\n\\n        var digitsCounters = new int[10];\\n\\n        foreach (var step in steps)\\n        {\\n            if (counters[step.ch] == 0) continue;\\n\\n            digitsCounters[step.digit] = counters[step.ch];\\n\\n            foreach (var ch in step.str)\\n                counters[ch] -= digitsCounters[step.digit];\\n        }\\n\\n        var sb = new StringBuilder();\\n\\n        for (var i = 0; i < 10; i++)\\n            sb.Append((char)(\\'0\\' + i), digitsCounters[i]);\\n\\n        return sb.ToString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789918,
                "title": "c-intuitive-explanation-two-passes-beats-66",
                "content": "# Intuition\\nEach even number has a unique letter to identify itself. First find out the counts of the even numbers, and remove them from the string. Then what is left should belong to odd numbers. We can now use unique identifiers for odd numbers as well. Since even numbers are removed, what is left must belong to odd numbers.\\n# Approach\\nFirst pass: Find out even number counts.\\nSecond pass: Find out odd number counts.\\n# Complexity\\n- Time complexity:\\nO(N) where N is length of string.\\n\\n- Space complexity:\\nO(N) where N is length of string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        string texts[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\n        char uniq_ids[] = {\\'z\\', \\'o\\', \\'w\\', \\'h\\', \\'u\\', \\'f\\', \\'x\\', \\'s\\', \\'g\\', \\'i\\'};\\n\\n        unordered_map<int, int>counter;\\n        unordered_map<char, int>charmap;\\n        \\n        for(char ch: s){\\n            charmap[ch]++;\\n        }\\n\\n        for(int i=0;i<10;i+=2){\\n            char uid = uniq_ids[i];\\n            counter[i] = charmap[uid];\\n            for(char ch: texts[i]){\\n                charmap[ch] -= counter[i];\\n            }\\n        }\\n\\n        for(int i=1;i<10;i+=2){\\n            char uid = uniq_ids[i];\\n            counter[i] += charmap[uid];\\n            for(char ch: texts[i]){\\n                charmap[ch] -= counter[i];\\n            }\\n        }\\n\\n        string str;\\n\\n        for(int i=0;i<10;i++){\\n            int cnt=counter[i];\\n            while(cnt){\\n                str.push_back(\\'0\\'+i);\\n                cnt--;\\n            }\\n        }\\n\\n        return str;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        string texts[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\\n\\n        char uniq_ids[] = {\\'z\\', \\'o\\', \\'w\\', \\'h\\', \\'u\\', \\'f\\', \\'x\\', \\'s\\', \\'g\\', \\'i\\'};\\n\\n        unordered_map<int, int>counter;\\n        unordered_map<char, int>charmap;\\n        \\n        for(char ch: s){\\n            charmap[ch]++;\\n        }\\n\\n        for(int i=0;i<10;i+=2){\\n            char uid = uniq_ids[i];\\n            counter[i] = charmap[uid];\\n            for(char ch: texts[i]){\\n                charmap[ch] -= counter[i];\\n            }\\n        }\\n\\n        for(int i=1;i<10;i+=2){\\n            char uid = uniq_ids[i];\\n            counter[i] += charmap[uid];\\n            for(char ch: texts[i]){\\n                charmap[ch] -= counter[i];\\n            }\\n        }\\n\\n        string str;\\n\\n        for(int i=0;i<10;i++){\\n            int cnt=counter[i];\\n            while(cnt){\\n                str.push_back(\\'0\\'+i);\\n                cnt--;\\n            }\\n        }\\n\\n        return str;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766125,
                "title": "python3-counter-and-dictionary-85-and-75-less-than-20-lines-of-code",
                "content": "# Intuition\\nOn finding the count of each digits, we can find the required string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIntially, we find the count of each letter in the string `s` using Counter() which `letters`. Then, we calculate the no. of digits present using the counter in `digits` dictionary.\\n\\nNote: \\nThe even digits has unique characters which are not present in other digits:\\n```\\n0 - \\'z\\'\\n2 - \\'w\\'\\n4 - \\'u\\'\\n6 - \\'x\\'\\n8 - \\'g\\'\\n```\\nSo, the count of these digits is simply the count of the corresponding characters. Store their count in `digits`.\\n\\nWe are left with digits 1, 3, 5, 7, 9\\n\\nThe characters unique to these alone:\\n```\\n1 - \\'o\\'\\n3 - \\'r\\'\\n5 - \\'f\\'\\n7 - \\'s\\'\\n```\\nSo, the count of these digits is the difference between count of the corresponding characters and the sum of count of each of the even digits that contain those characters.\\n(i.e.)\\n0, 2 and 4 has letter \\'o\\' in them and thus\\n`count of 1 = letters[\\'o\\'] - digits[\\'0\\'] - digits[\\'2\\'] - digits[\\'4\\']`\\n\\n0, 4 has letter \\'r\\' in them and thus\\n`count of 3 = letters[\\'r\\'] - digits[\\'0\\'] - digits[\\'4\\']`\\n\\n4 has letter \\'f\\' in it and thus\\n`count of 5 = letters[\\'f\\'] - digits[\\'4\\']`\\n\\n6 has letter \\'s\\' in it and thus\\n`count of 7 = letters[\\'s\\'] - digits[\\'6\\']`\\n\\nFinally,\\n`count of 9 = letters[\\'n\\'] - digits[\\'7\\'] - digits[\\'1]`\\n\\nOn storing these values in `digits`, we can form the required string using for loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nFor creating Counter object O(n) and O(1) for others\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        letters = Counter(s)\\n        digits = defaultdict(int)\\n        answer = \"\"\\n\\n        digits[\\'0\\'] = letters[\\'z\\']\\n        digits[\\'2\\'] = letters[\\'w\\']\\n        digits[\\'4\\'] = letters[\\'u\\']\\n        digits[\\'6\\'] = letters[\\'x\\']\\n        digits[\\'8\\'] = letters[\\'g\\']\\n        \\n        digits[\\'1\\'] = letters[\\'o\\'] - (digits[\\'0\\'] + digits[\\'2\\'] + digits[\\'4\\'])\\n        digits[\\'3\\'] = letters[\\'r\\'] - (digits[\\'0\\'] + digits[\\'4\\'])\\n        digits[\\'5\\'] = letters[\\'f\\'] - digits[\\'4\\']\\n        digits[\\'7\\'] = letters[\\'s\\'] - digits[\\'6\\']\\n        digits[\\'9\\'] = (letters[\\'n\\'] - digits[\\'7\\'] - digits[\\'1\\']) // 2\\n\\n        for ch in \"0123456789\":\\n            answer += ch * digits[ch]\\n\\n        return answer\\n```\\n\\n# Upvote if it was helpful",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\n0 - \\'z\\'\\n2 - \\'w\\'\\n4 - \\'u\\'\\n6 - \\'x\\'\\n8 - \\'g\\'\\n```\n```\\n1 - \\'o\\'\\n3 - \\'r\\'\\n5 - \\'f\\'\\n7 - \\'s\\'\\n```\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        letters = Counter(s)\\n        digits = defaultdict(int)\\n        answer = \"\"\\n\\n        digits[\\'0\\'] = letters[\\'z\\']\\n        digits[\\'2\\'] = letters[\\'w\\']\\n        digits[\\'4\\'] = letters[\\'u\\']\\n        digits[\\'6\\'] = letters[\\'x\\']\\n        digits[\\'8\\'] = letters[\\'g\\']\\n        \\n        digits[\\'1\\'] = letters[\\'o\\'] - (digits[\\'0\\'] + digits[\\'2\\'] + digits[\\'4\\'])\\n        digits[\\'3\\'] = letters[\\'r\\'] - (digits[\\'0\\'] + digits[\\'4\\'])\\n        digits[\\'5\\'] = letters[\\'f\\'] - digits[\\'4\\']\\n        digits[\\'7\\'] = letters[\\'s\\'] - digits[\\'6\\']\\n        digits[\\'9\\'] = (letters[\\'n\\'] - digits[\\'7\\'] - digits[\\'1\\']) // 2\\n\\n        for ch in \"0123456789\":\\n            answer += ch * digits[ch]\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759739,
                "title": "beats-100-here-language-doesn-t-matter-lmao-solution",
                "content": "# Intuition\\nThis is as straight forward as this gets. Lmao\\n\\n# Approach\\nxD\\n\\n# Complexity\\n- Time complexity:\\nO(n log(n))\\nBecause of the sorting.\\n\\n- Space complexity:\\nO(n) \\nBecause of the vector.\\nMap takes constant space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        \\n        unordered_map<char, int> mp ;\\n\\n        for(auto ch : s) mp[ch]++ ;\\n\\n        vector<char> v ;\\n\\n        while(mp[\\'z\\'] != 0){\\n            mp[\\'z\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'r\\']-- ;\\n            mp[\\'o\\']-- ;\\n            v.push_back(\\'0\\') ;\\n        }\\n\\n        while(mp[\\'w\\'] != 0){\\n            mp[\\'t\\']-- ;\\n            mp[\\'w\\']-- ;\\n            //mp[\\'r\\']-- ;\\n            mp[\\'o\\']-- ;\\n            v.push_back(\\'2\\') ;\\n        }\\n\\n        while(mp[\\'u\\'] != 0){\\n            mp[\\'f\\']-- ;\\n            mp[\\'u\\']-- ;\\n            mp[\\'r\\']-- ;\\n            mp[\\'o\\']-- ;\\n            v.push_back(\\'4\\') ;\\n        }\\n\\n        while(mp[\\'x\\'] != 0){\\n            mp[\\'s\\']-- ;\\n            mp[\\'i\\']-- ;\\n            mp[\\'x\\']-- ;\\n            //mp[\\'o\\']-- ;\\n            v.push_back(\\'6\\') ;\\n        }\\n\\n        while(mp[\\'g\\'] != 0){\\n            mp[\\'i\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'h\\']-- ;\\n            mp[\\'t\\']-- ;\\n            mp[\\'g\\']-- ;\\n            v.push_back(\\'8\\') ;\\n        }\\n\\n\\n        while(mp[\\'h\\'] != 0){\\n            mp[\\'t\\']-- ;\\n            mp[\\'r\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'h\\']-- ;\\n            v.push_back(\\'3\\') ;\\n        }\\n\\n        while(mp[\\'o\\'] != 0){\\n            mp[\\'n\\']-- ;\\n            mp[\\'e\\']-- ;\\n            //mp[\\'r\\']-- ;\\n            mp[\\'o\\']-- ;\\n            v.push_back(\\'1\\') ;\\n        }\\n\\n        while(mp[\\'f\\'] != 0){\\n            mp[\\'f\\']-- ;\\n            mp[\\'i\\']-- ;\\n            mp[\\'v\\']-- ;\\n            mp[\\'e\\']-- ;\\n            v.push_back(\\'5\\') ;\\n        }\\n\\n        while(mp[\\'v\\'] != 0){\\n            mp[\\'s\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'v\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'n\\']-- ;\\n            v.push_back(\\'7\\') ;\\n        }\\n\\n        while(mp[\\'i\\'] != 0){\\n            mp[\\'n\\']-- ;\\n            mp[\\'i\\']-- ;\\n            mp[\\'n\\']-- ;\\n            mp[\\'e\\']-- ;\\n            //mp[\\'n\\']-- ;\\n            v.push_back(\\'9\\') ;\\n        }\\n\\n        sort(v.begin(), v.end()) ;\\n\\n        string res = \"\" ;\\n\\n        for(auto ch : v) res += ch ;\\n\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        \\n        unordered_map<char, int> mp ;\\n\\n        for(auto ch : s) mp[ch]++ ;\\n\\n        vector<char> v ;\\n\\n        while(mp[\\'z\\'] != 0){\\n            mp[\\'z\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'r\\']-- ;\\n            mp[\\'o\\']-- ;\\n            v.push_back(\\'0\\') ;\\n        }\\n\\n        while(mp[\\'w\\'] != 0){\\n            mp[\\'t\\']-- ;\\n            mp[\\'w\\']-- ;\\n            //mp[\\'r\\']-- ;\\n            mp[\\'o\\']-- ;\\n            v.push_back(\\'2\\') ;\\n        }\\n\\n        while(mp[\\'u\\'] != 0){\\n            mp[\\'f\\']-- ;\\n            mp[\\'u\\']-- ;\\n            mp[\\'r\\']-- ;\\n            mp[\\'o\\']-- ;\\n            v.push_back(\\'4\\') ;\\n        }\\n\\n        while(mp[\\'x\\'] != 0){\\n            mp[\\'s\\']-- ;\\n            mp[\\'i\\']-- ;\\n            mp[\\'x\\']-- ;\\n            //mp[\\'o\\']-- ;\\n            v.push_back(\\'6\\') ;\\n        }\\n\\n        while(mp[\\'g\\'] != 0){\\n            mp[\\'i\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'h\\']-- ;\\n            mp[\\'t\\']-- ;\\n            mp[\\'g\\']-- ;\\n            v.push_back(\\'8\\') ;\\n        }\\n\\n\\n        while(mp[\\'h\\'] != 0){\\n            mp[\\'t\\']-- ;\\n            mp[\\'r\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'h\\']-- ;\\n            v.push_back(\\'3\\') ;\\n        }\\n\\n        while(mp[\\'o\\'] != 0){\\n            mp[\\'n\\']-- ;\\n            mp[\\'e\\']-- ;\\n            //mp[\\'r\\']-- ;\\n            mp[\\'o\\']-- ;\\n            v.push_back(\\'1\\') ;\\n        }\\n\\n        while(mp[\\'f\\'] != 0){\\n            mp[\\'f\\']-- ;\\n            mp[\\'i\\']-- ;\\n            mp[\\'v\\']-- ;\\n            mp[\\'e\\']-- ;\\n            v.push_back(\\'5\\') ;\\n        }\\n\\n        while(mp[\\'v\\'] != 0){\\n            mp[\\'s\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'v\\']-- ;\\n            mp[\\'e\\']-- ;\\n            mp[\\'n\\']-- ;\\n            v.push_back(\\'7\\') ;\\n        }\\n\\n        while(mp[\\'i\\'] != 0){\\n            mp[\\'n\\']-- ;\\n            mp[\\'i\\']-- ;\\n            mp[\\'n\\']-- ;\\n            mp[\\'e\\']-- ;\\n            //mp[\\'n\\']-- ;\\n            v.push_back(\\'9\\') ;\\n        }\\n\\n        sort(v.begin(), v.end()) ;\\n\\n        string res = \"\" ;\\n\\n        for(auto ch : v) res += ch ;\\n\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755573,
                "title": "simple-solution-with-explanation",
                "content": "# Intuition\\nWe use unique characters in string representation of digits.\\n\\n# Approach\\nWe count all characters in the string. Then we arrange digits according to unique characters in their string representation.\\nFirstly we have ```(\\'one\\', \\'two\\', \\'three\\', \\'four\\', \\'five\\', \\'six\\', \\'seven\\', \\'eight\\', \\'nine\\', \\'ten\\')```. We notice that ```(\\'Zero\\', \\'tWo\\', \\'foUr\\', \\'siX\\', \\'eiGht\\')``` have unique characters (```ZWUXG``` respectively), so we process them first. Then we have ```(\\'One\\', \\'tHree\\', \\'Five\\', \\'Seven\\')``` with unique characters (```OHFS``` respectively). Eventually one digit ```\\'nine\\'``` is left.\\nSo, all we need - to process digits according to the aforementioned order.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        digChs = ((0, \\'zero\\'), (2, \\'two\\'), (4, \\'four\\'), (6, \\'six\\'), (8, \\'eight\\'),  \\n                  (1, \\'one\\'), (3, \\'three\\'), (5, \\'five\\'), (7, \\'seven\\'),  (9, \\'nine\\'))\\n        cntrCh = Counter(s)\\n        cntrDig = [0]*10\\n        for dig, digCh in digChs:\\n            found = True\\n            while found:\\n                for ch in digCh:\\n                    if cntrCh[ch] == 0:\\n                        found = False\\n                        break\\n            \\n                if found:\\n                    cntrDig[dig] += 1\\n                    for ch in digCh:\\n                        cntrCh[ch] -= 1\\n        \\n        return \\'\\'.join(f\\'{dig}\\'*cntr for dig, cntr in enumerate(cntrDig))\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```(\\'one\\', \\'two\\', \\'three\\', \\'four\\', \\'five\\', \\'six\\', \\'seven\\', \\'eight\\', \\'nine\\', \\'ten\\')```\n```(\\'Zero\\', \\'tWo\\', \\'foUr\\', \\'siX\\', \\'eiGht\\')```\n```ZWUXG```\n```(\\'One\\', \\'tHree\\', \\'Five\\', \\'Seven\\')```\n```OHFS```\n```\\'nine\\'```\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        digChs = ((0, \\'zero\\'), (2, \\'two\\'), (4, \\'four\\'), (6, \\'six\\'), (8, \\'eight\\'),  \\n                  (1, \\'one\\'), (3, \\'three\\'), (5, \\'five\\'), (7, \\'seven\\'),  (9, \\'nine\\'))\\n        cntrCh = Counter(s)\\n        cntrDig = [0]*10\\n        for dig, digCh in digChs:\\n            found = True\\n            while found:\\n                for ch in digCh:\\n                    if cntrCh[ch] == 0:\\n                        found = False\\n                        break\\n            \\n                if found:\\n                    cntrDig[dig] += 1\\n                    for ch in digCh:\\n                        cntrCh[ch] -= 1\\n        \\n        return \\'\\'.join(f\\'{dig}\\'*cntr for dig, cntr in enumerate(cntrDig))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739550,
                "title": "best-solution-in-java-runtime-6ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String originalDigits(String s) {\\n    int[] count = new int[26]; // Array to store the frequency of each character\\n    char[] chars = s.toCharArray();\\n\\n    // Count the frequency of each character in the input string\\n    for (char c : chars) {\\n        count[c - \\'a\\']++;\\n    }\\n\\n    int[] digitCount = new int[10]; // Array to store the frequency of each digit\\n    // Identify the unique characters present in each digit\\'s English representation\\n    digitCount[0] = count[\\'z\\' - \\'a\\'];\\n    digitCount[2] = count[\\'w\\' - \\'a\\'];\\n    digitCount[4] = count[\\'u\\' - \\'a\\'];\\n    digitCount[6] = count[\\'x\\' - \\'a\\'];\\n    digitCount[8] = count[\\'g\\' - \\'a\\'];\\n    digitCount[3] = count[\\'h\\' - \\'a\\'] - digitCount[8];\\n    digitCount[5] = count[\\'f\\' - \\'a\\'] - digitCount[4];\\n    digitCount[7] = count[\\'s\\' - \\'a\\'] - digitCount[6];\\n    digitCount[9] = count[\\'i\\' - \\'a\\'] - digitCount[5] - digitCount[6] - digitCount[8];\\n    digitCount[1] = count[\\'o\\' - \\'a\\'] - digitCount[0] - digitCount[2] - digitCount[4];\\n\\n    StringBuilder result = new StringBuilder();\\n    // Build the resulting string by appending the digits in ascending order based on their frequency\\n    for (int i = 0; i < 10; i++) {\\n        for (int j = 0; j < digitCount[i]; j++) {\\n            result.append(i);\\n        }\\n    }\\n    return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n    int[] count = new int[26]; // Array to store the frequency of each character\\n    char[] chars = s.toCharArray();\\n\\n    // Count the frequency of each character in the input string\\n    for (char c : chars) {\\n        count[c - \\'a\\']++;\\n    }\\n\\n    int[] digitCount = new int[10]; // Array to store the frequency of each digit\\n    // Identify the unique characters present in each digit\\'s English representation\\n    digitCount[0] = count[\\'z\\' - \\'a\\'];\\n    digitCount[2] = count[\\'w\\' - \\'a\\'];\\n    digitCount[4] = count[\\'u\\' - \\'a\\'];\\n    digitCount[6] = count[\\'x\\' - \\'a\\'];\\n    digitCount[8] = count[\\'g\\' - \\'a\\'];\\n    digitCount[3] = count[\\'h\\' - \\'a\\'] - digitCount[8];\\n    digitCount[5] = count[\\'f\\' - \\'a\\'] - digitCount[4];\\n    digitCount[7] = count[\\'s\\' - \\'a\\'] - digitCount[6];\\n    digitCount[9] = count[\\'i\\' - \\'a\\'] - digitCount[5] - digitCount[6] - digitCount[8];\\n    digitCount[1] = count[\\'o\\' - \\'a\\'] - digitCount[0] - digitCount[2] - digitCount[4];\\n\\n    StringBuilder result = new StringBuilder();\\n    // Build the resulting string by appending the digits in ascending order based on their frequency\\n    for (int i = 0; i < 10; i++) {\\n        for (int j = 0; j < digitCount[i]; j++) {\\n            result.append(i);\\n        }\\n    }\\n    return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717053,
                "title": "straightforward-java-solution",
                "content": "# Approach\\nNumbers 0, 2, 4, 6, 8 have one letter unqiue in each, and for the rest we can create linear combinations among these andd other numbers using frequencies of other letters.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] rescount = new int[10];\\n        int[] freqs = new int[26];\\n        for(char ch: s.toCharArray()) freqs[ch-\\'a\\']++;\\n        rescount[0] = freqs[25];\\n        rescount[2] = freqs[22];\\n        rescount[8] = freqs[6];\\n        rescount[6] = freqs[23];\\n        rescount[4] = freqs[20];\\n        rescount[5] = freqs[5] - rescount[4];\\n        rescount[1] = freqs[14] - rescount[0] - rescount[2]-rescount[4];\\n        rescount[7] = freqs[18] - rescount[6];\\n        rescount[9] = freqs[8] - rescount[8]-rescount[6]-rescount[5];\\n        rescount[3] = freqs[19] - rescount[2] - rescount[8];\\n        String res = \"\";\\n        // System.out.println(Arrays.toString(freqs));\\n        // System.out.println(Arrays.toString(rescount));\\n        for(int i=0;i<10;i++){\\n            if(rescount[i] > 0){\\n                res += (Integer.toString(i).repeat(rescount[i]));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String originalDigits(String s) {\\n        int[] rescount = new int[10];\\n        int[] freqs = new int[26];\\n        for(char ch: s.toCharArray()) freqs[ch-\\'a\\']++;\\n        rescount[0] = freqs[25];\\n        rescount[2] = freqs[22];\\n        rescount[8] = freqs[6];\\n        rescount[6] = freqs[23];\\n        rescount[4] = freqs[20];\\n        rescount[5] = freqs[5] - rescount[4];\\n        rescount[1] = freqs[14] - rescount[0] - rescount[2]-rescount[4];\\n        rescount[7] = freqs[18] - rescount[6];\\n        rescount[9] = freqs[8] - rescount[8]-rescount[6]-rescount[5];\\n        rescount[3] = freqs[19] - rescount[2] - rescount[8];\\n        String res = \"\";\\n        // System.out.println(Arrays.toString(freqs));\\n        // System.out.println(Arrays.toString(rescount));\\n        for(int i=0;i<10;i++){\\n            if(rescount[i] > 0){\\n                res += (Integer.toString(i).repeat(rescount[i]));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679819,
                "title": "c-optimized-code-with-easy-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEliminate one by one digit with it\\'s unique letter.\\n(ex. 0 -> \\'z\\', 2 -> \\'w\\', 4 -> \\'u\\', 6 -> \\'x\\', 8 -> \\'g\\')\\nafter eliminate those we have a new unique key among remaining\\n(ex. 1 -> \\'o\\', 3 -> \\'h\\' or \\'r\\', 5 -> \\'f\\', 7 -> \\'s\\')\\nand then remain \\'9\\' only\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n\\n        // Store frequencies of each letter\\n        unordered_map<char, int> mpp;\\n        for(auto i : s)\\n            mpp[i]++;\\n\\n        vector<int> v(10);  // Store frequency of digits\\n\\n        // Eliminate all 0(\\'zero\\') according to frequency of \\'z\\'\\n        int count = mpp[\\'z\\'];\\n        v[0] = count;\\n        for(auto i : \"zero\")\\n            mpp[i] -= count;\\n\\n        // Eliminate all 2(\\'two\\') according to frequency of \\'w\\'\\n        count = mpp[\\'w\\'];\\n        v[2] = count;\\n        for(auto i : \"two\")\\n            mpp[i] -= count;\\n\\n        // Eliminate all 4(\\'four\\') according to frequency of \\'u\\'\\n        count = mpp[\\'u\\'];\\n        v[4] = count;\\n        for(auto i : \"four\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 5(\\'five\\') according to frequency of \\'f\\'\\n        count = mpp[\\'f\\'];\\n        v[5] = count;\\n        for(auto i : \"five\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 6(\\'six\\') according to frequency of \\'x\\'\\n        count = mpp[\\'x\\'];\\n        v[6] = count;\\n        for(auto i : \"six\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 7(\\'seven\\') according to frequency of \\'v\\'\\n        count = mpp[\\'v\\'];\\n        v[7] = count;\\n        for(auto i : \"seven\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 8(\\'eight\\') according to frequency of \\'g\\'\\n        count = mpp[\\'g\\'];\\n        v[8] = count;\\n        for(auto i : \"eight\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 9(\\'nine\\') according to frequency of \\'i\\'\\n        count = mpp[\\'i\\'];\\n        v[9] = count;\\n        for(auto i : \"nine\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 1(\\'one\\') according to frequency of \\'o\\'\\n        count = mpp[\\'o\\'];\\n        v[1] = count;\\n        for(auto i : \"one\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 3(\\'three\\') according to frequency of \\'h\\'\\n        count = mpp[\\'h\\'];\\n        v[3] = count;\\n        for(auto i : \"three\")\\n            mpp[i] -= count;\\n        \\n        // Concatanate all digits in ascending order\\n        s = \"\";\\n        for(int i = 0; i < 10; i++) {\\n            while(v[i]--)\\n                s.push_back(48 + i);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n\\n        // Store frequencies of each letter\\n        unordered_map<char, int> mpp;\\n        for(auto i : s)\\n            mpp[i]++;\\n\\n        vector<int> v(10);  // Store frequency of digits\\n\\n        // Eliminate all 0(\\'zero\\') according to frequency of \\'z\\'\\n        int count = mpp[\\'z\\'];\\n        v[0] = count;\\n        for(auto i : \"zero\")\\n            mpp[i] -= count;\\n\\n        // Eliminate all 2(\\'two\\') according to frequency of \\'w\\'\\n        count = mpp[\\'w\\'];\\n        v[2] = count;\\n        for(auto i : \"two\")\\n            mpp[i] -= count;\\n\\n        // Eliminate all 4(\\'four\\') according to frequency of \\'u\\'\\n        count = mpp[\\'u\\'];\\n        v[4] = count;\\n        for(auto i : \"four\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 5(\\'five\\') according to frequency of \\'f\\'\\n        count = mpp[\\'f\\'];\\n        v[5] = count;\\n        for(auto i : \"five\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 6(\\'six\\') according to frequency of \\'x\\'\\n        count = mpp[\\'x\\'];\\n        v[6] = count;\\n        for(auto i : \"six\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 7(\\'seven\\') according to frequency of \\'v\\'\\n        count = mpp[\\'v\\'];\\n        v[7] = count;\\n        for(auto i : \"seven\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 8(\\'eight\\') according to frequency of \\'g\\'\\n        count = mpp[\\'g\\'];\\n        v[8] = count;\\n        for(auto i : \"eight\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 9(\\'nine\\') according to frequency of \\'i\\'\\n        count = mpp[\\'i\\'];\\n        v[9] = count;\\n        for(auto i : \"nine\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 1(\\'one\\') according to frequency of \\'o\\'\\n        count = mpp[\\'o\\'];\\n        v[1] = count;\\n        for(auto i : \"one\")\\n            mpp[i] -= count;\\n        \\n        // Eliminate all 3(\\'three\\') according to frequency of \\'h\\'\\n        count = mpp[\\'h\\'];\\n        v[3] = count;\\n        for(auto i : \"three\")\\n            mpp[i] -= count;\\n        \\n        // Concatanate all digits in ascending order\\n        s = \"\";\\n        for(int i = 0; i < 10; i++) {\\n            while(v[i]--)\\n                s.push_back(48 + i);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672596,
                "title": "c-unique-character-mappings-single-pass",
                "content": "```\\nclass Solution {\\n  // k*s = (k/2)*s + (k/2)*s (+ s if k is odd)\\n  // 0*s = \"\"\\n  string multiplyString(string_view s, int k) {\\n    if (k == 0) return \"\";\\n    if (k == 1) return string(s.data(), s.size());\\n    \\n    string res = multiplyString(s, k >> 1);\\n    res += res;\\n    if (k & 1)\\n      res += multiplyString(s, 1);\\n    return res;\\n  }\\npublic:\\n    string originalDigits(string_view s) {\\n      string res;\\n      \\n      // Get the letter frequency of s\\n      vector<int> freq(26);\\n      for (char c : s) freq[c-\\'a\\']++;\\n      \\n      // Each entry uniquely defines a digit -> if there are 4 \\'z\\' then there must also be at least 4 \\'e\\',\\'r\\', and \\'o\\'.\\n      // The order is important!\\n      // i.e. \\'o\\' for \"one\" is unique as we have already processed \"zero\", \"two\", and \"four\" hence \\'o\\' is now unique \\n      // among the remainging letters for unprocessed digits.\\n      static const vector<pair<string_view, pair<char, string_view>>> mp = {\\n        {\"0\", {\\'z\\', \"zero\" }},\\n        {\"2\", {\\'w\\', \"two\"  }},\\n        {\"4\", {\\'u\\', \"four\" }},\\n        {\"6\", {\\'x\\', \"six\"  }},\\n        {\"8\", {\\'g\\', \"eight\"}},\\n        {\"1\", {\\'o\\', \"one\"  }},\\n        {\"3\", {\\'h\\', \"three\"}},\\n        {\"5\", {\\'f\\', \"five\" }},\\n        {\"7\", {\\'s\\', \"seven\"}},\\n        {\"9\", {\\'i\\', \"nine\" }},\\n      };\\n      // For every entry in the digit mapping add all occurrences into result\\n      for (int i = 0; i <= 9; i++) {\\n        string_view d = mp[i].first;\\n        auto [ch, digit] = mp[i].second;\\n        // ch is the unique character that determines the number of times a digit occurs.\\n        int num_times = freq[ch-\\'a\\'];\\n        if (num_times == 0) continue;\\n        // Remove all the occurrences of the characters of digit from the frequency count\\n        for (auto c : digit)\\n          freq[c-\\'a\\'] -= num_times;\\n        // Add num_times copies of d to result\\n        res += multiplyString(d, num_times);\\n      }\\n      // Order the digits in ascending order\\n      sort(res.begin(), res.end());\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  // k*s = (k/2)*s + (k/2)*s (+ s if k is odd)\\n  // 0*s = \"\"\\n  string multiplyString(string_view s, int k) {\\n    if (k == 0) return \"\";\\n    if (k == 1) return string(s.data(), s.size());\\n    \\n    string res = multiplyString(s, k >> 1);\\n    res += res;\\n    if (k & 1)\\n      res += multiplyString(s, 1);\\n    return res;\\n  }\\npublic:\\n    string originalDigits(string_view s) {\\n      string res;\\n      \\n      // Get the letter frequency of s\\n      vector<int> freq(26);\\n      for (char c : s) freq[c-\\'a\\']++;\\n      \\n      // Each entry uniquely defines a digit -> if there are 4 \\'z\\' then there must also be at least 4 \\'e\\',\\'r\\', and \\'o\\'.\\n      // The order is important!\\n      // i.e. \\'o\\' for \"one\" is unique as we have already processed \"zero\", \"two\", and \"four\" hence \\'o\\' is now unique \\n      // among the remainging letters for unprocessed digits.\\n      static const vector<pair<string_view, pair<char, string_view>>> mp = {\\n        {\"0\", {\\'z\\', \"zero\" }},\\n        {\"2\", {\\'w\\', \"two\"  }},\\n        {\"4\", {\\'u\\', \"four\" }},\\n        {\"6\", {\\'x\\', \"six\"  }},\\n        {\"8\", {\\'g\\', \"eight\"}},\\n        {\"1\", {\\'o\\', \"one\"  }},\\n        {\"3\", {\\'h\\', \"three\"}},\\n        {\"5\", {\\'f\\', \"five\" }},\\n        {\"7\", {\\'s\\', \"seven\"}},\\n        {\"9\", {\\'i\\', \"nine\" }},\\n      };\\n      // For every entry in the digit mapping add all occurrences into result\\n      for (int i = 0; i <= 9; i++) {\\n        string_view d = mp[i].first;\\n        auto [ch, digit] = mp[i].second;\\n        // ch is the unique character that determines the number of times a digit occurs.\\n        int num_times = freq[ch-\\'a\\'];\\n        if (num_times == 0) continue;\\n        // Remove all the occurrences of the characters of digit from the frequency count\\n        for (auto c : digit)\\n          freq[c-\\'a\\'] -= num_times;\\n        // Add num_times copies of d to result\\n        res += multiplyString(d, num_times);\\n      }\\n      // Order the digits in ascending order\\n      sort(res.begin(), res.end());\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670317,
                "title": "c-interesting-approach-using-map-full-explanation-brain-teaser",
                "content": "# Intuition\\nThis approach described here is more of a simple brain-teaser and is not too heavy on algorithms. I have simply gathered clues in each step from the number of letters in the string and proceeded to determine the digits.\\nFirstly, take a good look on each of the digits in the decimal number system **(0-9)** and their string representation in words. The `construct` function is as simple as it gets. What matters is the order in which I have called it for different digits.\\n\\n### For the Even Digits:\\nThe even digits i.e. 0,2,4,6 and 8 each have at least one unique character that can directly confirm their presence and frequency of occurrence in the jumbled string.\\n\\n- **For 0 (\"zero\") it is \\'z\\'**. The presence of any $$n$$ z\\'s in the jumbled string confirms the presence of $$n$$ 0\\'s.\\n- **For 2 (\"two\") it is \\'w\\'**. The presence of any $$n$$ w\\'s in the jumbled string confirms the presence of $$n$$ 2\\'s.\\n- **For 4 (\"four\") it is \\'u\\'**. The presence of any $$n$$ u\\'s in the jumbled string confirms the presence of $$n$$ 4\\'s.\\n- **For 6 (\"six\") it is \\'x\\'**. The presence of any $$n$$ x\\'s in the jumbled string confirms the presence of $$n$$ 6\\'s.\\n- **For 8 (\"eight\") it is \\'g\\'**. The presence of any $$n$$ g\\'s in the jumbled string confirms the presence of $$n$$ 8\\'s.\\n\\n### For the Odd Digits: \\nThese did not have exclusively unique characters for themselves, but now that sufficient characters have been eliminated and will be eliminated further, the remaining characters will be successively rendered unique for each digit.\\n\\n- **For 3 (\"three\") it is \\'t\\'**. Since eigh**t** and **t**wo have already been eliminated, the presence of any remaining $$n$$ t\\'s in the jumbled string confirms the presence of $$n$$ 3\\'s.\\n- **For 5 (\"five\") it is \\'f\\'**. Since **f**our has already been eliminated, the presence of any remaining $$n$$ f\\'s in the jumbled string confirms the presence of $$n$$ 5\\'s.\\n- **For 7 (\"seven\") it is \\'v\\'**. Since fi**v**e has already been eliminated, the presence of any remaining $$n$$ v\\'s in the jumbled string confirms the presence of $$n$$ 7\\'s.\\n- **For 9 (\"nine\") it is \\'i\\'**. Since s**i**x, f**i**ve and e**i**ght have already been eliminated, the presence of any remaining $$n$$ i\\'s in the jumbled string confirms the presence of $$n$$ 9\\'s.\\n- **For 1 (\"one\") it is \\'o\\'**. Now that all the other digits have been eliminated, the presence of any remaining $$n$$ o\\'s in the jumbled string confirms the presence of $$n$$ 1\\'s.\\n\\n# Approach\\nThe implementation is quite simple. I have simply used a map `charFreq` to store the frequencies of each character in the jumbled string. The `construct` function helps construct the final string `ans` by addding the required `count` number of digits to it at each call. It also decrements the values for the occurrences in `charFreq` by `count`, which is the number of times each digit occurs in the string. It simply builds `ans` and deletes all the used up characters at every call.\\nThe `construct` function is called for every digit (0-9) in the order that I have specified above in the bullet points. In the end, I have simply used `std::sort` to sort `ans`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void construct(unordered_map<char,int>& charFreq, string num, char dist, string& ans, char digit){\\n        int count=charFreq[dist];\\n        for(char c:num)\\n        charFreq[c]-=count; // decrementing the frequency of used up characters\\n        ans+=string(count,digit); // adding count number of digits to ans\\n    }\\n    string originalDigits(string s) {\\n        unordered_map<char,int> charFreq;\\n        for(char c:s)\\n        charFreq[c]++;\\n        string ans=\"\";\\n        // calling the construct function in the specified order\\n        construct(charFreq,\"zero\",\\'z\\',ans,\\'0\\');\\n        construct(charFreq,\"two\",\\'w\\',ans,\\'2\\');\\n        construct(charFreq,\"four\",\\'u\\',ans,\\'4\\');\\n        construct(charFreq,\"six\",\\'x\\',ans,\\'6\\');\\n        construct(charFreq,\"eight\",\\'g\\',ans,\\'8\\');\\n        construct(charFreq,\"three\",\\'t\\',ans,\\'3\\');\\n        construct(charFreq,\"five\",\\'f\\',ans,\\'5\\');\\n        construct(charFreq,\"seven\",\\'v\\',ans,\\'7\\');\\n        construct(charFreq,\"nine\",\\'i\\',ans,\\'9\\');\\n        ans+=string(charFreq[\\'o\\'],\\'1\\');\\n        // sorting ans\\n        sort(ans.begin(),ans.end());\\n        return(ans);\\n    }\\n};\\n```\\n# P.S.\\nAll sorts of constructive feedback are welcome in the comments. Share and Upvote if helpful.",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void construct(unordered_map<char,int>& charFreq, string num, char dist, string& ans, char digit){\\n        int count=charFreq[dist];\\n        for(char c:num)\\n        charFreq[c]-=count; // decrementing the frequency of used up characters\\n        ans+=string(count,digit); // adding count number of digits to ans\\n    }\\n    string originalDigits(string s) {\\n        unordered_map<char,int> charFreq;\\n        for(char c:s)\\n        charFreq[c]++;\\n        string ans=\"\";\\n        // calling the construct function in the specified order\\n        construct(charFreq,\"zero\",\\'z\\',ans,\\'0\\');\\n        construct(charFreq,\"two\",\\'w\\',ans,\\'2\\');\\n        construct(charFreq,\"four\",\\'u\\',ans,\\'4\\');\\n        construct(charFreq,\"six\",\\'x\\',ans,\\'6\\');\\n        construct(charFreq,\"eight\",\\'g\\',ans,\\'8\\');\\n        construct(charFreq,\"three\",\\'t\\',ans,\\'3\\');\\n        construct(charFreq,\"five\",\\'f\\',ans,\\'5\\');\\n        construct(charFreq,\"seven\",\\'v\\',ans,\\'7\\');\\n        construct(charFreq,\"nine\",\\'i\\',ans,\\'9\\');\\n        ans+=string(charFreq[\\'o\\'],\\'1\\');\\n        // sorting ans\\n        sort(ans.begin(),ans.end());\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638918,
                "title": "very-simple-odd-even-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int>vec(10,0);\\n        vector<int>vect(128,0);\\n        string ans=\"\";\\n        for(auto it:s)\\n        vect[it]++;\\n        \\n        vec[0]=vect[\\'z\\'];\\n        vec[6]=vect[\\'x\\'];\\n        vec[2]=vect[\\'w\\'];\\n        vec[4]=vect[\\'u\\'];\\n        vec[8]=vect[\\'g\\'];\\n        vec[5]=vect[\\'f\\']-vect[\\'u\\'];\\n        vec[3]=vect[\\'h\\']-vect[\\'g\\'];\\n        vec[1]=vect[\\'o\\']-vect[\\'w\\']-vect[\\'z\\']-vect[\\'u\\'];\\n        vec[7]=vect[\\'s\\']-vect[\\'x\\'];\\n        vec[9]=vect[\\'i\\']-vect[\\'g\\']-vect[\\'x\\']-vect[\\'f\\']+vect[\\'u\\'];\\n        for(int i=0;i<=9;i++){\\n            if(vec[i]>0){\\n                while(vec[i]>0){\\n                ans+=\\'0\\'+i;\\n                vec[i]--;\\n                }\\n\\n        }\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string originalDigits(string s) {\\n        vector<int>vec(10,0);\\n        vector<int>vect(128,0);\\n        string ans=\"\";\\n        for(auto it:s)\\n        vect[it]++;\\n        \\n        vec[0]=vect[\\'z\\'];\\n        vec[6]=vect[\\'x\\'];\\n        vec[2]=vect[\\'w\\'];\\n        vec[4]=vect[\\'u\\'];\\n        vec[8]=vect[\\'g\\'];\\n        vec[5]=vect[\\'f\\']-vect[\\'u\\'];\\n        vec[3]=vect[\\'h\\']-vect[\\'g\\'];\\n        vec[1]=vect[\\'o\\']-vect[\\'w\\']-vect[\\'z\\']-vect[\\'u\\'];\\n        vec[7]=vect[\\'s\\']-vect[\\'x\\'];\\n        vec[9]=vect[\\'i\\']-vect[\\'g\\']-vect[\\'x\\']-vect[\\'f\\']+vect[\\'u\\'];\\n        for(int i=0;i<=9;i++){\\n            if(vec[i]>0){\\n                while(vec[i]>0){\\n                ans+=\\'0\\'+i;\\n                vec[i]--;\\n                }\\n\\n        }\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564662,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1778192,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1565783,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1571699,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1575957,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1960736,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1951823,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1575068,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 2060907,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1891410,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1564662,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1778192,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1565783,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1571699,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1575957,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1960736,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1951823,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1575068,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 2060907,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            },
            {
                "id": 1891410,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "The **even** digits all have a unique letter while the **odd** digits all don't:\\n\\n`zero`: Only digit with `z`\\n`two`: Only digit with `w`\\n`four`: Only digit with `u`\\n`six`: Only digit with `x`\\n`eight`: Only digit with `g`\\n\\nThe odd ones for easy looking, each one's letters all also appear in other digit words:\\n`one`, `three`, `five`, `seven`, `nine`"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Who ever wrote the description of this question needs to go to jail"
                    },
                    {
                        "username": "mbsanjayp66",
                        "content": "please tell me correct !!\\nhow many of you understand this question without seeing the disscussion part?\\nfor me =\"i read the question continuously 4 to 5 times but doesnt get anything from the content of the question.\""
                    },
                    {
                        "username": "Ajay_Kumar_Verma",
                        "content": "Exactly! I also came to discussion section to understand the question."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Exactly! I too came to discussion section to understand the question."
                    },
                    {
                        "username": "agedboy",
                        "content": "If \"zzzeeerrrooo\" could be \"000\", why couldn't \"zeroonetwothreefourfivesixseveneightnine\" be \"01113356\"?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "Because then you have leftover chars. \\n\\nzeroonetwothreefourfivesixseveneightnine\\nhas 40 chars\\n\\nzerooneoneonethreethreefivesix\\nhas 30 chars\\n"
                    },
                    {
                        "username": "CrackItSean",
                        "content": "I used DP to solve this, and tried every way to optimize it, still get TLE.\\nPulled my hair, smashed my table, and realized this is an language test.\\nBingo, problem solved. \\n\\n"
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "At least provide some explanation for the sample test cases."
                    },
                    {
                        "username": "Kumar_11",
                        "content": "what the hell  is this problem statement \\uD83E\\uDD2C\\uD83D\\uDE21"
                    },
                    {
                        "username": "Spaniard_1",
                        "content": "Almost everyone used \\'unique characters\\' stradegy, anyone have other stardegy which is faster than it? or is there someone who optimized it to 100%?"
                    },
                    {
                        "username": "doublejvargas",
                        "content": "How is this a good interview question when both a correct and efficient solution rely on becoming aware that the ENGLISH spellings of digits 0-9 contain unique characters that can be used to simplify the digit identification process? Like, I don\\'t see myself having enough time in an interview to think of unique letters to each spelling of a digit when I\\'m already thinking of so many other things to solve the problem. The spellings would probably be something that dawns on me after I\\'ve spent far more time on this problem than allotted in an interview, or if I wanna come back to the problem to optimize an  already found solution."
                    },
                    {
                        "username": "java_run",
                        "content": "That level of satisfaction after completing the code and getting all the results getting passed with a good runtime \\uD83D\\uDE46\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    }
                ]
            }
        ]
    }
]