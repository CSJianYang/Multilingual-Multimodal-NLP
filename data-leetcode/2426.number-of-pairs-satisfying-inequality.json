[
    {
        "title": "Number of Pairs Satisfying Inequality",
        "question_content": "You are given two 0-indexed integer arrays nums1 and nums2, each of size n, and an integer diff. Find the number of pairs (i, j) such that:\n\n\t0 <= i < j <= n - 1 and\n\tnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\n\nReturn the number of pairs that satisfy the conditions.\n&nbsp;\nExample 1:\n\nInput: nums1 = [3,2,5], nums2 = [2,2,1], diff = 1\nOutput: 3\nExplanation:\nThere are 3 pairs that satisfy the conditions:\n1. i = 0, j = 1: 3 - 2 <= 2 - 2 + 1. Since i < j and 1 <= 1, this pair satisfies the conditions.\n2. i = 0, j = 2: 3 - 5 <= 2 - 1 + 1. Since i < j and -2 <= 2, this pair satisfies the conditions.\n3. i = 1, j = 2: 2 - 5 <= 2 - 1 + 1. Since i < j and -3 <= 2, this pair satisfies the conditions.\nTherefore, we return 3.\n\nExample 2:\n\nInput: nums1 = [3,-1], nums2 = [-2,2], diff = -1\nOutput: 0\nExplanation:\nSince there does not exist any pair that satisfies the conditions, we return 0.\n\n&nbsp;\nConstraints:\n\n\tn == nums1.length == nums2.length\n\t2 <= n <= 105\n\t-104 <= nums1[i], nums2[i] <= 104\n\t-104 <= diff <= 104",
        "solutions": [
            {
                "id": 2646606,
                "title": "python-reverse-pairs",
                "content": "# **Intuition**\\n`A[i] - A[j] <= B[i] - B[j] + diff`\\n`A[i] - B[i] <= A[j] - B[j] + diff`\\n\\nDefine `C[i] = A[i] - B[i]`,\\nwe need to find the number of pair in sequence C,\\nthat `C[i] <= C[j] + diff`.\\n\\nClassical reverse pair question,\\nreference 493. Reverse Pairs.\\n\\nUsually solved by\\nsolution 1: binary search tree\\nsolution 2: merge sort\\nsolution 3: this one\\n<br>\\n\\n# **Explanation**\\nIterate sequences `a = A[j]` and `b = B[j]`,\\nBinary search the position `a - b + diff` in a sorted list `l`.\\n\\nThe position index is the number of `C[i]`\\nthat `C[i] <= C[j] + diff`.\\n\\nAdd this value to result `res`,\\nand then add `a - b` to the sorted list `l`.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Python3**\\n```py\\n    def numberOfPairs(self, A, B, diff):\\n        l = SortedList()\\n        res = 0\\n        for a,b in zip(A, B):\\n            res += l.bisect_right(a - b + diff)\\n            l.add(a - b)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def numberOfPairs(self, A, B, diff):\\n        l = SortedList()\\n        res = 0\\n        for a,b in zip(A, B):\\n            res += l.bisect_right(a - b + diff)\\n            l.add(a - b)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2646585,
                "title": "easy-merge-sort-based-solution-c",
                "content": "**Explanation ::**\\n**Given that we have to find i , j such that 0 <= i < j <= n - 1 and \\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff**\\n**Step 1::**\\nRewriting the inequality--\\n(nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff\\n\\n**Step 2::**\\nMake a new array/vector c which stores nums1[i]-nums2[i].\\nor c[i] = nums1[i]-nums2[i] for  0 <= i <= n - 1.\\n\\n**Step 3::**\\nProblem reduces to  find i , j such that 0 <= i < j <= n - 1 and \\nc[i] <= c[j] + diff\\n\\nNow, This can be solved by using merge sort (Similar to inversion counting )\\n\\n\\n\\n```\\nclass Solution \\n{\\npublic:\\n\\n    long long int count;\\n   \\n    void checkCount(vector<int>& nums, int start, int mid, int end,int d)\\n    {\\n\\n        \\n        int l = start, r = mid + 1;\\n        while(l <= mid && r <= end)\\n        {\\n            if(nums[l]<=(nums[r]+d))  // if (nums[l]<=nums[r]+d) then all values from nums[r] to nums[end] will be be having their summation with d greater than or equal to nums[l]\\n            {\\n                count += (end - r+1);\\n                l++;\\n            }\\n            else      // otherwise we need to increment r so that we can find match for nums[l]\\n            {\\n                r++;\\n            }\\n        }\\n         // sort all values from start to end\\n        sort(nums.begin() + start, nums.begin() + end + 1);  // (Sort using two-pointers for better time complexity)\\n        return;\\n         \\n    }\\n    void mergeSort(vector<int>& nums, int start, int end,int d)\\n    {\\n        if(start == end) \\n            return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid,d);\\n        mergeSort(nums,mid+1,end,d);\\n        \\n        checkCount(nums,start,mid,end,d);\\n        return;\\n        \\n    }\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int d) \\n    {\\n        count = 0;\\n        int n = a.size();\\n        vector<int>c(n);  \\n        \\n        for(int i=0;i<n;i++)\\n        c[i]=a[i]-b[i];               \\n\\t\\t\\t\\n        mergeSort(c,0,n-1,d);\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n    long long int count;\\n   \\n    void checkCount(vector<int>& nums, int start, int mid, int end,int d)\\n    {\\n\\n        \\n        int l = start, r = mid + 1;\\n        while(l <= mid && r <= end)\\n        {\\n            if(nums[l]<=(nums[r]+d))  // if (nums[l]<=nums[r]+d) then all values from nums[r] to nums[end] will be be having their summation with d greater than or equal to nums[l]\\n            {\\n                count += (end - r+1);\\n                l++;\\n            }\\n            else      // otherwise we need to increment r so that we can find match for nums[l]\\n            {\\n                r++;\\n            }\\n        }\\n         // sort all values from start to end\\n        sort(nums.begin() + start, nums.begin() + end + 1);  // (Sort using two-pointers for better time complexity)\\n        return;\\n         \\n    }\\n    void mergeSort(vector<int>& nums, int start, int end,int d)\\n    {\\n        if(start == end) \\n            return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid,d);\\n        mergeSort(nums,mid+1,end,d);\\n        \\n        checkCount(nums,start,mid,end,d);\\n        return;\\n        \\n    }\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int d) \\n    {\\n        count = 0;\\n        int n = a.size();\\n        vector<int>c(n);  \\n        \\n        for(int i=0;i<n;i++)\\n        c[i]=a[i]-b[i];               \\n\\t\\t\\t\\n        mergeSort(c,0,n-1,d);\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646522,
                "title": "merge-sort-logic",
                "content": "```\\n\\n// ->   nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n// ->   nums1[i] - nums2[i] - nums1[j] + nums2[j] <= diff\\n// ->   (nums1[i] - nums2[i]) - (nums1[j] - nums2[j]) <= diff\\n\\n// make an array with values i.e arr[k] = nums1[k] - nums2[k];\\n\\n// now the question is boiled down to count pairs in array \\'arr\\' with difference less than diff i.e arr[i]-arr[j] <= diff (where j>i)\\n\\n// we can get both indices by doing merge sort.\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long cnt = 0;\\n    int diff = 0;\\n    void merge(vector<long> &arr,int low,int mid,int high){\\n        long long temp[arr.size()];\\n        int i = low;\\n        int j = mid+1;\\n        int k = low;\\n        \\n        while(i<=mid and j<=high){\\n            long long a = arr[j];\\n            if(arr[i]-a<=diff){\\n                cnt += high-j+1;\\n                i++;\\n             }\\n             else{\\n                 j++;\\n             }\\n          }\\n        \\n         i = low;\\n         j = mid+1;\\n         while(i<=mid and j<=high){\\n             if(arr[i]<=arr[j]){\\n                 temp[k++] = arr[i++];\\n             }\\n             else{\\n                 temp[k++] = arr[j++];\\n\\n             }\\n         }\\n         while(i<=mid){\\n             temp[k++] = arr[i++];\\n         }\\n         while(j<=high){\\n             temp[k++] = arr[j++];\\n         }\\n         for(int z = low; z<=high; z++){\\n             arr[z] = temp[z];\\n         }\\n        \\n    }\\n    \\n    void mergeSort(int low , int high ,vector<long> &nums){\\n        if(low<high){\\n            int mid = low + (high-low)/2;\\n            mergeSort(low , mid ,nums);\\n            mergeSort(mid+1, high,nums);\\n            merge(nums,low,mid,high);\\n        }\\n    }\\n    \\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int d) {\\n        int n = nums1.size();\\n        diff = d;\\n        vector<long> v;\\n        for(int i = 0; i<n; i++){\\n            long val = nums1[i]-nums2[i];\\n            v.push_back(val);\\n        }\\n        int l = 0;\\n        int h = n-1;\\n        mergeSort(l,h,v);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\n\\n// ->   nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n// ->   nums1[i] - nums2[i] - nums1[j] + nums2[j] <= diff\\n// ->   (nums1[i] - nums2[i]) - (nums1[j] - nums2[j]) <= diff\\n\\n// make an array with values i.e arr[k] = nums1[k] - nums2[k];\\n\\n// now the question is boiled down to count pairs in array \\'arr\\' with difference less than diff i.e arr[i]-arr[j] <= diff (where j>i)\\n\\n// we can get both indices by doing merge sort.\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long cnt = 0;\\n    int diff = 0;\\n    void merge(vector<long> &arr,int low,int mid,int high){\\n        long long temp[arr.size()];\\n        int i = low;\\n        int j = mid+1;\\n        int k = low;\\n        \\n        while(i<=mid and j<=high){\\n            long long a = arr[j];\\n            if(arr[i]-a<=diff){\\n                cnt += high-j+1;\\n                i++;\\n             }\\n             else{\\n                 j++;\\n             }\\n          }\\n        \\n         i = low;\\n         j = mid+1;\\n         while(i<=mid and j<=high){\\n             if(arr[i]<=arr[j]){\\n                 temp[k++] = arr[i++];\\n             }\\n             else{\\n                 temp[k++] = arr[j++];\\n\\n             }\\n         }\\n         while(i<=mid){\\n             temp[k++] = arr[i++];\\n         }\\n         while(j<=high){\\n             temp[k++] = arr[j++];\\n         }\\n         for(int z = low; z<=high; z++){\\n             arr[z] = temp[z];\\n         }\\n        \\n    }\\n    \\n    void mergeSort(int low , int high ,vector<long> &nums){\\n        if(low<high){\\n            int mid = low + (high-low)/2;\\n            mergeSort(low , mid ,nums);\\n            mergeSort(mid+1, high,nums);\\n            merge(nums,low,mid,high);\\n        }\\n    }\\n    \\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int d) {\\n        int n = nums1.size();\\n        diff = d;\\n        vector<long> v;\\n        for(int i = 0; i<n; i++){\\n            long val = nums1[i]-nums2[i];\\n            v.push_back(val);\\n        }\\n        int l = 0;\\n        int h = n-1;\\n        mergeSort(l,h,v);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646489,
                "title": "merge-sort-tree-cpp",
                "content": "Let\\'s first reorganize the equation\\n```\\na[i] - a[j] <= b[i] - b[j] + diff\\n\\ncan be written as \\n\\na[i] - b[i] - diff <= a[j] - b[j]\\n```\\n\\nFirst create an array where **v[i] = a[i] - b[i]**\\n\\nNow for a particular index **i** we just need to find the count of all the indices in the range **[i + 1, n - 1]**  such that our equation satisfies i.e we need to find all the indices **j** such that **a[j] - b[j] >= a[i] - b[i] - diff**.\\n\\nNow let\\'s tackle a small problem suppose we have a sorted array and we need to count the number of values greater than or equal to **x** this can easily be done using **Binary Search**.\\nNow let\\'s use a **Merge Sort Tree**(basically a Segment tree where each node stores the array of its range in sorted order)\\n\\nNow first build our Tree from the array **v** then for and index **i** make a query in the range **[i + 1, n - 1]** to find the count of the indices that have value greater than or equal to **a[i] - b[i] - diff**.\\n\\n**Time Complexity**: **O(n * log(n) * log(n))**\\n **n** for the for loop, **log(n)** no of nodes in our tree, **log(n)** binary search in  every correct node \\n\\n**Space Complexity**: **O(n * log(n))**\\n Total number of levels in Merge sort tree is **log(n)** and at every level whole array of size **n** is stored\\n\\n```\\n#define ll long long\\nstruct SEG {\\n    vector<vector<ll>> v;\\n    ll siz = 1;\\n    \\n    SEG(ll n, vector<ll> &ar) {\\n        siz = 1;\\n        while(siz <= n) siz <<= 1;\\n        v.resize(2 * siz);\\n        build(0, siz - 1, 0, ar);\\n    }\\n    \\n    void merge(vector<ll> &a, vector<ll> &b, vector<ll> &c) {\\n        int i = 0, j = 0;\\n        while(i < b.size() and j < c.size()) {\\n            if(b[i] < c[j]) a.push_back(b[i++]);\\n            else a.push_back(c[j++]);\\n        }\\n        while(i < b.size()) {\\n            a.push_back(b[i++]);\\n        }\\n        while(j < c.size()) {\\n            a.push_back(c[j++]);\\n        }\\n    }\\n\\n    void build(ll lx, ll rx, ll x, vector<ll> &ar) {\\n        if(lx == rx) {\\n            if(lx < ar.size()) {\\n                v[x].push_back(ar[lx]);\\n            }\\n            return;\\n        }\\n        ll mid = lx + (rx - lx) / 2;\\n        build(lx, mid, 2 * x + 1, ar);\\n        build(mid + 1, rx, 2 * x + 2, ar);\\n \\n        merge(v[x], v[2 * x + 1], v[2 * x + 2]);\\n    }\\n    \\n    //count of numbers greater than equal to val\\n    ll cnt(ll l, ll r, ll val, ll x, ll lx, ll rx) {\\n        if(lx > r or rx < l) return 0;\\n        if(lx >= l and rx <= r) {\\n            int ind = lower_bound(v[x].begin(), v[x].end(), val) - v[x].begin();\\n            return v[x].size() - ind;\\n        }\\n        ll mid = lx + (rx - lx) / 2;\\n        return cnt(l, r, val, 2 * x + 1, lx, mid) + cnt(l, r, val, 2 * x + 2, mid + 1, rx);\\n    }\\n    ll cnt(ll l, ll r, ll val) {\\n        return cnt(l, r, val, 0, 0, siz - 1);\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int diff) {\\n        int n = a.size();\\n        vector<ll> v(n);\\n        for(int i = 0; i < n; ++i) v[i] = a[i] - b[i];\\n        \\n        SEG tree(n, v);\\n        \\n        ll pairs = 0;\\n        for(int i = 0; i < n; ++i) {\\n            pairs += tree.cnt(i + 1, n - 1, v[i] - diff);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\na[i] - a[j] <= b[i] - b[j] + diff\\n\\ncan be written as \\n\\na[i] - b[i] - diff <= a[j] - b[j]\\n```\n```\\n#define ll long long\\nstruct SEG {\\n    vector<vector<ll>> v;\\n    ll siz = 1;\\n    \\n    SEG(ll n, vector<ll> &ar) {\\n        siz = 1;\\n        while(siz <= n) siz <<= 1;\\n        v.resize(2 * siz);\\n        build(0, siz - 1, 0, ar);\\n    }\\n    \\n    void merge(vector<ll> &a, vector<ll> &b, vector<ll> &c) {\\n        int i = 0, j = 0;\\n        while(i < b.size() and j < c.size()) {\\n            if(b[i] < c[j]) a.push_back(b[i++]);\\n            else a.push_back(c[j++]);\\n        }\\n        while(i < b.size()) {\\n            a.push_back(b[i++]);\\n        }\\n        while(j < c.size()) {\\n            a.push_back(c[j++]);\\n        }\\n    }\\n\\n    void build(ll lx, ll rx, ll x, vector<ll> &ar) {\\n        if(lx == rx) {\\n            if(lx < ar.size()) {\\n                v[x].push_back(ar[lx]);\\n            }\\n            return;\\n        }\\n        ll mid = lx + (rx - lx) / 2;\\n        build(lx, mid, 2 * x + 1, ar);\\n        build(mid + 1, rx, 2 * x + 2, ar);\\n \\n        merge(v[x], v[2 * x + 1], v[2 * x + 2]);\\n    }\\n    \\n    //count of numbers greater than equal to val\\n    ll cnt(ll l, ll r, ll val, ll x, ll lx, ll rx) {\\n        if(lx > r or rx < l) return 0;\\n        if(lx >= l and rx <= r) {\\n            int ind = lower_bound(v[x].begin(), v[x].end(), val) - v[x].begin();\\n            return v[x].size() - ind;\\n        }\\n        ll mid = lx + (rx - lx) / 2;\\n        return cnt(l, r, val, 2 * x + 1, lx, mid) + cnt(l, r, val, 2 * x + 2, mid + 1, rx);\\n    }\\n    ll cnt(ll l, ll r, ll val) {\\n        return cnt(l, r, val, 0, 0, siz - 1);\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int diff) {\\n        int n = a.size();\\n        vector<ll> v(n);\\n        for(int i = 0; i < n; ++i) v[i] = a[i] - b[i];\\n        \\n        SEG tree(n, v);\\n        \\n        ll pairs = 0;\\n        for(int i = 0; i < n; ++i) {\\n            pairs += tree.cnt(i + 1, n - 1, v[i] - diff);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648104,
                "title": "2-o-nlogn-solutions-merge-sort-bit-java",
                "content": "# Approach\\n- To find the number of pairs we first need to rearrange the equation:\\n`nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`\\n- Move all i to the left and all j to the right:\\n`nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff`\\n- Define `nums[i] = nums1[i] - nums2[i]`\\n- Find the number of pairs i,j such that `nums[i] <= nums[j] + diff`\\n- This can be done with a Binary Tree data structure like a Fenwick Tree - BIT (Solution 1) or a segment tree\\n- This can also be done using a modified merge sort (Solution 2)\\n- Time complexity O(nlogn)\\n- Related problem:  [493 Reverse pairs](https://leetcode.com/problems/reverse-pairs/)\\n  - Also read [this thread for a very detailed explanation of the principles](https://leetcode.com/problems/reverse-pairs/discuss/97268/General-principles-behind-problems-similar-to-%22Reverse-Pairs%22)\\n\\n# Solution 1 with a Fenwick tree (BIT)\\n- Use SHIFT to map all negative numbers into a positive number range\\n- Get the count of numbers already in the BIT satisfying `x <= current number + diff`\\n- Then add the current number to the BIT\\n```java\\n    private int SHIFT = 30000;\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        BIT bit = new BIT(SHIFT * 2);\\n        long res = 0L;\\n        for (int i = 0; i < n; i++) {\\n            int ndiff = nums1[i] - nums2[i];\\n            res += bit.get(ndiff + diff + SHIFT);\\n            bit.add(ndiff + SHIFT);\\n        }\\n        return res;\\n    }\\n    // BIT: both add & get O(logN)\\n    private class BIT {\\n        private int[] bit;\\n        public BIT(int n) {\\n            bit = new int[n+1];\\n        }\\n        \\n        public void add(int val) {\\n            if (val <= 0) return;\\n            for (int i = val; i < bit.length; i += (i & -i)) bit[i]++;\\n        }\\n        \\n        public int get(int val) {\\n            int res = 0;\\n            for (int i = val; i > 0; i -= (i & -i)) res += bit[i];\\n            return res;\\n        }\\n    }\\n```\\n# Solution 2 with a modified Merge Sort\\n- Divide and conquer\\n- Sort left and right halves recursively\\n- Then merge sorted halves, and while merging find the number of pairs satisfying inequality\\n```java\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        long[] nums = new long[n];\\n        for (int i = 0; i < n; i++) nums[i] = nums1[i] - nums2[i];\\n        long[] tmp = Arrays.copyOf(nums, n);\\n        return sort(nums, tmp, 0, n-1, diff);\\n    }\\n    // sort O(NlogN)\\n    private long sort(long[] nums, long[] tmp, int lo, int hi, int diff) {\\n        if (lo == hi) return 0L;\\n        int mid = lo + (hi - lo) / 2;\\n        long res = 0L;\\n        res += sort(nums, tmp, lo, mid, diff);\\n        res += sort(nums, tmp, mid+1, hi, diff);\\n        res += merge(nums, tmp, lo, mid, hi, diff);\\n        return res;\\n    }\\n    // merge 2*N = O(N)\\n    private long merge(long[] nums, long[] tmp, int lo, int mid, int hi, int diff) {\\n        long res = 0L;\\n        // find the count of pairs x <= y + diff in 2 sorted halves\\n        for (int i = lo, j = mid+1; i <= mid && j <= hi; i++) {\\n            while (j <= hi && nums[i] > nums[j] + diff) j++;\\n            res += hi-j+1;\\n        }\\n        // merge 2 sorted halves\\n        for (int i = lo, j = mid+1, k = lo; i <= mid || j <= hi; k++) {\\n            if (j > hi || (i <= mid && nums[i] < nums[j])) {\\n                tmp[k] = nums[i++];\\n            } else {\\n                tmp[k] = nums[j++];\\n            }\\n        }\\n        System.arraycopy(tmp, lo, nums, lo, hi-lo+1); // tmp -> nums\\n        return res;\\n    }\\n```\\n**Please upvote if you like my solutions. Thank you!**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```java\\n    private int SHIFT = 30000;\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        BIT bit = new BIT(SHIFT * 2);\\n        long res = 0L;\\n        for (int i = 0; i < n; i++) {\\n            int ndiff = nums1[i] - nums2[i];\\n            res += bit.get(ndiff + diff + SHIFT);\\n            bit.add(ndiff + SHIFT);\\n        }\\n        return res;\\n    }\\n    // BIT: both add & get O(logN)\\n    private class BIT {\\n        private int[] bit;\\n        public BIT(int n) {\\n            bit = new int[n+1];\\n        }\\n        \\n        public void add(int val) {\\n            if (val <= 0) return;\\n            for (int i = val; i < bit.length; i += (i & -i)) bit[i]++;\\n        }\\n        \\n        public int get(int val) {\\n            int res = 0;\\n            for (int i = val; i > 0; i -= (i & -i)) res += bit[i];\\n            return res;\\n        }\\n    }\\n```\n```java\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        long[] nums = new long[n];\\n        for (int i = 0; i < n; i++) nums[i] = nums1[i] - nums2[i];\\n        long[] tmp = Arrays.copyOf(nums, n);\\n        return sort(nums, tmp, 0, n-1, diff);\\n    }\\n    // sort O(NlogN)\\n    private long sort(long[] nums, long[] tmp, int lo, int hi, int diff) {\\n        if (lo == hi) return 0L;\\n        int mid = lo + (hi - lo) / 2;\\n        long res = 0L;\\n        res += sort(nums, tmp, lo, mid, diff);\\n        res += sort(nums, tmp, mid+1, hi, diff);\\n        res += merge(nums, tmp, lo, mid, hi, diff);\\n        return res;\\n    }\\n    // merge 2*N = O(N)\\n    private long merge(long[] nums, long[] tmp, int lo, int mid, int hi, int diff) {\\n        long res = 0L;\\n        // find the count of pairs x <= y + diff in 2 sorted halves\\n        for (int i = lo, j = mid+1; i <= mid && j <= hi; i++) {\\n            while (j <= hi && nums[i] > nums[j] + diff) j++;\\n            res += hi-j+1;\\n        }\\n        // merge 2 sorted halves\\n        for (int i = lo, j = mid+1, k = lo; i <= mid || j <= hi; k++) {\\n            if (j > hi || (i <= mid && nums[i] < nums[j])) {\\n                tmp[k] = nums[i++];\\n            } else {\\n                tmp[k] = nums[j++];\\n            }\\n        }\\n        System.arraycopy(tmp, lo, nums, lo, hi-lo+1); // tmp -> nums\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646917,
                "title": "ordered-set-c-easy",
                "content": "**Plz Upvote if you liked it :)**\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp> // Common file \\n#include <ext/pb_ds/tree_policy.hpp> \\n#include <functional> // for less \\n#include <iostream> \\nusing namespace __gnu_pbds; \\nusing namespace std; \\n\\nclass Solution {\\npublic:\\n    \\n//     take advantage of ordered set\\n    typedef tree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, \\n            tree_order_statistics_node_update> \\n    ordered_set; \\n    \\n    \\n    long long f(vector<long long>& vt,  long long n, long long k)\\n{\\n     long long count=0;\\n         ordered_set mySet;\\n        for(long long i=0;i<n;++i){\\n           \\n           \\n            count+=mySet.order_of_key({vt[i]+k,INT_MAX});\\n              mySet.insert({vt[i],i});  \\n        }\\n \\n    return count;\\n}\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        // cout<<endl;\\n        long long n=nums1.size();\\n        vector<long long> vt(n);\\n        for(long long i=0;i<n;++i){\\n            vt[i]=nums1[i]-nums2[i];\\n        }\\n        // sort(begin(vt),end(vt));\\n        return f(vt,n,diff);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> // Common file \\n#include <ext/pb_ds/tree_policy.hpp> \\n#include <functional> // for less \\n#include <iostream> \\nusing namespace __gnu_pbds; \\nusing namespace std; \\n\\nclass Solution {\\npublic:\\n    \\n//     take advantage of ordered set\\n    typedef tree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, \\n            tree_order_statistics_node_update> \\n    ordered_set; \\n    \\n    \\n    long long f(vector<long long>& vt,  long long n, long long k)\\n{\\n     long long count=0;\\n         ordered_set mySet;\\n        for(long long i=0;i<n;++i){\\n           \\n           \\n            count+=mySet.order_of_key({vt[i]+k,INT_MAX});\\n              mySet.insert({vt[i],i});  \\n        }\\n \\n    return count;\\n}\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        // cout<<endl;\\n        long long n=nums1.size();\\n        vector<long long> vt(n);\\n        for(long long i=0;i<n;++i){\\n            vt[i]=nums1[i]-nums2[i];\\n        }\\n        // sort(begin(vt),end(vt));\\n        return f(vt,n,diff);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2646911,
                "title": "binary-indexed-tree-rearrangements-in-equation",
                "content": "Let say we have two arrays A and B \\nthen \\nGiven A[i] - A[j] <= B[i] - B[j] + diff\\nthis can be rearranged as\\nA[i] - B[i] <= A[j] - B[j] + diff\\nX[i] <= X[j] + diff\\nhere X[i] = A[i] - B[i]  // consider it as a function \\nnow if know \\nX[j] and diff we can know the range of X[i] and hence we can apply binary indexed tree on numbers as it is less than 10 to the power 4 \\n\\n```\\nclass BIT{\\n    vector<int> bit;\\n    public:\\n    int N;\\n    BIT(int n){\\n        bit = vector<int> (n + 1);\\n        N = n;\\n    }\\n    \\n    void upd(int i,int val){\\n        i+=1;\\n        for(;i <= N;i+=(i & -i)){\\n            bit[i] += val;\\n        }\\n    }\\n    \\n    int summ(int i){\\n       int sum = 0;\\n        i+=1;\\n         for(;i > 0;i-=(i & -i)){\\n            sum += bit[i];\\n        }   \\n        return sum;\\n    }\\n    \\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int diff) {\\n        \\n        int n = a.size();\\n        \\n        long long ans = 0;\\n        \\n        int c = 1e5;\\n        \\n        BIT* bb = new BIT(10*c + 1);\\n\\n        bb->upd(a[0] - b[0] + c, 1);\\n\\n        for(int j=1;j<n;j++){\\n            int x = bb->summ(a[j] - b[j] + diff + c);\\n            ans += x;            \\n            bb->upd(a[j] - b[j] + c,1);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass BIT{\\n    vector<int> bit;\\n    public:\\n    int N;\\n    BIT(int n){\\n        bit = vector<int> (n + 1);\\n        N = n;\\n    }\\n    \\n    void upd(int i,int val){\\n        i+=1;\\n        for(;i <= N;i+=(i & -i)){\\n            bit[i] += val;\\n        }\\n    }\\n    \\n    int summ(int i){\\n       int sum = 0;\\n        i+=1;\\n         for(;i > 0;i-=(i & -i)){\\n            sum += bit[i];\\n        }   \\n        return sum;\\n    }\\n    \\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int diff) {\\n        \\n        int n = a.size();\\n        \\n        long long ans = 0;\\n        \\n        int c = 1e5;\\n        \\n        BIT* bb = new BIT(10*c + 1);\\n\\n        bb->upd(a[0] - b[0] + c, 1);\\n\\n        for(int j=1;j<n;j++){\\n            int x = bb->summ(a[j] - b[j] + diff + c);\\n            ans += x;            \\n            bb->upd(a[j] - b[j] + c,1);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646651,
                "title": "java-fenwick-tree-solution-explained-o-n-log-n",
                "content": "**Intuition:**\\n`nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`\\ncan be refactored into\\n`nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff`\\n\\nCreate a new array nums3 where `nums3[i] = nums1[i] - nums2[i]`\\n\\nThen equation will be \\n`nums3[i] <= nums3[j] + diff`\\n\\nSince i < j, for each j, find the total number of ith indexes that satisfy equation.\\nUse fenwick tree where each key is nums3[i], and each value is number of indexes with value equal to nums3[i].\\n\\nTherefore `sum(nums3[j] + diff)` would get total number of indexes that satisfy equation, with value from `0 <= value <= nums3[j] + diff`.\\n\\n**Edge cases:**\\nSince key can possibly be negative and arrays cannot have negative indexes, an offset of 50000 is added.\\n\\n```\\nclass Solution {\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        int[] nums3 = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            nums3[i] = nums1[i] - nums2[i];\\n        }\\n        long count = 0;\\n        int[] arr = new int[100000];\\n        int offset = 50000;\\n        Fenwick f = new Fenwick(arr);\\n        for (int j = 0; j < n; j++) {\\n            int key = offset + nums3[j] + diff;\\n            count += f.sum(key);\\n            f.update(offset + nums3[j], 1);\\n        }\\n        return count;\\n    }\\n}\\n\\npublic class Fenwick {\\n    long[] bit;\\n \\n    public Fenwick(int arr[]) {\\n        bit = new long[arr.length + 1]; // index starts from 1 not 0.\\n \\n        for (int i = 0; i < arr.length; i++) {\\n            int index = i+1;\\n            bit[index] += arr[i];\\n            int parent = index + (index & -index); // index of parent\\n            if (parent < bit.length) {\\n                bit[parent] += bit[index];\\n            }\\n        }\\n    }\\n \\n    // return sum of arr[0..index].\\n    public long sum(int index) {\\n        long totalSum = 0;\\n        index = index + 1;\\n \\n        while (index > 0) {\\n            totalSum += bit[index];\\n            index -= index & (-index);\\n        }\\n        return totalSum;\\n    }\\n\\n    public void update(int index, int val) {\\n        // index in BIT[] starts from 1\\n        index = index + 1;\\n \\n        while (index < bit.length) {\\n            bit[index] += val;\\n           index += index & (-index);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        int[] nums3 = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            nums3[i] = nums1[i] - nums2[i];\\n        }\\n        long count = 0;\\n        int[] arr = new int[100000];\\n        int offset = 50000;\\n        Fenwick f = new Fenwick(arr);\\n        for (int j = 0; j < n; j++) {\\n            int key = offset + nums3[j] + diff;\\n            count += f.sum(key);\\n            f.update(offset + nums3[j], 1);\\n        }\\n        return count;\\n    }\\n}\\n\\npublic class Fenwick {\\n    long[] bit;\\n \\n    public Fenwick(int arr[]) {\\n        bit = new long[arr.length + 1]; // index starts from 1 not 0.\\n \\n        for (int i = 0; i < arr.length; i++) {\\n            int index = i+1;\\n            bit[index] += arr[i];\\n            int parent = index + (index & -index); // index of parent\\n            if (parent < bit.length) {\\n                bit[parent] += bit[index];\\n            }\\n        }\\n    }\\n \\n    // return sum of arr[0..index].\\n    public long sum(int index) {\\n        long totalSum = 0;\\n        index = index + 1;\\n \\n        while (index > 0) {\\n            totalSum += bit[index];\\n            index -= index & (-index);\\n        }\\n        return totalSum;\\n    }\\n\\n    public void update(int index, int val) {\\n        // index in BIT[] starts from 1\\n        index = index + 1;\\n \\n        while (index < bit.length) {\\n            bit[index] += val;\\n           index += index & (-index);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646624,
                "title": "python3-sortedlist-o-nlogn-clean-concise",
                "content": "**Observation**\\nThe problem is equivalent to: Find the number of **pairs** `(i, j)` such that:\\n* `0 <= i < j <= n - 1` **and**\\n* `nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff`.\\n\\n**Implementation**\\nIn Python, we can utilize the [SortedList data structure](https://grantjenks.com/docs/sortedcontainers/sortedlist.html) to achieve fast addition of each new element ([in approx. log time](https://grantjenks.com/docs/sortedcontainers/sortedlist.html#sortedcontainers.SortedList.add)) while maintaining the array to be sorted.\\nIn other programming languages, we can utilize a similar data structure (Fenwick tree/binary indexed tree) to solve this problem with the same overall time complexity.\\n\\n**Complexity**\\nTime Complexity: `O(NlogN)`\\nSpace Complexity: `O(N)`\\n \\n **Solution**\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        sl, ans = SortedList(), 0\\n        for num1, num2 in zip(nums1, nums2):\\n            ans += sl.bisect_right(num1 - num2 + diff)\\n            sl.add(num1 - num2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        sl, ans = SortedList(), 0\\n        for num1, num2 in zip(nums1, nums2):\\n            ans += sl.bisect_right(num1 - num2 + diff)\\n            sl.add(num1 - num2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647385,
                "title": "java-binary-search-easy-to-understand-maintain-sorted-list",
                "content": "##### Explanation\\nInspired by @lee215 solution (https://leetcode.com/problems/number-of-pairs-satisfying-inequality/discuss/2646606/Python-Reverse-Pairs).\\n\\nDirect count from equation (nums1[i] - nums1[j]  <= nums2[i] - nums2[j] + diff ) will gives an o(n^2) time complexity solution.\\nChange above equation to:\\nnums1[i] -  nums2[i] <=  nums1[j] - nums2[j] + diff (0 <= i < j < n)\\nthen:\\nc[i] <= c[j] + diff (0 <= i < j < n), where c[i] = nums1[i] -  nums2[i]\\n\\nMaintain a sorted list(diffList) of c[i]. For every new c[j], find the number of c element that are smaller or equal to (c[j]+diff) by binary search, which is equivalent to the number of valid c[i] that can form valid pairs.\\n\\nFinally insert this c[j] to appropriate index sorted list (diffList).  c[j] is a new difference (c[j] = nums1[j] - nums2[j]). It can be later j\\'s paired i. So it\\'s necessary to insert into the correct position of the sorted difference list(diffList) for future binary search.\\n\\nThe c[j] index in sorted list can be found reusing binary search function from above step.\\n\\nSpace complexity: o(n)\\n\\nTime complexity: o(n^2). Thanks @bl2003 for checking Java source code and figuring out right complexity.\\n\\n```java\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        List<Integer> diffList = new ArrayList<>();\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int curDiff = nums1[i] - nums2[i];\\n            int target  = curDiff + diff; \\n            res += countSmallerEqual(diffList, target);\\n            diffList.add((int) countSmallerEqual(diffList, curDiff), curDiff);\\n        }\\n        return res;\\n    }\\n    \\n    private long countSmallerEqual(List<Integer> diffList, int target) {\\n        int left = 0, right = diffList.size(); \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (diffList.get(mid) <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return (long)left;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```java\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        List<Integer> diffList = new ArrayList<>();\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int curDiff = nums1[i] - nums2[i];\\n            int target  = curDiff + diff; \\n            res += countSmallerEqual(diffList, target);\\n            diffList.add((int) countSmallerEqual(diffList, curDiff), curDiff);\\n        }\\n        return res;\\n    }\\n    \\n    private long countSmallerEqual(List<Integer> diffList, int target) {\\n        int left = 0, right = diffList.size(); \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (diffList.get(mid) <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return (long)left;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647337,
                "title": "normal-segment-tree",
                "content": "```\\nclass SegTree{\\n        public:\\n        vector<long long>tree;\\n        SegTree(int n){\\n            tree.resize(4*n,0);\\n        }\\n        \\n        void update(int l,int r,int ind,int tar){\\n            \\n            if(l>tar || r< tar)return;\\n            if(l==r){\\n                tree[ind]++;\\n                return;\\n            }\\n            int m=l+(r-l)/2;\\n            update(l,m,2*ind+1,tar);\\n            update(m+1,r,2*ind+2,tar);\\n            tree[ind]=tree[2*ind+1]+tree[2*ind+2];\\n        }\\n        \\n        \\n        long long query(int l,int r,int ind,int low,int high){\\n            if(l>high || r<low)return 0;\\n            if(low<=l and high>=r){\\n                return tree[ind];\\n            }\\n            int m=l+(r-l)/2;\\n            return query(l,m,2*ind+1,low,high)+query(m+1,r,2*ind+2,low,high);\\n        }\\n        \\n        \\n    };\\n    \\n    \\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        vector<long long>arr(n,0);\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums1[i]-nums2[i];\\n        }\\n\\n        long long ans=0;\\n        \\n       \\n        int top=40000,add=20000;\\n        auto pos=new SegTree(top);\\n\\n        \\n        for(int i=0;i<n;i++){\\n            long long temp=arr[i]+diff+add;\\n            ans+=pos->query(0,top,0,0,temp);\\n            pos->update(0,top,0,arr[i]+add);\\n            \\n        }\\n        return ans;\\n    }\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Tree"
                ],
                "code": "```\\nclass SegTree{\\n        public:\\n        vector<long long>tree;\\n        SegTree(int n){\\n            tree.resize(4*n,0);\\n        }\\n        \\n        void update(int l,int r,int ind,int tar){\\n            \\n            if(l>tar || r< tar)return;\\n            if(l==r){\\n                tree[ind]++;\\n                return;\\n            }\\n            int m=l+(r-l)/2;\\n            update(l,m,2*ind+1,tar);\\n            update(m+1,r,2*ind+2,tar);\\n            tree[ind]=tree[2*ind+1]+tree[2*ind+2];\\n        }\\n        \\n        \\n        long long query(int l,int r,int ind,int low,int high){\\n            if(l>high || r<low)return 0;\\n            if(low<=l and high>=r){\\n                return tree[ind];\\n            }\\n            int m=l+(r-l)/2;\\n            return query(l,m,2*ind+1,low,high)+query(m+1,r,2*ind+2,low,high);\\n        }\\n        \\n        \\n    };\\n    \\n    \\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        vector<long long>arr(n,0);\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums1[i]-nums2[i];\\n        }\\n\\n        long long ans=0;\\n        \\n       \\n        int top=40000,add=20000;\\n        auto pos=new SegTree(top);\\n\\n        \\n        for(int i=0;i<n;i++){\\n            long long temp=arr[i]+diff+add;\\n            ans+=pos->query(0,top,0,0,temp);\\n            pos->update(0,top,0,arr[i]+add);\\n            \\n        }\\n        return ans;\\n    }\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646705,
                "title": "c-policy-based-data-structure",
                "content": "Rearrange the condition !!\\n\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n\\nNow, this simplies out solution.\\n[learn policy based data stucture ](https://codeforces.com/blog/entry/11080)\\n```\\n#include <ext/pb_ds/assoc_container.hpp> \\nusing namespace __gnu_pbds; \\ntypedef tree<int, null_type, \\n     less_equal<int>, rb_tree_tag,\\n          tree_order_statistics_node_update> pbds;\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        pbds s;\\n        int n = nums1.size();\\n        long long ans = 0;\\n        for(int i=n-1;i>=0; i--){\\n            int val = nums1[i] - nums2[i];\\n            auto it = s.order_of_key(val);\\n            ans += (s.size() - it);\\n            s.insert(val + diff);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHope helps \\uD83D\\uDE0A \\uD83D\\uDE0A",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\nusing namespace __gnu_pbds; \\ntypedef tree<int, null_type, \\n     less_equal<int>, rb_tree_tag,\\n          tree_order_statistics_node_update> pbds;\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        pbds s;\\n        int n = nums1.size();\\n        long long ans = 0;\\n        for(int i=n-1;i>=0; i--){\\n            int val = nums1[i] - nums2[i];\\n            auto it = s.order_of_key(val);\\n            ans += (s.size() - it);\\n            s.insert(val + diff);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2646836,
                "title": "python-clean",
                "content": "```\\n# N4. Number of Pairs Satisfying Inequality\\nclass Solution:\\n    def numberOfPairs(self, nums1, nums2, diff: int) -> int:\\n        sl = SortedList()\\n        ct = 0\\n\\n        # condition is equivalent to\\n        # nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff.\\n        for i in range(len(nums1)):\\n            d = nums1[i] - nums2[i] + diff\\n            ct += sl.bisect_right(d)\\n\\n            # that\\'s why save difference in sorted list\\n            sl.add(nums1[i] - nums2[i])\\n\\n        return ct\\n```",
                "solutionTags": [],
                "code": "```\\n# N4. Number of Pairs Satisfying Inequality\\nclass Solution:\\n    def numberOfPairs(self, nums1, nums2, diff: int) -> int:\\n        sl = SortedList()\\n        ct = 0\\n\\n        # condition is equivalent to\\n        # nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff.\\n        for i in range(len(nums1)):\\n            d = nums1[i] - nums2[i] + diff\\n            ct += sl.bisect_right(d)\\n\\n            # that\\'s why save difference in sorted list\\n            sl.add(nums1[i] - nums2[i])\\n\\n        return ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646591,
                "title": "simple-python-binary-search",
                "content": "We need to find number of pairs such that:\\n* `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`.\\n\\nIf we transform this inequality, it will take the following form:\\n* `nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff`.\\n\\nWe see that there is a common part here, let\\'s call it delta:\\n* `delta[k] = nums1[k] - nums2[k]`.\\n\\nWe need to calculate deltas for all `k` in the range `[0, n)`. Since `i < j`, when calculating the next delta, we can find how many deltas were calculated previously, such that\\n* `previous_delta <= current_delta + diff`,\\n\\nand add this number to the total number of pairs.\\n\\nThis can be done using binary search. We save all calculated deltas in a sorted list and add `current_delta` there after searching.\\n\\n`SortedList` is used to store deltas. Since it has logarithmic addition complexity, the total complexity is `O(nlog(n))`.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        deltas = SortedList()\\n        pairs = 0\\n        for num1, num2 in zip(nums1, nums2):\\n            delta = num1 - num2\\n            pairs += deltas.bisect_right(delta + diff)\\n            deltas.add(delta)\\n        return pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        deltas = SortedList()\\n        pairs = 0\\n        for num1, num2 in zip(nums1, nums2):\\n            delta = num1 - num2\\n            pairs += deltas.bisect_right(delta + diff)\\n            deltas.add(delta)\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800714,
                "title": "c-mergesort-similar-problem-list",
                "content": "Try to introduce my thoughts here.\\nLet\\'s look at the condition first.\\n```\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n```\\nIt can be swapped as \\n```\\n(nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff\\n```\\nTherefore, we can form a new vector by `vec[i] = nums1[i] - nums2[i]`.\\nOur problem becomes how to find all out pairs of [i, j] satisfying: \\n```\\nvec[i] <= vec[j] + diff\\n```\\nWe have two thoughts to tackle this problem.\\nThe first approach is to use BIT or Segment tree.\\nThe shortcoming for BIT is that it use spaces proportional to the value range of vec[i].\\nEx: if the value range becomes `-1e9 ~ 1e9`, it might not be a good choice to go for BIT.\\nBesides, original BIT index starting from value 1 so you need to shift the negative part to positive value.\\n\\nThis post uses MergeSort and its procedure to handle this problem.\\nIn MergeSort, you should always think of the merge process of two sorted arrays.\\n```\\narr1 = [i, i + 1, ...., mid]\\narr2 = [mid + 1, mid+2, ...., j]\\n```\\nBefore merge process, index in arr1 are all smaller than index in arr2, which means you can choose i from arr1 and j from arr2.\\nSo it\\'s suitable to caculate __\"How many pair count\"__ problem in merge process.\\nAs for this problem, you could easily use a sliding window to accmumulate the count in `O(N)`.\\nIt\\'s usually much harder to accumulate answer in merge process rather than how to write the MergeSort algo.\\nNote that one could use `inplace_merge` without reinventing the wheel of merge.\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        for (int i = 0; i < nums1.size(); i++)\\n            nums1[i] -= nums2[i];\\n    \\n        long long ans = 0;\\n        mergeSort(nums1, 0, nums1.size() - 1, ans, diff);\\n        return ans;\\n    }\\n    \\n    void mergeSort(vector<int> &nums, int i, int j, long long &ans, int diff) {\\n        if (i >= j) return;\\n        \\n        int mid = (i + j) / 2;      \\n        mergeSort(nums, i, mid, ans, diff);\\n        mergeSort(nums, mid + 1, j, ans, diff);\\n        \\n        int idx = i;\\n        for (int k = mid + 1; k <= j; k++) {\\n            while (idx <= mid && nums[idx] <= nums[k] + diff) {\\n                idx++;\\n            }\\n\\t\\t\\t// idx is the first index not satisfying nums[idx] <= nums[k] + diff\\n            ans += (idx - i);\\n        }\\n        \\n        inplace_merge(nums.begin() + i, nums.begin() + mid + 1, nums.begin() + j + 1);\\n    }  \\n};\\n```\\nTime complexity: `O(NlogN)` as mergeSort.\\nSpace complexity: `O(N)` as merge process requires additional storage.\\n\\nFor more similar problems to use MergeSort, you could find out the pattern here - they all ask __\"How many pair count\"__.\\n[315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)\\n[327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/)\\n[493. Reverse Pairs](https://leetcode.com/problems/reverse-pairs/)",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n```\n```\\n(nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff\\n```\n```\\nvec[i] <= vec[j] + diff\\n```\n```\\narr1 = [i, i + 1, ...., mid]\\narr2 = [mid + 1, mid+2, ...., j]\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        for (int i = 0; i < nums1.size(); i++)\\n            nums1[i] -= nums2[i];\\n    \\n        long long ans = 0;\\n        mergeSort(nums1, 0, nums1.size() - 1, ans, diff);\\n        return ans;\\n    }\\n    \\n    void mergeSort(vector<int> &nums, int i, int j, long long &ans, int diff) {\\n        if (i >= j) return;\\n        \\n        int mid = (i + j) / 2;      \\n        mergeSort(nums, i, mid, ans, diff);\\n        mergeSort(nums, mid + 1, j, ans, diff);\\n        \\n        int idx = i;\\n        for (int k = mid + 1; k <= j; k++) {\\n            while (idx <= mid && nums[idx] <= nums[k] + diff) {\\n                idx++;\\n            }\\n\\t\\t\\t// idx is the first index not satisfying nums[idx] <= nums[k] + diff\\n            ans += (idx - i);\\n        }\\n        \\n        inplace_merge(nums.begin() + i, nums.begin() + mid + 1, nums.begin() + j + 1);\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028715,
                "title": "c-merge-sort-based-solution-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long c=0;\\n    void Count(vector<int>&v,int start, int mid, int end,int d){\\n        int l=start, r=mid+1;\\n        while(l<=mid && r<=end){\\n            if(v[l]<=(v[r]+d)){\\n                //if a condition is satisfied for index r then it will be satisfied for all indices in the right side\\n                //as both left and right parts already sorted\\n                c+=(end-r+1);\\n                l++;\\n            }\\n            else{\\n                r++;\\n            }\\n        }\\n        //now sort the combined list to use in upper levels\\n        sort(v.begin()+start,v.begin()+end+1);\\n    }\\n    void mergeSort(vector<int>&v, int start, int end, int d){\\n        if(start==end){\\n            return;\\n        }\\n        //go deeper\\n        int mid=start+(end-start)/2;\\n        //call for left side\\n        //will go deeper to left side and the left side will be returned as a sorted list\\n        mergeSort(v,start,mid,d);\\n        //will go deeper to the right side and right side will be returned as a sorted list\\n        mergeSort(v,mid+1,end,d);\\n\\n        //now both left and right side are a sorted list\\n        //and the indices of left sides are less than right side\\n        //call the count function\\n        Count(v,start,mid,end,d);\\n\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>v;\\n        int n=nums1.size();\\n        //reduce the condition\\n        //nums1[i]-nums1[j]<=nums2[i]-nums2[j]+diff\\n        //nums1[i]-nums2[i]<=nums1[j]-nums2[j]+diff\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back(nums1[i]-nums2[i]);\\n        }\\n        mergeSort(v,0,n-1,diff);\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long c=0;\\n    void Count(vector<int>&v,int start, int mid, int end,int d){\\n        int l=start, r=mid+1;\\n        while(l<=mid && r<=end){\\n            if(v[l]<=(v[r]+d)){\\n                //if a condition is satisfied for index r then it will be satisfied for all indices in the right side\\n                //as both left and right parts already sorted\\n                c+=(end-r+1);\\n                l++;\\n            }\\n            else{\\n                r++;\\n            }\\n        }\\n        //now sort the combined list to use in upper levels\\n        sort(v.begin()+start,v.begin()+end+1);\\n    }\\n    void mergeSort(vector<int>&v, int start, int end, int d){\\n        if(start==end){\\n            return;\\n        }\\n        //go deeper\\n        int mid=start+(end-start)/2;\\n        //call for left side\\n        //will go deeper to left side and the left side will be returned as a sorted list\\n        mergeSort(v,start,mid,d);\\n        //will go deeper to the right side and right side will be returned as a sorted list\\n        mergeSort(v,mid+1,end,d);\\n\\n        //now both left and right side are a sorted list\\n        //and the indices of left sides are less than right side\\n        //call the count function\\n        Count(v,start,mid,end,d);\\n\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>v;\\n        int n=nums1.size();\\n        //reduce the condition\\n        //nums1[i]-nums1[j]<=nums2[i]-nums2[j]+diff\\n        //nums1[i]-nums2[i]<=nums1[j]-nums2[j]+diff\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back(nums1[i]-nums2[i]);\\n        }\\n        mergeSort(v,0,n-1,diff);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753655,
                "title": "python-binary-search-on-a-sorted-list-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs binary search on a maintainable sorted list for fast retrieval of index. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is constant: **O(N)**.\\n```\\nfrom sortedcontainers import SortedList\\nimport numpy as np\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \\n        # [1] it is easily observed that the problem for two arrays\\n        #     can be restated as a problem for a single array which\\n        #     equals to their sum;\\n        nums = np.array(nums1) - np.array(nums2)\\n        \\n        # [2] we use SortedList to keep seen numbers sorted\\n        seen = SortedList()\\n        count = 0\\n        \\n        for n in nums:\\n            # [3] for sorted lists, performing binary search allows\\n            #     to obtain the index of insertion in logN time;\\n            #     this index equals to the amount of numbers (i.e.,\\n            #     the amount of pairs) that satisfy the condition \\n            count += seen.bisect_right(n + diff)\\n            seen.add(n)\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nimport numpy as np\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \\n        # [1] it is easily observed that the problem for two arrays\\n        #     can be restated as a problem for a single array which\\n        #     equals to their sum;\\n        nums = np.array(nums1) - np.array(nums2)\\n        \\n        # [2] we use SortedList to keep seen numbers sorted\\n        seen = SortedList()\\n        count = 0\\n        \\n        for n in nums:\\n            # [3] for sorted lists, performing binary search allows\\n            #     to obtain the index of insertion in logN time;\\n            #     this index equals to the amount of numbers (i.e.,\\n            #     the amount of pairs) that satisfy the condition \\n            count += seen.bisect_right(n + diff)\\n            seen.add(n)\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743723,
                "title": "python-6-lines-binary-search-w-example-t-m-98-94",
                "content": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \\n        nums = [n1-n2 for n1, n2 in zip(nums1, nums2)]\\n                                                        #    Ex: nums1 = [3,-1,5,5]  ; nums2 = [-2,2,7,1] \\n        arr, ans = [], 0                                #        nums  = [5, -3, -2, 4]\\n                                                        #    \\n        for num in nums:                                #    num     arr           ans\\n            ans += bisect_right(arr, num + diff)        #    \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013\\n            insort(arr, num)                            #     5   [5]               0\\n                                                        #    -3   [-3, 5]           0\\n        return ans                                      #    -2   [-3, -2, 5]       1\\n                                                        #     4   [-3, -2, 4, 5]    4   <-- answer\\n```\\n[https://leetcode.com/submissions/detail/830122730/](http://)",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \\n        nums = [n1-n2 for n1, n2 in zip(nums1, nums2)]\\n                                                        #    Ex: nums1 = [3,-1,5,5]  ; nums2 = [-2,2,7,1] \\n        arr, ans = [], 0                                #        nums  = [5, -3, -2, 4]\\n                                                        #    \\n        for num in nums:                                #    num     arr           ans\\n            ans += bisect_right(arr, num + diff)        #    \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013\\n            insort(arr, num)                            #     5   [5]               0\\n                                                        #    -3   [-3, 5]           0\\n        return ans                                      #    -2   [-3, -2, 5]       1\\n                                                        #     4   [-3, -2, 4, 5]    4   <-- answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646928,
                "title": "c-solution-using-fenwick-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mx=300005+10;\\n    int bit[300005+10];\\n    void update(int i,int val)\\n    {\\n        while(i<mx)\\n        {\\n            bit[i]+=val;\\n            i=i+(i&-i);\\n        }\\n    }\\n    int find(int i)\\n    {\\n        int sum=0;\\n        while(i>0)\\n        {\\n            sum+=bit[i];\\n            i=i-(i&-i);\\n        }\\n        return sum;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff)\\n    {    \\n        int n=nums1.size();\\n        long long count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            count+=find(nums1[i]-nums2[i]+diff+80000);\\n            update(nums1[i]-nums2[i]+80000,1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mx=300005+10;\\n    int bit[300005+10];\\n    void update(int i,int val)\\n    {\\n        while(i<mx)\\n        {\\n            bit[i]+=val;\\n            i=i+(i&-i);\\n        }\\n    }\\n    int find(int i)\\n    {\\n        int sum=0;\\n        while(i>0)\\n        {\\n            sum+=bit[i];\\n            i=i-(i&-i);\\n        }\\n        return sum;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff)\\n    {    \\n        int n=nums1.size();\\n        long long count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            count+=find(nums1[i]-nums2[i]+diff+80000);\\n            update(nums1[i]-nums2[i]+80000,1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646733,
                "title": "c-o-nlogn-fast-and-easy-to-code-fenwick-tree",
                "content": "This question is a variation of Count inversions.\\n\\nIntuition ```v1[i] - v1[j] <= v2[i] - v2[j] + diff  ==> v1[i] - v2[i] <= v1[j] - v2[j] + diff```\\n\\nAt any index j, Ask query to count elements less than or equal to ```v1[j] - v2[j] + diff``` and add the result to answer.\\n\\nThen update the count for ```v1[i] - v2[i]```.\\n\\nTo keep the elements in positive range, we added 40005 to make it positive as we are only interested in the relative ordering of the elements.\\n    \\n```class Solution {\\npublic:\\n    vector< long >fen;\\n    void update( int i )\\n    {\\n        while(i < fen.size())\\n        {\\n            fen[i]++;\\n            i += (i&-i);\\n        }\\n    }\\n\\t\\n    long query( int i )\\n    {\\n        long ans=0;\\n        while(i>0)\\n        {\\n            ans += fen[i];\\n            i -= (i&-i);\\n        }\\n        return ans;\\n    }\\n\\t\\n    long long numberOfPairs(vector<int>& v1, vector<int>& v2, int diff) {\\n        int N=40005;\\n        fen.assign( 100000 , 0);\\n        int n = v1.size();\\n        long long ans = 0;\\n        for ( int i = 0 ; i < n ; i++ )\\n        {\\n            ans += query( v1[i] - v2[i] + diff + N );\\n            update(v1[i] - v2[i] + N);\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```v1[i] - v1[j] <= v2[i] - v2[j] + diff  ==> v1[i] - v2[i] <= v1[j] - v2[j] + diff```\n```v1[j] - v2[j] + diff```\n```v1[i] - v2[i]```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646544,
                "title": "sortedlist-in-python-with-explanation-and-complexities",
                "content": "##### Rationale\\n* We could rearrage the given equation from `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff` to `nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff` or `a <= b + diff`, where, for instance, `a = nums1[i] - nums2[i]`\\n* The problem has been reduced to: \"For every number b, find all the numbers to its left that are `<= b + diff`\"\\n* Implementation:\\n\\t* Let\\'s build a `reduced_array` with `nums1[i] - nums2[i]` from the two arrays\\n\\t* Use a `SortedList` to find all the numbers that are `<= b + diff` in `logn` time\\n\\n##### Complexities\\n* Time: `O(nlogn)`\\n* Space: `O(n)`\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        sorted_list = SortedList()\\n        count = 0\\n\\t\\t\\n\\t\\treduced_array = [a - b for a, b in zip(nums1, nums2)]\\n        \\n        for num in reduced_array:\\n            smaller = sorted_list.bisect_right(num + diff)\\n            count += smaller\\n\\t\\t\\t\\n\\t\\t\\tsorted_list.add(num)\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        sorted_list = SortedList()\\n        count = 0\\n\\t\\t\\n\\t\\treduced_array = [a - b for a, b in zip(nums1, nums2)]\\n        \\n        for num in reduced_array:\\n            smaller = sorted_list.bisect_right(num + diff)\\n            count += smaller\\n\\t\\t\\t\\n\\t\\t\\tsorted_list.add(num)\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646512,
                "title": "simple-c-solution-using-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    long long d,cnt=0;\\n    void merge(int s,int m,int e,vector<int>& v) {\\n        vector<int> v1,v2;\\n        for (int i=s;i<=m;i++) v1.push_back(v[i]);\\n        for (int i=m+1;i<=e;i++) v2.push_back(v[i]);\\n        int i=0,j=0,k=s;\\n        while (j<v2.size()) {\\n            while (i<v1.size()&&v1[i]-d<=v2[j]) i++;\\n            j++;\\n            cnt+=i;\\n        }\\n        i=0,j=0;\\n        while (i<v1.size()&&j<v2.size()) {\\n            if (v1[i]<v2[j]) {\\n                v[k++]=v1[i++];\\n            }\\n            else {\\n                v[k++]=v2[j++];\\n            }\\n        }\\n        if (i==v1.size()) {\\n            while (j<v2.size()) v[k++]=v2[j++];\\n        }\\n        else {\\n            while (i<v1.size()) v[k++]=v1[i++];\\n        }\\n    }\\n    void mergeSort(int s,int e,vector<int> &nums1) {\\n        if (s>=e) return;\\n        int m=(s+e)>>1;\\n        mergeSort(s,m,nums1);\\n        mergeSort(m+1,e,nums1);\\n        merge(s,m,e,nums1);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        d=diff;\\n        for (int i=0;i<nums1.size();i++) {\\n            nums1[i]-=nums2[i];\\n        }\\n        mergeSort(0,nums1.size()-1,nums1);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long d,cnt=0;\\n    void merge(int s,int m,int e,vector<int>& v) {\\n        vector<int> v1,v2;\\n        for (int i=s;i<=m;i++) v1.push_back(v[i]);\\n        for (int i=m+1;i<=e;i++) v2.push_back(v[i]);\\n        int i=0,j=0,k=s;\\n        while (j<v2.size()) {\\n            while (i<v1.size()&&v1[i]-d<=v2[j]) i++;\\n            j++;\\n            cnt+=i;\\n        }\\n        i=0,j=0;\\n        while (i<v1.size()&&j<v2.size()) {\\n            if (v1[i]<v2[j]) {\\n                v[k++]=v1[i++];\\n            }\\n            else {\\n                v[k++]=v2[j++];\\n            }\\n        }\\n        if (i==v1.size()) {\\n            while (j<v2.size()) v[k++]=v2[j++];\\n        }\\n        else {\\n            while (i<v1.size()) v[k++]=v1[i++];\\n        }\\n    }\\n    void mergeSort(int s,int e,vector<int> &nums1) {\\n        if (s>=e) return;\\n        int m=(s+e)>>1;\\n        mergeSort(s,m,nums1);\\n        mergeSort(m+1,e,nums1);\\n        merge(s,m,e,nums1);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        d=diff;\\n        for (int i=0;i<nums1.size();i++) {\\n            nums1[i]-=nums2[i];\\n        }\\n        mergeSort(0,nums1.size()-1,nums1);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646498,
                "title": "c-python-java-binary-indexed-tree-with-explanation",
                "content": "Let\\'s redefine the requirements a bit\\nCondition 2 states that:\\n```nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff```\\nLet\\'s move `j` to the left and `i` to the right, it becomes:\\n```nums2[j] - nums1[j] <= nums2[i] - nums1[i] + diff```\\nLet\\'s call `nums2[j] - nums1[j]` -> `nums_diff[j]`, so the condition becomes:\\n```nums_diff[j] <= nums_diff[i] + diff```\\n\\n\\nSince condition 1 states that `i < j`, the new requirements become:\\n> For every index `i`, count many indices greater than `i` that have `nums_diff[j] <= nums_diff[i] + diff`\\n\\nWe use a `binary indexed tree` to calculate and update the counts in `O(logN)`\\n\\nAlgo:\\n- For every index `i` from `n - 1` to `0` (to satisfy condition 1).\\n  - get the sum for all `values <= nums_diff[i] + diff`\\n  - update `nums_diff[i]` in the tree.\\n\\nWhen storing the numbers in the binary indexed tree, we ***shift*** them all by a fixed value to avoid negative numbers.\\n\\n\\n#### C++\\n```c++\\nint query(vector<int>& tree, int index) {\\n  int ans = 0;\\n  index++;\\n\\n  while (index > 0) {\\n    ans += tree[index];\\n    index -= index & (-index);\\n  }\\n  return ans;\\n}\\n\\nvoid update(vector<int>& tree, int index, int size) {\\n  index++;\\n  while (index <= size) {\\n    tree[index] += 1;\\n    index += index & (-index);\\n  }\\n}\\n\\nclass Solution {\\n public:\\n  long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n    int shift = 20000;\\n    int mx = 100000;\\n    vector<int> tree(mx + 1);\\n    long long res = 0;\\n\\n    for (int i = nums1.size() - 1; i >= 0; --i) {\\n      int k = nums2[i] - nums1[i];\\n      res += query(tree, k + diff + shift);\\n      update(tree, k + shift, mx);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\\n\\n\\n#### Python\\n```python\\ndef query(tree, index):\\n  ans = 0\\n  index += 1\\n\\n  while index > 0:\\n    ans += tree[index]\\n    index -= index & (-index)\\n\\n  return ans\\n\\ndef update(tree, index, size):\\n  index += 1\\n  while index <= size:\\n    tree[index] += 1\\n    index += index & (-index)\\n\\nclass Solution:\\n  def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n    shift = 20000\\n    mx = 100000\\n    tree = [0] * (mx + 1)\\n    res = 0\\n    for i in range(len(nums1) - 1, -1, -1):\\n      k = nums2[i] - nums1[i]\\n      res += query(tree, k + diff + shift)\\n      update(tree, k + shift, mx)\\n\\n    return res\\n```\\n\\n#### Java\\n```java\\nclass Solution {\\n  int query(int[] tree, int index) {\\n    int ans = 0;\\n    index++;\\n\\n    while (index > 0) {\\n      ans += tree[index];\\n      index -= index & (-index);\\n    }\\n    return ans;\\n  }\\n\\n  void update(int[] tree, int index, int size) {\\n    index++;\\n    while (index <= size) {\\n      tree[index] += 1;\\n      index += index & (-index);\\n    }\\n  }\\n\\n  public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n    int shift = 20000;\\n    int mx = 100000;\\n    int[] tree = new int[mx + 1];\\n    long res = 0;\\n\\n    for (int i = nums1.length - 1; i >= 0; --i) {\\n      int k = nums2[i] - nums1[i];\\n      res += query(tree, k + diff + shift);\\n      update(tree, k + shift, mx);\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n\\n\\n**Upvote if you find it helpful :)**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Indexed Tree"
                ],
                "code": "```nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff```\n```nums2[j] - nums1[j] <= nums2[i] - nums1[i] + diff```\n```nums_diff[j] <= nums_diff[i] + diff```\n```c++\\nint query(vector<int>& tree, int index) {\\n  int ans = 0;\\n  index++;\\n\\n  while (index > 0) {\\n    ans += tree[index];\\n    index -= index & (-index);\\n  }\\n  return ans;\\n}\\n\\nvoid update(vector<int>& tree, int index, int size) {\\n  index++;\\n  while (index <= size) {\\n    tree[index] += 1;\\n    index += index & (-index);\\n  }\\n}\\n\\nclass Solution {\\n public:\\n  long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n    int shift = 20000;\\n    int mx = 100000;\\n    vector<int> tree(mx + 1);\\n    long long res = 0;\\n\\n    for (int i = nums1.size() - 1; i >= 0; --i) {\\n      int k = nums2[i] - nums1[i];\\n      res += query(tree, k + diff + shift);\\n      update(tree, k + shift, mx);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\n```python\\ndef query(tree, index):\\n  ans = 0\\n  index += 1\\n\\n  while index > 0:\\n    ans += tree[index]\\n    index -= index & (-index)\\n\\n  return ans\\n\\ndef update(tree, index, size):\\n  index += 1\\n  while index <= size:\\n    tree[index] += 1\\n    index += index & (-index)\\n\\nclass Solution:\\n  def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n    shift = 20000\\n    mx = 100000\\n    tree = [0] * (mx + 1)\\n    res = 0\\n    for i in range(len(nums1) - 1, -1, -1):\\n      k = nums2[i] - nums1[i]\\n      res += query(tree, k + diff + shift)\\n      update(tree, k + shift, mx)\\n\\n    return res\\n```\n```java\\nclass Solution {\\n  int query(int[] tree, int index) {\\n    int ans = 0;\\n    index++;\\n\\n    while (index > 0) {\\n      ans += tree[index];\\n      index -= index & (-index);\\n    }\\n    return ans;\\n  }\\n\\n  void update(int[] tree, int index, int size) {\\n    index++;\\n    while (index <= size) {\\n      tree[index] += 1;\\n      index += index & (-index);\\n    }\\n  }\\n\\n  public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n    int shift = 20000;\\n    int mx = 100000;\\n    int[] tree = new int[mx + 1];\\n    long res = 0;\\n\\n    for (int i = nums1.length - 1; i >= 0; --i) {\\n      int k = nums2[i] - nums1[i];\\n      res += query(tree, k + diff + shift);\\n      update(tree, k + shift, mx);\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646493,
                "title": "rearrange-expression-and-binary-search",
                "content": "```\\nimport bisect\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        n = len(nums1)\\n        d = []\\n        for i in range(n):\\n            d.append(nums1[i] - nums2[i])\\n        res = 0\\n        order = []\\n        for i in range(n - 1, -1, -1):\\n            res += len(order) - bisect.bisect_left(order, d[i] - diff)\\n            bisect.insort(order, d[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        n = len(nums1)\\n        d = []\\n        for i in range(n):\\n            d.append(nums1[i] - nums2[i])\\n        res = 0\\n        order = []\\n        for i in range(n - 1, -1, -1):\\n            res += len(order) - bisect.bisect_left(order, d[i] - diff)\\n            bisect.insort(order, d[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369458,
                "title": "detailed-explanation-3-approaches-merge-sort-segment-tree-bit-o-nlogn-multiple-languages",
                "content": "# Intuition & Approach for BIT/Fenwick Tree:\\nThe Expression `A[i] - A[j] <= B[i] - B[j] + diff` can be written as `A[i] - B[i] - A[j] + B[j] <= diff`\\n=> `A[i] - B[i] - (A[j] - B[j]) <=diff`\\n=> `X[i] - X[j] <= diff`, where `X[k] = A[k] - B[k]`\\n\\nFrom the above expression we can see that we need to find a pair of `(i,j)` in `X`, such that it\\'s less than or equal to diff. And `X[k]` can be calculated by doing `A[k]-B[k]` for all the array elements.\\n\\nWe will be using **BIT** here to solve the problem. The idea is to for every `j` try to find all such `i`, such that  `X[i] - X[j] <= diff` is satisfied. This will implicitly ensure `i < j`. So, for every `X[j]`, we will try to find all `X[i]` in the range `[1 to (X[j] + diff)]`. Once the count is obtained. We update the BIT with `X[j]` so that it will get considered as a candidate for `X[i]`, for any future values of `X[j]`.\\n\\nAlso, Since the input can contain both `+ve` & `-ve` numbers. We will shift all numbers to the right by adding some constant to all the numbers, such that the smallest number in the input range gets mapped to `1`. second smallest in the input range gets mapped to `2` and so on.\\n\\nHere, we are using `30001` for shift, `20001` is to handle the `-10000 to +10000` range and additional `10000` to handle diff value of the range `-10000 to 10000`.\\n\\n# Complexity\\n- Time complexity:\\n`O(n + nlog(n)) = O(nlog(n))`, `n` is the size of the input array.\\n\\n- Space complexity:\\n`O(n)`,  where `n` is the length of the input array.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingBIT().numberOfPairs(A, B, diff);\\n    }\\n}\\nclass UsingBIT {\\n\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        int SHIFT = 30001;\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = A[i] - B[i] + SHIFT;\\n        }\\n        int[] BIT = new int[SHIFT * 2 + 1];\\n        long count = 0;\\n        for (int j : A) {\\n            count += query(BIT, j + diff);\\n            update(BIT, j);\\n        }\\n        return count;\\n    }\\n\\n    private int query(int[] BIT, int n) {\\n        int count = 0;\\n        while (n >= 1) {\\n            count += BIT[n];\\n            n -= (n & -n);\\n        }\\n        return count;\\n    }\\n\\n    private void update(int[] BIT, int n) {\\n        while (n < BIT.length) {\\n            BIT[n]++;\\n            n += (n & -n);\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        return UsingBIT().numberOfPairs(A, B, diff)\\n\\nclass UsingBIT:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        SHIFT = 30001\\n        for i in range(len(A)):\\n            A[i] = A[i] - B[i] + SHIFT\\n        BIT = [0] * (SHIFT * 2 + 1)\\n        count = 0\\n        for j in A:\\n            count += self.query(BIT, j + diff)\\n            self.update(BIT, j)\\n        return count\\n\\n    def query(self, BIT: List[int], n: int) -> int:\\n        count = 0\\n        while n >= 1:\\n            count += BIT[n]\\n            n -= (n & -n)\\n        return count\\n\\n    def update(self, BIT: List[int], n: int) -> None:\\n        while n < len(BIT):\\n            BIT[n] += 1\\n            n += (n & -n)\\n```\\n```cpp []\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        return UsingBIT().numberOfPairs(A, B, diff);\\n    }\\n};\\n\\nclass UsingBIT {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        int SHIFT = 30001;\\n        for (int i = 0; i < A.size(); i++) {\\n            A[i] = A[i] - B[i] + SHIFT;\\n        }\\n        vector<int> BIT(SHIFT * 2 + 1);\\n        long long count = 0;\\n        for (int j : A) {\\n            count += query(BIT, j + diff);\\n            update(BIT, j);\\n        }\\n        return count;\\n    }\\n\\nprivate:\\n    int query(vector<int>& BIT, int n) {\\n        int count = 0;\\n        while (n >= 1) {\\n            count += BIT[n];\\n            n -= (n & -n);\\n        }\\n        return count;\\n    }\\n\\n    void update(vector<int>& BIT, int n) {\\n        while (n < BIT.size()) {\\n            BIT[n]++;\\n            n += (n & -n);\\n        }\\n    }\\n};\\n```\\n---\\n# Intuition & Approach for Segment Tree:\\nThe Expression `A[i] - A[j] <= B[i] - B[j] + diff` can be written as `A[i] - B[i] - A[j] + B[j] <= diff`\\n=> `A[i] - B[i] - (A[j] - B[j]) <=diff`\\n=> `X[i] - X[j] <= diff`, where `X[k] = A[k] - B[k]`\\n\\nFrom the above expression we can see that we need to find a pair of `(i,j)` in `X`, such that it\\'s less than or equal to diff. And `X[k]` can be calculated by doing `A[k]-B[k]` for all the array elements.\\n\\nWe will be using **Segment Tree** here to solve the problem. The idea is to for every `j` try to find all such `i`, such that  `X[i] - X[j] <= diff` is satisfied. This will implicitly ensure `i < j`. So, for every `X[j]`, we will try to find all `X[i]` in the range `[1 to (X[j] + diff)]`. Once the count is obtained. We update the Segment tree with `X[j]` so that it will get considered as a candidate for `X[i]`, for any future values of `X[j]`.\\n\\nAlso, Since the input can contain both `+ve` & `-ve` numbers. We will shift all numbers to the right by adding some constant to all the numbers, such that the smallest number in the input range gets mapped to `1`. second smallest in the input range gets mapped to `2` and so on.\\n\\nHere, we are using `30001` for shift, `20001` is to handle the `-10000 to +10000` range and additional `10000` to handle diff value of the range `-10000 to 10000`.\\n\\n# Complexity\\n- Time complexity:\\n`O(n + nlog(n)) = O(nlog(n))`, `n` is the size of the input array.\\n\\n- Space complexity:\\n`O(n)`, `n` is the size of the input array.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingSegmentTree().numberOfPairs(A, B, diff);\\n    }\\n}\\nclass UsingSegmentTree {\\n\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        int SHIFT = 30001;\\n        int n = 50001;\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = A[i] - B[i] + SHIFT;\\n        }\\n        int[] segmentTree = new int[n * 4 + 1];\\n        long count = 0;\\n        for (int j : A) {\\n            count += query(segmentTree, 1, 1, n, 1, j + diff);\\n            update(segmentTree, 1, 1, n, j);\\n        }\\n        return count;\\n    }\\n\\n    private void update(int[] segmentTree, int index, int start, int end, int updateIndex) {\\n        if (start == end) {\\n            segmentTree[index]++;\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        if (updateIndex <= mid) update(segmentTree, index * 2, start, mid, updateIndex);\\n        else update(segmentTree, index * 2 + 1, mid + 1, end, updateIndex);\\n        segmentTree[index] = segmentTree[index * 2] + segmentTree[index * 2 + 1];\\n    }\\n\\n    private int query(int[] segmentTree, int index, int start, int end, int queryStart, int queryEnd) {\\n        if (end < start || start > queryEnd) return 0;\\n        if (start >= queryStart && end <= queryEnd) return segmentTree[index];\\n        int mid = start + (end - start) / 2;\\n        int left = query(segmentTree, index * 2, start, mid, queryStart, queryEnd);\\n        int right = query(segmentTree, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n        return left + right;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        return UsingSegmentTree().numberOfPairs(A, B, diff)\\n\\nclass UsingSegmentTree:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        SHIFT = 30001\\n        n = 50001\\n        for i in range(len(A)):\\n            A[i] = A[i] - B[i] + SHIFT\\n        segmentTree = [0] * (n * 4 + 1)\\n        count = 0\\n        for j in A:\\n            count += self.query(segmentTree, 1, 1, n, 1, j + diff)\\n            self.update(segmentTree, 1, 1, n, j)\\n        return count\\n\\n    def update(self, segmentTree: List[int], index: int, start: int, end: int, updateIndex: int) -> None:\\n        if start == end:\\n            segmentTree[index] += 1\\n            return\\n        mid = start + (end - start) // 2\\n        if updateIndex <= mid:\\n            self.update(segmentTree, index * 2, start, mid, updateIndex)\\n        else:\\n            self.update(segmentTree, index * 2 + 1, mid + 1, end, updateIndex)\\n        segmentTree[index] = segmentTree[index * 2] + segmentTree[index * 2 + 1]\\n\\n    def query(self, segmentTree: List[int], index: int, start: int, end: int, queryStart: int, queryEnd: int) -> int:\\n        if end < start or start > queryEnd:\\n            return 0\\n        if start >= queryStart and end <= queryEnd:\\n            return segmentTree[index]\\n        mid = start + (end - start) // 2\\n        left = self.query(segmentTree, index * 2, start, mid, queryStart, queryEnd)\\n        right = self.query(segmentTree, index * 2 + 1, mid + 1, end, queryStart, queryEnd)\\n        return left + right\\n```\\n```cpp []\\n#include <vector>\\nusing namespace std;\\n\\nclass UsingSegmentTree {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        const int SHIFT = 30001;\\n        const int n = 50001;\\n        for (int i = 0; i < A.size(); i++) {\\n            A[i] = A[i] - B[i] + SHIFT;\\n        }\\n        vector<int> segmentTree(n * 4 + 1);\\n        long long count = 0;\\n        for (int j : A) {\\n            count += query(segmentTree, 1, 1, n, 1, j + diff);\\n            update(segmentTree, 1, 1, n, j);\\n        }\\n        return count;\\n    }\\n\\nprivate:\\n    void update(vector<int>& segmentTree, int index, int start, int end, int updateIndex) {\\n        if (start == end) {\\n            segmentTree[index]++;\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        if (updateIndex <= mid) update(segmentTree, index * 2, start, mid, updateIndex);\\n        else update(segmentTree, index * 2 + 1, mid + 1, end, updateIndex);\\n        segmentTree[index] = segmentTree[index * 2] + segmentTree[index * 2 + 1];\\n    }\\n\\n    int query(vector<int>& segmentTree, int index, int start, int end, int queryStart, int queryEnd) {\\n        if (end < start || start > queryEnd) return 0;\\n        if (start >= queryStart && end <= queryEnd) return segmentTree[index];\\n        int mid = start + (end - start) / 2;\\n        int left = query(segmentTree, index * 2, start, mid, queryStart, queryEnd);\\n        int right = query(segmentTree, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n        return left + right;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        UsingSegmentTree usingSegmentTree;\\n        return usingSegmentTree.numberOfPairs(nums1, nums2, diff);\\n    }\\n};\\n```\\n---\\n# Intuition & Approach for Merge Sort:\\nThe Expression `A[i] - A[j] <= B[i] - B[j] + diff` can be written as `A[i] - B[i] - A[j] + B[j] <= diff`\\n=> `A[i] - B[i] - (A[j] - B[j]) <=diff`\\n=> `X[i] - X[j] <= diff`, where `X[k] = A[k] - B[k]`\\n=> `X[i] - diff <= X[j]`\\n\\nFrom the above expression, we can see that we need to find a pair of `(i,j)` in `X` such that it is less than or equal to `diff`. `X[k]` can be calculated by subtracting `B[k]` from `A[k]` for all the array elements.\\n\\nWe will be using Merge Sort to solve the problem. The idea is to use the merge step of merge sort. For every `X[i]` in the left sorted half, we find all `X[j]` in the right sorted half such that `X[j] >= X[i] - diff`. This ensures that `i < j`, since all the elements on the left half have indices less than those on the right half.\\n\\nOnce we obtain the count, we combine the left and right halves to create a sorted array using the normal merge sort merge step.\\n\\n# Complexity\\n- Time complexity:\\n`O(n log n)`, where `n` is the length of the input array.\\n\\n- Space complexity:\\n`O(n)`,  where `n` is the length of the input array.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingMergeSort().numberOfPairs(A, B, diff);\\n    }\\n}\\nclass UsingMergeSort {\\n\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = A[i] - B[i];\\n        }\\n        return mergeSort(A, 0, A.length - 1, diff);\\n    }\\n\\n    private long mergeSort(int[] arr, int start, int end, int diff) {\\n        if (start >= end) return 0;\\n        int mid = start + (end - start) / 2;\\n        long count = 0;\\n        count += mergeSort(arr, start, mid, diff);\\n        count += mergeSort(arr, mid + 1, end, diff);\\n        count += merge(arr, start, mid, end, diff);\\n        return count;\\n    }\\n\\n    private long merge(int[] arr, int start, int mid, int end, int diff) {\\n        int j = mid + 1, k = mid + 1, sortedIndex = 0;\\n        int[] sorted = new int[end - start + 1];\\n        long count = 0;\\n        for (int i = start; i <= mid; i++) {\\n            while (k <= end && arr[i] - diff > arr[k]) k++;\\n            count += end - k + 1;\\n            while (j <= end && arr[j] < arr[i]) {\\n                sorted[sortedIndex++] = arr[j++];\\n            }\\n            sorted[sortedIndex++] = arr[i];\\n        }\\n        while (j <= end) {\\n            sorted[sortedIndex++] = arr[j++];\\n        }\\n        for (int i = start, index = 0; i <= end; i++, index++) {\\n            arr[i] = sorted[index];\\n        }\\n        return count;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        return UsingMergeSort().numberOfPairs(A, B, diff)\\n    \\nclass UsingMergeSort:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        for i in range(len(A)):\\n            A[i] = A[i] - B[i]\\n        return self.mergeSort(A, 0, len(A)-1, diff)\\n\\n    def mergeSort(self, arr: List[int], start: int, end: int, diff: int) -> int:\\n        if start >= end:\\n            return 0\\n        mid = start + (end - start) // 2\\n        count = 0\\n        count += self.mergeSort(arr, start, mid, diff)\\n        count += self.mergeSort(arr, mid+1, end, diff)\\n        count += self.merge(arr, start, mid, end, diff)\\n        return count\\n\\n    def merge(self, arr: List[int], start: int, mid: int, end: int, diff: int) -> int:\\n        j, k, sortedIndex = mid+1, mid+1, 0\\n        sortedList = [0] * (end-start+1)\\n        count = 0\\n        for i in range(start, mid+1):\\n            while k <= end and arr[i] - diff > arr[k]:\\n                k += 1\\n            count += end - k + 1\\n            while j <= end and arr[j] < arr[i]:\\n                sortedList[sortedIndex] = arr[j]\\n                sortedIndex += 1\\n                j += 1\\n            sortedList[sortedIndex] = arr[i]\\n            sortedIndex += 1\\n        while j <= end:\\n            sortedList[sortedIndex] = arr[j]\\n            sortedIndex += 1\\n            j += 1\\n        for i in range(start, end+1):\\n            arr[i] = sortedList[i-start]\\n        return count\\n```\\n```cpp []\\n#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass UsingMergeSort {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        int n = A.size();\\n        vector<int> arr(n);\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = A[i] - B[i];\\n        }\\n        return mergeSort(arr, 0, n - 1, diff);\\n    }\\n\\nprivate:\\n    long long mergeSort(vector<int>& arr, int start, int end, int diff) {\\n        if (start >= end) return 0;\\n        int mid = start + (end - start) / 2;\\n        long long count = 0;\\n        count += mergeSort(arr, start, mid, diff);\\n        count += mergeSort(arr, mid + 1, end, diff);\\n        count += merge(arr, start, mid, end, diff);\\n        return count;\\n    }\\n\\n    long long merge(vector<int>& arr, int start, int mid, int end, int diff) {\\n        int j = mid + 1, k = mid + 1, sortedIndex = 0;\\n        int n = end - start + 1;\\n        vector<int> sorted(n);\\n        long long count = 0;\\n        for (int i = start; i <= mid; i++) {\\n            while (k <= end && arr[i] - diff > arr[k]) k++;\\n            count += end - k + 1;\\n            while (j <= end && arr[j] < arr[i]) {\\n                sorted[sortedIndex++] = arr[j++];\\n            }\\n            sorted[sortedIndex++] = arr[i];\\n        }\\n        while (j <= end) {\\n            sorted[sortedIndex++] = arr[j++];\\n        }\\n        for (int i = start, index = 0; i <= end; i++, index++) {\\n            arr[i] = sorted[index];\\n        }\\n        return count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        return UsingMergeSort().numberOfPairs(A, B, diff);\\n    }\\n};\\n```\\n---",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Binary Indexed Tree",
                    "Segment Tree",
                    "Merge Sort"
                ],
                "code": "```java []\\nclass Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingBIT().numberOfPairs(A, B, diff);\\n    }\\n}\\nclass UsingBIT {\\n\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        int SHIFT = 30001;\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = A[i] - B[i] + SHIFT;\\n        }\\n        int[] BIT = new int[SHIFT * 2 + 1];\\n        long count = 0;\\n        for (int j : A) {\\n            count += query(BIT, j + diff);\\n            update(BIT, j);\\n        }\\n        return count;\\n    }\\n\\n    private int query(int[] BIT, int n) {\\n        int count = 0;\\n        while (n >= 1) {\\n            count += BIT[n];\\n            n -= (n & -n);\\n        }\\n        return count;\\n    }\\n\\n    private void update(int[] BIT, int n) {\\n        while (n < BIT.length) {\\n            BIT[n]++;\\n            n += (n & -n);\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        return UsingBIT().numberOfPairs(A, B, diff)\\n\\nclass UsingBIT:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        SHIFT = 30001\\n        for i in range(len(A)):\\n            A[i] = A[i] - B[i] + SHIFT\\n        BIT = [0] * (SHIFT * 2 + 1)\\n        count = 0\\n        for j in A:\\n            count += self.query(BIT, j + diff)\\n            self.update(BIT, j)\\n        return count\\n\\n    def query(self, BIT: List[int], n: int) -> int:\\n        count = 0\\n        while n >= 1:\\n            count += BIT[n]\\n            n -= (n & -n)\\n        return count\\n\\n    def update(self, BIT: List[int], n: int) -> None:\\n        while n < len(BIT):\\n            BIT[n] += 1\\n            n += (n & -n)\\n```\n```cpp []\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        return UsingBIT().numberOfPairs(A, B, diff);\\n    }\\n};\\n\\nclass UsingBIT {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        int SHIFT = 30001;\\n        for (int i = 0; i < A.size(); i++) {\\n            A[i] = A[i] - B[i] + SHIFT;\\n        }\\n        vector<int> BIT(SHIFT * 2 + 1);\\n        long long count = 0;\\n        for (int j : A) {\\n            count += query(BIT, j + diff);\\n            update(BIT, j);\\n        }\\n        return count;\\n    }\\n\\nprivate:\\n    int query(vector<int>& BIT, int n) {\\n        int count = 0;\\n        while (n >= 1) {\\n            count += BIT[n];\\n            n -= (n & -n);\\n        }\\n        return count;\\n    }\\n\\n    void update(vector<int>& BIT, int n) {\\n        while (n < BIT.size()) {\\n            BIT[n]++;\\n            n += (n & -n);\\n        }\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingSegmentTree().numberOfPairs(A, B, diff);\\n    }\\n}\\nclass UsingSegmentTree {\\n\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        int SHIFT = 30001;\\n        int n = 50001;\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = A[i] - B[i] + SHIFT;\\n        }\\n        int[] segmentTree = new int[n * 4 + 1];\\n        long count = 0;\\n        for (int j : A) {\\n            count += query(segmentTree, 1, 1, n, 1, j + diff);\\n            update(segmentTree, 1, 1, n, j);\\n        }\\n        return count;\\n    }\\n\\n    private void update(int[] segmentTree, int index, int start, int end, int updateIndex) {\\n        if (start == end) {\\n            segmentTree[index]++;\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        if (updateIndex <= mid) update(segmentTree, index * 2, start, mid, updateIndex);\\n        else update(segmentTree, index * 2 + 1, mid + 1, end, updateIndex);\\n        segmentTree[index] = segmentTree[index * 2] + segmentTree[index * 2 + 1];\\n    }\\n\\n    private int query(int[] segmentTree, int index, int start, int end, int queryStart, int queryEnd) {\\n        if (end < start || start > queryEnd) return 0;\\n        if (start >= queryStart && end <= queryEnd) return segmentTree[index];\\n        int mid = start + (end - start) / 2;\\n        int left = query(segmentTree, index * 2, start, mid, queryStart, queryEnd);\\n        int right = query(segmentTree, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n        return left + right;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        return UsingSegmentTree().numberOfPairs(A, B, diff)\\n\\nclass UsingSegmentTree:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        SHIFT = 30001\\n        n = 50001\\n        for i in range(len(A)):\\n            A[i] = A[i] - B[i] + SHIFT\\n        segmentTree = [0] * (n * 4 + 1)\\n        count = 0\\n        for j in A:\\n            count += self.query(segmentTree, 1, 1, n, 1, j + diff)\\n            self.update(segmentTree, 1, 1, n, j)\\n        return count\\n\\n    def update(self, segmentTree: List[int], index: int, start: int, end: int, updateIndex: int) -> None:\\n        if start == end:\\n            segmentTree[index] += 1\\n            return\\n        mid = start + (end - start) // 2\\n        if updateIndex <= mid:\\n            self.update(segmentTree, index * 2, start, mid, updateIndex)\\n        else:\\n            self.update(segmentTree, index * 2 + 1, mid + 1, end, updateIndex)\\n        segmentTree[index] = segmentTree[index * 2] + segmentTree[index * 2 + 1]\\n\\n    def query(self, segmentTree: List[int], index: int, start: int, end: int, queryStart: int, queryEnd: int) -> int:\\n        if end < start or start > queryEnd:\\n            return 0\\n        if start >= queryStart and end <= queryEnd:\\n            return segmentTree[index]\\n        mid = start + (end - start) // 2\\n        left = self.query(segmentTree, index * 2, start, mid, queryStart, queryEnd)\\n        right = self.query(segmentTree, index * 2 + 1, mid + 1, end, queryStart, queryEnd)\\n        return left + right\\n```\n```cpp []\\n#include <vector>\\nusing namespace std;\\n\\nclass UsingSegmentTree {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        const int SHIFT = 30001;\\n        const int n = 50001;\\n        for (int i = 0; i < A.size(); i++) {\\n            A[i] = A[i] - B[i] + SHIFT;\\n        }\\n        vector<int> segmentTree(n * 4 + 1);\\n        long long count = 0;\\n        for (int j : A) {\\n            count += query(segmentTree, 1, 1, n, 1, j + diff);\\n            update(segmentTree, 1, 1, n, j);\\n        }\\n        return count;\\n    }\\n\\nprivate:\\n    void update(vector<int>& segmentTree, int index, int start, int end, int updateIndex) {\\n        if (start == end) {\\n            segmentTree[index]++;\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        if (updateIndex <= mid) update(segmentTree, index * 2, start, mid, updateIndex);\\n        else update(segmentTree, index * 2 + 1, mid + 1, end, updateIndex);\\n        segmentTree[index] = segmentTree[index * 2] + segmentTree[index * 2 + 1];\\n    }\\n\\n    int query(vector<int>& segmentTree, int index, int start, int end, int queryStart, int queryEnd) {\\n        if (end < start || start > queryEnd) return 0;\\n        if (start >= queryStart && end <= queryEnd) return segmentTree[index];\\n        int mid = start + (end - start) / 2;\\n        int left = query(segmentTree, index * 2, start, mid, queryStart, queryEnd);\\n        int right = query(segmentTree, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n        return left + right;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        UsingSegmentTree usingSegmentTree;\\n        return usingSegmentTree.numberOfPairs(nums1, nums2, diff);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingMergeSort().numberOfPairs(A, B, diff);\\n    }\\n}\\nclass UsingMergeSort {\\n\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = A[i] - B[i];\\n        }\\n        return mergeSort(A, 0, A.length - 1, diff);\\n    }\\n\\n    private long mergeSort(int[] arr, int start, int end, int diff) {\\n        if (start >= end) return 0;\\n        int mid = start + (end - start) / 2;\\n        long count = 0;\\n        count += mergeSort(arr, start, mid, diff);\\n        count += mergeSort(arr, mid + 1, end, diff);\\n        count += merge(arr, start, mid, end, diff);\\n        return count;\\n    }\\n\\n    private long merge(int[] arr, int start, int mid, int end, int diff) {\\n        int j = mid + 1, k = mid + 1, sortedIndex = 0;\\n        int[] sorted = new int[end - start + 1];\\n        long count = 0;\\n        for (int i = start; i <= mid; i++) {\\n            while (k <= end && arr[i] - diff > arr[k]) k++;\\n            count += end - k + 1;\\n            while (j <= end && arr[j] < arr[i]) {\\n                sorted[sortedIndex++] = arr[j++];\\n            }\\n            sorted[sortedIndex++] = arr[i];\\n        }\\n        while (j <= end) {\\n            sorted[sortedIndex++] = arr[j++];\\n        }\\n        for (int i = start, index = 0; i <= end; i++, index++) {\\n            arr[i] = sorted[index];\\n        }\\n        return count;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        return UsingMergeSort().numberOfPairs(A, B, diff)\\n    \\nclass UsingMergeSort:\\n    def numberOfPairs(self, A: List[int], B: List[int], diff: int) -> int:\\n        for i in range(len(A)):\\n            A[i] = A[i] - B[i]\\n        return self.mergeSort(A, 0, len(A)-1, diff)\\n\\n    def mergeSort(self, arr: List[int], start: int, end: int, diff: int) -> int:\\n        if start >= end:\\n            return 0\\n        mid = start + (end - start) // 2\\n        count = 0\\n        count += self.mergeSort(arr, start, mid, diff)\\n        count += self.mergeSort(arr, mid+1, end, diff)\\n        count += self.merge(arr, start, mid, end, diff)\\n        return count\\n\\n    def merge(self, arr: List[int], start: int, mid: int, end: int, diff: int) -> int:\\n        j, k, sortedIndex = mid+1, mid+1, 0\\n        sortedList = [0] * (end-start+1)\\n        count = 0\\n        for i in range(start, mid+1):\\n            while k <= end and arr[i] - diff > arr[k]:\\n                k += 1\\n            count += end - k + 1\\n            while j <= end and arr[j] < arr[i]:\\n                sortedList[sortedIndex] = arr[j]\\n                sortedIndex += 1\\n                j += 1\\n            sortedList[sortedIndex] = arr[i]\\n            sortedIndex += 1\\n        while j <= end:\\n            sortedList[sortedIndex] = arr[j]\\n            sortedIndex += 1\\n            j += 1\\n        for i in range(start, end+1):\\n            arr[i] = sortedList[i-start]\\n        return count\\n```\n```cpp []\\n#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass UsingMergeSort {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        int n = A.size();\\n        vector<int> arr(n);\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = A[i] - B[i];\\n        }\\n        return mergeSort(arr, 0, n - 1, diff);\\n    }\\n\\nprivate:\\n    long long mergeSort(vector<int>& arr, int start, int end, int diff) {\\n        if (start >= end) return 0;\\n        int mid = start + (end - start) / 2;\\n        long long count = 0;\\n        count += mergeSort(arr, start, mid, diff);\\n        count += mergeSort(arr, mid + 1, end, diff);\\n        count += merge(arr, start, mid, end, diff);\\n        return count;\\n    }\\n\\n    long long merge(vector<int>& arr, int start, int mid, int end, int diff) {\\n        int j = mid + 1, k = mid + 1, sortedIndex = 0;\\n        int n = end - start + 1;\\n        vector<int> sorted(n);\\n        long long count = 0;\\n        for (int i = start; i <= mid; i++) {\\n            while (k <= end && arr[i] - diff > arr[k]) k++;\\n            count += end - k + 1;\\n            while (j <= end && arr[j] < arr[i]) {\\n                sorted[sortedIndex++] = arr[j++];\\n            }\\n            sorted[sortedIndex++] = arr[i];\\n        }\\n        while (j <= end) {\\n            sorted[sortedIndex++] = arr[j++];\\n        }\\n        for (int i = start, index = 0; i <= end; i++, index++) {\\n            arr[i] = sorted[index];\\n        }\\n        return count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        return UsingMergeSort().numberOfPairs(A, B, diff);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227757,
                "title": "easy-c-short-divide-and-conquer-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     long long ans=0;\\n   \\n       vector<int>fun(int i,int j,int diff,vector<int>&nums)\\n       {\\n           \\n           if(i==j)return {nums[j]};\\n             int mid=(i+j)/2;\\n              vector<int>left=fun(i,mid,diff,nums);\\n              vector<int>right=fun(mid+1,j,diff,nums);\\n              int y=0;\\n               for(int x=0;x<right.size();x++)\\n               {\\n                   while(y<left.size()&&right[x]+diff>=left[y])y++;\\n                   ans+=y;\\n               }\\n            vector<int>new_v(left.size()+right.size());\\n            merge(left.begin(),left.end(),right.begin(),right.end(),new_v.begin());\\n            sort(new_v.begin(),new_v.end());\\n            return new_v;\\n\\n       }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>nums;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n     fun(0,nums.size()-1,diff,nums);\\n     return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long ans=0;\\n   \\n       vector<int>fun(int i,int j,int diff,vector<int>&nums)\\n       {\\n           \\n           if(i==j)return {nums[j]};\\n             int mid=(i+j)/2;\\n              vector<int>left=fun(i,mid,diff,nums);\\n              vector<int>right=fun(mid+1,j,diff,nums);\\n              int y=0;\\n               for(int x=0;x<right.size();x++)\\n               {\\n                   while(y<left.size()&&right[x]+diff>=left[y])y++;\\n                   ans+=y;\\n               }\\n            vector<int>new_v(left.size()+right.size());\\n            merge(left.begin(),left.end(),right.begin(),right.end(),new_v.begin());\\n            sort(new_v.begin(),new_v.end());\\n            return new_v;\\n\\n       }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>nums;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n     fun(0,nums.size()-1,diff,nums);\\n     return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997494,
                "title": "c-simple-merge-sort-with-no-modification-highly-commented",
                "content": "```\\n/*\\n    Using Merge Sort\\n    nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n    (nums1[i] - nums2[i]) - (nums1[j] - nums2[j]) <= diff\\n    nums[i] - nums[j] <= diff\\n    \\n    Simpy do a merge sort and while returning and merging the sorted arary first do the comparision and store it in res.\\n*/\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    int dif = 0;\\n    void merge(vector<int> &nums,int start,int mid,int end){\\n        vector<int> temp(end - start + 1);\\n        int i = start; \\n        int j = mid + 1;\\n        int idx = 0;\\n        \\n        // Couting the pairs\\n        while(i <= mid && j <= end){\\n            if(nums[i] <= dif + nums[j]){      \\n                res += end - j + 1;      \\n                i++;\\n            }\\n            else j++;\\n        }\\n        \\n        i = start;\\n        j = mid + 1;\\n        \\n        // Merge two sorted array\\n        while(i <= mid && j <= end){\\n            if(nums[i] <= nums[j]) temp[idx++] = nums[i++];\\n            else temp[idx++] = nums[j++];\\n        }\\n        \\n        // Merging the sorted array which is left out \\n        while(i <= mid)temp[idx++] = nums[i++];\\n        while(j <= end)temp[idx++] = nums[j++];\\n        idx = 0;\\n        \\n        // Storing Back the array after it is sorted and the pairs are counted\\n        for(int itr = start; itr <= end ; itr++, idx++)nums[itr] = temp[idx];\\n        }\\n            \\n    void mergeSort(int start, int end, vector<int>&nums){\\n        if(start >= end)return;\\n        \\n        int mid = start + (end - start) / 2;\\n        mergeSort(start, mid, nums);\\n        mergeSort(mid + 1, end, nums);\\n        merge(nums, start, mid, end);\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        dif = diff;\\n        int n = nums1.size();\\n        vector<int>nums(n);\\n        for(int i = 0 ; i < n ; i++)nums[i] = nums1[i] - nums2[i];\\n        mergeSort(0, n - 1, nums);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\n/*\\n    Using Merge Sort\\n    nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n    (nums1[i] - nums2[i]) - (nums1[j] - nums2[j]) <= diff\\n    nums[i] - nums[j] <= diff\\n    \\n    Simpy do a merge sort and while returning and merging the sorted arary first do the comparision and store it in res.\\n*/\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    int dif = 0;\\n    void merge(vector<int> &nums,int start,int mid,int end){\\n        vector<int> temp(end - start + 1);\\n        int i = start; \\n        int j = mid + 1;\\n        int idx = 0;\\n        \\n        // Couting the pairs\\n        while(i <= mid && j <= end){\\n            if(nums[i] <= dif + nums[j]){      \\n                res += end - j + 1;      \\n                i++;\\n            }\\n            else j++;\\n        }\\n        \\n        i = start;\\n        j = mid + 1;\\n        \\n        // Merge two sorted array\\n        while(i <= mid && j <= end){\\n            if(nums[i] <= nums[j]) temp[idx++] = nums[i++];\\n            else temp[idx++] = nums[j++];\\n        }\\n        \\n        // Merging the sorted array which is left out \\n        while(i <= mid)temp[idx++] = nums[i++];\\n        while(j <= end)temp[idx++] = nums[j++];\\n        idx = 0;\\n        \\n        // Storing Back the array after it is sorted and the pairs are counted\\n        for(int itr = start; itr <= end ; itr++, idx++)nums[itr] = temp[idx];\\n        }\\n            \\n    void mergeSort(int start, int end, vector<int>&nums){\\n        if(start >= end)return;\\n        \\n        int mid = start + (end - start) / 2;\\n        mergeSort(start, mid, nums);\\n        mergeSort(mid + 1, end, nums);\\n        merge(nums, start, mid, end);\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        dif = diff;\\n        int n = nums1.size();\\n        vector<int>nums(n);\\n        for(int i = 0 ; i < n ; i++)nums[i] = nums1[i] - nums2[i];\\n        mergeSort(0, n - 1, nums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660020,
                "title": "c-segment-tree",
                "content": "```\\ntypedef long long ll;   const int offset = 2E4;\\n\\nclass Solution {\\nprivate:\\n    ll maxN;\\n    vector<ll> seg;\\n    void seg_update(int i, int low, int high, int node) {\\n        if(low == high) {\\n            seg[i]++;\\n            return;\\n        }\\n        int mid = low + (high - low) / 2;\\n        if(node <= mid) {\\n            seg_update(2 * i + 1, low, mid, node);\\n        } else {\\n            seg_update(2 * i + 2, mid + 1, high, node);\\n        }\\n        seg[i] = seg[2 * i + 1] + seg[2 * i + 2];\\n    }\\n    ll seg_query(int i, int low, int high, int l, int r) {\\n        if(low > r || high < l) {\\n            return 0;\\n        }\\n        if(low >= l && high <= r) {\\n            return seg[i];\\n        }\\n        ll mid = low + (high - low) / 2;\\n        ll left = seg_query(2 * i + 1, low, mid, l, r);\\n        ll right = seg_query(2 * i + 2, mid + 1, high, l, r);\\n        return left + right;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> v(n);\\n        for(int i = 0; i < n; i++) {\\n            v[i] = nums1[i] - nums2[i] + offset;\\n        }\\n        maxN = 2 * offset + 1;\\n        seg.resize(maxN * 4 + 10, 0);\\n        ll ans = 0;\\n        for(auto it : v) {\\n            ans += seg_query(0, 0, maxN - 1, 0, it + diff);\\n            seg_update(0, 0, maxN - 1, it);\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\ntypedef long long ll;   const int offset = 2E4;\\n\\nclass Solution {\\nprivate:\\n    ll maxN;\\n    vector<ll> seg;\\n    void seg_update(int i, int low, int high, int node) {\\n        if(low == high) {\\n            seg[i]++;\\n            return;\\n        }\\n        int mid = low + (high - low) / 2;\\n        if(node <= mid) {\\n            seg_update(2 * i + 1, low, mid, node);\\n        } else {\\n            seg_update(2 * i + 2, mid + 1, high, node);\\n        }\\n        seg[i] = seg[2 * i + 1] + seg[2 * i + 2];\\n    }\\n    ll seg_query(int i, int low, int high, int l, int r) {\\n        if(low > r || high < l) {\\n            return 0;\\n        }\\n        if(low >= l && high <= r) {\\n            return seg[i];\\n        }\\n        ll mid = low + (high - low) / 2;\\n        ll left = seg_query(2 * i + 1, low, mid, l, r);\\n        ll right = seg_query(2 * i + 2, mid + 1, high, l, r);\\n        return left + right;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> v(n);\\n        for(int i = 0; i < n; i++) {\\n            v[i] = nums1[i] - nums2[i] + offset;\\n        }\\n        maxN = 2 * offset + 1;\\n        seg.resize(maxN * 4 + 10, 0);\\n        ll ans = 0;\\n        for(auto it : v) {\\n            ans += seg_query(0, 0, maxN - 1, 0, it + diff);\\n            seg_update(0, 0, maxN - 1, it);\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656295,
                "title": "easy-c-solution-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int d) {\\n         int n = a.size();\\n         vector<int> c(n);\\n         for(int i=0; i<n; i++) c[i] = a[i] - b[i];\\n         mergeSort(0,n-1,c,d);\\n         return ans;\\n    }\\n    void mergeSort(int l,int r,vector<int> &c,int d) {\\n         if(l == r) return;\\n         int m = (l+r)/2;\\n         mergeSort(l,m,c,d);\\n         mergeSort(m+1,r,c,d);\\n         merge(l,m,r,c,d);\\n    }\\n    void merge(int l,int m,int r,vector<int>&c,int d) {\\n         int start = l , end = m+1;\\n         while(start<=m && end<=r) {\\n               if(c[start]<=c[end]+d) {\\n                   ans+=(r - end + 1);\\n                   start++;\\n               }else {\\n                   end++;\\n               }\\n         }\\n        sort(c.begin()+l,c.begin()+r+1);\\n    }\\n};\\n/*\\na[i] - a[j] <= b[i] - b[j] + diff\\n\\na[i] - b[i] <= a[j] - b[j] + diff\\n\\nc[i] <= c[j] + diff\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int d) {\\n         int n = a.size();\\n         vector<int> c(n);\\n         for(int i=0; i<n; i++) c[i] = a[i] - b[i];\\n         mergeSort(0,n-1,c,d);\\n         return ans;\\n    }\\n    void mergeSort(int l,int r,vector<int> &c,int d) {\\n         if(l == r) return;\\n         int m = (l+r)/2;\\n         mergeSort(l,m,c,d);\\n         mergeSort(m+1,r,c,d);\\n         merge(l,m,r,c,d);\\n    }\\n    void merge(int l,int m,int r,vector<int>&c,int d) {\\n         int start = l , end = m+1;\\n         while(start<=m && end<=r) {\\n               if(c[start]<=c[end]+d) {\\n                   ans+=(r - end + 1);\\n                   start++;\\n               }else {\\n                   end++;\\n               }\\n         }\\n        sort(c.begin()+l,c.begin()+r+1);\\n    }\\n};\\n/*\\na[i] - a[j] <= b[i] - b[j] + diff\\n\\na[i] - b[i] <= a[j] - b[j] + diff\\n\\nc[i] <= c[j] + diff\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653766,
                "title": "mergesort-binarysearch-divide-and-conquer-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    long long ans = 0;\\n    int k;\\n    \\n    void countPairs(int start, int end, vector<int> &nums) {\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        for(int i = start; i <= mid; i++) {\\n            \\n            int low = mid + 1, high = end;\\n            int index = high + 1;\\n            \\n            while(low <= high) {\\n                int mid = low + (high - low) / 2;\\n                \\n                if (nums[i] <= nums[mid] + k) {\\n                    index = mid;\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n            \\n            ans += (end - index + 1);\\n        }\\n        \\n        // merging arrays\\n        \\n        int sz = end - start + 1;\\n        vector<int> temp(sz);\\n        \\n        int i = start, j = mid + 1;\\n        int z = 0;\\n        \\n        while(i <= mid and j <= end) {\\n            if (nums[i] <= nums[j]) {\\n                temp[z++] = nums[i++];\\n            }\\n            else {\\n                temp[z++] = nums[j++];\\n            }\\n        }\\n        \\n        while(i <= mid) temp[z++] = nums[i++];\\n        while(j <= end) temp[z++] = nums[j++];\\n        \\n        z = 0;\\n        for (int i = start; i <= end; i++) {\\n            nums[i] = temp[z++];\\n        }\\n    }\\n    \\n    void mergeSort(int start, int end, vector<int> &nums) {\\n        if (start >= end) {\\n            return;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        mergeSort(start, mid, nums);\\n        mergeSort(mid + 1, end, nums);\\n        \\n        countPairs(start, end, nums);\\n    }\\n    \\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        ans = 0;\\n        k = diff;\\n        vector<int> nums(n);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n        \\n        mergeSort(0, n - 1, nums);\\n        return ans;\\n    }\\n};\\n```\\n\\nwe can use STL\\'s sort to sort the partition and lower bound for binary search\\n\\n```\\nclass Solution {\\nprivate:\\n    long long ans = 0;\\n    int k;\\n    \\n    void countPairs(int start, int end, vector<int> &nums) {\\n        \\n        int mid = start + (end - start) / 2;\\n\\n        for (int i = mid + 1; i <= end; i++) nums[i] += k;\\n        \\n        for (int i = start; i <= mid; i++) {\\n            int index = lower_bound(nums.begin() + mid + 1, nums.begin() + end + 1, nums[i]) - nums.begin();\\n            ans += (end - index + 1);\\n        }\\n        \\n        for (int i = mid + 1; i <= end; i++) nums[i] -= k;\\n        sort(nums.begin() + start, nums.begin() + end + 1);\\n    }\\n    \\n    void mergeSort(int start, int end, vector<int> &nums) {\\n        if (start >= end) \\n            return;\\n        \\n        int mid = start + (end - start) / 2;\\n        mergeSort(start, mid, nums);\\n        mergeSort(mid + 1, end, nums);\\n        \\n        countPairs(start, end, nums);\\n    }\\n    \\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        ans = 0;\\n        k = diff;\\n        \\n        vector<int> nums(n);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n        \\n        mergeSort(0, n - 1, nums);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long ans = 0;\\n    int k;\\n    \\n    void countPairs(int start, int end, vector<int> &nums) {\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        for(int i = start; i <= mid; i++) {\\n            \\n            int low = mid + 1, high = end;\\n            int index = high + 1;\\n            \\n            while(low <= high) {\\n                int mid = low + (high - low) / 2;\\n                \\n                if (nums[i] <= nums[mid] + k) {\\n                    index = mid;\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n            \\n            ans += (end - index + 1);\\n        }\\n        \\n        // merging arrays\\n        \\n        int sz = end - start + 1;\\n        vector<int> temp(sz);\\n        \\n        int i = start, j = mid + 1;\\n        int z = 0;\\n        \\n        while(i <= mid and j <= end) {\\n            if (nums[i] <= nums[j]) {\\n                temp[z++] = nums[i++];\\n            }\\n            else {\\n                temp[z++] = nums[j++];\\n            }\\n        }\\n        \\n        while(i <= mid) temp[z++] = nums[i++];\\n        while(j <= end) temp[z++] = nums[j++];\\n        \\n        z = 0;\\n        for (int i = start; i <= end; i++) {\\n            nums[i] = temp[z++];\\n        }\\n    }\\n    \\n    void mergeSort(int start, int end, vector<int> &nums) {\\n        if (start >= end) {\\n            return;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        mergeSort(start, mid, nums);\\n        mergeSort(mid + 1, end, nums);\\n        \\n        countPairs(start, end, nums);\\n    }\\n    \\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        ans = 0;\\n        k = diff;\\n        vector<int> nums(n);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n        \\n        mergeSort(0, n - 1, nums);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    long long ans = 0;\\n    int k;\\n    \\n    void countPairs(int start, int end, vector<int> &nums) {\\n        \\n        int mid = start + (end - start) / 2;\\n\\n        for (int i = mid + 1; i <= end; i++) nums[i] += k;\\n        \\n        for (int i = start; i <= mid; i++) {\\n            int index = lower_bound(nums.begin() + mid + 1, nums.begin() + end + 1, nums[i]) - nums.begin();\\n            ans += (end - index + 1);\\n        }\\n        \\n        for (int i = mid + 1; i <= end; i++) nums[i] -= k;\\n        sort(nums.begin() + start, nums.begin() + end + 1);\\n    }\\n    \\n    void mergeSort(int start, int end, vector<int> &nums) {\\n        if (start >= end) \\n            return;\\n        \\n        int mid = start + (end - start) / 2;\\n        mergeSort(start, mid, nums);\\n        mergeSort(mid + 1, end, nums);\\n        \\n        countPairs(start, end, nums);\\n    }\\n    \\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        ans = 0;\\n        k = diff;\\n        \\n        vector<int> nums(n);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n        \\n        mergeSort(0, n - 1, nums);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647667,
                "title": "c-fenwick-tree-linearithmic-solution-100-time-127ms-100-space-75-4mb",
                "content": "Nice problem that boils down to a few core intuitions:\\n\\n```cpp\\nn1[i] - n1[j] <= n2[i] - n2[j] + diff\\ncan be refactored as:\\nn1[i] - n2[i] <= n1[j] - n2[j] + diff\\n```\\n\\nWith this we can see that basically we can create each couple of `n1[i] - n2[i]` pairs and see how many elements to the right of it are such that they are `<= n1[y] - n2[y] + diff`.\\n\\nAnd this count can be efficiently found setting up a Binary Indexed Tree (BIT from now; AKA \"Fenwick Tree\"), in sheer logarithmic time.\\n\\nThe final trick is to start parsing `n1` and `n2` from the right, so that we will also populate our BIT as we go.\\n\\nGiven the specs and that we cannot work well with a BIT sporting negative indexes, the usual trick is to normalise everything to be positive; since we know our lower bound from the specs, we can set `lowBound` to be `10000`; we will also need a triple of that value to know the upper limit (since we can get this much low if `n1[i]`, `n2[i]` and `diff` are all the minimum possible value, `tripleLowBound`. Finally, we will need to set the upper limit of our BIT by double that amount, plus `3`: `maxSize`.\\n\\nWe will declare a `BITree` array of `maxSize` size and `elements` (set to `0`) as instance variables.\\n\\nOur `updateBIT` is pretty standard, taking a position `idx` and a value to add `val` to it, with the extra bit of increasing the `elements` counter.\\n\\n`getSum` similarly will count all the elements below `idx` (included) and `return` `elements` minus their amount, which means all the values above it.\\n\\nIn our main function we will declare:\\n* `len` storing the length of both `n1` and `n2`;\\n* `res`, our usual accumulator variable set to `0`.\\n\\nGoing from right to left, we will take each element pointed by `i` and:\\n* set `curr` to be `n1[i] - n2[i] + tripleLowBound`;\\n* increase `res` by the amount of all the values above `curr`;\\n* finally, we update our BIT increasing the frequency of elements valued `curr + diff + 1` by `1`.\\n\\nOnce done, we can `return` `res`.\\n\\nThe code:\\n\\n```cpp\\nconstexpr int lowBound = 10000, tripleLowBound = lowBound * 3, maxSize = (tripleLowBound << 1) + 3;\\n\\nclass Solution {\\n    int BITree[maxSize] = {}, elements = 0;\\n    void updateBIT(int idx, int val) {\\n        // increasing elements count\\n        elements++;\\n        idx = idx + 1;\\n        while (idx <= maxSize) {\\n            BITree[idx] += val;\\n            idx += idx & (-idx);\\n        }\\n    }\\n    int getSum(int idx) {\\n        int tot = 0;\\n        idx = idx + 1;\\n        while (idx > 0) {\\n            tot += BITree[idx];\\n            idx -= idx & (-idx);\\n        }\\n        return elements - tot;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n        // support variables\\n        int len = n1.size();\\n        long long res = 0;\\n        // populating base and diffs\\n        for (int i = len - 1, curr; i >= 0; i--) {\\n            curr = n1[i] - n2[i] + tripleLowBound;\\n            res += getSum(curr);\\n            updateBIT(curr + diff + 1, 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nMh, actually starting from the right was really not needed - I could just reverse the logic, going from the left and counting how many previous elements were below `curr + diff` (included) and then just add `curr` to the BIT.\\n\\nMore intuitive for sure, one couple of operations no more needed (`elements++` and `elements - tot`) and somehow even easier to debug, I guess - but that is subjective. \\n\\nThe updated code:\\n\\n```cpp\\nconstexpr int lowBound = 10000, tripleLowBound = lowBound * 3, maxSize = (tripleLowBound << 1) + 3;\\n\\nclass Solution {\\n    int BITree[maxSize] = {}, elements = 0;\\n    void updateBIT(int idx, int val) {\\n        idx = idx + 1;\\n        while (idx <= maxSize) {\\n            BITree[idx] += val;\\n            idx += idx & (-idx);\\n        }\\n    }\\n    int getSum(int idx) {\\n        int tot = 0;\\n        idx = idx + 1;\\n        while (idx > 0) {\\n            tot += BITree[idx];\\n            idx -= idx & (-idx);\\n        }\\n        return tot;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n        // support variables\\n        int len = n1.size();\\n        long long res = 0;\\n        // populating base and diffs\\n        for (int i = 0, curr; i < len; i++) {\\n            curr = n1[i] - n2[i] + tripleLowBound;\\n            res += getSum(curr + diff);\\n            updateBIT(curr, 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinal version, optimising a bit for `maxSize` to be computed within a reasonable range; it runs a bit faster:\\n\\n```cpp\\nclass Solution {\\n    int BITree[50003] = {}, elements = 0, maxSize;\\n    void updateBIT(int idx, int val) {\\n        idx = idx + 1;\\n        while (idx <= maxSize) {\\n            BITree[idx] += val;\\n            idx += idx & (-idx);\\n        }\\n    }\\n    int getSum(int idx) {\\n        int tot = 0;\\n        idx = idx + 1;\\n        while (idx > 0) {\\n            tot += BITree[idx];\\n            idx -= idx & (-idx);\\n        }\\n        return tot;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n        // support variables\\n        int len = n1.size(), minPair = INT_MAX, maxPair = INT_MIN;\\n        long long res = 0;\\n        // preparing BITree\\n        for (int i = 0, diff; i < len; i++) {\\n            diff = n1[i] - n2[i];\\n            minPair = min(minPair, diff);\\n            maxPair = max(maxPair, diff);\\n        }\\n        // factoring diff in\\n        diff <= 0 ? minPair += diff : maxPair += diff;\\n        maxSize = maxPair - minPair + 2;\\n        // populating base and diffs\\n        for (int i = 0, curr; i < len; i++) {\\n            curr = n1[i] - n2[i] - minPair;\\n            res += getSum(curr + diff);\\n            updateBIT(curr, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Indexed Tree",
                    "Binary Tree"
                ],
                "code": "```cpp\\nn1[i] - n1[j] <= n2[i] - n2[j] + diff\\ncan be refactored as:\\nn1[i] - n2[i] <= n1[j] - n2[j] + diff\\n```\n```cpp\\nconstexpr int lowBound = 10000, tripleLowBound = lowBound * 3, maxSize = (tripleLowBound << 1) + 3;\\n\\nclass Solution {\\n    int BITree[maxSize] = {}, elements = 0;\\n    void updateBIT(int idx, int val) {\\n        // increasing elements count\\n        elements++;\\n        idx = idx + 1;\\n        while (idx <= maxSize) {\\n            BITree[idx] += val;\\n            idx += idx & (-idx);\\n        }\\n    }\\n    int getSum(int idx) {\\n        int tot = 0;\\n        idx = idx + 1;\\n        while (idx > 0) {\\n            tot += BITree[idx];\\n            idx -= idx & (-idx);\\n        }\\n        return elements - tot;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n        // support variables\\n        int len = n1.size();\\n        long long res = 0;\\n        // populating base and diffs\\n        for (int i = len - 1, curr; i >= 0; i--) {\\n            curr = n1[i] - n2[i] + tripleLowBound;\\n            res += getSum(curr);\\n            updateBIT(curr + diff + 1, 1);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int lowBound = 10000, tripleLowBound = lowBound * 3, maxSize = (tripleLowBound << 1) + 3;\\n\\nclass Solution {\\n    int BITree[maxSize] = {}, elements = 0;\\n    void updateBIT(int idx, int val) {\\n        idx = idx + 1;\\n        while (idx <= maxSize) {\\n            BITree[idx] += val;\\n            idx += idx & (-idx);\\n        }\\n    }\\n    int getSum(int idx) {\\n        int tot = 0;\\n        idx = idx + 1;\\n        while (idx > 0) {\\n            tot += BITree[idx];\\n            idx -= idx & (-idx);\\n        }\\n        return tot;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n        // support variables\\n        int len = n1.size();\\n        long long res = 0;\\n        // populating base and diffs\\n        for (int i = 0, curr; i < len; i++) {\\n            curr = n1[i] - n2[i] + tripleLowBound;\\n            res += getSum(curr + diff);\\n            updateBIT(curr, 1);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int BITree[50003] = {}, elements = 0, maxSize;\\n    void updateBIT(int idx, int val) {\\n        idx = idx + 1;\\n        while (idx <= maxSize) {\\n            BITree[idx] += val;\\n            idx += idx & (-idx);\\n        }\\n    }\\n    int getSum(int idx) {\\n        int tot = 0;\\n        idx = idx + 1;\\n        while (idx > 0) {\\n            tot += BITree[idx];\\n            idx -= idx & (-idx);\\n        }\\n        return tot;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n        // support variables\\n        int len = n1.size(), minPair = INT_MAX, maxPair = INT_MIN;\\n        long long res = 0;\\n        // preparing BITree\\n        for (int i = 0, diff; i < len; i++) {\\n            diff = n1[i] - n2[i];\\n            minPair = min(minPair, diff);\\n            maxPair = max(maxPair, diff);\\n        }\\n        // factoring diff in\\n        diff <= 0 ? minPair += diff : maxPair += diff;\\n        maxSize = maxPair - minPair + 2;\\n        // populating base and diffs\\n        for (int i = 0, curr; i < len; i++) {\\n            curr = n1[i] - n2[i] - minPair;\\n            res += getSum(curr + diff);\\n            updateBIT(curr, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647305,
                "title": "100-simple-solution-with-binary-search",
                "content": "Sorry, I\\'m not good at english and explanation\\n\\n**Explanation**\\n\\nLet\\'s see the conditions.\\n\\n```\\n0 <= i < j <= n - 1 and\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\\n```\\n\\n**First,** *i* is always smaller than *j*\\n\\nIt means we just need to compare *i* th elem with *0 ... ( i-1 )* th elems.\\n\\nthus, we can\\'t sort this array.\\n\\n**Second,** it is equation, you can change it like below.\\n\\nnums1[ *i* ] **- nums1[ *j* ]** <= **nums2[ *i* ]** - nums2[ *j* ] + diff\\n\\n=> nums1[ *i* ] **- nums2[ *i* ]** <= **nums1[ *j* ]** - nums2[ *j* ] + diff\\n\\nThen we can get a hint with this permuted equation.\\n\\ndiff + *j* th sum of both array should be bigger than *i* th sum of both array or equal\\n\\n**conclusion** is we need to find a good solution that compare value fast and memoize past values with ascending orders.\\n\\nso I used binary search and i tried to find both index in binSeach function\\n1. index of satisfying *condition 2* \\n2. index of *j* th sum\\n\\n```\\nconst binSearch = (arr, sum, diff) => {\\n    let l1 = 0;\\n    let r1 = arr.length;\\n    \\n    let l2 = 0;\\n    let r2 = arr.length;\\n    \\n    while(l1 < r1 || l2 < r2) {\\n\\t\\t// 1. index of satisfying *condition 2* \\n        if(l1 < r1) {\\n            const mid = Math.floor((l1 + r1) / 2);\\n            if(arr[mid] <= sum + diff) l1 = mid + 1;\\n            else r1 = mid;\\n        }\\n\\t\\t// 2. index of *j* th sum\\n        if(l2 < r2) {\\n            const mid = Math.floor((l2 + r2) / 2);\\n            if(arr[mid] <= sum) l2 = mid + 1;\\n            else r2 = mid;\\n        }\\n    }\\n    return [l1, l2];\\n}\\n\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} diff\\n * @return {number}\\n */\\nvar numberOfPairs = function(nums1, nums2, diff) {    \\n    let answer = 0;\\n    const past = [];\\n    \\n    for(let i = 0; i < nums1.length; i++) {\\n        const sum = nums1[i] - nums2[i];\\n        const [cnt, pos] = binSearch(past, sum, diff);\\n        answer += cnt;\\n        past.splice(pos, 0, sum);\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n0 <= i < j <= n - 1 and\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\\n```\n```\\nconst binSearch = (arr, sum, diff) => {\\n    let l1 = 0;\\n    let r1 = arr.length;\\n    \\n    let l2 = 0;\\n    let r2 = arr.length;\\n    \\n    while(l1 < r1 || l2 < r2) {\\n\\t\\t// 1. index of satisfying *condition 2* \\n        if(l1 < r1) {\\n            const mid = Math.floor((l1 + r1) / 2);\\n            if(arr[mid] <= sum + diff) l1 = mid + 1;\\n            else r1 = mid;\\n        }\\n\\t\\t// 2. index of *j* th sum\\n        if(l2 < r2) {\\n            const mid = Math.floor((l2 + r2) / 2);\\n            if(arr[mid] <= sum) l2 = mid + 1;\\n            else r2 = mid;\\n        }\\n    }\\n    return [l1, l2];\\n}\\n\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} diff\\n * @return {number}\\n */\\nvar numberOfPairs = function(nums1, nums2, diff) {    \\n    let answer = 0;\\n    const past = [];\\n    \\n    for(let i = 0; i < nums1.length; i++) {\\n        const sum = nums1[i] - nums2[i];\\n        const [cnt, pos] = binSearch(past, sum, diff);\\n        answer += cnt;\\n        past.splice(pos, 0, sum);\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646764,
                "title": "trie-solution-c-easy-to-understand",
                "content": "Given :\\n\\tnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\nCan be rewritten as \\n\\tnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n\\nThen the problem reduces to finding the count of values already in array less than a search value i.e.  nums1[i] - nums2[i] + diff for all i < n. \\n\\nIdea is to use Binary Trie with each node storing the count of values less than or equal to current value. This count can be maintained while inserting in trie. \\n\\nNow  while traversing the trie nodes we can count the values required.\\n\\nWe need to be careful about having only positive values in our Trie. So we can use an ```offset``` to take care of negative values.  \\n\\n```\\nstruct node {\\n    int val;\\n    node* left;\\n    node* right;\\n    \\n    node(){\\n        left = right = NULL;\\n        val = 0;\\n    }\\n};\\n\\nclass Trie {\\n    int LIM = 30;\\npublic:\\n    Trie() {\\n        root = new node();\\n    }\\n    \\n    node *root;\\n    void insert(int val) {\\n        node *ptr = root;\\n        \\n        for(int i=LIM;i>=0;i--)\\n        {\\n            ptr->val++;\\n            if(val&(1<<i))\\n            {\\n                if(ptr->right==NULL)\\n                    ptr->right = new node();\\n                ptr = ptr->right;                \\n            }\\n            else\\n            {\\n                if(ptr->left==NULL)\\n                    ptr->left = new node();\\n                ptr = ptr->left;  \\n            }\\n        }\\n        ptr->val++;\\n    }\\n    \\n    int getans(int num) {\\n        node *ptr = root;\\n        int ans = 0;\\n        \\n        for(int i=LIM;i>=0;i--)\\n        {\\n            if(ptr == NULL)\\n                return ans;\\n            if(num & (1<<i))\\n            {\\n                ans = ans + (ptr->left ? ptr->left->val : 0);\\n                ptr = ptr->right;\\n            }\\n            else {\\n                ptr = ptr->left;\\n            }\\n            //cout<<\" \";\\n        }\\n        //cout<<\"hh\";\\n        if(ptr)\\n            ans+=ptr->val;\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int offset = 1e5;\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        Trie tr;\\n        \\n        int mini = 0;\\n        \\n        vector<long long> vals;\\n        for(int i=0;i<nums1.size();i++) {\\n            nums1[i] -= nums2[i];\\n            mini = min(mini, nums1[i]+diff);\\n        }\\n        \\n        for(int i=0;i<nums1.size();i++) {\\n              long long val = 1LL*nums1[i] - mini + offset;\\n            vals.push_back(val);\\n        }\\n          \\n        \\n        long long res = 0;\\n        \\n        for(int i=0;i<nums1.size();i++) {\\n            int ct = tr.getans(vals[i] + diff);\\n            tr.insert(vals[i]);\\n            res = res + ct;\\n        }\\n        return res;\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```offset```\n```\\nstruct node {\\n    int val;\\n    node* left;\\n    node* right;\\n    \\n    node(){\\n        left = right = NULL;\\n        val = 0;\\n    }\\n};\\n\\nclass Trie {\\n    int LIM = 30;\\npublic:\\n    Trie() {\\n        root = new node();\\n    }\\n    \\n    node *root;\\n    void insert(int val) {\\n        node *ptr = root;\\n        \\n        for(int i=LIM;i>=0;i--)\\n        {\\n            ptr->val++;\\n            if(val&(1<<i))\\n            {\\n                if(ptr->right==NULL)\\n                    ptr->right = new node();\\n                ptr = ptr->right;                \\n            }\\n            else\\n            {\\n                if(ptr->left==NULL)\\n                    ptr->left = new node();\\n                ptr = ptr->left;  \\n            }\\n        }\\n        ptr->val++;\\n    }\\n    \\n    int getans(int num) {\\n        node *ptr = root;\\n        int ans = 0;\\n        \\n        for(int i=LIM;i>=0;i--)\\n        {\\n            if(ptr == NULL)\\n                return ans;\\n            if(num & (1<<i))\\n            {\\n                ans = ans + (ptr->left ? ptr->left->val : 0);\\n                ptr = ptr->right;\\n            }\\n            else {\\n                ptr = ptr->left;\\n            }\\n            //cout<<\" \";\\n        }\\n        //cout<<\"hh\";\\n        if(ptr)\\n            ans+=ptr->val;\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int offset = 1e5;\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        Trie tr;\\n        \\n        int mini = 0;\\n        \\n        vector<long long> vals;\\n        for(int i=0;i<nums1.size();i++) {\\n            nums1[i] -= nums2[i];\\n            mini = min(mini, nums1[i]+diff);\\n        }\\n        \\n        for(int i=0;i<nums1.size();i++) {\\n              long long val = 1LL*nums1[i] - mini + offset;\\n            vals.push_back(val);\\n        }\\n          \\n        \\n        long long res = 0;\\n        \\n        for(int i=0;i<nums1.size();i++) {\\n            int ct = tr.getans(vals[i] + diff);\\n            tr.insert(vals[i]);\\n            res = res + ct;\\n        }\\n        return res;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2646711,
                "title": "python-segment-tree-with-explanation",
                "content": "At first, we change the inequality to this form:\\n(nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff\\n\\nThen, we can get nums by subtracking nums2 from nums1. To use segment tree, we add (2 * 10 ** 4) to nums to ensure all elements are positive. \\n\\nWe need to perform a littele adjustment on segment tree. We use position to represent numbers in nums. When updating p (which is actually a number in nums), we simply add 1 to tree[p].\\n\\nFinally we just iterate on nums. For each n in nums, we query n+diff+1 and update tree[n]. \\n```\\nclass Tree:\\n    def __init__(self):\\n        self.tree = [0] * (4 * 4 * (10 ** 4) + 1)\\n    def updateTreeNode(self, p) : \\n        n = 8 * (10 ** 4)\\n        # set value at position p \\n        self.tree[p + n] += 1; \\n        p = p + n; \\n\\n        # move upward and update parents \\n        i = p;\\n\\n        while i > 1 :\\n\\n            self.tree[i >> 1] = self.tree[i] + self.tree[i ^ 1]; \\n            i >>= 1; \\n\\n    def query(self, l, r):\\n\\n        res = 0; \\n\\n        # loop to find the sum in the range \\n        l += 8 * (10 ** 4);\\n        r += 8 * (10 ** 4);\\n\\n        while l < r:\\n\\n            if (l & 1) :\\n                res += self.tree[l]; \\n                l += 1\\n\\n            if (r & 1) :\\n                r -= 1;\\n                res += self.tree[r]; \\n\\n            l >>= 1;\\n            r >>= 1\\n\\n        return res; \\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        nums = [(2 * 10 ** 4) + nums1[x] - nums2[x] for x in range(len(nums1))]\\n        #print(min(nums), max(nums))\\n        t = Tree()\\n        res = 0\\n        for n in nums:\\n            res += t.query(0, diff + n + 1)\\n            t.updateTreeNode(n)\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Tree:\\n    def __init__(self):\\n        self.tree = [0] * (4 * 4 * (10 ** 4) + 1)\\n    def updateTreeNode(self, p) : \\n        n = 8 * (10 ** 4)\\n        # set value at position p \\n        self.tree[p + n] += 1; \\n        p = p + n; \\n\\n        # move upward and update parents \\n        i = p;\\n\\n        while i > 1 :\\n\\n            self.tree[i >> 1] = self.tree[i] + self.tree[i ^ 1]; \\n            i >>= 1; \\n\\n    def query(self, l, r):\\n\\n        res = 0; \\n\\n        # loop to find the sum in the range \\n        l += 8 * (10 ** 4);\\n        r += 8 * (10 ** 4);\\n\\n        while l < r:\\n\\n            if (l & 1) :\\n                res += self.tree[l]; \\n                l += 1\\n\\n            if (r & 1) :\\n                r -= 1;\\n                res += self.tree[r]; \\n\\n            l >>= 1;\\n            r >>= 1\\n\\n        return res; \\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        nums = [(2 * 10 ** 4) + nums1[x] - nums2[x] for x in range(len(nums1))]\\n        #print(min(nums), max(nums))\\n        t = Tree()\\n        res = 0\\n        for n in nums:\\n            res += t.query(0, diff + n + 1)\\n            t.updateTreeNode(n)\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646515,
                "title": "c-segtree-o-nlogn-with-explanation",
                "content": "# Solution/Intuition\\nLet nums1 = A and nums2 = B. \\n\\nWe need to find the number of pairs (i, j) such that: \\n\\nA[i] - A[j] <= B[i] - B[j] + diff\\nA[i] - B[i] <= A[j] - B[j] + diff\\n\\nWe convert it to the latter form because then it is easier to work with indexies at the same position. * \\n\\nNow, we realize that the question is just asking us how many indexes (i, j), such that the difference of A[i] and B[i] is less than or equal to A[j] - B[j] + diff. One way we may approach this problem is by scanning forward through the array and updating the differences using a segtree. Because differences may be negative, we will need to shift all values in the segtree right by at least 2e4 (2 * maxN), see implementation for how it is done, as our segtree can only store positive values/indexes. For each index, we check how many indexes (i) less than our current index that we have reached, that satisfy our inequality with our current index (j). \\n\\nWe are checking the number of indexes (i) that we have already reached (lower than j which we are currently at) where (A[i] - B[i]) lies in the interval (-infinity, A[j] - B[j] + diff]. \\n\\nAs such, we can simply do segtree.query(0, A[j]-B[j]+diff + shift + 1), making sure to add a shift to ensure positive numbers, and adding one because our queries are exclusive [l, r). \\n\\nAfter checking, we increment our current difference in the segtree, and move on. \\n\\n\\n\\n*As a matter of fact, it is easier to make A a difference array, and instead of using A[i] - B[i], you could just use A[i] instead (since we dont use A[i] or B[i] individually at all, we only care about the difference)\\n\\n\\n# Implementation \\n```cpp\\n\\ntemplate <class T> \\nclass St {\\n    private: \\n    vector<T> t;\\n    int n; T def = 0;\\n    //operation (in this case it is addition, so sum from [l, r)) \\n    T op(T a, T b) {\\n        return a + b; \\n    } \\n    public:\\n    //initialize segtree\\n    St(T N) { \\n        t = vector<T>(2 * N, 0); \\n        n = N; \\n    }\\n\\n    //make segtree off of a vector\\n    void make(vector<T> & a) { \\n        for (int i = 0; i < n; ++i) t[n+i] = a[i]; \\n    } \\n\\n    //build segtree\\n    void build() {\\n        for (int i = n - 1; i > 0; --i) t[i] = op(t[i<<1], t[i<<1|1]);\\n    }\\n    \\n    //modify tree[p] to val \\n    void modify(int p, T val) {\\n        for (t[p += n] = val; p > 1; p >>= 1) t[p>>1] = op(t[p], t[p^1]);\\n    }\\n    \\n    //query on [l, r)\\n    T query(int l, int r) {  \\n        T res = def;\\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\\n            if (l&1) res = op(res, t[l++]);\\n            if (r&1) res = op(res, t[--r]);\\n        }\\n        return res;\\n    }\\n};\\nint shift = 2e4; \\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int diff) {\\n        int n = a.size(); \\n        long long ans = 0; \\n        //make empty segtree (that counts frequencies of differences)\\n        St st(100000); \\n        vector<int> v(100000, 0); \\n        st.make(v); \\n        st.build(); \\n        \\n        for (int i = 0; i < n; ++i) {\\n            //cur is the rightmost bound we should get \\n            int cur = a[i] - b[i] + diff; \\n            // add the sum of (-infinity, cur)\\n            // add 1 to include right value\\n            ans += st.query(0, cur + shift + 1); \\n\\n            //increment current value\\n            int cur = st.query(a[i]-b[i] + shift, a[i]-b[i] + shift + 1);\\n            st.modify(a[i]-b[i] + shift, cur + 1); \\n            //make sure to shift all values by shift (so they are positive)\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n\\ntemplate <class T> \\nclass St {\\n    private: \\n    vector<T> t;\\n    int n; T def = 0;\\n    //operation (in this case it is addition, so sum from [l, r)) \\n    T op(T a, T b) {\\n        return a + b; \\n    } \\n    public:\\n    //initialize segtree\\n    St(T N) { \\n        t = vector<T>(2 * N, 0); \\n        n = N; \\n    }\\n\\n    //make segtree off of a vector\\n    void make(vector<T> & a) { \\n        for (int i = 0; i < n; ++i) t[n+i] = a[i]; \\n    } \\n\\n    //build segtree\\n    void build() {\\n        for (int i = n - 1; i > 0; --i) t[i] = op(t[i<<1], t[i<<1|1]);\\n    }\\n    \\n    //modify tree[p] to val \\n    void modify(int p, T val) {\\n        for (t[p += n] = val; p > 1; p >>= 1) t[p>>1] = op(t[p], t[p^1]);\\n    }\\n    \\n    //query on [l, r)\\n    T query(int l, int r) {  \\n        T res = def;\\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\\n            if (l&1) res = op(res, t[l++]);\\n            if (r&1) res = op(res, t[--r]);\\n        }\\n        return res;\\n    }\\n};\\nint shift = 2e4; \\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int diff) {\\n        int n = a.size(); \\n        long long ans = 0; \\n        //make empty segtree (that counts frequencies of differences)\\n        St st(100000); \\n        vector<int> v(100000, 0); \\n        st.make(v); \\n        st.build(); \\n        \\n        for (int i = 0; i < n; ++i) {\\n            //cur is the rightmost bound we should get \\n            int cur = a[i] - b[i] + diff; \\n            // add the sum of (-infinity, cur)\\n            // add 1 to include right value\\n            ans += st.query(0, cur + shift + 1); \\n\\n            //increment current value\\n            int cur = st.query(a[i]-b[i] + shift, a[i]-b[i] + shift + 1);\\n            st.modify(a[i]-b[i] + shift, cur + 1); \\n            //make sure to shift all values by shift (so they are positive)\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646505,
                "title": "ordered-set-rearrange-the-equation-c-explained",
                "content": "Given equation: \\tnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\nRearranging it to:\\tnums1[i] - nums2[i] - diff <= nums1[j] - nums2[j]\\n\\nReason for rearranging: Grouping i\\'s and j\\'s together so that we can do binary search to find the pairs (i, j) satisfying this equation\\n\\nAlgorithm / Steps to solve: \\n1. Initialize an ordered set (Behaves like normal set but added advantage is that we can do lower_bound also :))\\n2. Iterate from i from (n - 1) to (0).\\n3. Keep current value = nums1[i] - nums2[i] - diff;\\n4. Search for the number values greater than current value and add it to answer.\\n5. Insert nums1[i] - nums2[i] in ordered set.\\n\\nCode:\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n\\n// namespace necessary for GNU based \\n// policy based data structures\\nusing namespace __gnu_pbds;\\n  \\n  \\n// Declaring ordered_set for pair<int,int>\\ntypedef tree<pair<int,int>, null_type, \\n        less<pair<int,int>>, rb_tree_tag,\\n        tree_order_statistics_node_update>\\n        ordered_set_pair;\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        ordered_set_pair oset;\\n        long long curr_ans, curr, i, n = nums1.size(), j, ans = 0;\\n        for(j=n-1;j>=0;j--){\\n            curr = 0LL + nums1[j] - nums2[j] - diff;\\n            curr_ans = oset.size() - oset.order_of_key({curr, -1});\\n            ans += curr_ans;\\n            oset.insert({nums1[j] - nums2[j], j});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity: O(n logn)\\nSpace Complexity: O(n)",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n\\n// namespace necessary for GNU based \\n// policy based data structures\\nusing namespace __gnu_pbds;\\n  \\n  \\n// Declaring ordered_set for pair<int,int>\\ntypedef tree<pair<int,int>, null_type, \\n        less<pair<int,int>>, rb_tree_tag,\\n        tree_order_statistics_node_update>\\n        ordered_set_pair;\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        ordered_set_pair oset;\\n        long long curr_ans, curr, i, n = nums1.size(), j, ans = 0;\\n        for(j=n-1;j>=0;j--){\\n            curr = 0LL + nums1[j] - nums2[j] - diff;\\n            curr_ans = oset.size() - oset.order_of_key({curr, -1});\\n            ans += curr_ans;\\n            oset.insert({nums1[j] - nums2[j], j});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3637668,
                "title": "python-short-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        N = len(nums1)\\n        count = 0\\n        sl = SortedList()\\n        \\n        for i in range(N):\\n\\t\\t\\n#           If rhs is in the list (applying binary search)\\n            count += sl.bisect_right(nums1[i]-nums2[i]+diff)\\n\\t\\t\\t\\n#           adding lhs in the left side \\n            sl.add(nums1[i] - nums2[i])\\n\\t\\t\\t\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        N = len(nums1)\\n        count = 0\\n        sl = SortedList()\\n        \\n        for i in range(N):\\n\\t\\t\\n#           If rhs is in the list (applying binary search)\\n            count += sl.bisect_right(nums1[i]-nums2[i]+diff)\\n\\t\\t\\t\\n#           adding lhs in the left side \\n            sl.add(nums1[i] - nums2[i])\\n\\t\\t\\t\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358204,
                "title": "python3-in-place-mergesort-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        # See Merge Sort and 493. Reverse Pairs before this\\n        # This problem is exactly as 493, but we need to transform the two input\\n        # arrays to one first\\n        # nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff, can be written as\\n        # nums1[i] - nums2[i] <= nums1[j] - nums2[j]\\n        # Say nums1 - nums2 = arr\\n        # then above can be written as \\n        # a[i] <= a[j] + diff -- exactly like Reverse pairs but with <= instead of >\\n        # This <= instead of > affect the calculation of count only\\n        # see c += len(right) - j below, since if left[i] <= right[i] + diff\\n        # this will be true for all remaing j, since they are greater than this value\\n\\n        def merge_sort(nums):\\n            if len(nums) <= 1: return 0\\n            mid = len(nums) // 2\\n            left = nums[:mid]\\n            right = nums[mid:]\\n\\n            c_l = merge_sort(left)\\n            c_r = merge_sort(right)\\n\\n            # This part we count the pairs\\n            i = j = c = 0\\n            while i < len(left) and j < len(right):\\n                if left[i] <= right[j] + diff:\\n                    c += (len(right) - j)\\n                    i += 1\\n                else:\\n                    j += 1\\n            \\n            # here we do the regular merge of merge sort \\n            i = j = k = 0\\n            while i < len(left) and j < len(right):\\n                if right[j] < left[i]:\\n                    nums[k] = right[j]\\n                    j += 1\\n                else:\\n                    nums[k] = left[i]\\n                    i += 1\\n                k += 1\\n            \\n            while i < len(left):\\n                nums[k] = left[i]\\n                i += 1\\n                k += 1\\n            \\n            while j < len(right):\\n                nums[k] = right[j]\\n                j += 1\\n                k += 1\\n            \\n            return c_l + c_r + c\\n\\n        diff_arr = [a - b for (a, b) in zip(nums1, nums2)]\\n        return merge_sort(diff_arr) \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        # See Merge Sort and 493. Reverse Pairs before this\\n        # This problem is exactly as 493, but we need to transform the two input\\n        # arrays to one first\\n        # nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff, can be written as\\n        # nums1[i] - nums2[i] <= nums1[j] - nums2[j]\\n        # Say nums1 - nums2 = arr\\n        # then above can be written as \\n        # a[i] <= a[j] + diff -- exactly like Reverse pairs but with <= instead of >\\n        # This <= instead of > affect the calculation of count only\\n        # see c += len(right) - j below, since if left[i] <= right[i] + diff\\n        # this will be true for all remaing j, since they are greater than this value\\n\\n        def merge_sort(nums):\\n            if len(nums) <= 1: return 0\\n            mid = len(nums) // 2\\n            left = nums[:mid]\\n            right = nums[mid:]\\n\\n            c_l = merge_sort(left)\\n            c_r = merge_sort(right)\\n\\n            # This part we count the pairs\\n            i = j = c = 0\\n            while i < len(left) and j < len(right):\\n                if left[i] <= right[j] + diff:\\n                    c += (len(right) - j)\\n                    i += 1\\n                else:\\n                    j += 1\\n            \\n            # here we do the regular merge of merge sort \\n            i = j = k = 0\\n            while i < len(left) and j < len(right):\\n                if right[j] < left[i]:\\n                    nums[k] = right[j]\\n                    j += 1\\n                else:\\n                    nums[k] = left[i]\\n                    i += 1\\n                k += 1\\n            \\n            while i < len(left):\\n                nums[k] = left[i]\\n                i += 1\\n                k += 1\\n            \\n            while j < len(right):\\n                nums[k] = right[j]\\n                j += 1\\n                k += 1\\n            \\n            return c_l + c_r + c\\n\\n        diff_arr = [a - b for (a, b) in zip(nums1, nums2)]\\n        return merge_sort(diff_arr) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842906,
                "title": "python-mergesort-no-sortedlist-no-insort",
                "content": "```\\nclass Solution:\\n    def numberOfPairs(self, n1: List[int], n2: List[int], d: int) -> int:\\n        n=len(n1)\\n        q=[n1[i]-n2[i] for i in range(n)]\\n        ans=0\\n        def merge(s):\\n            o=len(s)\\n            if o==1:\\n                return s\\n            nonlocal ans\\n            m=o//2\\n            x=merge(s[:m])\\n            y=merge(s[m:])\\n            b=len(y)\\n            for i in x:\\n                ans+=b-bisect_left(y,i-d)\\n            return sorted(x+y)\\n        merge(q)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, n1: List[int], n2: List[int], d: int) -> int:\\n        n=len(n1)\\n        q=[n1[i]-n2[i] for i in range(n)]\\n        ans=0\\n        def merge(s):\\n            o=len(s)\\n            if o==1:\\n                return s\\n            nonlocal ans\\n            m=o//2\\n            x=merge(s[:m])\\n            y=merge(s[m:])\\n            b=len(y)\\n            for i in x:\\n                ans+=b-bisect_left(y,i-d)\\n            return sorted(x+y)\\n        merge(q)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2661883,
                "title": "c-3-line-fenwick-tree-beats-99",
                "content": "I learned about Fenwick Trees today thanks to this problem. Much thanks to user Malomalomalomalo on Codeforces for his excellent write-up on Fenwick Trees / BITs. https://codeforces.com/blog/entry/57292\\nThe idea is to rearrange the problem into the problem: How many values are in front of a given index that are greater than or equal to it? Here is how I rearranged it:\\n\\nn1[i] - n1[j] <= n2[i] - n2[j] + d\\nn1[i] - n2[i] <= n1[j] - n2[j] + d\\nLet n3 = n1[i]-n2[i]:\\nn3[i] <= n3[j] + d\\nLet n4 = n3[i] + d:\\nn3[i] <= n4[j]\\nTherefore: Find all pairs such that n3[i] <= n4[j] and j > i.\\nWe don\\'t have to explicitly construct n3 and n4 arrays, but I decided to do so to better illustrate what is going on in the code.\\n\\nThis is a problem that may be solved using a Fenwick Tree // BIT. If you want to understand the BIT operations I highly recommend reading the codeforces post linked above. Negative indexes were a headache with BITs for me so I just shifted everything by 20001 due to the constraints.\\n\\n```\\nclass Solution {\\npublic:\\n    long long BIT[60002] = {};\\n    void update(int x, int val){ ++x;  while(x>=1)  {  BIT[x]+=val;  x-=(x&-x);  } }\\n    long long query(int x){  ++x;  long long res=0;  while(x<=60002)  {  res+=BIT[x];  x+=(x&-x);  } return res; }\\n\\t\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> v3(n, 0);\\n        vector<int> v4(n, 0);\\n        for(int i = 0 ; i < n; i++){ // construct v3 from algebraic manipulation\\n            v3[i] = nums1[i]-nums2[i]+20001; // negative indexing fix \\n        }\\n        for(int i = 0 ; i < n; i++){\\n            v4[i] = v3[i] + diff; // construct v4 from algebraic manipulation\\n        }\\n        long long ans = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            ans += query(v3[i]); // how many numbers in front of this index are greater or equal to it?\\n            update(v4[i], 1); // we update after the query because j must be greater than i\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long BIT[60002] = {}",
                "codeTag": "Java"
            },
            {
                "id": 2661253,
                "title": "bit",
                "content": "First thing to realize is that:\\n- `n1[i] - n1[j] <= n2[i] - n2[j] + diff`\\n\\nis the same as:\\n- `n1[i] - n2[i] <= n1[j] - n2[j] + diff`\\n\\nAs we go through our arrays, we count `n1[i] - n2[i]` values on the number line.\\n\\nThis way, we can use the prefix sum to find out how many values are less or equal to `n1[i] - n2[i] + diff`.\\n\\nBIT provides O(log n) operations for a mutating prefix sum.\\n\\n**C++**\\n```cpp\\nconstexpr int static n = 40001;\\nint bt[n + 1] = {};\\nlong long prefix_sum(int i)\\n{\\n    long long sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nlong long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n    long long res = 0, sz = n1.size();\\n    for (int i = 0; i < sz; ++i) {\\n        res += n1[i] - n2[i] + diff < -n / 2 ? 0 : n1[i] - n2[i] + diff >= n / 2 ?\\n            i : prefix_sum(n / 2 + n1[i] - n2[i] + diff);\\n        add(n / 2 + n1[i] - n2[i], 1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nconstexpr int static n = 40001;\\nint bt[n + 1] = {};\\nlong long prefix_sum(int i)\\n{\\n    long long sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nlong long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n    long long res = 0, sz = n1.size();\\n    for (int i = 0; i < sz; ++i) {\\n        res += n1[i] - n2[i] + diff < -n / 2 ? 0 : n1[i] - n2[i] + diff >= n / 2 ?\\n            i : prefix_sum(n / 2 + n1[i] - n2[i] + diff);\\n        add(n / 2 + n1[i] - n2[i], 1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2659812,
                "title": "c-both-100-99ms-75-4mb-bit-o-nlog-n-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int BIT[60001];\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long ans=0;\\n        for(int i=nums1.size()-1;i>=0;--i){\\n            nums1[i]-=nums2[i];\\n            for(int j=nums1[i]+30000;j<=60000;j+=j&-j)\\n                ans+=BIT[j];\\n            for(int j=nums1[i]+30000+diff;j;j-=j&-j)\\n                ++BIT[j];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n1.nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n-> (nums1[i] - nums2[i]) - (nums1[j] - nums2[j]) <= diff\\n-> let A[i] = nums1[i] - nums2[i]\\n-> A[i] <= diff + A[j].\\n2.use BIT to count and update each A[i] from end to begin.\\n3.the range of BIT = min(A[i])-diff ~ max(A[i])+diff = -10000-10000-diff ~ 10000+10000+diff -> -30000~30000.",
                "solutionTags": [
                    "C",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BIT[60001];\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long ans=0;\\n        for(int i=nums1.size()-1;i>=0;--i){\\n            nums1[i]-=nums2[i];\\n            for(int j=nums1[i]+30000;j<=60000;j+=j&-j)\\n                ans+=BIT[j];\\n            for(int j=nums1[i]+30000+diff;j;j-=j&-j)\\n                ++BIT[j];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655175,
                "title": "c-solutions-in-segment-tree-and-binary-search",
                "content": "**Segment tree solution : **\\n```\\nstruct segmentTree{\\n    std::vector<int> tree;\\n    const int N=40001;\\n    int size;\\n    \\n    segmentTree(){\\n        tree.resize(4*N, 0);\\n        return;\\n    }\\n    \\n    void update(int x, int left, int right, int key){\\n        if (left==right){\\n            tree[x]++;\\n            return;\\n        }\\n        int mid = (left+right)/2;\\n        if (key+20000>mid){\\n            update(2*x+1, mid+1, right, key);\\n        }else{\\n            update(2*x, left, mid, key);\\n        }\\n        tree[x] = tree[2*x] + tree[2*x+1];\\n        return;\\n    }\\n    \\n    //find the number of stored elements greater than or equal to a\\n    long long find(int x, int left, int right, int a){\\n        if (a <= left-20000){\\n            return tree[x];\\n        }\\n        if (a > right-20000){\\n            return 0;\\n        }\\n        int mid = (left+right)/2;\\n        long long temp;\\n        if (a <= (mid-20000)){\\n            temp = tree[2*x+1] + find(2*x, left, mid, a);\\n        }else{\\n            temp = find(2*x+1, mid+1, right, a);\\n        }\\n        return temp;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    std::vector<int> u;\\n    long long count=0;\\n    int temp;\\n    \\n    long long numberOfPairs(vector<int>& nums1,vector<int>& nums2,int diff){\\n        int n = nums1.size();\\n        u.resize(n, 0);\\n        for (int i=0; i<n; i++){\\n            u[i] = nums1[i] - nums2[i];\\n        }\\n        segmentTree sgTree = segmentTree(); \\n        int M=40001;\\n        for (int i=n-1; i>=0; i--){\\n            temp = sgTree.find(1, 0, M-1, u[i]-diff);\\n            count += temp;\\n            sgTree.update(1, 0, M-1, u[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Binary Search Solution :** \\n```\\nclass Solution {\\npublic:\\n    long long count = 0;\\n    int n;\\n    std::vector<int> v;\\n    std::vector<int> u;\\n    \\n    //find number of elements in u which are >= x\\n    int myBinarySearch(int x){\\n        if (x<=u[0]) return u.size();\\n        if (x>u.back()) return 0;\\n        int left = 0;\\n        int right = u.size()-1;\\n        //control u[left] < x <= u[right]\\n        int mid;\\n        while (left<right){\\n            if (right-left==1) break;\\n            mid = (left+right)/2;\\n            if (u[mid]<x){\\n                left = mid;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        return u.size()-right;\\n    }\\n    \\n    void myBinaryInsert(long long y){\\n        if (y>=u.back()){\\n            u.push_back(y);\\n            return;\\n        }\\n        if (y<=u[0]){\\n            u.insert(u.begin(), y);\\n            return;\\n        }\\n        int left=0, right=u.size()-1;\\n        int mid;\\n        //control u[left]<y<u[right] \\n        while (left<=right){\\n            if (right==left+1){\\n                u.insert(u.begin()+right, y);\\n                break;\\n            }\\n            mid = (left+right)/2;\\n            if (u[mid]==y){\\n                u.insert(u.begin()+mid, y);\\n                break;\\n            }else if (u[mid]<y){\\n                left = mid;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        return;        \\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        n = nums1.size();\\n        for (int i=0; i<n; i++){\\n            v.push_back(nums1[i]-nums2[i]);\\n        }\\n        u.push_back(v.back());\\n        long long test;\\n        for (int i=n-2; i>=0; i--){\\n            test = v[i]-diff;\\n            count += myBinarySearch(test);\\n            myBinaryInsert(v[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\nstruct segmentTree{\\n    std::vector<int> tree;\\n    const int N=40001;\\n    int size;\\n    \\n    segmentTree(){\\n        tree.resize(4*N, 0);\\n        return;\\n    }\\n    \\n    void update(int x, int left, int right, int key){\\n        if (left==right){\\n            tree[x]++;\\n            return;\\n        }\\n        int mid = (left+right)/2;\\n        if (key+20000>mid){\\n            update(2*x+1, mid+1, right, key);\\n        }else{\\n            update(2*x, left, mid, key);\\n        }\\n        tree[x] = tree[2*x] + tree[2*x+1];\\n        return;\\n    }\\n    \\n    //find the number of stored elements greater than or equal to a\\n    long long find(int x, int left, int right, int a){\\n        if (a <= left-20000){\\n            return tree[x];\\n        }\\n        if (a > right-20000){\\n            return 0;\\n        }\\n        int mid = (left+right)/2;\\n        long long temp;\\n        if (a <= (mid-20000)){\\n            temp = tree[2*x+1] + find(2*x, left, mid, a);\\n        }else{\\n            temp = find(2*x+1, mid+1, right, a);\\n        }\\n        return temp;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    std::vector<int> u;\\n    long long count=0;\\n    int temp;\\n    \\n    long long numberOfPairs(vector<int>& nums1,vector<int>& nums2,int diff){\\n        int n = nums1.size();\\n        u.resize(n, 0);\\n        for (int i=0; i<n; i++){\\n            u[i] = nums1[i] - nums2[i];\\n        }\\n        segmentTree sgTree = segmentTree(); \\n        int M=40001;\\n        for (int i=n-1; i>=0; i--){\\n            temp = sgTree.find(1, 0, M-1, u[i]-diff);\\n            count += temp;\\n            sgTree.update(1, 0, M-1, u[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long count = 0;\\n    int n;\\n    std::vector<int> v;\\n    std::vector<int> u;\\n    \\n    //find number of elements in u which are >= x\\n    int myBinarySearch(int x){\\n        if (x<=u[0]) return u.size();\\n        if (x>u.back()) return 0;\\n        int left = 0;\\n        int right = u.size()-1;\\n        //control u[left] < x <= u[right]\\n        int mid;\\n        while (left<right){\\n            if (right-left==1) break;\\n            mid = (left+right)/2;\\n            if (u[mid]<x){\\n                left = mid;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        return u.size()-right;\\n    }\\n    \\n    void myBinaryInsert(long long y){\\n        if (y>=u.back()){\\n            u.push_back(y);\\n            return;\\n        }\\n        if (y<=u[0]){\\n            u.insert(u.begin(), y);\\n            return;\\n        }\\n        int left=0, right=u.size()-1;\\n        int mid;\\n        //control u[left]<y<u[right] \\n        while (left<=right){\\n            if (right==left+1){\\n                u.insert(u.begin()+right, y);\\n                break;\\n            }\\n            mid = (left+right)/2;\\n            if (u[mid]==y){\\n                u.insert(u.begin()+mid, y);\\n                break;\\n            }else if (u[mid]<y){\\n                left = mid;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        return;        \\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        n = nums1.size();\\n        for (int i=0; i<n; i++){\\n            v.push_back(nums1[i]-nums2[i]);\\n        }\\n        u.push_back(v.back());\\n        long long test;\\n        for (int i=n-2; i>=0; i--){\\n            test = v[i]-diff;\\n            count += myBinarySearch(test);\\n            myBinaryInsert(v[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653840,
                "title": "c-solution-using-binary-indexed-tree-or-fenwick-tree",
                "content": "**Solution:**\\n```\\ntemplate<typename T>\\nclass BIT {\\npublic:\\n    vector<T> bit;\\n    int n;\\n    \\n    BIT(){}\\n    \\n    BIT(int _n) {\\n        n = _n;\\n        bit = vector<T>(n, 0);\\n    }\\n    \\n    void inc(int idx, T val) {\\n        for(int i = idx + 1; i <= n; i += (i & -i))\\n            bit[i - 1] += val;\\n    }\\n    \\n    T at(int idx) {\\n        T res = 0;\\n        for(int i = idx + 1; i > 0; i -= (i & -i))\\n            res += bit[i - 1];\\n        return res;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        BIT<long long> bit(1e5 + 2);\\n        int shift = 1e4;\\n        long long ans = 0;\\n        for(int i = 0; i < (int)nums1.size(); i++) {\\n            ans += bit.at(nums1[i] - nums2[i] + diff + 2 * shift);\\n            bit.inc(nums1[i] - nums2[i] + 2 * shift, 1);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "class Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        BIT<long long> bit(1e5 + 2);\\n        int shift = 1e4;\\n        long long ans = 0;\\n        for(int i = 0; i < (int)nums1.size(); i++) {\\n            ans += bit.at(nums1[i] - nums2[i] + diff + 2 * shift);\\n            bit.inc(nums1[i] - nums2[i] + 2 * shift, 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2653305,
                "title": "c-bit",
                "content": "```\\nclass Solution {\\npublic:\\n    long long bias = 40000 + 7;\\n    long long bit[100007];\\n    int n = 1e5;\\n    void update(int i, long long v){\\n        int x = i;\\n        while(x < n){\\n            bit[x] += v;\\n            x += (x&-x);\\n        }\\n    }\\n    long long sum(int i){\\n        long long s = 0;\\n        while(i>0){\\n            s = s + bit[i];\\n            i -= (i&-i);\\n        }\\n        return s;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        update(nums1[0] - nums2[0] + bias, 1);\\n        long long ans = 0;\\n        for(int i=1;i<n;i++){\\n            ans += sum(nums1[i] - nums2[i] + bias + diff);\\n            update(nums1[i] - nums2[i] + bias, 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long bias = 40000 + 7;\\n    long long bit[100007];\\n    int n = 1e5;\\n    void update(int i, long long v){\\n        int x = i;\\n        while(x < n){\\n            bit[x] += v;\\n            x += (x&-x);\\n        }\\n    }\\n    long long sum(int i){\\n        long long s = 0;\\n        while(i>0){\\n            s = s + bit[i];\\n            i -= (i&-i);\\n        }\\n        return s;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        update(nums1[0] - nums2[0] + bias, 1);\\n        long long ans = 0;\\n        for(int i=1;i<n;i++){\\n            ans += sum(nums1[i] - nums2[i] + bias + diff);\\n            update(nums1[i] - nums2[i] + bias, 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651776,
                "title": "python3-segment-tree-solution",
                "content": "```\\nclass segment_tree:\\n  \\n  def __init__(self, arr):\\n    self.len_ = len(arr)\\n    \\n    self.data_ = [0] * (self.len_ * 2)\\n    \\n    for t in range(self.len_, self.len_ * 2, 1):\\n        self.data_[t] = arr[t - self.len_]\\n      \\n    for t in range(self.len_-1, -1, -1): \\n        self.data_[t] = self.data_[t * 2] + self.data_[t * 2 + 1]\\n  \\n  def update(self, index, target):\\n    self.data_[index + self.len_] = target\\n    \\n    start = index + self.len_\\n    start = start // 2\\n    \\n    while start >= 1:\\n        self.data_[start] = self.data_[start*2] + self.data_[start*2+1]\\n        start = start // 2\\n  \\n  def query(self, left, right):\\n    left += self.len_\\n    right += self.len_\\n    \\n    res = 0\\n    \\n    while left < right:\\n        if left & 1:\\n            res += self.data_[left]\\n            left += 1\\n        if right & 1:\\n            right -= 1\\n            res += self.data_[right]\\n        left = left // 2\\n        right = right //2\\n      \\n    return res\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \\n        data = [ x-y for (x,y) in zip(nums1, nums2)]\\n        \\n        data2 = [(data[i] + diff, i) for i in range(len(data))]\\n         \\n        data2.sort(key = lambda x : x[0])\\n                \\n        st = segment_tree([1 for x in range(len(data2))])\\n        \\n        lookup = {}\\n        \\n        for t in range(len(data2)):\\n            lookup[data2[t][1]] = t \\n            \\n        data3 = [x[0] for x in data2]\\n        \\n        res = 0\\n        \\n        n = len(data)\\n        \\n        for i in range(len(data)):\\n            element = data[i]\\n            index = bisect.bisect_left(data3, element)\\n            index2 = lookup[i]\\n            st.update(index2, 0)\\n            if index < n:\\n                res += st.query(index, n)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass segment_tree:\\n  \\n  def __init__(self, arr):\\n    self.len_ = len(arr)\\n    \\n    self.data_ = [0] * (self.len_ * 2)\\n    \\n    for t in range(self.len_, self.len_ * 2, 1):\\n        self.data_[t] = arr[t - self.len_]\\n      \\n    for t in range(self.len_-1, -1, -1): \\n        self.data_[t] = self.data_[t * 2] + self.data_[t * 2 + 1]\\n  \\n  def update(self, index, target):\\n    self.data_[index + self.len_] = target\\n    \\n    start = index + self.len_\\n    start = start // 2\\n    \\n    while start >= 1:\\n        self.data_[start] = self.data_[start*2] + self.data_[start*2+1]\\n        start = start // 2\\n  \\n  def query(self, left, right):\\n    left += self.len_\\n    right += self.len_\\n    \\n    res = 0\\n    \\n    while left < right:\\n        if left & 1:\\n            res += self.data_[left]\\n            left += 1\\n        if right & 1:\\n            right -= 1\\n            res += self.data_[right]\\n        left = left // 2\\n        right = right //2\\n      \\n    return res\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \\n        data = [ x-y for (x,y) in zip(nums1, nums2)]\\n        \\n        data2 = [(data[i] + diff, i) for i in range(len(data))]\\n         \\n        data2.sort(key = lambda x : x[0])\\n                \\n        st = segment_tree([1 for x in range(len(data2))])\\n        \\n        lookup = {}\\n        \\n        for t in range(len(data2)):\\n            lookup[data2[t][1]] = t \\n            \\n        data3 = [x[0] for x in data2]\\n        \\n        res = 0\\n        \\n        n = len(data)\\n        \\n        for i in range(len(data)):\\n            element = data[i]\\n            index = bisect.bisect_left(data3, element)\\n            index2 = lookup[i]\\n            st.update(index2, 0)\\n            if index < n:\\n                res += st.query(index, n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651015,
                "title": "c-merge-sort",
                "content": "```\\n long long merge(int l, int mid, int r, vector<int>&arr, int &diff)  // merges two array after evaluation\\n    {\\n        long long cnt=0;\\n        int i=l, j= mid+1;\\n        while(i<=mid && j<=r)\\n        {\\n            if(arr[i]<=arr[j]+diff)    // base condition\\n            {\\n                cnt+= (r-j+1);   // number of elements from right side that hold condition \\n                i++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        sort(arr.begin()+l,arr.begin()+r+1);    \\n        return cnt;\\n    }\\n    \\n    long long mergesort(int l, int r, vector<int>&arr, int &diff)\\n    {\\n        if(l==r)\\n            return 0;\\n        int mid= (l+r)/2;\\n        long long cnt=0;\\n        cnt+= mergesort(l,mid,arr,diff);\\n        cnt+= mergesort(mid+1,r,arr,diff);\\n        cnt+= merge(l,mid,r,arr,diff);\\n        return cnt;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        vector<int>arr(nums1.size());\\n        for(int i=0;i<nums1.size();i++)\\n            arr[i]=nums1[i]-nums2[i];    // take difference of both arrays to perform merge sort easily \\n        \\n        return mergesort(0,nums1.size()-1,arr,diff);\\n    }\\n```",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\n long long merge(int l, int mid, int r, vector<int>&arr, int &diff)  // merges two array after evaluation\\n    {\\n        long long cnt=0;\\n        int i=l, j= mid+1;\\n        while(i<=mid && j<=r)\\n        {\\n            if(arr[i]<=arr[j]+diff)    // base condition\\n            {\\n                cnt+= (r-j+1);   // number of elements from right side that hold condition \\n                i++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        sort(arr.begin()+l,arr.begin()+r+1);    \\n        return cnt;\\n    }\\n    \\n    long long mergesort(int l, int r, vector<int>&arr, int &diff)\\n    {\\n        if(l==r)\\n            return 0;\\n        int mid= (l+r)/2;\\n        long long cnt=0;\\n        cnt+= mergesort(l,mid,arr,diff);\\n        cnt+= mergesort(mid+1,r,arr,diff);\\n        cnt+= merge(l,mid,r,arr,diff);\\n        return cnt;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        vector<int>arr(nums1.size());\\n        for(int i=0;i<nums1.size();i++)\\n            arr[i]=nums1[i]-nums2[i];    // take difference of both arrays to perform merge sort easily \\n        \\n        return mergesort(0,nums1.size()-1,arr,diff);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650145,
                "title": "simple-c-solution-using-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int count;\\n   \\n     void merge(vector<long> &arr,int low,int mid,int high,int diff){\\n        vector<long> temp(high-low+1);\\n        int i = low;\\n        int j = mid+1;\\n        int k = 0;\\n        \\n        while(i<=mid and j<=high){\\n            \\n            if(arr[i]<=diff+arr[j]){      // Just add this condition to simple merge sort\\n                count += high-j+1;      \\n                i++;\\n             }\\n             else{\\n                 j++;\\n             }\\n          }\\n        \\n         i = low;\\n         j = mid+1;\\n         while(i<=mid and j<=high){a\\n             if(arr[i]<=arr[j]){\\n                 temp[k++] = arr[i++];\\n             }\\n             else{\\n                 temp[k++] = arr[j++];\\n\\n             }\\n         }\\n         while(i<=mid){\\n             temp[k++] = arr[i++];\\n         }\\n         while(j<=high){\\n             temp[k++] = arr[j++];\\n         }\\n         k=0;\\n         for(int z = low; z<=high; z++,k++){\\n             arr[z] = temp[k];\\n         }\\n        \\n    }\\n    void mergeSort(vector<long>& nums, int start, int end,int d)\\n    {\\n        if(start >= end) \\n            return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid,d);\\n        mergeSort(nums,mid+1,end,d);\\n        \\n        merge(nums,start,mid,end,d);\\n        return;\\n        \\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) \\n    {\\n        count = 0;\\n        int size = nums1.size();\\n         \\n        vector<long> new_num(size);\\n        \\n        for(int i=0;i<size;i++)             /*Make a new array by subtracting 2nd array from first*/\\n        new_num[i]=nums1[i]-nums2[i];               \\n\\t\\t\\t\\n        mergeSort(new_num,0,size-1,diff);\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int count;\\n   \\n     void merge(vector<long> &arr,int low,int mid,int high,int diff){\\n        vector<long> temp(high-low+1);\\n        int i = low;\\n        int j = mid+1;\\n        int k = 0;\\n        \\n        while(i<=mid and j<=high){\\n            \\n            if(arr[i]<=diff+arr[j]){      // Just add this condition to simple merge sort\\n                count += high-j+1;      \\n                i++;\\n             }\\n             else{\\n                 j++;\\n             }\\n          }\\n        \\n         i = low;\\n         j = mid+1;\\n         while(i<=mid and j<=high){a\\n             if(arr[i]<=arr[j]){\\n                 temp[k++] = arr[i++];\\n             }\\n             else{\\n                 temp[k++] = arr[j++];\\n\\n             }\\n         }\\n         while(i<=mid){\\n             temp[k++] = arr[i++];\\n         }\\n         while(j<=high){\\n             temp[k++] = arr[j++];\\n         }\\n         k=0;\\n         for(int z = low; z<=high; z++,k++){\\n             arr[z] = temp[k];\\n         }\\n        \\n    }\\n    void mergeSort(vector<long>& nums, int start, int end,int d)\\n    {\\n        if(start >= end) \\n            return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid,d);\\n        mergeSort(nums,mid+1,end,d);\\n        \\n        merge(nums,start,mid,end,d);\\n        return;\\n        \\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) \\n    {\\n        count = 0;\\n        int size = nums1.size();\\n         \\n        vector<long> new_num(size);\\n        \\n        for(int i=0;i<size;i++)             /*Make a new array by subtracting 2nd array from first*/\\n        new_num[i]=nums1[i]-nums2[i];               \\n\\t\\t\\t\\n        mergeSort(new_num,0,size-1,diff);\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650092,
                "title": "c-simple-fenwick-tree-solution-detailed-explanation",
                "content": "Given, `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`\\n\\nIt can be rewritten as: \\n-> `nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff`\\n-> `nums1[j] - nums2[j] + diff >= nums1[i] - nums2[i]`\\n\\nSo, we need to **find no.of elements that are >= nums1[j] - nums2[j] + diff**\\n\\n**Pre-requisite:** Please solve the below problems first before solving the current problem\\n[493. Reverse Pairs](https://leetcode.com/problems/reverse-pairs/)\\n[315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)\\n[1395. Count Number of Teams](https://leetcode.com/problems/count-number-of-teams/)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> BIT;\\n    void update(int ind){\\n        while(ind < BIT.size()){\\n            BIT[ind] += 1;\\n            ind += (ind&-ind);\\n        }\\n    }\\n    \\n    int query(int n){\\n        int ans = 0;\\n        while(n > 0){\\n            ans += BIT[n];\\n            n -= (n&-n);\\n        }\\n        return ans;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        BIT.resize(50002, 0);\\n        long long ans = 0;\\n        \\n        for(int j=0; j<n; j++){\\n\\t\\t\\t// Adding 20001 to make indices neutral and non-negative\\n            int d = nums1[j]-nums2[j]+20001;\\n\\t\\t\\t// Find no.of elements that are greater than or equal to nums1[j]-nums2[j]+diff\\n            ans += query(d+diff);\\n\\t\\t\\t// Updating the count for nums1[j]-nums2[j], as it becomes nums1[i]-nums2[i] for the next elements\\n            update(d);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> BIT;\\n    void update(int ind){\\n        while(ind < BIT.size()){\\n            BIT[ind] += 1;\\n            ind += (ind&-ind);\\n        }\\n    }\\n    \\n    int query(int n){\\n        int ans = 0;\\n        while(n > 0){\\n            ans += BIT[n];\\n            n -= (n&-n);\\n        }\\n        return ans;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        BIT.resize(50002, 0);\\n        long long ans = 0;\\n        \\n        for(int j=0; j<n; j++){\\n\\t\\t\\t// Adding 20001 to make indices neutral and non-negative\\n            int d = nums1[j]-nums2[j]+20001;\\n\\t\\t\\t// Find no.of elements that are greater than or equal to nums1[j]-nums2[j]+diff\\n            ans += query(d+diff);\\n\\t\\t\\t// Updating the count for nums1[j]-nums2[j], as it becomes nums1[i]-nums2[i] for the next elements\\n            update(d);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2649245,
                "title": "c-ordered-set-google-oa",
                "content": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntypedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> pbds; \\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long re = 0;\\n        pbds st;\\n        for(int i = 0; i<nums1.size(); ++i){\\n            int k = nums1[i]-nums2[i]+diff+1;\\n            re+= st.order_of_key(k);\\n            k = nums1[i]-nums2[i];\\n            st.insert(k);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntypedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> pbds; \\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long re = 0;\\n        pbds st;\\n        for(int i = 0; i<nums1.size(); ++i){\\n            int k = nums1[i]-nums2[i]+diff+1;\\n            re+= st.order_of_key(k);\\n            k = nums1[i]-nums2[i];\\n            st.insert(k);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2648332,
                "title": "merge-sort-binary-search",
                "content": "#define ll long long int \\n\\n\\n// v[i]-v[j]<=diff\\n// v[j]>=v[i]-diff\\n\\nclass Solution {\\npublic:\\n    \\n    int d;ll cnt=0;\\n    \\n    void merge(int left,int mid,int right,vector<int>& v){\\n        \\n        vector <int> temp (right-left+1);\\n        \\n        for(int a=left;a<=mid;a++)\\n        {\\n           int l = mid+1,r=right,id=-1;\\n           \\n            while(l<=r){\\n                \\n                int mid = (l+r)/2;\\n                \\n                if(v[mid]>=v[a]-d){\\n                    id = mid;\\n                    r = mid-1;\\n                }else{\\n                    l = mid+1;\\n                }\\n            }\\n            if(id!=-1)cnt += (right-id+1);\\n        }    \\n        \\n        int i=left,j=mid+1,k=0;\\n        \\n        while(i<=mid and j<=right){\\n            \\n            if(v[i]<=v[j]){\\n                temp[k++]=v[i++];\\n            }else{\\n                temp[k++]=v[j++];\\n            }\\n        }\\n        \\n        while(i<=mid)temp[k++]=v[i++];\\n        while(j<=right)temp[k++]=v[j++];\\n        \\n        for(int i=left;i<=right;i++)v[i]=temp[i-left];\\n        return;\\n    }\\n    \\n    void mergesort(int left,int right,vector<int>& v){\\n        \\n        if(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            mergesort(left,mid,v);\\n            mergesort(mid+1,right,v);\\n            merge(left,mid,right,v);\\n        }    \\n    }\\n    \\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        \\n        int n = nums1.size();\\n        vector <int> v(n);\\n        \\n        for(int i=0;i<n;i++)v[i] = nums1[i]-nums2[i];\\n        \\n        d = diff;\\n        mergesort(0,n-1,v);\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int d;ll cnt=0;\\n    \\n    void merge(int left,int mid,int right,vector<int>& v){\\n        \\n        vector <int> temp (right-left+1);\\n        \\n        for(int a=left;a<=mid;a++)\\n        {\\n           int l = mid+1,r=right,id=-1;\\n           \\n            while(l<=r){\\n                \\n                int mid = (l+r)/2;\\n                \\n                if(v[mid]>=v[a]-d){\\n                    id = mid;\\n                    r = mid-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2648280,
                "title": "golang-binary-search-with-explanation",
                "content": "The naive solution is as follows:\\n```go\\nfunc numberOfPairs(nums1 []int, nums2 []int, diff int) int64 {\\n        var result int64\\n        for i := 0; i < len(nums1); i++ {\\n                for j := i + 1; j < len(nums1); j++ {\\n                        if nums1[i]-nums1[j] <= nums2[i]-nums2[j]+diff {\\n                                result++\\n                        }\\n                }\\n        }\\n        return result\\n}\\n```\\n\\nBut this gives TLE which is expected since it\\'s `O(N^2)`. Need to optimize it.\\n\\nFirst of all the initial expression needs to be rearranged:\\n1. Initial expression\\n`nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`\\n2. Move the `nums2[i]` to the left and `nums1[j]` to the right.\\n`nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff`\\n3. This means that in fact we are working with only single array which is calculated by substructing one from another:\\n`(nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff`\\n`nums1[i] - nums2[i] = nums[i]`\\n`nums1[j] - nums2[j] = nums[j]`\\n`nums[i] <= nums[j] + diff`\\n4. Once we realized that there is only single array we have to find the number of times when each element is less or equal than the right elements with a `diff`:\\n`0 <= i < j <= n - 1`\\n`nums[i] <= nums[j] + diff`\\n5. For sure this can be done by nested loop but it returns us to the same state when we were in the beginning when wanted to avoid O(N^2) solution.\\n6. We want to iterate over each element and find how many elements to the right of it with `diff` less or equal to the element itself. Basically it\\'s the same when we say for the next element that `how many elements I\\'ve beat when incremented by diff`, i.e. the algorightm will look like the following:\\n- take the both elements from `nums1` and `nums2` and substruct them from each other\\n- check what position will be for the `nums1[i] - nums2[i] + diff` in the sorted array. This position will be added to the results as it exactly shows how many elements to the left less or equal to the current `nums1[i] - nums2[i] + diff`\\n- insert the number itself to the sorted array `nums1[i] - nums2[i]` so that on the next iteration with the following element we could do the same operations\\n\\n```go\\nfunc numberOfPairs(nums1 []int, nums2 []int, diff int) int64 {\\n\\tvar result int64\\n\\tn := len(nums1)\\n\\n\\tsortedDiffs := make([]int, 0)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tnum := nums1[i] - nums2[i]\\n\\t\\t// check what position will be for the `num+diff` in the\\n\\t\\t// sorted array. It will be the number of the values to be added to the result\\n\\t\\tresult += int64(getInsertPos(sortedDiffs, num+diff))\\n\\t\\tpos := getInsertPos(sortedDiffs, num)\\n\\n\\t\\t// insert the value to the position\\n\\t\\tsortedDiffs = append(sortedDiffs, 0)\\n\\t\\tcopy(sortedDiffs[pos+1:], sortedDiffs[pos:])\\n\\t\\tsortedDiffs[pos] = nums1[i] - nums2[i]\\n\\t}\\n\\n\\treturn result\\n}\\n\\n// Find the proper position to insert the value\\nfunc getInsertPos(slice []int, x int) int {\\n\\tl, r := 0, len(slice)\\n\\tfor l < r {\\n\\t\\tmid := l + (r-l)/2\\n\\t\\tif x < slice[mid] {\\n\\t\\t\\tr = mid\\n\\t\\t} else {\\n\\t\\t\\tl = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn l\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```go\\nfunc numberOfPairs(nums1 []int, nums2 []int, diff int) int64 {\\n        var result int64\\n        for i := 0; i < len(nums1); i++ {\\n                for j := i + 1; j < len(nums1); j++ {\\n                        if nums1[i]-nums1[j] <= nums2[i]-nums2[j]+diff {\\n                                result++\\n                        }\\n                }\\n        }\\n        return result\\n}\\n```\n```go\\nfunc numberOfPairs(nums1 []int, nums2 []int, diff int) int64 {\\n\\tvar result int64\\n\\tn := len(nums1)\\n\\n\\tsortedDiffs := make([]int, 0)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tnum := nums1[i] - nums2[i]\\n\\t\\t// check what position will be for the `num+diff` in the\\n\\t\\t// sorted array. It will be the number of the values to be added to the result\\n\\t\\tresult += int64(getInsertPos(sortedDiffs, num+diff))\\n\\t\\tpos := getInsertPos(sortedDiffs, num)\\n\\n\\t\\t// insert the value to the position\\n\\t\\tsortedDiffs = append(sortedDiffs, 0)\\n\\t\\tcopy(sortedDiffs[pos+1:], sortedDiffs[pos:])\\n\\t\\tsortedDiffs[pos] = nums1[i] - nums2[i]\\n\\t}\\n\\n\\treturn result\\n}\\n\\n// Find the proper position to insert the value\\nfunc getInsertPos(slice []int, x int) int {\\n\\tl, r := 0, len(slice)\\n\\tfor l < r {\\n\\t\\tmid := l + (r-l)/2\\n\\t\\tif x < slice[mid] {\\n\\t\\t\\tr = mid\\n\\t\\t} else {\\n\\t\\t\\tl = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648256,
                "title": "java-segment-tree",
                "content": "```\\nclass Solution {\\n    private long seg[];\\n    private int offset;\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        int DIFF[] = new int[n];\\n        \\n        for(int i = 0; i<n; i++)\\n            DIFF[i] = nums1[i] - nums2[i];\\n        \\n        int min = Arrays.stream(DIFF).min().getAsInt();\\n        min = Math.min(min, min + diff);\\n        int max = Arrays.stream(DIFF).max().getAsInt();\\n        \\n        if(min < 0)\\n            this.offset = -1*min;\\n        else this.offset = 0;\\n        \\n        long ans = 0L;\\n        this.seg = new long[4*(max + offset) + 5];\\n        for(int x: D) {\\n            ans += rangeSum(0, 0, max + offset, min + offset, x + diff + offset);\\n            pointUpdate(0, 0, max + offset, x + offset);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void pointUpdate(int segIdx, int left, int right, int updateIdx) {\\n        if(left == right && left == updateIdx) {\\n            this.seg[segIdx]++;\\n            return;\\n        }\\n        \\n        if(updateIdx < left || updateIdx > right)\\n            return;\\n        \\n        int mid = (left + right)/2;\\n        pointUpdate(2*segIdx+1, left, mid, updateIdx);\\n        pointUpdate(2*segIdx+2, mid+1, right, updateIdx);\\n        this.seg[segIdx] = this.seg[2*segIdx+1] + this.seg[2*segIdx+2];\\n        return;\\n    }\\n    \\n    long rangeSum(int segIdx, int left, int right, int l, int r) {\\n        if(r < left || right < l)\\n            return 0L;\\n        \\n        if(left >= l && right <= r)\\n            return this.seg[segIdx];\\n        \\n        int mid = (left + right)/2;\\n        return rangeSum(2*segIdx+1, left, mid, l, r) + rangeSum(2*segIdx+2, mid+1, right, l, r);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private long seg[];\\n    private int offset;\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        int DIFF[] = new int[n];\\n        \\n        for(int i = 0; i<n; i++)\\n            DIFF[i] = nums1[i] - nums2[i];\\n        \\n        int min = Arrays.stream(DIFF).min().getAsInt();\\n        min = Math.min(min, min + diff);\\n        int max = Arrays.stream(DIFF).max().getAsInt();\\n        \\n        if(min < 0)\\n            this.offset = -1*min;\\n        else this.offset = 0;\\n        \\n        long ans = 0L;\\n        this.seg = new long[4*(max + offset) + 5];\\n        for(int x: D) {\\n            ans += rangeSum(0, 0, max + offset, min + offset, x + diff + offset);\\n            pointUpdate(0, 0, max + offset, x + offset);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void pointUpdate(int segIdx, int left, int right, int updateIdx) {\\n        if(left == right && left == updateIdx) {\\n            this.seg[segIdx]++;\\n            return;\\n        }\\n        \\n        if(updateIdx < left || updateIdx > right)\\n            return;\\n        \\n        int mid = (left + right)/2;\\n        pointUpdate(2*segIdx+1, left, mid, updateIdx);\\n        pointUpdate(2*segIdx+2, mid+1, right, updateIdx);\\n        this.seg[segIdx] = this.seg[2*segIdx+1] + this.seg[2*segIdx+2];\\n        return;\\n    }\\n    \\n    long rangeSum(int segIdx, int left, int right, int l, int r) {\\n        if(r < left || right < l)\\n            return 0L;\\n        \\n        if(left >= l && right <= r)\\n            return this.seg[segIdx];\\n        \\n        int mid = (left + right)/2;\\n        return rangeSum(2*segIdx+1, left, mid, l, r) + rangeSum(2*segIdx+2, mid+1, right, l, r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648036,
                "title": "python-made-easy-6-lines-insort-bisect-explained",
                "content": "We rewite the equation this way:\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n\\nWe iterate and store i indices from left to right **inorder**. These i indices are previously visited j indices. When we are at a current index (j), we bisect stored array to find index slightly greater than nums1[j] - nums2[j] + diff. For every index less than the bisect index, we are sure it will satisfy the equation. So we add the bisect index to the answer.\\n\\nComment if it needs improvement. **Upvote if it helped :)**\\n```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:        \\n        prev, ans = [], 0\\n        \\n        for j in range(len(nums1)):\\n            search = nums1[j] - nums2[j] + diff\\n            ans += bisect_right(prev, search)        \\n            insort(prev, nums1[j] - nums2[j])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:        \\n        prev, ans = [], 0\\n        \\n        for j in range(len(nums1)):\\n            search = nums1[j] - nums2[j] + diff\\n            ans += bisect_right(prev, search)        \\n            insort(prev, nums1[j] - nums2[j])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647517,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    void update(vector<int>& seg, int idx, int l, int r, int val)\\n    {\\n        if(l>r)\\n            return;\\n        if(l==r)\\n        {\\n             if(val==l)\\n             {\\n                 seg[idx]++;\\n             }\\n            return;\\n        }\\n        int mid = (l+r)/2;\\n        if(val>=l && val<=mid)\\n        update(seg, idx*2+1, l, mid, val);\\n        else\\n        update(seg, idx*2+2, mid+1, r, val);\\n        seg[idx] = seg[idx*2+1]+seg[idx*2+2];\\n        \\n    }\\n    \\n    int query(vector<int>& seg, int idx, int l, int r, int ll, int rr)\\n    {\\n        if(l>rr || r<ll)\\n        {\\n            return 0;\\n        }\\n        if(l>=ll && r<=rr)\\n        {\\n            return seg[idx];\\n        }\\n        int mid = (l+r)/2;\\n        int p1 =  query(seg, idx*2+1, l, mid, ll,rr);\\n        int p2 =   query(seg, idx*2+2, mid+1, r, ll, rr);\\n        return p1+p2;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) \\n    {\\n        int  n = nums1.size();\\n        vector<int>v(n);\\n        for(int i =  0;i<n;i++)\\n        {\\n            v[i] = (nums1[i]-nums2[i])+20000;    \\n        }\\n       long long int ans = 0;\\n        \\n        vector<int>seg(160004,0);\\n        int nn = 40001;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            int pp = query(seg, 0, 0, nn, 0, v[i]+diff );\\n            ans += pp;\\n            update(seg, 0, 0, nn, v[i]);\\n        }\\n        return ans;\\n              \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void update(vector<int>& seg, int idx, int l, int r, int val)\\n    {\\n        if(l>r)\\n            return;\\n        if(l==r)\\n        {\\n             if(val==l)\\n             {\\n                 seg[idx]++;\\n             }\\n            return;\\n        }\\n        int mid = (l+r)/2;\\n        if(val>=l && val<=mid)\\n        update(seg, idx*2+1, l, mid, val);\\n        else\\n        update(seg, idx*2+2, mid+1, r, val);\\n        seg[idx] = seg[idx*2+1]+seg[idx*2+2];\\n        \\n    }\\n    \\n    int query(vector<int>& seg, int idx, int l, int r, int ll, int rr)\\n    {\\n        if(l>rr || r<ll)\\n        {\\n            return 0;\\n        }\\n        if(l>=ll && r<=rr)\\n        {\\n            return seg[idx];\\n        }\\n        int mid = (l+r)/2;\\n        int p1 =  query(seg, idx*2+1, l, mid, ll,rr);\\n        int p2 =   query(seg, idx*2+2, mid+1, r, ll, rr);\\n        return p1+p2;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) \\n    {\\n        int  n = nums1.size();\\n        vector<int>v(n);\\n        for(int i =  0;i<n;i++)\\n        {\\n            v[i] = (nums1[i]-nums2[i])+20000;    \\n        }\\n       long long int ans = 0;\\n        \\n        vector<int>seg(160004,0);\\n        int nn = 40001;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            int pp = query(seg, 0, 0, nn, 0, v[i]+diff );\\n            ans += pp;\\n            update(seg, 0, 0, nn, v[i]);\\n        }\\n        return ans;\\n              \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647438,
                "title": "python-concise",
                "content": "Start by shuffling the equation to only have one index on each side of the equation as follows:\\n\\n```\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n```\\n\\n* Iterate through the array and compute the difference: `nums1[i] - nums2[i]`.\\n* All the previous candidates for index i are stored in an array `diff_lst`.\\n* Binary search the number of values less than the difference plus `diff`.\\n* Insort the difference value into `diff_lst`.\\n\\n```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        l = len(nums1)\\n        \\n        diff_lst = []\\n        res = 0\\n        for i in range(l):\\n            cur_diff = nums1[i] - nums2[i]\\n            cand = cur_diff + diff\\n            \\n            index = bisect.bisect_right(diff_lst, cand)\\n            res += index\\n            \\n            bisect.insort(diff_lst, cur_diff)\\n\\n        return res\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n```\n```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        l = len(nums1)\\n        \\n        diff_lst = []\\n        res = 0\\n        for i in range(l):\\n            cur_diff = nums1[i] - nums2[i]\\n            cand = cur_diff + diff\\n            \\n            index = bisect.bisect_right(diff_lst, cand)\\n            res += index\\n            \\n            bisect.insort(diff_lst, cur_diff)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647377,
                "title": "c-easy-fenwick-tree-bit-solution-o-n-log-n",
                "content": "##### Prerequisites\\n\\u2022 Fenwick Tree (Binary Indexed Tree)\\n\\u2022 or Ordered Set\\n\\n##### What we are given\\n\\u2022 nums1[] (say a) of size n\\n\\u2022 nums2[] (say b) of size n\\n\\u2022 diff (say d)\\n\\nNow we need to find the count of pairs\\n```\\n(i, j), such that\\na[i] - a[j] <= b[i] - b[j] + d, where 0 <= i < j < n\\n```\\n\\nWe can simplify the above condition as\\n```\\na[i] - a[j] <= b[i] - b[j] + d\\na[i] - a[j] - b[i] + b[j] <= d\\n(a[i] - b[i]) - (a[j] - b[j]) <= d\\n```\\n    \\n> Here, if we replace\\n```\\na[i] --> a[i] - b[i] for i --> 0 ... n-1\\n```\\n> then the above equation can be further simplified to\\n\\n```\\n(a[i] - b[i]) - (a[j] - b[j]) <= d\\n\\na[i] - b[i] --> a[i]\\na[j] - b[j] --> a[j]\\n\\na[i] - a[j] <= d\\n```\\n\\n> or for easy implementation in code\\n\\n```\\na[i] - d <= a[j]\\n```\\n\\n> now we can just count the values >= (a[i] - d) for i --> 0 ... n-1,\\n> using ordered set or binary indexed tree\\n\\n### Solution (C++)\\n```\\nstruct Solution {\\n    \\n    const static int N = 60006;\\n    \\n    int bit[N] = {};\\n    \\n    int sum(int i) {\\n        int res = 0;\\n        for (; i; i -= (-i&i)) {\\n            res += bit[i];\\n        }\\n        return res;\\n    }\\n        \\n    void add(int i) {\\n        for (; i < N; i += (-i&i)) {\\n            bit[i] += 1;\\n        }\\n    }\\n    \\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int d) {\\n        \\n        int n = size(a);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            a[i] = a[i] - b[i] + 30002;\\n        }\\n        \\n        add(a[n-1]);\\n        ++d;\\n        \\n        long long ans = 0;\\n        \\n        for (int i = n-2; i >= 0; --i) {\\n            ans += sum(60004) - sum(a[i] - d);\\n            add(a[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nTC: O(N\\u2022Log(N))\\nSC: O(N)\\n\\nPlease upvote if found helpful \\uD83D\\uDE42\\nFor any query or doubt or correction just ask\\nI will be Happy to help...",
                "solutionTags": [
                    "C",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n(i, j), such that\\na[i] - a[j] <= b[i] - b[j] + d, where 0 <= i < j < n\\n```\n```\\na[i] - a[j] <= b[i] - b[j] + d\\na[i] - a[j] - b[i] + b[j] <= d\\n(a[i] - b[i]) - (a[j] - b[j]) <= d\\n```\n```\\na[i] --> a[i] - b[i] for i --> 0 ... n-1\\n```\n```\\n(a[i] - b[i]) - (a[j] - b[j]) <= d\\n\\na[i] - b[i] --> a[i]\\na[j] - b[j] --> a[j]\\n\\na[i] - a[j] <= d\\n```\n```\\na[i] - d <= a[j]\\n```\n```\\nstruct Solution {\\n    \\n    const static int N = 60006;\\n    \\n    int bit[N] = {};\\n    \\n    int sum(int i) {\\n        int res = 0;\\n        for (; i; i -= (-i&i)) {\\n            res += bit[i];\\n        }\\n        return res;\\n    }\\n        \\n    void add(int i) {\\n        for (; i < N; i += (-i&i)) {\\n            bit[i] += 1;\\n        }\\n    }\\n    \\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int d) {\\n        \\n        int n = size(a);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            a[i] = a[i] - b[i] + 30002;\\n        }\\n        \\n        add(a[n-1]);\\n        ++d;\\n        \\n        long long ans = 0;\\n        \\n        for (int i = n-2; i >= 0; --i) {\\n            ans += sum(60004) - sum(a[i] - d);\\n            add(a[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647281,
                "title": "c-9-liners-solution-using-bit",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    long long bit[200001]={};\\n    void update(int x)\\n    {\\n        for(int i=x+1;i<200001;i+=i&-i) bit[i]++;\\n    }\\n    long long get(int x)\\n    {\\n        long long s=0;\\n        for(int i=x;i>0;i-=i&-i) s+=bit[i];\\n        return s;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) \\n    {\\n        long long result=0,n=nums1.size();\\n        for(int i=0;i<n;i++) nums1[i]-=nums2[i]-100000;\\n        for(int i=0;i<n;i++) result+=get(nums1[i]+1), update(nums1[i]-diff);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    long long bit[200001]={};\\n    void update(int x)\\n    {\\n        for(int i=x+1;i<200001;i+=i&-i) bit[i]++;\\n    }\\n    long long get(int x)\\n    {\\n        long long s=0;\\n        for(int i=x;i>0;i-=i&-i) s+=bit[i];\\n        return s;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) \\n    {\\n        long long result=0,n=nums1.size();\\n        for(int i=0;i<n;i++) nums1[i]-=nums2[i]-100000;\\n        for(int i=0;i<n;i++) result+=get(nums1[i]+1), update(nums1[i]-diff);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647226,
                "title": "java",
                "content": "```\\nIntution:\\n\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\ncan be written as\\nnums1[i] - nums2[i] - (nums1[j] - nums2[j]) <= diff\\n\\nnow we create another array nums which consists of difference of nums1[idx] - nums2[idx]  where 0 <= idx < n\\n\\nFor array nums we have find a how many numbers are present on right of particular index idx which are greater than equal to nums[idx] - diff  \\nThis can be found using merge sort and binary search\\n\\nbs funtion returns the index of first element which is greater than equal to val\\n```\\n\\n\\n```\\nclass Solution {\\n    long ans = 0;\\n    int dif;\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        dif = diff;\\n        int[] nums = new int[nums1.length];\\n        for(int i = 0; i < nums2.length; i++) {\\n            nums[i] = nums1[i]-nums2[i];\\n        }\\n        \\n        nums = mergeSort(nums);\\n        return ans;\\n    }\\n    \\n    public int[] mergeSort(int[] arr) {\\n        if(arr.length == 1) {\\n            return arr;\\n        }\\n        int mid = arr.length/2;\\n        int[] left = mergeSort(Arrays.copyOfRange(arr,0,mid));\\n        int[] right = mergeSort(Arrays.copyOfRange(arr,mid,arr.length));\\n        \\n        return merge(left,right);\\n    }\\n    \\n    public int[] merge(int[] left, int[] right) {\\n        int[] arr = new int[left.length+right.length];\\n        int i = 0;\\n        int j = 0;\\n        int idx = 0;\\n        while(i < left.length && j < right.length) {\\n            if(left[i] <= right[j]) {\\n                int id = bs(right, left[i]-dif);\\n                arr[idx] = left[i];\\n                i++;\\n                idx++;\\n                ans += right.length-id;\\n            } else {\\n                arr[idx] = right[j];\\n                j++;\\n                idx++;\\n            }\\n        }\\n        \\n        while(i < left.length) {\\n            int id = bs(right, left[i]-dif);\\n            arr[idx] = left[i];\\n            i++;\\n            idx++;\\n            ans += right.length-id;\\n        }\\n        \\n        while(j < right.length) {\\n            arr[idx] = right[j];\\n            j++;\\n            idx++;\\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public int bs(int[] arr, int val) {\\n        int start = 0;\\n        int end = arr.length-1;\\n        \\n        while(start <= end) {\\n            int mid = (start+end)/2;\\n            \\n            if(arr[mid] >= val) {\\n                end = mid-1;\\n            } else {\\n                start = mid+1;\\n            }\\n        }\\n        \\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\nIntution:\\n\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\ncan be written as\\nnums1[i] - nums2[i] - (nums1[j] - nums2[j]) <= diff\\n\\nnow we create another array nums which consists of difference of nums1[idx] - nums2[idx]  where 0 <= idx < n\\n\\nFor array nums we have find a how many numbers are present on right of particular index idx which are greater than equal to nums[idx] - diff  \\nThis can be found using merge sort and binary search\\n\\nbs funtion returns the index of first element which is greater than equal to val\\n```\n```\\nclass Solution {\\n    long ans = 0;\\n    int dif;\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        dif = diff;\\n        int[] nums = new int[nums1.length];\\n        for(int i = 0; i < nums2.length; i++) {\\n            nums[i] = nums1[i]-nums2[i];\\n        }\\n        \\n        nums = mergeSort(nums);\\n        return ans;\\n    }\\n    \\n    public int[] mergeSort(int[] arr) {\\n        if(arr.length == 1) {\\n            return arr;\\n        }\\n        int mid = arr.length/2;\\n        int[] left = mergeSort(Arrays.copyOfRange(arr,0,mid));\\n        int[] right = mergeSort(Arrays.copyOfRange(arr,mid,arr.length));\\n        \\n        return merge(left,right);\\n    }\\n    \\n    public int[] merge(int[] left, int[] right) {\\n        int[] arr = new int[left.length+right.length];\\n        int i = 0;\\n        int j = 0;\\n        int idx = 0;\\n        while(i < left.length && j < right.length) {\\n            if(left[i] <= right[j]) {\\n                int id = bs(right, left[i]-dif);\\n                arr[idx] = left[i];\\n                i++;\\n                idx++;\\n                ans += right.length-id;\\n            } else {\\n                arr[idx] = right[j];\\n                j++;\\n                idx++;\\n            }\\n        }\\n        \\n        while(i < left.length) {\\n            int id = bs(right, left[i]-dif);\\n            arr[idx] = left[i];\\n            i++;\\n            idx++;\\n            ans += right.length-id;\\n        }\\n        \\n        while(j < right.length) {\\n            arr[idx] = right[j];\\n            j++;\\n            idx++;\\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public int bs(int[] arr, int val) {\\n        int start = 0;\\n        int end = arr.length-1;\\n        \\n        while(start <= end) {\\n            int mid = (start+end)/2;\\n            \\n            if(arr[mid] >= val) {\\n                end = mid-1;\\n            } else {\\n                start = mid+1;\\n            }\\n        }\\n        \\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647184,
                "title": "c-merge-sort-o-nlog-n",
                "content": "**SIMILAR QUESTION AS :  (315. Count of Smaller Numbers After Self) **https://leetcode.com/problems/count-of-smaller-numbers-after-self/\\n```\\nclass Solution \\n{\\n    public:\\n    long long ans=0;\\n    void merge(vector<int> &v,int l,int mid,int r,int diff)\\n    {\\n        vector<int> temp(r-l+1);\\n        int i=l;\\n        int j=mid+1;\\n        int k=0;\\n        while(j<=r)\\n        {\\n            while(i<=mid && v[i]<=v[j]+diff)\\n                i++;\\n            j++;\\n            ans+=(long long)(i-l);\\n        }\\n        i=l;j=mid+1;\\n        while(i<=mid && j<=r)\\n        {\\n            if(v[i]<v[j])\\n                temp[k++]=v[i++];\\n            else\\n                temp[k++]=v[j++];\\n        }\\n        while(i<=mid)\\n            temp[k++]=v[i++];\\n        while(j<=r)\\n            temp[k++]=v[j++];\\n        for(i=0;i<temp.size();i++)\\n            v[l+i]=temp[i];\\n    }\\n    void mergeSort(vector<int> &v,int l,int r,int diff)\\n    {\\n        if(l>=r)\\n            return;\\n        int mid=(l+r)/2;\\n        mergeSort(v,l,mid,diff);\\n        mergeSort(v,mid+1,r,diff);\\n        merge(v,l,mid,r,diff);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) \\n    {\\n        int n=nums1.size();\\n        vector<int> arr(n);\\n        for(int i=0;i<n;i++)\\n            arr[i]=nums1[i]-nums2[i];\\n        mergeSort(arr,0,n-1,diff);\\n        return ans;\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    long long ans=0;\\n    void merge(vector<int> &v,int l,int mid,int r,int diff)\\n    {\\n        vector<int> temp(r-l+1);\\n        int i=l;\\n        int j=mid+1;\\n        int k=0;\\n        while(j<=r)\\n        {\\n            while(i<=mid && v[i]<=v[j]+diff)\\n                i++;\\n            j++;\\n            ans+=(long long)(i-l);\\n        }\\n        i=l;j=mid+1;\\n        while(i<=mid && j<=r)\\n        {\\n            if(v[i]<v[j])\\n                temp[k++]=v[i++];\\n            else\\n                temp[k++]=v[j++];\\n        }\\n        while(i<=mid)\\n            temp[k++]=v[i++];\\n        while(j<=r)\\n            temp[k++]=v[j++];\\n        for(i=0;i<temp.size();i++)\\n            v[l+i]=temp[i];\\n    }\\n    void mergeSort(vector<int> &v,int l,int r,int diff)\\n    {\\n        if(l>=r)\\n            return;\\n        int mid=(l+r)/2;\\n        mergeSort(v,l,mid,diff);\\n        mergeSort(v,mid+1,r,diff);\\n        merge(v,l,mid,r,diff);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) \\n    {\\n        int n=nums1.size();\\n        vector<int> arr(n);\\n        for(int i=0;i<n;i++)\\n            arr[i]=nums1[i]-nums2[i];\\n        mergeSort(arr,0,n-1,diff);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647104,
                "title": "c-solution-o-nlogn-time-o-n-space-merge-sort",
                "content": "# Approach\\nMerge Sort\\n\\n# Complexity\\n- Time complexity:\\n`O(nlogn)` -> `n` is the length of arrays `nums1` and `nums2`\\n\\n- Space complexity:\\n`O(n)` -> `n` is the length of arrays `nums1` and `nums2`\\n\\n# Code\\n```\\nclass Solution {\\n    using i64 = long long;\\npublic:\\n    static i64 numberOfPairs(const vector<int>& nums1, const vector<int>& nums2, const int diff) {\\n        const int n = size(nums1);\\n        vector<i64> arr(n);\\n        for (int i = 0; i < n; ++i)\\n            arr[i] = i64(nums1[i]) - nums2[i];\\n        i64 ret = 0;\\n\\n        function<void(int, int)> merge = [&] (int low, int hi) {\\n            if(low >= hi)\\n                return;\\n            int mid = ((hi - low) >> 1) + low;\\n            merge(low, mid);\\n            merge(mid + 1, hi);\\n            int i = low, j = mid + 1;\\n            while (i <= mid && j <= hi)\\n                if (arr[i] <= arr[j] + diff) \\n                    ret += (hi - j + 1), ++i;\\n                else\\n                    ++j;\\n            inplace_merge(begin(arr) + low, begin(arr) + mid + 1, begin(arr) + hi + 1);\\n        };\\n\\n        merge(0, n - 1);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    using i64 = long long;\\npublic:\\n    static i64 numberOfPairs(const vector<int>& nums1, const vector<int>& nums2, const int diff) {\\n        const int n = size(nums1);\\n        vector<i64> arr(n);\\n        for (int i = 0; i < n; ++i)\\n            arr[i] = i64(nums1[i]) - nums2[i];\\n        i64 ret = 0;\\n\\n        function<void(int, int)> merge = [&] (int low, int hi) {\\n            if(low >= hi)\\n                return;\\n            int mid = ((hi - low) >> 1) + low;\\n            merge(low, mid);\\n            merge(mid + 1, hi);\\n            int i = low, j = mid + 1;\\n            while (i <= mid && j <= hi)\\n                if (arr[i] <= arr[j] + diff) \\n                    ret += (hi - j + 1), ++i;\\n                else\\n                    ++j;\\n            inplace_merge(begin(arr) + low, begin(arr) + mid + 1, begin(arr) + hi + 1);\\n        };\\n\\n        merge(0, n - 1);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647082,
                "title": "c-ordered-set-solution",
                "content": "\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\n// find_by_order(x) : returns iterator to the xth element in pbds\\n// order_of_key(x) : gives number of elements strictly less than x\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        vector<int> x(n);\\n        for(int i=0;i<n;i++){\\n            x[i]=nums1[i]-nums2[i];\\n        }        \\n        pbds os;\\n        long long ans=0;\\n     \\n        for(int i=0;i<n;i++){\\n            int cur=x[i]+diff;\\n            cur++;\\n            ans+=(long long)os.order_of_key(cur);\\n            // cout<<cur<<\" \"<<os.order_of_key(cur)<<\"\\\\n\";\\n            os.insert(x[i]);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        vector<int> x(n);\\n        for(int i=0;i<n;i++){\\n            x[i]=nums1[i]-nums2[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2647001,
                "title": "c-binary-search-o-nlogn-tle-cannot-work",
                "content": "Hi yall,\\nI tried binary search to count the pairs and it worked when N is small.\\nThe time complexity is roughly O(NlogN),\\nbut I got a TLE and I don\\'t know why.\\nAny thoughts?\\n```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int i,j,n;\\n        n=nums1.size();\\n    \\n        long long k=0;\\n        \\n        /*\\n        for(i=0;i<n;i++){\\n            for(j=i+1;j<n;j++){\\n                if(nums1[i]-nums1[j] <=diff) k++;\\n            }\\n        }*/\\n        \\n        multiset<int> s;\\n        multiset<int>::iterator it;\\n        for(i=n-1;i>=0;i--) {\\n            int x;\\n            x = nums1[i]-nums2[i] - diff;\\n            it = s.lower_bound (x);\\n            k += distance(it,s.end());\\n            //cout<<i<<\" \"<<distance(it,s.end())<<endl;\\n            //it--;\\n            s.insert(it,nums1[i]-nums2[i]);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int i,j,n;\\n        n=nums1.size();\\n    \\n        long long k=0;\\n        \\n        /*\\n        for(i=0;i<n;i++){\\n            for(j=i+1;j<n;j++){\\n                if(nums1[i]-nums1[j] <=diff) k++;\\n            }\\n        }*/\\n        \\n        multiset<int> s;\\n        multiset<int>::iterator it;\\n        for(i=n-1;i>=0;i--) {\\n            int x;\\n            x = nums1[i]-nums2[i] - diff;\\n            it = s.lower_bound (x);\\n            k += distance(it,s.end());\\n            //cout<<i<<\" \"<<distance(it,s.end())<<endl;\\n            //it--;\\n            s.insert(it,nums1[i]-nums2[i]);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2646984,
                "title": "c-short-segment-tree",
                "content": "[good resources for segment tree](https://codeforces.com/blog/entry/18051)\\n \\n```\\nconst int N = 2e5;  // limit for array size\\nint n;  // array size\\nint t[2 * N];\\n\\nvoid build() {  // build the tree\\n    for (int i = n - 1; i > 0; --i) t[i] = t[i << 1] + t[i << 1 | 1];\\n}\\n\\nvoid modify(int p, int value) {  // set value at position p\\n    for (t[p += n] += 1; p > 1; p >>= 1) t[p >> 1] = t[p] + t[p ^ 1]; // t[p += n] += 1 is for this problem, check the link for original implementation\\n}\\n\\nint query(int l, int r) {  // sum on interval [l, r)\\n    int res = 0;\\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\\n        if (l & 1) res += t[l++];\\n        if (r & 1) res += t[--r];\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> d(nums1.size(), 0);\\n        for (int i = 0; i < nums1.size(); i++) d[i] = nums1[i] - nums2[i];\\n        n = 50010; memset(t, 0, sizeof(t));\\n        int offset = 40010;\\n        //count k : d[k]>=d[i]-diff;\\n        long long ans = 0;\\n        for (int i = nums1.size() - 1; i >= 0; i--) {\\n            ans += query(d[i] - diff+offset, n+offset);\\n            modify(d[i]+offset, 1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nconst int N = 2e5;  // limit for array size\\nint n;  // array size\\nint t[2 * N];\\n\\nvoid build() {  // build the tree\\n    for (int i = n - 1; i > 0; --i) t[i] = t[i << 1] + t[i << 1 | 1];\\n}\\n\\nvoid modify(int p, int value) {  // set value at position p\\n    for (t[p += n] += 1; p > 1; p >>= 1) t[p >> 1] = t[p] + t[p ^ 1]; // t[p += n] += 1 is for this problem, check the link for original implementation\\n}\\n\\nint query(int l, int r) {  // sum on interval [l, r)\\n    int res = 0;\\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\\n        if (l & 1) res += t[l++];\\n        if (r & 1) res += t[--r];\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> d(nums1.size(), 0);\\n        for (int i = 0; i < nums1.size(); i++) d[i] = nums1[i] - nums2[i];\\n        n = 50010; memset(t, 0, sizeof(t));\\n        int offset = 40010;\\n        //count k : d[k]>=d[i]-diff;\\n        long long ans = 0;\\n        for (int i = nums1.size() - 1; i >= 0; i--) {\\n            ans += query(d[i] - diff+offset, n+offset);\\n            modify(d[i]+offset, 1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646971,
                "title": "ordered-set-c-shortest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem can be solved using ordered set data structure\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolve the inequality you get \\n(nums1[i]-nums2[i])-(nums1[j]-nums2[j]) <= k,\\nto handle duplicate cases in ordered set you have to write greater_equal \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,greater_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long res = 0;\\n        ordered_set s;\\n        for(int i=n-1; i>=0; i--){\\n            int t = s.order_of_key(nums1[i]-nums2[i]-k-1);\\n            res += t;\\n            s.insert(nums1[i]-nums2[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,greater_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long res = 0;\\n        ordered_set s;\\n        for(int i=n-1; i>=0; i--){\\n            int t = s.order_of_key(nums1[i]-nums2[i]-k-1);\\n            res += t;\\n            s.insert(nums1[i]-nums2[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2646930,
                "title": "c-merge-sort-o-nlogn",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    ll ans ;\\n    void merge(vector<ll> &arr, int low, int hi, int diff){\\n        if(low >= hi) return;\\n        int mid = low+(hi-low)/2;\\n        merge(arr, low, mid, diff);\\n        merge(arr, mid+1, hi, diff);\\n        int i = low, j = mid+1;\\n        while(i <= mid && j <= hi){\\n            if(arr[i] <= arr[j]+diff) \\n                ans += (hi-j+1), i++;\\n            else j++;\\n        }\\n        inplace_merge(arr.begin()+low,arr.begin()+mid+1,arr.begin()+hi+1);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<ll> arr(n);\\n        for(int i = 0; i<n; i++) arr[i] = nums1[i]-nums2[i];\\n        ans = 0;\\n        merge(arr, 0, n-1, diff);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    ll ans ;\\n    void merge(vector<ll> &arr, int low, int hi, int diff){\\n        if(low >= hi) return;\\n        int mid = low+(hi-low)/2;\\n        merge(arr, low, mid, diff);\\n        merge(arr, mid+1, hi, diff);\\n        int i = low, j = mid+1;\\n        while(i <= mid && j <= hi){\\n            if(arr[i] <= arr[j]+diff) \\n                ans += (hi-j+1), i++;\\n            else j++;\\n        }\\n        inplace_merge(arr.begin()+low,arr.begin()+mid+1,arr.begin()+hi+1);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<ll> arr(n);\\n        for(int i = 0; i<n; i++) arr[i] = nums1[i]-nums2[i];\\n        ans = 0;\\n        merge(arr, 0, n-1, diff);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646919,
                "title": "segment-tree-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[200000];\\n    \\n    void update(int ind,int l,int r,int pos){\\n        if(pos<l||pos>r) return;\\n        if(l==r){\\n            t[ind]++;return;\\n        }\\n        int mid=l+(r-l)/2;\\n        update(2*ind,l,mid,pos);\\n        update(2*ind+1,mid+1,r,pos);\\n        t[ind]=t[2*ind]+t[2*ind+1];\\n    }\\n    int qs(int ind,int l,int r,int ql,int qr){\\n        if(l>qr||r<ql) return 0;\\n        if(ql<=l && r<=qr) return t[ind];\\n        int mid=l+(r-l)/2;\\n        return qs(2*ind,l,mid,ql,qr)+qs(2*ind+1,mid+1,r,ql,qr);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int dif) {\\n         int n=nums1.size();\\n        vector<int> v(n);\\n        for(int i=0;i<n;i++){\\n            v[i] = nums1[i]-nums2[i];\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            int d= qs(1,0,40001,0,dif+v[i]+20000);ans+=d;\\n            update(1,0,40001,v[i]+20000);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int t[200000];\\n    \\n    void update(int ind,int l,int r,int pos){\\n        if(pos<l||pos>r) return;\\n        if(l==r){\\n            t[ind]++;return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2646899,
                "title": "python-iterative-segment-tree-o-nlogn",
                "content": "Copy pasting code for now. Will post explanation later. Comment incase of any doubt\\n```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \\n        max_length = 10**6\\n        tree = [0] * 2 * max_length\\n        \\n        def query_count(right):\\n            left = 0 + max_length\\n            right = right + max_length\\n            res = 0\\n            while left < right:\\n                if left & 1:\\n                    res += tree[left]\\n                    left += 1\\n                \\n                if right & 1:\\n                    right -= 1\\n                    res += tree[right]\\n                left >>= 1\\n                right >>= 1\\n            \\n            return res\\n        \\n        def update(index):\\n            index += max_length\\n            tree[index] += 1\\n            \\n            while index > 1:\\n                tree[index >> 1] = tree[index] + tree[index ^ 1]\\n                index >>= 1\\n            \\n        \\n        answer = 0\\n        for j in range(len(nums1)):\\n            \\n            curr_val = nums1[j] - nums2[j]\\n            \\n            # adding offset so that i only get positive values\\n            curr_val += 10**5 + 1\\n            curr_ans = query_count(curr_val + 1)\\n            # print(j, curr_ans, curr_val-diff)\\n            answer += curr_ans\\n            update(curr_val - diff)\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \\n        max_length = 10**6\\n        tree = [0] * 2 * max_length\\n        \\n        def query_count(right):\\n            left = 0 + max_length\\n            right = right + max_length\\n            res = 0\\n            while left < right:\\n                if left & 1:\\n                    res += tree[left]\\n                    left += 1\\n                \\n                if right & 1:\\n                    right -= 1\\n                    res += tree[right]\\n                left >>= 1\\n                right >>= 1\\n            \\n            return res\\n        \\n        def update(index):\\n            index += max_length\\n            tree[index] += 1\\n            \\n            while index > 1:\\n                tree[index >> 1] = tree[index] + tree[index ^ 1]\\n                index >>= 1\\n            \\n        \\n        answer = 0\\n        for j in range(len(nums1)):\\n            \\n            curr_val = nums1[j] - nums2[j]\\n            \\n            # adding offset so that i only get positive values\\n            curr_val += 10**5 + 1\\n            curr_ans = query_count(curr_val + 1)\\n            # print(j, curr_ans, curr_val-diff)\\n            answer += curr_ans\\n            update(curr_val - diff)\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646895,
                "title": "easy-cpp-solution",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\nusing namespace __gnu_pbds; \\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; \\nclass Solution {\\npublic:\\n    using ll=long long;\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        int n=nums1.size();\\n        vector<int> a(n);\\n        \\n        for(int i=0;i<n;i++){\\n            a[i]=nums1[i]-nums2[i];\\n        }\\n        \\n        ll ans=0;\\n        ordered_set s;\\n        for(int i=0;i<n;i++){\\n            \\n            ll key=a[i]+diff;\\n    \\n            if(!s.empty()) {\\n                ans+= s.order_of_key(key+1);\\n            }\\n            \\n            \\n            s.insert(a[i]);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\nusing namespace __gnu_pbds; \\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; \\nclass Solution {\\npublic:\\n    using ll=long long;\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        int n=nums1.size();\\n        vector<int> a(n);\\n        \\n        for(int i=0;i<n;i++){\\n            a[i]=nums1[i]-nums2[i];\\n        }\\n        \\n        ll ans=0;\\n        ordered_set s;\\n        for(int i=0;i<n;i++){\\n            \\n            ll key=a[i]+diff;\\n    \\n            if(!s.empty()) {\\n                ans+= s.order_of_key(key+1);\\n            }\\n            \\n            \\n            s.insert(a[i]);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2646861,
                "title": "c-segment-tree-detailed-explanation",
                "content": "**IDEA:**\\nFirst, we rearrange the given equation to obtain => **nums1[j] - nums2[j] >= nums1[i] - nums2[i] - diff** and **j > i**\\nSo, we have to find the count of indexes `j (> i)` where the difference is greater than `current difference - diff`\\n    \\nIdea is to maintain the count of every possible difference in a count array. \\nThen, for for every index =>\\n1. Decrease the count of the difference at that index by 1 (We only want to count specific differences to the **right** of the current index)\\n2. Find the count of differences greater than the required difference (Say \\'req\\'): `Prefix sum of count array from req to max difference (end)`\\n                                             \\nNow that we know what we have to do, we just have to do it in efficient manner. In order to make updates and calculate prefix sum efficiently, we use segment tree.\\n\\n**IMPLEMENTATION:**\\n```\\n#define ll long long\\nvector<ll> tree;\\n\\nvoid build(vector<ll>& nums, ll l, ll r, ll node) {\\n    if(l == r) {\\n        tree[node] = nums[l];\\n        return;\\n    }\\n    \\n    ll mid = l-(l-r)/2;\\n    build(nums, l, mid, 2*node+1);\\n    build(nums, mid+1, r, 2*node+2);\\n    \\n    tree[node] = tree[2*node+1] + tree[2*node+2];\\n}\\n\\nvoid update(ll idx, ll val, ll l, ll r, ll node) {\\n    if(l == r) {\\n        tree[node] = val;\\n        return;\\n    }\\n    \\n    ll mid = l-(l-r)/2;\\n    if(l <= idx && idx <= mid) update(idx, val, l, mid, 2*node+1);\\n    else update(idx, val, mid+1, r, 2*node+2);\\n    \\n    tree[node] = tree[2*node+1] + tree[2*node+2];\\n}\\n\\nll rangeSum(ll start, ll end, ll l, ll r, ll node) {\\n    if(l > end || r < start) return 0;\\n    if(l >= start && r <= end) return tree[node];\\n    \\n    ll mid = l-(l-r)/2;\\n    ll p1 = rangeSum(start, end, l, mid, 2*node+1);\\n    ll p2 = rangeSum(start, end, mid+1, r, 2*node+2);\\n    \\n    return p1 + p2;\\n}\\n\\nll numberOfPairs(vector<int>& nums1, vector<int>& nums2, int d) {\\n    int n = nums1.size(), shift = 2*10000, sz = 1e5; // Difference can also be negative, so make a shift to make it positive\\n    vector<ll> cnt(sz, 0);\\n\\n    for(int i = 0; i<n; i++) {\\n        ll diff = shift + nums1[i]-nums2[i];\\n        cnt[diff]++;\\n    }\\n\\n    tree = vector<ll>(4*sz, 0);\\n    build(cnt, 0, sz-1, 0);\\n\\n    ll res = 0;\\n    for(int i = 0; i<n; i++) {\\n        ll diff = shift + nums1[i] - nums2[i];\\n        ll curr = --cnt[diff]; // We don\\'t want to consider the current index now onwards (Point 1)\\n        update(diff, curr, 0, sz-1, 0);\\n        res += rangeSum(diff-d, sz-1, 0, sz-1, 0); // (Point 2)\\n    }\\n\\n    return res;\\n}\\n```\\n\\n**TIME AND SPACE COMPLEXITY:**\\n\\nLet\\'s say that the size of the given arrays is `n` and the maximum difference at any index is `maxDiff`, then =>\\nTC = `O(n * log(maxDiff))`\\nAS = `O(maxDiff)`\\n\\n*Note:* I have considered `maxDiff` as `1e5` for simplicity.\\n\\n**Do upvote if you like!**",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n#define ll long long\\nvector<ll> tree;\\n\\nvoid build(vector<ll>& nums, ll l, ll r, ll node) {\\n    if(l == r) {\\n        tree[node] = nums[l];\\n        return;\\n    }\\n    \\n    ll mid = l-(l-r)/2;\\n    build(nums, l, mid, 2*node+1);\\n    build(nums, mid+1, r, 2*node+2);\\n    \\n    tree[node] = tree[2*node+1] + tree[2*node+2];\\n}\\n\\nvoid update(ll idx, ll val, ll l, ll r, ll node) {\\n    if(l == r) {\\n        tree[node] = val;\\n        return;\\n    }\\n    \\n    ll mid = l-(l-r)/2;\\n    if(l <= idx && idx <= mid) update(idx, val, l, mid, 2*node+1);\\n    else update(idx, val, mid+1, r, 2*node+2);\\n    \\n    tree[node] = tree[2*node+1] + tree[2*node+2];\\n}\\n\\nll rangeSum(ll start, ll end, ll l, ll r, ll node) {\\n    if(l > end || r < start) return 0;\\n    if(l >= start && r <= end) return tree[node];\\n    \\n    ll mid = l-(l-r)/2;\\n    ll p1 = rangeSum(start, end, l, mid, 2*node+1);\\n    ll p2 = rangeSum(start, end, mid+1, r, 2*node+2);\\n    \\n    return p1 + p2;\\n}\\n\\nll numberOfPairs(vector<int>& nums1, vector<int>& nums2, int d) {\\n    int n = nums1.size(), shift = 2*10000, sz = 1e5; // Difference can also be negative, so make a shift to make it positive\\n    vector<ll> cnt(sz, 0);\\n\\n    for(int i = 0; i<n; i++) {\\n        ll diff = shift + nums1[i]-nums2[i];\\n        cnt[diff]++;\\n    }\\n\\n    tree = vector<ll>(4*sz, 0);\\n    build(cnt, 0, sz-1, 0);\\n\\n    ll res = 0;\\n    for(int i = 0; i<n; i++) {\\n        ll diff = shift + nums1[i] - nums2[i];\\n        ll curr = --cnt[diff]; // We don\\'t want to consider the current index now onwards (Point 1)\\n        update(diff, curr, 0, sz-1, 0);\\n        res += rangeSum(diff-d, sz-1, 0, sz-1, 0); // (Point 2)\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646680,
                "title": "clean-fast-python3-sortedlist-o-n-log-n",
                "content": "Please upvote if it helps!\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        n, pairs = len(nums1), 0\\n        # simplify the problem by rearranging equations: find all pairs of i, j in nums such that nums[i] - nums[j] <= diff\\n        nums = [x1 - x2 for x1, x2 in zip(nums1, nums2)] # condense to one list\\n        # look back thru sorted list to find number of past i\\'s such that nums[i] <= nums[j] + diff\\n        i_nums = SortedList()      \\n        for j_num in nums:\\n            pairs += i_nums.bisect_right(j_num + diff)\\n            i_nums.add(j_num)\\n\\t\\t\\t\\n        return pairs\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Please upvote if it helps!\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        n, pairs = len(nums1), 0\\n        # simplify the problem by rearranging equations: find all pairs of i, j in nums such that nums[i] - nums[j] <= diff\\n        nums = [x1 - x2 for x1, x2 in zip(nums1, nums2)] # condense to one list\\n        # look back thru sorted list to find number of past i\\'s such that nums[i] <= nums[j] + diff\\n        i_nums = SortedList()      \\n        for j_num in nums:\\n            pairs += i_nums.bisect_right(j_num + diff)\\n            i_nums.add(j_num)\\n\\t\\t\\t\\n        return pairs\\n",
                "codeTag": "Java"
            },
            {
                "id": 2646559,
                "title": "c-using-pbds",
                "content": "Just rearrange equation.\\n```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds; \\n#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long res = 0;\\n        ordered_set s;\\n        \\n        int n = nums1.size();\\n        for(int j = 0; j<n; j++){\\n            pair<int,int> p = {nums1[j] - nums2[j] + diff + 1, INT_MIN};\\n            res += (s.order_of_key(p));\\n            s.insert({nums1[j] - nums2[j], j});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds; \\n#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long res = 0;\\n        ordered_set s;\\n        \\n        int n = nums1.size();\\n        for(int j = 0; j<n; j++){\\n            pair<int,int> p = {nums1[j] - nums2[j] + diff + 1, INT_MIN};\\n            res += (s.order_of_key(p));\\n            s.insert({nums1[j] - nums2[j], j});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2646508,
                "title": "c-fenwic-tree",
                "content": "vector<long long> fen;\\n    void update(int index){\\n        // fen[val]++;\\n        while(index<2000000){\\n            fen[index]++;\\n            index+=index&(-index);\\n        }\\n       \\n    }\\n    long long get(int index){\\n        long long sum=0;\\n        while(index>0){\\n            sum+=fen[index];\\n            index-=index&(-index);\\n        }\\n        return sum;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> v;\\n        fen.resize(2000000);\\n        // diff+=1000;\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back(nums1[i]-nums2[i]+100000);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            ans+=get(v[i]+diff);\\n            // cout<<ans;\\n            update(v[i]);\\n        }\\n        return ans;\\n        \\n        \\n    }",
                "solutionTags": [
                    "Tree"
                ],
                "code": "vector<long long> fen;\\n    void update(int index){\\n        // fen[val]++;\\n        while(index<2000000){\\n            fen[index]++;\\n            index+=index&(-index);\\n        }\\n       \\n    }\\n    long long get(int index){\\n        long long sum=0;\\n        while(index>0){\\n            sum+=fen[index];\\n            index-=index&(-index);\\n        }\\n        return sum;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> v;\\n        fen.resize(2000000);\\n        // diff+=1000;\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back(nums1[i]-nums2[i]+100000);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            ans+=get(v[i]+diff);\\n            // cout<<ans;\\n            update(v[i]);\\n        }\\n        return ans;\\n        \\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2646492,
                "title": "c-with-explanation-segment-tree",
                "content": "We want to put index i\\'s and index j\\'s on the same side, so we convert the equation from \\n```\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\\n```\\nto\\n```\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff.\\n```\\nThen the problem become how many ``` nums1[i] - nums2[i]``` are there which are smaller than nums1[j] - nums2[j] + diff.\\n##### Look familiar? It becomes a range query problem. Segment tree is efficient for range query.\\n#### How to do it?\\n1. We can precaculate all the nums1[i] - nums2[i]  and nums1[j] - nums2[j], and store it in a vector of int\\n2. Then we query and update number on each index of the precalculated vector up to index n-1.\\n\\n##### Note: In the problem, nums[i] and diff can be negative, making them to positive number by adding a shift number is easier for us to implement segment tree.\\nCode as follow:\\n```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    int n=0;\\n    \\n    int query(int left, int right){\\n        int res=0;\\n        for(left+=n, right+=n; left<right; left>>=1, right>>=1){\\n            if(left&1){\\n                res+=seg[left++];\\n            }\\n            if(right&1){\\n                res+=seg[--right];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n\\t// update the tree\\n    void update(int index){\\n        for(seg[index+=n]+=1; index>1; index>>=1){\\n            seg[index>>1]=seg[index]+seg[index^1];\\n        }\\n    }\\n    \\n    long long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n        int shift=20000;\\n        n=200001;\\n        vector<int> d1;\\n        \\n        seg.resize(n*2, 0);\\n        \\n\\t\\t// precaculate nums1[i]-nums2[i]\\n        for(int i=0; i<n1.size(); i++){\\n            d1.push_back(n1[i]-n2[i]);\\n        }\\n        \\n        long long ans=0;\\n        update(d1[0]+shift);\\n\\t\\t// query and update the tree\\n        for(int i=1; i<n1.size(); i++){\\n            ans+=query(0, d1[i]+1+shift+diff);\\n            update(d1[i]+shift);\\n        }\\n              \\n        return ans;\\n    }\\n};\\n```\\n\\n#### Hope it helps :)",
                "solutionTags": [],
                "code": "```\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\\n```\n```\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff.\\n```\n``` nums1[i] - nums2[i]```\n```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    int n=0;\\n    \\n    int query(int left, int right){\\n        int res=0;\\n        for(left+=n, right+=n; left<right; left>>=1, right>>=1){\\n            if(left&1){\\n                res+=seg[left++];\\n            }\\n            if(right&1){\\n                res+=seg[--right];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n\\t// update the tree\\n    void update(int index){\\n        for(seg[index+=n]+=1; index>1; index>>=1){\\n            seg[index>>1]=seg[index]+seg[index^1];\\n        }\\n    }\\n    \\n    long long numberOfPairs(vector<int>& n1, vector<int>& n2, int diff) {\\n        int shift=20000;\\n        n=200001;\\n        vector<int> d1;\\n        \\n        seg.resize(n*2, 0);\\n        \\n\\t\\t// precaculate nums1[i]-nums2[i]\\n        for(int i=0; i<n1.size(); i++){\\n            d1.push_back(n1[i]-n2[i]);\\n        }\\n        \\n        long long ans=0;\\n        update(d1[0]+shift);\\n\\t\\t// query and update the tree\\n        for(int i=1; i<n1.size(); i++){\\n            ans+=query(0, d1[i]+1+shift+diff);\\n            update(d1[i]+shift);\\n        }\\n              \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088917,
                "title": "time-o-n-logn-space-o-n-easy-explanation-and-implementation",
                "content": "# Intuition\\nOriginal equation poses some difficulty because the indexes are on both sides of the inequality. Rewriting such that all `i` are on one side and `j` are on the other side might make the problem easier to solve.\\n\\n\\n# Approach\\n\\n1. Rewrite:\\n$$nums1[i] - nums2[i] <=  nums1[j] - nums2[j] + diff$$\\n2. At each index `j`, we want to know how many index `i` where `i < j` exist such that the condition holds.\\n3.  To search the past deltas `nums1[i] - nums2[i]` quickly, we can use a `sortedcontainers.SortedList`. We use `bisect_right()` which can in $$O(log(N))$$ find the insertion index for a given value.\\n4. In our case, the insertion index of `nums1[j] - nums2[j] + diff` tells us how many `i` in the explored subproblems satisfy the condition. \\n5. We can iterate through each index `j`, accumulate the `ans`, and update our `SortedList` with the new delta values.\\n\\n\\n# Complexity\\n\\nAnalysis is based on the documentation: https://grantjenks.com/docs/sortedcontainers/sortedlist.html\\n\\n- Time complexity: $$N * O(log(N))$$\\n    For N deltas, we must do a $$log(N)$$ search plus a $$log(N)$$ insertion.\\n\\n- Space complexity: $$O(N)$$\\n    Store each delta once in BST.\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        sl = SortedList()\\n        ans = 0\\n        \\n        for j, (a, b) in enumerate(zip(nums1, nums2)):\\n            ans += sl.bisect_right(a - b + diff)\\n            sl.add((a - b))\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        sl = SortedList()\\n        ans = 0\\n        \\n        for j, (a, b) in enumerate(zip(nums1, nums2)):\\n            ans += sl.bisect_right(a - b + diff)\\n            sl.add((a - b))\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055224,
                "title": "merge-sort-inversion-count",
                "content": "# Intuition\\nInversion Count\\n\\n# Approach\\nDivide & Conquer\\nLeft half will give an answer of count by recursive hypothesis.\\nRight half will give an answer of count by recursive hypothesis.\\n\\nThen we have to find answers while combining left half and right half.\\n\\nAccumulate all the count by leftHalf rightHalf & while combining.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    long long mergeArr(vector<int>& nums, int l, int m, int r, int diff) {\\n        int i = l;\\n        int j = m + 1;\\n        vector<int> temp(r-l + 1);\\n        int k = 0;\\n        long long cnt = 0;\\n        while(i<=m && j<=r){\\n            if(nums[i] - nums[j] <= diff){\\n                cnt += r - j + 1;\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n\\n        i = l;\\n        j = m + 1;\\n        while (i <= m && j <= r) {\\n            if (nums[i] <= nums[j]) {\\n                temp[k++] = nums[i++];\\n            } else {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n\\n        while (i <= m) {\\n            temp[k++] = nums[i++];\\n        }\\n\\n        while (j <= r) {\\n            temp[k++] = nums[j++];\\n        }\\n\\n        for (int p = 0; p <=r-l; p++) {\\n            nums[l + p] = temp[p];\\n        }\\n\\n        return cnt;\\n    }\\n\\n    long long mergeSort(vector<int>& nums, int l, int r, int diff) {\\n        if (l == r) return 0;\\n\\n        int m = l + (r - l) / 2;\\n        long long leftCnt = mergeSort(nums, l, m, diff);\\n        long long rightCnt = mergeSort(nums, m + 1, r, diff);\\n        long long mergeCnt = mergeArr(nums, l, m, r, diff);\\n\\n        return leftCnt + rightCnt + mergeCnt;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        for (int i = 0; i < n; i++) {\\n            nums1[i] = nums1[i] - nums2[i];\\n        }\\n        return mergeSort(nums1, 0, n - 1, diff);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    long long mergeArr(vector<int>& nums, int l, int m, int r, int diff) {\\n        int i = l;\\n        int j = m + 1;\\n        vector<int> temp(r-l + 1);\\n        int k = 0;\\n        long long cnt = 0;\\n        while(i<=m && j<=r){\\n            if(nums[i] - nums[j] <= diff){\\n                cnt += r - j + 1;\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n\\n        i = l;\\n        j = m + 1;\\n        while (i <= m && j <= r) {\\n            if (nums[i] <= nums[j]) {\\n                temp[k++] = nums[i++];\\n            } else {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n\\n        while (i <= m) {\\n            temp[k++] = nums[i++];\\n        }\\n\\n        while (j <= r) {\\n            temp[k++] = nums[j++];\\n        }\\n\\n        for (int p = 0; p <=r-l; p++) {\\n            nums[l + p] = temp[p];\\n        }\\n\\n        return cnt;\\n    }\\n\\n    long long mergeSort(vector<int>& nums, int l, int r, int diff) {\\n        if (l == r) return 0;\\n\\n        int m = l + (r - l) / 2;\\n        long long leftCnt = mergeSort(nums, l, m, diff);\\n        long long rightCnt = mergeSort(nums, m + 1, r, diff);\\n        long long mergeCnt = mergeArr(nums, l, m, r, diff);\\n\\n        return leftCnt + rightCnt + mergeCnt;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        for (int i = 0; i < n; i++) {\\n            nums1[i] = nums1[i] - nums2[i];\\n        }\\n        return mergeSort(nums1, 0, n - 1, diff);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4044047,
                "title": "python-nooby-bits-beat-40-nlgn",
                "content": "whenever counting something cumulative under a certain threshold or above a certain threshold, treat brute force naive as BIT , so you can always use BIT even you can\\'t spot the O(n) smart tricks, and avoiding N^2 naive solutions\\n```\\nclass BIT:\\n    def __init__(self):\\n        self.bit = [0]*(4*10**4 + 2)\\n    \\n    def update(self,num):\\n        x = num\\n        while x < len(self.bit):\\n            self.bit[x] += 1\\n            x += x&(-x)\\n            \\n    def query(self,num):\\n        x = num \\n        res = 0\\n        while x > 0:\\n            res += self.bit[x]\\n            x -= x&(-x)\\n        return res \\n            \\n        \\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        diff_arr = []\\n        offset = 2*10**4\\n        for i in range(len(nums1)):\\n            diff_arr.append(nums1[i]-nums2[i])\\n        bt = BIT()\\n        res = 0\\n        for i in range(len(diff_arr)):\\n            res += bt.query(min(diff_arr[i]+diff+offset+1,len(bt.bit)-1))\\n            bt.update(diff_arr[i]+offset+1)\\n        return res",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "whenever counting something cumulative under a certain threshold or above a certain threshold, treat brute force naive as BIT , so you can always use BIT even you can\\'t spot the O(n) smart tricks, and avoiding N^2 naive solutions\\n```\\nclass BIT:\\n    def __init__(self):\\n        self.bit = [0]*(4*10**4 + 2)\\n    \\n    def update(self,num):\\n        x = num\\n        while x < len(self.bit):\\n            self.bit[x] += 1\\n            x += x&(-x)\\n            \\n    def query(self,num):\\n        x = num \\n        res = 0\\n        while x > 0:\\n            res += self.bit[x]\\n            x -= x&(-x)\\n        return res \\n            \\n        \\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        diff_arr = []\\n        offset = 2*10**4\\n        for i in range(len(nums1)):\\n            diff_arr.append(nums1[i]-nums2[i])\\n        bt = BIT()\\n        res = 0\\n        for i in range(len(diff_arr)):\\n            res += bt.query(min(diff_arr[i]+diff+offset+1,len(bt.bit)-1))\\n            bt.update(diff_arr[i]+offset+1)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3991842,
                "title": "using-mergesort-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    long long  merge ( int left ,int mid , int right , vector<int>&A ,int diff)\\n    {\\n         long long c=0;\\n        int i=left , j=mid+1;\\n        while( i<= mid && j<= right)\\n        {\\n            if( A[i]<=A[j]+diff)\\n            {\\n                c+=right-j+1;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        int l=left , r=mid+1;\\n        vector<int> tem;\\n        while (l<=mid && r<=right)\\n        {\\n            if(A[l]<A[r])\\n            {\\n                tem.push_back(A[l++]);\\n            }\\n            else\\n            tem.push_back(A[r++]);\\n        }\\n\\n        while(l<=mid)tem.push_back(A[l++]);\\n        while(r<=right)tem.push_back(A[r++]);\\n        l=left;\\n        int k=0;\\n        while(l<=right)\\n        A[l++]=tem[k++];\\n\\n        return c;\\n    }\\n    long long  mergesort(int l, int r,vector< int >&A ,int diff)\\n    {\\n        if(l>=r)return 0;\\n         long long c=0;\\n        int mid=(l+r)/2;\\n        c+=mergesort(l,mid , A ,diff);\\n        c+=mergesort(mid+1,r , A, diff);\\n        c+=merge( l , mid , r ,A ,diff);\\n\\n        return c;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long res=0;\\n        int n=nums1.size();\\n        vector<int > A(n);\\n\\n        for( int i =0 ; i< n ; i++ )\\n        {\\n            A[i]= nums1[i] - nums2[i];\\n        }\\n        \\n       return mergesort(0,n-1,A,diff);\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    long long  merge ( int left ,int mid , int right , vector<int>&A ,int diff)\\n    {\\n         long long c=0;\\n        int i=left , j=mid+1;\\n        while( i<= mid && j<= right)\\n        {\\n            if( A[i]<=A[j]+diff)\\n            {\\n                c+=right-j+1;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        int l=left , r=mid+1;\\n        vector<int> tem;\\n        while (l<=mid && r<=right)\\n        {\\n            if(A[l]<A[r])\\n            {\\n                tem.push_back(A[l++]);\\n            }\\n            else\\n            tem.push_back(A[r++]);\\n        }\\n\\n        while(l<=mid)tem.push_back(A[l++]);\\n        while(r<=right)tem.push_back(A[r++]);\\n        l=left;\\n        int k=0;\\n        while(l<=right)\\n        A[l++]=tem[k++];\\n\\n        return c;\\n    }\\n    long long  mergesort(int l, int r,vector< int >&A ,int diff)\\n    {\\n        if(l>=r)return 0;\\n         long long c=0;\\n        int mid=(l+r)/2;\\n        c+=mergesort(l,mid , A ,diff);\\n        c+=mergesort(mid+1,r , A, diff);\\n        c+=merge( l , mid , r ,A ,diff);\\n\\n        return c;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long res=0;\\n        int n=nums1.size();\\n        vector<int > A(n);\\n\\n        for( int i =0 ; i< n ; i++ )\\n        {\\n            A[i]= nums1[i] - nums2[i];\\n        }\\n        \\n       return mergesort(0,n-1,A,diff);\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982228,
                "title": "explained-beginner-friendly-mergesort-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhereever the Question ask for a pair with condition such that i < j then we can use MergeSort, Fenwik tree (Binary Indexed Tree). Here we will see Merge Sort Technique. The intiution to use merge sort is the since we divide the array until 1 and the merge back to get original. The small segment of the divided array will be sorted hence we can compare left and right.  \\n\\nAlso on rearranging we get $$nums1[i]-nums2[i] <= nums1[j] - nums2[j] + diff$$\\n\\nWe can create new array that will be named $$nums$$ which store $$nums1[i]-nums2[i]$$\\n\\nso that we can apply merge sort technique in the new array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the merge sort algorithm and in the merge function check the condition if $$ nums[left]<nums[right]+diff$$ if the statement is correct we will increase the count by (rightmost index - right + 1).  Since if one condition of $$ nums[left]<nums[right]+diff$$ is satisfied all the elements to the right of $$right$$ will also be of diff greater than $$diff$$ as the array is sorted.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$ same as merge sort\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n) $$ created new nums of size n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long count = 0;\\n    void merge(vector<int> &nums, int l,int mid, int r, int diff){\\n        vector<int> temp;\\n        int left = l;\\n        int right = mid+1;\\n        while(left<=mid && right<=r){\\n            if(nums[left]<=nums[right]+diff){\\n                count+=(r-right+1);\\n                left++;\\n            }\\n            else{\\n                // temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        left = l;\\n        right = mid+1;\\n        while(left<=mid && right<=r){\\n            // if(nums[left]<=nums[right]+diff){\\n            //     count+=(r-right+1);\\n            // }\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n            else{\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right<=r){\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n        for(int i =0;i<temp.size();i++){\\n            nums[i+l] = temp[i];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums, int l, int r,int diff){\\n        if(l==r) return;\\n        int mid = l+(r-l)/2;\\n        mergeSort(nums, l, mid,diff);\\n        mergeSort(nums, mid+1,r,diff);\\n        merge(nums, l, mid, r,diff);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        count = 0;\\n        vector<int> nums;\\n        for(int i=0;i<nums1.size();i++){\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n        mergeSort(nums,0, nums.size()-1,diff);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long count = 0;\\n    void merge(vector<int> &nums, int l,int mid, int r, int diff){\\n        vector<int> temp;\\n        int left = l;\\n        int right = mid+1;\\n        while(left<=mid && right<=r){\\n            if(nums[left]<=nums[right]+diff){\\n                count+=(r-right+1);\\n                left++;\\n            }\\n            else{\\n                // temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        left = l;\\n        right = mid+1;\\n        while(left<=mid && right<=r){\\n            // if(nums[left]<=nums[right]+diff){\\n            //     count+=(r-right+1);\\n            // }\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n            else{\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right<=r){\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n        for(int i =0;i<temp.size();i++){\\n            nums[i+l] = temp[i];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums, int l, int r,int diff){\\n        if(l==r) return;\\n        int mid = l+(r-l)/2;\\n        mergeSort(nums, l, mid,diff);\\n        mergeSort(nums, mid+1,r,diff);\\n        merge(nums, l, mid, r,diff);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        count = 0;\\n        vector<int> nums;\\n        for(int i=0;i<nums1.size();i++){\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n        mergeSort(nums,0, nums.size()-1,diff);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960762,
                "title": "rust-segment-tree",
                "content": "# Intuition\\n\\nJust look at the hints.\\n\\n# Approach\\n\\nIn this problem, we need to find the number of elements smaller than a certain value. Segment trees can be used, as the constraints for the values of each number is quite small.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```rust\\n#[derive(Clone)]\\npub struct SegmentTree<T, F> {\\n    n: usize,\\n\\n    inner: Vec<T>,\\n    op: F,\\n}\\n\\nimpl<T: Default + Clone, F: Fn(T, T) -> T> SegmentTree<T, F> {\\n    pub fn new(vec: Vec<T>, op: F) -> Self {\\n        let n = vec.len();\\n        let mut inner = vec![T::default(); n];\\n        inner.extend(vec.into_iter());\\n\\n        for i in (1..n).rev() {\\n            inner[i] = op(inner[i * 2].clone(), inner[i * 2 + 1].clone());\\n        }\\n\\n        Self { n, inner, op }\\n    }\\n}\\n\\nimpl<T: Default + Clone, F: Fn(T, T) -> T> SegmentTree<T, F> {\\n    pub fn query(&self, p0: usize, p1: usize) -> T {\\n        if p0 >= p1 { return T::default(); }\\n        if p1 > self.n { panic!(\"out of bound: {}\", p1); }\\n\\n        let l = p0 + self.n;\\n        let r = p1 + self.n - 1;\\n\\n        self.query_inner(l, r)\\n    }\\n\\n    fn query_inner(&self, l: usize, r: usize) -> T {\\n        let mut ret = T::default();\\n        if l > r { return ret; }\\n\\n        if l % 2 > 0 { ret = (self.op)(ret, self.inner[l].clone()); }\\n\\n        if r % 2 < 1 { ret = (self.op)(ret, self.inner[r].clone()); }\\n\\n        let (l_next, r_next) = ((l + 1) / 2, (r - 1) / 2);\\n        ret = (self.op)(ret, self.query_inner(l_next, r_next));\\n\\n        ret\\n    }\\n\\n    pub fn update(&mut self, index: usize, val_next: T) {\\n        if index >= self.n { panic!(\"out of bound\"); }\\n\\n        let i = index + self.n;\\n        self.inner[i] = val_next;\\n\\n        self.update_inner(i / 2);\\n    }\\n\\n    fn update_inner(&mut self, i: usize) {\\n        if i < 1 { return; }\\n\\n        let (child_0, child_1) = (i * 2, i * 2 + 1);\\n        self.inner[i] = (self.op)(self.inner[child_0].clone(), self.inner[child_1].clone());\\n\\n        self.update_inner(i / 2);\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn number_of_pairs(\\n        vec_0: Vec<i32>,\\n        vec_1: Vec<i32>,\\n        diff: i32\\n    ) -> i64 {\\n        let vec = vec_0.into_iter()\\n            .zip(vec_1.into_iter())\\n            .map(|(e0, e1)| e0 + 20_000 - e1)\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        // println!(\"vec: {:?}\", vec);\\n\\n        let mut ret = usize::MIN;\\n\\n        let mut tree = SegmentTree::new(\\n            vec![usize::MIN; 50_007],\\n            |op0, op1| op0 + op1\\n        );\\n        for e in vec {\\n            let mut threshold = e as i32;\\n            threshold += diff + 1;\\n            let threshold = threshold.max(0) as usize;\\n            \\n            let _ret = tree.query(usize::MIN, threshold);\\n            \\n            let count = tree.query(e as usize, e as usize + 1);\\n            tree.update(e as usize, count + 1);\\n\\n            ret += _ret;\\n        }\\n\\n        ret as i64\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Segment Tree"
                ],
                "code": "```rust\\n#[derive(Clone)]\\npub struct SegmentTree<T, F> {\\n    n: usize,\\n\\n    inner: Vec<T>,\\n    op: F,\\n}\\n\\nimpl<T: Default + Clone, F: Fn(T, T) -> T> SegmentTree<T, F> {\\n    pub fn new(vec: Vec<T>, op: F) -> Self {\\n        let n = vec.len();\\n        let mut inner = vec![T::default(); n];\\n        inner.extend(vec.into_iter());\\n\\n        for i in (1..n).rev() {\\n            inner[i] = op(inner[i * 2].clone(), inner[i * 2 + 1].clone());\\n        }\\n\\n        Self { n, inner, op }\\n    }\\n}\\n\\nimpl<T: Default + Clone, F: Fn(T, T) -> T> SegmentTree<T, F> {\\n    pub fn query(&self, p0: usize, p1: usize) -> T {\\n        if p0 >= p1 { return T::default(); }\\n        if p1 > self.n { panic!(\"out of bound: {}\", p1); }\\n\\n        let l = p0 + self.n;\\n        let r = p1 + self.n - 1;\\n\\n        self.query_inner(l, r)\\n    }\\n\\n    fn query_inner(&self, l: usize, r: usize) -> T {\\n        let mut ret = T::default();\\n        if l > r { return ret; }\\n\\n        if l % 2 > 0 { ret = (self.op)(ret, self.inner[l].clone()); }\\n\\n        if r % 2 < 1 { ret = (self.op)(ret, self.inner[r].clone()); }\\n\\n        let (l_next, r_next) = ((l + 1) / 2, (r - 1) / 2);\\n        ret = (self.op)(ret, self.query_inner(l_next, r_next));\\n\\n        ret\\n    }\\n\\n    pub fn update(&mut self, index: usize, val_next: T) {\\n        if index >= self.n { panic!(\"out of bound\"); }\\n\\n        let i = index + self.n;\\n        self.inner[i] = val_next;\\n\\n        self.update_inner(i / 2);\\n    }\\n\\n    fn update_inner(&mut self, i: usize) {\\n        if i < 1 { return; }\\n\\n        let (child_0, child_1) = (i * 2, i * 2 + 1);\\n        self.inner[i] = (self.op)(self.inner[child_0].clone(), self.inner[child_1].clone());\\n\\n        self.update_inner(i / 2);\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn number_of_pairs(\\n        vec_0: Vec<i32>,\\n        vec_1: Vec<i32>,\\n        diff: i32\\n    ) -> i64 {\\n        let vec = vec_0.into_iter()\\n            .zip(vec_1.into_iter())\\n            .map(|(e0, e1)| e0 + 20_000 - e1)\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        // println!(\"vec: {:?}\", vec);\\n\\n        let mut ret = usize::MIN;\\n\\n        let mut tree = SegmentTree::new(\\n            vec![usize::MIN; 50_007],\\n            |op0, op1| op0 + op1\\n        );\\n        for e in vec {\\n            let mut threshold = e as i32;\\n            threshold += diff + 1;\\n            let threshold = threshold.max(0) as usize;\\n            \\n            let _ret = tree.query(usize::MIN, threshold);\\n            \\n            let count = tree.query(e as usize, e as usize + 1);\\n            tree.update(e as usize, count + 1);\\n\\n            ret += _ret;\\n        }\\n\\n        ret as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853172,
                "title": "c-python-binary-indexed-tree-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/343b3177-f2e8-436e-b994-7eb0a4c4df62_1690980197.327958.png)\\n\\ntc is O(nlogn), sc is O(n).\\n### python\\n```python\\nclass BIT:\\n    def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n    \\n    def add(self, idx, val):\\n        idx += 1\\n        while idx < len(self.bit):\\n            self.bit[idx] += val\\n            idx += idx & -idx\\n        \\n    def query(self, idx):\\n        idx += 1\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        nums = [n1 - n2 for n1, n2 in zip(nums1, nums2)]\\n        mapping = set()\\n        for n in nums:\\n            mapping.add(n)\\n            mapping.add(n+diff)\\n\\t\\t\\n\\t\\t# coordinate compression\\n        mapping = {n: i for i, n in enumerate(sorted(mapping))}\\n        bit = BIT(len(mapping))\\n        \\n        ans = 0\\n        for n in nums:\\n\\t\\t\\t\\n\\t\\t\\t# count how many ci <= cj + diff\\n            ans += bit.query(mapping[n+diff])\\n\\t\\t\\t\\n\\t\\t\\t# update frequency of cj\\n            bit.add(mapping[n], 1)\\n        return ans\\n```\\n### c++\\n```cpp\\nclass BIT {\\npublic:\\n    vector<int> bit;\\n    BIT(int size): bit(size + 1) {}\\n    \\n    void add(int idx, int val) {\\n        idx += 1;\\n        while (idx < this -> bit.size()) {\\n            this -> bit[idx] += val;\\n            idx += idx & -idx;\\n        }\\n    }\\n    \\n    int query(int idx) {\\n        idx += 1;\\n        int s = 0;\\n        while (idx > 0) {\\n            s += this -> bit[idx];\\n            idx -= idx & -idx;\\n        }\\n        return s;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        set<int> tmp;\\n        vector<int> nums;\\n        for (int i = 0; i < nums1.size(); i+=1) {\\n            nums.emplace_back(nums1[i] - nums2[i]);\\n            tmp.emplace(nums1[i] - nums2[i]);\\n            tmp.emplace(nums1[i] - nums2[i] + diff);\\n        }\\n        \\n        unordered_map<int, int> mapping;\\n        int i = 0;\\n        for (auto& n: tmp) {\\n            mapping.emplace(n, i);\\n            i += 1;\\n        }\\n        \\n        long long ans = 0;\\n        BIT bit(mapping.size());\\n        \\n        for (int& n: nums) {\\n            ans += bit.query(mapping[n + diff]);\\n            bit.add(mapping[n], 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Indexed Tree"
                ],
                "code": "```python\\nclass BIT:\\n    def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n    \\n    def add(self, idx, val):\\n        idx += 1\\n        while idx < len(self.bit):\\n            self.bit[idx] += val\\n            idx += idx & -idx\\n        \\n    def query(self, idx):\\n        idx += 1\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        nums = [n1 - n2 for n1, n2 in zip(nums1, nums2)]\\n        mapping = set()\\n        for n in nums:\\n            mapping.add(n)\\n            mapping.add(n+diff)\\n\\t\\t\\n\\t\\t# coordinate compression\\n        mapping = {n: i for i, n in enumerate(sorted(mapping))}\\n        bit = BIT(len(mapping))\\n        \\n        ans = 0\\n        for n in nums:\\n\\t\\t\\t\\n\\t\\t\\t# count how many ci <= cj + diff\\n            ans += bit.query(mapping[n+diff])\\n\\t\\t\\t\\n\\t\\t\\t# update frequency of cj\\n            bit.add(mapping[n], 1)\\n        return ans\\n```\n```cpp\\nclass BIT {\\npublic:\\n    vector<int> bit;\\n    BIT(int size): bit(size + 1) {}\\n    \\n    void add(int idx, int val) {\\n        idx += 1;\\n        while (idx < this -> bit.size()) {\\n            this -> bit[idx] += val;\\n            idx += idx & -idx;\\n        }\\n    }\\n    \\n    int query(int idx) {\\n        idx += 1;\\n        int s = 0;\\n        while (idx > 0) {\\n            s += this -> bit[idx];\\n            idx -= idx & -idx;\\n        }\\n        return s;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        set<int> tmp;\\n        vector<int> nums;\\n        for (int i = 0; i < nums1.size(); i+=1) {\\n            nums.emplace_back(nums1[i] - nums2[i]);\\n            tmp.emplace(nums1[i] - nums2[i]);\\n            tmp.emplace(nums1[i] - nums2[i] + diff);\\n        }\\n        \\n        unordered_map<int, int> mapping;\\n        int i = 0;\\n        for (auto& n: tmp) {\\n            mapping.emplace(n, i);\\n            i += 1;\\n        }\\n        \\n        long long ans = 0;\\n        BIT bit(mapping.size());\\n        \\n        for (int& n: nums) {\\n            ans += bit.query(mapping[n + diff]);\\n            bit.add(mapping[n], 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750915,
                "title": "segment-tree-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int seg[400000+5];\\n    // void buildSeg(int idx,int low,int high,vector<int>&a)\\n    // {\\n    //     if(low==high)\\n    //     {\\n    //         seg[idx]=a[low];\\n    //     return;\\n    //     }\\n\\n    //     int mid = (low+high)/2;\\n    //     buildSeg(2*idx+1,low,mid,a);\\n    //     buildSeg(2*idx+2,mid+1,high,a);\\n\\n    //     seg[idx] = seg[2*idx+1] + seg[2*idx + 2];\\n    // }\\n\\n    int querySeg(int idx,int low,int high,int l,int r)\\n    {\\n        if(low >= l && high <= r)\\n        return seg[idx];\\n\\n        if(high < l || low > r)\\n        return 0;\\n\\n        int mid=(low+high)/2;\\n        return querySeg(2*idx+1,low,mid,l,r) + querySeg(2*idx+2,mid+1,high,l,r);\\n    }\\n\\n    void updateSeg(int idx,int low,int high, int index,int val)\\n    {\\n        if(low==high)  \\n        {\\n            seg[idx]+=val;\\n        return;\\n        }\\n\\n        int mid=(low+high)/2;\\n        if(index <= mid)\\n        updateSeg(2*idx+1,low,mid,index,val);\\n        else\\n        updateSeg(2*idx+2,mid+1,high,index,val);\\n\\n        seg[idx]=seg[2*idx+1] + seg[2*idx+2];\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>res;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            res.push_back(nums1[i]-nums2[i]);\\n        }\\n\\n\\n        long long int ans = 0;\\n        for(int i=res.size()-1;i>=0;i--)\\n        {\\n            long long int x=1LL*querySeg(0,0,1e5,0,res[i]+2e4-diff-1);\\n            long long int pairs = res.size() - i - 1;\\n            ans+=(pairs - x);\\n            \\n            updateSeg(0,0,1e5,res[i]+2e4,1);\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    int seg[400000+5];\\n    // void buildSeg(int idx,int low,int high,vector<int>&a)\\n    // {\\n    //     if(low==high)\\n    //     {\\n    //         seg[idx]=a[low];\\n    //     return;\\n    //     }\\n\\n    //     int mid = (low+high)/2;\\n    //     buildSeg(2*idx+1,low,mid,a);\\n    //     buildSeg(2*idx+2,mid+1,high,a);\\n\\n    //     seg[idx] = seg[2*idx+1] + seg[2*idx + 2];\\n    // }\\n\\n    int querySeg(int idx,int low,int high,int l,int r)\\n    {\\n        if(low >= l && high <= r)\\n        return seg[idx];\\n\\n        if(high < l || low > r)\\n        return 0;\\n\\n        int mid=(low+high)/2;\\n        return querySeg(2*idx+1,low,mid,l,r) + querySeg(2*idx+2,mid+1,high,l,r);\\n    }\\n\\n    void updateSeg(int idx,int low,int high, int index,int val)\\n    {\\n        if(low==high)  \\n        {\\n            seg[idx]+=val;\\n        return;\\n        }\\n\\n        int mid=(low+high)/2;\\n        if(index <= mid)\\n        updateSeg(2*idx+1,low,mid,index,val);\\n        else\\n        updateSeg(2*idx+2,mid+1,high,index,val);\\n\\n        seg[idx]=seg[2*idx+1] + seg[2*idx+2];\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>res;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            res.push_back(nums1[i]-nums2[i]);\\n        }\\n\\n\\n        long long int ans = 0;\\n        for(int i=res.size()-1;i>=0;i--)\\n        {\\n            long long int x=1LL*querySeg(0,0,1e5,0,res[i]+2e4-diff-1);\\n            long long int pairs = res.size() - i - 1;\\n            ans+=(pairs - x);\\n            \\n            updateSeg(0,0,1e5,res[i]+2e4,1);\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727741,
                "title": "python-fenwick-tree-solution",
                "content": "```\\n\"\"\"\\nAs mentioned in the problem, we have to satisfy the equation: \\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\nnums1[i] - nums2[i] - nums1[j] + nums2[j] <= diff\\n\\n(nums1[i] - nums2[i]) - (nums1[j] - nums2[j]) <= diff\\nD1[i] - D2[j] <= diff\\n\\nD = [...] , i, j , j > i , D[i] - D[j] <= diff\\n\\nD[i] - diff <= D[j] for j > i\\n\\nHence we have to find number of elements or number of j > i such that D[j] >= D[i] - diff for each i from 0 to n - 2. \\nWe can use fenwick tree algorithm. \\n\"\"\"\\n\\n\\nclass Solution(object):\\n\\n    def update(self, bit, idx, val, n):\\n        while idx <= n:\\n            # print(\"idx \" , idx)\\n            bit[idx] += val\\n            idx += idx & (-idx)\\n\\n    def query(self, bit, idx):\\n        res = 0\\n        while idx > 0:\\n            res = res + bit[idx]\\n            idx -= (idx) & (-idx)\\n        return res\\n\\n    def numberOfPairs(self, nums1, nums2, diff):\\n        query = []\\n        array = []\\n        n = len(nums1)\\n        bit = [0] * (n + 1)\\n        for i in range(0, n):\\n            array.append((nums1[i] - nums2[i], i))\\n            if i <= (n - 2):\\n                query.append((nums1[i] - nums2[i] - diff, i + 1, n - 1))\\n        array = sorted(array, key=lambda val: (-val[0]))\\n        query = sorted(query, key=lambda val: (-val[0]))\\n        curr = 0\\n        ans = 0\\n        for i in range(0, len(query)):\\n            while curr < n and (array[curr][0] >= query[i][0]):\\n                self.update(bit, array[curr][1] + 1, 1, n)\\n                curr = curr + 1\\n            ll = query[i][1]\\n            rr = query[i][2]\\n            curr_ans = self.query(bit, rr + 1) - self.query(bit, ll)\\n            ans = ans + curr_ans\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nAs mentioned in the problem, we have to satisfy the equation: \\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\nnums1[i] - nums2[i] - nums1[j] + nums2[j] <= diff\\n\\n(nums1[i] - nums2[i]) - (nums1[j] - nums2[j]) <= diff\\nD1[i] - D2[j] <= diff\\n\\nD = [...] , i, j , j > i , D[i] - D[j] <= diff\\n\\nD[i] - diff <= D[j] for j > i\\n\\nHence we have to find number of elements or number of j > i such that D[j] >= D[i] - diff for each i from 0 to n - 2. \\nWe can use fenwick tree algorithm. \\n\"\"\"\\n\\n\\nclass Solution(object):\\n\\n    def update(self, bit, idx, val, n):\\n        while idx <= n:\\n            # print(\"idx \" , idx)\\n            bit[idx] += val\\n            idx += idx & (-idx)\\n\\n    def query(self, bit, idx):\\n        res = 0\\n        while idx > 0:\\n            res = res + bit[idx]\\n            idx -= (idx) & (-idx)\\n        return res\\n\\n    def numberOfPairs(self, nums1, nums2, diff):\\n        query = []\\n        array = []\\n        n = len(nums1)\\n        bit = [0] * (n + 1)\\n        for i in range(0, n):\\n            array.append((nums1[i] - nums2[i], i))\\n            if i <= (n - 2):\\n                query.append((nums1[i] - nums2[i] - diff, i + 1, n - 1))\\n        array = sorted(array, key=lambda val: (-val[0]))\\n        query = sorted(query, key=lambda val: (-val[0]))\\n        curr = 0\\n        ans = 0\\n        for i in range(0, len(query)):\\n            while curr < n and (array[curr][0] >= query[i][0]):\\n                self.update(bit, array[curr][1] + 1, 1, n)\\n                curr = curr + 1\\n            ll = query[i][1]\\n            rr = query[i][2]\\n            curr_ans = self.query(bit, rr + 1) - self.query(bit, ll)\\n            ans = ans + curr_ans\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723060,
                "title": "easy-merge-sort-based-solution-c",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Merge Sort Pair Pattern\\u2705\\n    //TC=O(2NlogN)\\n    //SC=O(N) N=size of temp\\n    //Find all pair from low...high that satisfy the equation\\n    long long find(int low,int mid,int high,vector<int>& nums,int diff){\\n        int left=low,right=mid+1;\\n        long long c=0;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]+diff){\\n                left++;\\n            }else{\\n                c+=(left-low);\\n                right++;\\n            }\\n        }\\n        while(right<=high){\\n            c+=(left-low);\\n            right++;\\n        }\\n        return c;\\n    }\\n    long long merge(int low,int mid,int high,vector<int>& nums,int diff){\\n        vector<int> temp;\\n        int left=low,right=mid+1;\\n        long long countPair=find(low,mid,high,nums,diff);\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }else{\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right<=high){\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n        for(int i=low;i<=high;i++){\\n            nums[i]=temp[i-low];\\n        }\\n        return countPair;\\n    }\\n    long long mergeSort(int low,int high,vector<int>& nums,int diff){\\n        if(low>=high)\\n            return 0;\\n        int mid=low+(high-low)/2;\\n        long long c=0;\\n        c+=mergeSort(low,mid,nums,diff);\\n        c+=mergeSort(mid+1,high,nums,diff);\\n        c+=merge(low,mid,high,nums,diff);\\n        return c;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            nums1[i]=nums1[i]-nums2[i];\\n        }\\n        return mergeSort(0,n-1,nums1,diff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Merge Sort Pair Pattern\\u2705\\n    //TC=O(2NlogN)\\n    //SC=O(N) N=size of temp\\n    //Find all pair from low...high that satisfy the equation\\n    long long find(int low,int mid,int high,vector<int>& nums,int diff){\\n        int left=low,right=mid+1;\\n        long long c=0;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]+diff){\\n                left++;\\n            }else{\\n                c+=(left-low);\\n                right++;\\n            }\\n        }\\n        while(right<=high){\\n            c+=(left-low);\\n            right++;\\n        }\\n        return c;\\n    }\\n    long long merge(int low,int mid,int high,vector<int>& nums,int diff){\\n        vector<int> temp;\\n        int left=low,right=mid+1;\\n        long long countPair=find(low,mid,high,nums,diff);\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }else{\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right<=high){\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n        for(int i=low;i<=high;i++){\\n            nums[i]=temp[i-low];\\n        }\\n        return countPair;\\n    }\\n    long long mergeSort(int low,int high,vector<int>& nums,int diff){\\n        if(low>=high)\\n            return 0;\\n        int mid=low+(high-low)/2;\\n        long long c=0;\\n        c+=mergeSort(low,mid,nums,diff);\\n        c+=mergeSort(mid+1,high,nums,diff);\\n        c+=merge(low,mid,high,nums,diff);\\n        return c;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            nums1[i]=nums1[i]-nums2[i];\\n        }\\n        return mergeSort(0,n-1,nums1,diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709545,
                "title": "merge-sort-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int left, int mid, int right, int diff) {\\n        int index1 = left, index2 = mid + 1;\\n        long long pairs = 0;\\n        vector<int> temp;\\n        while(index1 <= mid && index2 <= right) {\\n            if(nums[index1] <= nums[index2] + diff) {\\n                pairs += right - index2 + 1;\\n                index1++;\\n            } else {\\n                index2++;\\n            }\\n        }\\n        index1 = left;\\n        index2 = mid + 1;\\n        while(index1 <= mid && index2 <= right) {\\n            if(nums[index1] <= nums[index2]) {\\n                temp.push_back(nums[index1++]);\\n            } else {\\n                temp.push_back(nums[index2++]);\\n            }\\n        }\\n        while(index1 <= mid) {\\n            temp.push_back(nums[index1++]);\\n        }\\n        while(index2 <= right){\\n            temp.push_back(nums[index2++]);\\n        }\\n        for(int index = 0; index < temp.size(); index++) {\\n            nums[index + left] = temp[index];\\n        }\\n        return pairs;\\n    }\\n\\n    long long divide(vector<int>& nums, int left, int right, int diff) {\\n        int mid = left + (right - left) / 2;\\n        if(left >= right)\\n            return 0;\\n        long long numberOfPairs = 0;\\n        numberOfPairs += divide(nums, left, mid, diff);\\n        numberOfPairs += divide(nums, mid + 1, right, diff);\\n        numberOfPairs += countPairs(nums, left, mid, right, diff);\\n        return numberOfPairs;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> nums;\\n        for(int index = 0; index < nums1.size(); index++) {\\n            nums.push_back(nums1[index] - nums2[index]);\\n        }\\n        return divide(nums, 0, nums1.size() - 1, diff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countPairs(vector<int>& nums, int left, int mid, int right, int diff) {\\n        int index1 = left, index2 = mid + 1;\\n        long long pairs = 0;\\n        vector<int> temp;\\n        while(index1 <= mid && index2 <= right) {\\n            if(nums[index1] <= nums[index2] + diff) {\\n                pairs += right - index2 + 1;\\n                index1++;\\n            } else {\\n                index2++;\\n            }\\n        }\\n        index1 = left;\\n        index2 = mid + 1;\\n        while(index1 <= mid && index2 <= right) {\\n            if(nums[index1] <= nums[index2]) {\\n                temp.push_back(nums[index1++]);\\n            } else {\\n                temp.push_back(nums[index2++]);\\n            }\\n        }\\n        while(index1 <= mid) {\\n            temp.push_back(nums[index1++]);\\n        }\\n        while(index2 <= right){\\n            temp.push_back(nums[index2++]);\\n        }\\n        for(int index = 0; index < temp.size(); index++) {\\n            nums[index + left] = temp[index];\\n        }\\n        return pairs;\\n    }\\n\\n    long long divide(vector<int>& nums, int left, int right, int diff) {\\n        int mid = left + (right - left) / 2;\\n        if(left >= right)\\n            return 0;\\n        long long numberOfPairs = 0;\\n        numberOfPairs += divide(nums, left, mid, diff);\\n        numberOfPairs += divide(nums, mid + 1, right, diff);\\n        numberOfPairs += countPairs(nums, left, mid, right, diff);\\n        return numberOfPairs;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> nums;\\n        for(int index = 0; index < nums1.size(); index++) {\\n            nums.push_back(nums1[index] - nums2[index]);\\n        }\\n        return divide(nums, 0, nums1.size() - 1, diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691792,
                "title": "rust-merge-sort-o-nlogn",
                "content": "# Intuition\\nLet the two given array be $A,B$ the diff is $d$, let\\'s take some observation:\\n$A_i - A_j \\\\geq B_i - B_j + d \\\\implies A_i - B_i \\\\geq A_j - B_j + d$\\nLet $delta = A-B$, the problem becomes\\n> Count the pair $(i,j)$ where $delta_i \\\\geq delta_j + d$ and $0 \\\\leq i < j < n$\\n# Approach\\n- Calculate $delta = A-B$\\n- Merge sort $delta$\\n    - Each merge operation, we can loop through `left` array and query how many element in the `right` array that satisfy the condition\\n    - Since `right` array are sorted, we can use binary search and query in $O(log(n))$\\n\\n# Complexity\\n- Time complexity: $O(n\\\\times log(n))$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```rust\\nuse std::cmp::Ordering;\\nconst INF: i32 = 1000_000_000;\\nimpl Solution {\\n    fn merge_sort(nums: &mut Vec<i32>, diff: i32) -> i64 {\\n        let n = nums.len();\\n        if n <= 1 {\\n            return 0;\\n        }\\n        let mut ret = 0;\\n        let mut left = nums.clone();\\n        let mut right = left.split_off(n/2);\\n        ret += Self::merge_sort(&mut left, diff);\\n        ret += Self::merge_sort(&mut right, diff);\\n        let n = left.len();\\n        let m = right.len();\\n        for x in left.iter() {\\n            let target = x - diff;\\n            let i = right.binary_search_by(|&y| \\n                if y >= target {\\n                    Ordering::Greater\\n                } else {\\n                    Ordering::Less\\n                }\\n            ).unwrap_err();\\n            ret += (m-i) as i64;\\n        }\\n        nums.clear();\\n        let mut i = 0;\\n        let mut j = 0;\\n        while i < n || j < m {\\n            let li = left.get(i).unwrap_or(&INF);\\n            let rj = right.get(j).unwrap_or(&INF);\\n            if li < rj {\\n                nums.push(*li);\\n                i += 1;\\n            } else {\\n                nums.push(*rj);\\n                j += 1;\\n            }\\n        }\\n        return ret;\\n    }\\n    pub fn number_of_pairs(nums1: Vec<i32>, nums2: Vec<i32>, diff: i32) -> i64 {\\n        let n = nums1.len();\\n        let mut delta: Vec<i32> = (0..n)\\n            .map(|i| nums1[i] - nums2[i])\\n            .collect();\\n        //println!(\"delta = {nums:?}\");\\n        // now the problem becomes:\\n        // find all pairs (i,j), where i<j, delta[i] - delta[j] <= diff\\n        Self::merge_sort(&mut delta, diff)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Ordering;\\nconst INF: i32 = 1000_000_000;\\nimpl Solution {\\n    fn merge_sort(nums: &mut Vec<i32>, diff: i32) -> i64 {\\n        let n = nums.len();\\n        if n <= 1 {\\n            return 0;\\n        }\\n        let mut ret = 0;\\n        let mut left = nums.clone();\\n        let mut right = left.split_off(n/2);\\n        ret += Self::merge_sort(&mut left, diff);\\n        ret += Self::merge_sort(&mut right, diff);\\n        let n = left.len();\\n        let m = right.len();\\n        for x in left.iter() {\\n            let target = x - diff;\\n            let i = right.binary_search_by(|&y| \\n                if y >= target {\\n                    Ordering::Greater\\n                } else {\\n                    Ordering::Less\\n                }\\n            ).unwrap_err();\\n            ret += (m-i) as i64;\\n        }\\n        nums.clear();\\n        let mut i = 0;\\n        let mut j = 0;\\n        while i < n || j < m {\\n            let li = left.get(i).unwrap_or(&INF);\\n            let rj = right.get(j).unwrap_or(&INF);\\n            if li < rj {\\n                nums.push(*li);\\n                i += 1;\\n            } else {\\n                nums.push(*rj);\\n                j += 1;\\n            }\\n        }\\n        return ret;\\n    }\\n    pub fn number_of_pairs(nums1: Vec<i32>, nums2: Vec<i32>, diff: i32) -> i64 {\\n        let n = nums1.len();\\n        let mut delta: Vec<i32> = (0..n)\\n            .map(|i| nums1[i] - nums2[i])\\n            .collect();\\n        //println!(\"delta = {nums:?}\");\\n        // now the problem becomes:\\n        // find all pairs (i,j), where i<j, delta[i] - delta[j] <= diff\\n        Self::merge_sort(&mut delta, diff)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3681112,
                "title": "easy-intuition-segment-tree-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAfter simplifying the equation \\ntemp[i] = temp[j] + diff;\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<vector<int>>tree;\\n     int size ;\\n     void build(int root,int l,int r,vector<int>&arr){\\n            if(l>r){\\n                return;\\n            }\\n            if(l == r){\\n                tree[root].push_back(arr[l-1]);\\n       \\n                return;\\n            }\\n            int mid = (l+r)/2;\\n            build(2*root,l,mid,arr);\\n            build(2*root+1,mid+1,r,arr);\\n            for(auto x : tree[2*root]){\\n                tree[root].push_back(x);\\n            }\\n            for(auto x : tree[2*root+1]){\\n                tree[root].push_back(x);\\n            }\\n           sort(tree[root].begin(),tree[root].end());\\n     }\\n     int result(int root,int ql,int qr,int l,int r,int target){\\n         if( ql>r || qr<l){\\n             return 0;\\n         }\\n         if(ql == l && qr == r){\\n             if(tree[root].size() ==0){\\n                 return 0;\\n             }\\n            auto it = std::lower_bound(tree[root].begin(),tree[root].end(),target);\\n            if(it == tree[root].end()){\\n                return 0;\\n            }\\n            int k = tree[root].size();\\n            if(k == 1){\\n                return 1;\\n            }\\n            int ind = it - tree[root].begin();\\n            int ans = k - ind ;\\n             // cout<<root<<\" \"<<\" l : \"<<l<<\" r : \"<<r<<\" \"<<ans<<endl;\\n            return ans;\\n         }\\n         int mid = (l+r)/2;\\n         int left = result(2*root,ql,min(mid,qr),l,mid,target);\\n         int right = result(2*root+1,max(mid+1,ql),qr,mid+1,r,target);\\n      //     cout<<root<<\" \"<<left<<\" \"<<right<<endl;\\n         return left+right;\\n     }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        size = 4*n+1;\\n        tree.resize(size);\\n        vector<int>arr;\\n        \\n        long long ans = 0;\\n        for(int i =0;i<n;i++){\\n            int val=nums1[i] - nums2[i];\\n            arr.push_back(val+diff);\\n        };\\n\\n        build(1,1,n,arr);\\n        // int cal = result(1,2,n,1,n,1);\\n        // cout<<cal<<endl;\\n        for(int i =0;i<n-1;i++){\\n         //  cout<<i+2<<\" \"<<n<<endl;\\n            int cal = result(1,i+2,n,1,n,arr[i]-diff);\\n      //      cout<<endl<<\" -- \"<<cal<<\" --\"<<endl;\\n            ans += cal;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<vector<int>>tree;\\n     int size ;\\n     void build(int root,int l,int r,vector<int>&arr){\\n            if(l>r){\\n                return;\\n            }\\n            if(l == r){\\n                tree[root].push_back(arr[l-1]);\\n       \\n                return;\\n            }\\n            int mid = (l+r)/2;\\n            build(2*root,l,mid,arr);\\n            build(2*root+1,mid+1,r,arr);\\n            for(auto x : tree[2*root]){\\n                tree[root].push_back(x);\\n            }\\n            for(auto x : tree[2*root+1]){\\n                tree[root].push_back(x);\\n            }\\n           sort(tree[root].begin(),tree[root].end());\\n     }\\n     int result(int root,int ql,int qr,int l,int r,int target){\\n         if( ql>r || qr<l){\\n             return 0;\\n         }\\n         if(ql == l && qr == r){\\n             if(tree[root].size() ==0){\\n                 return 0;\\n             }\\n            auto it = std::lower_bound(tree[root].begin(),tree[root].end(),target);\\n            if(it == tree[root].end()){\\n                return 0;\\n            }\\n            int k = tree[root].size();\\n            if(k == 1){\\n                return 1;\\n            }\\n            int ind = it - tree[root].begin();\\n            int ans = k - ind ;\\n             // cout<<root<<\" \"<<\" l : \"<<l<<\" r : \"<<r<<\" \"<<ans<<endl;\\n            return ans;\\n         }\\n         int mid = (l+r)/2;\\n         int left = result(2*root,ql,min(mid,qr),l,mid,target);\\n         int right = result(2*root+1,max(mid+1,ql),qr,mid+1,r,target);\\n      //     cout<<root<<\" \"<<left<<\" \"<<right<<endl;\\n         return left+right;\\n     }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        size = 4*n+1;\\n        tree.resize(size);\\n        vector<int>arr;\\n        \\n        long long ans = 0;\\n        for(int i =0;i<n;i++){\\n            int val=nums1[i] - nums2[i];\\n            arr.push_back(val+diff);\\n        };\\n\\n        build(1,1,n,arr);\\n        // int cal = result(1,2,n,1,n,1);\\n        // cout<<cal<<endl;\\n        for(int i =0;i<n-1;i++){\\n         //  cout<<i+2<<\" \"<<n<<endl;\\n            int cal = result(1,i+2,n,1,n,arr[i]-diff);\\n      //      cout<<endl<<\" -- \"<<cal<<\" --\"<<endl;\\n            ans += cal;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3672500,
                "title": "count-in-range-using-numpy",
                "content": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        n = len(nums1)\\n        d = []\\n        M = 0\\n        mx = 0\\n        for i in range(n):\\n            d.append(nums1[i] - nums2[i])\\n            M = min(M, nums1[i] - nums2[i] - diff, nums1[i] - nums2[i])\\n            mx = max(mx, nums1[i] - nums2[i])\\n        M *= -1\\n        res = 0\\n        order = np.array([0] * (mx + M + 1))\\n        for i in range(n - 1, -1, -1):\\n            res += np.sum(order[d[i] - diff + M : mx + M + 1])\\n            order[d[i] + M] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        n = len(nums1)\\n        d = []\\n        M = 0\\n        mx = 0\\n        for i in range(n):\\n            d.append(nums1[i] - nums2[i])\\n            M = min(M, nums1[i] - nums2[i] - diff, nums1[i] - nums2[i])\\n            mx = max(mx, nums1[i] - nums2[i])\\n        M *= -1\\n        res = 0\\n        order = np.array([0] * (mx + M + 1))\\n        for i in range(n - 1, -1, -1):\\n            res += np.sum(order[d[i] - diff + M : mx + M + 1])\\n            order[d[i] + M] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669367,
                "title": "c-binary-indexed-tree",
                "content": "# Intuition\\n       nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n    -> nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    // 1101 & (0010 + 1) = 0001\\n    #define LOWBIT(x) (x & -x) \\n    typedef long long ll;\\n    vector<int> btree;\\n\\n    void update(ll id, vector<int>& btree) {\\n        int n = btree.size();\\n        for (; id < n; id += LOWBIT(id)) { \\n            btree[id] += 1;\\n        }\\n    }\\n\\n    ll query(ll id, vector<int>& btree) {\\n        ll sum = 0;\\n        for (; id > 0; id -= LOWBIT(id)) {\\n            sum += btree[id];\\n        }\\n        return sum;\\n    }\\n    \\n    ll numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        int l = abs(3 * -1e4) + 1 + (3 * 1e4);\\n        int shift = abs(3 * -1e4); // n1 is -1e4, n2 is -1e4, diff is -1e4\\n        ll ret = 0;\\n        \\n        btree = vector<int> (l, 0);\\n\\n        for (int i = 0; i < n; i++) {\\n            int val = (nums1[i] - nums2[i]) + shift;\\n            \\n            ret += query(val + diff, btree);\\n            update(val, btree);\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    // 1101 & (0010 + 1) = 0001\\n    #define LOWBIT(x) (x & -x) \\n    typedef long long ll;\\n    vector<int> btree;\\n\\n    void update(ll id, vector<int>& btree) {\\n        int n = btree.size();\\n        for (; id < n; id += LOWBIT(id)) { \\n            btree[id] += 1;\\n        }\\n    }\\n\\n    ll query(ll id, vector<int>& btree) {\\n        ll sum = 0;\\n        for (; id > 0; id -= LOWBIT(id)) {\\n            sum += btree[id];\\n        }\\n        return sum;\\n    }\\n    \\n    ll numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        int l = abs(3 * -1e4) + 1 + (3 * 1e4);\\n        int shift = abs(3 * -1e4); // n1 is -1e4, n2 is -1e4, diff is -1e4\\n        ll ret = 0;\\n        \\n        btree = vector<int> (l, 0);\\n\\n        for (int i = 0; i < n; i++) {\\n            int val = (nums1[i] - nums2[i]) + shift;\\n            \\n            ret += query(val + diff, btree);\\n            update(val, btree);\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612990,
                "title": "golang-binary-indexed-tree",
                "content": "\\n# Code\\n```\\nfunc numberOfPairs(nums1 []int, nums2 []int, diff int) int64 {\\n  // We can rearrange the given equation like below:\\n  // nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n  // nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n  // This way we can reduce two arrays into a single array by calculating the\\n  // differece of elements at the same position on both arrays.\\n  // And then we\\'ll start from left to right and query for count of\\n  // positions we\\'ve seen that are <= comb[i] + diff. We\\'ll also add the current\\n  // comb[i] as we proceed.\\n  comb := make([]int, len(nums1))\\n  for i := 0; i < len(nums1); i++ {\\n    comb[i] = nums1[i] - nums2[i]\\n  }\\n  // Since the range of values is too huge, we can\\'t use the maximum\\n  // values as the size for the BIT (using an offset for negative numbers).\\n  // We\\'re collecting all possible numbers we\\'ll add and query from BIT and assign\\n  // them IDs in sorted order.\\n  sorted := make([]int, 2*len(comb))\\n  copy(sorted, comb)\\n  for i := 0; i < 2*len(comb); i++ {\\n    if i < len(comb) {\\n      sorted[i] = comb[i]\\n    } else {\\n      sorted[i] = comb[i - len(comb)] + diff\\n    }\\n  }\\n  sort.Ints(sorted)\\n  ids := make(map[int]int)\\n  id := 1\\n  for i := 0; i < len(sorted); i++ {\\n    if _, ok := ids[sorted[i]]; !ok {\\n      ids[sorted[i]] = id\\n      id++\\n    }\\n  }\\n  bit := make([]int, len(ids)+2)\\n  var res int64\\n  for i := 0; i < len(comb); i++ {\\n    curr := int64(prefixSum(bit, ids[comb[i]+diff]))\\n    res += curr\\n    add(bit, ids[comb[i]], 1)\\n  }\\n  return res\\n}\\n\\nfunc prefixSum(bit []int, i int) int {\\n  var sum int\\n  // 1-indexed\\n  for i = i+1; i > 0; i -= i & (-i) {\\n    sum += bit[i]\\n  }\\n  return sum\\n}\\n\\nfunc add(bit []int, i, val int) {\\n  for i = i+1; i < len(bit); i += i & (-i) {\\n    bit[i] += val\\n  }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nfunc numberOfPairs(nums1 []int, nums2 []int, diff int) int64 {\\n  // We can rearrange the given equation like below:\\n  // nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n  // nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n  // This way we can reduce two arrays into a single array by calculating the\\n  // differece of elements at the same position on both arrays.\\n  // And then we\\'ll start from left to right and query for count of\\n  // positions we\\'ve seen that are <= comb[i] + diff. We\\'ll also add the current\\n  // comb[i] as we proceed.\\n  comb := make([]int, len(nums1))\\n  for i := 0; i < len(nums1); i++ {\\n    comb[i] = nums1[i] - nums2[i]\\n  }\\n  // Since the range of values is too huge, we can\\'t use the maximum\\n  // values as the size for the BIT (using an offset for negative numbers).\\n  // We\\'re collecting all possible numbers we\\'ll add and query from BIT and assign\\n  // them IDs in sorted order.\\n  sorted := make([]int, 2*len(comb))\\n  copy(sorted, comb)\\n  for i := 0; i < 2*len(comb); i++ {\\n    if i < len(comb) {\\n      sorted[i] = comb[i]\\n    } else {\\n      sorted[i] = comb[i - len(comb)] + diff\\n    }\\n  }\\n  sort.Ints(sorted)\\n  ids := make(map[int]int)\\n  id := 1\\n  for i := 0; i < len(sorted); i++ {\\n    if _, ok := ids[sorted[i]]; !ok {\\n      ids[sorted[i]] = id\\n      id++\\n    }\\n  }\\n  bit := make([]int, len(ids)+2)\\n  var res int64\\n  for i := 0; i < len(comb); i++ {\\n    curr := int64(prefixSum(bit, ids[comb[i]+diff]))\\n    res += curr\\n    add(bit, ids[comb[i]], 1)\\n  }\\n  return res\\n}\\n\\nfunc prefixSum(bit []int, i int) int {\\n  var sum int\\n  // 1-indexed\\n  for i = i+1; i > 0; i -= i & (-i) {\\n    sum += bit[i]\\n  }\\n  return sum\\n}\\n\\nfunc add(bit []int, i, val int) {\\n  for i = i+1; i < len(bit); i += i & (-i) {\\n    bit[i] += val\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610986,
                "title": "python-o-nlogn-clean-mergesort-solution",
                "content": "# Intuition\\nI didn\\'t find any good solution using mergesort with Python; so I post my solution here.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n- $$O(n)$$\\n\\nn is the size of nums. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numberOfPairs(self, nums1, nums2, diff):\\n        new_num = [a - b for i, (a, b) in enumerate(zip(nums1, nums2))]\\n\\n\\n        def rev(nums):\\n            if len(nums) == 1:\\n                return nums, 0\\n            mid = len(nums) // 2\\n            L = nums[:mid]\\n            R = nums[mid:]\\n\\n            L, Lcnt = rev(L)\\n            R, Rcnt = rev(R)\\n\\n            i = j = 0\\n            ans = Lcnt + Rcnt\\n            while i < len(L) and j < len(R):\\n                if L[i] <= R[j] + diff:\\n                    i += 1  \\n                    ans += len(R) - j\\n                else:\\n                    j +=1\\n            return sorted(L+R), ans\\n        \\n        return rev(new_num)[1]\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfPairs(self, nums1, nums2, diff):\\n        new_num = [a - b for i, (a, b) in enumerate(zip(nums1, nums2))]\\n\\n\\n        def rev(nums):\\n            if len(nums) == 1:\\n                return nums, 0\\n            mid = len(nums) // 2\\n            L = nums[:mid]\\n            R = nums[mid:]\\n\\n            L, Lcnt = rev(L)\\n            R, Rcnt = rev(R)\\n\\n            i = j = 0\\n            ans = Lcnt + Rcnt\\n            while i < len(L) and j < len(R):\\n                if L[i] <= R[j] + diff:\\n                    i += 1  \\n                    ans += len(R) - j\\n                else:\\n                    j +=1\\n            return sorted(L+R), ans\\n        \\n        return rev(new_num)[1]\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523280,
                "title": "c-concise-bit-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(std::vector<int> & nums1, std::vector<int> & nums2, int diff) {\\n        for (int i = 0; i < std::size(nums1); ++i)\\n            nums1[i] -= nums2[i];\\n        auto [min, max] = std::minmax_element(std::begin(nums1), std::end(nums1));\\n        std::vector<int> bit(std::max(1, *max - *min + diff + 2));\\n        long long count = 0ll;\\n        for (int i = 0; i < std::size(nums1); ++i) {\\n            for (int j = nums1[i] + diff - *min + 1; j > 0; j -= j & -j)\\n                count += bit[j];\\n            for (int j = nums1[i] - *min + 1; j < std::size(bit); j += j & -j)\\n                ++bit[j];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(std::vector<int> & nums1, std::vector<int> & nums2, int diff) {\\n        for (int i = 0; i < std::size(nums1); ++i)\\n            nums1[i] -= nums2[i];\\n        auto [min, max] = std::minmax_element(std::begin(nums1), std::end(nums1));\\n        std::vector<int> bit(std::max(1, *max - *min + diff + 2));\\n        long long count = 0ll;\\n        for (int i = 0; i < std::size(nums1); ++i) {\\n            for (int j = nums1[i] + diff - *min + 1; j > 0; j -= j & -j)\\n                count += bit[j];\\n            for (int j = nums1[i] - *min + 1; j < std::size(bit); j += j & -j)\\n                ++bit[j];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392927,
                "title": "python-simple-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT:\\n    def __init__(self,n):\\n        self.ans = [0]*(n+1)\\n\\n    def query(self,i):\\n        res = 0\\n\\n        while i > 0:\\n            res += self.ans[i]\\n            i -= i&-i\\n\\n        return res\\n\\n    def update(self,i,val):\\n        while i < len(self.ans):\\n            self.ans[i] += val\\n            i += i&-i\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1, nums2, diff):\\n        n, total, c = len(nums1), 0, 10**5\\n\\n        result = BIT(1000000)\\n\\n        for j in range(n):\\n            x = result.query(nums1[j]-nums2[j]+c+diff)\\n            total += x\\n            result.update(nums1[j]-nums2[j]+c,1)\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BIT:\\n    def __init__(self,n):\\n        self.ans = [0]*(n+1)\\n\\n    def query(self,i):\\n        res = 0\\n\\n        while i > 0:\\n            res += self.ans[i]\\n            i -= i&-i\\n\\n        return res\\n\\n    def update(self,i,val):\\n        while i < len(self.ans):\\n            self.ans[i] += val\\n            i += i&-i\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1, nums2, diff):\\n        n, total, c = len(nums1), 0, 10**5\\n\\n        result = BIT(1000000)\\n\\n        for j in range(n):\\n            x = result.query(nums1[j]-nums2[j]+c+diff)\\n            total += x\\n            result.update(nums1[j]-nums2[j]+c,1)\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353686,
                "title": "c-fenwink-tree",
                "content": "```\\npublic class Solution {\\n    int size =0xFFFF+1;\\n    int OFFSET=20_001;\\n    public long NumberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n=nums1.Length;\\n        long res=0;\\n        FT ft =new FT(size);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int v=nums1[i]-nums2[i];\\n            res+=ft.prefixSum(v+diff+OFFSET);\\n            ft.addValue(v+OFFSET,1);\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n\\npublic class FT{\\n    int[] arr;\\n    int size;\\n    public FT(int size)\\n    {\\n        arr=new int[size];\\n        this.size=size;\\n    }\\n    \\n    public void addValue(int i, int amt){\\n        while(i<size){\\n            arr[i]+=amt;\\n            i+=lsb(i);\\n        }\\n    }\\n    \\n    public int prefixSum(int i)\\n    {\\n        int res=0;\\n        while(i>0){\\n            res+=arr[i];\\n            i&=~lsb(i);\\n        }\\n        return res;\\n    }\\n    \\n    public int GetValue(int i)\\n    {\\n        return prefixSum(i) - prefixSum(i-1);\\n        \\n    }\\n    \\n    public int lsb(int i){\\n        \\n        return i & (-i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int size =0xFFFF+1;\\n    int OFFSET=20_001;\\n    public long NumberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n=nums1.Length;\\n        long res=0;\\n        FT ft =new FT(size);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int v=nums1[i]-nums2[i];\\n            res+=ft.prefixSum(v+diff+OFFSET);\\n            ft.addValue(v+OFFSET,1);\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n\\npublic class FT{\\n    int[] arr;\\n    int size;\\n    public FT(int size)\\n    {\\n        arr=new int[size];\\n        this.size=size;\\n    }\\n    \\n    public void addValue(int i, int amt){\\n        while(i<size){\\n            arr[i]+=amt;\\n            i+=lsb(i);\\n        }\\n    }\\n    \\n    public int prefixSum(int i)\\n    {\\n        int res=0;\\n        while(i>0){\\n            res+=arr[i];\\n            i&=~lsb(i);\\n        }\\n        return res;\\n    }\\n    \\n    public int GetValue(int i)\\n    {\\n        return prefixSum(i) - prefixSum(i-1);\\n        \\n    }\\n    \\n    public int lsb(int i){\\n        \\n        return i & (-i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350348,
                "title": "python-vanila-mergesort-solution",
                "content": "# Approach\\n**Merge Sort**\\n\\n    The constraint nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n    can be transferred to nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n\\n    Therefore, we can calculate the element-wise difference between nums1 and nums2, nums_diff,\\n    where nums_diff[i] = nums1[i] - nums2[i].\\n\\n    Then the question is transferred to finding all index pairs (i, j), where i < j in nums_diff,\\n    where nums_diff[i] <= nums_diff[j] + diff.\\n\\n    This is then similar as question 315, where we can use the merge sort idea to solve the problem.\\n\\n    During the \"merge\" phase, we are dealing with two sorted arrays, left, and right, we need to\\n    find how many pairs (i, j), where left[i] - right[j] <= diff. This can be done in O(n) with\\n    two pointers.\\n\\n    In the end we\\'ll just return the accumulated result.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        n = len(nums1)\\n        nums_diff = [nums1[i] - nums2[i] for i in range(n)]\\n        result = 0\\n\\n        def merge_sort(start: int, end: int) -> None:\\n            nonlocal diff, nums_diff, result\\n\\n            if start == end:\\n                return\\n            \\n            mid = (start + end) // 2\\n            merge_sort(start, mid)\\n            merge_sort(mid + 1, end)\\n\\n            i, j = start, mid + 1\\n            while i <= mid and j <= end:\\n                if nums_diff[i] - nums_diff[j] <= diff:\\n                    result += end - j + 1\\n                    i += 1\\n                else:\\n                    j += 1\\n\\n            i, j = start, mid + 1\\n            merged = []\\n\\n            while i <= mid and j <= end:\\n                if nums_diff[i] <= nums_diff[j]:\\n                    merged.append(nums_diff[i])\\n                    i += 1\\n                else:\\n                    merged.append(nums_diff[j])\\n                    j += 1\\n            \\n            while i <= mid:\\n                merged.append(nums_diff[i])\\n                i += 1\\n            while j <= end:\\n                merged.append(nums_diff[j])\\n                j += 1\\n            \\n            nums_diff[start:end+1] = merged\\n        \\n        merge_sort(0, n - 1)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        n = len(nums1)\\n        nums_diff = [nums1[i] - nums2[i] for i in range(n)]\\n        result = 0\\n\\n        def merge_sort(start: int, end: int) -> None:\\n            nonlocal diff, nums_diff, result\\n\\n            if start == end:\\n                return\\n            \\n            mid = (start + end) // 2\\n            merge_sort(start, mid)\\n            merge_sort(mid + 1, end)\\n\\n            i, j = start, mid + 1\\n            while i <= mid and j <= end:\\n                if nums_diff[i] - nums_diff[j] <= diff:\\n                    result += end - j + 1\\n                    i += 1\\n                else:\\n                    j += 1\\n\\n            i, j = start, mid + 1\\n            merged = []\\n\\n            while i <= mid and j <= end:\\n                if nums_diff[i] <= nums_diff[j]:\\n                    merged.append(nums_diff[i])\\n                    i += 1\\n                else:\\n                    merged.append(nums_diff[j])\\n                    j += 1\\n            \\n            while i <= mid:\\n                merged.append(nums_diff[i])\\n                i += 1\\n            while j <= end:\\n                merged.append(nums_diff[j])\\n                j += 1\\n            \\n            nums_diff[start:end+1] = merged\\n        \\n        merge_sort(0, n - 1)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285918,
                "title": "c-merge-sort-explained-fast",
                "content": "# Intuition\\n- Use merge sort\\n- On each iteration, after sorting halves before merging, count number of elements on the left, those are smaller or equal to elements on the right plus `diff`. This can be done in $\\\\max(n_l, n_r)$ comparisons.\\n\\n# Approach\\nThe problem can be reformulated as\\n\\n```\\n(nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff\\n```\\n\\nThus, subtract (in matrix semantics) `nums2` from `nums1` and rename (assign a reference) to `nums`:\\n\\n```\\nfor (int i{}; i < n; i++) nums1[i] -= nums2[i];\\nvector<int>& nums = nums1;\\n```\\n\\nDenote `nums` array as $A = {a_0, a_1, \\\\dots, a_n}$. Assume that $n_1$ elements $a_{l+1}, a_{l+2}, \\\\dots, a_{l+n_1}$, are already sorted in ascending order. Also assume, that $n_2$ elemets $a_{r+1}, a_{r+2}, \\\\dots, a_{r+n_2}$, where $r = l + n_1$, are also sorted in ascending order. Then, if for some $i_1, i_2$, such that $l < i_1 \\\\leq l + n_1$ and $r < i_2 \\\\leq r + n_2$ holds $a_{i_1} \\\\leq a_{i_2} + d$, then it will hold for any $i, i_2 \\\\leq i < r + n_2$. So, we can compute number of appropriate index pairs for these two parts in a loop with $\\\\max(n_1, n_2)$ iterations:\\n\\n```\\n// Code here is slightly modified for consistency.\\nlong long ans{};\\nint i1 = l + 1;\\nint i2 = r + 1;\\nwhile (i1 <= (l + n1) && i2 <= (r + n2)) {\\n    if (nums[i1] <= nums[i2] + diff) {  // (*)\\n        ans += ((r + n2) - i2 + 1);  \\n        i1++;\\n    } else {\\n        i2++;\\n    }\\n}\\n```\\n\\nAfter this comparisons we can merge halves as usual in merge-sort algorithm. However, to avoid multiple ADD operations on the right half in merge-sort, we can increase elements in `nums` array by `diff`. This can be done only when these elements will not be used in comparisons denoted by `(*)` in further merges.\\n\\nAll other details see in code and comments.\\n\\n> By the time of writing, code worked as fast as **84%**.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums, int offset, int n1, int n2) {\\n        int n{n1 + n2};         // total number of elements\\n\\n        static vector<int> buf{};   // here we collect merge result\\n        buf.resize(n);\\n\\n        int i1{offset};         // index in the left half\\n        int end1{offset + n1};  // index after the last elem in the left part\\n        int i2{end1};           // index in the right half\\n        int end2{end1 + n2};    // index after the last elem in the right part\\n        int j{};                // index in buffer\\n\\n        while (i1 < end1 && i2 < end2) {\\n            if (nums[i1] <= nums[i2]) \\n                buf[j++] = nums[i1++];\\n            else\\n                buf[j++] = nums[i2++];\\n        }\\n        while (i1 < end1) \\n            buf[j++] = nums[i1++];\\n        while (i2 < end2) \\n            buf[j++] = nums[i2++];\\n\\n        // Write back to nums.\\n        for (int i{}; i < n; i++) \\n            nums[offset + i] = buf[i];\\n    }\\n\\n    long long sort(vector<int>& nums, int offset, int n1, int n2, int diff) {\\n\\n        // Define indexes and boundaries for inversions count and merge:\\n        int base1{offset};       // index of the first element in the left half\\n        int base2{offset + n1};  // index of the first element in the right half\\n        int end1{base2};         // index after the last element in the left half\\n        int end2{base2 + n2};    // index after the last element in the right half\\n\\n        long long ans{};  // answer (number of index pairs)\\n\\n        // Sort halfs\\n        if (n1 > 1) {\\n            // Elements in the left part are NOT increased by diff.\\n            ans += sort(nums, offset, n1/2, n1 - n1/2, diff);\\n        }\\n        if (n2 > 1) {\\n            // Elements in the right part are increased by diff if this is\\n            // the rightmost half (end2 == nums.size())\\n            ans += sort(nums, offset+n1, n2/2, n2 - n2/2, diff);\\n        } else if (end2 == nums.size()) {\\n            // If this is the rightmost part, and no sort() on it was called,\\n            // e.g. n2 == 0 or 1, then no index pairs there. Increase by diff.\\n            for (int i{base2}; i < end2; i++) {\\n                nums[i] += diff;\\n            }\\n        }\\n\\n        // Count inversions: number of elements in the left half less or equal\\n        // to elements in the right half + diff.\\n        // Note: left and right halfs are already sorted.\\n        int i1{base1}, i2{base2};\\n\\n        // Depending on whether this is the rightmost half, we either temporarily\\n        // increase by diff, or permanently change values.\\n        if (end2 == nums.size()) {\\n            // Assume rightmost half is increased by diff.\\n            while (i1 < end1 && i2 < end2) {\\n                if (nums[i1] <= nums[i2]) {\\n                    // Since nums[i2+k] >= nums[i2], then all (n2 - i2) elements are.\\n                    ans += (end2 - i2); \\n                    i1++;  // move to the next element in the left half\\n                } else {\\n                    i2++;  // nums[i1] > nums[i2] + diff. Maybe next i2 will be better.\\n                }\\n                // If i1 == end1, then there is some i2 <= n2, such that \\n                //  all nums[i2] >= nums[i1], for i1 up to n1-1.\\n                // If i2 == end2, then there were some elements on the left, which were too large.\\n            }\\n\\n            // If this is not the last iteration (i.e. offset != 0, since we know, that\\n            // this part is the righmost already), then we increase elements in the left\\n            // half and merge.\\n            if (offset > 0) {\\n                // Since this is the rightmost part,\\n                // we also increase left half elements by diff before merge.\\n                for (i1 = base1; i1 < end1; i1++)\\n                    nums[i1] += diff;\\n                merge(nums, offset, n1, n2);\\n            }\\n        } else {\\n            // This is NOT the rightmost half. It will be used somewhere later\\n            // as the leftmsot part, so we can not permanently increase elements by diff.\\n            while (i1 < end1 && i2 < end2) {\\n                if (nums[i1] <= nums[i2] + diff) {  // add diff here, result not stored.\\n                    ans += (end2 - i2); \\n                    i1++;\\n                } else {\\n                    i2++;\\n                }\\n            }\\n            merge(nums, offset, n1, n2);\\n        }\\n\\n        return ans;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        // Task is equal to find number of pairs (i, j) such that: \\n        //      (nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff\\n        // To simplify, subtract nums2 from nums1.\\n        const int n = nums1.size();\\n        for (int i{}; i < n; i++)\\n            nums1[i] -= nums2[i];\\n        \\n        vector<int>& nums{nums1};\\n        // Now task looks like find pairs (i, j), i < j, such that:\\n        //      nums[i] <= nums[j] + diff.\\n\\n        // Since i < j, when i is fixed we only need to compare nums[i] with values\\n        // of (nums[j] + diff), for j > i. So, we can move from right to left,\\n        // adding `diff` to all visited elements, sorting and comparing.\\n        return sort(nums, 0, n/2, n - n/2, diff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\n(nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff\\n```\n```\\nfor (int i{}; i < n; i++) nums1[i] -= nums2[i];\\nvector<int>& nums = nums1;\\n```\n```\\n// Code here is slightly modified for consistency.\\nlong long ans{};\\nint i1 = l + 1;\\nint i2 = r + 1;\\nwhile (i1 <= (l + n1) && i2 <= (r + n2)) {\\n    if (nums[i1] <= nums[i2] + diff) {  // (*)\\n        ans += ((r + n2) - i2 + 1);  \\n        i1++;\\n    } else {\\n        i2++;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums, int offset, int n1, int n2) {\\n        int n{n1 + n2};         // total number of elements\\n\\n        static vector<int> buf{};   // here we collect merge result\\n        buf.resize(n);\\n\\n        int i1{offset};         // index in the left half\\n        int end1{offset + n1};  // index after the last elem in the left part\\n        int i2{end1};           // index in the right half\\n        int end2{end1 + n2};    // index after the last elem in the right part\\n        int j{};                // index in buffer\\n\\n        while (i1 < end1 && i2 < end2) {\\n            if (nums[i1] <= nums[i2]) \\n                buf[j++] = nums[i1++];\\n            else\\n                buf[j++] = nums[i2++];\\n        }\\n        while (i1 < end1) \\n            buf[j++] = nums[i1++];\\n        while (i2 < end2) \\n            buf[j++] = nums[i2++];\\n\\n        // Write back to nums.\\n        for (int i{}; i < n; i++) \\n            nums[offset + i] = buf[i];\\n    }\\n\\n    long long sort(vector<int>& nums, int offset, int n1, int n2, int diff) {\\n\\n        // Define indexes and boundaries for inversions count and merge:\\n        int base1{offset};       // index of the first element in the left half\\n        int base2{offset + n1};  // index of the first element in the right half\\n        int end1{base2};         // index after the last element in the left half\\n        int end2{base2 + n2};    // index after the last element in the right half\\n\\n        long long ans{};  // answer (number of index pairs)\\n\\n        // Sort halfs\\n        if (n1 > 1) {\\n            // Elements in the left part are NOT increased by diff.\\n            ans += sort(nums, offset, n1/2, n1 - n1/2, diff);\\n        }\\n        if (n2 > 1) {\\n            // Elements in the right part are increased by diff if this is\\n            // the rightmost half (end2 == nums.size())\\n            ans += sort(nums, offset+n1, n2/2, n2 - n2/2, diff);\\n        } else if (end2 == nums.size()) {\\n            // If this is the rightmost part, and no sort() on it was called,\\n            // e.g. n2 == 0 or 1, then no index pairs there. Increase by diff.\\n            for (int i{base2}; i < end2; i++) {\\n                nums[i] += diff;\\n            }\\n        }\\n\\n        // Count inversions: number of elements in the left half less or equal\\n        // to elements in the right half + diff.\\n        // Note: left and right halfs are already sorted.\\n        int i1{base1}, i2{base2};\\n\\n        // Depending on whether this is the rightmost half, we either temporarily\\n        // increase by diff, or permanently change values.\\n        if (end2 == nums.size()) {\\n            // Assume rightmost half is increased by diff.\\n            while (i1 < end1 && i2 < end2) {\\n                if (nums[i1] <= nums[i2]) {\\n                    // Since nums[i2+k] >= nums[i2], then all (n2 - i2) elements are.\\n                    ans += (end2 - i2); \\n                    i1++;  // move to the next element in the left half\\n                } else {\\n                    i2++;  // nums[i1] > nums[i2] + diff. Maybe next i2 will be better.\\n                }\\n                // If i1 == end1, then there is some i2 <= n2, such that \\n                //  all nums[i2] >= nums[i1], for i1 up to n1-1.\\n                // If i2 == end2, then there were some elements on the left, which were too large.\\n            }\\n\\n            // If this is not the last iteration (i.e. offset != 0, since we know, that\\n            // this part is the righmost already), then we increase elements in the left\\n            // half and merge.\\n            if (offset > 0) {\\n                // Since this is the rightmost part,\\n                // we also increase left half elements by diff before merge.\\n                for (i1 = base1; i1 < end1; i1++)\\n                    nums[i1] += diff;\\n                merge(nums, offset, n1, n2);\\n            }\\n        } else {\\n            // This is NOT the rightmost half. It will be used somewhere later\\n            // as the leftmsot part, so we can not permanently increase elements by diff.\\n            while (i1 < end1 && i2 < end2) {\\n                if (nums[i1] <= nums[i2] + diff) {  // add diff here, result not stored.\\n                    ans += (end2 - i2); \\n                    i1++;\\n                } else {\\n                    i2++;\\n                }\\n            }\\n            merge(nums, offset, n1, n2);\\n        }\\n\\n        return ans;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        // Task is equal to find number of pairs (i, j) such that: \\n        //      (nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff\\n        // To simplify, subtract nums2 from nums1.\\n        const int n = nums1.size();\\n        for (int i{}; i < n; i++)\\n            nums1[i] -= nums2[i];\\n        \\n        vector<int>& nums{nums1};\\n        // Now task looks like find pairs (i, j), i < j, such that:\\n        //      nums[i] <= nums[j] + diff.\\n\\n        // Since i < j, when i is fixed we only need to compare nums[i] with values\\n        // of (nums[j] + diff), for j > i. So, we can move from right to left,\\n        // adding `diff` to all visited elements, sorting and comparing.\\n        return sort(nums, 0, n/2, n - n/2, diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258568,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long int count;\\n   \\n    void checkCount(vector<int>& nums, int start, int mid, int end,int d)\\n    {\\n\\n        \\n        int l = start, r = mid + 1;\\n        while(l <= mid && r <= end)\\n        {\\n            if(nums[l]<=(nums[r]+d))  \\n            {\\n                count += (end - r+1);\\n                l++;\\n            }\\n            else      \\n            {\\n                r++;\\n            }\\n        }\\n        sort(nums.begin() + start, nums.begin() + end + 1);  \\n        return;\\n         \\n    }\\n    void mergeSort(vector<int>& nums, int start, int end,int d)\\n    {\\n        if(start == end) \\n            return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid,d);\\n        mergeSort(nums,mid+1,end,d);\\n        \\n        checkCount(nums,start,mid,end,d);\\n        return;\\n        \\n    }\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int d) \\n    {\\n        count = 0;\\n        int n = a.size();\\n        vector<int>c(n);  \\n        \\n        for(int i=0;i<n;i++)\\n        c[i]=a[i]-b[i];               \\n\\t\\t\\t\\n        mergeSort(c,0,n-1,d);\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long int count;\\n   \\n    void checkCount(vector<int>& nums, int start, int mid, int end,int d)\\n    {\\n\\n        \\n        int l = start, r = mid + 1;\\n        while(l <= mid && r <= end)\\n        {\\n            if(nums[l]<=(nums[r]+d))  \\n            {\\n                count += (end - r+1);\\n                l++;\\n            }\\n            else      \\n            {\\n                r++;\\n            }\\n        }\\n        sort(nums.begin() + start, nums.begin() + end + 1);  \\n        return;\\n         \\n    }\\n    void mergeSort(vector<int>& nums, int start, int end,int d)\\n    {\\n        if(start == end) \\n            return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid,d);\\n        mergeSort(nums,mid+1,end,d);\\n        \\n        checkCount(nums,start,mid,end,d);\\n        return;\\n        \\n    }\\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int d) \\n    {\\n        count = 0;\\n        int n = a.size();\\n        vector<int>c(n);  \\n        \\n        for(int i=0;i<n;i++)\\n        c[i]=a[i]-b[i];               \\n\\t\\t\\t\\n        mergeSort(c,0,n-1,d);\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203496,
                "title": "mergesort-java",
                "content": "\\n# Approach\\nMerge Sort, before merging left and right sub-arrays, iterate left and right to find out how many pairs satisfy:\\n\\nleft[i] <= right[j] + diff\\n\\nNote i does not need to start from 0 again in each iteration, because when j increases, i can continue from where it was in the last iteration.\\n\\nAlso, note the answer should be \"long\" type, if you use \"int\" type it will fail because some test cases might be larger than Integer.MAX_VALUE.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    long count;\\n    int globalDiff;\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        count = 0;\\n        globalDiff = diff;\\n\\n        int[] nums = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n\\n        mergeSort(nums, 0, n - 1);\\n        return count;   \\n    }\\n\\n    private void mergeSort(int[] nums, int start, int end) {\\n        if (start >= end)\\n            return;\\n        int mid = start + (end - start) / 2;\\n        mergeSort(nums, start, mid);\\n        mergeSort(nums, mid + 1, end);\\n        merge(nums, start, mid, end);\\n    }\\n\\n    private void merge(int[] nums, int start, int mid, int end) {\\n        int n1 = mid - start + 1;\\n        int n2 = end - mid;\\n        int[] left = new int[n1];\\n        int[] right = new int[n2];\\n\\n        for (int i = 0; i < n1; i++) {\\n            left[i] = nums[start + i];\\n        }\\n        for (int i = 0; i < n2; i++) {\\n            right[i] = nums[mid + 1 + i];\\n        }\\n\\n        int i = 0;\\n        for (int j = 0; j < n2; j++) {\\n            while (i < n1 && left[i] <= right[j] + globalDiff)\\n                i++;\\n            count += i;\\n        }\\n\\n        // Merge left and right\\n        i = 0;\\n        int j = 0, k = start;\\n        while (i < n1 && j < n2) {\\n            if (left[i] <= right[j]) {\\n                nums[k] = left[i];\\n                i++;\\n            } else {\\n                nums[k] = right[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while (i < n1) {\\n            nums[k] = left[i];\\n            i++;\\n            k++;\\n        }\\n        while (j < n2) {\\n            nums[k] = right[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    long count;\\n    int globalDiff;\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        count = 0;\\n        globalDiff = diff;\\n\\n        int[] nums = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n\\n        mergeSort(nums, 0, n - 1);\\n        return count;   \\n    }\\n\\n    private void mergeSort(int[] nums, int start, int end) {\\n        if (start >= end)\\n            return;\\n        int mid = start + (end - start) / 2;\\n        mergeSort(nums, start, mid);\\n        mergeSort(nums, mid + 1, end);\\n        merge(nums, start, mid, end);\\n    }\\n\\n    private void merge(int[] nums, int start, int mid, int end) {\\n        int n1 = mid - start + 1;\\n        int n2 = end - mid;\\n        int[] left = new int[n1];\\n        int[] right = new int[n2];\\n\\n        for (int i = 0; i < n1; i++) {\\n            left[i] = nums[start + i];\\n        }\\n        for (int i = 0; i < n2; i++) {\\n            right[i] = nums[mid + 1 + i];\\n        }\\n\\n        int i = 0;\\n        for (int j = 0; j < n2; j++) {\\n            while (i < n1 && left[i] <= right[j] + globalDiff)\\n                i++;\\n            count += i;\\n        }\\n\\n        // Merge left and right\\n        i = 0;\\n        int j = 0, k = start;\\n        while (i < n1 && j < n2) {\\n            if (left[i] <= right[j]) {\\n                nums[k] = left[i];\\n                i++;\\n            } else {\\n                nums[k] = right[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while (i < n1) {\\n            nums[k] = left[i];\\n            i++;\\n            k++;\\n        }\\n        while (j < n2) {\\n            nums[k] = right[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190760,
                "title": "using-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        from sortedcontainers import SortedList\\n        list1=SortedList()\\n        count=0\\n        for i,j in zip(nums1,nums2):\\n            count+=list1.bisect_right(i-j+diff)\\n            list1.add(i-j)\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        from sortedcontainers import SortedList\\n        list1=SortedList()\\n        count=0\\n        for i,j in zip(nums1,nums2):\\n            count+=list1.bisect_right(i-j+diff)\\n            list1.add(i-j)\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109835,
                "title": "simplest-explanation",
                "content": "Rearrange the equation to form the equation given below:\\n> nums1[j] - nums2[j] <= nums1[i] - nums2[i] - diff ; j > i\\n\\nNow look at the code below, if you remove \\'code block 1\\' labled in the code, then its just a merge sort code, not a single line is changed and it does sort the array\\nIf you have any doubt about merge sort then this question is not for you right now.\\n\\nNow mergeSort sorts both the array and before we merge these two array we calculate the temp ans and add to our global ans.\\n\\nWhat is temp ans? For each element in second sorted we find the number of elements in first sorted array that satisfy the condition given above. Before we check condition, we add diff to element of second array since we subtracted diff from each element.\\nNow the rest part is handled by recursive calls, time complexity is same as merge sort, since merge operation is linear and the code block also runs in linear time.\\n\\nIf you have any doubt, comment down, I\\'ll try to ans when I\\'m free\\n\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\nprivate:\\n    int d;\\n    ll ans = 0;\\n    void merge(vector<int>&a, int l, int mid, int r){\\n        vector<int> b(r-l+1);\\n        int i = l, j = mid + 1, k = 0;\\n        while(i<=mid and j<=r){\\n            if(a[i] <= a[j]) b[k] = a[i++];\\n            else b[k] = a[j++];\\n            k++;\\n        }\\n        while(i<=mid) b[k++] = a[i++];\\n        while(j<=r) b[k++] = a[j++];\\n        for(k=0,i=l;i<=r;k++,i++) a[i] = b[k];\\n    }\\n\\n\\n    void mergeSort(vector<int>& a, int l, int r){\\n        if(l>=r) return;\\n        int mid = (l + r) / 2;\\n        mergeSort(a, mid+1, r);\\n        mergeSort(a, l, mid);\\n        // Code block 1 start here.... //\\n        for(int i=l,j=mid+1;j<=r;j++){\\n            while(i<=mid and a[j] + d >= a[i]) i++;\\n            ans += (ll) i - l;\\n        }\\n        // Ends here ////////////////////\\n        merge(a,l,mid,r);\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        d = diff;\\n        int n = nums1.size();\\n        vector<int> v(n);\\n        for(int i=0;i<n;i++) v[i] = nums1[i] - nums2[i] - diff;\\n        mergeSort(v, 0, n-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\nprivate:\\n    int d;\\n    ll ans = 0;\\n    void merge(vector<int>&a, int l, int mid, int r){\\n        vector<int> b(r-l+1);\\n        int i = l, j = mid + 1, k = 0;\\n        while(i<=mid and j<=r){\\n            if(a[i] <= a[j]) b[k] = a[i++];\\n            else b[k] = a[j++];\\n            k++;\\n        }\\n        while(i<=mid) b[k++] = a[i++];\\n        while(j<=r) b[k++] = a[j++];\\n        for(k=0,i=l;i<=r;k++,i++) a[i] = b[k];\\n    }\\n\\n\\n    void mergeSort(vector<int>& a, int l, int r){\\n        if(l>=r) return;\\n        int mid = (l + r) / 2;\\n        mergeSort(a, mid+1, r);\\n        mergeSort(a, l, mid);\\n        // Code block 1 start here.... //\\n        for(int i=l,j=mid+1;j<=r;j++){\\n            while(i<=mid and a[j] + d >= a[i]) i++;\\n            ans += (ll) i - l;\\n        }\\n        // Ends here ////////////////////\\n        merge(a,l,mid,r);\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        d = diff;\\n        int n = nums1.size();\\n        vector<int> v(n);\\n        for(int i=0;i<n;i++) v[i] = nums1[i] - nums2[i] - diff;\\n        mergeSort(v, 0, n-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081579,
                "title": "c-merge-sort-like-technique-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    vector<int> A;\\n    int K;\\n    int64 ans;\\n\\n    void merge(int l, int r) {\\n        int mid = (l + r) / 2;\\n        int i = l;\\n        int j = mid + 1;\\n        int64 count = 0LL;\\n        while(i <= mid && j <= r) {\\n            if(A[i] <= A[j] + K) {\\n                count++;          // for {A[i], A[j]} is one pair\\n                i++;\\n            } else {\\n                ans += count;     // for A[j] count is found hence updating ans\\n                j++;\\n            }\\n        }\\n        while(j <= r) {\\n            ans += count;\\n            j++;\\n        }\\n        sort(A.begin() + l, A.begin() + r + 1);\\n    }\\n\\n    void mergeSort(int l, int r) {\\n        if(l >= r) {\\n            return;\\n        }\\n        int mid = (l + r) / 2;\\n        mergeSort(l, mid);\\n        mergeSort(mid + 1, r);\\n        merge(l, r);\\n    }\\n\\n    int64 numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        A = vector<int> (n);\\n        K = diff;\\n        ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            A[i] = nums1[i] - nums2[i];\\n        }\\n        mergeSort(0, n - 1);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n---------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    vector<int> A;\\n    int K;\\n    int64 ans;\\n\\n    void merge(int l, int r) {\\n        int mid = (l + r) / 2;\\n        int i = l;\\n        int j = mid + 1;\\n        int64 count = 0LL;\\n        while(i <= mid && j <= r) {\\n            if(A[i] <= A[j] + K) {\\n                count += (r - j + 1); // for A[i], {A[j...r]} all form possible pairs\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        sort(A.begin() + l, A.begin() + r + 1);\\n        ans += count;\\n    }\\n\\n    void mergeSort(int l, int r) {\\n        if(l >= r) {\\n            return;\\n        }\\n        int mid = (l + r) / 2;\\n        mergeSort(l, mid);\\n        mergeSort(mid + 1, r);\\n        merge(l, r);\\n    }\\n\\n    int64 numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        A = vector<int> (n);\\n        K = diff;\\n        ans = 0LL;\\n        for(int i = 0; i < n; i++) {\\n            A[i] = nums1[i] - nums2[i];\\n        }\\n        mergeSort(0, n - 1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    vector<int> A;\\n    int K;\\n    int64 ans;\\n\\n    void merge(int l, int r) {\\n        int mid = (l + r) / 2;\\n        int i = l;\\n        int j = mid + 1;\\n        int64 count = 0LL;\\n        while(i <= mid && j <= r) {\\n            if(A[i] <= A[j] + K) {\\n                count++;          // for {A[i], A[j]} is one pair\\n                i++;\\n            } else {\\n                ans += count;     // for A[j] count is found hence updating ans\\n                j++;\\n            }\\n        }\\n        while(j <= r) {\\n            ans += count;\\n            j++;\\n        }\\n        sort(A.begin() + l, A.begin() + r + 1);\\n    }\\n\\n    void mergeSort(int l, int r) {\\n        if(l >= r) {\\n            return;\\n        }\\n        int mid = (l + r) / 2;\\n        mergeSort(l, mid);\\n        mergeSort(mid + 1, r);\\n        merge(l, r);\\n    }\\n\\n    int64 numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        A = vector<int> (n);\\n        K = diff;\\n        ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            A[i] = nums1[i] - nums2[i];\\n        }\\n        mergeSort(0, n - 1);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n---------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    vector<int> A;\\n    int K;\\n    int64 ans;\\n\\n    void merge(int l, int r) {\\n        int mid = (l + r) / 2;\\n        int i = l;\\n        int j = mid + 1;\\n        int64 count = 0LL;\\n        while(i <= mid && j <= r) {\\n            if(A[i] <= A[j] + K) {\\n                count += (r - j + 1); // for A[i], {A[j...r]} all form possible pairs\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        sort(A.begin() + l, A.begin() + r + 1);\\n        ans += count;\\n    }\\n\\n    void mergeSort(int l, int r) {\\n        if(l >= r) {\\n            return;\\n        }\\n        int mid = (l + r) / 2;\\n        mergeSort(l, mid);\\n        mergeSort(mid + 1, r);\\n        merge(l, r);\\n    }\\n\\n    int64 numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        A = vector<int> (n);\\n        K = diff;\\n        ans = 0LL;\\n        for(int i = 0; i < n; i++) {\\n            A[i] = nums1[i] - nums2[i];\\n        }\\n        mergeSort(0, n - 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053258,
                "title": "segment-tree-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> nums(n, 0);\\n        for(int i=0;i<n;i++) {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n\\n        unordered_set<long long> set;\\n        for(auto& ele: nums) {\\n            set.insert(ele);\\n            set.insert(ele-diff);\\n            set.insert(ele+diff);\\n        }\\n        vector<long long> values(set.begin(), set.end());\\n        sort(values.begin(), values.end());\\n        unordered_map<int, int> map;\\n        for(int i=0;i<values.size();i++) {\\n            cout << values[i] <<\" \";\\n            map[values[i]] = i;\\n        }\\n\\n        int values_size = values.size();\\n        vector<long long> treenode(4*values.size()+1, 0);\\n\\n        long long res = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            int pos = map[nums[i]+diff];\\n            long long count = query(treenode, 1, 0, values.size()-1, 0, pos);\\n            res += count;\\n\\n            int insert_pos = map[nums[i]];\\n            update(treenode, 1, 0, values.size()-1, insert_pos, 1);\\n        }\\n\\n        return res;\\n    }\\n\\n\\n    void update(vector<long long>& treenode, int node, int start, int end, int index, int val) {\\n         if(start == end) {\\n             treenode[node] += val;\\n         }else {\\n             int mid = (start + end)/2;\\n             if(index<=mid) {\\n                 update(treenode, 2*node, start, mid, index, val);\\n             }else{\\n                 update(treenode, 2*node+1, mid+1, end, index, val);\\n             }\\n\\n\\n             treenode[node] = treenode[2*node] + treenode[2*node+1];\\n         }\\n    }\\n\\n\\n    long long query(vector<long long>& treenode, int node, int start, int end, int left, int right) {\\n        if(right < start || left > end) {\\n            return 0;\\n        }\\n\\n        if(left<=start && end <= right) {\\n            return treenode[node];\\n        }\\n\\n        int mid = (start+end)/2;\\n        int left_sum = query(treenode, 2*node, start, mid, left, right);\\n        int right_sum = query(treenode, 2*node+1, mid+1, end, left, right);\\n        return left_sum + right_sum;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> nums(n, 0);\\n        for(int i=0;i<n;i++) {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n\\n        unordered_set<long long> set;\\n        for(auto& ele: nums) {\\n            set.insert(ele);\\n            set.insert(ele-diff);\\n            set.insert(ele+diff);\\n        }\\n        vector<long long> values(set.begin(), set.end());\\n        sort(values.begin(), values.end());\\n        unordered_map<int, int> map;\\n        for(int i=0;i<values.size();i++) {\\n            cout << values[i] <<\" \";\\n            map[values[i]] = i;\\n        }\\n\\n        int values_size = values.size();\\n        vector<long long> treenode(4*values.size()+1, 0);\\n\\n        long long res = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            int pos = map[nums[i]+diff];\\n            long long count = query(treenode, 1, 0, values.size()-1, 0, pos);\\n            res += count;\\n\\n            int insert_pos = map[nums[i]];\\n            update(treenode, 1, 0, values.size()-1, insert_pos, 1);\\n        }\\n\\n        return res;\\n    }\\n\\n\\n    void update(vector<long long>& treenode, int node, int start, int end, int index, int val) {\\n         if(start == end) {\\n             treenode[node] += val;\\n         }else {\\n             int mid = (start + end)/2;\\n             if(index<=mid) {\\n                 update(treenode, 2*node, start, mid, index, val);\\n             }else{\\n                 update(treenode, 2*node+1, mid+1, end, index, val);\\n             }\\n\\n\\n             treenode[node] = treenode[2*node] + treenode[2*node+1];\\n         }\\n    }\\n\\n\\n    long long query(vector<long long>& treenode, int node, int start, int end, int left, int right) {\\n        if(right < start || left > end) {\\n            return 0;\\n        }\\n\\n        if(left<=start && end <= right) {\\n            return treenode[node];\\n        }\\n\\n        int mid = (start+end)/2;\\n        int left_sum = query(treenode, 2*node, start, mid, left, right);\\n        int right_sum = query(treenode, 2*node+1, mid+1, end, left, right);\\n        return left_sum + right_sum;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3052133,
                "title": "segment-tree-o-n-log-n",
                "content": "Idea: count numbers nums[i] that are <= nums[j] + diff and i < j\\nsump up the counts will give the answer\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> ST;\\n    int M;\\n\\n    void update(int i, int val = 1) {\\n        i += M;\\n        ST[i] += val;\\n\\n        while(i > 1) {\\n            i /= 2;\\n            ST[i] = ST[2*i] + ST[2*i+1];\\n        }\\n    }\\n\\n    int getSum(int l, int r) { // half open [l, r)\\n        int res = 0;\\n        for (l += M, r += M; l < r; l /= 2, r /= 2) {\\n            if (l % 2) {\\n                res += ST[l++];\\n            }\\n            if (r % 2) {\\n                res += ST[--r];\\n            }\\n        }\\n        return res;\\n    }\\n\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int N = nums1.size();\\n        for (int i = 0; i < N; i++) {\\n            nums1[i] -= nums2[i];\\n        }\\n\\n        auto nums = nums1;\\n        for (auto num : nums1) {\\n            nums.push_back(num + diff);\\n        }\\n        sort(nums.begin(), nums.end());\\n\\n        int rank = 0;\\n        unordered_map<int,int> ranks;\\n        for (auto num : nums) {\\n            if (!ranks.count(num)) {\\n                ranks[num] = rank++;\\n            }\\n        }\\n\\n        M = rank;\\n        ST.resize(2*M);\\n\\n        long res = 0;\\n        for (int i = 0; i < N; i++) {\\n            // count numbers so far that are <= nums1[i] + diff\\n            res += getSum(0, ranks[nums1[i] + diff]+1);\\n            update(ranks[nums1[i]]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> ST;\\n    int M;\\n\\n    void update(int i, int val = 1) {\\n        i += M;\\n        ST[i] += val;\\n\\n        while(i > 1) {\\n            i /= 2;\\n            ST[i] = ST[2*i] + ST[2*i+1];\\n        }\\n    }\\n\\n    int getSum(int l, int r) { // half open [l, r)\\n        int res = 0;\\n        for (l += M, r += M; l < r; l /= 2, r /= 2) {\\n            if (l % 2) {\\n                res += ST[l++];\\n            }\\n            if (r % 2) {\\n                res += ST[--r];\\n            }\\n        }\\n        return res;\\n    }\\n\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int N = nums1.size();\\n        for (int i = 0; i < N; i++) {\\n            nums1[i] -= nums2[i];\\n        }\\n\\n        auto nums = nums1;\\n        for (auto num : nums1) {\\n            nums.push_back(num + diff);\\n        }\\n        sort(nums.begin(), nums.end());\\n\\n        int rank = 0;\\n        unordered_map<int,int> ranks;\\n        for (auto num : nums) {\\n            if (!ranks.count(num)) {\\n                ranks[num] = rank++;\\n            }\\n        }\\n\\n        M = rank;\\n        ST.resize(2*M);\\n\\n        long res = 0;\\n        for (int i = 0; i < N; i++) {\\n            // count numbers so far that are <= nums1[i] + diff\\n            res += getSum(0, ranks[nums1[i] + diff]+1);\\n            update(ranks[nums1[i]]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049869,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n    O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long merge_sort(vector<int>& nums,int l,int r,int& diff){\\n        if(l==r) return 0;\\n        int mid = l + (r-l)/2;\\n        long long ans = 0;\\n        ans += merge_sort(nums,l,mid,diff);\\n        ans += merge_sort(nums,mid+1,r,diff);\\n        auto it = nums.begin();\\n        for(int i=mid+1;i<=r;i++){\\n            auto upper = upper_bound(it+l,it+mid+1,nums[i]+diff);\\n            ans += upper - (it+l);\\n        }\\n        sort(it+l,it+r+1);\\n        return ans;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> nums;\\n        for(int i=0;i<nums1.size();i++){\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n        return merge_sort(nums,0,nums.size()-1,diff);\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long merge_sort(vector<int>& nums,int l,int r,int& diff){\\n        if(l==r) return 0;\\n        int mid = l + (r-l)/2;\\n        long long ans = 0;\\n        ans += merge_sort(nums,l,mid,diff);\\n        ans += merge_sort(nums,mid+1,r,diff);\\n        auto it = nums.begin();\\n        for(int i=mid+1;i<=r;i++){\\n            auto upper = upper_bound(it+l,it+mid+1,nums[i]+diff);\\n            ans += upper - (it+l);\\n        }\\n        sort(it+l,it+r+1);\\n        return ans;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> nums;\\n        for(int i=0;i<nums1.size();i++){\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n        return merge_sort(nums,0,nums.size()-1,diff);\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043078,
                "title": "javascript-splay-tree-377ms-71-43",
                "content": "```\\n///////////////////////////////Template////////////////////////////////\\nclass Node {\\n    constructor(value) {\\n        this.parent_ = null;\\n        this.left_ = null;\\n        this.right_ = null;\\n        this.value_ = value;\\n        this.size_ = 1;\\n    }\\n    Update() {\\n        this.size_ = (this.left_ != null ? this.left_.size_ : 0) + (this.right_ != null ? this.right_.size_ : 0) + 1;\\n    }\\n    IsLeft() {\\n        return this.parent_ != null && this.parent_.left_ == this;\\n    }\\n    IsRight() {\\n        return this.parent_ != null && this.parent_.right_ == this;\\n    }\\n    IsRoot(guard = null) {\\n        return this.parent_ == guard;\\n    }\\n\\n}\\n\\nclass SplayTree {\\n    constructor() {\\n        this.root_ = null;\\n        this.cmp_ = (x, y) => x >= y ? 0 : 1;\\n    }\\n    Zig(x) {\\n        let y = x.parent_;\\n        if (x.right_ != null) x.right_.parent_ = y;\\n        y.left_ = x.right_;\\n        x.right_ = y;\\n        if (y.IsLeft()) {\\n            y.parent_.left_ = x;\\n        } else if (y.IsRight()) { // Special attention here for Link-Cut Trees.\\n            y.parent_.right_ = x;\\n        }\\n        x.parent_ = y.parent_;\\n        y.parent_ = x;\\n        y.Update();\\n        x.Update();\\n    }\\n\\n    // Zag:\\n    //   y                x\\n    //  / \\\\              / \\\\\\n    // A   x    --.    y   C\\n    //    / \\\\          / \\\\\\n    //   B   C        A   B        \\n    Zag(x) {\\n        let y = x.parent_;\\n        if (x.left_ != null) x.left_.parent_ = y;\\n        y.right_ = x.left_;\\n        x.left_ = y;\\n        if (y.IsLeft()) {\\n            y.parent_.left_ = x;\\n        } else if (y.IsRight()) { // Special attention here for Link-Cut Trees.\\n            y.parent_.right_ = x;\\n        }\\n        x.parent_ = y.parent_;\\n        y.parent_ = x;\\n        y.Update();\\n        x.Update();\\n    }\\n    ZigZig(x) {\\n        this.Zig(x.parent_);\\n        this.Zig(x);\\n    }\\n    ZigZag(x) {\\n        this.Zig(x);\\n        this.Zag(x);\\n    }\\n    ZagZag(x) {\\n        this.Zag(x.parent_);\\n        this.Zag(x);\\n    }\\n    ZagZig(x) {\\n        this.Zag(x);\\n        this.Zig(x);\\n    }\\n\\n    // Splay a \"node\" just under a \"guard\", which is default to splay to the \"root_\".\\n    Splay(node, guard = null) {\\n        while (!node.IsRoot(guard)) {\\n            if (node.parent_.IsRoot(guard)) {\\n                if (node.IsLeft()) {\\n                    this.Zig(node);\\n                } else {\\n                    this.Zag(node);\\n                }\\n            } else {\\n                if (node.parent_.IsLeft()) {\\n                    if (node.IsLeft()) {\\n                        this.ZigZig(node);\\n                    } else {\\n                        this.ZagZig(node);\\n                    }\\n                }\\n                else {\\n                    if (node.IsRight()) {\\n                        this.ZagZag(node);\\n                    } else {\\n                        this.ZigZag(node);\\n                    }\\n                }\\n            }\\n        }\\n        if (guard == null) this.root_ = node; // reset \"root_\" to \"node\".\\n    }\\n    LastNode(x) {\\n        this.Splay(x);\\n        let node = x.left_;\\n        if (node == null) return null;\\n        while (node.right_ != null) node = node.right_;\\n        this.Splay(node);\\n        return node;\\n    }\\n    NextNode(x) {\\n        this.Splay(x);\\n        let node = x.right_;\\n        if (node == null) return null;\\n        while (node.left_ != null) node = node.left_;\\n        this.Splay(node);\\n        return node;\\n    }\\n    Find(value) {\\n        return this.FindFirstOf(value);\\n    }\\n    FindFirstOf(value) {\\n        let node = this.root_, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp_(value, node.value_)) {\\n                node = node.left_;\\n            } else if (this.cmp_(node.value_, value)) {\\n                node = node.right_;\\n            } else {\\n                res = node;\\n                node = node.left_;\\n            }\\n        }\\n        if (last_visited != null) this.Splay(last_visited);\\n        return res;\\n    }\\n    FindLastOf(value) {\\n        let node = this.root_, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp_(value, node.value_)) {\\n                node = node.left_;\\n            } else if (this.cmp_(node.value_, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.right_;\\n            }\\n        }\\n        if (last_visited != null) this.Splay(last_visited);\\n        return res;\\n    }\\n    FindRankOf(node) {\\n        this.Splay(node);\\n        return node.left_ == null ? 0 : node.left_.size_;\\n    }\\n    FindSuccessorOf(value) {\\n        let node = this.root_, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp_(value, node.value_)) {\\n                res = node;\\n                node = node.left_;\\n            } else {\\n                node = node.right_;\\n            }\\n        }\\n        if (last_visited != null) this.Splay(last_visited);\\n        return res;\\n    }\\n    FindPrecursorOf(value) {\\n        let node = this.root_, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp_(node.value_, value)) {\\n                res = node;\\n                node = node.right_;\\n            } else {\\n                node = node.left_;\\n            }\\n        }\\n        if (last_visited != null) this.Splay(last_visited);\\n        return res;\\n    }\\n    FindKth(rank) {\\n        if (rank < 0 || rank >= this.Size()) return null;\\n        let node = this.root_;\\n        while (node != null) {\\n            let left_size = node.left_ == null ? 0 : node.left_.size_;\\n            if (left_size == rank) break;\\n            if (left_size > rank) {\\n                node = node.left_;\\n            } else {\\n                rank -= left_size + 1;\\n                node = node.right_;\\n            }\\n        }\\n        this.Splay(node);\\n        return node;\\n    }\\n    NewNode(value) {\\n        return new Node(value);\\n    }\\n    DeleteNode(node) {\\n        node = null;\\n    }\\n\\n    // -------------------------------- Public Usage --------------------------------------\\n    Size() {\\n        return this.root_ == null ? 0 : this.root_.size_;\\n    }\\n    IsEmpty() {\\n        return this.root_ == null;\\n    }\\n\\n    // Insert an element into the container O(log(n))\\n    Insert(value) {\\n        if (this.root_ == null) {\\n            this.root_ = this.NewNode(value);\\n            return this.root_;\\n        }\\n        let node = this.root_;\\n        while (node != null) {\\n            if (this.cmp_(value, node.value_)) {\\n                if (node.left_ == null) {\\n                    node.left_ = this.NewNode(value);\\n                    node.left_.parent_ = node;\\n                    node = node.left_;\\n                    break;\\n                }\\n                node = node.left_;\\n            } else {\\n                if (node.right_ == null) {\\n                    node.right_ = this.NewNode(value);\\n                    node.right_.parent_ = node;\\n                    node = node.right_;\\n                    break;\\n                }\\n                node = node.right_;\\n            }\\n        }\\n        this.Splay(node);\\n        return node;\\n    }\\n\\n    // Delete an element from the container if it exists O(log n)\\n    Delete(value) {\\n        let node = this.Find(value);\\n        if (node == null) return false;\\n        this.Splay(node);\\n        if (node.left_ == null) {\\n            this.root_ = node.right_;\\n            if (node.right_ != null) node.right_.parent_ = null;\\n            this.DeleteNode(node);\\n            return true;\\n        }\\n        if (node.right_ == null) {\\n            this.root_ = node.left_;\\n            if (node.left_ != null) node.left_.parent_ = null;\\n            this.DeleteNode(node);\\n            return true;\\n        }\\n        let last_node = this.LastNode(node);\\n        let next_node = this.NextNode(node);\\n        this.Splay(last_node);\\n        this.Splay(next_node, last_node);\\n        // After the above operations, the tree becomes:\\n        //      last_node\\n        //     /         \\\\\\n        //    A       next_node\\n        //           /         \\\\\\n        //         node         B\\n        // Then \"next_node.left_\" is \"node\".\\n        this.DeleteNode(next_node.left_);\\n        next_node.left_ = null;\\n        next_node.Update();\\n        last_node.Update();\\n        return true;\\n    }\\n\\n    // Whether the splay tree contains value O(log n).\\n    Contains(value) {\\n        return this.CountOf(value) > 0;\\n    }\\n\\n    // The number of ocurrences of value O(log n)\\n    CountOf(value) {\\n        let x = this.FindFirstOf(value);\\n        if (x == null) return 0;\\n        let rank_x = this.FindRankOf(x);\\n        let y = this.FindLastOf(value);\\n        let rank_y = this.FindRankOf(y);\\n        return rank_y - rank_x + 1;\\n    }\\n\\n    // The number of elements strictly less than value O(log n)\\n    RankOf(value) {\\n        let x = this.FindPrecursorOf(value);\\n        return x == null ? 0 : this.FindRankOf(x) + 1;\\n    }\\n\\n    // Get the k-th element (0-indexed) O(log n).\\n    Kth(rank) {\\n        let x = this.FindKth(rank);\\n        return x == null ? null : (x.value_);\\n    }\\n\\n    // Find the smallest element that is strictly greater than value > , if it exists O(log n).\\n    SuccessorOf(value) {\\n        let node = this.FindSuccessorOf(value);\\n        return node == null ? null : (node.value_);\\n    }\\n\\n    // Find the largest element that is strictly less than value < , if it exists O(log n).\\n    PrecursorOf(value) {\\n        let node = this.FindPrecursorOf(value);\\n        return node == null ? null : (node.value_);\\n    }\\n\\n    // Get sorted values in the splay tree O(n).\\n    GetValues() {\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left_);\\n            res.push(x.value_);\\n            dfs(x.right_);\\n        };\\n        dfs(this.root_);\\n        return res;\\n    }\\n}\\n///////////////////////////////////////////////////////////////\\n\\nconst numberOfPairs = (a, b, diff) => {\\n    let tree = new SplayTree(), n = a.length, res = 0;\\n    let d = [];\\n    for(let i = 0; i < n; i++) d.push(a[i]-b[i]);\\n    for (let i = 0; i < n; i++) {\\n        let x = d[i], y = x + diff;\\n        res += tree.RankOf(y + 1);\\n        tree.Insert(x);\\n    }\\n    return res;\\n};\\n```\\nFenwick tree solution: \\nhttps://leetcode.com/problems/number-of-pairs-satisfying-inequality/solutions/3042905/javascript-fenwick-tree-bit-145ms/\\n\\nmultiset solution:\\nhttps://leetcode.com/problems/number-of-pairs-satisfying-inequality/solutions/3042851/javascript-multisetsortedlist-515ms/",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n///////////////////////////////Template////////////////////////////////\\nclass Node {\\n    constructor(value) {\\n        this.parent_ = null;\\n        this.left_ = null;\\n        this.right_ = null;\\n        this.value_ = value;\\n        this.size_ = 1;\\n    }\\n    Update() {\\n        this.size_ = (this.left_ != null ? this.left_.size_ : 0) + (this.right_ != null ? this.right_.size_ : 0) + 1;\\n    }\\n    IsLeft() {\\n        return this.parent_ != null && this.parent_.left_ == this;\\n    }\\n    IsRight() {\\n        return this.parent_ != null && this.parent_.right_ == this;\\n    }\\n    IsRoot(guard = null) {\\n        return this.parent_ == guard;\\n    }\\n\\n}\\n\\nclass SplayTree {\\n    constructor() {\\n        this.root_ = null;\\n        this.cmp_ = (x, y) => x >= y ? 0 : 1;\\n    }\\n    Zig(x) {\\n        let y = x.parent_;\\n        if (x.right_ != null) x.right_.parent_ = y;\\n        y.left_ = x.right_;\\n        x.right_ = y;\\n        if (y.IsLeft()) {\\n            y.parent_.left_ = x;\\n        } else if (y.IsRight()) { // Special attention here for Link-Cut Trees.\\n            y.parent_.right_ = x;\\n        }\\n        x.parent_ = y.parent_;\\n        y.parent_ = x;\\n        y.Update();\\n        x.Update();\\n    }\\n\\n    // Zag:\\n    //   y                x\\n    //  / \\\\              / \\\\\\n    // A   x    --.    y   C\\n    //    / \\\\          / \\\\\\n    //   B   C        A   B        \\n    Zag(x) {\\n        let y = x.parent_;\\n        if (x.left_ != null) x.left_.parent_ = y;\\n        y.right_ = x.left_;\\n        x.left_ = y;\\n        if (y.IsLeft()) {\\n            y.parent_.left_ = x;\\n        } else if (y.IsRight()) { // Special attention here for Link-Cut Trees.\\n            y.parent_.right_ = x;\\n        }\\n        x.parent_ = y.parent_;\\n        y.parent_ = x;\\n        y.Update();\\n        x.Update();\\n    }\\n    ZigZig(x) {\\n        this.Zig(x.parent_);\\n        this.Zig(x);\\n    }\\n    ZigZag(x) {\\n        this.Zig(x);\\n        this.Zag(x);\\n    }\\n    ZagZag(x) {\\n        this.Zag(x.parent_);\\n        this.Zag(x);\\n    }\\n    ZagZig(x) {\\n        this.Zag(x);\\n        this.Zig(x);\\n    }\\n\\n    // Splay a \"node\" just under a \"guard\", which is default to splay to the \"root_\".\\n    Splay(node, guard = null) {\\n        while (!node.IsRoot(guard)) {\\n            if (node.parent_.IsRoot(guard)) {\\n                if (node.IsLeft()) {\\n                    this.Zig(node);\\n                } else {\\n                    this.Zag(node);\\n                }\\n            } else {\\n                if (node.parent_.IsLeft()) {\\n                    if (node.IsLeft()) {\\n                        this.ZigZig(node);\\n                    } else {\\n                        this.ZagZig(node);\\n                    }\\n                }\\n                else {\\n                    if (node.IsRight()) {\\n                        this.ZagZag(node);\\n                    } else {\\n                        this.ZigZag(node);\\n                    }\\n                }\\n            }\\n        }\\n        if (guard == null) this.root_ = node; // reset \"root_\" to \"node\".\\n    }\\n    LastNode(x) {\\n        this.Splay(x);\\n        let node = x.left_;\\n        if (node == null) return null;\\n        while (node.right_ != null) node = node.right_;\\n        this.Splay(node);\\n        return node;\\n    }\\n    NextNode(x) {\\n        this.Splay(x);\\n        let node = x.right_;\\n        if (node == null) return null;\\n        while (node.left_ != null) node = node.left_;\\n        this.Splay(node);\\n        return node;\\n    }\\n    Find(value) {\\n        return this.FindFirstOf(value);\\n    }\\n    FindFirstOf(value) {\\n        let node = this.root_, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp_(value, node.value_)) {\\n                node = node.left_;\\n            } else if (this.cmp_(node.value_, value)) {\\n                node = node.right_;\\n            } else {\\n                res = node;\\n                node = node.left_;\\n            }\\n        }\\n        if (last_visited != null) this.Splay(last_visited);\\n        return res;\\n    }\\n    FindLastOf(value) {\\n        let node = this.root_, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp_(value, node.value_)) {\\n                node = node.left_;\\n            } else if (this.cmp_(node.value_, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.right_;\\n            }\\n        }\\n        if (last_visited != null) this.Splay(last_visited);\\n        return res;\\n    }\\n    FindRankOf(node) {\\n        this.Splay(node);\\n        return node.left_ == null ? 0 : node.left_.size_;\\n    }\\n    FindSuccessorOf(value) {\\n        let node = this.root_, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp_(value, node.value_)) {\\n                res = node;\\n                node = node.left_;\\n            } else {\\n                node = node.right_;\\n            }\\n        }\\n        if (last_visited != null) this.Splay(last_visited);\\n        return res;\\n    }\\n    FindPrecursorOf(value) {\\n        let node = this.root_, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp_(node.value_, value)) {\\n                res = node;\\n                node = node.right_;\\n            } else {\\n                node = node.left_;\\n            }\\n        }\\n        if (last_visited != null) this.Splay(last_visited);\\n        return res;\\n    }\\n    FindKth(rank) {\\n        if (rank < 0 || rank >= this.Size()) return null;\\n        let node = this.root_;\\n        while (node != null) {\\n            let left_size = node.left_ == null ? 0 : node.left_.size_;\\n            if (left_size == rank) break;\\n            if (left_size > rank) {\\n                node = node.left_;\\n            } else {\\n                rank -= left_size + 1;\\n                node = node.right_;\\n            }\\n        }\\n        this.Splay(node);\\n        return node;\\n    }\\n    NewNode(value) {\\n        return new Node(value);\\n    }\\n    DeleteNode(node) {\\n        node = null;\\n    }\\n\\n    // -------------------------------- Public Usage --------------------------------------\\n    Size() {\\n        return this.root_ == null ? 0 : this.root_.size_;\\n    }\\n    IsEmpty() {\\n        return this.root_ == null;\\n    }\\n\\n    // Insert an element into the container O(log(n))\\n    Insert(value) {\\n        if (this.root_ == null) {\\n            this.root_ = this.NewNode(value);\\n            return this.root_;\\n        }\\n        let node = this.root_;\\n        while (node != null) {\\n            if (this.cmp_(value, node.value_)) {\\n                if (node.left_ == null) {\\n                    node.left_ = this.NewNode(value);\\n                    node.left_.parent_ = node;\\n                    node = node.left_;\\n                    break;\\n                }\\n                node = node.left_;\\n            } else {\\n                if (node.right_ == null) {\\n                    node.right_ = this.NewNode(value);\\n                    node.right_.parent_ = node;\\n                    node = node.right_;\\n                    break;\\n                }\\n                node = node.right_;\\n            }\\n        }\\n        this.Splay(node);\\n        return node;\\n    }\\n\\n    // Delete an element from the container if it exists O(log n)\\n    Delete(value) {\\n        let node = this.Find(value);\\n        if (node == null) return false;\\n        this.Splay(node);\\n        if (node.left_ == null) {\\n            this.root_ = node.right_;\\n            if (node.right_ != null) node.right_.parent_ = null;\\n            this.DeleteNode(node);\\n            return true;\\n        }\\n        if (node.right_ == null) {\\n            this.root_ = node.left_;\\n            if (node.left_ != null) node.left_.parent_ = null;\\n            this.DeleteNode(node);\\n            return true;\\n        }\\n        let last_node = this.LastNode(node);\\n        let next_node = this.NextNode(node);\\n        this.Splay(last_node);\\n        this.Splay(next_node, last_node);\\n        // After the above operations, the tree becomes:\\n        //      last_node\\n        //     /         \\\\\\n        //    A       next_node\\n        //           /         \\\\\\n        //         node         B\\n        // Then \"next_node.left_\" is \"node\".\\n        this.DeleteNode(next_node.left_);\\n        next_node.left_ = null;\\n        next_node.Update();\\n        last_node.Update();\\n        return true;\\n    }\\n\\n    // Whether the splay tree contains value O(log n).\\n    Contains(value) {\\n        return this.CountOf(value) > 0;\\n    }\\n\\n    // The number of ocurrences of value O(log n)\\n    CountOf(value) {\\n        let x = this.FindFirstOf(value);\\n        if (x == null) return 0;\\n        let rank_x = this.FindRankOf(x);\\n        let y = this.FindLastOf(value);\\n        let rank_y = this.FindRankOf(y);\\n        return rank_y - rank_x + 1;\\n    }\\n\\n    // The number of elements strictly less than value O(log n)\\n    RankOf(value) {\\n        let x = this.FindPrecursorOf(value);\\n        return x == null ? 0 : this.FindRankOf(x) + 1;\\n    }\\n\\n    // Get the k-th element (0-indexed) O(log n).\\n    Kth(rank) {\\n        let x = this.FindKth(rank);\\n        return x == null ? null : (x.value_);\\n    }\\n\\n    // Find the smallest element that is strictly greater than value > , if it exists O(log n).\\n    SuccessorOf(value) {\\n        let node = this.FindSuccessorOf(value);\\n        return node == null ? null : (node.value_);\\n    }\\n\\n    // Find the largest element that is strictly less than value < , if it exists O(log n).\\n    PrecursorOf(value) {\\n        let node = this.FindPrecursorOf(value);\\n        return node == null ? null : (node.value_);\\n    }\\n\\n    // Get sorted values in the splay tree O(n).\\n    GetValues() {\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left_);\\n            res.push(x.value_);\\n            dfs(x.right_);\\n        };\\n        dfs(this.root_);\\n        return res;\\n    }\\n}\\n///////////////////////////////////////////////////////////////\\n\\nconst numberOfPairs = (a, b, diff) => {\\n    let tree = new SplayTree(), n = a.length, res = 0;\\n    let d = [];\\n    for(let i = 0; i < n; i++) d.push(a[i]-b[i]);\\n    for (let i = 0; i < n; i++) {\\n        let x = d[i], y = x + diff;\\n        res += tree.RankOf(y + 1);\\n        tree.Insert(x);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042905,
                "title": "javascript-fenwick-tree-bit-145ms",
                "content": "```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst numberOfPairs = (a, b, diff) => {\\n    let n = a.length, res = 0, st = new Fenwick(1e5), offset = 1e5 / 2;\\n    for (let i = 0; i < n; i++) {\\n        let x = a[i] - b[i], y = x + diff;\\n        res += st.rangeSum(0, y + offset);\\n        st.update(x + offset, 1)\\n    }\\n    return res;\\n};\\n```\\nsolution 2: use multiset\\nhttps://leetcode.com/problems/number-of-pairs-satisfying-inequality/solutions/3042851/javascript-multiset-sortedlist-515ms/\\nsolution 3: use splay tree:\\nhttps://leetcode.com/problems/number-of-pairs-satisfying-inequality/solutions/3043078/javascript-splay-tree-377ms-71-43/",
                "solutionTags": [
                    "JavaScript",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst numberOfPairs = (a, b, diff) => {\\n    let n = a.length, res = 0, st = new Fenwick(1e5), offset = 1e5 / 2;\\n    for (let i = 0; i < n; i++) {\\n        let x = a[i] - b[i], y = x + diff;\\n        res += st.rangeSum(0, y + offset);\\n        st.update(x + offset, 1)\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042851,
                "title": "javascript-multiset-sortedlist-515ms",
                "content": "reference: https://leetcode.com/problems/number-of-pairs-satisfying-inequality/solutions/2646606/python-reverse-pairs/\\n```\\n/////////////////////////// Template ///////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction MultiSet(elements) {\\n    let a = [], m = new Map(), bi = new Bisect();\\n    initialize();\\n    return { insert, first, last, get, search, poll, pollLast, lower_bound, upper_bound, findKth, eraseByIndex, eraseAll, contains, size, clear, show };\\n    function initialize() {\\n        if (elements) {\\n            for (const x of elements) {\\n                bi.insort_right(a, x);\\n                m.set(x, m.get(x) + 1 || 1);\\n            }\\n        }\\n    }\\n    function insert(x) {\\n        bi.insort_right(a, x);\\n        m.set(x, m.get(x) + 1 || 1);\\n    }\\n    function first() {\\n        return a[0];\\n    }\\n    function last() {\\n        return a[a.length - 1];\\n    }\\n    function get(i) {\\n        return a[i];\\n    }\\n    function poll() {\\n        let res = a[0];\\n        a.splice(0, 1);\\n        removeOneOrManyMap(m, res);\\n        return res;\\n    }\\n    function pollLast() {\\n        let res = a.pop();\\n        removeOneOrManyMap(m, res);\\n        return res;\\n    }\\n    function lower_bound(x) {\\n        return bi.bisect_left(a, x);\\n    }\\n    function upper_bound(x) {\\n        return bi.bisect_right(a, x);\\n    }\\n    function findKth(k) {\\n        return a[k - 1];\\n    }\\n    function search(x) {\\n        return lower_bound(x);\\n    }\\n    function eraseByIndex(idx) {\\n        removeOneOrManyMap(m, a[idx]);\\n        a.splice(idx, 1);\\n    }\\n    function eraseAll(x) {\\n        if (contains(x)) {\\n            let idx = search(x), occ = m.get(x);\\n            while (occ--) a.splice(idx, 1);\\n            m.delete(x);\\n        }\\n    }\\n    function removeOneOrManyMap(m, x, cnt = 1) {\\n        let occ = m.get(x);\\n        occ > cnt ? m.set(x, occ - cnt) : m.delete(x);\\n    }\\n    function contains(x) {\\n        return m.has(x);\\n    }\\n    function size() {\\n        return a.length;\\n    }\\n    function clear() {\\n        a = [];\\n        m.clear();\\n    }\\n    function show() {\\n        return a;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////\\n\\nconst numberOfPairs = (a, b, diff) => {\\n    let s = new MultiSet(), n = a.length, res = 0;\\n    for (let i = 0; i < n; i++) {\\n        let v = a[i] - b[i] + diff, idx = s.upper_bound(v);\\n        res += idx;\\n        s.insert(a[i] - b[i]);\\n    }\\n    return res;\\n};\\n```\\nFenwick tree solution: https://leetcode.com/problems/number-of-pairs-satisfying-inequality/solutions/3042905/javascript-fenwick-tree-bit-145ms/\\nSplay tree solution: https://leetcode.com/problems/number-of-pairs-satisfying-inequality/solutions/3043078/javascript-splay-tree-377ms-71-43/",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\n/////////////////////////// Template ///////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction MultiSet(elements) {\\n    let a = [], m = new Map(), bi = new Bisect();\\n    initialize();\\n    return { insert, first, last, get, search, poll, pollLast, lower_bound, upper_bound, findKth, eraseByIndex, eraseAll, contains, size, clear, show };\\n    function initialize() {\\n        if (elements) {\\n            for (const x of elements) {\\n                bi.insort_right(a, x);\\n                m.set(x, m.get(x) + 1 || 1);\\n            }\\n        }\\n    }\\n    function insert(x) {\\n        bi.insort_right(a, x);\\n        m.set(x, m.get(x) + 1 || 1);\\n    }\\n    function first() {\\n        return a[0];\\n    }\\n    function last() {\\n        return a[a.length - 1];\\n    }\\n    function get(i) {\\n        return a[i];\\n    }\\n    function poll() {\\n        let res = a[0];\\n        a.splice(0, 1);\\n        removeOneOrManyMap(m, res);\\n        return res;\\n    }\\n    function pollLast() {\\n        let res = a.pop();\\n        removeOneOrManyMap(m, res);\\n        return res;\\n    }\\n    function lower_bound(x) {\\n        return bi.bisect_left(a, x);\\n    }\\n    function upper_bound(x) {\\n        return bi.bisect_right(a, x);\\n    }\\n    function findKth(k) {\\n        return a[k - 1];\\n    }\\n    function search(x) {\\n        return lower_bound(x);\\n    }\\n    function eraseByIndex(idx) {\\n        removeOneOrManyMap(m, a[idx]);\\n        a.splice(idx, 1);\\n    }\\n    function eraseAll(x) {\\n        if (contains(x)) {\\n            let idx = search(x), occ = m.get(x);\\n            while (occ--) a.splice(idx, 1);\\n            m.delete(x);\\n        }\\n    }\\n    function removeOneOrManyMap(m, x, cnt = 1) {\\n        let occ = m.get(x);\\n        occ > cnt ? m.set(x, occ - cnt) : m.delete(x);\\n    }\\n    function contains(x) {\\n        return m.has(x);\\n    }\\n    function size() {\\n        return a.length;\\n    }\\n    function clear() {\\n        a = [];\\n        m.clear();\\n    }\\n    function show() {\\n        return a;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////\\n\\nconst numberOfPairs = (a, b, diff) => {\\n    let s = new MultiSet(), n = a.length, res = 0;\\n    for (let i = 0; i < n; i++) {\\n        let v = a[i] - b[i] + diff, idx = s.upper_bound(v);\\n        res += idx;\\n        s.insert(a[i] - b[i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3030009,
                "title": "c-good-code-quality-merge-sort-technique-easy-explanation-with-code",
                "content": "**Explanation:**\\nThis question is very similar to SDE sheet or Leetcode 493 Reverse Pairs (https://leetcode.com/problems/reverse-pairs/)  question.\\nThe problem statement says that we need two indices i,j such that 0<i<j<n-1 i.e i<j and should be in range.\\nSo for getting guaranteed i<j we need to use Merge and Sort technique in which we divide and sort the array\\ninto halves but we can intercept in middle of sorting and can count the pairs which satisfies the inequality.\\n\\n**Approach:**\\nAs we learnt in linear inequality in maths we can write an equation by reordering the elements from left \\nto right side or vice-versa.\\nSo lets look at the equation\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\nwe can also write the above equation as\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n\\nAs we can observe we need the subtractions of i and j pairs and compare them.\\nSo now it reduces to Reverse Pairs question (https://leetcode.com/problems/reverse-pairs/) \\nLet a[i] = nums1[i]-nums2[i]\\nthen a[j] = nums1[j]-nums2[j]\\n\\nSo equation will be\\na[i] <= a[j] + diff (i<j)\\n\\n**Algorithm:**\\nPrepare a seperate array and store differences a[i] for each index i from 0 to n-1.\\nApply recursive mergeSort technique dividing the subarrays into halves.\\nBefore merging count the pairs in those two halves, Take i from 1st halve and j from another halve (i<j).\\nCount the pairs satisfy the conditions.\\nFinally sort the halves and merge them.\\nReturn the count of pairs.\\n\\n```\\nclass Solution {\\npublic:\\n    long long merge(int low,int mid,int high,vector<int>& nums,int& diff){\\n        long long count=0;\\n        int l=low,r=mid+1;\\n        while(l<=mid && r<=high){\\n            if(nums[l]<=nums[r]+diff){\\n                count+=(high-r+1);\\n                l++;\\n            }else{\\n                r++;\\n            }\\n        }\\n        sort(nums.begin()+low,nums.begin()+high+1);\\n        return count;\\n    }\\n\\n    long long mergeSort(int low,int high,vector<int>& nums,int& diff){\\n        if(low>=high) return 0;\\n        long long pairs=0;\\n        int mid = (low+high)/2;\\n        pairs+=mergeSort(low,mid,nums,diff);\\n        pairs+=mergeSort(mid+1,high,nums,diff);\\n        pairs+=merge(low,mid,high,nums,diff);\\n        return pairs;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;++i){\\n            nums[i] = nums1[i]-nums2[i];\\n        }\\n        return mergeSort(0,n-1,nums,diff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long merge(int low,int mid,int high,vector<int>& nums,int& diff){\\n        long long count=0;\\n        int l=low,r=mid+1;\\n        while(l<=mid && r<=high){\\n            if(nums[l]<=nums[r]+diff){\\n                count+=(high-r+1);\\n                l++;\\n            }else{\\n                r++;\\n            }\\n        }\\n        sort(nums.begin()+low,nums.begin()+high+1);\\n        return count;\\n    }\\n\\n    long long mergeSort(int low,int high,vector<int>& nums,int& diff){\\n        if(low>=high) return 0;\\n        long long pairs=0;\\n        int mid = (low+high)/2;\\n        pairs+=mergeSort(low,mid,nums,diff);\\n        pairs+=mergeSort(mid+1,high,nums,diff);\\n        pairs+=merge(low,mid,high,nums,diff);\\n        return pairs;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;++i){\\n            nums[i] = nums1[i]-nums2[i];\\n        }\\n        return mergeSort(0,n-1,nums,diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017588,
                "title": "number-of-pairs-satisfying-inequality",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we have given two arrays of integers nums1 and nums2 of size n and an integer named diff.\\nNow from both the given arrays we need to find common pairs of indexes(i,j) such that \\n1. Index i must be less than j where i can be any index starting from 0- less than j AND j can be any index greater than j and must be less than n i.e. no. of elements in the array.\\n2. Pairs of indexes(i,j) must satisfy the relation:\\n   nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all we will do some change in the relation, i.e. we will bring i indexes of both arrays together in the left hand side and same with the j indexes, i.e. separated both i and j indexes, our relations becomes:\\nnums1[i]-nums2[i]-nums1[j]-nums2[j]<=diff\\nor nums[i]-nums[j]<=diff  <------> HAVE TO SOLVE FOR THIS EQUATION NOW\\nwhere i<j\\n1. Here order matters so we cannot directly sort the array.\\n2. So we will use divide and conquer and will divide the array into smaller pieces assuming for each part what would have been the answer if this is the only array, then we will find out how many indexes would satisfy the inequality in the particular array.\\n3. Suppose we know the answer for both divided arrays now our job is to merge the answer efficiently so that the order will be less than O(n^2).\\n4. In order to do that we will mark one divided part for i and another for j and then we will slightly change the inequality as:\\nnums[i]<=nums[j]+diff and then as both i and j belong to different arrays so we can sort.\\n5. So what we will do, we will check the inequality by checking for differnt values of i in the relation by putting 1 value of j at a time for all trials of i.\\n6. Similarly checking for different values of i by putting another value of j same for all next trials.\\n7. Then we will get no. of indexes possible.\\n8. Single element array would not contain any pair so will not consider them and so their contribution would be 0.\\n\\n# Code\\n```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    ll ValidPairs (int l, int r, vector<ll>& nums, const ll diff) {\\n        if (l == r) return 0;\\n        \\n        int m = (l+r) >> 1;\\n        ll result = ValidPairs (l, m, nums, diff) + ValidPairs (m+1, r, nums, diff);\\n        \\n        int l1 = l, r1 = m, l2 = m+1, r2 = r;\\n        vector<ll> merged;\\n        \\n        for (int j = l2; j <= r2; j ++) {\\n            // x <= y+d\\n            ll mx_allowed = nums[j] + diff;\\n            \\n            int ind = upper_bound (nums.begin()+l1, nums.begin()+r1+1, mx_allowed) - nums.begin() - 1;\\n            if (ind <= r1) result += (ind - l1 + 1);\\n        }\\n        \\n        while (l1 <= r1 && l2 <= r2) {            \\n            if (nums[l1] <= nums[l2]) \\n                merged.push_back(nums[l1 ++]);\\n            else \\n                merged.push_back(nums[l2 ++]);\\n        }\\n        while (l2 <= r2) merged.push_back(nums[l2 ++]);\\n        while (l1 <= r1) merged.push_back(nums[l1 ++]);\\n        \\n        for (int j = l; j <= r; j ++) nums[j] = merged[j - l];\\n        return result;\\n    }\\n    \\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<ll> nums(n);\\n        for (int j = 0; j < n; j ++) nums[j] = nums1[j] - nums2[j];\\n        \\n        return ValidPairs (0, n-1, nums, diff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    ll ValidPairs (int l, int r, vector<ll>& nums, const ll diff) {\\n        if (l == r) return 0;\\n        \\n        int m = (l+r) >> 1;\\n        ll result = ValidPairs (l, m, nums, diff) + ValidPairs (m+1, r, nums, diff);\\n        \\n        int l1 = l, r1 = m, l2 = m+1, r2 = r;\\n        vector<ll> merged;\\n        \\n        for (int j = l2; j <= r2; j ++) {\\n            // x <= y+d\\n            ll mx_allowed = nums[j] + diff;\\n            \\n            int ind = upper_bound (nums.begin()+l1, nums.begin()+r1+1, mx_allowed) - nums.begin() - 1;\\n            if (ind <= r1) result += (ind - l1 + 1);\\n        }\\n        \\n        while (l1 <= r1 && l2 <= r2) {            \\n            if (nums[l1] <= nums[l2]) \\n                merged.push_back(nums[l1 ++]);\\n            else \\n                merged.push_back(nums[l2 ++]);\\n        }\\n        while (l2 <= r2) merged.push_back(nums[l2 ++]);\\n        while (l1 <= r1) merged.push_back(nums[l1 ++]);\\n        \\n        for (int j = l; j <= r; j ++) nums[j] = merged[j - l];\\n        return result;\\n    }\\n    \\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<ll> nums(n);\\n        for (int j = 0; j < n; j ++) nums[j] = nums1[j] - nums2[j];\\n        \\n        return ValidPairs (0, n-1, nums, diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010194,
                "title": "using-segment-tree-relatively-faster-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> nums(n);\\n        int mn = INT_MAX;\\n        for(int x = 0; x < n; x++){\\n            nums[x] = nums1[x] - nums2[x];\\n            mn = min(mn, nums[x] + diff);\\n            mn = min(mn, nums[x]);\\n        }\\n        int offset = max(1, -mn + 1), mx = INT_MIN;\\n        for(auto x: nums){\\n            mx = max(mx, offset + x + diff + 5);\\n        }\\n        vector<long long> seg(2 * mx, 0);\\n        auto update = [&](int pos, int val) -> void {\\n            pos += mx;\\n            seg[pos]++;\\n            while(pos > 0){\\n                int left = pos, right = pos;\\n                if(pos % 2 == 0){\\n                    right = pos + 1;\\n                }else{\\n                    left = pos - 1;\\n                }\\n                seg[pos / 2] = seg[left] + seg[right];\\n                pos /= 2;\\n            }\\n        };\\n\\n        auto query = [&](int l, int r) -> int {\\n            int res = 0;\\n            for (l += mx, r += mx; l <= r; l >>= 1, r >>= 1) {\\n                if (l & 1) {\\n                    res += seg[l++];\\n                }\\n                if (!(r & 1)) {\\n                    res += seg[r--];\\n                }\\n            }\\n            return res;\\n        };\\n\\n        long long res = 0;\\n        for(int x = n - 1; x >= 0; x--){\\n            res += query(nums[x] + offset, mx - 2);\\n            update(nums[x] + diff + offset, 1);\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> nums(n);\\n        int mn = INT_MAX;\\n        for(int x = 0; x < n; x++){\\n            nums[x] = nums1[x] - nums2[x];\\n            mn = min(mn, nums[x] + diff);\\n            mn = min(mn, nums[x]);\\n        }\\n        int offset = max(1, -mn + 1), mx = INT_MIN;\\n        for(auto x: nums){\\n            mx = max(mx, offset + x + diff + 5);\\n        }\\n        vector<long long> seg(2 * mx, 0);\\n        auto update = [&](int pos, int val) -> void {\\n            pos += mx;\\n            seg[pos]++;\\n            while(pos > 0){\\n                int left = pos, right = pos;\\n                if(pos % 2 == 0){\\n                    right = pos + 1;\\n                }else{\\n                    left = pos - 1;\\n                }\\n                seg[pos / 2] = seg[left] + seg[right];\\n                pos /= 2;\\n            }\\n        };\\n\\n        auto query = [&](int l, int r) -> int {\\n            int res = 0;\\n            for (l += mx, r += mx; l <= r; l >>= 1, r >>= 1) {\\n                if (l & 1) {\\n                    res += seg[l++];\\n                }\\n                if (!(r & 1)) {\\n                    res += seg[r--];\\n                }\\n            }\\n            return res;\\n        };\\n\\n        long long res = 0;\\n        for(int x = n - 1; x >= 0; x--){\\n            res += query(nums[x] + offset, mx - 2);\\n            update(nums[x] + diff + offset, 1);\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005079,
                "title": "ordered-set-c-pbds-solution-simple-code",
                "content": "# Code\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace std;\\nusing namespace __gnu_pbds;\\n// #define int long long\\n#define pi pair<int , int>\\n#define ppi pair<pi ,int>\\n\\n// int INF = INT64_MAX;\\nint mod = 1e9+7;\\n\\ntypedef tree<int,null_type,less_equal<int> ,rb_tree_tag,tree_order_statistics_node_update> pbds;\\n\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        pbds p1;\\n        long long ans = 0;\\n        map<long long,long long> mp;\\n        long long n = nums1.size();\\n        for(long long i=0;i<n;i++)\\n        {\\n            if(i)\\n            {\\n                long long des_value = (nums1[i] - nums2[i]) + diff;\\n                ans += (long long)(p1.order_of_key(des_value) + mp[des_value]);\\n            }\\n            p1.insert(nums1[i] - nums2[i]);\\n            mp[nums1[i]-nums2[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace std;\\nusing namespace __gnu_pbds;\\n// #define int long long\\n#define pi pair<int , int>\\n#define ppi pair<pi ,int>\\n\\n// int INF = INT64_MAX;\\nint mod = 1e9+7;\\n\\ntypedef tree<int,null_type,less_equal<int> ,rb_tree_tag,tree_order_statistics_node_update> pbds;\\n\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        pbds p1;\\n        long long ans = 0;\\n        map<long long,long long> mp;\\n        long long n = nums1.size();\\n        for(long long i=0;i<n;i++)\\n        {\\n            if(i)\\n            {\\n                long long des_value = (nums1[i] - nums2[i]) + diff;\\n                ans += (long long)(p1.order_of_key(des_value) + mp[des_value]);\\n            }\\n            p1.insert(nums1[i] - nums2[i]);\\n            mp[nums1[i]-nums2[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3004062,
                "title": "number-of-pairs-satisfying-inequality-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        ans = 0\\n        n = len(nums1)\\n        nums = [nums1[i] - nums2[i] for i in range(n)]\\n        vis = []\\n        for i in range(n - 1, -1, -1):\\n            if not vis:\\n                vis.append(nums[i] + diff)\\n            else:\\n                pos = bisect.bisect_left(vis, nums[i])\\n                ans += len(vis) - pos\\n                bisect.insort(vis, nums[i] + diff)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        ans = 0\\n        n = len(nums1)\\n        nums = [nums1[i] - nums2[i] for i in range(n)]\\n        vis = []\\n        for i in range(n - 1, -1, -1):\\n            if not vis:\\n                vis.append(nums[i] + diff)\\n            else:\\n                pos = bisect.bisect_left(vis, nums[i])\\n                ans += len(vis) - pos\\n                bisect.insort(vis, nums[i] + diff)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003431,
                "title": "intuitive-interview-specific-without-ordered-set",
                "content": "# Intuition\\nWe may not be allowed to use PBDS in interviews.   \\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff \\n**transforms into** :-\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff.\\n\\nSince we have to find i , j such that i < j :\\ndiff[i] <= diff[j] + diff.\\n\\n# Approach\\nUse Merge Sort to count Inversions !\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     long long cnt;\\n    void merge(vector<int> &nums ,int start, int mid, int end, int d){\\n        int l = start, r = mid+1;\\n        while(l<=mid and r<=end){\\n            if(nums[l]<=(nums[r]+d)) \\n            {\\n                cnt += (end - r + 1);\\n                l++;\\n            }\\n            else     \\n            {\\n                r++;\\n            }\\n        }\\n        sort(nums.begin()+start, nums.begin()+end+1);\\n    }\\n\\n    void mergeSort(vector<int> &diff, int l , int r, int d){\\n        if(l < r){\\n            int mid = (l+r)/2;\\n            mergeSort(diff, l, mid, d);\\n            mergeSort(diff, mid+1, r, d);\\n            merge(diff, l, mid, r, d);\\n        }\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int d) {\\n        cnt = 0;\\n        int n = size(nums1);\\n        vector<int> diff(n);  \\n        \\n        for(int i=0;i<n;i++) diff[i]=nums1[i] - nums2[i];               \\n\\t\\t\\t\\n        mergeSort(diff,0,n-1,d);\\n\\t\\t\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long cnt;\\n    void merge(vector<int> &nums ,int start, int mid, int end, int d){\\n        int l = start, r = mid+1;\\n        while(l<=mid and r<=end){\\n            if(nums[l]<=(nums[r]+d)) \\n            {\\n                cnt += (end - r + 1);\\n                l++;\\n            }\\n            else     \\n            {\\n                r++;\\n            }\\n        }\\n        sort(nums.begin()+start, nums.begin()+end+1);\\n    }\\n\\n    void mergeSort(vector<int> &diff, int l , int r, int d){\\n        if(l < r){\\n            int mid = (l+r)/2;\\n            mergeSort(diff, l, mid, d);\\n            mergeSort(diff, mid+1, r, d);\\n            merge(diff, l, mid, r, d);\\n        }\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int d) {\\n        cnt = 0;\\n        int n = size(nums1);\\n        vector<int> diff(n);  \\n        \\n        for(int i=0;i<n;i++) diff[i]=nums1[i] - nums2[i];               \\n\\t\\t\\t\\n        mergeSort(diff,0,n-1,d);\\n\\t\\t\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998151,
                "title": "6-companies-30-days-q-9",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/7bd26f60-a365-4cec-bdfa-774bdb172e4f_1672839449.8203056.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        List<Integer> diffList = new ArrayList<>();\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int curDiff = nums1[i] - nums2[i];\\n            int target  = curDiff + diff; \\n            res += countSmallerEqual(diffList, target);\\n            diffList.add((int) countSmallerEqual(diffList, curDiff), curDiff);\\n        }\\n        return res;\\n    }\\n    \\n    private long countSmallerEqual(List<Integer> diffList, int target) {\\n        int left = 0, right = diffList.size(); \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (diffList.get(mid) <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return (long)left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        List<Integer> diffList = new ArrayList<>();\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int curDiff = nums1[i] - nums2[i];\\n            int target  = curDiff + diff; \\n            res += countSmallerEqual(diffList, target);\\n            diffList.add((int) countSmallerEqual(diffList, curDiff), curDiff);\\n        }\\n        return res;\\n    }\\n    \\n    private long countSmallerEqual(List<Integer> diffList, int target) {\\n        int left = 0, right = diffList.size(); \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (diffList.get(mid) <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return (long)left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992521,
                "title": "commented-full-explanation-ordered-set-c",
                "content": "\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp> \\n#include <ext/pb_ds/detail/standard_policies.hpp>\\nusing namespace __gnu_pbds;\\n\\ntypedef tree<pair<int,int>, null_type, less_equal<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\\n\\nclass Solution {\\npublic:\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        ordered_set os; \\n        /* We are creating ordered_set of pair to make element unique,\\n           since same element can\\'t be inserted in set, every element has a unique index\\n           which will solve this problem\\n        */\\n        \\n        int n = nums1.size();\\n        vector<int> d(n);  // this array will store our difference\\n        for(int i = 0; i < n; i++) {\\n            d[i] = nums1[i] - nums2[i];\\n        }\\n        \\n        \\n        long long count = 0;\\n        for(int i = n-1; i >= 0; i--) {\\n            pair<int,int> search = {d[i] - diff, INT_MIN};     // key to apply lower_bound\\n            int smaller = os.order_of_key(search); // order_of_key returns no. of element smaller than key\\n            count += os.size() - smaller; // remaining element are greater than key\\n            os.insert({d[i], i});  // inserting the curr d[i] and its index\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp> \\n#include <ext/pb_ds/detail/standard_policies.hpp>\\nusing namespace __gnu_pbds;\\n\\ntypedef tree<pair<int,int>, null_type, less_equal<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\\n\\nclass Solution {\\npublic:\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        ordered_set os; \\n        /* We are creating ordered_set of pair to make element unique,\\n           since same element can\\'t be inserted in set, every element has a unique index\\n           which will solve this problem\\n        */\\n        \\n        int n = nums1.size();\\n        vector<int> d(n);  // this array will store our difference\\n        for(int i = 0; i < n; i++) {\\n            d[i] = nums1[i] - nums2[i];\\n        }\\n        \\n        \\n        long long count = 0;\\n        for(int i = n-1; i >= 0; i--) {\\n            pair<int,int> search = {d[i] - diff, INT_MIN};     // key to apply lower_bound\\n            int smaller = os.order_of_key(search); // order_of_key returns no. of element smaller than key\\n            count += os.size() - smaller; // remaining element are greater than key\\n            os.insert({d[i], i});  // inserting the curr d[i] and its index\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2987405,
                "title": "merge-sort-c-solution-o-nlogn-counting-sort",
                "content": "```\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n\\nwritten as\\n\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n\\nlet,\\nv[i] = nums1[i] - nums2[i] \\nv[j] = nums1[j] - nums2[j]\\ncount all pairs where v[i]<=v[j]+diff and i<j (same as counting sort /merge sort)\\n\\n```\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int d;\\n    long long cnt = 0;\\n    void mergeSort(vector<int>&v,int st,int mid,int en){\\n        int i = st;\\n        int j = mid + 1;\\n        int n1 = mid-st+1;\\n        int n2 = en-mid;\\n        vector<int>a(n1);\\n        vector<int>b(n2);\\n\\n        for(int ii=0;ii<n1;ii++){\\n            a[ii] = v[ii+st];\\n        }\\n        for(int ii=0;ii<n2;ii++){\\n            b[ii] = v[ii+mid+1];\\n        }\\n\\n        while(i<=mid and j<=en){\\n            if(v[i] <= v[j] + d){\\n                cnt += (en-j+1);\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        i = 0;\\n        j = 0;\\n        int k = st;\\n        while(i<n1 and j<n2){\\n            if(a[i]<=b[j]){\\n                v[k] = a[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                v[k] = b[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i<n1){\\n            v[k++] = a[i++];\\n        }\\n        while(j<n2){\\n            v[k++] = b[j++];\\n        }\\n      \\n\\n        return;\\n    }\\n\\n    void merge(vector<int>&v,int st,int en){\\n        if(st<en){\\n            int mid = st + (en-st)/2;\\n            merge(v,st,mid);\\n            merge(v,mid+1,en);\\n            mergeSort(v,st,mid,en);\\n        }\\n        return ;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>v;\\n        d = diff;\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back(nums1[i] - nums2[i]);\\n        }\\n        merge(v,0,v.size()-1);\\n        return cnt;\\n    }\\n};\\n```\\n\\n\\nTC : (n*log(n*longn))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int d;\\n\\n    long long mergeSort(vector<int>&v,int st,int mid,int en){\\n        long long cnt = 0;\\n        int i = st;\\n        int j = mid + 1;\\n        while(i<=mid and j<=en){\\n            if(v[i] <= v[j] + d){\\n                cnt += (en-j+1);\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        sort(v.begin() + st,v.begin() + en + 1);\\n\\n        return cnt;\\n    }\\n\\n    long long merge(vector<int>&v,int st,int en){\\n        long long cnt = 0;\\n        if(st<en){\\n            int mid = st + (en-st)/2;\\n            cnt += merge(v,st,mid);\\n            cnt += merge(v,mid+1,en);\\n            cnt += mergeSort(v,st,mid,en);\\n        }\\n        return cnt;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>v;\\n        d = diff;\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back(nums1[i] - nums2[i]);\\n        }\\n        return merge(v,0,v.size()-1);\\n    }\\n};\\n```\\n\\n# upvote if you liked the solution HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Merge Sort",
                    "Counting Sort"
                ],
                "code": "```\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n\\nwritten as\\n\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff\\n\\nlet,\\nv[i] = nums1[i] - nums2[i] \\nv[j] = nums1[j] - nums2[j]\\ncount all pairs where v[i]<=v[j]+diff and i<j (same as counting sort /merge sort)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int d;\\n    long long cnt = 0;\\n    void mergeSort(vector<int>&v,int st,int mid,int en){\\n        int i = st;\\n        int j = mid + 1;\\n        int n1 = mid-st+1;\\n        int n2 = en-mid;\\n        vector<int>a(n1);\\n        vector<int>b(n2);\\n\\n        for(int ii=0;ii<n1;ii++){\\n            a[ii] = v[ii+st];\\n        }\\n        for(int ii=0;ii<n2;ii++){\\n            b[ii] = v[ii+mid+1];\\n        }\\n\\n        while(i<=mid and j<=en){\\n            if(v[i] <= v[j] + d){\\n                cnt += (en-j+1);\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        i = 0;\\n        j = 0;\\n        int k = st;\\n        while(i<n1 and j<n2){\\n            if(a[i]<=b[j]){\\n                v[k] = a[i];\\n                i++;\\n                k++;\\n            }\\n            else{\\n                v[k] = b[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n\\n        while(i<n1){\\n            v[k++] = a[i++];\\n        }\\n        while(j<n2){\\n            v[k++] = b[j++];\\n        }\\n      \\n\\n        return;\\n    }\\n\\n    void merge(vector<int>&v,int st,int en){\\n        if(st<en){\\n            int mid = st + (en-st)/2;\\n            merge(v,st,mid);\\n            merge(v,mid+1,en);\\n            mergeSort(v,st,mid,en);\\n        }\\n        return ;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>v;\\n        d = diff;\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back(nums1[i] - nums2[i]);\\n        }\\n        merge(v,0,v.size()-1);\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int d;\\n\\n    long long mergeSort(vector<int>&v,int st,int mid,int en){\\n        long long cnt = 0;\\n        int i = st;\\n        int j = mid + 1;\\n        while(i<=mid and j<=en){\\n            if(v[i] <= v[j] + d){\\n                cnt += (en-j+1);\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        sort(v.begin() + st,v.begin() + en + 1);\\n\\n        return cnt;\\n    }\\n\\n    long long merge(vector<int>&v,int st,int en){\\n        long long cnt = 0;\\n        if(st<en){\\n            int mid = st + (en-st)/2;\\n            cnt += merge(v,st,mid);\\n            cnt += merge(v,mid+1,en);\\n            cnt += mergeSort(v,st,mid,en);\\n        }\\n        return cnt;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int>v;\\n        d = diff;\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back(nums1[i] - nums2[i]);\\n        }\\n        return merge(v,0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984031,
                "title": "c-code-using-segment-tree",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRewritting the equation we get nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff run a loop from j->0 to end and find the value of nums1[j] - nums2[j] + diff and use a segment tree to get the number of i\\'s satisfy the equation then update the current answer and segment tree\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n# Code\\n```\\nconst int N = 1e5;\\nconst int offset = 4e4;\\nclass Solution {\\npublic:\\n    // left ---> st to mid\\n    // right ---> mid + 1 to end\\n    vector<int>tree;\\n    long long func(int curr, int st, int ed, int qst, int qed)\\n    {\\n        if(st >= qst and ed <= qed) return tree[curr];\\n        if(st > qed or ed < qst) return 0;\\n\\n        int mid = st + (ed - st) / 2;\\n        return 0LL + func(2*curr, st, mid, qst, qed) + func(2*curr+1, mid + 1, ed, qst, qed);\\n    }\\n    void query(int st, int ed, int curr, int target)\\n    {\\n        if(st == ed)\\n        {\\n            tree[curr] ++;\\n            return;\\n        }\\n        int mid = st + (ed - st) / 2;\\n        if(target <= mid) query(st, mid, 2*curr, target);\\n        else query(mid+1, ed, 2*curr+1, target);\\n        tree[curr] = tree[2*curr] + tree[2*curr+1]; \\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long ans = 0LL;\\n        tree.resize(4*N+5);\\n\\n        int n = nums1.size();\\n        for(int j=0;j<n;++j)\\n        {\\n            long long maxx = 0LL + nums1[j] - nums2[j] + diff + offset;\\n            ans = ans + 0LL + func(1, 1, N, 1, maxx);\\n            maxx = maxx - diff;\\n            query(1, N, 1, maxx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Segment Tree"
                ],
                "code": "```\\nconst int N = 1e5;\\nconst int offset = 4e4;\\nclass Solution {\\npublic:\\n    // left ---> st to mid\\n    // right ---> mid + 1 to end\\n    vector<int>tree;\\n    long long func(int curr, int st, int ed, int qst, int qed)\\n    {\\n        if(st >= qst and ed <= qed) return tree[curr];\\n        if(st > qed or ed < qst) return 0;\\n\\n        int mid = st + (ed - st) / 2;\\n        return 0LL + func(2*curr, st, mid, qst, qed) + func(2*curr+1, mid + 1, ed, qst, qed);\\n    }\\n    void query(int st, int ed, int curr, int target)\\n    {\\n        if(st == ed)\\n        {\\n            tree[curr] ++;\\n            return;\\n        }\\n        int mid = st + (ed - st) / 2;\\n        if(target <= mid) query(st, mid, 2*curr, target);\\n        else query(mid+1, ed, 2*curr+1, target);\\n        tree[curr] = tree[2*curr] + tree[2*curr+1]; \\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long ans = 0LL;\\n        tree.resize(4*N+5);\\n\\n        int n = nums1.size();\\n        for(int j=0;j<n;++j)\\n        {\\n            long long maxx = 0LL + nums1[j] - nums2[j] + diff + offset;\\n            ans = ans + 0LL + func(1, 1, N, 1, maxx);\\n            maxx = maxx - diff;\\n            query(1, N, 1, maxx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880695,
                "title": "c-divide-and-conquer-clean-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    ll merge(vector<ll>&container,vector<ll>&temp,ll start,ll mid,ll high,int &diff){\\n        ll i=start,j=mid,k,count=0;\\n        while(i<mid && j<=high){\\n            if(container[j]+diff>=container[i]){\\n                count+=(high-j+1);\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        i=start;j=mid,k=start;\\n        while(i<mid && j<=high){\\n            if(container[i]<=container[j]){\\n                temp[k++]=container[i++];\\n            }\\n            else{\\n                temp[k++]=container[j++];\\n            }\\n        }\\n        while(i<mid){\\n            temp[k++]=container[i++];\\n        }\\n        while(j<=high){\\n            temp[k++]=container[j++];\\n        }\\n        for(ll i=start;i<=high;i++){\\n            container[i]=temp[i];\\n        }\\n        return count;\\n    }\\n\\n    ll solve(vector<ll>&container,vector<ll>&temp,ll start,ll end,int &diff){\\n        ll answer=0,mid;\\n        if(end>start){\\n            mid=(start+end)>>1;\\n            answer+=solve(container,temp,start,mid,diff);\\n            answer+=solve(container,temp,mid+1,end,diff);\\n            answer+=merge(container,temp,start,mid+1,end,diff);\\n        }\\n        return answer;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        ll n=nums1.size();\\n        vector<ll>container(n,0),temp(n,0);\\n        for(ll i=0;i<n;i++){\\n            container[i]=nums1[i]-nums2[i];\\n        }\\n        return solve(container,temp,0,n-1,diff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    ll merge(vector<ll>&container,vector<ll>&temp,ll start,ll mid,ll high,int &diff){\\n        ll i=start,j=mid,k,count=0;\\n        while(i<mid && j<=high){\\n            if(container[j]+diff>=container[i]){\\n                count+=(high-j+1);\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        i=start;j=mid,k=start;\\n        while(i<mid && j<=high){\\n            if(container[i]<=container[j]){\\n                temp[k++]=container[i++];\\n            }\\n            else{\\n                temp[k++]=container[j++];\\n            }\\n        }\\n        while(i<mid){\\n            temp[k++]=container[i++];\\n        }\\n        while(j<=high){\\n            temp[k++]=container[j++];\\n        }\\n        for(ll i=start;i<=high;i++){\\n            container[i]=temp[i];\\n        }\\n        return count;\\n    }\\n\\n    ll solve(vector<ll>&container,vector<ll>&temp,ll start,ll end,int &diff){\\n        ll answer=0,mid;\\n        if(end>start){\\n            mid=(start+end)>>1;\\n            answer+=solve(container,temp,start,mid,diff);\\n            answer+=solve(container,temp,mid+1,end,diff);\\n            answer+=merge(container,temp,start,mid+1,end,diff);\\n        }\\n        return answer;\\n    }\\n\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        ll n=nums1.size();\\n        vector<ll>container(n,0),temp(n,0);\\n        for(ll i=0;i<n;i++){\\n            container[i]=nums1[i]-nums2[i];\\n        }\\n        return solve(container,temp,0,n-1,diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852678,
                "title": "python3-using-merge-sort",
                "content": "class Solution:\\n\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        num = [n1-n2 for n1,n2 in zip(nums1,nums2)]\\n        res = 0\\n        \\n        def merge(arr):\\n            n = len(arr)\\n            if n>1:\\n                nonlocal res\\n                left,right = arr[:n//2],arr[n//2:]\\n                merge(left)\\n                merge(right)\\n                L,R = len(left),len(right)\\n                for ele in right:\\n                    res+=bisect_right(left,ele+diff)\\n                i = j = k = 0\\n                while i<L and j<R:\\n                    if left[i]<=right[j]:\\n                        arr[k] = left[i]\\n                        i+=1\\n                    else:\\n                        arr[k] = right[j]\\n                        j+=1\\n                    k+=1\\n                while i<L:\\n                    arr[k] = left[i]\\n                    k+=1\\n                    i+=1\\n                while j<R:\\n                    arr[k] = right[j]\\n                    k+=1\\n                    j+=1\\n            return arr        \\n        \\n        merge(num)\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        num = [n1-n2 for n1,n2 in zip(nums1,nums2)]\\n        res = 0\\n        \\n        def merge(arr):\\n            n = len(arr)\\n            if n>1:\\n                nonlocal res\\n                left,right = arr[:n//2],arr[n//2:]\\n                merge(left)\\n                merge(right)\\n                L,R = len(left),len(right)\\n                for ele in right:\\n                    res+=bisect_right(left,ele+diff)\\n                i = j = k = 0\\n                while i<L and j<R:\\n                    if left[i]<=right[j]:\\n                        arr[k] = left[i]\\n                        i+=1\\n                    else:\\n                        arr[k] = right[j]\\n                        j+=1\\n                    k+=1\\n                while i<L:\\n                    arr[k] = left[i]\\n                    k+=1\\n                    i+=1\\n                while j<R:\\n                    arr[k] = right[j]\\n                    k+=1\\n                    j+=1\\n            return arr        \\n        \\n        merge(num)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2851712,
                "title": "python3-using-sortedlist",
                "content": "from sortedcontainers import SortedList\\n\\nclass Solution:\\n\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        s = SortedList()\\n        res = 0\\n        \\n        for n1,n2 in zip(nums1,nums2):\\n            idx = s.bisect_right(n1-n2+diff)\\n            res+=idx\\n            s.add(n1-n2)\\n        return res",
                "solutionTags": [],
                "code": "from sortedcontainers import SortedList\\n\\nclass Solution:\\n\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        s = SortedList()\\n        res = 0\\n        \\n        for n1,n2 in zip(nums1,nums2):\\n            idx = s.bisect_right(n1-n2+diff)\\n            res+=idx\\n            s.add(n1-n2)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2842621,
                "title": "python3-commented-sorted-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter restructuring this problem is very similar to the two sum problem. We keep track of sums we have already seen previously.\\n\\nSince the formula is allowing for buildings pairs with differences equal or smaller, we need to keep a sorted list and bisect it to find smaller differences\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a sorted list which has logN inclusion time complexity and search for values again with logN inclusion time complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n\\n        # we can do the following: restructure the formula.\\n        #\\n        # nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff ==>> nums1[i] - nums2[i] <= nums1[j] - nums[j] + diff\\n        # we could keep a minimal diff\\n        previous_diffs = SortedList()\\n\\n        # insert the differences\\n        result = 0\\n        for idx, (num1, num2) in enumerate(zip(nums1, nums2)):\\n            \\n            # calculate the difference\\n            difference = num1-num2\\n            cmp_value = difference + diff\\n\\n            # find the index with numbers lower\\n            if previous_diffs:\\n                lower = previous_diffs.bisect_right(cmp_value)\\n                result += lower\\n\\n            # input the difference in the sorted list\\n            minimal_diff = previous_diffs.add(difference)\\n        return result\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n\\n        # we can do the following: restructure the formula.\\n        #\\n        # nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff ==>> nums1[i] - nums2[i] <= nums1[j] - nums[j] + diff\\n        # we could keep a minimal diff\\n        previous_diffs = SortedList()\\n\\n        # insert the differences\\n        result = 0\\n        for idx, (num1, num2) in enumerate(zip(nums1, nums2)):\\n            \\n            # calculate the difference\\n            difference = num1-num2\\n            cmp_value = difference + diff\\n\\n            # find the index with numbers lower\\n            if previous_diffs:\\n                lower = previous_diffs.bisect_right(cmp_value)\\n                result += lower\\n\\n            # input the difference in the sorted list\\n            minimal_diff = previous_diffs.add(difference)\\n        return result\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809373,
                "title": "c-segment-tree-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n    int size;\\n    const int nax = 4e4 + 10;\\n    const int add = 2e4;\\n    void update(int val) {\\n        --tree[size - 1 + val + add];\\n        int p = (size - 2 + val + add) / 2;\\n        for (int i = p; i > 0; i = (i  - 1) / 2) {\\n            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n        }\\n        if (size > 1) {\\n            tree[0] = tree[1] + tree[2];\\n        }\\n    }\\n    int getSum(int root, int l, int r, int left, int right) {\\n        if (right < l || left > r) {\\n            return 0;\\n        }\\n        if (left >= l && right <= r) {\\n            return tree[root];\\n        }\\n        int mid = (left + right) / 2;\\n        return getSum(2 * root + 1, l, r, left, mid) + getSum(2 * root + 2, l, r, mid + 1, right);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        for (int i = 0; i < n; i++) {\\n            nums1[i] -= nums2[i];\\n        }\\n        size = 1;\\n        while (size <= nax) {\\n            size *= 2;\\n        }\\n        tree = vector<int> (2 * size - 1);\\n        for (int i = 0; i < n; i++) {\\n            ++tree[size - 1 + nums1[i] + add];\\n        }\\n        for (int i = size - 2; i >= 0; i--) {\\n            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n        }\\n        long long sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            update(nums1[i]);\\n            int value = nums1[i] - diff;\\n            sol += getSum(0, value + add, size - 1, 0, size - 1);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n    int size;\\n    const int nax = 4e4 + 10;\\n    const int add = 2e4;\\n    void update(int val) {\\n        --tree[size - 1 + val + add];\\n        int p = (size - 2 + val + add) / 2;\\n        for (int i = p; i > 0; i = (i  - 1) / 2) {\\n            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n        }\\n        if (size > 1) {\\n            tree[0] = tree[1] + tree[2];\\n        }\\n    }\\n    int getSum(int root, int l, int r, int left, int right) {\\n        if (right < l || left > r) {\\n            return 0;\\n        }\\n        if (left >= l && right <= r) {\\n            return tree[root];\\n        }\\n        int mid = (left + right) / 2;\\n        return getSum(2 * root + 1, l, r, left, mid) + getSum(2 * root + 2, l, r, mid + 1, right);\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        for (int i = 0; i < n; i++) {\\n            nums1[i] -= nums2[i];\\n        }\\n        size = 1;\\n        while (size <= nax) {\\n            size *= 2;\\n        }\\n        tree = vector<int> (2 * size - 1);\\n        for (int i = 0; i < n; i++) {\\n            ++tree[size - 1 + nums1[i] + add];\\n        }\\n        for (int i = size - 2; i >= 0; i--) {\\n            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n        }\\n        long long sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            update(nums1[i]);\\n            int value = nums1[i] - diff;\\n            sol += getSum(0, value + add, size - 1, 0, size - 1);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777811,
                "title": "my-solutions",
                "content": "**1. Use the Fenwick Tree**\\n```\\n/**\\n * Time Complexity: O(n * log(diff_range))\\n * Space Complexity: O(n + diff_range)\\n * where `n` is the length of the vector `nums1`\\n *       `diff_range` is the `max_diff - min_diff + 1`\\n *       `max_diff` is max({nums1[0] - nums2[0], nums1[1] - nums2[1], ..., nums1[n - 1] - nums2[n - 1]})\\n *       `min_diff` is min({nums1[0] - nums2[0], nums1[1] - nums2[1], ..., nums1[n - 1] - nums2[n - 1]})\\n */\\nclass Solution {\\n private:\\n  class FenwickTree {\\n   public:\\n    FenwickTree(const int n) : tree_(n) {\\n    }\\n    \\n    int read(int i) {\\n      int ret = 0;\\n      while (i > 0) {\\n        ret += tree_[i - 1];\\n        i -= (i & (-i));\\n      }\\n      return ret;\\n    }\\n    \\n    void update(int i, const int delta) {\\n      const int n = static_cast<int>(tree_.size());\\n      while (i <= n) {\\n        tree_[i - 1] += delta;\\n        i += (i & (-i));\\n      }\\n    }\\n    \\n    int n() const {\\n      return static_cast<int>(tree_.size());\\n    }\\n    \\n   private:\\n    vector<int> tree_;\\n  };\\n\\n public:\\n  long long numberOfPairs(const vector<int> &nums1, const vector<int> &nums2, const int diff) {\\n    const int n = static_cast<int>(nums1.size());\\n    int diffs[n];\\n    int max_diff = numeric_limits<int>::min();\\n    int min_diff = numeric_limits<int>::max();\\n    for (int i = 0; i < n; ++i) {\\n      diffs[i] = nums1[i] - nums2[i];\\n      max_diff = max(max_diff, diffs[i]);\\n      min_diff = min(min_diff, diffs[i]);\\n    }\\n    \\n    const int diff_range = max_diff - min_diff + 1;\\n    FenwickTree fenwick_tree(diff_range);\\n    long long ret = 0LL;\\n    for (const int current_diff : diffs) {\\n      ret += fenwick_tree.read(min(diff_range, current_diff + diff - min_diff + 1));\\n      fenwick_tree.update(current_diff - min_diff + 1, 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the Segment Tree**\\n```\\n/**\\n * Time Complexity: O(n * log(diff_range))\\n * Space Complexity: O(n + diff_range)\\n * where `n` is the length of the vector `nums1`\\n *       `diff_range` is the `max_diff - min_diff + 1`\\n *       `max_diff` is max({nums1[0] - nums2[0], nums1[1] - nums2[1], ..., nums1[n - 1] - nums2[n - 1]})\\n *       `min_diff` is min({nums1[0] - nums2[0], nums1[1] - nums2[1], ..., nums1[n - 1] - nums2[n - 1]})\\n */\\nclass Solution {\\n private:\\n  class SegmentTree {\\n   public:\\n    SegmentTree(const int n) : n_(n), tree_((1 << (static_cast<int>(ceil(log2(n))) + 1)) - 1) {\\n    }\\n\\n    int read(const int index) {\\n      return read_dfs(0, 0, n_, 0, index + 1);\\n    }\\n\\n    void update(const int index, const int delta) {\\n      update_dfs(0, 0, n_, index, delta);\\n    }\\n\\n   private:\\n    int read_dfs(const int node, const int begin, const int end, const int left, const int right) {\\n      if (right <= begin || left >= end) {\\n        return 0;\\n      }\\n\\n      if (begin == left && end == right) {\\n        return tree_[node];\\n      }\\n\\n      const int mid = begin + (end - begin) / 2;\\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      int left_ret = read_dfs(left_node, begin, mid, max(begin, left), min(mid, right));\\n      int right_ret = read_dfs(right_node, mid, end, max(mid, left), min(end, right));\\n      return left_ret + right_ret;\\n    }\\n\\n    void update_dfs(const int node, const int begin, const int end, const int index, const int delta) {\\n      if (index < begin || index >= end) {\\n        return;\\n      }\\n      if (end - begin == 1) {\\n        tree_[node] += delta;\\n        return;\\n      }\\n\\n      const int mid = begin + (end - begin) / 2;\\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      update_dfs(left_node, begin, mid, index, delta);\\n      update_dfs(right_node, mid, end, index, delta);\\n      tree_[node] = tree_[left_node] + tree_[right_node];\\n    }\\n\\n    const int n_;\\n    vector<int> tree_;\\n  };\\n\\n public:\\n  long long numberOfPairs(const vector<int> &nums1, const vector<int> &nums2, const int diff) {\\n    const int n = static_cast<int>(nums1.size());\\n    int diffs[n];\\n    int max_diff = numeric_limits<int>::min();\\n    int min_diff = numeric_limits<int>::max();\\n    for (int i = 0; i < n; ++i) {\\n      diffs[i] = nums1[i] - nums2[i];\\n      max_diff = max(max_diff, diffs[i]);\\n      min_diff = min(min_diff, diffs[i]);\\n    }\\n    \\n    const int diff_range = max_diff - min_diff + 1;\\n    SegmentTree segment_tree(diff_range);\\n    long long ret = 0LL;\\n    for (const int current_diff : diffs) {\\n      ret += segment_tree.read(min(diff_range - 1, current_diff + diff - min_diff));\\n      segment_tree.update(current_diff - min_diff, 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**3. Use the merge sort**\\n```\\n/**\\n * Time Complexity: O(n * log(n) * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums1`\\n */\\nclass Solution {\\n public:\\n  long long numberOfPairs(const vector<int> &nums1, const vector<int> &nums2, const int diff) {\\n    const int n = static_cast<int>(nums1.size());\\n    int diffs[n];\\n    for (int i = 0; i < n; ++i) {\\n      diffs[i] = nums1[i] - nums2[i];\\n    }\\n\\n    long long ret = 0LL;\\n    merge_sort(diffs, 0, n, diff, ret);\\n    return ret;\\n  }\\n\\n private:\\n  void merge_sort(int *diffs, const int begin, const int end, const int diff, long long &result) {\\n    if (end - begin <= 1) {\\n      return;\\n    }\\n\\n    const int mid = begin + (end - begin) / 2;\\n    merge_sort(diffs, begin, mid, diff, result);\\n    merge_sort(diffs, mid, end, diff, result);\\n\\n    const int n_left = mid - begin;\\n    int left_diffs[n_left];\\n    for (int i = 0; i < n_left; ++i) {\\n      left_diffs[i] = diffs[begin + i];\\n    }\\n    const int n_right = end - mid;\\n    int right_diffs[n_right];\\n    for (int i = 0; i < n_right; ++i) {\\n      right_diffs[i] = diffs[mid + i];\\n    }\\n\\n    int i_left = 0;\\n    int i_right = 0;\\n    int index = begin;\\n    while (i_left < n_left && i_right < n_right) {\\n      if (left_diffs[i_left] <= right_diffs[i_right]) {\\n        diffs[index++] = left_diffs[i_left++];\\n      } else {\\n        diffs[index++] = right_diffs[i_right++];\\n      }\\n    }\\n    if (i_left < n_left) {\\n      while (i_left < n_left) {\\n        diffs[index++] = left_diffs[i_left++];\\n      }\\n    } else {\\n      while (i_right < n_right) {\\n        diffs[index++] = right_diffs[i_right++];\\n      }\\n    }\\n    for (const int right_diff : right_diffs) {\\n      result += static_cast<long long>(upper_bound(left_diffs, left_diffs + n_left, right_diff + diff) - left_diffs);\\n    }\\n\\t/**\\n\\t * the following `for` statement works as well\\n\\t * for (const int left_diff : left_diffs) {\\n     *   result += n_right - static_cast<long long>(lower_bound(right_diffs, right_diffs + n_right, left_diff - diff) - right_diffs);\\n     * }\\n\\t */\\n  }\\n};\\n```\\n**4. Use the binary search tree**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums1`\\n */\\nclass Solution {\\n private:\\n  class TreeNode {\\n   public:\\n    TreeNode(const int value)\\n      : left_(nullptr)\\n      , right_(nullptr)\\n      , value_(value)\\n      , left_count_(0)\\n      , self_count_(0)\\n      , right_count_(0) {\\n    }\\n    \\n    ~TreeNode() {\\n      delete left_;\\n      delete right_;\\n    }\\n    \\n    void set_left(TreeNode * const left) {\\n      left_ = left;\\n    }\\n    \\n    TreeNode* left() const {\\n      return left_;\\n    }\\n    \\n    void set_right(TreeNode * const right) {\\n      right_ = right;\\n    }\\n    \\n    TreeNode* right() const {\\n      return right_;\\n    }\\n    \\n    int value() const {\\n      return value_;\\n    }\\n    \\n    void increase_left_count() {\\n      ++left_count_;\\n    }\\n    \\n    int left_count() const {\\n      return left_count_;\\n    }\\n    \\n    void increase_self_count() {\\n      ++self_count_;\\n    }\\n    \\n    int self_count() const {\\n      return self_count_;\\n    }\\n    \\n    void increase_right_count() {\\n      ++right_count_;\\n    }\\n    \\n    int right_count() const {\\n      return right_count_;\\n    }\\n    \\n   private:\\n    TreeNode *left_;\\n    TreeNode *right_;\\n    const int value_;\\n    int left_count_;\\n    int self_count_;\\n    int right_count_;\\n  };\\n  \\n  class Tree {\\n   public:\\n    Tree(const vector<int> &data) : root_(build(data)) {\\n    }\\n    \\n    ~Tree() {\\n      delete root_;\\n    }\\n    \\n    int count(const int value) {\\n      int ret = 0;\\n      for (TreeNode *node = root_; node != nullptr; ) {\\n        if (node->value() == value) {\\n          ret += node->left_count() + node->self_count();\\n          break;\\n        }\\n        if (node->value() < value) {\\n          ret += node->left_count() + node->self_count();\\n          node = node->right();\\n        } else {\\n          // node->value() > value\\n          node = node->left();\\n        }\\n      }\\n      return ret;\\n    }\\n    \\n    void emplace(const int value) {\\n      for (TreeNode *node = root_; node != nullptr; ) {\\n        if (node->value() == value) {\\n          node->increase_self_count();\\n          break;\\n        }\\n        if (node->value() < value) {\\n          node->increase_right_count();\\n          node = node->right();\\n        } else {\\n          // node->value() > value\\n          node->increase_left_count();\\n          node = node->left();\\n        }\\n      }\\n    }\\n    \\n   private:\\n    TreeNode* build(const vector<int> &data) {\\n      vector<int> sorted_data(data);\\n      sort(sorted_data.begin(), sorted_data.end());\\n      const int n = static_cast<int>(sorted_data.size());\\n      return build_impl(sorted_data, 0, n);\\n    }\\n    \\n    TreeNode* build_impl(const vector<int> &data, const int begin, const int end) {\\n      if (begin == end) {\\n        return nullptr;\\n      }\\n      if (end - begin == 1) {\\n        return new TreeNode(data[begin]);\\n      }\\n      \\n      const int mid = begin + (end - begin) / 2;\\n      TreeNode *ret = new TreeNode(data[mid]);\\n      ret->set_left(build_impl(data, begin, mid));\\n      ret->set_right(build_impl(data, mid + 1, end));\\n      return ret;\\n    }\\n    \\n    TreeNode *root_;\\n  };\\n  \\n public:\\n  long long numberOfPairs(const vector<int> &nums1, const vector<int> &nums2, const int diff) {\\n    const int n = static_cast<int>(nums1.size());\\n    vector<int> diffs(n);\\n    for (int i = 0; i < n; ++i) {\\n      diffs[i] = nums1[i] - nums2[i];\\n    }\\n    \\n    long long ret = 0LL;\\n    Tree tree(diffs);\\n    for (const int current_diff : diffs) {\\n      ret += tree.count(current_diff + diff);\\n      tree.emplace(current_diff);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(diff_range))\\n * Space Complexity: O(n + diff_range)\\n * where `n` is the length of the vector `nums1`\\n *       `diff_range` is the `max_diff - min_diff + 1`\\n *       `max_diff` is max({nums1[0] - nums2[0], nums1[1] - nums2[1], ..., nums1[n - 1] - nums2[n - 1]})\\n *       `min_diff` is min({nums1[0] - nums2[0], nums1[1] - nums2[1], ..., nums1[n - 1] - nums2[n - 1]})\\n */\\nclass Solution {\\n private:\\n  class FenwickTree {\\n   public:\\n    FenwickTree(const int n) : tree_(n) {\\n    }\\n    \\n    int read(int i) {\\n      int ret = 0;\\n      while (i > 0) {\\n        ret += tree_[i - 1];\\n        i -= (i & (-i));\\n      }\\n      return ret;\\n    }\\n    \\n    void update(int i, const int delta) {\\n      const int n = static_cast<int>(tree_.size());\\n      while (i <= n) {\\n        tree_[i - 1] += delta;\\n        i += (i & (-i));\\n      }\\n    }\\n    \\n    int n() const {\\n      return static_cast<int>(tree_.size());\\n    }\\n    \\n   private:\\n    vector<int> tree_;\\n  };\\n\\n public:\\n  long long numberOfPairs(const vector<int> &nums1, const vector<int> &nums2, const int diff) {\\n    const int n = static_cast<int>(nums1.size());\\n    int diffs[n];\\n    int max_diff = numeric_limits<int>::min();\\n    int min_diff = numeric_limits<int>::max();\\n    for (int i = 0; i < n; ++i) {\\n      diffs[i] = nums1[i] - nums2[i];\\n      max_diff = max(max_diff, diffs[i]);\\n      min_diff = min(min_diff, diffs[i]);\\n    }\\n    \\n    const int diff_range = max_diff - min_diff + 1;\\n    FenwickTree fenwick_tree(diff_range);\\n    long long ret = 0LL;\\n    for (const int current_diff : diffs) {\\n      ret += fenwick_tree.read(min(diff_range, current_diff + diff - min_diff + 1));\\n      fenwick_tree.update(current_diff - min_diff + 1, 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * log(diff_range))\\n * Space Complexity: O(n + diff_range)\\n * where `n` is the length of the vector `nums1`\\n *       `diff_range` is the `max_diff - min_diff + 1`\\n *       `max_diff` is max({nums1[0] - nums2[0], nums1[1] - nums2[1], ..., nums1[n - 1] - nums2[n - 1]})\\n *       `min_diff` is min({nums1[0] - nums2[0], nums1[1] - nums2[1], ..., nums1[n - 1] - nums2[n - 1]})\\n */\\nclass Solution {\\n private:\\n  class SegmentTree {\\n   public:\\n    SegmentTree(const int n) : n_(n), tree_((1 << (static_cast<int>(ceil(log2(n))) + 1)) - 1) {\\n    }\\n\\n    int read(const int index) {\\n      return read_dfs(0, 0, n_, 0, index + 1);\\n    }\\n\\n    void update(const int index, const int delta) {\\n      update_dfs(0, 0, n_, index, delta);\\n    }\\n\\n   private:\\n    int read_dfs(const int node, const int begin, const int end, const int left, const int right) {\\n      if (right <= begin || left >= end) {\\n        return 0;\\n      }\\n\\n      if (begin == left && end == right) {\\n        return tree_[node];\\n      }\\n\\n      const int mid = begin + (end - begin) / 2;\\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      int left_ret = read_dfs(left_node, begin, mid, max(begin, left), min(mid, right));\\n      int right_ret = read_dfs(right_node, mid, end, max(mid, left), min(end, right));\\n      return left_ret + right_ret;\\n    }\\n\\n    void update_dfs(const int node, const int begin, const int end, const int index, const int delta) {\\n      if (index < begin || index >= end) {\\n        return;\\n      }\\n      if (end - begin == 1) {\\n        tree_[node] += delta;\\n        return;\\n      }\\n\\n      const int mid = begin + (end - begin) / 2;\\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      update_dfs(left_node, begin, mid, index, delta);\\n      update_dfs(right_node, mid, end, index, delta);\\n      tree_[node] = tree_[left_node] + tree_[right_node];\\n    }\\n\\n    const int n_;\\n    vector<int> tree_;\\n  };\\n\\n public:\\n  long long numberOfPairs(const vector<int> &nums1, const vector<int> &nums2, const int diff) {\\n    const int n = static_cast<int>(nums1.size());\\n    int diffs[n];\\n    int max_diff = numeric_limits<int>::min();\\n    int min_diff = numeric_limits<int>::max();\\n    for (int i = 0; i < n; ++i) {\\n      diffs[i] = nums1[i] - nums2[i];\\n      max_diff = max(max_diff, diffs[i]);\\n      min_diff = min(min_diff, diffs[i]);\\n    }\\n    \\n    const int diff_range = max_diff - min_diff + 1;\\n    SegmentTree segment_tree(diff_range);\\n    long long ret = 0LL;\\n    for (const int current_diff : diffs) {\\n      ret += segment_tree.read(min(diff_range - 1, current_diff + diff - min_diff));\\n      segment_tree.update(current_diff - min_diff, 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * log(n) * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums1`\\n */\\nclass Solution {\\n public:\\n  long long numberOfPairs(const vector<int> &nums1, const vector<int> &nums2, const int diff) {\\n    const int n = static_cast<int>(nums1.size());\\n    int diffs[n];\\n    for (int i = 0; i < n; ++i) {\\n      diffs[i] = nums1[i] - nums2[i];\\n    }\\n\\n    long long ret = 0LL;\\n    merge_sort(diffs, 0, n, diff, ret);\\n    return ret;\\n  }\\n\\n private:\\n  void merge_sort(int *diffs, const int begin, const int end, const int diff, long long &result) {\\n    if (end - begin <= 1) {\\n      return;\\n    }\\n\\n    const int mid = begin + (end - begin) / 2;\\n    merge_sort(diffs, begin, mid, diff, result);\\n    merge_sort(diffs, mid, end, diff, result);\\n\\n    const int n_left = mid - begin;\\n    int left_diffs[n_left];\\n    for (int i = 0; i < n_left; ++i) {\\n      left_diffs[i] = diffs[begin + i];\\n    }\\n    const int n_right = end - mid;\\n    int right_diffs[n_right];\\n    for (int i = 0; i < n_right; ++i) {\\n      right_diffs[i] = diffs[mid + i];\\n    }\\n\\n    int i_left = 0;\\n    int i_right = 0;\\n    int index = begin;\\n    while (i_left < n_left && i_right < n_right) {\\n      if (left_diffs[i_left] <= right_diffs[i_right]) {\\n        diffs[index++] = left_diffs[i_left++];\\n      } else {\\n        diffs[index++] = right_diffs[i_right++];\\n      }\\n    }\\n    if (i_left < n_left) {\\n      while (i_left < n_left) {\\n        diffs[index++] = left_diffs[i_left++];\\n      }\\n    } else {\\n      while (i_right < n_right) {\\n        diffs[index++] = right_diffs[i_right++];\\n      }\\n    }\\n    for (const int right_diff : right_diffs) {\\n      result += static_cast<long long>(upper_bound(left_diffs, left_diffs + n_left, right_diff + diff) - left_diffs);\\n    }\\n\\t/**\\n\\t * the following `for` statement works as well\\n\\t * for (const int left_diff : left_diffs) {\\n     *   result += n_right - static_cast<long long>(lower_bound(right_diffs, right_diffs + n_right, left_diff - diff) - right_diffs);\\n     * }\\n\\t */\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums1`\\n */\\nclass Solution {\\n private:\\n  class TreeNode {\\n   public:\\n    TreeNode(const int value)\\n      : left_(nullptr)\\n      , right_(nullptr)\\n      , value_(value)\\n      , left_count_(0)\\n      , self_count_(0)\\n      , right_count_(0) {\\n    }\\n    \\n    ~TreeNode() {\\n      delete left_;\\n      delete right_;\\n    }\\n    \\n    void set_left(TreeNode * const left) {\\n      left_ = left;\\n    }\\n    \\n    TreeNode* left() const {\\n      return left_;\\n    }\\n    \\n    void set_right(TreeNode * const right) {\\n      right_ = right;\\n    }\\n    \\n    TreeNode* right() const {\\n      return right_;\\n    }\\n    \\n    int value() const {\\n      return value_;\\n    }\\n    \\n    void increase_left_count() {\\n      ++left_count_;\\n    }\\n    \\n    int left_count() const {\\n      return left_count_;\\n    }\\n    \\n    void increase_self_count() {\\n      ++self_count_;\\n    }\\n    \\n    int self_count() const {\\n      return self_count_;\\n    }\\n    \\n    void increase_right_count() {\\n      ++right_count_;\\n    }\\n    \\n    int right_count() const {\\n      return right_count_;\\n    }\\n    \\n   private:\\n    TreeNode *left_;\\n    TreeNode *right_;\\n    const int value_;\\n    int left_count_;\\n    int self_count_;\\n    int right_count_;\\n  };\\n  \\n  class Tree {\\n   public:\\n    Tree(const vector<int> &data) : root_(build(data)) {\\n    }\\n    \\n    ~Tree() {\\n      delete root_;\\n    }\\n    \\n    int count(const int value) {\\n      int ret = 0;\\n      for (TreeNode *node = root_; node != nullptr; ) {\\n        if (node->value() == value) {\\n          ret += node->left_count() + node->self_count();\\n          break;\\n        }\\n        if (node->value() < value) {\\n          ret += node->left_count() + node->self_count();\\n          node = node->right();\\n        } else {\\n          // node->value() > value\\n          node = node->left();\\n        }\\n      }\\n      return ret;\\n    }\\n    \\n    void emplace(const int value) {\\n      for (TreeNode *node = root_; node != nullptr; ) {\\n        if (node->value() == value) {\\n          node->increase_self_count();\\n          break;\\n        }\\n        if (node->value() < value) {\\n          node->increase_right_count();\\n          node = node->right();\\n        } else {\\n          // node->value() > value\\n          node->increase_left_count();\\n          node = node->left();\\n        }\\n      }\\n    }\\n    \\n   private:\\n    TreeNode* build(const vector<int> &data) {\\n      vector<int> sorted_data(data);\\n      sort(sorted_data.begin(), sorted_data.end());\\n      const int n = static_cast<int>(sorted_data.size());\\n      return build_impl(sorted_data, 0, n);\\n    }\\n    \\n    TreeNode* build_impl(const vector<int> &data, const int begin, const int end) {\\n      if (begin == end) {\\n        return nullptr;\\n      }\\n      if (end - begin == 1) {\\n        return new TreeNode(data[begin]);\\n      }\\n      \\n      const int mid = begin + (end - begin) / 2;\\n      TreeNode *ret = new TreeNode(data[mid]);\\n      ret->set_left(build_impl(data, begin, mid));\\n      ret->set_right(build_impl(data, mid + 1, end));\\n      return ret;\\n    }\\n    \\n    TreeNode *root_;\\n  };\\n  \\n public:\\n  long long numberOfPairs(const vector<int> &nums1, const vector<int> &nums2, const int diff) {\\n    const int n = static_cast<int>(nums1.size());\\n    vector<int> diffs(n);\\n    for (int i = 0; i < n; ++i) {\\n      diffs[i] = nums1[i] - nums2[i];\\n    }\\n    \\n    long long ret = 0LL;\\n    Tree tree(diffs);\\n    for (const int current_diff : diffs) {\\n      ret += tree.count(current_diff + diff);\\n      tree.emplace(current_diff);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775837,
                "title": "c-solution-reverse-pairs-logic-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int dif=0;\\n    long long merge(vector<int>& nums,int low,int mid,int high){\\n        long long total=0;\\n        int j=mid+1;\\n        for(int i=low;i<=mid;i++){\\n\\t\\t//this is the logic we need to understand\\n\\t\\t//Ex: [4,5,6] [1,2,4] and diff=2\\n\\t\\t/* i=0 mid=2 j=3 high=5\\n\\t\\t\\ti=0 means we are at 4 and j=3 means we are 1 and diff=2\\n\\t\\t\\t4>1+2 true incr j\\n\\t\\t\\t4>2+2 false break\\n\\t\\t\\ttotal=total+(high-j+1) means from curr J position all elements(bcs all are greater(>2) els only) will satisify the condition\\n\\t\\t\\tso we take all elements into the count \\n\\t\\t\\tnow i=1 means 5 \\n\\t\\t\\t5>2+2 true incr j\\n\\t\\t\\t5>4+2 false\\n\\t\\t\\ttotal+= 5-5+1=1 means only last ele is satisfying \\n\\t\\t\\tnow i=2 means 6\\n\\t\\t\\t6>4+2 false\\n\\t\\t\\ttotal+=5-5+1 \\n\\t\\t*/\\n            while(j<=high and nums[i]>dif+nums[j]){\\n                j++;\\n            }\\n            total+=(high-j+1);\\n        }\\n        vector<int> temp;\\n        int left=low,right=mid+1;\\n        while(left<=mid and right<=high){\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }else{\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right<=high){\\n            temp.push_back(nums[right++]);\\n        }\\n        for(int i=low;i<=high;i++){\\n            nums[i]=temp[i-low];\\n        }\\n        return total;\\n    }\\n    long long merge_sort(vector<int>& nums,int left,int right){\\n        if(left>=right) return 0;\\n        int mid=left+(right-left)/2;\\n        long long count=0;\\n        count+=merge_sort(nums,left,mid);\\n        count+=merge_sort(nums,mid+1,right);\\n        count+=merge(nums,left,mid,right);\\n        return count;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> nums;\\n        dif=diff;\\n        int n=nums1.size();\\n\\t\\t/*\\n\\t\\tnums1[i]-nums1[j]<=nums2[i]-nums2[j]+diff\\n\\t\\tnums1[i]-nums2[i]<=nums1[j]-nums2[j]+diff\\n\\t\\tStore differences in another array call it as nums\\n\\t\\tnums[i]<=nums[j]+diff\\n\\t\\tthis is our new satisfiabilty equation\\n\\t\\tNow follow reverse pairs logic\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n        return merge_sort(nums,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dif=0;\\n    long long merge(vector<int>& nums,int low,int mid,int high){\\n        long long total=0;\\n        int j=mid+1;\\n        for(int i=low;i<=mid;i++){\\n\\t\\t//this is the logic we need to understand\\n\\t\\t//Ex: [4,5,6] [1,2,4] and diff=2\\n\\t\\t/* i=0 mid=2 j=3 high=5\\n\\t\\t\\ti=0 means we are at 4 and j=3 means we are 1 and diff=2\\n\\t\\t\\t4>1+2 true incr j\\n\\t\\t\\t4>2+2 false break\\n\\t\\t\\ttotal=total+(high-j+1) means from curr J position all elements(bcs all are greater(>2) els only) will satisify the condition\\n\\t\\t\\tso we take all elements into the count \\n\\t\\t\\tnow i=1 means 5 \\n\\t\\t\\t5>2+2 true incr j\\n\\t\\t\\t5>4+2 false\\n\\t\\t\\ttotal+= 5-5+1=1 means only last ele is satisfying \\n\\t\\t\\tnow i=2 means 6\\n\\t\\t\\t6>4+2 false\\n\\t\\t\\ttotal+=5-5+1 \\n\\t\\t*/\\n            while(j<=high and nums[i]>dif+nums[j]){\\n                j++;\\n            }\\n            total+=(high-j+1);\\n        }\\n        vector<int> temp;\\n        int left=low,right=mid+1;\\n        while(left<=mid and right<=high){\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }else{\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right<=high){\\n            temp.push_back(nums[right++]);\\n        }\\n        for(int i=low;i<=high;i++){\\n            nums[i]=temp[i-low];\\n        }\\n        return total;\\n    }\\n    long long merge_sort(vector<int>& nums,int left,int right){\\n        if(left>=right) return 0;\\n        int mid=left+(right-left)/2;\\n        long long count=0;\\n        count+=merge_sort(nums,left,mid);\\n        count+=merge_sort(nums,mid+1,right);\\n        count+=merge(nums,left,mid,right);\\n        return count;\\n    }\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        vector<int> nums;\\n        dif=diff;\\n        int n=nums1.size();\\n\\t\\t/*\\n\\t\\tnums1[i]-nums1[j]<=nums2[i]-nums2[j]+diff\\n\\t\\tnums1[i]-nums2[i]<=nums1[j]-nums2[j]+diff\\n\\t\\tStore differences in another array call it as nums\\n\\t\\tnums[i]<=nums[j]+diff\\n\\t\\tthis is our new satisfiabilty equation\\n\\t\\tNow follow reverse pairs logic\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n        return merge_sort(nums,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760208,
                "title": "python-3-time-o-nlogn-space-o-n",
                "content": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        d=[]\\n        for i in range(0,len(nums1)):\\n            d.append(nums1[i]-nums2[i])\\n        ans=0\\n        z=[]\\n        for i in range(len(d)-1,-1,-1):\\n            b=bisect.bisect_left(z,d[i]-diff)             \\n            ans+=max(0,len(z)-b)\\n            bisect.insort(z,d[i])\\n        return ans\\n```\\nfaster than 88.88%\\nMemory less than 93.60% of Python3 online submissions for Number of Pairs Satisfying Inequality.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        d=[]\\n        for i in range(0,len(nums1)):\\n            d.append(nums1[i]-nums2[i])\\n        ans=0\\n        z=[]\\n        for i in range(len(d)-1,-1,-1):\\n            b=bisect.bisect_left(z,d[i]-diff)             \\n            ans+=max(0,len(z)-b)\\n            bisect.insort(z,d[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738400,
                "title": "javascript-segment-tree",
                "content": "**Solution: Math & Segment Tree**\\n\\nThe equation `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff` can be converted into `nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff`.\\n\\nGo through each index `j`.\\n  Record all past index `i`\\'s differences (`nums1[i] - nums2[i]`).\\n  If `nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff`, we have a found a pair.\\n\\nUse a segment tree to keep track of the count of each (`nums1[i] - nums2[i]`).\\nFor each index `j`, find the number of previous index `i`\\'s with difference in the range of `(min(nums1[i] - nums2[i]), nums1[j] - nums2[j] + diff)`.\\n  Offset the segment tree by `min(nums1[i] - nums2[i]` so that we won\\'t go into negative indexes.\\n\\n`m = max(nums1[i] - nums2[i])`\\nTime Complexity: `O(n log(m))` 226ms\\nSpace Complexity: `O(m)` 55.3MB\\n```\\nvar numberOfPairs = function(nums1, nums2, diff) {\\n  let offset = 0, maxDiff = -Infinity, n = nums1.length;\\n  for (let i = 0; i < n; i++) {\\n    offset = Math.min(offset, nums1[i] - nums2[i]);\\n    maxDiff = Math.max(maxDiff, nums1[i] - nums2[i]);\\n  }\\n  offset = Math.abs(offset);\\n  maxDiff += offset;\\n\\n  let segTree = new SegmentTree(maxDiff + 1), res = 0;\\n  for (let j = 0; j < n; j++) {\\n    let maxRange = Math.min(maxDiff, nums1[j] - nums2[j] + diff + offset);\\n    let pairs = segTree.sumRange(0, maxRange);\\n    res += pairs;\\n    segTree.update(nums1[j] - nums2[j] + offset, 1);\\n  }\\n  return res;\\n};\\n\\nclass SegmentTree {\\n  constructor(n) {\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n  }\\n  update(index, val) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] += val;\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = this.segTree[idx * 2] + this.segTree[idx * 2 + 1];\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  sumRange(left, right) {\\n    if (left > right) return 0;\\n    let n = this.size, sum = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    // left must be even, right must be odd\\n    // when left is odd or right is even, this indicates partial coverage. \\n    // in other words, the parent node will be covering a range outside of the range we are looking for.\\n    // so, we need to take the partial sum and move the pointers so that it has full coverage.\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) sum += this.segTree[left_idx++];\\n      if (right_idx % 2 === 0) sum += this.segTree[right_idx--];\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfPairs = function(nums1, nums2, diff) {\\n  let offset = 0, maxDiff = -Infinity, n = nums1.length;\\n  for (let i = 0; i < n; i++) {\\n    offset = Math.min(offset, nums1[i] - nums2[i]);\\n    maxDiff = Math.max(maxDiff, nums1[i] - nums2[i]);\\n  }\\n  offset = Math.abs(offset);\\n  maxDiff += offset;\\n\\n  let segTree = new SegmentTree(maxDiff + 1), res = 0;\\n  for (let j = 0; j < n; j++) {\\n    let maxRange = Math.min(maxDiff, nums1[j] - nums2[j] + diff + offset);\\n    let pairs = segTree.sumRange(0, maxRange);\\n    res += pairs;\\n    segTree.update(nums1[j] - nums2[j] + offset, 1);\\n  }\\n  return res;\\n};\\n\\nclass SegmentTree {\\n  constructor(n) {\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n  }\\n  update(index, val) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] += val;\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = this.segTree[idx * 2] + this.segTree[idx * 2 + 1];\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  sumRange(left, right) {\\n    if (left > right) return 0;\\n    let n = this.size, sum = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    // left must be even, right must be odd\\n    // when left is odd or right is even, this indicates partial coverage. \\n    // in other words, the parent node will be covering a range outside of the range we are looking for.\\n    // so, we need to take the partial sum and move the pointers so that it has full coverage.\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) sum += this.segTree[left_idx++];\\n      if (right_idx % 2 === 0) sum += this.segTree[right_idx--];\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727209,
                "title": "python3-binary-search",
                "content": "The selection criteria is equivalent to:\\nnums1[i]-nums2[i] <= nums1[j]-nums2[j] + diff\\nDefine diffList as the difference of nums1 and nums2\\n=> diffList[i] < diffList[j] + diff\\n\\nIterate the diffList backward and store the thresholds\\nFor each diffList[i], count how many existing thresholds is larger than diffList[i], add the number to # of valid pairs,  and insert the new threshold diffList[i]+diff to the list\\n```\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        # nums1[i]-nums2[i] <= nums1[j]-nums2[j] + diff\\n        diffList = []\\n        for i in range(len(nums1)):\\n            diffList.append(nums1[i]-nums2[i])\\n         \\n        threshold = []\\n        nTotal = 0\\n        for j in range(len(diffList)-1,-1,-1):\\n            val = diffList[j]\\n            nValid = len(threshold) - bisect.bisect_left(threshold,val)\\n            nTotal += nValid\\n            bisect.insort(threshold,val+diff)\\n            \\n        return nTotal\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        # nums1[i]-nums2[i] <= nums1[j]-nums2[j] + diff\\n        diffList = []\\n        for i in range(len(nums1)):\\n            diffList.append(nums1[i]-nums2[i])\\n         \\n        threshold = []\\n        nTotal = 0\\n        for j in range(len(diffList)-1,-1,-1):\\n            val = diffList[j]\\n            nValid = len(threshold) - bisect.bisect_left(threshold,val)\\n            nTotal += nValid\\n            bisect.insort(threshold,val+diff)\\n            \\n        return nTotal\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2704267,
                "title": "c-fenwick-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    struct node {\\n        int idx, val;\\n    };\\n    vector<node> D;        \\n    \\n    int tree[100001];\\n    // Fenwick tree\\n    void f_update (int loc, int val, int n) {\\n        while(loc <= n) {\\n            tree[loc] += val;\\n            loc += (loc & -loc);\\n        }\\n    }\\n    \\n    int f_query (int loc) {\\n        int ret = 0;\\n        while(loc > 0) {\\n            ret += tree[loc];\\n            loc -= (loc & -loc);\\n        }\\n        return ret;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {        \\n        // nums1[i] - nums2[i] - diff <= nums2[j] - nums2[j]\\n        // D[i] = nums1[i] - nums2[i]\\n        // D[i] - diff <= D[j] , i < j        \\n        int n = nums1.size();\\n        \\n        //get D[i]\\n        //tree update for all\\n        for (int i=0; i<n; ++i) {\\n            D.push_back({i+1, nums1[i] - nums2[i]});\\n            f_update(i+1, 1, n);\\n        }\\n        // sort by D[i]\\n        sort(D.begin(), D.end(), [](const node &a, const node &b){\\n            return a.val < b.val;\\n        });\\n        \\n        long long ans = 0;\\n        int val = 0;\\n        int loc = 0;\\n        for (int i=0; i<n; ++i) {\\n            val = D[i].val - diff; // base value\\n            // count down for D[loc] under val in the tree\\n            while(loc<n && D[loc].val < val) {  \\n                f_update(D[loc].idx, -1, n);\\n                ++loc;\\n            }\\n            // query count for j greater than i\\n            ans += f_query(n) - f_query(D[i].idx);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node {\\n        int idx, val;\\n    };\\n    vector<node> D;        \\n    \\n    int tree[100001];\\n    // Fenwick tree\\n    void f_update (int loc, int val, int n) {\\n        while(loc <= n) {\\n            tree[loc] += val;\\n            loc += (loc & -loc);\\n        }\\n    }\\n    \\n    int f_query (int loc) {\\n        int ret = 0;\\n        while(loc > 0) {\\n            ret += tree[loc];\\n            loc -= (loc & -loc);\\n        }\\n        return ret;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {        \\n        // nums1[i] - nums2[i] - diff <= nums2[j] - nums2[j]\\n        // D[i] = nums1[i] - nums2[i]\\n        // D[i] - diff <= D[j] , i < j        \\n        int n = nums1.size();\\n        \\n        //get D[i]\\n        //tree update for all\\n        for (int i=0; i<n; ++i) {\\n            D.push_back({i+1, nums1[i] - nums2[i]});\\n            f_update(i+1, 1, n);\\n        }\\n        // sort by D[i]\\n        sort(D.begin(), D.end(), [](const node &a, const node &b){\\n            return a.val < b.val;\\n        });\\n        \\n        long long ans = 0;\\n        int val = 0;\\n        int loc = 0;\\n        for (int i=0; i<n; ++i) {\\n            val = D[i].val - diff; // base value\\n            // count down for D[loc] under val in the tree\\n            while(loc<n && D[loc].val < val) {  \\n                f_update(D[loc].idx, -1, n);\\n                ++loc;\\n            }\\n            // query count for j greater than i\\n            ans += f_query(n) - f_query(D[i].idx);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699839,
                "title": "easy-understanding-merge-sort",
                "content": "```\\nclass Solution {\\n    long long int ans = 0;\\n     void merge(int l,int m,int r,vector<int>&c,int d) {\\n         int start = l , end = m+1;\\n         while(start<=m && end<=r) {\\n               if(c[start]<=c[end]+d) {\\n                   ans+=(r - end + 1);\\n                   start++;\\n               }else {\\n                   end++;\\n               }\\n         }\\n        sort(c.begin()+l,c.begin()+r+1);\\n    }\\n    void mergeSort(int  l,int r,vector<int> &nums,int diff)\\n    {\\n        if(l == r)\\n        {\\n            return;\\n        }\\n        \\n        int mid = (r+l)/2;\\n        mergeSort(l,mid,nums,diff);\\n        mergeSort(mid+1,r,nums,diff);\\n        merge(l,mid,r,nums,diff);\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n        \\n        mergeSort(0,n-1,nums,diff);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    long long int ans = 0;\\n     void merge(int l,int m,int r,vector<int>&c,int d) {\\n         int start = l , end = m+1;\\n         while(start<=m && end<=r) {\\n               if(c[start]<=c[end]+d) {\\n                   ans+=(r - end + 1);\\n                   start++;\\n               }else {\\n                   end++;\\n               }\\n         }\\n        sort(c.begin()+l,c.begin()+r+1);\\n    }\\n    void mergeSort(int  l,int r,vector<int> &nums,int diff)\\n    {\\n        if(l == r)\\n        {\\n            return;\\n        }\\n        \\n        int mid = (r+l)/2;\\n        mergeSort(l,mid,nums,diff);\\n        mergeSort(mid+1,r,nums,diff);\\n        merge(l,mid,r,nums,diff);\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n = nums1.size();\\n        vector<int> nums(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = nums1[i] - nums2[i];\\n        }\\n        \\n        mergeSort(0,n-1,nums,diff);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695589,
                "title": "easy-math-in-6-lines-of-python-fully-explained",
                "content": "The original inequality (1) can be rewritten as (2) as follows:\\n\\n1. nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n2. nums1[i] - nums2[i] - diff <= nums1[j] - nums2[j]\\n\\nAt each step of `j`, we just need to sum up the number of previuos step `i` that `nums1[i] - nums2[i] - diff <= nums1[j] - nums2[j]`. \\nTo speed up, all the previuos values of `nums1[i] - nums2[i] - diff` can be precalculated and stored in a sorted container such as SortedList in Python. \\n\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        tree = SortedList()        \\n        ans = 0\\n        for a, b in zip(nums1, nums2):\\n            ans += tree.bisect_right(a - b)\\n            tree.add(a - b - diff)\\n        return ans",
                "solutionTags": [
                    "Math",
                    "Binary Search Tree"
                ],
                "code": "The original inequality (1) can be rewritten as (2) as follows:\\n\\n1. nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n2. nums1[i] - nums2[i] - diff <= nums1[j] - nums2[j]\\n\\nAt each step of `j`, we just need to sum up the number of previuos step `i` that `nums1[i] - nums2[i] - diff <= nums1[j] - nums2[j]`. \\nTo speed up, all the previuos values of `nums1[i] - nums2[i] - diff` can be precalculated and stored in a sorted container such as SortedList in Python. \\n\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        tree = SortedList()        \\n        ans = 0\\n        for a, b in zip(nums1, nums2):\\n            ans += tree.bisect_right(a - b)\\n            tree.add(a - b - diff)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2691087,
                "title": "3-methods-mergesort-segementtree-sortedcontainer",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        #n1[i] - n2[i] <= d + n1[j] - n2[j]\\n        #left <= right\\n        n = len(nums1)\\n        left = SortedList()\\n\\n        count = 0\\n        for r_i in range(1, n):\\n            #j is strictly less than thats why we only add upto r_i - i\\n            left.add(nums1[r_i - 1] - nums2[r_i - 1])\\n            c_right = diff + nums1[r_i] - nums2[r_i]\\n\\n            #find index of first element more than d + n1[j] - n2[j]\\n            #so everything to the left of index must be <= d + n1[j] - n2[j]\\n            idx = left.bisect_right(c_right)\\n            count += idx\\n\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Segment Tree",
                    "Ordered Map",
                    "Merge Sort"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        #n1[i] - n2[i] <= d + n1[j] - n2[j]\\n        #left <= right\\n        n = len(nums1)\\n        left = SortedList()\\n\\n        count = 0\\n        for r_i in range(1, n):\\n            #j is strictly less than thats why we only add upto r_i - i\\n            left.add(nums1[r_i - 1] - nums2[r_i - 1])\\n            c_right = diff + nums1[r_i] - nums2[r_i]\\n\\n            #find index of first element more than d + n1[j] - n2[j]\\n            #so everything to the left of index must be <= d + n1[j] - n2[j]\\n            idx = left.bisect_right(c_right)\\n            count += idx\\n\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691085,
                "title": "3-methods-mergesort-segementtree-sortedcontainer",
                "content": "I will add the segment tree approach and merge sort approach soon. In the mean time read and understand the SortedContainer/OrderedMap approach\\nMake sure to understand the logic first, all 3 methods are basically same just different data structure\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        #n1[i] - n2[i] <= d + n1[j] - n2[j]\\n        #left <= right\\n        n = len(nums1)\\n        left = SortedList()\\n\\n        count = 0\\n        for r_i in range(1, n):\\n            #j is strictly less than thats why we only add upto r_i - i\\n            left.add(nums1[r_i - 1] - nums2[r_i - 1])\\n            c_right = diff + nums1[r_i] - nums2[r_i]\\n\\n            #find index of first element more than d + n1[j] - n2[j]\\n            #so everything to the left of index must be <= d + n1[j] - n2[j]\\n            idx = left.bisect_right(c_right)\\n            count += idx\\n\\n        return count\\n\\n        #segment tree approach -> TODO\\n\\n        #merge sort approach -> TODO\\n\\n\\n```",
                "solutionTags": [
                    "Segment Tree",
                    "Ordered Map",
                    "Merge Sort"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        #n1[i] - n2[i] <= d + n1[j] - n2[j]\\n        #left <= right\\n        n = len(nums1)\\n        left = SortedList()\\n\\n        count = 0\\n        for r_i in range(1, n):\\n            #j is strictly less than thats why we only add upto r_i - i\\n            left.add(nums1[r_i - 1] - nums2[r_i - 1])\\n            c_right = diff + nums1[r_i] - nums2[r_i]\\n\\n            #find index of first element more than d + n1[j] - n2[j]\\n            #so everything to the left of index must be <= d + n1[j] - n2[j]\\n            idx = left.bisect_right(c_right)\\n            count += idx\\n\\n        return count\\n\\n        #segment tree approach -> TODO\\n\\n        #merge sort approach -> TODO\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684534,
                "title": "python-merge-sort-solution-reuseable-framework",
                "content": "```\\ndef numberOfPairs(self, nums1: List[int], nums2: List[int], d: int) -> int:\\n\\tnums = [nums1[i]-nums2[i] for i in range(len(nums1))]\\n\\tself.ans = 0\\n\\n\\tdef msort(arr, lo, hi):\\n\\t\\tif lo<hi:\\n\\t\\t\\tmid = (lo+hi)//2\\n\\t\\t\\tmsort(arr, lo, mid)\\n\\t\\t\\tmsort(arr, mid+1, hi)\\n\\t\\t\\tmerge(arr, lo, mid, hi)\\n\\n\\tdef merge(arr, a, mid, b):\\n\\t\\ti, j, lst = a, mid+1, []\\n\\t\\twhile(i<=mid and j<=b):\\n\\t\\t\\tif arr[i]<=arr[j]:\\n\\t\\t\\t\\tlst.append(arr[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlst.append(arr[j])\\n\\t\\t\\t\\tj += 1\\n\\t\\tlst.extend(arr[i:mid+1])\\n\\t\\tlst.extend(arr[j:b+1])\\n\\n\\t\\t###################\\n\\t\\t# additioal code for counting pairs           \\n\\t\\ti, j = a, mid+1\\n\\t\\twhile(i<=mid and j<=b):\\n\\t\\t\\tif arr[i]<=arr[j]+d:\\n\\t\\t\\t\\tself.ans += (b-j+1)\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tj += 1\\n\\t\\t####################\\n\\n\\t\\tarr[a:b+1] = lst\\n\\n\\tmsort(nums, 0, len(nums)-1)\\n\\treturn self.ans\\n```\\nOther problems can be solved with merge-sort framework\\n[Leetcode 315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/2516771/Python-solution-or-merge-sort-framework)\\n[Leetcode 327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/discuss/2516769/Python-solution-or-merge-sort-framework)\\n[Leetcode 493. Reverse Pairs](https://leetcode.com/problems/reverse-pairs/discuss/2516098/Python-solution-or-merge-sort-framework)",
                "solutionTags": [],
                "code": "```\\ndef numberOfPairs(self, nums1: List[int], nums2: List[int], d: int) -> int:\\n\\tnums = [nums1[i]-nums2[i] for i in range(len(nums1))]\\n\\tself.ans = 0\\n\\n\\tdef msort(arr, lo, hi):\\n\\t\\tif lo<hi:\\n\\t\\t\\tmid = (lo+hi)//2\\n\\t\\t\\tmsort(arr, lo, mid)\\n\\t\\t\\tmsort(arr, mid+1, hi)\\n\\t\\t\\tmerge(arr, lo, mid, hi)\\n\\n\\tdef merge(arr, a, mid, b):\\n\\t\\ti, j, lst = a, mid+1, []\\n\\t\\twhile(i<=mid and j<=b):\\n\\t\\t\\tif arr[i]<=arr[j]:\\n\\t\\t\\t\\tlst.append(arr[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlst.append(arr[j])\\n\\t\\t\\t\\tj += 1\\n\\t\\tlst.extend(arr[i:mid+1])\\n\\t\\tlst.extend(arr[j:b+1])\\n\\n\\t\\t###################\\n\\t\\t# additioal code for counting pairs           \\n\\t\\ti, j = a, mid+1\\n\\t\\twhile(i<=mid and j<=b):\\n\\t\\t\\tif arr[i]<=arr[j]+d:\\n\\t\\t\\t\\tself.ans += (b-j+1)\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tj += 1\\n\\t\\t####################\\n\\n\\t\\tarr[a:b+1] = lst\\n\\n\\tmsort(nums, 0, len(nums)-1)\\n\\treturn self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2676229,
                "title": "c-segment-tree-binary-search",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll count(ll l , ll r , vector<int>& n , int d) {\\n        if(l == r)\\n            return 0;\\n        \\n        ll mid = (l + r)>>1;\\n        \\n        ll result = count(l , mid , n , d) + count(mid + 1 , r , n , d);\\n        \\n        vector<int> s;\\n        for(int i = l ; i <= mid ; i++) {\\n            s.push_back(n[i]);\\n        }\\n        \\n        sort(s.begin() , s.end());\\n        \\n        for(int j = mid + 1 ; j <= r ; j++) {\\n            ll mx = d + n[j];\\n            \\n            result += upper_bound(s.begin() , s.end() , mx) - s.begin();\\n        }\\n        return result;\\n    }\\n    \\n    ll numberOfPairs(vector<int>& nums1, vector<int>& nums2, int d) {\\n    \\n        int n = nums1.size();\\n        \\n        vector<int> dif;\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            dif.push_back(nums1[i] - nums2[i]);\\n        }\\n        \\n        return count(0 , n - 1 , dif , d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll count(ll l , ll r , vector<int>& n , int d) {\\n        if(l == r)\\n            return 0;\\n        \\n        ll mid = (l + r)>>1;\\n        \\n        ll result = count(l , mid , n , d) + count(mid + 1 , r , n , d);\\n        \\n        vector<int> s;\\n        for(int i = l ; i <= mid ; i++) {\\n            s.push_back(n[i]);\\n        }\\n        \\n        sort(s.begin() , s.end());\\n        \\n        for(int j = mid + 1 ; j <= r ; j++) {\\n            ll mx = d + n[j];\\n            \\n            result += upper_bound(s.begin() , s.end() , mx) - s.begin();\\n        }\\n        return result;\\n    }\\n    \\n    ll numberOfPairs(vector<int>& nums1, vector<int>& nums2, int d) {\\n    \\n        int n = nums1.size();\\n        \\n        vector<int> dif;\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            dif.push_back(nums1[i] - nums2[i]);\\n        }\\n        \\n        return count(0 , n - 1 , dif , d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672120,
                "title": "c-bit",
                "content": "\\n```\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n```\\n\\nFormula can be rewrite as\\n```\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff.\\n```\\n\\nfor 0 <= j < n, we need to calculate how many i (0 <= i < j) satisfied the formula, and it could be easily done by Fenwick tree\\n\\n```\\nusing ll = long long;\\nconst int off = 3e4+5;\\nconst int nax = 1e5+5;\\nint bits[nax];\\nclass Solution {\\npublic:\\n    void add(int x) {\\n        x += off;\\n        while (x < nax) {\\n            bits[x]++;\\n            x += x&-x;\\n        }\\n    }\\n    \\n    ll q(int x) {\\n        x += off;\\n        ll s = 0;\\n        while (x > 0) {\\n            s += bits[x];\\n            x -= x&-x;\\n        }\\n        return s;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int diff) {\\n        int n = a.size();\\n        memset(bits, 0, sizeof(bits));\\n        int p = 0;\\n        ll ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (i > 0)\\n                add(a[i-1]-b[i-1]);\\n            \\n            ll v = a[i]-b[i]+diff;\\n            ans += q(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff\\n```\n```\\nnums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff.\\n```\n```\\nusing ll = long long;\\nconst int off = 3e4+5;\\nconst int nax = 1e5+5;\\nint bits[nax];\\nclass Solution {\\npublic:\\n    void add(int x) {\\n        x += off;\\n        while (x < nax) {\\n            bits[x]++;\\n            x += x&-x;\\n        }\\n    }\\n    \\n    ll q(int x) {\\n        x += off;\\n        ll s = 0;\\n        while (x > 0) {\\n            s += bits[x];\\n            x -= x&-x;\\n        }\\n        return s;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& a, vector<int>& b, int diff) {\\n        int n = a.size();\\n        memset(bits, 0, sizeof(bits));\\n        int p = 0;\\n        ll ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (i > 0)\\n                add(a[i-1]-b[i-1]);\\n            \\n            ll v = a[i]-b[i]+diff;\\n            ans += q(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670282,
                "title": "why-am-i-gettling-mle",
                "content": "```\\nclass Solution {\\npublic:\\n    long long  merge(vector<int> &a,int l,int mid,int r,int &d){\\n        int le=l,k=l,re=mid;\\n        long long  ans=0;\\n        while(le<mid && re<=r){\\n            if(a[le]<=a[re]+d){\\n                le++; ans+=(r-re+1);}\\n            else\\n                re++;\\n        }\\n        le=l,re=mid;\\n        vector<int> temp(a.size());\\n        while(le<mid && re<=r){\\n            if(a[le]<=a[re])\\n                temp[k++]=a[le++];\\n            else\\n                temp[k++]=a[re++];\\n        }\\n        while(le<mid)\\n            temp[k++]=a[le++];\\n        while(re<=r)\\n            temp[k++]=a[re++];\\n        for(int i=l;i<=r;i++)\\n            a[i]=temp[i];\\n        return ans;\\n    }\\n    long long  divide(vector<int> &a,int l,int r,int &d){\\n        if(l>=r)\\n            return 0;\\n        long long  ans=0;\\n        int mid=(l+r)/2;\\n        ans+=divide(a,l,mid,d);\\n        ans+=divide(a,mid+1,r,d);\\n        ans+=merge(a,l,mid+1,r,d);\\n        return ans;\\n    }\\n    long long numberOfPairs(vector<int>& a, vector<int>& b1, int d) {\\n        // vector<int> a(a1.size());\\n        for(int i=0;i<a.size();i++){\\n            a[i]=a[i]-b1[i];\\n        }\\n        return divide(a,0,a.size()-1,d);\\n    }\\n};",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "class Solution {\\npublic:\\n    long long  merge(vector<int> &a,int l,int mid,int r,int &d){\\n        int le=l,k=l,re=mid;\\n        long long  ans=0;\\n        while(le<mid && re<=r){\\n            if(a[le]<=a[re]+d){\\n                le++; ans+=(r-re+1);}",
                "codeTag": "Java"
            },
            {
                "id": 2669340,
                "title": "segment-tree-map-set-c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int seg[400001];\\n    void update(int index,int l,int r,int &val){\\n        if(l>=r){\\n            seg[index]++;\\n            return ;\\n        }\\n        int m=(l+r)/2;\\n        if(val<=m){\\n            update(2*index+1,l,m,val);\\n        }\\n        else update(2*index+2,m+1,r,val);\\n        \\n        seg[index]=seg[2*index+1]+seg[2*index+2];\\n        return ;\\n    }\\n    int find(int index,int l,int r,int left,int &right){\\n        if(left<=l && r<=right){\\n            return seg[index];\\n        }\\n        if(r<left || right<l){\\n            return 0;\\n        }\\n        int m=(l+r)/2;\\n        int cntl=find(2*index+1,l,m,left,right);\\n        int cntr=find(2*index+2,m+1,r,left,right);\\n        return cntl+cntr;\\n    }\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        int n=A.size();\\n        int maxi=-10001;\\n        set<int> s;\\n        for(int i=0;i<n;i++){\\n            A[i]-=B[i];\\n            s.insert(A[i]);\\n            maxi=max(maxi,A[i]);\\n        }\\n        int m=s.size();\\n        int k=0;\\n        map<int,int> mp;\\n\\t\\t// map A[i]-B[i] value to it index according acending order of value\\n        for(auto it=s.begin();it!=s.end();it++){\\n            int val=*it;\\n            mp[val]=k;\\n            k++;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n\\t\\t// find upper bound of A[i]-B[i]+diff\\n            auto it=mp.upper_bound(A[i]+diff);\\n            if(it!=mp.begin()){\\n                it--;\\n\\t\\t\\t\\t// find number of values in range 0,it->second;\\n                int val=find(0,0,m-1,0,it->second);\\n                ans+=val;\\n            }\\n\\t\\t\\t// update in cur value in seg ment tree\\n            update(0,0,m-1,mp[A[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int seg[400001];\\n    void update(int index,int l,int r,int &val){\\n        if(l>=r){\\n            seg[index]++;\\n            return ;\\n        }\\n        int m=(l+r)/2;\\n        if(val<=m){\\n            update(2*index+1,l,m,val);\\n        }\\n        else update(2*index+2,m+1,r,val);\\n        \\n        seg[index]=seg[2*index+1]+seg[2*index+2];\\n        return ;\\n    }\\n    int find(int index,int l,int r,int left,int &right){\\n        if(left<=l && r<=right){\\n            return seg[index];\\n        }\\n        if(r<left || right<l){\\n            return 0;\\n        }\\n        int m=(l+r)/2;\\n        int cntl=find(2*index+1,l,m,left,right);\\n        int cntr=find(2*index+2,m+1,r,left,right);\\n        return cntl+cntr;\\n    }\\n    long long numberOfPairs(vector<int>& A, vector<int>& B, int diff) {\\n        int n=A.size();\\n        int maxi=-10001;\\n        set<int> s;\\n        for(int i=0;i<n;i++){\\n            A[i]-=B[i];\\n            s.insert(A[i]);\\n            maxi=max(maxi,A[i]);\\n        }\\n        int m=s.size();\\n        int k=0;\\n        map<int,int> mp;\\n\\t\\t// map A[i]-B[i] value to it index according acending order of value\\n        for(auto it=s.begin();it!=s.end();it++){\\n            int val=*it;\\n            mp[val]=k;\\n            k++;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n\\t\\t// find upper bound of A[i]-B[i]+diff\\n            auto it=mp.upper_bound(A[i]+diff);\\n            if(it!=mp.begin()){\\n                it--;\\n\\t\\t\\t\\t// find number of values in range 0,it->second;\\n                int val=find(0,0,m-1,0,it->second);\\n                ans+=val;\\n            }\\n\\t\\t\\t// update in cur value in seg ment tree\\n            update(0,0,m-1,mp[A[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668528,
                "title": "golang-binary-indexed-tree",
                "content": "```\\nfunc numberOfPairs(nums1 []int, nums2 []int, diff int) int64 {\\n    t := BIT{tree: make([]int, 60001)}\\n    offset := 30001\\n    res := 0\\n    for i := len(nums1) - 1; i >= 0; i-- {        \\n        res += len(nums1) - i - 1 - t.get(nums1[i] - nums2[i] - diff + offset - 1)\\n        t.add(nums1[i] - nums2[i] + offset, 1)\\n    }\\n    return int64(res)\\n}\\n\\ntype BIT struct {\\n    tree []int\\n}\\n\\nfunc(t BIT) get(i int) int {\\n    res := 0\\n    for i > 0 {\\n        res += t.tree[i]\\n        i = i & (i - 1)\\n    }\\n    return res\\n}\\n\\nfunc(t BIT) add(i int, diff int) {\\n    for i < len(t.tree) {\\n        t.tree[i] += diff\\n        i = i + i - i & (i - 1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numberOfPairs(nums1 []int, nums2 []int, diff int) int64 {\\n    t := BIT{tree: make([]int, 60001)}\\n    offset := 30001\\n    res := 0\\n    for i := len(nums1) - 1; i >= 0; i-- {        \\n        res += len(nums1) - i - 1 - t.get(nums1[i] - nums2[i] - diff + offset - 1)\\n        t.add(nums1[i] - nums2[i] + offset, 1)\\n    }\\n    return int64(res)\\n}\\n\\ntype BIT struct {\\n    tree []int\\n}\\n\\nfunc(t BIT) get(i int) int {\\n    res := 0\\n    for i > 0 {\\n        res += t.tree[i]\\n        i = i & (i - 1)\\n    }\\n    return res\\n}\\n\\nfunc(t BIT) add(i int, diff int) {\\n    for i < len(t.tree) {\\n        t.tree[i] += diff\\n        i = i + i - i & (i - 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668314,
                "title": "c-merge-sort-approch",
                "content": "**Approch** :-\\n1.] First we need to analyse a part of question which is *nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff*\\n2.] by rearrenging the equation we get *nums1[i]-nums2[i] <= nums1[j]-nums2[j] + diff*\\n3.] So create a new array of length same as nums1 ans nums2 store **new_array[i] = nums1[i] - nums2[i]**\\n4.] Now apply Merge sort logic in which we have to part of array which is low-->mid-->high\\n5.] so merge that two part and while doing this first check **if( new_array[i] <= new_array[j] + diff )** so add **high-j+1** becoz we all now in merge sort the both part of array is sorted in itself range so if some **i** give ans with **j** so definatly all the element form **j to high** going to give ans.\\n\\n**c++ code** \\n```\\nclass Solution {\\nprivate:\\n    long long ans=0;\\n    int d;\\npublic:\\n    \\n    void merege(vector<int> &nums, int low, int mid, int high){\\n       int l=low,r=mid+1;\\n        \\n        while(l<=mid && r<=high){\\n            if(nums[l]<=nums[r]+d){\\n                ans+=high-r+1;\\n                l++;\\n            }\\n            else{\\n                r++;\\n            }\\n        }\\n        sort(nums.begin()+low, nums.begin()+high+1);\\n        \\n    }\\n    \\n    void mergeSort(vector<int> &nums, int low, int high){\\n        if(low>=high){\\n            return;\\n        }\\n        int mid=low+(high-low)/2;\\n        mergeSort(nums,low,mid);\\n        mergeSort(nums,mid+1,high);\\n        merege(nums,low,mid,high);\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            nums1[i]-=nums2[i];\\n        }\\n        d=diff;\\n        mergeSort(nums1,0,n-1);\\n       \\n        \\n        return ans;\\n    }\\n};\\n//code by sachin\\n```\\n**Upvote is solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long ans=0;\\n    int d;\\npublic:\\n    \\n    void merege(vector<int> &nums, int low, int mid, int high){\\n       int l=low,r=mid+1;\\n        \\n        while(l<=mid && r<=high){\\n            if(nums[l]<=nums[r]+d){\\n                ans+=high-r+1;\\n                l++;\\n            }\\n            else{\\n                r++;\\n            }\\n        }\\n        sort(nums.begin()+low, nums.begin()+high+1);\\n        \\n    }\\n    \\n    void mergeSort(vector<int> &nums, int low, int high){\\n        if(low>=high){\\n            return;\\n        }\\n        int mid=low+(high-low)/2;\\n        mergeSort(nums,low,mid);\\n        mergeSort(nums,mid+1,high);\\n        merege(nums,low,mid,high);\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            nums1[i]-=nums2[i];\\n        }\\n        d=diff;\\n        mergeSort(nums1,0,n-1);\\n       \\n        \\n        return ans;\\n    }\\n};\\n//code by sachin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668007,
                "title": "damm-this-merge-sort-solution-is-so-good-and-clear",
                "content": "```\\n#define ll long long int\\nclass Solution {\\n    \\n    ll ValidPairs(int l,int r,vector<ll>&nums,ll diff){\\n        if(l==r) return 0;\\n        \\n        int m=(l+r)>>1;\\n        ll result=ValidPairs(l,m,nums,diff)+ValidPairs(m+1,r,nums,diff);\\n        \\n        int l1=l,r1=m,l2=m+1,r2=r;\\n        vector<ll>merged;\\n        \\n        for(int j=l2;j<=r2;j++){\\n            ll mx_allowed=nums[j]+diff;\\n            int ind=upper_bound(nums.begin()+l1,nums.begin()+r1+1,mx_allowed)-nums.begin()-1;\\n            if(ind<=r1) result+=(ind-l1+1);\\n        }\\n        \\n        while(l1<=r1 && l2<=r2){\\n            if(nums[l1]<=nums[l2])\\n                merged.push_back(nums[l1++]);\\n            else\\n                merged.push_back(nums[l2++]);\\n        }\\n        while(l2<=r2) merged.push_back(nums[l2++]);\\n        while(l1<=r1) merged.push_back(nums[l1++]);\\n        \\n        for(int j=l;j<=r;j++)\\n            nums[j]=merged[j-l];\\n        \\n        return result;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        vector<ll>nums(n);\\n        \\n        for(int j=0;j<n;j++)\\n            nums[j]=nums1[j]-nums2[j];\\n        \\n        return ValidPairs(0,n-1,nums,diff);\\n    }\\n};\\n\\n```\\n\\n\\nthis solution is well explained by a youtube. i will leave the link here- https://www.youtube.com/watch?v=USh4o9_9hn0&ab_channel=codingMohan",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    \\n    ll ValidPairs(int l,int r,vector<ll>&nums,ll diff){\\n        if(l==r) return 0;\\n        \\n        int m=(l+r)>>1;\\n        ll result=ValidPairs(l,m,nums,diff)+ValidPairs(m+1,r,nums,diff);\\n        \\n        int l1=l,r1=m,l2=m+1,r2=r;\\n        vector<ll>merged;\\n        \\n        for(int j=l2;j<=r2;j++){\\n            ll mx_allowed=nums[j]+diff;\\n            int ind=upper_bound(nums.begin()+l1,nums.begin()+r1+1,mx_allowed)-nums.begin()-1;\\n            if(ind<=r1) result+=(ind-l1+1);\\n        }\\n        \\n        while(l1<=r1 && l2<=r2){\\n            if(nums[l1]<=nums[l2])\\n                merged.push_back(nums[l1++]);\\n            else\\n                merged.push_back(nums[l2++]);\\n        }\\n        while(l2<=r2) merged.push_back(nums[l2++]);\\n        while(l1<=r1) merged.push_back(nums[l1++]);\\n        \\n        for(int j=l;j<=r;j++)\\n            nums[j]=merged[j-l];\\n        \\n        return result;\\n    }\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        int n=nums1.size();\\n        vector<ll>nums(n);\\n        \\n        for(int j=0;j<n;j++)\\n            nums[j]=nums1[j]-nums2[j];\\n        \\n        return ValidPairs(0,n-1,nums,diff);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665995,
                "title": "using-merge-sort",
                "content": "```\\nclass Solution {\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        \\n        for(int i = 0; i < n; ++i) nums1[i] -= nums2[i];\\n        return mergeSort(nums1, new int[n], 0, n - 1, diff);\\n    }\\n    \\n    public long mergeSort(int[] nums, int[] temp, int l, int r, int diff) {\\n        if(l < r) {\\n            int m = (l + r)/2;\\n            long ans = 0;\\n            ans += mergeSort(nums, temp, l, m, diff);\\n            ans += mergeSort(nums, temp, m+1, r, diff);\\n            ans += merge(nums, temp, l, m+1, r, diff);\\n            return ans;\\n        }\\n        return 0;\\n    }\\n    \\n    public long merge(int[] nums, int[] temp, int l, int m, int r, int diff) {\\n        long res = 0;\\n        \\n        for(int i = m; i <= r; ++i) {\\n            int up = upperbound(nums, diff + nums[i], l, m-1);\\n            if(up <= m) res += (up - l );\\n        }\\n        \\n        int i = l, j = m, k = l;\\n        while(i < m && j <= r) {\\n            if(nums[i] < nums[j]) {\\n                temp[k++] = nums[i++];\\n            }else {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n        \\n        while(i < m) {\\n            temp[k++] = nums[i++];\\n        }\\n        \\n        while(j <= r) {\\n            temp[k++] = nums[j++];\\n        }\\n        \\n        for(int pos = l; pos <= r; ++pos) {\\n            nums[pos] = temp[pos];\\n        } \\n        return res;\\n    }\\n    \\n    public int upperbound(int[] arr, int target, int l, int r) {\\n        int ans = r+1;\\n        while(l <= r) {\\n            int m = (l + r)/2;\\n            if(arr[m] > target) {\\n                ans = m;\\n                r = m - 1;\\n            }else {\\n                l = m + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        int n = nums1.length;\\n        \\n        for(int i = 0; i < n; ++i) nums1[i] -= nums2[i];\\n        return mergeSort(nums1, new int[n], 0, n - 1, diff);\\n    }\\n    \\n    public long mergeSort(int[] nums, int[] temp, int l, int r, int diff) {\\n        if(l < r) {\\n            int m = (l + r)/2;\\n            long ans = 0;\\n            ans += mergeSort(nums, temp, l, m, diff);\\n            ans += mergeSort(nums, temp, m+1, r, diff);\\n            ans += merge(nums, temp, l, m+1, r, diff);\\n            return ans;\\n        }\\n        return 0;\\n    }\\n    \\n    public long merge(int[] nums, int[] temp, int l, int m, int r, int diff) {\\n        long res = 0;\\n        \\n        for(int i = m; i <= r; ++i) {\\n            int up = upperbound(nums, diff + nums[i], l, m-1);\\n            if(up <= m) res += (up - l );\\n        }\\n        \\n        int i = l, j = m, k = l;\\n        while(i < m && j <= r) {\\n            if(nums[i] < nums[j]) {\\n                temp[k++] = nums[i++];\\n            }else {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n        \\n        while(i < m) {\\n            temp[k++] = nums[i++];\\n        }\\n        \\n        while(j <= r) {\\n            temp[k++] = nums[j++];\\n        }\\n        \\n        for(int pos = l; pos <= r; ++pos) {\\n            nums[pos] = temp[pos];\\n        } \\n        return res;\\n    }\\n    \\n    public int upperbound(int[] arr, int target, int l, int r) {\\n        int ans = r+1;\\n        while(l <= r) {\\n            int m = (l + r)/2;\\n            if(arr[m] > target) {\\n                ans = m;\\n                r = m - 1;\\n            }else {\\n                l = m + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661656,
                "title": "c-binary-indexed-tree-to-store-a-histogram",
                "content": "```\\nconst int offset = 3e4+1;\\nclass BIT\\n{\\n    int size;\\n    vector<int> bit;\\n    //vector<int> arr;\\npublic:\\n    BIT(int n) : size(n)\\n    {\\n        bit.resize(n+1);\\n    }\\n    BIT(vector<int>& nums)\\n    {  // construct BIT\\n        //arr = nums;\\n        bit = vector<int>(nums.size()+1);\\n        bit[0] = 0;\\n        for(int i=0; i<nums.size(); ++i)\\n        {\\n            int k=i+1;\\n            while(k < bit.size())\\n            {\\n                bit[k] += nums[i];\\n                k += k & (-k);\\n            }\\n        }\\n    }\\n    void insert(int index, int val=1)\\n    {\\n        int k=index+1;\\n        while(k < bit.size())\\n        {\\n            bit[k] += val;\\n            k += k & (-k);\\n        }\\n    }\\n        \\n    // void update(int index, int val)\\n    // {\\n    //     //int delta = val - arr[index];\\n    //     //arr[index] = val;\\n    //     int k=index+1;\\n    //     while(k < bit.size())\\n    //     {\\n    //         bit[k] += delta;\\n    //         k += k & (-k);\\n    //     }\\n    // }\\n\\n    int cumSum(int i)  // including the number.\\n    {\\n        int ret = 0;\\n        int k=i+1;\\n        while(k)\\n        {\\n            ret += bit[k];\\n            k -= k & (-k);\\n        }\\n        return ret;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff)\\n    {\\n        int n = nums1.size();\\n        BIT b(2*offset);\\n        long long ret = 0LL;\\n        for(int j=0; j<n; j++)\\n        {\\n            int d = nums1[j] - nums2[j];\\n            ret += b.cumSum(offset + d + diff);\\n            b.insert(offset + d);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int offset = 3e4+1;\\nclass BIT\\n{\\n    int size;\\n    vector<int> bit;\\n    //vector<int> arr;\\npublic:\\n    BIT(int n) : size(n)\\n    {\\n        bit.resize(n+1);\\n    }\\n    BIT(vector<int>& nums)\\n    {  // construct BIT\\n        //arr = nums;\\n        bit = vector<int>(nums.size()+1);\\n        bit[0] = 0;\\n        for(int i=0; i<nums.size(); ++i)\\n        {\\n            int k=i+1;\\n            while(k < bit.size())\\n            {\\n                bit[k] += nums[i];\\n                k += k & (-k);\\n            }\\n        }\\n    }\\n    void insert(int index, int val=1)\\n    {\\n        int k=index+1;\\n        while(k < bit.size())\\n        {\\n            bit[k] += val;\\n            k += k & (-k);\\n        }\\n    }\\n        \\n    // void update(int index, int val)\\n    // {\\n    //     //int delta = val - arr[index];\\n    //     //arr[index] = val;\\n    //     int k=index+1;\\n    //     while(k < bit.size())\\n    //     {\\n    //         bit[k] += delta;\\n    //         k += k & (-k);\\n    //     }\\n    // }\\n\\n    int cumSum(int i)  // including the number.\\n    {\\n        int ret = 0;\\n        int k=i+1;\\n        while(k)\\n        {\\n            ret += bit[k];\\n            k -= k & (-k);\\n        }\\n        return ret;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff)\\n    {\\n        int n = nums1.size();\\n        BIT b(2*offset);\\n        long long ret = 0LL;\\n        for(int j=0; j<n; j++)\\n        {\\n            int d = nums1[j] - nums2[j];\\n            ret += b.cumSum(offset + d + diff);\\n            b.insert(offset + d);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661392,
                "title": "segment-tree-c",
                "content": "```\\nclass SegmentTree {\\nprivate:\\n    vector<int> st;\\n    int sz;\\n    \\npublic:\\n    SegmentTree(int n) {\\n        st.resize(4 * n, 0);\\n        sz = n;\\n    }\\n    \\n    void update(int idx, int s, int e, int val) {\\n        if(s == val && e == val) {\\n            st[idx] += 1;\\n            return;\\n        }\\n        \\n        if(val < s || val > e) return;\\n        \\n        int mid = (s + e) >> 1;\\n        update(idx * 2 + 1, s, mid, val);\\n        update(idx * 2 + 2, mid + 1, e, val);\\n        st[idx] = st[idx * 2 + 1] + st[idx * 2 + 2];\\n    }\\n    \\n    int query(int idx, int s, int e, int qs, int qe) {\\n        if(qs <= s && e <= qe) return st[idx];\\n        if(qe < s || e < qs) return 0;\\n        \\n        int mid = (s + e) >> 1;\\n        return query(idx * 2 + 1, s, mid, qs, qe) + query(idx * 2 + 2, mid + 1, e, qs, qe);\\n    }\\n};\\n\\n#define s -20000\\n#define e 20000\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long res = 0;\\n        int range = 40001;\\n        SegmentTree st(range);\\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            res += st.query(0, s, e, s, nums1[i] - nums2[i] + diff);\\n            st.update(0, s, e, nums1[i] - nums2[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree {\\nprivate:\\n    vector<int> st;\\n    int sz;\\n    \\npublic:\\n    SegmentTree(int n) {\\n        st.resize(4 * n, 0);\\n        sz = n;\\n    }\\n    \\n    void update(int idx, int s, int e, int val) {\\n        if(s == val && e == val) {\\n            st[idx] += 1;\\n            return;\\n        }\\n        \\n        if(val < s || val > e) return;\\n        \\n        int mid = (s + e) >> 1;\\n        update(idx * 2 + 1, s, mid, val);\\n        update(idx * 2 + 2, mid + 1, e, val);\\n        st[idx] = st[idx * 2 + 1] + st[idx * 2 + 2];\\n    }\\n    \\n    int query(int idx, int s, int e, int qs, int qe) {\\n        if(qs <= s && e <= qe) return st[idx];\\n        if(qe < s || e < qs) return 0;\\n        \\n        int mid = (s + e) >> 1;\\n        return query(idx * 2 + 1, s, mid, qs, qe) + query(idx * 2 + 2, mid + 1, e, qs, qe);\\n    }\\n};\\n\\n#define s -20000\\n#define e 20000\\n\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long res = 0;\\n        int range = 40001;\\n        SegmentTree st(range);\\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            res += st.query(0, s, e, s, nums1[i] - nums2[i] + diff);\\n            st.update(0, s, e, nums1[i] - nums2[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660877,
                "title": "segment-tree-iterative-version",
                "content": "**nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff**\\n=> **nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff** [find all i\\'s which satisfy this condition]\\n```\\nclass tree{\\n    int n;\\n    vector<long long> v;\\npublic:\\n    tree(int n){\\n        this->n = n;\\n        v.resize(2*n, 0);\\n    }\\n    int cnt(int l, int r){\\n        long long c = 0;\\n        l += n;\\n        r += n;\\n        while(l <= r){\\n            if(l%2 == 1) c += v[l++];\\n            if(r%2 == 0) c += v[r--];\\n            l >>= 1;\\n            r >>= 1;\\n        }\\n        return c;\\n    }\\n    void insert(int i){\\n        i += n;\\n        v[i] += 1;\\n        while(i > 0){\\n            i >>= 1;\\n            v[i] = v[i << 1] + v[i << 1 | 1];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long res = 0;\\n        tree t(60000);\\n        int offset = 20000;//to handle negetive numbers\\n        for(int i = 0; i < nums1.size(); i++){\\n            res += t.cnt(0, nums1[i] - nums2[i] + diff + offset);\\n            t.insert(nums1[i] - nums2[i] + offset);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass tree{\\n    int n;\\n    vector<long long> v;\\npublic:\\n    tree(int n){\\n        this->n = n;\\n        v.resize(2*n, 0);\\n    }\\n    int cnt(int l, int r){\\n        long long c = 0;\\n        l += n;\\n        r += n;\\n        while(l <= r){\\n            if(l%2 == 1) c += v[l++];\\n            if(r%2 == 0) c += v[r--];\\n            l >>= 1;\\n            r >>= 1;\\n        }\\n        return c;\\n    }\\n    void insert(int i){\\n        i += n;\\n        v[i] += 1;\\n        while(i > 0){\\n            i >>= 1;\\n            v[i] = v[i << 1] + v[i << 1 | 1];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        long long res = 0;\\n        tree t(60000);\\n        int offset = 20000;//to handle negetive numbers\\n        for(int i = 0; i < nums1.size(); i++){\\n            res += t.cnt(0, nums1[i] - nums2[i] + diff + offset);\\n            t.insert(nums1[i] - nums2[i] + offset);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659108,
                "title": "simple-implement-of-segment-tree-in-c-high-functional-in-space-and-time-cost",
                "content": "**How to  transform the inequality into a simple one ?**\\n*nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff*   ---->  *(nums1[i] - nums2[i]) <= (nums1[j] - nums2[j]) + diff*.\\nwe recognize *nums1[i] - nums2[i]* as *nums3[i]*. \\nThen we have this equation : *nums3[i] <= nums3[j] + diff*\\nwhere *-20000 <= nums3[i] <= 20000*, and* -30000 <= nums3[i] + diff <= 30000*\\nif we want put *nums3[i] + diff* in a segment tree, we need to add an offset= 30000 to make sure every value is non-negtive.\\n\\nAnd do recognize array \"segTree\" as a full binary tree ! a leaf\\'s value means how many times has this leaf emerged before.\\nwe accumulate from backend of nums3 can make sure every cnt we find in this round has a smaller idx than those who already in tree.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    // segment tree\\n    int len = 120002; // (maxVal + maxDiff + offset ) >> 1\\n    vector<int> segTree; \\n    int query(int l){ // [bound, len), count from bottom leaf to root!\\n        int ans = 0;\\n        for(int r = len - 1; l <= r; r >>= 1,l >>= 1)\\n        {\\n            if(l & 1) //l is right child\\n                ans += segTree[l++];\\n            if(!(r & 1)) // r is left child\\n                ans += segTree[r--];\\n        }\\n        return ans;\\n    }\\n    void update(int val){\\n        for(val; val >= 1; val >>= 1)\\n            segTree[val]++;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        segTree = vector<int>(len, 0);\\n        int N = 60001, offset = 30000; \\n        long long ans = 0;\\n        for(int i = nums1.size() - 1; i >= 0; i--){\\n            int tmp = nums1[i] - nums2[i] + offset + N; \\n            ans += query(tmp);\\n            update(tmp + diff);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // segment tree\\n    int len = 120002; // (maxVal + maxDiff + offset ) >> 1\\n    vector<int> segTree; \\n    int query(int l){ // [bound, len), count from bottom leaf to root!\\n        int ans = 0;\\n        for(int r = len - 1; l <= r; r >>= 1,l >>= 1)\\n        {\\n            if(l & 1) //l is right child\\n                ans += segTree[l++];\\n            if(!(r & 1)) // r is left child\\n                ans += segTree[r--];\\n        }\\n        return ans;\\n    }\\n    void update(int val){\\n        for(val; val >= 1; val >>= 1)\\n            segTree[val]++;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        \\n        segTree = vector<int>(len, 0);\\n        int N = 60001, offset = 30000; \\n        long long ans = 0;\\n        for(int i = nums1.size() - 1; i >= 0; i--){\\n            int tmp = nums1[i] - nums2[i] + offset + N; \\n            ans += query(tmp);\\n            update(tmp + diff);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658553,
                "title": "java-twice-binary-search-easy",
                "content": "find the **cur** and **target** values based on inequality\\n\\n# cur = nums1[i] - nums2[i];\\n\\n# target = cur +diff;\\n\\nnow do binary search to find index before which all elemnts are smaller\\n\\nagain do binary search to find insert position to maintain sorted list \\n\\n```\\nclass Solution {\\n    public long binarySearch(List<Integer> l1, int t)\\n    { int i =0 ,j =l1.size();\\n\\n        while (i<j)\\n        {\\n            int mid = (i+j)>>1;\\n\\n            if(l1.get(mid)<= t)\\n                i = mid+1;\\n            else\\n                j= mid;\\n        }\\n\\n        return (long)i;\\n    }\\n\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n\\n        long ans =0;\\n\\n       List<Integer> list = new ArrayList<>();\\n\\n        for (int j = 0; j < nums1.length; j++) {\\n\\n            int cur = nums1[j] - nums2[j];\\n            int target = cur +diff;\\n\\n            ans  += binarySearch(list,target);\\n\\n            int idx = (int)binarySearch(list,cur);\\n\\n            list.add(idx,cur);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long binarySearch(List<Integer> l1, int t)\\n    { int i =0 ,j =l1.size();\\n\\n        while (i<j)\\n        {\\n            int mid = (i+j)>>1;\\n\\n            if(l1.get(mid)<= t)\\n                i = mid+1;\\n            else\\n                j= mid;\\n        }\\n\\n        return (long)i;\\n    }\\n\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n\\n        long ans =0;\\n\\n       List<Integer> list = new ArrayList<>();\\n\\n        for (int j = 0; j < nums1.length; j++) {\\n\\n            int cur = nums1[j] - nums2[j];\\n            int target = cur +diff;\\n\\n            ans  += binarySearch(list,target);\\n\\n            int idx = (int)binarySearch(list,cur);\\n\\n            list.add(idx,cur);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658165,
                "title": "c-merge-sort-tree",
                "content": "# MERGE SORT TREE \\n\\nIt is a segment tree were each node of the tree will contain vector of numbers falling inside that node in sorted order.\\nNow we can use binary search to get numbers of elements greater than or smaller than a given value.\\n\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> seg;\\n    \\n    vector<int> merge(vector<int>& v1, vector<int>& v2){\\n        int n = v1.size();\\n        int m = v2.size();\\n        vector<int> temp(n+m);\\n        int i = 0;\\n        int j = 0;\\n        for(int k = 0; k<n+m; k++){\\n            if(i == n){\\n                temp[k] = v2[j++];\\n            }\\n            else if(j == m){\\n                temp[k] = v1[i++];\\n            }\\n            else{\\n                if(v1[i] < v2[j]){\\n                    temp[k] = v1[i++];\\n                }\\n                else{\\n                    temp[k] = v2[j++];\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n    void build_tree(int N, int l, int r, vector<int>& v){\\n        if(l == r){\\n            seg[N].push_back(v[l]);\\n            return;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        \\n        build_tree(2*N, l, mid, v);\\n        build_tree(2*N+1, mid+1, r, v);\\n        \\n        seg[N] = merge(seg[2*N], seg[2*N+1]);\\n    }\\n    \\n    int query_tree(int i, int j, int num, int N, int l, int r){\\n        if(r<i or l>j) return 0;\\n        if(l>=i and r<=j){\\n            int idx = upper_bound(seg[N].begin(), seg[N].end(), num) - seg[N].begin();\\n            return idx;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        \\n        int n1 = query_tree(i, j, num, 2*N, l, mid);\\n        int n2 = query_tree(i, j, num, 2*N+1, mid+1, r);\\n        \\n        return n1 + n2;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<int> diff(n);\\n        seg.resize(4*n);\\n        long long cnt = 0;\\n        for(int i = 0; i<n; i++){\\n            diff[i] = nums1[i] - nums2[i];\\n        }\\n        build_tree(1, 0, n-1, diff);\\n        for(int i = 0; i<n; i++){\\n            cnt += query_tree(0, i-1, diff[i] + k, 1, 0, n-1);\\n            // query_tree(i, j, num, node, tree_i, tree_j)\\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity: For forming the segment tree it is O(nlogn)\\n\\n- Space complexity: O(n*log(n)) \\n(total number of elements in each level of seg tree * number of levels)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> seg;\\n    \\n    vector<int> merge(vector<int>& v1, vector<int>& v2){\\n        int n = v1.size();\\n        int m = v2.size();\\n        vector<int> temp(n+m);\\n        int i = 0;\\n        int j = 0;\\n        for(int k = 0; k<n+m; k++){\\n            if(i == n){\\n                temp[k] = v2[j++];\\n            }\\n            else if(j == m){\\n                temp[k] = v1[i++];\\n            }\\n            else{\\n                if(v1[i] < v2[j]){\\n                    temp[k] = v1[i++];\\n                }\\n                else{\\n                    temp[k] = v2[j++];\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n    void build_tree(int N, int l, int r, vector<int>& v){\\n        if(l == r){\\n            seg[N].push_back(v[l]);\\n            return;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        \\n        build_tree(2*N, l, mid, v);\\n        build_tree(2*N+1, mid+1, r, v);\\n        \\n        seg[N] = merge(seg[2*N], seg[2*N+1]);\\n    }\\n    \\n    int query_tree(int i, int j, int num, int N, int l, int r){\\n        if(r<i or l>j) return 0;\\n        if(l>=i and r<=j){\\n            int idx = upper_bound(seg[N].begin(), seg[N].end(), num) - seg[N].begin();\\n            return idx;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        \\n        int n1 = query_tree(i, j, num, 2*N, l, mid);\\n        int n2 = query_tree(i, j, num, 2*N+1, mid+1, r);\\n        \\n        return n1 + n2;\\n    }\\n    \\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<int> diff(n);\\n        seg.resize(4*n);\\n        long long cnt = 0;\\n        for(int i = 0; i<n; i++){\\n            diff[i] = nums1[i] - nums2[i];\\n        }\\n        build_tree(1, 0, n-1, diff);\\n        for(int i = 0; i<n; i++){\\n            cnt += query_tree(0, i-1, diff[i] + k, 1, 0, n-1);\\n            // query_tree(i, j, num, node, tree_i, tree_j)\\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656806,
                "title": "binary-search-or-sorted-containers-practice-python",
                "content": "1- Two solution formats (essentially the same idea)\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs_v1(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \"\"\"\\n        binary search\\n        \"\"\"\\n        delta = [a - b for a, b in zip(nums1, nums2)]\\n        aux = []\\n        res = 0\\n        for y in delta:\\n            cnt = bisect.bisect_right(aux, y + diff)\\n            res += cnt\\n            bisect.insort(aux, y)\\n        return res\\n    \\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \"\"\"\\n        SortedList\\n        \"\"\"\\n        delta = [a - b for a, b in zip(nums1, nums2)]\\n        aux = SortedList()\\n        res = 0\\n        for y in delta:\\n            cnt = aux.bisect_right(y)\\n            res += cnt\\n            aux.add(y - diff)\\n        return res\\n        \\n```\\n2- Video Explanation: [Click Video Here](https://youtu.be/gXvHTFDAzPc;)\\n\\n3- Analysis or summary\\n\\nMethod: binary search\\n\\nnums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff  (*)\\n\\nis equivalent mathematically to\\n\\nnums1[i] - nums2[i] <= nums2[j] - nums2[j] + diff  (**)\\n\\nHowever, the i, j are decoupled in (**), which enables us to\\nexamine the difference list:\\n\\ndelta = [x - y for x, y in zip(nums1, nums2)]\\n\\nThen the procedure will be routine:\\n\\nfor each element in delta we look at, it corresponds to an index j,\\nwe find how many previous indices i can pair with j, and satisfy (**).\\n\\nTo carry out the procedure, we could use binary search or sorted containers.\\n\\n\\nExtension:\\n- Try to write a solution format using Segment Tree\\n- Examine Leetcode 493. Reverse Pairs. \\n  493 can be solved using the procedure presented here. It is more direct.",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def numberOfPairs_v1(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \"\"\"\\n        binary search\\n        \"\"\"\\n        delta = [a - b for a, b in zip(nums1, nums2)]\\n        aux = []\\n        res = 0\\n        for y in delta:\\n            cnt = bisect.bisect_right(aux, y + diff)\\n            res += cnt\\n            bisect.insort(aux, y)\\n        return res\\n    \\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\\n        \"\"\"\\n        SortedList\\n        \"\"\"\\n        delta = [a - b for a, b in zip(nums1, nums2)]\\n        aux = SortedList()\\n        res = 0\\n        for y in delta:\\n            cnt = aux.bisect_right(y)\\n            res += cnt\\n            aux.add(y - diff)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656125,
                "title": "java-solution-clean-code-segment-tree",
                "content": "```\\nclass Solution {\\n    \\n    long tree [] ;\\n\\n    int CONSTANT = 0;\\n\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        \\n        // nums1[i] - nums2[i] <= nums1[j]-nums2[j] + diff\\n        \\n        for( int i = 0;i < nums1.length ; i++ )     nums1[i] = nums1[i] - nums2[i];\\n\\n        int min = Integer.MAX_VALUE , max = Integer.MIN_VALUE;\\n\\n        for(int i = 0 ;i < nums1.length;i++){\\n            \\n            min = Math.min( nums1[i] + diff , min );\\n            \\n            max = Math.max( nums1[i] + diff , max );\\n        \\n        }\\n\\n        if ( min >= 0 )\\n            tree = new long[4*max+1];\\n        else\\n        {\\n            CONSTANT = Math.abs(min);\\n            \\n            tree = new long[4*(max+CONSTANT)+1];\\n        }\\n\\n\\n        long result = 0;\\n\\n        for( int i = nums1.length - 1 ; i>=0 ;i--){\\n            \\n            long count = query( 0 , max + CONSTANT , 0 , nums1[i]+CONSTANT,max+CONSTANT);\\n            \\n            result += count; \\n            \\n            update(0,max+CONSTANT,0,nums1[i]+CONSTANT+diff);\\n           \\n        }\\n\\n        return result ;\\n\\n\\n    }\\n\\n\\n    long query (  int low , int high , int index , int ql , int qh ){\\n\\n        if( qh < low || ql > high ) return 0;\\n\\n        else if ( ql <= low && qh >= high  ) return tree [ index  ];\\n\\n        else \\n        {\\n            int mid = ( low + high )/2;\\n\\n            long res_l = query( low , mid , 2 * index + 1 , ql , qh );\\n            \\n            long res_h = query( mid + 1 , high , 2 * index + 2 , ql , qh );\\n\\n            return res_l + res_h;\\n        }\\n\\n\\n\\n    }\\n\\n\\n    long update ( int low , int high , int index , int value ){\\n        \\n        if(low> value || high < value) return tree[index];\\n\\n        else if ( low == high && low == value  ){\\n            \\n            tree [ index ] += 1;\\n            \\n            return tree [ index ];\\n        \\n        }\\n        else{\\n\\n            int mid = ( low + high )/2;\\n\\n            long left  = update( low , mid , 2 * index + 1 , value );\\n            \\n            long right = update( mid + 1 , high , 2 * index + 2 , value );\\n\\n            return tree[index] = left + right ;\\n\\n        }\\n\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    long tree [] ;\\n\\n    int CONSTANT = 0;\\n\\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\\n        \\n        // nums1[i] - nums2[i] <= nums1[j]-nums2[j] + diff\\n        \\n        for( int i = 0;i < nums1.length ; i++ )     nums1[i] = nums1[i] - nums2[i];\\n\\n        int min = Integer.MAX_VALUE , max = Integer.MIN_VALUE;\\n\\n        for(int i = 0 ;i < nums1.length;i++){\\n            \\n            min = Math.min( nums1[i] + diff , min );\\n            \\n            max = Math.max( nums1[i] + diff , max );\\n        \\n        }\\n\\n        if ( min >= 0 )\\n            tree = new long[4*max+1];\\n        else\\n        {\\n            CONSTANT = Math.abs(min);\\n            \\n            tree = new long[4*(max+CONSTANT)+1];\\n        }\\n\\n\\n        long result = 0;\\n\\n        for( int i = nums1.length - 1 ; i>=0 ;i--){\\n            \\n            long count = query( 0 , max + CONSTANT , 0 , nums1[i]+CONSTANT,max+CONSTANT);\\n            \\n            result += count; \\n            \\n            update(0,max+CONSTANT,0,nums1[i]+CONSTANT+diff);\\n           \\n        }\\n\\n        return result ;\\n\\n\\n    }\\n\\n\\n    long query (  int low , int high , int index , int ql , int qh ){\\n\\n        if( qh < low || ql > high ) return 0;\\n\\n        else if ( ql <= low && qh >= high  ) return tree [ index  ];\\n\\n        else \\n        {\\n            int mid = ( low + high )/2;\\n\\n            long res_l = query( low , mid , 2 * index + 1 , ql , qh );\\n            \\n            long res_h = query( mid + 1 , high , 2 * index + 2 , ql , qh );\\n\\n            return res_l + res_h;\\n        }\\n\\n\\n\\n    }\\n\\n\\n    long update ( int low , int high , int index , int value ){\\n        \\n        if(low> value || high < value) return tree[index];\\n\\n        else if ( low == high && low == value  ){\\n            \\n            tree [ index ] += 1;\\n            \\n            return tree [ index ];\\n        \\n        }\\n        else{\\n\\n            int mid = ( low + high )/2;\\n\\n            long left  = update( low , mid , 2 * index + 1 , value );\\n            \\n            long right = update( mid + 1 , high , 2 * index + 2 , value );\\n\\n            return tree[index] = left + right ;\\n\\n        }\\n\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656060,
                "title": "simple-segment-tree-approach-o-nlogn",
                "content": "Consider another **Array c** s.t **c[i]=a[i]-b[i]**. Then the problem can be reduced to following form:\\n\\nFor each i we need to find the count of element c[j] s.t following conditions hold\\n**1.  j>i**\\n**2. c[i]-d<=c[j]**. \\n\\nHere to make all c[i]>=1 we have added an offset which will not affect the answer since \\n**c[i]+offset-d<=c[j]+offset**.\\n\\nThen it becomes a simple **Segment Tree problem** where we are traversing the array from end and keep updating the count of all elements we find. And then to calculate the no of possible elements which can be paired with ith element which satisfy the two conditions given above we simply make a **query in segment tree to find the number of elements which are greater than c[i]-d and smaller than mx**. Since all elements in array c are smaller than equal to mx\\n\\n\\n```\\n#define ll long long int\\nclass Solution {\\n    vector<int> st;\\npublic:\\n    ll query(int tind,int tl,int tr,int ql,int qr){\\n        if(tl>tr or ql>tr or qr<tl)\\n            return 0;\\n        if(ql<=tl and tr<=qr)\\n            return st[tind];\\n        int left=tind<<1,tm=tl+((tr-tl)>>1);\\n        return query(left,tl,tm,ql,qr)+query(left|1,tm+1,tr,ql,qr);\\n    }\\n    \\n    void update(int tind,int tl,int tr,int ind){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]++;\\n            return;\\n        }\\n        int left=tind<<1,tm=tl+((tr-tl)>>1);\\n        if(ind<=tm)\\n            update(left,tl,tm,ind);\\n        else\\n            update(left|1,tm+1,tr,ind);\\n        st[tind]=st[left]+st[left|1];\\n    }\\n    \\n    ll numberOfPairs(vector<int>& a, vector<int>& b, int d) {\\n        int mn=0,mx=0,n=a.size();\\n        vector<int> c(n);\\n        for(int i=0;i<n;i++){\\n            c[i]=a[i]-b[i];\\n            mn=min(mn,c[i]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            c[i]+=abs(mn)+1;\\n            mx=max(mx,c[i]);\\n        }\\n        \\n        ll ans=0;\\n        st.resize(5*mx+10,0);\\n        for(int i=n-1;i>=0;i--){\\n            ans+=query(1,1,mx,max(1,c[i]-d),mx);\\n            update(1,1,mx,c[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    vector<int> st;\\npublic:\\n    ll query(int tind,int tl,int tr,int ql,int qr){\\n        if(tl>tr or ql>tr or qr<tl)\\n            return 0;\\n        if(ql<=tl and tr<=qr)\\n            return st[tind];\\n        int left=tind<<1,tm=tl+((tr-tl)>>1);\\n        return query(left,tl,tm,ql,qr)+query(left|1,tm+1,tr,ql,qr);\\n    }\\n    \\n    void update(int tind,int tl,int tr,int ind){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]++;\\n            return;\\n        }\\n        int left=tind<<1,tm=tl+((tr-tl)>>1);\\n        if(ind<=tm)\\n            update(left,tl,tm,ind);\\n        else\\n            update(left|1,tm+1,tr,ind);\\n        st[tind]=st[left]+st[left|1];\\n    }\\n    \\n    ll numberOfPairs(vector<int>& a, vector<int>& b, int d) {\\n        int mn=0,mx=0,n=a.size();\\n        vector<int> c(n);\\n        for(int i=0;i<n;i++){\\n            c[i]=a[i]-b[i];\\n            mn=min(mn,c[i]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            c[i]+=abs(mn)+1;\\n            mx=max(mx,c[i]);\\n        }\\n        \\n        ll ans=0;\\n        st.resize(5*mx+10,0);\\n        for(int i=n-1;i>=0;i--){\\n            ans+=query(1,1,mx,max(1,c[i]-d),mx);\\n            update(1,1,mx,c[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1742838,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "ak5113165",
                        "content": "can someone explain the approach"
                    },
                    {
                        "username": "yashvaibhav",
                        "content": "Can all index i terms be bought on the left side and j to the right?\\nSo the new transformed array would look like \\nA[ i ] - diff <= A[ j ] \\nSince i<j this inequality basically yells  \\n> For index anchored at i, how many to the **right of i** have a value greater than or equal to A[i] - diff ?"
                    },
                    {
                        "username": "SajLeet",
                        "content": "Think about the inequality, can you rewrite it in such a way that it makes processing easier?"
                    }
                ]
            },
            {
                "id": 1626444,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "ak5113165",
                        "content": "can someone explain the approach"
                    },
                    {
                        "username": "yashvaibhav",
                        "content": "Can all index i terms be bought on the left side and j to the right?\\nSo the new transformed array would look like \\nA[ i ] - diff <= A[ j ] \\nSince i<j this inequality basically yells  \\n> For index anchored at i, how many to the **right of i** have a value greater than or equal to A[i] - diff ?"
                    },
                    {
                        "username": "SajLeet",
                        "content": "Think about the inequality, can you rewrite it in such a way that it makes processing easier?"
                    }
                ]
            }
        ]
    }
]