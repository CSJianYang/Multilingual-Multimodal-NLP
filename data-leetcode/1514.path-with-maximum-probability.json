[
    {
        "title": "Number of Good Pairs",
        "question_content": "Given an array of integers nums, return the number of good pairs.\nA pair (i, j) is called good if nums[i] == nums[j] and i < j.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,1,1,3]\nOutput: 4\nExplanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n\nExample 2:\n\nInput: nums = [1,1,1,1]\nOutput: 6\nExplanation: Each pair in the array are good.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t1 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 731561,
                "title": "java-c-python-count",
                "content": "## **Explanation**\\n`count` the occurrence of the same elements.\\nFor each new element `a`,\\nthere will be more `count[a]` pairs,\\nwith `A[i] == A[j]` and `i < j`\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numIdenticalPairs(int[] A) {\\n        int res = 0, count[] = new int[101];\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        int res = 0;\\n        unordered_map<int, int> count;\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n1-line from @generationx2020\\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0, [count = unordered_map<int, int> {}] (auto a, auto b) mutable {\\n            return a + count[b]++;\\n        });\\n    }\\n```\\n**Python:**\\n```py\\n    def numIdenticalPairs(self, A):\\n        return sum(k * (k - 1) / 2 for k in collections.Counter(A).values())\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numIdenticalPairs(int[] A) {\\n        int res = 0, count[] = new int[101];\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        int res = 0;\\n        unordered_map<int, int> count;\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0, [count = unordered_map<int, int> {}] (auto a, auto b) mutable {\\n            return a + count[b]++;\\n        });\\n    }\\n```\n```py\\n    def numIdenticalPairs(self, A):\\n        return sum(k * (k - 1) / 2 for k in collections.Counter(A).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1457646,
                "title": "java-story-based-0ms-single-pass-easy-to-understand-simple-hashmap",
                "content": "\\n# HANDSHAKES IN GATHERING\\n\\n# **YOU ALL CAN BUY ME A ******BEER \\uD83C\\uDF7A****** AT \\uD83D\\uDC47**\\n\\n**https://www.buymeacoffee.com/deepakgupta**\\n\\nImagine this problem like, There is a gathering organized by some guy, the guest list is [1,2,3,1,1,3].\\nThe problem with the guest is they only handshake with like minded people. (Like minded here is basically the digit should be same , for example, 1 will handshake with 1 only, 2 will handshake with 2 only and so on)\\n\\n\\n\\n**So, finally we just need to count number of handshakes in the gathering. \\uD83D\\uDCAF \\uD83D\\uDCAF**\\n\\n(To distinguish , multiple 1\\'s and 3\\'s , a,b,c,d... letters are used)\\n\\n**\\uD83D\\uDD25 the day of arrival \\uD83D\\uDD25** \\n\\none by one guests are arriving at the gathering\\n\\n\\u2705 first guest: 1\\n\\n\\u2705 second guest: 2\\n(at this moment, in gathering hall we have **1** (2 is about to enter) , since they are not like minded they wont shake hands)\\n\\n\\u2705 third guest:3\\n(at this moment, in gathering hall we have **1 ,2** (3 is about to enter), since they are not like minded they wont shake hands)\\n\\n\\u2705 fourth guest : 1\\n(at this moment, fourth guest will see in gathering hall , there is **one like minded guy** ie(1) , so he will handshake with him)\\ntherefore totalHandShake = 1\\n\\n\\u2705 fifth guest : 1\\n(at this moment, fifth guest will see in gathering hall, there are **two like minded guys** ie(1,1) , so he will handshake with them)\\ntherefore totalHandShake = 1(last handshake between 1a-1b ) + 2(current handshake between 1a-1c, 1b-1c) = 3\\n\\n\\u2705 sixth guest : 3\\n(at this moment, sixth guest will see in gathering hall, there is **one like minded guy** ie(3) , so he will handshake with him)\\ntherefore totalHandShake = 3(last handshake) + 1(3a-3b) = 4 \\n\\n\\nHere, in code we can imagine\\n\\n**given array as guest list.\\nHashmap as gathering hall\\nans as totalHandshakes.**\\n\\n# IF YOU GUYS ENJOYED THIS, PLEASE UPVOTE AND COMMENT, THIS GIVES ME HUGE MOTIVATION.\\n# **YOU ALL CAN BUY ME A BEER \\uD83C\\uDF7A AT \\uD83D\\uDC47**\\n\\n**https://www.buymeacoffee.com/deepakgupta**\\n\\n\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] guestList) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int ans = 0;\\n        \\n        for(int friend:guestList)\\n        {\\n            int friendCount = hm.getOrDefault(friend,0);\\n            ans+=friendCount;\\n            hm.put(friend,friendCount+1);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**SPACE : O(N)\\nTIME   :  O(N)**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] guestList) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int ans = 0;\\n        \\n        for(int friend:guestList)\\n        {\\n            int friendCount = hm.getOrDefault(friend,0);\\n            ans+=friendCount;\\n            hm.put(friend,friendCount+1);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736565,
                "title": "python-simple-o-n-solution",
                "content": "**Solution Idea**\\nThe idea is storing the number of repeated elements in a dictionary/hash table and using mathmatics to calculate the number of combinations.\\n\\n**Fundamental Math Concept (Combinations)**\\nThe \"# of pairs\" can be calculated by summing each value from range 0 to n-1, where n is the \"# of times repeated\". So the \"# of pairs\" for the 5 repeated values, would be 0+1+2+3+4 = 10.\\n\\nAnother way to think about it is:\\n\\nNotice in the table below how the number of pairs increments by adding the previous \"# of times repeated\" to the previous \"# of pairs.\"\\n\\nFor example: to get the \"# of pairs\" for 3 repeated values, you would add the previous \"# of times repeated\" (which is 2) with the previous \"# of pairs\" (which is 1). Therefore, the \"# of pairs for 3 repeated values is 2+1=3. In this method, you don\\'t peform the same computations multiple times.\\n\\nExample Table of # of repeated items with their corresponding # of pairs\\n<table>\\n\\t<tr>\\n    <th># of times repeated</th>\\n    <th># of pairs</th>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>1</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>3</td>\\n  </tr>\\n  <tr>\\n    <td>4</td>\\n    <td>6</td>\\n  </tr>\\n  <tr>\\n    <td>5</td>\\n    <td>10</td>\\n  </tr>\\n  <tr>\\n    <td>6</td>\\n    <td>15</td>\\n  </tr>\\n</table>\\n\\n**My Code Solution**\\n1. Dictionary/Hash Table to store the number of times an element is repeated\\n2. Record total number of pairs (num)\\n3. Iterate through the nums list\\n4. Check to see if each element has already been seen, if not add it to the Hash Table\\n5. If it has been seen, but only once, just add 1 to \"num\"\\n6. If it has been seen, multiple times. Add the number of repeated times to \"num\"\\n7. Increment the number of reapeated times by 1.\\n7. Move onto next element\\n\\n```\\nclass Solution:\\n    \\n    # search for duplicate numbers\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        # number of good pairs\\n        repeat = {}\\n        num = 0\\n        \\n        # for every element in nums\\n        for v in nums:\\n            \\n            # number of repeated digits\\n            if v in repeat:\\n                \\n                # count number of pairs based on duplicate values\\n                if repeat[v] == 1:\\n                    num += 1\\n                else:\\n                    num += repeat[v]\\n                \\n                # increment the number of counts\\n                repeat[v] += 1\\n            # number has not been seen before\\n            else:\\n                repeat[v] = 1\\n        # return\\n        return num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # search for duplicate numbers\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        # number of good pairs\\n        repeat = {}\\n        num = 0\\n        \\n        # for every element in nums\\n        for v in nums:\\n            \\n            # number of repeated digits\\n            if v in repeat:\\n                \\n                # count number of pairs based on duplicate values\\n                if repeat[v] == 1:\\n                    num += 1\\n                else:\\n                    num += repeat[v]\\n                \\n                # increment the number of counts\\n                repeat[v] += 1\\n            # number has not been seen before\\n            else:\\n                repeat[v] = 1\\n        # return\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733540,
                "title": "java-100-faster-100-space-easy-solution",
                "content": "Method - 1: We can use two for loops and check is <b> nums[i] = nums[j] </b> and i < j and simply increase count by one every time. I think it will give error of time limit exceeded.\\n\\nMethod - 2 : First we can count the frequency of each numbers using array. If a number appears n times, then n * (n \\u2013 1) / 2 pairs can be made with this number.\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int ans = 0;\\n        int[] count = new int[101];\\n        \\n        for(int n: nums)\\n            count[n]++;\\n        \\n        for(int n: count)\\n            ans += (n * (n - 1))/2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int ans = 0;\\n        int[] count = new int[101];\\n        \\n        for(int n: nums)\\n            count[n]++;\\n        \\n        for(int n: count)\\n            ans += (n * (n - 1))/2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749025,
                "title": "python-o-n-simple-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        hashMap = {}\\n        res = 0\\n        for number in nums:            \\n            if number in hashMap:\\n                res += hashMap[number]\\n                hashMap[number] += 1\\n            else:\\n                hashMap[number] = 1\\n        return res\\n```\\n\\n- If the value already exists in the hashMap that means the number of new pairs is equal to the frequency since the current value can be paired with each prior occurrence . \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        hashMap = {}\\n        res = 0\\n        for number in nums:            \\n            if number in hashMap:\\n                res += hashMap[number]\\n                hashMap[number] += 1\\n            else:\\n                hashMap[number] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731571,
                "title": "java-hashmap-o-n",
                "content": "for each i, finds all j where, j < i &&  nums[j] == nums[i];\\n```\\n    public int numIdenticalPairs(int[] nums) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            res += map.get(n) - 1;  // addtional pair can be formed btw n and all previous v == n;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numIdenticalPairs(int[] nums) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            res += map.get(n) - 1;  // addtional pair can be formed btw n and all previous v == n;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731624,
                "title": "c-java-o-n",
                "content": "We can just count each value. Then, `n` elements with the same value can form `n * (n - 1) / 2` pairs.\\n\\n> Why? The first element forms `n - 1` pairs, the second - `n - 2` pairs and so on. So the sum of the [1, n - 1] progression is `n * (n - 1) / 2`.\\n\\n**C++**\\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {};\\n    for (auto n: nums)\\n        ++cnt[n];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int s, int i)\\n        { return s + i * (i - 1) / 2; });\\n}\\n```\\n**Java**\\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        ++cnt[n];\\n    for (int i = 0; i <= 100; ++i)\\n        res += cnt[i] * (cnt[i] - 1) / 2;\\n    return res;     \\n}\\n```\\n\\nWe can also simplify the logic a bit by combining the counting and progression.\\n\\n**C++**\\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {}, res = 0;\\n    for (auto n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {};\\n    for (auto n: nums)\\n        ++cnt[n];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int s, int i)\\n        { return s + i * (i - 1) / 2; });\\n}\\n```\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        ++cnt[n];\\n    for (int i = 0; i <= 100; ++i)\\n        res += cnt[i] * (cnt[i] - 1) / 2;\\n    return res;     \\n}\\n```\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {}, res = 0;\\n    for (auto n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 911686,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(N^2) space O(1)\\n var numIdenticalPairs = function(nums) {\\n     let count = 0\\n    \\n     for(let i=0; i<nums.length; i++) {\\n         for(let j=i+1; j<nums.length; j++) {\\n             if(nums[i] === nums[j]) {\\n                 count++\\n             }\\n         }\\n     }\\n    \\n     return count\\n };\\n```\\n\\n```\\n// time O(N) space O(N)\\nvar numIdenticalPairs = function(nums) {\\n    const map = {}\\n    let count = 0\\n    \\n    for (const number of nums) {\\n        if (map[number]) {\\n            count += map[number];\\n            map[number] += 1;\\n        } else {\\n            map[number] = 1;\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(N^2) space O(1)\\n var numIdenticalPairs = function(nums) {\\n     let count = 0\\n    \\n     for(let i=0; i<nums.length; i++) {\\n         for(let j=i+1; j<nums.length; j++) {\\n             if(nums[i] === nums[j]) {\\n                 count++\\n             }\\n         }\\n     }\\n    \\n     return count\\n };\\n```\n```\\n// time O(N) space O(N)\\nvar numIdenticalPairs = function(nums) {\\n    const map = {}\\n    let count = 0\\n    \\n    for (const number of nums) {\\n        if (map[number]) {\\n            count += map[number];\\n            map[number] += 1;\\n        } else {\\n            map[number] = 1;\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1202414,
                "title": "weeb-explains-python-beats-97-65",
                "content": "![image](https://assets.leetcode.com/users/images/6a27264b-cfe3-42e3-92e0-bfcee79d7d1e_1620717462.3697262.png)\\nfirst try btw and its already 97%\\n\\nOkay, my code looks weird at first glance but its actually pretty easy, just plug in the formula for quadratic sequence\\n\\t\\n\\tclass Solution:\\n\\t\\tdef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, memo = sorted(nums), {} # sort to get the total number of digits that have duplicates\\n\\t\\t\\tfor i in range(len(nums)-1): # lets say nums = [1,1,1,1,2,2,2,3] the total digits with duplicates is 7\\n\\t\\t\\t\\tif nums[i] == nums[i+1]: # because nums has 4 ones and 3 twos so it adds up to 7\\n\\t\\t\\t\\t\\tif nums[i] not in memo: # 3 is not counted because there are no duplicates of it\\n\\t\\t\\t\\t\\t\\tmemo[nums[i]] = 1\\n\\t\\t\\t\\t\\tmemo[nums[i]] = memo[nums[i]] + 1 \\n\\t\\t\\t# nums = [1,1,1,1,2,2,2,3]\\n\\t\\t\\t# so now memo = {1 : 4, 2: 3} which means we have 4 ones and 3 twos\\n\\t\\t\\tanswer = 0\\n\\t\\t\\tfor n in memo.values(): # this is the hard part, please refer to my beautiful drawing to understand this\\n\\t\\t\\t\\tanswer += (n**2 - n)//2 # after looking at the drawing, we repeat with each n value in memo\\n\\n\\t\\t\\treturn answer\\n\\n![image](https://assets.leetcode.com/users/images/62dfbc6c-2157-4b97-bebb-aa4cc1978ac6_1620719423.0946832.png)\\n![image](https://assets.leetcode.com/users/images/d3bba77d-366c-4380-a2e6-8e6844184e97_1620719531.481281.png)\\n\\nDamn, this took some time to do, please give me an upvote if u find it helpful\\n\\nAnways, i want to recommend an anime called **Karakai Jouzu no Takagi-san(Teasing Master Takagi-san)**\\n\\n# Episodes: 24 + 1 OVA\\n# Genres: Romantic comedy, Slice of life\\n\\nI love this anime, its wholesome so go check it out!\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, memo = sorted(nums), {}",
                "codeTag": "Java"
            },
            {
                "id": 939461,
                "title": "java-1-pass-one-pass-solution-intuitive-explanation",
                "content": "**1512. Number of Good Pairs**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int answer = 0;\\n        for(int i: nums){\\n            if(map.containsKey(i)){ // if number has occurred before\\n                int temp = map.get(i);\\n                answer += temp; // add number of occurrences to the answer\\n                map.put(i,temp+1); // increment number of occurrences\\n            } else {\\n                map.put(i,1); // if it is the first time, add it to the map\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n**PROBLEM OVERVIEW**\\nThe basic premise of the prolem is to find of many times nums[i] == nums[j], where j > i\\nWe are esentially tasked with finding the number of repeats after first occurence of each number.\\n\\n**ASSESSING SOLUTIONS**\\nA hashmap is great for this solution as we can looop through the array of numbers and have 1 of 2 states:\\n\\n*  if it exists, then add the number of currently stores and subsequently increment it\\n* otherwise, set that value as 1 (it exists)\\n\\nThe code is O(n), as it iterates through the entire array\\n\\n**EXPLANATIONS**\\nHere\\'s a way to visualize it. If I have [1,1], then there is only **1** \"good pair,\" which is the first and second 1. **(0+1 = 1)**\\nIf I have [1,1,1] then there are **3** \"good pairs\" ([first,second], [second,third,], [first,third]). **The first 1 has 0 pairs, the second 1 has 1 pair, and the third 1 has 2 pairs. (0+1+2 = 3)!**\\nLikeswise for [1,1,1,1] there are **6** \"good pairs\" **(0+1+2+3 = 6)**\\n\\nFrom this, we can conclude the pattern is **for every subsequent repeat of a number, the number of combinations increases by the current number of appearances of that number.**\\n\\nIn the code, we demonstrate this by incrementing the value in the map by one everytime, signaling the next occurence to add to \"answers\" one more combination than before.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int answer = 0;\\n        for(int i: nums){\\n            if(map.containsKey(i)){ // if number has occurred before\\n                int temp = map.get(i);\\n                answer += temp; // add number of occurrences to the answer\\n                map.put(i,temp+1); // increment number of occurrences\\n            } else {\\n                map.put(i,1); // if it is the first time, add it to the map\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731808,
                "title": "simplest-c-explanation-o-n2-and-o-n",
                "content": "\\n**O(n2)** [100% less memory usage] [75% less time usage]\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint counter = 0;\\n\\tfor(int i=0;i<nums.size()-1;++i)\\n\\t  for(int j=i+1;j<nums.size();++j)\\n\\t\\tif(nums[i]==nums[j]) counter++;\\n\\treturn counter;\\n}\\n```\\n\\n\\n**O(n)** [100% less memory usage] [100% less time usage]\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint count[101] = {};\\n\\tfor (auto n: nums)\\n\\t\\t++count[n];\\n\\treturn accumulate(begin(count), end(count), 0, [](int s, int i)\\n\\t\\t{ return s + i * (i - 1) / 2; });\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint counter = 0;\\n\\tfor(int i=0;i<nums.size()-1;++i)\\n\\t  for(int j=i+1;j<nums.size();++j)\\n\\t\\tif(nums[i]==nums[j]) counter++;\\n\\treturn counter;\\n}\\n```\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint count[101] = {};\\n\\tfor (auto n: nums)\\n\\t\\t++count[n];\\n\\treturn accumulate(begin(count), end(count), 0, [](int s, int i)\\n\\t\\t{ return s + i * (i - 1) / 2; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822102,
                "title": "python-99-27-o-n-easy-to-understand-its-math",
                "content": "Because pairs are only created if **nums[i] == nums[j]** and i < j, we can infer a arithmethic sequence from this condition. \\n\\nA hint was also given from the examples:\\n[1,1,1,1] have 6 combination\\nThe first 1 have 3 pairs\\nThe second 1 have 2 pairs\\nThe third 1 have 1 pairs\\nHence for 4 of 1\\'s, we can have 3 + 2 + 1 combination\\n\\nThen we just have to store every value count and then count arithmetic sequence sum from 1 to n, given n is the number of appearance for each number.\\n\\nPlease star it if you like my solution and explanation :), any advice or correction would be appreciated.\\n\\nThanks !\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for num in d:\\n            val = d[num]\\n            for i in range(val):\\n                pairs += i\\n        return pairs\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for num in d:\\n            val = d[num]\\n            for i in range(val):\\n                pairs += i\\n        return pairs\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 737778,
                "title": "c-speed-mem-o-n-o-n-w-o-map-video",
                "content": "Since the given nums.length() <= 100, space complexity is O(n).\\nhttps://www.youtube.com/watch?v=FlFxSnK2SmY\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int mem[101] ={0};\\n        int sum=0;\\n        \\n        for(int i=0; i < nums.size(); i++){\\n            sum += mem[nums[i]];\\n            ++mem[nums[i]];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int mem[101] ={0};\\n        int sum=0;\\n        \\n        for(int i=0; i < nums.size(); i++){\\n            sum += mem[nums[i]];\\n            ++mem[nums[i]];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966159,
                "title": "c-single-pass-solution-explained-100-time-96-space",
                "content": "This is a nice one that can be solved trivially, but it has some more challenge if you plan on tackling it in a more optimised way. My core intuition was that for each number `n` we basically need to apply the Gaussian formula to its frequency `f`, `-1` (since numbers can\\'t form couples with themselves in this problem).\\n\\nSo, if we encounter `9` once, we have `0` pairs; twice, we have `1` pair; thrice, we have `1 + 2 == 3` pairs; four times, we have `1 + 2 + 3 == 6` pairs and so on.\\n\\nWith that in mind, we have 2 ways to skin this cat \\uD83D\\uDC08 : the first one is to add for each number the cumulative frequency of its occurrence so far.\\n\\nTo do so, we declare 2 support variables;\\n* `res` to store our ongoing total;\\n* `seen` to collect the frequency of each element (and we know that all the values will go in the `1 - 100` range, so we can just use an array with `101` elements to avoid converting them into a `0`-indexed operation).\\n\\nFor each number `n`, we will:\\n* increase `res` by its previous comulative frequency so far `seen[n]`;\\n* increase said frequency by `1` with `seen[n]++`.\\n\\nOnce done, we can return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        for (auto n: nums) {\\n            // for each occurrence, we had the previously found matches to res...\\n            res += seen[n];\\n            // ...and then we update seen \\n            seen[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative version, which would be more perfoming with significantly longer inputs where an optimised multiplicative algorithm trumps manual sums, would do partially the same, first populating `seen` with all the relative frequencies (provided at least one element was found) and then applying the gaussian formula to them.\\n\\nInterestingly enough, this approach proved to be consistently slower and a bit more demanding in terms of memory (I guess due to how multiplications are usually computed):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        // populating seen with all the frequencies\\n        for (int n: nums) seen[n]++;\\n        // updating res based on the found frequencies\\n        for (int f: seen) if (f) res += f * (f - 1) / 2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        for (auto n: nums) {\\n            // for each occurrence, we had the previously found matches to res...\\n            res += seen[n];\\n            // ...and then we update seen \\n            seen[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        // populating seen with all the frequencies\\n        for (int n: nums) seen[n]++;\\n        // updating res based on the found frequencies\\n        for (int f: seen) if (f) res += f * (f - 1) / 2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080300,
                "title": "hash-table-explained-line-by-line-faster",
                "content": "Before solving the question we will keep two thing in mind.\\n1.The use of Vectors\\n2.The use of Hashing.\\n\\nHere, this question can be solved by a direct formula which we will use to find the number of good pairs.\\nThe formula is (n*(n-1))/2.\\n\\n*First we find the count of number occurences of a number. \\n*Then store the number count in the dictionary .\\n[1,2,3,1,1,3]\\n\\nkey - value pair\\n1     :         3\\n2     :         1\\n3     :         2\\n\\n*Then we consider n = value in the hash table\\n*using loop calculate the good pairs.\\n```\\n//Program to find the number of good pairs\\n//Good pairs are those in which nums[i] == nums[j] and i<j\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) \\n    {\\n   \\n        unordered_map<int,int> umap; //Initializing a Hash Table\\n         \\n        for(int i=0;i<nums.size();i++) //Iterating through the vector\\n        {\\n            ++umap[nums[i]];  //Counting the occurences of a number and storing it in value.\\n            \\n        }\\n        int good_pairs = 0;\\n        for(auto i:umap) //Using the formula \\n        {\\n            int n = i.second; //i.second implies -- value of hash table\\n            good_pairs += ((n)*(n-1))/2;\\n            \\n        }\\n        return good_pairs;\\n        \\n        \\n    }\\n};\\n    \\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n//Program to find the number of good pairs\\n//Good pairs are those in which nums[i] == nums[j] and i<j\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) \\n    {\\n   \\n        unordered_map<int,int> umap; //Initializing a Hash Table\\n         \\n        for(int i=0;i<nums.size();i++) //Iterating through the vector\\n        {\\n            ++umap[nums[i]];  //Counting the occurences of a number and storing it in value.\\n            \\n        }\\n        int good_pairs = 0;\\n        for(auto i:umap) //Using the formula \\n        {\\n            int n = i.second; //i.second implies -- value of hash table\\n            good_pairs += ((n)*(n-1))/2;\\n            \\n        }\\n        return good_pairs;\\n        \\n        \\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 975212,
                "title": "one-pass-o-n-time-using-hashmap",
                "content": "This is a basic concept of **combinations**:\\n```\\nn_C_r = n! / r! * (n-r)!\\n\\nwhere:\\nn_C_r\\t= \\tnumber of combinations\\nn\\t= \\ttotal number of objects in the set\\nr\\t= \\tnumber of choosing objects from the set\\n```\\nHere:\\n* The **set** would be with respect to a unique number at a time. (combinations for each distinct number)\\n* **n** is the number of occurences and **r = 2**, since we are choosing pairs. So replacing these values will lead to the formula: **n * (n-1)/2**\\n**Note**: Even with numbers with frequency 1 in total, the respective pairs will amount to 0 based on above formula. (Hence, 0 pairs)\\n\\n\\n# TL;DR\\n**Approach taken with an example:**\\n\\n- For a number with number of occurences count **n**, the number of good pairs would be: **n * (n-1)/2**\\n- We will consider the data structure **HashMap** that will store **key** as the number and number of occurrences as **value**.\\n\\nSo let\\'s say for array **[1,2,3,1,1,3,5,6,5]**, the Hashmap will have the following entries:\\n```\\n{\\n\\t1 : 3,\\n\\t2 : 1,\\n\\t3 : 2,\\n\\t5 : 2,\\n\\t6 : 1\\n}\\n```\\nThe required count would be: **(3 * 2/2) + (1 * 0/2) + (2 * 1/2) + (2 * 1/2) + (1 * 0/2) = 5**\\n, which is true since the good pairs are: **(0, 3), (0, 4), (3, 4), (2, 5), (6, 8)**\\n\\n**Short & Sweet:**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int count = 0;\\n        \\n        for(Integer num : nums)\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        \\n        for(Integer currCount : countMap.values())\\n            count += currCount * (currCount-1)/2;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nn_C_r = n! / r! * (n-r)!\\n\\nwhere:\\nn_C_r\\t= \\tnumber of combinations\\nn\\t= \\ttotal number of objects in the set\\nr\\t= \\tnumber of choosing objects from the set\\n```\n```\\n{\\n\\t1 : 3,\\n\\t2 : 1,\\n\\t3 : 2,\\n\\t5 : 2,\\n\\t6 : 1\\n}\\n```\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int count = 0;\\n        \\n        for(Integer num : nums)\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        \\n        for(Integer currCount : countMap.values())\\n            count += currCount * (currCount-1)/2;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732910,
                "title": "my-favorite-story-in-maths-the-prince-of-mathematicians",
                "content": "https://nrich.maths.org/2478 & https://nrich.maths.org/2478\\n\\nCarl Friedrich Gauss (1777-1855) is recognised as being one of the greatest mathematicians of all time.\\n\\nThe most well-known story is a tale from when Gauss was still at primary school. One day Gauss\\' teacher asked his class to add together all the numbers from 1 to 100, assuming that this task would occupy them for quite a while. He was shocked when young Gauss, after a few seconds thought, wrote down the answer 5050. The teacher couldn\\'t understand how his pupil had calculated the sum so quickly in his head, but the eight year old Gauss pointed out that the problem was actually quite simple.\\n![image](https://assets.leetcode.com/users/images/0bdd5099-5631-40e9-b3a6-ad5b11ba2eeb_1594576169.009218.png)\\n\\nHe had added the numbers in pairs \\n1. the first and the last (1+100=101)\\n2. the second and the second to last  (2+99=101) \\n3. and so on...\\n\\nso the total would be 50 lots of 101, which is 5050.\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, arr: List[int]) -> int:\\n        \\n\\t\\t#  Gauss\\'s insight as a child  ->  n(n + 1)/2\\n        def sumASeriesOfConsecutiveNumbers(n):\\n            return n*(n + 1)//2\\n        \\n        res = 0\\n        c = collections.Counter(arr)\\n        for v in c.values():\\n            res += sumASeriesOfConsecutiveNumbers(v-1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numIdenticalPairs(self, arr: List[int]) -> int:\\n        \\n\\t\\t#  Gauss\\'s insight as a child  ->  n(n + 1)/2\\n        def sumASeriesOfConsecutiveNumbers(n):\\n            return n*(n + 1)//2\\n        \\n        res = 0\\n        c = collections.Counter(arr)\\n        for v in c.values():\\n            res += sumASeriesOfConsecutiveNumbers(v-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341032,
                "title": "good-pairs-java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n     int counter = 0;\\n\\n     for(int i = 0; i < nums.length; i++){\\n         for(int j = i+1; j < nums.length; j++){\\n             if(nums[i] == nums[j]){\\n                 counter++;\\n                }\\n            }\\n        }\\n        return counter;   \\n    }\\n}\\n```\\nplease upvote me, to nourish the child of curiosity within me!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n     int counter = 0;\\n\\n     for(int i = 0; i < nums.length; i++){\\n         for(int j = i+1; j < nums.length; j++){\\n             if(nums[i] == nums[j]){\\n                 counter++;\\n                }\\n            }\\n        }\\n        return counter;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941264,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n    unordered_map<int,int> map;\\n    int res=0;\\n    for(int i:nums)\\n        res+=map[i]++;\\n    return res;\\n    }\\n};\\n```\\n\\n**Explanation:**\\n\\n[1,2,3,1,1,3]\\nconsider the above example\\n\\nres=0\\n\\n* iteration 1: map[1]=0 so res=0+0 =0 and map[1]=0+1 =1\\n* iteration 2: map[2]=0 so res=0+0 =0 and map[2]=0+1 =1\\n* iteration 3: map[3]=0 so res=0+0 =0 and map[3]=0+1 =1\\n* iteration 4: map[1]=1 so res=0+1 =1 and map[1]=1+1 =2\\n* iteration 5: map[1]=2 so res=2+1 =3 and map[1]=2+1 =3\\n* iteration 6: map[3]=1 so res=3+1 =4 and map[3]=1+1 =2\\n\\nfinally **res=4** is returned",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n    unordered_map<int,int> map;\\n    int res=0;\\n    for(int i:nums)\\n        res+=map[i]++;\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023592,
                "title": "golang-o-n-solution",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    cnt := make(map[int]int)\\n    var pairs int\\n    \\n    for _, num := range nums {\\n\\t\\tpairs += cnt[num]     //if num not in hash map \"cnt\", map returns default value of int (ie 0)\\n        cnt[num]++\\n    } \\n    return pairs\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    cnt := make(map[int]int)\\n    var pairs int\\n    \\n    for _, num := range nums {\\n\\t\\tpairs += cnt[num]     //if num not in hash map \"cnt\", map returns default value of int (ie 0)\\n        cnt[num]++\\n    } \\n    return pairs\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 742796,
                "title": "2-lines-in-javascript-using-counter-for-o-n-brute-o-n-2",
                "content": "Short and sweet:\\n```\\nfunction numIdenticalPairs(nums) { // O(n)\\n  const map = nums.reduce((m, n, i) => m.set(n, (m.get(n)||0) + 1), new Map());\\n  return [...map.values()].reduce((num, n) => num + n * (n - 1) / 2, 0);\\n};\\n```\\n\\nFirst line, count how many times each number appears.\\n2nd line, use the `n(n-1)/2`  to get how many combinations are possible.\\n\\nThis is the intuition for the formula, if you have only one number is zero, if you have a pair is two and so on.\\n\\n1: 0\\n2: 1\\n3: 2 + 1 = 3\\n4: 3 + 2 + 1 = 6\\n5: 4 + 3 + 2 + 1 = 10\\n\\nSo of the formula to getting all natural number added up is: `n(n-1)/2`.\\n\\nAlso, you can use the brute force for O(n^2):\\n\\n```js\\nfunction numIdenticalPairs(nums) { // O(n^2)\\n\\tlet sum = 0;\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tfor (let j = i + 1; j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] === nums[j]) sum++;\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction numIdenticalPairs(nums) { // O(n)\\n  const map = nums.reduce((m, n, i) => m.set(n, (m.get(n)||0) + 1), new Map());\\n  return [...map.values()].reduce((num, n) => num + n * (n - 1) / 2, 0);\\n};\\n```\n```js\\nfunction numIdenticalPairs(nums) { // O(n^2)\\n\\tlet sum = 0;\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tfor (let j = i + 1; j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] === nums[j]) sum++;\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738609,
                "title": "javascript-3-solutions",
                "content": "**Brute force solution:**\\nO(N^2) time + O(1) space\\nlogic:\\n- nested loop i (start from beginning) & j (start from end)\\n- if `nums[i] === nums[j]`, increment count\\n```\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0; \\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = nums.length - 1; j > i; j--) {\\n            if (nums[i] === nums[j]) count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```\\n_____\\n**Optimized Time**\\nO(N) time + O(N) space\\nlogic: \\n- Use an object to store numbers (can also use array since this problem have constraint of `1 <= nums[i] <= 100`\\n- when new number is added to object, set 1 as value\\n- if current number already exist in object, add 1 to current value + add the value to `count`\\n```\\nvar numIdenticalPairs = function(nums) {\\n    const map = {};\\n    let count = 0;\\n    nums.forEach(num => {\\n        if (map[num]) {\\n            count += map[num];\\n            map[num]++;\\n        } else {\\n            map[num] = 1;\\n        }\\n    })\\n    return count;\\n};\\n```\\n____ \\n**Optimized Space**\\nO(NlogN) time + O(1) space\\nlogic: \\n- use sorting to sort nums (sorting takes NlogN time)\\n- have `curCount = 1`  and update it as we see same neighboring numbers in the array\\n- add `curCount` to `totalCount`\\n- reset `curCount` to 1 when neighboring numbers are not the same\\n\\n```\\nvar numIdenticalPairs = function(nums) {\\n    nums.sort();\\n    let totalCount = 0; \\n    let curCount = 1;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            totalCount += curCount;\\n            curCount++;\\n        } else {\\n            curCount = 1;\\n        }\\n    }\\n    \\n    return totalCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0; \\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = nums.length - 1; j > i; j--) {\\n            if (nums[i] === nums[j]) count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```\n```\\nvar numIdenticalPairs = function(nums) {\\n    const map = {};\\n    let count = 0;\\n    nums.forEach(num => {\\n        if (map[num]) {\\n            count += map[num];\\n            map[num]++;\\n        } else {\\n            map[num] = 1;\\n        }\\n    })\\n    return count;\\n};\\n```\n```\\nvar numIdenticalPairs = function(nums) {\\n    nums.sort();\\n    let totalCount = 0; \\n    let curCount = 1;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            totalCount += curCount;\\n            curCount++;\\n        } else {\\n            curCount = 1;\\n        }\\n    }\\n    \\n    return totalCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941242,
                "title": "python-simple-solutions",
                "content": "#### Solution 1: Using count\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            c+=nums[:i].count(nums[i])\\n        return c\\n```\\n\\n#### Solution 2: Using dictionary\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={};c=0\\n        for i in nums:\\n            if i in d:\\n                c+=d[i]\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            c+=nums[:i].count(nums[i])\\n        return c\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={};c=0\\n        for i in nums:\\n            if i in d:\\n                c+=d[i]\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154018,
                "title": "swift-number-of-good-pairs",
                "content": "```swift\\nclass Solution {\\n    func numIdenticalPairs(_ nums: [Int]) -> Int {\\n        var res = 0, map = [Int:Int]()\\n        nums.forEach {\\n            res += map[$0] ?? 0\\n            map[$0,default: 0] += 1\\n        }\\n        return res\\n    }\\n}\\n```\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.031 (0.033) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3,1,1,3]), 4)\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,1,1,1]), 6)\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3]), 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func numIdenticalPairs(_ nums: [Int]) -> Int {\\n        var res = 0, map = [Int:Int]()\\n        nums.forEach {\\n            res += map[$0] ?? 0\\n            map[$0,default: 0] += 1\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.031 (0.033) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3,1,1,3]), 4)\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,1,1,1]), 6)\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3]), 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733661,
                "title": "basic-java-solution",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int i=0,j=0,c=0;\\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                    c++;;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int i=0,j=0,c=0;\\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                    c++;;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417146,
                "title": "simple-c-code-beats-100-time",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two iterators, traverse one iterator from other till the end of the vector and check if both have same value or not.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        std::vector<int>::iterator itr1,itr2;\\n        int count=0;\\n        for(itr1=nums.begin();itr1!=nums.end();itr1++)\\n        {\\n            for(itr2=itr1+1;itr2!=nums.end();itr2++)\\n            {\\n                if(*itr1==*itr2)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        std::vector<int>::iterator itr1,itr2;\\n        int count=0;\\n        for(itr1=nums.begin();itr1!=nums.end();itr1++)\\n        {\\n            for(itr2=itr1+1;itr2!=nums.end();itr2++)\\n            {\\n                if(*itr1==*itr2)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564800,
                "title": "python-o-n-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tcountPairs = 0\\n\\tcounter = {}\\n\\n\\tfor n in nums:\\n\\t\\tif n in counter:\\n\\t\\t\\tcountPairs += counter[n]\\n\\t\\t\\tcounter[n] += 1\\n\\n\\t\\telse:\\n\\t\\t\\tcounter[n] = 1\\n\\n\\treturn countPairs\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tcountPairs = 0\\n\\tcounter = {}\\n\\n\\tfor n in nums:\\n\\t\\tif n in counter:\\n\\t\\t\\tcountPairs += counter[n]\\n\\t\\t\\tcounter[n] += 1\\n\\n\\t\\telse:\\n\\t\\t\\tcounter[n] = 1\\n\\n\\treturn countPairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1122623,
                "title": "clear-explanation-using-combinations-for-pairs",
                "content": "We are asked to return the total number of pairs in a list of numbers  (`pair (i,j)` is called good if `nums[i] == nums[j]` and `i < j`).\\n\\nFirst, let\\'s consider a list of just one number, e.g. `nums = [1]`.  Here, this number cannot be paired with any others (other than itself), so the result is zero.\\n\\nNext, let\\'s consider a list of all idential numbers, e.g. `nums = [1, 1, 1, 1]`.  What we are really being asked is how many combinations of two can be made from such a list.  Using zero based indexing, we have the following six pairs of such combinations:\\n```\\n(0, 1), (0, 2), (0, 3)  # The first number at index 0 can be paired with the others at index locations 1, 2 and 3.\\n        (1, 2), (1, 3)  # The second at index 1 can be paired with its matching pair at index locations 2 and 3.\\n\\t\\t        (2, 3)  # The third at index 2 can form a unique pair with the number at index location 3.\\n```\\n\\nMore generally, the combination formula is `n! / [k! * (n - k)!]`.  In this problem, `n` represents the count of a given number and `k=2` because we are looking at unique pairs.  So the general formula becomes `n! / [2 * (n - 2)!]`.  Noting that  `n! / (n - 2)!` is simply `n * (n - 1)` after cancelling the factorial terms, the total number of unique pairs of the same number can be calculated as `n * (n - 1) / 2`.\\n\\nNow let\\'s say we are given the following ten mixed numbers:\\n`nums = [1, 2, 3, 1, 3, 2, 2, 4, 2, 3]`\\n\\nThe first thing we want to do is count the number of occurrences of each number, so `number: count of number`\\n```\\n1: 2\\n2: 4\\n3: 3\\n4: 1\\n```\\n\\nNote that when `n = 1`, then  `n * (n - 1) / 2` is simply zero and can hence be ignored (one item cannot be paired with any matching item).\\n\\nSo, the result is as follows given the above set of ten numbers with their respective counts:\\n```\\n1: 2 -> 2 * (2 - 1) / 2 = 1\\n2: 4 -> 4 * (4 - 1) / 2 = 6\\n3: 3 -> 3 * (3 - 1) / 2 = 3\\n4: 1 -> 1 * (1 - 1) / 2 = 0\\n```\\nThe answer in this example is thus `1 + 6 + 3 = 10`.\\n\\n<strong>Python Implementations</strong>\\n\\nNote that all of this can be solved simply in python using `Counter` and using a generator expression to sum the calculations for each counted value. Note that `n * (n - 1)` always results in an even number because it is the product of an odd number and an even number.  We can therefore use floor division on the summed result because this summed result will be even. All intermediate results are guaranteed to be integers as is the final result.  Note that summing everything and then dividing by two just once is slightly more efficient that summing all intermediate `n * (n - 1) / 2` calculations.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(num * (num - 1) for num in Counter(nums).values()) // 2\\n```\\n\\nAn alternative solution that just uses one pass (`O(n)` time complexity) to calculated the total pairs:\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        counts = {}\\n        for num in nums:\\n            prior_num_count = counts.get(num, 0)\\n            pairs += prior_num_count\\n            counts[num] = prior_num_count + 1\\n        return pairs\\n```\\n\\nBy observing the cumulative count, one notes that it is equal to the sum of the prior counts plus one minus the current total count (i.e. the prior count). The solution immediately above uses this obvservation, increasing the pairs count by one less than the number of occurrences observed for each number.  This solution has the same `O(n)` space complexity as the prior solution, as they both require the use of a dictionary/hashmap to keep track of the counts for each number observed.\\n\\n```\\ncount: sum of prior counts + (count - 1)\\n1: 0\\n2: 1 (0 + 1)\\n3: 3 (1 + 2)\\n4: 6 (3 + 3)\\n5: 10 (6 + 4)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n(0, 1), (0, 2), (0, 3)  # The first number at index 0 can be paired with the others at index locations 1, 2 and 3.\\n        (1, 2), (1, 3)  # The second at index 1 can be paired with its matching pair at index locations 2 and 3.\\n\\t\\t        (2, 3)  # The third at index 2 can form a unique pair with the number at index location 3.\\n```\n```\\n1: 2\\n2: 4\\n3: 3\\n4: 1\\n```\n```\\n1: 2 -> 2 * (2 - 1) / 2 = 1\\n2: 4 -> 4 * (4 - 1) / 2 = 6\\n3: 3 -> 3 * (3 - 1) / 2 = 3\\n4: 1 -> 1 * (1 - 1) / 2 = 0\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(num * (num - 1) for num in Counter(nums).values()) // 2\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        counts = {}\\n        for num in nums:\\n            prior_num_count = counts.get(num, 0)\\n            pairs += prior_num_count\\n            counts[num] = prior_num_count + 1\\n        return pairs\\n```\n```\\ncount: sum of prior counts + (count - 1)\\n1: 0\\n2: 1 (0 + 1)\\n3: 3 (1 + 2)\\n4: 6 (3 + 3)\\n5: 10 (6 + 4)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195779,
                "title": "java-hashmap-100-faster",
                "content": "**1.** we make a HashMap<Integer, Integer> , which we will use to store freq of each num (How many times every num has appeared in array) \\n\\n**2.** we traverse through nums array and for each num :\\n* we check if ( it is already present in our HashMap or not ):\\n*  * A) num is not already present in HashMap : *Then it has only one occurrence and it can not make pair with itself. We simply put it in HashMap with its frequecy as 1.*\\n B) num is already present in HashMap : Then it means there are (one or) more than one occurrences of it previously and now it can make pairs.  ( but how many pairs?  ) \\n To know how many pairs? we need to know how many times it has previously appeared in the array ( that\\'s why we used HashMap instead of Hashset to store the current frequency of num. )\\n we get the frequency ( k ) of num from HashMap ( which is also equal to the number of  pairs it can make ). add then add freq ( k) to count [ count += k; ]. Then increment the freq of that num by one and put new freq in hashMap [ hs.put(n, k + 1); ]\\n \\n** 3.**  we count all such pairs in \\'count\\' variable. which is our final answer.\\n\\n# CODE:\\n\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> hs = new HashMap<>();\\n        int count = 0;\\n        for (int n : nums) {\\n            if (hs.containsKey(n)) {\\n                int k = hs.get(n);\\n                count += k;\\n                hs.put(n, k + 1);\\n            } else {\\n                hs.put(n, 1);\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```\\n\\n# **EXAMPLE DRY RUN:**\\nwe have have array as { 3,3,3,3 } then we start traversing....\\n\\n**index 0 :** value = 3.... and frequency(3) = 0.... and good pairs = 0; \\n===> update frequency(3) = 1 and still good pairs = 0 bcz only one occurrence of 3 till now.\\n\\n**index 1:** value = 3.... and frequency(3) = 1.... and good pairs = 0;\\n===>access previous frequency(3) = 1 and update good pairs = 0+1 (bcz the \\'3\\' at \\'index 1\\' can make *one* new pair with \\'3\\' at \\'index 0\\')\\n===> update frequency(3) = 2\\n\\n**index 2:** value = 3.... and frequency(3) = 2.... and good pairs = 1; \\n===>access previous frequency(3) = 2 and update good pairs = 0+1+2 (bcz the \\'3\\' at \\'index 2\\' can make* two* new pairs with \\'3\\' at \\'index 1\\' & with \\'3\\' at \\'index 0\\' )\\n===> update frequency(3) = 3.\\n\\n**index 3:** value = 3.... and frequency(3) = 3.... and good pairs = 3;\\n===>access previous frequency(3) = 3 and update good pairs = 0+1+2+3 (bcz the \\'3\\' at \\'index 3\\' can make* three *new pairs with \\'3\\' at \\'index 2\\' & with \\'3\\' at \\'index 1\\' & & with \\'3\\' at \\'index 0\\')\\n===> update frequency(3) = 4.\\n\\n*good pairs* = 0+1+2+3 = 6",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> hs = new HashMap<>();\\n        int count = 0;\\n        for (int n : nums) {\\n            if (hs.containsKey(n)) {\\n                int k = hs.get(n);\\n                count += k;\\n                hs.put(n, k + 1);\\n            } else {\\n                hs.put(n, 1);\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066453,
                "title": "c-java-c-python-easy-to-understand-clean-code-with-comment",
                "content": "This code implements an optimized solution to solve the \"Number of Good Pairs\" problem. The problem requires counting the number of good pairs in an array of integers.\\n\\nTo solve the problem, the code follows these steps:\\n\\n- **Initialization**: An array called \"count\" is created with a size of 101. This array will be used to store the counts of each number. Since the problem specifies that the integers in the array are in the range 1 to 100, using an array of size 101 ensures coverage for all possible values. Additionally, a variable named \"goodPairs\" is initialized to keep track of the count of good pairs found so far. This variable will be returned as the final result.\\n\\n- **Iteration**: The code iterates through the \"nums\" array using a foreach loop. For each number, denoted as \"num,\" the following steps are performed:\\n\\n  a. Incrementing goodPairs: The code increases \"goodPairs\" by the current count of \"num\" in the \"count\" array. This step takes into account the number of existing pairs that \"num\" can form with previous occurrences of the same number. For example, if there are \"x\" occurrences of \"num\" before the current iteration, it means that there are \"x\" pairs that \"num\" can form with those previous occurrences. Therefore, \"goodPairs\" is increased by \"x\".\\n\\n  b. Updating count: The code increments the count of \"num\" in the \"count\" array by 1 to account for the current occurrence of \"num.\" This ensures that all occurrences of each number are correctly counted.\\n\\n- **Return**: Finally, the code returns the value of \"goodPairs,\" which represents the total number of good pairs found in the \"nums\" array.\\n\\nIn summary, the code efficiently solves the problem by using an optimized approach with a time complexity of O(n), where \"n\" is the length of the \"nums\" array. The space complexity is constant, O(1), as it uses a fixed-size array (\"count\") to store the counts, which does not depend on the input size.\\n```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        vector<int> count(101, 0);\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        foreach (int num in nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        count = [0] * 101\\n        goodPairs = 0\\n        for num in nums:\\n            goodPairs += count[num]  # Increase goodPairs by the current count\\n            count[num] += 1  # Increment the count of the number\\n        return goodPairs\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        vector<int> count(101, 0);\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        foreach (int num in nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        count = [0] * 101\\n        goodPairs = 0\\n        for num in nums:\\n            goodPairs += count[num]  # Increase goodPairs by the current count\\n            count[num] += 1  # Increment the count of the number\\n        return goodPairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745047,
                "title": "c-o-n-easy-solution-using-unordered-map",
                "content": "We store the count of each number in unordered map, if the count of a number is greater than 1 then we increase the variable res  and store the number of possible combinations which satisfy the given condition given in the question (nums[i] == nums[j] and i<j)\\n```\\nclass Solution {\\npublic:\\n    \\n    int numIdenticalPairs(vector<int>& nums) {\\n        int res=0;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second > 1){\\n                res += (x.second * (x.second - 1))/2; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numIdenticalPairs(vector<int>& nums) {\\n        int res=0;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second > 1){\\n                res += (x.second * (x.second - 1))/2; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731660,
                "title": "optimal-and-suboptimal-completely-explained-with-2-solutions",
                "content": "\\nThis is the bruteforce approach.\\n\\nTime:O(n^2)\\nSpace:O(1)\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        res = 0 \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] == nums[j]:\\n                    res+=1\\n        return res\\n```\\n\\nThis is the optimal solution which stores the {number,[list of indices of occurence of number]} as an event.\\nThen find the number of number of pairs from each event.\\nTime:O(n) | Space:O(n)\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        events = collections.defaultdict(list)\\n        for idx,num in enumerate(nums):\\n            events[num].append(idx)\\n        count = lambda x:x*(x-1)//2 if x>1 else 0\\n        res = 0 \\n        for event in events:\\n            indices = events[event]\\n            length = len(indices)\\n            ans = count(length)\\n            res+=ans\\n        return res\\n```\\n\\nThis is very critical in the interview setting.Dont get satisfied after proposing the first solution.I mean anyone could do the first\\nsolution and its pretty naive.Discuss all possible approaches with their Time and space complexities.If you observe,its a tradeoff with memory\\nand optimising time in the second solution. In eitherway,both solution are good and we need to choose according to the situation based on time,memory constraints.\\n\\nThanks for your time :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        res = 0 \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] == nums[j]:\\n                    res+=1\\n        return res\\n```\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        events = collections.defaultdict(list)\\n        for idx,num in enumerate(nums):\\n            events[num].append(idx)\\n        count = lambda x:x*(x-1)//2 if x>1 else 0\\n        res = 0 \\n        for event in events:\\n            indices = events[event]\\n            length = len(indices)\\n            ans = count(length)\\n            res+=ans\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675214,
                "title": "java-o-n-1-line-logic-easy",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int ans = 0;\\n        int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            ans += temp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int ans = 0;\\n        int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            ans += temp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601830,
                "title": "simple-o-n-java-solution-hashmap",
                "content": "**Upvote if you LIKE**\\uD83D\\uDE42 \\nclass Solution {\\n\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                count += hm.get(nums[i]);\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n                hm.put(nums[i],1);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                count += hm.get(nums[i]);\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 851005,
                "title": "c-0-ms-faster-than-100-00-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        //Using map to store frequencies of each element\\n        map<int,int> count;\\n        \\n        int noOfPairs = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            count[nums[i]]+=1;\\n        }\\n        \\n        //if there are say n 1\\'s then idea is that there will\\n        //will be exactly 1+2+....+(n-1) no. of pairs which is\\n        //(n)*(n-1)/2\\n        \\n        for(auto ele: count){\\n            noOfPairs+=(ele.second)*(ele.second - 1)/2; \\n        }\\n        \\n        return noOfPairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        //Using map to store frequencies of each element\\n        map<int,int> count;\\n        \\n        int noOfPairs = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            count[nums[i]]+=1;\\n        }\\n        \\n        //if there are say n 1\\'s then idea is that there will\\n        //will be exactly 1+2+....+(n-1) no. of pairs which is\\n        //(n)*(n-1)/2\\n        \\n        for(auto ele: count){\\n            noOfPairs+=(ele.second)*(ele.second - 1)/2; \\n        }\\n        \\n        return noOfPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731682,
                "title": "c-simple-o-n-2-solution",
                "content": "```csharp\\npublic int NumIdenticalPairs(int[] nums) \\n{\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tfor(int j = i + 1; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(nums[i] == nums[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumIdenticalPairs(int[] nums) \\n{\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tfor(int j = i + 1; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(nums[i] == nums[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109723,
                "title": "simple-solution-number-of-good-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i<j:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i<j:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873992,
                "title": "javascript-solution-faster-than-97-43-of-other-submissions-map-array-reduce",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\nRuntime: 58 ms\\nMemory Usage: 41.7 MB\\n\\n```\\n\\n/**\\n * @param {number[]} nums\\n * @param {Map} map\\n * @return {number}\\n */\\nconst numIdenticalPairs = (nums, map = new Map(), res = 0) => {\\n    for (let i = 0; i < nums.length; i++) {\\n        let temp = map.get(nums[i]);\\n        if (temp) res += temp;\\n        /** Everytime same value is found in other index it can be paired with \\n         * existing one so adding previous value to result \\n         */\\n        map.set(nums[i], temp ? temp + 1 : 1);\\n    }\\n    return res;\\n};\\n```\\n\\n\\nSolution 2 with Map and Array reduce method a slight variation\\n\\n```\\nconst numIdenticalPairs = (nums, map = new Map()) => nums.reduce((prev, cur) => {\\n    if (map.get(cur)) {\\n        prev += map.get(cur);\\n        map.set(cur, map.get(cur) + 1);\\n    } else {\\n        map.set(cur, 1)\\n    }\\n    return prev;\\n}, 0);\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number[]} nums\\n * @param {Map} map\\n * @return {number}\\n */\\nconst numIdenticalPairs = (nums, map = new Map(), res = 0) => {\\n    for (let i = 0; i < nums.length; i++) {\\n        let temp = map.get(nums[i]);\\n        if (temp) res += temp;\\n        /** Everytime same value is found in other index it can be paired with \\n         * existing one so adding previous value to result \\n         */\\n        map.set(nums[i], temp ? temp + 1 : 1);\\n    }\\n    return res;\\n};\\n```\n```\\nconst numIdenticalPairs = (nums, map = new Map()) => nums.reduce((prev, cur) => {\\n    if (map.get(cur)) {\\n        prev += map.get(cur);\\n        map.set(cur, map.get(cur) + 1);\\n    } else {\\n        map.set(cur, 1)\\n    }\\n    return prev;\\n}, 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651454,
                "title": "c-hashmap-solution-explained",
                "content": "**Hello Everyone!**\\nI hope you find this solution helpful, feel free to comment suggestions and critiques!\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            //Go through the vector given and increment the map by 1\\n\\t\\t\\t// everytime the same number appears. This is counting the \\n\\t\\t\\t// frequency of that number\\n\\t\\t\\t++mp[nums[i]];\\n\\t\\t\\t\\n\\t\\t\\t//If the number shows up more than once, then it has atleast one pair\\n            if (mp[nums[i]] > 1)\\n            {\\n\\t\\t\\t\\t//add to the answer the frequency - 1\\n\\t\\t\\t\\t// (appearing two times means there is one pair, three times is two pairs, etc etc\\n                ans += mp[nums[i]] - 1;       \\n            }\\n        }\\n\\t\\t//return the answer\\n        return ans;\\n    }\\n};\\n```\\nPlease leave an upvote if you found this solution helpful!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            //Go through the vector given and increment the map by 1\\n\\t\\t\\t// everytime the same number appears. This is counting the \\n\\t\\t\\t// frequency of that number\\n\\t\\t\\t++mp[nums[i]];\\n\\t\\t\\t\\n\\t\\t\\t//If the number shows up more than once, then it has atleast one pair\\n            if (mp[nums[i]] > 1)\\n            {\\n\\t\\t\\t\\t//add to the answer the frequency - 1\\n\\t\\t\\t\\t// (appearing two times means there is one pair, three times is two pairs, etc etc\\n                ans += mp[nums[i]] - 1;       \\n            }\\n        }\\n\\t\\t//return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101026,
                "title": "python-1-liner-without-using-counter",
                "content": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        return (sum(i==j for j in nums for i in nums)-len(nums))//2\\n```",
                "solutionTags": [],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        return (sum(i==j for j in nums for i in nums)-len(nums))//2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 990196,
                "title": "python-3-faster-than-99-48",
                "content": "The solution to this problem uses a small math formula and a hash table. The following is the approach I used,\\n\\n1. Build a dictionary to store the array items as keys and the value is a list of indices where this element appears. Ex: nums = [1,2,1,1]. d = { 1: [0,2,3], 2: [1]}. As I am iterating through the array linearly, this automatically guarantees i < j.\\n2. In this dicitionary check for the presence of lists whose length is greater than 1, which means the element repeats. In those cases, it is the number of pairs we can form with the elements of that list incrementally. Say the lenght of a list is n, this is equivalent to summing up the numbers upto n-1. \\n3. Using Gauss\\'s trick, sum of numbers upto n, is n(n+1) / 2. Modifying it slightly for n-1, it is (n-1)n / 2. Add this for each list whose length is greater than 1 to the answer variable. Ex: consider the dictionary d = { 1: [0,2,3], 2: [1]}, for this list 1 has 3 elements, so we add (3-1) * 3 / 2 = 3 to the answer.\\n\\nFollowing code implements it.\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        d = defaultdict(list)\\n        for i in range(len(nums)):\\n            d[nums[i]].append(i)\\n        # print(d)\\n        for k,v in d.items():\\n            n = len(v)\\n            # print(n)\\n            if n > 1:\\n                ans += ((n-1) * n) // 2\\n        return ans\\n```\\n\\nWhile this is faster than 99.48% python 3 solutions, it doesn\\'t perform that well on space.  Any suggestions are appreciated.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        d = defaultdict(list)\\n        for i in range(len(nums)):\\n            d[nums[i]].append(i)\\n        # print(d)\\n        for k,v in d.items():\\n            n = len(v)\\n            # print(n)\\n            if n > 1:\\n                ans += ((n-1) * n) // 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893146,
                "title": "python-98-with-o-n",
                "content": "Solution1: Brute force\\nTC= O(n*2)\\nSC O(n)\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                 if nums[i]==nums[j] and i<j:\\n                     count +=1\\n        return count\\n```\\n\\nSolution2 : Optimize in O(n)\\n\\nTC O(n)\\nSC O(1)\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dic = {}\\n        count =0\\n        \\n        for num in nums:\\n            if num in dic:\\n                count +=dic[num]\\n                dic[num] +=1\\n            else:\\n                dic[num] =1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                 if nums[i]==nums[j] and i<j:\\n                     count +=1\\n        return count\\n```\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dic = {}\\n        count =0\\n        \\n        for num in nums:\\n            if num in dic:\\n                count +=dic[num]\\n                dic[num] +=1\\n            else:\\n                dic[num] =1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 879663,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        int ans=0;\\n        for(auto n:nums){\\n            map[n]++;\\n            ans+=(map[n]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        int ans=0;\\n        for(auto n:nums){\\n            map[n]++;\\n            ans+=(map[n]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185645,
                "title": "easy-java-hashmap-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis Java code defines a method named **numIdenticalPairs** that takes an array of integers nums and returns the number of good pairs of indices **(i, j)** such that **nums[i] == nums[j]** and **i < j**. A good pair is a pair of indices that satisfies the condition.\\n\\nThe code first creates a hash map to store the count of occurrences of each number in the input array. It then iterates over the map and computes the count of good pairs for each number using the formula **m*(m-1)/2**, where m is the count of occurrences of the number. The total count of good pairs is accumulated in the count variable and returned.\\n\\nThe time complexity of the code is **O(n)**, where n is the length of the input array, because it uses a hash map to count the occurrences of each number, which takes **O(n)** time, and then iterates over the map, which takes **O(m)** time where m is the number of distinct numbers in the array (which is usually much smaller than n).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++){\\n            if(map.containsKey(nums[i]))\\n                map.put(nums[i],map.get(nums[i])+1);\\n            else\\n                map.put(nums[i],1);\\n        }\\n        for(Map.Entry<Integer,Integer> e: map.entrySet()){\\n            if(e.getValue()>0){\\n                int m = e.getValue();\\n                count+=(m*(m-1))/2;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n## If you find this helpful then pls upvote me..........",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++){\\n            if(map.containsKey(nums[i]))\\n                map.put(nums[i],map.get(nums[i])+1);\\n            else\\n                map.put(nums[i],1);\\n        }\\n        for(Map.Entry<Integer,Integer> e: map.entrySet()){\\n            if(e.getValue()>0){\\n                int m = e.getValue();\\n                count+=(m*(m-1))/2;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746064,
                "title": "java-simple-explanation-o-n-time-0-ms-faster-than-100",
                "content": "We declared an empty array of size 101 since 101 is the max number given in constraints.\\nThe temp array looks like [0, 0, 0, 0, 0, ... , 0] now.\\n\\nWe are now looping in the given nums array and going to each element and adding it\\'s temp count.\\n\\nLet\\'s understand this by an example.\\nGiven `nums = [1,2,3,1,1,3]`\\nwhen i=0, we will check nums[i] which is num[0] = 1.\\nThen we will go to temp[nums[i]] which is temp[1] = 0 for now. So we will add it to count 0 + 0 = 0.\\nThen we will perform temp[1]++ which means we will make the temp array look like [0,1,0,0,0...0]\\n\\nNow, we will have i =1:\\nnums[1]=2\\ntemp[2]++\\ncount = 0 + 0\\nNow the temp array will look like [0, 1, 1, 0, 0, ... , 0]\\n\\ni = 2\\nnums[2] = 3\\ntemp[3]++\\ncount = 0 + 0\\nNow the temp array will look like [0, 1, 1, 1, 0, 0, ... , 0]\\n\\nNow for i = 3\\nnums[3] = 1\\ntemp[1]++\\ncount = 0 + 1\\nNow the temp array will look like [0, 2, 1, 1, 0, 0, ... , 0]\\n\\nNow for i = 4\\nnums[4] = 1\\ntemp[1]++\\ncount = 1 + 2\\nNow the temp array will look like [0, 3, 1, 1, 0, 0, ... , 0]\\n\\nFor i = 5\\nnums[5] = 3\\ntemp[3]++\\ncount = 3 + 1\\nNow the temp array will look like [0, 3, 1, 2, 0, ... , 0]\\n\\nWe will return count which is 4\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] temp = new int[101];\\n        \\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            count += temp[nums[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] temp = new int[101];\\n        \\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            count += temp[nums[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544514,
                "title": "easy-java-solution-simple-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length; i ++){\\n            for(int j = i + 1; j < nums.length; j ++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length; i ++){\\n            for(int j = i + 1; j < nums.length; j ++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383728,
                "title": "python3-hash-table-o-n-93-3-faster-98-04-memory-efficient",
                "content": "\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={}\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                d[nums[i]]+=1\\n                c+=d[nums[i]]\\n            else:\\n                d[nums[i]]=0\\n        return c\\n```\\nPlease Upvote\\nHappy Coding!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={}\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                d[nums[i]]+=1\\n                c+=d[nums[i]]\\n            else:\\n                d[nums[i]]=0\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1066531,
                "title": "kotlin-1-line",
                "content": "```\\nfun numIdenticalPairs(a: IntArray) = a.mapIndexed { i, n -> a.slice(i + 1..a.lastIndex).count { it == n } }.sum()\\n```\\n**Approach 2:**\\n```\\nfun numIdenticalPairs(a: IntArray): Int {\\n    var c = 0\\n    a.forEachIndexed { i, n -> for (j in i + 1 until a.size) if (n == a[j]) c++ }\\n    return c\\n}\\n```\\n**Approach 3:**\\n```\\nfun numIdenticalPairs(nums: IntArray): Int {\\n    val map = mutableMapOf<Int, Int>()\\n    var count = 0\\n    nums.forEach {\\n        if (map.containsKey(it)) count += map[it]!!\\n        map[it] = map.getOrDefault(it, 0) + 1\\n    }     \\n    return count\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun numIdenticalPairs(a: IntArray) = a.mapIndexed { i, n -> a.slice(i + 1..a.lastIndex).count { it == n } }.sum()\\n```\n```\\nfun numIdenticalPairs(a: IntArray): Int {\\n    var c = 0\\n    a.forEachIndexed { i, n -> for (j in i + 1 until a.size) if (n == a[j]) c++ }\\n    return c\\n}\\n```\n```\\nfun numIdenticalPairs(nums: IntArray): Int {\\n    val map = mutableMapOf<Int, Int>()\\n    var count = 0\\n    nums.forEach {\\n        if (map.containsKey(it)) count += map[it]!!\\n        map[it] = map.getOrDefault(it, 0) + 1\\n    }     \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1031419,
                "title": "javascript-solution-93-speed-using-map-and-counter",
                "content": "```/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    const map = new Map();\\n    let pairs = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (map.has(nums[i])) {\\n            pairs += map.get(nums[i]);\\n            map.set(nums[i], map.get(nums[i]) + 1);\\n        } else {\\n            map.set(nums[i], 1);\\n        }\\n    }\\n    return pairs;\\n};\\n\\nWe can also use for...of instead of traditional for loop",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    const map = new Map();\\n    let pairs = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (map.has(nums[i])) {\\n            pairs += map.get(nums[i]);\\n            map.set(nums[i], map.get(nums[i]) + 1);\\n        } else {\\n            map.set(nums[i], 1);\\n        }\\n    }\\n    return pairs;\\n};\\n\\nWe can also use for...of instead of traditional for loop",
                "codeTag": "Unknown"
            },
            {
                "id": 935442,
                "title": "simple-javascript-solution",
                "content": "```\\nvar numIdenticalPairs = function(nums) {\\n      let obj = {};\\n      let counter = 0;\\n\\n      for (val of nums) {\\n        if (obj[val]) {\\n          counter += obj[val];\\n          obj[val]++;\\n        } else {\\n          obj[val] = 1;\\n        }\\n      }\\n      console.log(obj);\\n      return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n      let obj = {};\\n      let counter = 0;\\n\\n      for (val of nums) {\\n        if (obj[val]) {\\n          counter += obj[val];\\n          obj[val]++;\\n        } else {\\n          obj[val] = 1;\\n        }\\n      }\\n      console.log(obj);\\n      return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 837450,
                "title": "python3-solution-with-a-single-pass-and-no-if-else-statements",
                "content": "This solution makes use of a single pass and no if-else statements.\\n\\n[@navinmittal29](https://leetcode.com/navinmittal29) Thanks for your suggestion on how to avoid using the if-else statements in my previous solution.\\n\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        my_count = 0\\n        my_dict = {}\\n        \\n        for n in nums:\\n            # Check to see if number has already been encountered\\n            # and increase count by the number of previous instances\\n            my_count += my_dict.get(n, 0) \\n\\n            # Increase the count of previous observation\\n            # Or store newly encountered number along with its count\\n            my_dict[n] = my_dict.get(n, 0) + 1\\n                \\n        return my_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        my_count = 0\\n        my_dict = {}\\n        \\n        for n in nums:\\n            # Check to see if number has already been encountered\\n            # and increase count by the number of previous instances\\n            my_count += my_dict.get(n, 0) \\n\\n            # Increase the count of previous observation\\n            # Or store newly encountered number along with its count\\n            my_dict[n] = my_dict.get(n, 0) + 1\\n                \\n        return my_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731739,
                "title": "java-python-3-4-1-liners-o-n-counting-codes-w-brief-explanation-and-analysis",
                "content": "For any given `i` items, we have `C(i, 2) = (i - 1) * i / 2` combination options if choosing pairs from the `i` elements.\\n```java\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] cnt = new int[101];\\n        for (int n : nums)\\n            ++cnt[n];\\n        return Arrays.stream(cnt).map(i -> (i - 1) * i / 2).sum();\\n    }\\n```\\n```python\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(v * (v - 1) // 2 for v in Counter(nums).values())\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(R)`, where `R = cnt.length`, the range of the `nums`.",
                "solutionTags": [],
                "code": "```java\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] cnt = new int[101];\\n        for (int n : nums)\\n            ++cnt[n];\\n        return Arrays.stream(cnt).map(i -> (i - 1) * i / 2).sum();\\n    }\\n```\n```python\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(v * (v - 1) // 2 for v in Counter(nums).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3837000,
                "title": "c-3-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int ans = 0, freq[101] = {0};\\n        for(auto i : nums) ans += freq[i], freq[i] += 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int ans = 0, freq[101] = {0};\\n        for(auto i : nums) ans += freq[i], freq[i] += 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460814,
                "title": "java-o-n-log-n-hashmap-used-for-beginners-explained",
                "content": "# Approach\\n- Create a hashmap\\n- O(n log n) nested loop setup for finding out pairs\\n- If a key == nums[i] does not exist upon finding a pair, push a pair (nums[i] , 1)\\n- If key exist, increment the value corresponding to the key in the hashmap.\\n- for all the key values in the map, return the sum of all the values  \\n\\n# Complexity\\n- Time complexity: O(n log n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    if(map.containsKey(nums[i]) == true){\\n                        int value = map.get(nums[i]);\\n                        value++;\\n                        map.put(nums[i],value);\\n                    }else{\\n                        map.put(nums[i],1);\\n                    }\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int val: map.keySet()){\\n            sum += map.get(val);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/50a24157-7d7e-43a9-8524-2a6d895ec72e_1682603816.5533574.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    if(map.containsKey(nums[i]) == true){\\n                        int value = map.get(nums[i]);\\n                        value++;\\n                        map.put(nums[i],value);\\n                    }else{\\n                        map.put(nums[i],1);\\n                    }\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int val: map.keySet()){\\n            sum += map.get(val);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379741,
                "title": "find-the-number-of-identical-pairs-in-an-array-of-integers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the number of identical pairs in an array of integers. We can keep track of the frequency of each integer using a hash map, where the keys are the integers and the values are the frequency of occurrence. Then, for each key in the map, we can calculate the number of pairs that can be formed using the formula n * (n-1) / 2, where n is the frequency of the integer. We can then sum up the number of pairs for each integer to get the total number of identical pairs in the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to first create a hash map, where we iterate through the input array and keep track of the frequency of each integer. Then, we iterate through the keys in the map and calculate the number of identical pairs that can be formed using the formula mentioned above. Finally, we sum up the number of pairs for each integer to get the total number of identical pairs in the array.\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the length of the input array. This is because we iterate through the array once to create the hash map, and then iterate through the keys in the map, which has a maximum length of the number of unique integers in the array. The space complexity is also O(n), since we are using a hash map to store the frequency of each integer in the array.\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function (nums) {\\n  let m = {};\\n\\n  nums.forEach((element) => {\\n    if (m[element] == undefined) m[element] = 1;\\n    else m[element]++;\\n  });\\n\\n  let res = 0;\\n\\n  for (const key in m) {\\n    if (Object.hasOwnProperty.call(m, key)) {\\n      const element = m[key];\\n      if (element > 1) res += element * (element / 2 - 0.5);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function (nums) {\\n  let m = {};\\n\\n  nums.forEach((element) => {\\n    if (m[element] == undefined) m[element] = 1;\\n    else m[element]++;\\n  });\\n\\n  let res = 0;\\n\\n  for (const key in m) {\\n    if (Object.hasOwnProperty.call(m, key)) {\\n      const element = m[key];\\n      if (element > 1) res += element * (element / 2 - 0.5);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977892,
                "title": "beats-100-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int count=0;\\n\\n    for(int i=0;i<nums.length;i++){\\n\\n    if(!mp.containsKey(nums[i])){\\n        mp.put(nums[i],1);\\n    }\\n    else{\\n        count+=mp.get(nums[i]);\\n        mp.put(nums[i],mp.get(nums[i])+1);\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int count=0;\\n\\n    for(int i=0;i<nums.length;i++){\\n\\n    if(!mp.containsKey(nums[i])){\\n        mp.put(nums[i],1);\\n    }\\n    else{\\n        count+=mp.get(nums[i]);\\n        mp.put(nums[i],mp.get(nums[i])+1);\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968656,
                "title": "using-basic-combination-with-bucket-array",
                "content": "# Intuition\\n(Read the note below)\\nSince we have to count the number of pairs using `nCr` which is `n!/(n-r)! * r!`\\nTaking `r = 2`, since we are to count the number of pairs\\n\\n`nC2 = n!/(n-2)! * (2)!`\\n\\n# Approach\\nNow next step was to minimize the value of `nC2` else taking the worst case scenario 100 (max value of nums[i]) it\\'ll lead to overflow since 100! is a very big number. \\n\\nTherefore `nC2 = n! / (n-2)! * 2!`\\n`nC2 = n(n-1)(n-2)! / (n-2)! * 2!`\\n`nC2 = n(n-1) / 2`  _cancelling (n-2)! out_\\n\\n# Complexity\\n- Time complexity: __O(2n)__\\n\\n- Space complexity: __O(101)__\\n\\n# Note\\nbuc_arr[] is used to store the frequency of each element present in the nums vector.\\n\\nThe size is taken as 101 as the maximum value of nums[i] is 100 \\nTherefore that means `buc_arr[nums[i]]` cannot exceed a value of `buc_arr[100]` therefore size taken as `101` i.e. to accomodate all values from 0 to 100 \\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // nC2 = n! / (n-2)! x 2!\\n        // nC2 = n(n-1)(n-2)! / (n-2)! x 2!\\n        // nC2 = n(n-1) / 2\\n\\n        vector<int> buc_arr(101);\\n        for(int x: nums)\\n            buc_arr[x]++;\\n        \\n        int sum = 0;\\n        for(int x: buc_arr) {\\n            sum += x*(x-1)/2;\\n        }\\n\\n        return sum;\\n\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // nC2 = n! / (n-2)! x 2!\\n        // nC2 = n(n-1)(n-2)! / (n-2)! x 2!\\n        // nC2 = n(n-1) / 2\\n\\n        vector<int> buc_arr(101);\\n        for(int x: nums)\\n            buc_arr[x]++;\\n        \\n        int sum = 0;\\n        for(int x: buc_arr) {\\n            sum += x*(x-1)/2;\\n        }\\n\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771165,
                "title": "c-map-math-o-n",
                "content": "***Explanation***\\ncount the occurrence of the same elements.\\nFor each new element a,\\nthere will be more count[a] pairs.\\nwith *A[i] == A[j]* and *i < j*\\n\\n***Explaining the logic:***\\n1) We can store the ints like a key in map, and the indexes save in the vector of ints like a  value in a map. \\nFor example 1, it will be like that:\\n[![image](https://assets.leetcode.com/users/images/72269524-2e0d-4d35-9887-e52b219a6485_1667408712.184323.png)\\n](http://)[](http://)\\n2) It is a fact that, to find the sum of numbers from 1 to n, the formula will be:\\n![image](https://assets.leetcode.com/users/images/8e4d0c3b-e70a-48e1-9377-3f314e0135e2_1667408825.1531677.png)\\n**((n)*(n+1))/2**\\n3) Then we can iterate trough the map and take the size of vectors and apply that formula to the sizes of vectors in map:\\n ``\\n int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n ``\\n 4) and make `ans+=sum`\\n\\n***C++ code with comments:***\\n```\\n int numIdenticalPairs(vector<int>& nums) {\\n        map<int,vector<int>> mp; // creating a map with key - int, and value - vector\\n        for(int i = 0 ; i < nums.size();i++){\\n            // For example: key is 1, and we saving the indexes of this number. Example 1:\\n            // [1]:0,3,4\\n            // [2]:1\\n            // and etc...\\n            mp[nums[i]].push_back(i); \\n        }\\n        //declaring the variable to save the numbers of good pairs\\n        int ans = 0;\\n        \\n        for(auto i : mp){\\n            //using the formula to find the sum of numbers\\n            // ((n)*(n+1))/2\\n            // n - the size of the vector\\n            int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n            // saving it to the ans\\n            ans+=sum;\\n        }\\n        //returning ans\\n        return ans;\\n    }\\n```\\n***C++ code without comments:***\\n```\\nint numIdenticalPairs(vector<int> &nums)\\n{\\n    map<int, vector<int>> mp;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        mp[nums[i]].push_back(i);\\n    }\\n    int ans = 0;\\n    for (auto i : mp)\\n    {\\n        int sum = ((i.second.size() - 1) * (i.second.size())) / 2;\\n\\n        ans += sum;\\n    }\\n    return ans;\\n}\\n```\\n\\n***Complexity***\\nTime O(N)\\nSpace O(N)\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n int numIdenticalPairs(vector<int>& nums) {\\n        map<int,vector<int>> mp; // creating a map with key - int, and value - vector\\n        for(int i = 0 ; i < nums.size();i++){\\n            // For example: key is 1, and we saving the indexes of this number. Example 1:\\n            // [1]:0,3,4\\n            // [2]:1\\n            // and etc...\\n            mp[nums[i]].push_back(i); \\n        }\\n        //declaring the variable to save the numbers of good pairs\\n        int ans = 0;\\n        \\n        for(auto i : mp){\\n            //using the formula to find the sum of numbers\\n            // ((n)*(n+1))/2\\n            // n - the size of the vector\\n            int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n            // saving it to the ans\\n            ans+=sum;\\n        }\\n        //returning ans\\n        return ans;\\n    }\\n```\n```\\nint numIdenticalPairs(vector<int> &nums)\\n{\\n    map<int, vector<int>> mp;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        mp[nums[i]].push_back(i);\\n    }\\n    int ans = 0;\\n    for (auto i : mp)\\n    {\\n        int sum = ((i.second.size() - 1) * (i.second.size())) / 2;\\n\\n        ans += sum;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671622,
                "title": "c-explained-easy-using-permutation",
                "content": "```\\nThe approach is very simple. Count number of duplicates for each element in a given array and calculate nC2 which is used to select two elements at a time.\\n\\nNote: nC2=n*(n-1)/2\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++) m[nums[i]]++;\\n        int c=0;\\n        for(auto i:m)\\n        {\\n            int n=i.second;\\n            c+=n*(n-1)/2;\\n        }\\n        return c;\\n    }\\n};\\n```\\n```\\nFeel free to comment if any doubt...\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nThe approach is very simple. Count number of duplicates for each element in a given array and calculate nC2 which is used to select two elements at a time.\\n\\nNote: nC2=n*(n-1)/2\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++) m[nums[i]]++;\\n        int c=0;\\n        for(auto i:m)\\n        {\\n            int n=i.second;\\n            c+=n*(n-1)/2;\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nFeel free to comment if any doubt...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514502,
                "title": "java-solution-using-hashmap",
                "content": "Time Complexity : O(N)\\n\\n```\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i])+1);\\n            }\\n            else{\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2449707,
                "title": "c-o-n-best-explanation-easy-understanding",
                "content": "### ***Use new version of leetcode to see latex expressions properly***\\n***\\n```\\n// Time Complexity = O(n)\\n// Space Complexity = O(n)\\n// Runtime : 0ms, faster than 100.00%\\n// Memory Usage : 7.2 MB, less than 60.74%\\n```\\n\\n```\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        unordered_map<int,int> hashmap;\\n        int goodPairs = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n            hashtable[nums[i]] += 1;\\n        \\n        for(auto element : hashtable)\\n            goodPairs += element.second * (element.second - 1) / 2;\\n        \\n        return goodPairs;\\n    }\\n```\\n\\nFirst, we find the count of numbers in the array with **hashmap**.\\n\\nLet our array be [1,2,3,1,1,3,1,1,3]\\nWe can specify good pairs as the count of same numbers after them.\\nThere are 5 1s in an array, where the positions of the numbers don\\'t matter to us because all we\\'re looking at are the numbers that come after them that are the same as themselves. Returning to our example, after the first 1 will come 4 more 1s. The second future is 3 after 1, the third future is 2 after 1, and so on until 1.\\n\\nNow let **a** be the count of 1 in the array. After the first 1 will come a-1 more 1s. The second future is a-2 after 1, the third future is a-3 after 1, and so on until 1.\\n\\nNow let\\'s change our arr a little bit and let our new array be [1,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]\\nLet **a** be the count of 1s here too\\n\\n\\n\\n| Arr | Count of 1s after ***bold-italic*** value (**a** is count of all 1s) |\\n|:-:| :-:|\\n| [***1***,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-1 |\\n| [1,2,3,***1***,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-2 |\\n| [1,2,3,1,***1***,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-3 |\\n| ... | |\\n| [1,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , ***1***,1]| 1 |\\n\\n****\\nIf check the second column you can see numbers goes to 1 from a-1 so we can specify as\\nTotal number of good pairs = $$[(a-1) + (a-2)+(a-3)+...+1]$$\\n\\n\\nIf we use consecutive numbers formula on *Total number of good pairs*\\n\\n$$\\\\Large\\\\frac {n(firstNumber + lastNumber)}{2}$$  $$\\\\leftarrow$$ this is the **consecutive formula**\\n\\nin our problem,\\n*n* = **a-1**, because when size **a** we start from **a-1** \\nfor example 1s count are 5, its sum of good pairs 4+3+2+1. That\\u2019s why size is 5-1 = 4, so **a-1**.\\n\\n*first number* = **a - 1**,\\n*last number* = **1**,\\n\\nIf we substitute the variables\\n$$\\\\Large\\\\frac {(a-1) * (a-1 + 1)}{2} = \\\\Large\\\\frac{(a-1) * a}{2}$$\\n\\nWith $\\\\large\\\\frac{(a-1) * a}{2}$, we calculate the number of good pairs for each different number and return the sum.\\n\\n**If we use the counts of the numbers we keep in the hashmap in this formula and sum the results, we will find the good pairs in the array.**\\n\\n\\n```\\nbool shouldYouUpvote() { return (I helped == true) ? upvote : nothing; }\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\n// Time Complexity = O(n)\\n// Space Complexity = O(n)\\n// Runtime : 0ms, faster than 100.00%\\n// Memory Usage : 7.2 MB, less than 60.74%\\n```\n```\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        unordered_map<int,int> hashmap;\\n        int goodPairs = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n            hashtable[nums[i]] += 1;\\n        \\n        for(auto element : hashtable)\\n            goodPairs += element.second * (element.second - 1) / 2;\\n        \\n        return goodPairs;\\n    }\\n```\n```\\nbool shouldYouUpvote() { return (I helped == true) ? upvote : nothing; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2094229,
                "title": "python-oneliner-solution",
                "content": "Here is my python one-liner:\\n\\n```python\\n        return sum(c * (c - 1) // 2 for c in Counter(nums).values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        return sum(c * (c - 1) // 2 for c in Counter(nums).values())\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151026,
                "title": "good-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> smap;\\n        int count =0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            count+=smap[nums[i]];\\n            smap[nums[i]]++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> smap;\\n        int count =0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            count+=smap[nums[i]];\\n            smap[nums[i]]++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987128,
                "title": "java-easiest-100-faster",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\tint answer = 0;\\n\\tint[] freq = new int[102];\\n        \\n\\tfor (int i : nums) {\\n\\t\\tif (freq[i] == 0) freq[i]++;\\n\\t\\telse{\\n\\t\\t\\tanswer += freq[i];\\n\\t\\t\\tfreq[i]++;\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\tint answer = 0;\\n\\tint[] freq = new int[102];\\n        \\n\\tfor (int i : nums) {\\n\\t\\tif (freq[i] == 0) freq[i]++;\\n\\t\\telse{\\n\\t\\t\\tanswer += freq[i];\\n\\t\\t\\tfreq[i]++;\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981334,
                "title": "java-0-ms-runtime-beats-100",
                "content": "**Method 1**: T: O(n\\xB2), S: O(1)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\tfor (int j = i + 1; j < nums.length; j++)\\n\\t\\t\\tif (nums[i] == nums[j])\\n\\t\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\\n\\n**Method 2**: T: O(n), S: O(n)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tInteger frequency = frequencyByNum.get(num);\\n\\t\\tif (frequency == null) {\\n\\t\\t\\tfrequencyByNum.put(num, 1);\\n\\t\\t} else {\\n\\t\\t\\tcount += frequency;\\n\\t\\t\\tfrequencyByNum.put(num, frequency + 1);\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\n**Method 2 but simpler**: T: O(n), S: O(n)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tif (frequencyByNum.containsKey(num))\\n\\t\\t\\tcount += frequencyByNum.get(num);\\n\\t\\tfrequencyByNum.compute(num, (k, v) -> v == null ? 1 : v + 1);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\tfor (int j = i + 1; j < nums.length; j++)\\n\\t\\t\\tif (nums[i] == nums[j])\\n\\t\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tInteger frequency = frequencyByNum.get(num);\\n\\t\\tif (frequency == null) {\\n\\t\\t\\tfrequencyByNum.put(num, 1);\\n\\t\\t} else {\\n\\t\\t\\tcount += frequency;\\n\\t\\t\\tfrequencyByNum.put(num, frequency + 1);\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tif (frequencyByNum.containsKey(num))\\n\\t\\t\\tcount += frequencyByNum.get(num);\\n\\t\\tfrequencyByNum.compute(num, (k, v) -> v == null ? 1 : v + 1);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745974,
                "title": "simplest-solution-with-python-3",
                "content": "```\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        set_nums=set(nums)\\n        good=0\\n        for x in set_nums:\\n            n=nums.count(x)\\n            good+=(n*(n-1))/2 \\n\\t\\t\\t#finding number of occurences of element and using nC2 to find good pairs \\n        return int(good)\\n```",
                "solutionTags": [],
                "code": "```\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        set_nums=set(nums)\\n        good=0\\n        for x in set_nums:\\n            n=nums.count(x)\\n            good+=(n*(n-1))/2 \\n\\t\\t\\t#finding number of occurences of element and using nC2 to find good pairs \\n        return int(good)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 732229,
                "title": "python-faster-than-100-of-submission",
                "content": "```\\n        freq={}\\n        output=0\\n        for num in nums:\\n            if not num in freq:\\n                freq[num]=0\\n            freq[num]+=1\\n        \\n        for num in freq:\\n            n=freq[num]\\n            output+=(n*(n-1)//2)\\n            \\n        return output\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n        freq={}\\n        output=0\\n        for num in nums:\\n            if not num in freq:\\n                freq[num]=0\\n            freq[num]+=1\\n        \\n        for num in freq:\\n            n=freq[num]\\n            output+=(n*(n-1)//2)\\n            \\n        return output\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784488,
                "title": "easiest-c-solution-o-n-time-complexity-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        for(auto num : nums){\\n            ans += m[num];\\n            m[num]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        for(auto num : nums){\\n            ans += m[num];\\n            m[num]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090562,
                "title": "easy-to-understand-c-code-rt-0-ms-memory-7-2-mb",
                "content": "\\n\\n# Complexity\\n- Runtime: 0 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Memory: 7.2 Mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }return c;\\n    }\\n};\\n```\\nIf you like the code approach, make sure to upvote \\u270C\\uFE0F. \\nGooD Day",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055896,
                "title": "easy-python-solution-more-than-80-beats",
                "content": "simply use nested for loop.\\n```\\nfor i in range(0,len(nums)):\\n    for j in range(i+1,len(nums)):\\n```\\nThe outer loop will run from index 0 upto 2nd last index, because in the inner loop we are comparing the items with rest of the list.\\n\\nThe outer loop starts from i+1 and stop as 2nd last index.\\nThat way we can compare every element with rest of the list, if num[i] equals to num[j] then count it.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfor i in range(0,len(nums)):\\n    for j in range(i+1,len(nums)):\\n```\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902383,
                "title": "single-loop-o-n-speed-hash-table-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe good pair quantites are same as how many identical number already accululated each time when you encounter the same number. For example, if number 1 appears 4 times already, then the next time you encounter number 1, that will contribute 4 quantites to the good pair. So we only need to record how many times the number appears and save it in a bucket for that number. That is the hash table. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nTaking advantage of only 100 distinct possible numbers, our hash function can directly map the key to the index of hashmap array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nSince we only for loop once, it is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nWe need full size hashmap, O(n) space complexity\\n\\n# Code\\n```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int hashmap[101] = {0};\\n    for(int i = 0; i < numsSize; i++){\\n        hashmap[0]+= hashmap[nums[i]]++;\\n    }\\n    return hashmap[0];\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int hashmap[101] = {0};\\n    for(int i = 0; i < numsSize; i++){\\n        hashmap[0]+= hashmap[nums[i]]++;\\n    }\\n    return hashmap[0];\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2432446,
                "title": "java-using-hashmaps",
                "content": "```class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap <Integer, Integer> map = new HashMap<>();\\n        HashMap <Integer, Integer> goodPairs = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int curr = nums[i];\\n            if(!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            } else {\\n                int occurences = map.get(curr);\\n                occurences = occurences + 1;\\n                map.replace(curr, occurences);\\n                if(!goodPairs.containsKey(curr)) {\\n                    goodPairs.put(curr, 1);\\n                } else {\\n                    int goodP = goodPairs.get(curr);\\n                    int pairs = occurences + (goodP -1);\\n                    goodPairs.replace(curr, pairs);\\n                }\\n                \\n            }\\n        }\\n        \\n        Set <Integer> set = new HashSet<>();\\n        set = goodPairs.keySet();\\n        int sum = 0;\\n        \\n        for(int i: set) {\\n            int value = goodPairs.get(i);\\n            sum = sum + value;\\n        }\\n        \\n        return sum;\\n        \\n        \\n        \\n    }\\n}\\n\\n\\n    //math examples\\n//     when occurences = 2 \\n//    + (goodpair-1)\\n//     good pair = 1\\n    \\n//     occurence = 3\\n//     + (goodpair-1)\\n//     good pair = 3\\n    \\n//     occurence = 4\\n//     + (goodpair - 1)\\n//     good pairs = 6\\n    \\n//     occurence = 5\\n//     + (goodpair-1)\\n    \\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap <Integer, Integer> map = new HashMap<>();\\n        HashMap <Integer, Integer> goodPairs = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int curr = nums[i];\\n            if(!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1976561,
                "title": "python-3-99-fast-3-solutions-each-better-than-the-other",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe can use that brute force which can get us the solution in O(n^2) time.\\nBut that would be a naive solution. \\nEvery following solution is built upon previous solution and give us 99% best result after submission when you submit solution 3.\\n\\n**Solution 1:**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)\\n            \\n        for indexes in mapping.values():\\n            for i in range(len(indexes)-1):\\n                for j in range(i+1, len(indexes)):\\n                    count += 1\\n                    \\n        return count\\n```\\n        \\n**Solution 2**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)                \\n            \\n        for indexes in mapping.values():\\n            size = len(indexes)\\n            count += (size * (size-1))//2\\n            \\n        return count\\n```\\n\\n**Solution 3**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.Counter(nums)\\n        count = 0\\n                \\n        for value in mapping.values():\\n            count += (value * (value-1))//2\\n            \\n        return count\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)\\n            \\n        for indexes in mapping.values():\\n            for i in range(len(indexes)-1):\\n                for j in range(i+1, len(indexes)):\\n                    count += 1\\n                    \\n        return count\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)                \\n            \\n        for indexes in mapping.values():\\n            size = len(indexes)\\n            count += (size * (size-1))//2\\n            \\n        return count\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.Counter(nums)\\n        count = 0\\n                \\n        for value in mapping.values():\\n            count += (value * (value-1))//2\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554480,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0;index<nums.size();index++)\\n        {\\n            for(int jindex=index+1;jindex<nums.size();jindex++)\\n            {\\n                if(nums[index]==nums[jindex])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0;index<nums.size();index++)\\n        {\\n            for(int jindex=index+1;jindex<nums.size();jindex++)\\n            {\\n                if(nums[index]==nums[jindex])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520782,
                "title": "java-simple-o-n-time-complexity-easy-to-understand",
                "content": "\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>(); // to count number of occurences of number\\n        int ans = 0; // result\\n        \\n        for (int i : nums) {\\n            int count = map.getOrDefault(i, 0); // if number doesn\\'t exist in array then simply return 0, else return number of time it occurred\\n\\t\\t\\t/**\\n\\t\\t\\tE.g we have nums = [1,2,3,1,1,3]\\n\\t\\t\\ttill [1,2,3] we have 0 ans, map->[{1,1}, {2,1}, {3,1}]\\n\\t\\t\\t1. now  we have first duplicate number come i.e. 1\\n\\t\\t\\tans updated to 1 and map updated to 2\\n\\t\\t\\tmap->[{1,2}, {2,1}, {3,1}], ans->1\\n\\t\\t\\t2. and now again 1 (index 4)\\n\\t\\t\\tans updated to 3 and map updated to 3\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,1}], ans->3\\n\\t\\t\\t3. now come 3 which is second occurence for number 3\\n\\t\\t\\tans updated to 4 (because for key 3 we have value 1 in map)\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,2}], ans->4\\n\\t\\t\\t4. And answer is 4 {as all indexes travelled}\\n\\t\\t\\n\\t\\t\\t*/\\n            ans += count; // add it to result\\n            map.put(i, count + 1);//update the frequency/count of number in map\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numIdenticalPairs(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>(); // to count number of occurences of number\\n        int ans = 0; // result\\n        \\n        for (int i : nums) {\\n            int count = map.getOrDefault(i, 0); // if number doesn\\'t exist in array then simply return 0, else return number of time it occurred\\n\\t\\t\\t/**\\n\\t\\t\\tE.g we have nums = [1,2,3,1,1,3]\\n\\t\\t\\ttill [1,2,3] we have 0 ans, map->[{1,1}, {2,1}, {3,1}]\\n\\t\\t\\t1. now  we have first duplicate number come i.e. 1\\n\\t\\t\\tans updated to 1 and map updated to 2\\n\\t\\t\\tmap->[{1,2}, {2,1}, {3,1}], ans->1\\n\\t\\t\\t2. and now again 1 (index 4)\\n\\t\\t\\tans updated to 3 and map updated to 3\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,1}], ans->3\\n\\t\\t\\t3. now come 3 which is second occurence for number 3\\n\\t\\t\\tans updated to 4 (because for key 3 we have value 1 in map)\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,2}], ans->4\\n\\t\\t\\t4. And answer is 4 {as all indexes travelled}\\n\\t\\t\\n\\t\\t\\t*/\\n            ans += count; // add it to result\\n            map.put(i, count + 1);//update the frequency/count of number in map\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404812,
                "title": "java-fasted-method-100-working-o-n",
                "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int n = nums.length;\\n            \\n        int goodPairs=0;\\n      \\n        int[] map = new int[101];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            map[nums[i]]++;\\n        }\\n        \\n     \\n        for(int i=0;i<=100;i++){\\n            if(map[i] > 1){\\n                goodPairs += (map[i] * (map[i]-1)) / 2; \\n            }\\n        }\\n        return goodPairs;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int n = nums.length;\\n            \\n        int goodPairs=0;\\n      \\n        int[] map = new int[101];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            map[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1353137,
                "title": "c-hashmap-solution-0-n",
                "content": "\\'\\'\\'\\n  class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\nunordered_map<int,int>dp;\\n        \\n        \\n        int good_pairs,x;good_pairs=0;x=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n             dp[nums[i]]++;  //storing the count of each num;  \\n        }\\n        \\n        for(auto i=dp.begin();i!=dp.end();i++)    \\n      {\\n          if(i->second>1)\\n          {\\n        x=(i->second*(i->second-1))>>1;\\n              good_pairs=good_pairs+x;\\n              \\n          }\\n      }\\n        return good_pairs;\\n    \\n                                       \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\nunordered_map<int,int>dp;\\n        \\n        \\n        int good_pairs,x;good_pairs=0;x=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n             dp[nums[i]]++;  //storing the count of each num;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1281128,
                "title": "c-simple-you-ll-love-it-guaranteed",
                "content": "If you have Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\nstoring values to set to avoid repeatation.\\n\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tset<int>set1; int pairs = 0;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tif(set1.find(nums[i]) == set1.end()){\\n\\t\\t\\tint cnt = count(begin(nums), end(nums), nums[i]);\\n\\t\\t\\tpairs += cnt * (cnt-1)/2;\\n\\t\\t\\tset1.insert(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn pairs;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tset<int>set1; int pairs = 0;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tif(set1.find(nums[i]) == set1.end()){\\n\\t\\t\\tint cnt = count(begin(nums), end(nums), nums[i]);\\n\\t\\t\\tpairs += cnt * (cnt-1)/2;\\n\\t\\t\\tset1.insert(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn pairs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1209470,
                "title": "java-100-solution-with-hashmap",
                "content": "\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put( nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        \\n        int sum=0;\\n        \\n        for(Integer i: map.keySet())\\n        {\\n            int count=map.get(i);\\n            if(count>1)\\n                sum=sum+(count*(count-1))/2;    //for n items, n*(n-1)/2 pairs exist\\n        }\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put( nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 933762,
                "title": "o-n-javascript-solution",
                "content": "```\\nconst numIdenticalPairs = (nums) => {\\n    \\n    let map = {};\\n    let counter = 0;\\n    \\n    for(val of nums) {\\n        !map[val] ? map[val] = 1 : counter += map[val]++ \\n    }\\n    \\n    return counter;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numIdenticalPairs = (nums) => {\\n    \\n    let map = {};\\n    let counter = 0;\\n    \\n    for(val of nums) {\\n        !map[val] ? map[val] = 1 : counter += map[val]++ \\n    }\\n    \\n    return counter;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910704,
                "title": "simple-java-solution-with-explaination-0ms-o-n-time-constant-space-100-faster-single-loop",
                "content": "1.take output array of size 101 (since this is the max possible numbers) and count variable to store the total number of pairs.\\n2.start counting frequency of each element. before incrementing frequency just add the current frequency to the count. (why? because we need to add pair i.e. one less than the frequency).\\n3. once loop finishes count will hold the answer.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[]  op = new int[101];\\n        int c=0;\\n        for(int i:nums) {\\n            c+=op[i]++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[]  op = new int[101];\\n        int c=0;\\n        for(int i:nums) {\\n            c+=op[i]++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819035,
                "title": "python-3-98-52-faster-3-techniques-but-only-1-optimal-solution",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nThere are 3 ways of doing this:\\n1. Use 2 for loops. For every ith element, compare with the remaining i+1 to n elements. If match is found, increase the count. This is T=O(n2) and S=O(1)\\n\\n2. Sort the list before processing it. This way all the matching numbers will be near each other. Now searching for the pair can be done using binary search. Assuming sorting is O(n log n) and binary search for every ith element is also O(n log n), overall T = O(n log n) and S = O(1)\\n\\n3. Using dictionary. Record every elements that we encounter. If the element already exists, then increment it\\'s count. We sum the elements that match and return the result. Here T=O(n) at the expense of space, S=O(n)\\n\\n**Implementation of solution 3:**\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tmapping = collections.defaultdict(int)\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += mapping[nums[i]]\\n\\t\\tmapping[nums[i]] += 1\\n\\treturn total\\n```\\n\\n**If this solution helped, please upvote it for others to take advantage of it and learn their techniques**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tmapping = collections.defaultdict(int)\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += mapping[nums[i]]\\n\\t\\tmapping[nums[i]] += 1\\n\\treturn total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 803606,
                "title": "a-simple-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int , int> m; int sum=0;\\n        for(auto i : nums) m[i]++;\\n        for(auto i : m) {\\n        int num = i.second; \\n        if(num>1) sum += (num*(num-1))/2;  \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int , int> m; int sum=0;\\n        for(auto i : nums) m[i]++;\\n        for(auto i : m) {\\n        int num = i.second; \\n        if(num>1) sum += (num*(num-1))/2;  \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787607,
                "title": "python-sol-by-iteration",
                "content": "Python sol by iteration\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        good_pair_count = 0\\n        \\n        for i in range(size - 1):\\n            \\n            for j in range(i+1, size):\\n                \\n                if nums[i] == nums[j]:\\n                    good_pair_count += 1\\n                    \\n        \\n        return good_pair_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        good_pair_count = 0\\n        \\n        for i in range(size - 1):\\n            \\n            for j in range(i+1, size):\\n                \\n                if nums[i] == nums[j]:\\n                    good_pair_count += 1\\n                    \\n        \\n        return good_pair_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783552,
                "title": "three-java-solutions-including-optimal-0ms-and-100-faster",
                "content": "**Approach 1.** \\nNaive brute force solution. O(N^2) time and O(1) space. Max(N) == 100;\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int  ret = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++){\\n                if (nums[i]==nums[j]) ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n\\n``` \\n**APPROACH 2**. \\nCombinatorics. O(N) time (max(N) == 100) and O(N) space complexity. \\nThis approach is based on the number ways to sample r elements (== 2 in our case) from n elements.\\n**C = n!/(r! * (n-r)!)**\\n\\nTime complexity : O(N) space, space is O(1) since the number n is limited to 100;\\nFactorial calculation is DP based. And we need to use BigInteger to avoid overflows\\n\\n```\\nstatic HashMap<Integer, BigInteger> facts = new HashMap<>();\\n\\n    static {\\n        facts.put(1, BigInteger.ONE);\\n        facts.put(0, BigInteger.ONE);\\n        for (int i = 2; i <= 100; i++) {\\n            fact(i);\\n        }\\n    }\\n        \\n     public static int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n\\n        for (int key : counts.values()) {\\n            int numOfComb = key == 1 ? 0 : calcNumbOfComb(key);\\n            if (numOfComb > 0) ret += numOfComb;\\n        }\\n\\n        return ret;\\n    }\\n\\n    private static int calcNumbOfComb(int i) {\\n\\n        BigInteger nF = fact(i);\\n        BigInteger nrFact = fact(i - 2);\\n        return (nF.divide(BigInteger.TWO.multiply(nrFact))).intValue();\\n    }\\n\\n    private static BigInteger fact(int i) {\\n        if (facts.get(i) == null) {\\n            if (facts.get(i - 1) == null)\\n                facts.put(i - 1, fact(i - 2).multiply(BigInteger.valueOf(i - 1)));\\n            facts.put(i, BigInteger.valueOf(i).multiply(facts.get(i - 1)));\\n        }\\n\\n        return facts.get(i);\\n    }\\n```\\n**APPROACH 2 Optimized**. \\nWe can simplify by canceling (n - 2)! in **C = n!/(r! * (n-r)!)**.\\n**C = n!/(r! * (n-r)!) = n * (n-1) * (n-2)!/(2! * (n-2)!) = n * (n-1)/2**. This means that it is not necessary to caculate factorials which simplifies the solution. \\n\\nHere is an example of experimental way to get the same formula\\n\\n\\t// Sample input: [1,1,1,1]. Start looking from the end of the array.\\n    // Number of ones: 1 -> 0 (+0) possible pairs -> 1 * 0/2\\n    // Number of ones: 2 -> 1 (+1) possible pair -> 2 * 1/2\\n    // Number of ones: 3 -> 3 (+2) possible pairs -> 3 * 2/2\\n    // Number of ones: 4 -> 6 (+3) possible pairs -> 4 * 3/2\\n    // Number of ones: 5 -> 10 (+4) possible pairs -> 5 * 4/2\\n\\t// Number of ones: n ->  x (+ n-1) possible pair -> x = n * (n - 1)/2\\n\\n**Here is the final solution**\\n```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    \\npublic static int numIdenticalPairs(int[] nums) {\\n        // Count frequncies \\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n        \\n        // Maximum 100 iterations\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n        \\n        // Maximum 100 iterations\\n        for (int key : counts.values()) {\\n            ret += key * (key - 1)/2;\\n        }\\n\\n        return ret;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int  ret = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++){\\n                if (nums[i]==nums[j]) ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n\\n```\n```\\nstatic HashMap<Integer, BigInteger> facts = new HashMap<>();\\n\\n    static {\\n        facts.put(1, BigInteger.ONE);\\n        facts.put(0, BigInteger.ONE);\\n        for (int i = 2; i <= 100; i++) {\\n            fact(i);\\n        }\\n    }\\n        \\n     public static int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n\\n        for (int key : counts.values()) {\\n            int numOfComb = key == 1 ? 0 : calcNumbOfComb(key);\\n            if (numOfComb > 0) ret += numOfComb;\\n        }\\n\\n        return ret;\\n    }\\n\\n    private static int calcNumbOfComb(int i) {\\n\\n        BigInteger nF = fact(i);\\n        BigInteger nrFact = fact(i - 2);\\n        return (nF.divide(BigInteger.TWO.multiply(nrFact))).intValue();\\n    }\\n\\n    private static BigInteger fact(int i) {\\n        if (facts.get(i) == null) {\\n            if (facts.get(i - 1) == null)\\n                facts.put(i - 1, fact(i - 2).multiply(BigInteger.valueOf(i - 1)));\\n            facts.put(i, BigInteger.valueOf(i).multiply(facts.get(i - 1)));\\n        }\\n\\n        return facts.get(i);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749449,
                "title": "c-dictionary-o-n-solution",
                "content": "**Solution:** \\n\\nUpdated solution with Kiebus\\'s advice.\\n\\nThe idea is count the occurrence of the same elements. nums[i] will contribute dic[nums[i]] pairs to the result. Time complexity and space complexity are both O(n).\\n\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], 1);\\n            else\\n            {               \\n                cnt += dic[nums[i]];\\n                dic[nums[i]]++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\\n\\n\\noriginal implmentation\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], new List<int>(){nums[i]});\\n            else\\n            {\\n                cnt += dic[nums[i]].Count;\\n                dic[nums[i]].Add(i);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], 1);\\n            else\\n            {               \\n                cnt += dic[nums[i]];\\n                dic[nums[i]]++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], new List<int>(){nums[i]});\\n            else\\n            {\\n                cnt += dic[nums[i]].Count;\\n                dic[nums[i]].Add(i);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736026,
                "title": "c",
                "content": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int s = 0, a[101] = { 0 };\\n    for (int i = 0; i < numsSize; i++) s += a[nums[i]]++;\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int s = 0, a[101] = { 0 };\\n    for (int i = 0; i < numsSize; i++) s += a[nums[i]]++;\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734440,
                "title": "c-solution-hashmap-using-map-o-n-simplest-solution-easy-to-understand",
                "content": "This question uses basic math.\\nAlthough shown in HINT the formula is n(n-1)/2, where n is number of time any number occur.\\nWe don\\'t care about the number but only the number of time any number.\\nAlthough every solution shows in 0ms.\\nBut the solution easy to understand is here.\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            auto  itr=mp.find(nums[i]);\\n            if(itr==mp.end())\\n                mp.insert(make_pair(nums[i],1));\\n            else\\n                itr->second++;\\n        }\\n        int sum=0;\\n        for(auto it=mp.begin();it!=mp.end();++it){\\n            int z=it->second;\\n            sum+=z*(z-1)/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            auto  itr=mp.find(nums[i]);\\n            if(itr==mp.end())\\n                mp.insert(make_pair(nums[i],1));\\n            else\\n                itr->second++;\\n        }\\n        int sum=0;\\n        for(auto it=mp.begin();it!=mp.end();++it){\\n            int z=it->second;\\n            sum+=z*(z-1)/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732615,
                "title": "python-3-solution-with-defaultdict",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums) -> int:\\n        \"\"\"\\n        Given an array of numbers, this program determines the\\n        number of good pairs [nums[j], nums[k]]. In a good pair,\\n        j < k and nums[j] = nums[k].\\n        \\n        If there are 2 or more ocurrences of a value within nums, then\\n        there is at least 1 good pair for that value. If there are n\\n        occurrences of a value, the number of good pairs is:\\n        \\n                            n!\\n                      ----------------  or  n * (n - 1) / 2\\n                        (n - 2)! * 2!\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :return: number of good pairs\\n        :rtype: int\\n        \"\"\"\\n        counts = defaultdict(int)\\n        for num in nums:\\n            counts[num] += 1\\n        good_pairs = 0\\n        for count in counts.values():\\n            if count > 1:\\n                good_pairs += count * (count - 1) // 2\\n        return good_pairs\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums) -> int:\\n        \"\"\"\\n        Given an array of numbers, this program determines the\\n        number of good pairs [nums[j], nums[k]]. In a good pair,\\n        j < k and nums[j] = nums[k].\\n        \\n        If there are 2 or more ocurrences of a value within nums, then\\n        there is at least 1 good pair for that value. If there are n\\n        occurrences of a value, the number of good pairs is:\\n        \\n                            n!\\n                      ----------------  or  n * (n - 1) / 2\\n                        (n - 2)! * 2!\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :return: number of good pairs\\n        :rtype: int\\n        \"\"\"\\n        counts = defaultdict(int)\\n        for num in nums:\\n            counts[num] += 1\\n        good_pairs = 0\\n        for count in counts.values():\\n            if count > 1:\\n                good_pairs += count * (count - 1) // 2\\n        return good_pairs\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731702,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i] == nums[j]) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i] == nums[j]) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731616,
                "title": "clean-python-3-counter-and-math-o-n",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n```\\nimport collections\\nimport math\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        counter = collections.Counter(nums)\\n        return sum(math.comb(count, 2) for count in counter.values() if count > 1)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport math\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        counter = collections.Counter(nums)\\n        return sum(math.comb(count, 2) for count in counter.values() if count > 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974306,
                "title": "optimized-with-frequency-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrequency Array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int mx=Arrays.stream(nums).max().getAsInt();\\n        int[] freqArray=new int[mx+1];\\n        for(int i:nums){\\n            freqArray[i]++;\\n        }\\n        int ans=0;\\n        for(int i:freqArray){\\n            ans += (i*(i-1))/2;\\n        }return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int mx=Arrays.stream(nums).max().getAsInt();\\n        int[] freqArray=new int[mx+1];\\n        for(int i:nums){\\n            freqArray[i]++;\\n        }\\n        int ans=0;\\n        for(int i:freqArray){\\n            ans += (i*(i-1))/2;\\n        }return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899512,
                "title": "simple-solution-with-dictionary-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, done with brute force where I achieved the task but time complexity is higher i.e. O(n^2), then come up with this dictionary approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        result={}\\n        res=0\\n\\n        for num in nums:\\n            if num in result:\\n                res+=result[num]\\n                result[num]+=1\\n            else:\\n                result[num]=1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        result={}\\n        res=0\\n\\n        for num in nums:\\n            if num in result:\\n                res+=result[num]\\n                result[num]+=1\\n            else:\\n                result[num]=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526881,
                "title": "c-java-simple-solution-single-iteration-o-n",
                "content": "\\n# Approach\\nWe will use a HashMap to store the numbers and frequency of those numbers.\\nIn single iteration, we will check if the number exists in map we will increase the count by frequency of the number, and increase the frequncy by 1.\\nIf the number does not exist we will add the number to the map with frequency 1.\\n$$ map <int,\\\\hspace{0.1cm}int> \\\\hspace{0.2cm} $$ key = nums[i], value = frequency\\n$$ count \\\\hspace{0.1cm} += map[nums[i]] \\\\hspace{0.2cm} $$\\n*Let 1 exists 3 times then, [1, 1, 1] --> {0, 1}, {1, 2}, {0, 2}*\\n\\n# Dry run\\n$$nums:$$ [ 1, 2, 3, 1, 1, 3 ] $$ \\\\hspace{0.2cm} n:$$ 6\\n\\n$$ i = 0, $$ map = { } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 1, $$ map = { {1, 1} } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 2, $$ map = { {1, 1}, {2, 1} } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 3, $$ map = { {1, 2}, {2, 1}, {3, 1} } $$ \\\\hspace{0.2cm} count = 1 $$\\n$$ i = 4, $$ map = { {1, 3}, {2, 1}, {3, 1} } $$ \\\\hspace{0.2cm} count = 3 $$\\n$$ i = 5, $$ map = { {1, 3}, {2, 1}, {3, 2} } $$ \\\\hspace{0.2cm} count = 4 $$\\n\\n$$ number \\\\hspace{0.1cm} of \\\\hspace{0.1cm} magic \\\\hspace{0.1cm} pairs: $$ 4\\n\\n*Note:* First update the number then change the frequency.\\n\\n# Complexity\\n- Time complexity: **O(n)** $$ To \\\\hspace{0.2cm} traverse \\\\hspace{0.2cm} once \\\\hspace{0.2cm} through \\\\hspace{0.2cm} the \\\\hspace{0.2cm} given \\\\hspace{0.2cm} array.$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** $$ To \\\\hspace{0.2cm} store \\\\hspace{0.2cm} the \\\\hspace{0.2cm} array \\\\hspace{0.2cm} in  \\\\hspace{0.2cm} a \\\\hspace{0.2cm} hashmap. $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int, int> m;\\n        int count = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (m.count(nums[i]) > 0) {\\n                count += m[nums[i]];\\n                m[nums[i]] = m[nums[i]] + 1;\\n            } else {\\n                m[nums[i]] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (map.containsKey(nums[i])) {\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int, int> m;\\n        int count = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (m.count(nums[i]) > 0) {\\n                count += m[nums[i]];\\n                m[nums[i]] = m[nums[i]] + 1;\\n            } else {\\n                m[nums[i]] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (map.containsKey(nums[i])) {\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497764,
                "title": "c-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        Dictionary<int, int> id = new();\\n        int ans = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int c= id.GetValueOrDefault(nums[i],0);\\n            ans += c;\\n            id[nums[i]] = c + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        Dictionary<int, int> id = new();\\n        int ans = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int c= id.GetValueOrDefault(nums[i],0);\\n            ans += c;\\n            id[nums[i]] = c + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466162,
                "title": "three-c-easy-solutions-with-time-and-space-complexity",
                "content": "\\n**Solution: 1**\\n\\n\\nSimple just compare the ```ith``` and ```jth``` index.\\n```\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(N^2)\\n    Space Complexity : O(N)\\n*/\\n\\n```\\n\\n**Solution:2**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/\\n\\n\\n```\\n\\n\\n**Solution: 3**\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/    \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```ith```\n```jth```\n```\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(N^2)\\n    Space Complexity : O(N)\\n*/\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289788,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280312,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: 82 ms.Beats 76.37% of other solutions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:38.2 MB.Beats 15.19% of other solutions.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.Length-1;i++){\\n            for(int j=i+1;j<nums.Length;j++)\\n            if(nums[i]==nums[j])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.Length-1;i++){\\n            for(int j=i+1;j<nums.Length;j++)\\n            if(nums[i]==nums[j])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168634,
                "title": "python-2-ways",
                "content": "# O(n) time, O(n) space\\nFirst solution is a **hash table**-based approach to count the number of good pairs. Here I use a dictionary `repeats` where the keys are the unique integers in `nums` and the values are the number of times that integer appears in `nums`. Then iterate through `nums` and increments the count of pairs by the number of times the current integer has already appeared in `nums`.\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        repeats: dict[int, int] = {}\\n        pairs = 0\\n        for num in nums:\\n            if num in repeats:\\n                pairs += repeats[num]\\n                repeats[num] += 1\\n            else:\\n                repeats[num] = 1\\n        return pairs\\n\\n```\\n# O(n^2) time, O(1) space\\nSecond solution is a nested loop approach to count the number of good pairs in the given array of integers `nums`. Here I use an outer loop to iterate through `nums`, and an inner loop to compare the current integer to each subsequent integer in `nums`. If the current integer and the next integer are equal, increments the count of pairs.\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        for i, left in enumerate(nums):\\n            j = i + 1\\n            while j < len(nums):\\n                right = nums[j]\\n                if left == right:\\n                    pairs += 1\\n                j += 1\\n        return pairs\\n```\\n...but runtime and memory consumption in submissions are almost equal",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        repeats: dict[int, int] = {}\\n        pairs = 0\\n        for num in nums:\\n            if num in repeats:\\n                pairs += repeats[num]\\n                repeats[num] += 1\\n            else:\\n                repeats[num] = 1\\n        return pairs\\n\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        for i, left in enumerate(nums):\\n            j = i + 1\\n            while j < len(nums):\\n                right = nums[j]\\n                if left == right:\\n                    pairs += 1\\n                j += 1\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063412,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use two for loops but then I decided to reduce the time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used a hashmap which stores the elements count and for the elements having count more than 1,I will apply the formula n*(n-1)/2 as among them we need to choose the pairs and finally add the value to the variable pairs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!hm.containsKey(nums[i]))\\n                hm.put(nums[i],1);\\n            else{\\n                int val=hm.get(nums[i]);\\n                val++;\\n                hm.put(nums[i],val);\\n            }\\n        }\\n        for(Map.Entry<Integer,Integer> entry : hm.entrySet()) {\\n            int val=entry.getValue();\\n            if(val>1){\\n                pairs+=val*(val-1)/2;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!hm.containsKey(nums[i]))\\n                hm.put(nums[i],1);\\n            else{\\n                int val=hm.get(nums[i]);\\n                val++;\\n                hm.put(nums[i],val);\\n            }\\n        }\\n        for(Map.Entry<Integer,Integer> entry : hm.entrySet()) {\\n            int val=entry.getValue();\\n            if(val>1){\\n                pairs+=val*(val-1)/2;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979550,
                "title": "c-hashmap-explained-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hashmap;\\n        int count=0;\\n        for (int i=0;i<nums.size();i++){\\n    //we will increase the frequency if we encounter the same number again\\n            hashmap[nums[i]]++;\\n//we will add counts of pairs by freq-1 for ex if freq 2 pair will be 1 ,if freq is 3 pair will be 2 etc etc.\\n            if (hashmap[nums[i]]>1){\\n                count+=hashmap[nums[i]]-1;\\n            }\\n       \\n        }\\n//return the ans\\n        return count;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hashmap;\\n        int count=0;\\n        for (int i=0;i<nums.size();i++){\\n    //we will increase the frequency if we encounter the same number again\\n            hashmap[nums[i]]++;\\n//we will add counts of pairs by freq-1 for ex if freq 2 pair will be 1 ,if freq is 3 pair will be 2 etc etc.\\n            if (hashmap[nums[i]]>1){\\n                count+=hashmap[nums[i]]-1;\\n            }\\n       \\n        }\\n//return the ans\\n        return count;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972803,
                "title": "c-solution-2ms-simpleapproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937996,
                "title": "using-java-simple-code",
                "content": "# Intuition\\nwithout any advance method \\n\\n# Approach\\nmatching approach\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int numIdenticalPairs(int[] nums) {\\n        int c=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int numIdenticalPairs(int[] nums) {\\n        int c=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853022,
                "title": "0ms-solution",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n\\tvar res int\\n\\thashMap := make(map[int]int)\\n\\tfor _, val := range nums {\\n\\t\\thashMap[val]++\\n\\t}\\n\\tfor _, element := range hashMap {\\n\\t\\tfor i := element - 1; i > 0; i-- {\\n\\t\\t\\tres = res + i\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n\\tvar res int\\n\\thashMap := make(map[int]int)\\n\\tfor _, val := range nums {\\n\\t\\thashMap[val]++\\n\\t}\\n\\tfor _, element := range hashMap {\\n\\t\\tfor i := element - 1; i > 0; i-- {\\n\\t\\t\\tres = res + i\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2830033,
                "title": "c-nested-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe input size is small enough we can just do nested loops.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWell, nested loops.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int good_pairs = 0;\\n        for (int i = 0; i < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j)\\n                good_pairs += nums[i] == nums[j];\\n        \\n        return good_pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int good_pairs = 0;\\n        for (int i = 0; i < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j)\\n                good_pairs += nums[i] == nums[j];\\n        \\n        return good_pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788796,
                "title": "o-n-java",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i:nums)m.put(i,m.getOrDefault(i,0)+1);\\n        \\n        int c=0;\\n        \\n        for(int i:m.keySet()){\\n            int n=m.get(i);\\n            int val=n-1;\\n            if(n>1)c+=(val*(val+1))/2;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i:nums)m.put(i,m.getOrDefault(i,0)+1);\\n        \\n        int c=0;\\n        \\n        for(int i:m.keySet()){\\n            int n=m.get(i);\\n            int val=n-1;\\n            if(n>1)c+=(val*(val+1))/2;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785405,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++)\\n                if(nums[i]==nums[j])\\n                    count++;\\n        }\\n        return count;\\n    }\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++)\\n                if(nums[i]==nums[j])\\n                    count++;\\n        }\\n        return count;\\n    }\\n\\t}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2784238,
                "title": "easy-c-o-n-soln-faang-interview-optimized-code",
                "content": "# **Plz Upvote if it helps \\uD83D\\uDE4F**\\n\\n# \\uD83D\\uDC49 Approach-1  (O(n^2) using Bruteforce)\\n> Time Complexity: O(n^2) \\nSpace Complexity: O(1)\\n![Screenshot (3405).png](https://assets.leetcode.com/users/images/dd357b66-2fcc-49a1-8b50-6abf5d4ac4e4_1667720335.9933274.png)\\n\\n\\n# \\uD83D\\uDC49 Approach-2  (O(nlogn) using sort())\\n\\n> Time Complexity: O(nlogn) \\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int count = 1 , p = 0;\\n        for(int i = 0 ; i < nums.size()-1 ; i++){\\n            if(nums[i] == nums[i+1])\\n                count++;\\n            else{\\n                p = p + count*(count-1)/2;\\n                count = 1;\\n            }      \\n        }\\n        p = p + count*(count-1)/2;\\n        return p;\\n    }\\n};\\n```\\n\\n# \\uD83D\\uDC49 Approach-3  (Most Optimal \\uD83D\\uDD25 O(n) using Unordered map )\\n\\n1) Create an unordered map and store no. of time all elements occur in nums.\\n2) If count>1, use the combination formula NC2, which gives n*(n-1)/2;\\n\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n> Time Complexity: O(n) \\uD83D\\uDCAF\\uD83D\\uDCA8\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n       unordered_map <int,int> mp;\\n       int res=0;\\n       for(int i = 0 ; i < nums.size() ; i++){\\n           mp[nums[i]]++;\\n       }\\n       for(auto it : mp){\\n           if(it.second>1)\\n               res+=it.second*(it.second-1)/2;\\n       }\\n       return res;\\n    }\\n};\\n```\\n\\n#### ***For \\'n\\' numbers you can have nC2 pairs, which is equal to (n*(n-1))/2.**\\n\\n**I hope it cleared your doubt, if not you can check this out (https://stackoverflow.com/questions/18859430/how-do-i-get-the-total-number-of-unique-pairs-of-a-set-in-the-database)**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int count = 1 , p = 0;\\n        for(int i = 0 ; i < nums.size()-1 ; i++){\\n            if(nums[i] == nums[i+1])\\n                count++;\\n            else{\\n                p = p + count*(count-1)/2;\\n                count = 1;\\n            }      \\n        }\\n        p = p + count*(count-1)/2;\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n       unordered_map <int,int> mp;\\n       int res=0;\\n       for(int i = 0 ; i < nums.size() ; i++){\\n           mp[nums[i]]++;\\n       }\\n       for(auto it : mp){\\n           if(it.second>1)\\n               res+=it.second*(it.second-1)/2;\\n       }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766771,
                "title": "java-easy-solution",
                "content": "Time Complexity: O(N^2)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs = 0;\\n        int length = nums.length;\\n        for (int i = 0; i < length; i++) {\\n            for (int j = i + 1; j < length; j++) {\\n                if (nums[i] == nums[j])\\n                    pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs = 0;\\n        int length = nums.length;\\n        for (int i = 0; i < length; i++) {\\n            for (int j = i + 1; j < length; j++) {\\n                if (nums[i] == nums[j])\\n                    pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726864,
                "title": "0ms-100-fastest-cpp-solution-using-hash-map",
                "content": "\\n# # Abb is ke liye ek upvote tho bantha hai yaar..\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numIdenticalPairs(vector<int>& nums) {\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tunordered_map <int,int> mp;\\n\\t\\t\\tfor(int i=0;  i<nums.size();  i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal  +=  mp[nums[i]];\\n\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numIdenticalPairs(vector<int>& nums) {\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tunordered_map <int,int> mp;\\n\\t\\t\\tfor(int i=0;  i<nums.size();  i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal  +=  mp[nums[i]];\\n\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2672879,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int sum = 0;\\n        map<int,int>mp;//To keep track of how many times elements of nums occur\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            sum += mp[nums[i]]++;//if we get an element, check in map how many times it has occured before and add in sum\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int sum = 0;\\n        map<int,int>mp;//To keep track of how many times elements of nums occur\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            sum += mp[nums[i]]++;//if we get an element, check in map how many times it has occured before and add in sum\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672346,
                "title": "100-faster-with-easy-understand",
                "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count =0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count =0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2552019,
                "title": "java-hashmap-mathematics-combinations-nc2",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm.put(arr[i], hm.getOrDefault(arr[i], 0)+1);\\n        }\\n        int ans = 0;\\n        for(Map.Entry<Integer, Integer> m: hm.entrySet()){\\n            int i = m.getValue();\\n            int res = (i*(i-1))/2;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm.put(arr[i], hm.getOrDefault(arr[i], 0)+1);\\n        }\\n        int ans = 0;\\n        for(Map.Entry<Integer, Integer> m: hm.entrySet()){\\n            int i = m.getValue();\\n            int res = (i*(i-1))/2;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473799,
                "title": "java-solution-95-faster",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       int i=0;\\n            int j=i+1;\\n            int count=0;\\n            while (i<nums.length-1){\\n                if (nums[i]==nums[j])\\n                    count++;\\n                j++;\\n                if (j==nums.length) {\\n                    i++;\\n                    j=i+1;\\n                }\\n            }\\n            return count; \\n    }\\n}\\n```\\nPlease Give a upvote if you find this helpful",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       int i=0;\\n            int j=i+1;\\n            int count=0;\\n            while (i<nums.length-1){\\n                if (nums[i]==nums[j])\\n                    count++;\\n                j++;\\n                if (j==nums.length) {\\n                    i++;\\n                    j=i+1;\\n                }\\n            }\\n            return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400203,
                "title": "python-o-2-solution",
                "content": "```\\nclass SolutionTwo:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n\\n        goodPairs = 0;\\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if (nums[i] == nums[j]):\\n                    goodPairs += 1;\\n\\n        return goodPairs;\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SolutionTwo:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n\\n        goodPairs = 0;\\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if (nums[i] == nums[j]):\\n                    goodPairs += 1;\\n\\n        return goodPairs;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295967,
                "title": "solution-in-o-n-time-python",
                "content": "If we consider the following example: [1, 2, 3, 1, 1, 2, 1]\\nWe have 6 (1, 1) pairs and 1 (2, 2), total is 7.\\n\\nIn the array, 1 appears 4 times and that gives us 6 pairs, 2 appears twice and that gives 1 pair.\\nWe can try to figure out a relation between frequence of appearance of a number and the numbers of good pairs that genarates.\\n\\nIf we take number 1, based on the following figure, we have 3 + 2 +1 = 6 good pairs.\\nIf we generalize that, if **k is the frequency** of a number in the array, the number of pairs generated by k would be the sum **(k-1) + (k-2) + ... + 1** and that is the sum of the first (k-1) numbers, which is equal to: **(k-1)k/2**.\\n\\n![image](https://assets.leetcode.com/users/images/de7704ef-6180-4263-b806-47245d4efcea_1658072374.5028248.png)\\n\\n\\nSo, first, we need to keep track of the appearance of a number in the array. We can achieve that by using a hashmap/dictionary.\\n```python\\nfor num in nums:\\n\\tif num in freq:\\n\\t\\tfreq[num] += 1\\n\\telse:\\n\\t\\tfreq[num] = 1\\n```\\n\\nSecond, we iterate through the frequencies, and sum up the number of pairs each frequency generates.\\n```python\\nfor num in freq:\\n\\tcount += (freq[num]*(freq[num]-1)//2)\\n```\\n\\nA solution to this problem would then be:\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        freq = {}\\n        for num in nums:\\n            if num in freq:\\n                freq[num] += 1\\n            else:\\n                freq[num] = 1\\n        for num in freq:\\n            count += (freq[num]*(freq[num]-1)//2)\\n        return count \\n```\\n\\n**Time Complexity**: O(N), N being the number of elements in the array. First we iterate though the array to calculate the frequencies. That is done in O(N) time. Then we iterate through the dictionary once to calculate the number of good pairs, that is in worst-case (all numbers are different) done in O(N) time. So, total is O(2N) ~ O(N).\\n**Space Complexity**: O(N), we use a dictionaty to keep track of the frequencies, which in worst-case (all numbers are different) consumes N extra space.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfor num in nums:\\n\\tif num in freq:\\n\\t\\tfreq[num] += 1\\n\\telse:\\n\\t\\tfreq[num] = 1\\n```\n```python\\nfor num in freq:\\n\\tcount += (freq[num]*(freq[num]-1)//2)\\n```\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        freq = {}\\n        for num in nums:\\n            if num in freq:\\n                freq[num] += 1\\n            else:\\n                freq[num] = 1\\n        for num in freq:\\n            count += (freq[num]*(freq[num]-1)//2)\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250415,
                "title": "python3-o-n-o-n-runtime-47ms-60-77-memory-13-8mb-95-62",
                "content": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 60.77% Memory: 13.8mb 95.62%\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\t\\t\\t\\n        freqOfNumber = Counter(nums)\\n\\t\\t\\n        return sum([key * (key - 1) // 2 for key in freqOfNumber.values()])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 60.77% Memory: 13.8mb 95.62%\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\t\\t\\t\\n        freqOfNumber = Counter(nums)\\n\\t\\t\\n        return sum([key * (key - 1) // 2 for key in freqOfNumber.values()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189733,
                "title": "python-using-hashmap",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        dic = {}\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] in dic:\\n                ans += dic[nums[i]]\\n                dic[nums[i]] += 1\\n            else:\\n                dic[nums[i]] = 1 \\n        return ans\\n```\\nTime : O(N)\\nSpace : O(N)\\nPlease **UPVOTE**.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        dic = {}\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] in dic:\\n                ans += dic[nums[i]]\\n                dic[nums[i]] += 1\\n            else:\\n                dic[nums[i]] = 1 \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967855,
                "title": "java-0ms-counting-explanation-simple",
                "content": "The trick to solving this problem is to realize that for any given number, the number of \"good pairs\" that can be made with this number is the number of times we have seen this number previously in the array.\\n\\nWith the above logic, we just need to **iterate** over the input and **count** the number of times we have seen a given number so far, then add that to the total result before incrementing the count for the current number.\\n\\nSomething very important to mention, is that we can only get away with using an array of size 101 because the problem constraints state that no number in the input will be greater than 100. If this constaint didn\\'t exist, we could use something like a **HashMap** to keep track of the counts.\\n\\nUsing a **HashMap** instead of the array is perfectly acceptable and does yield the same runtime, but in practice will be much slower because of **overhead** from the **HashMap**. To recap, the use of a **HashMap** would not change the runtime complexity but it does make the practical performance worse.\\n\\n**Runtime Complexity - O(N)**\\n**Memory Complexity - O(1)**\\nwhere N is the size of the input array.\\n```\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] counts = new int[101];\\n        \\n        int toReturn = 0;\\n        for(int num : nums) {\\n            toReturn += counts[num];\\n            counts[num]++;\\n        }\\n        \\n        return toReturn;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] counts = new int[101];\\n        \\n        int toReturn = 0;\\n        for(int num : nums) {\\n            toReturn += counts[num];\\n            counts[num]++;\\n        }\\n        \\n        return toReturn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730842,
                "title": "python-beginner-65-fast-using-hashmap-and-explanation",
                "content": "1. getting the count of all the numbers in a hashmap.\\n2. the number can only make a pair when it has frequency in the map more than once so we traverse the array checking frequence in the map we made\\n3. if the frequency is more than one we add to the result no of pairs it can make (number of pairs it can make is 1 less then the current frequency).\\n4. after we add to the result we subtract from the frequency of the count and continue in the loop.\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = Counter(nums)\\n        \\n        #for n in nums:\\n        #    count[n] += 1\\n            \\n        res = 0\\n        \\n        for i in nums:\\n            if count[i] > 1:\\n                res += count[i] - 1\\n                count[i] -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = Counter(nums)\\n        \\n        #for n in nums:\\n        #    count[n] += 1\\n            \\n        res = 0\\n        \\n        for i in nums:\\n            if count[i] > 1:\\n                res += count[i] - 1\\n                count[i] -= 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1701546,
                "title": "100-faster-solution-using-unordered-map-self-explainable",
                "content": "Guys do upvote if you like it, Please.\\nI have used a unordered map to count the occurence of elements in the array .\\nAfter counting ,if count>=2 we need to add their possible no.of pairs to sum(result)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++)\\n            map[nums[i]]++;\\n        \\n        int sum=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        { \\n            int count=0;\\n            if(it->second>1)\\n            {\\n                for(int i=1;i<it->second;i++)\\n                    count+=i;\\n                \\n                sum+=count;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++)\\n            map[nums[i]]++;\\n        \\n        int sum=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        { \\n            int count=0;\\n            if(it->second>1)\\n            {\\n                for(int i=1;i<it->second;i++)\\n                    count+=i;\\n                \\n                sum+=count;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623759,
                "title": "python-99-7-faster-optimal-hashmap-solution",
                "content": "For the O(n) TC, O(n) SC solution, I used a dictionary to map the number to the number of times a value appears, starting from the last value.\\nI started from the last value because then the next time we see that number, we can count it as a good pair, since the index of the new number will be smaller than the index of the number we have in the dictionary. \\nIf the number is in the dictionary, we can increment our # of good pairs by adding the # of times we\\'ve seen the value.\\nFor example, if we have [1,1,1,1], we add 1 for the i = 2, 2 for i = 1, and 3 for the i = 0. We increment the counter in the dictionary after we\\'ve updated the count so we don\\'t include i = i as a good pair. This is effectively the same as ```n * (n - 1) / 2```, which is the sum from 1 to n-1.\\n\\n```\\n        count, nums_dict = 0, {}\\n        \\n        for i in range(-1, -(len(nums) + 1), -1):\\n            if nums[i] not in nums_dict:\\n                nums_dict[nums[i]] = 1\\n            else:\\n                count += nums_dict[nums[i]]\\n                nums_dict[nums[i]] += 1\\n        print(nums_dict)\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```n * (n - 1) / 2```\n```\\n        count, nums_dict = 0, {}\\n        \\n        for i in range(-1, -(len(nums) + 1), -1):\\n            if nums[i] not in nums_dict:\\n                nums_dict[nums[i]] = 1\\n            else:\\n                count += nums_dict[nums[i]]\\n                nums_dict[nums[i]] += 1\\n        print(nums_dict)\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1554481,
                "title": "easy-to-understand-with-and-without-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            for(int jindex = index + 1 ; jindex < nums.size() ; jindex++)\\n                if(nums[index] == nums[jindex])\\n                  count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n       \\n        int res = 0;\\n        \\n        for(auto n : nums)\\n        {\\n            res += map[n]++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        \\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            map[nums[index]]++;\\n        }\\n        \\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            int n = map[nums[index]];\\n            map[nums[index]] = 0;\\n            count += (n * (n - 1))/2;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            for(int jindex = index + 1 ; jindex < nums.size() ; jindex++)\\n                if(nums[index] == nums[jindex])\\n                  count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n       \\n        int res = 0;\\n        \\n        for(auto n : nums)\\n        {\\n            res += map[n]++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        \\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            map[nums[index]]++;\\n        }\\n        \\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            int n = map[nums[index]];\\n            map[nums[index]] = 0;\\n            count += (n * (n - 1))/2;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495575,
                "title": "super-fast-100",
                "content": "int result =0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                result+=map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n       return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "int result =0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                result+=map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n       return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1479230,
                "title": "python3-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mydict = {}\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] += 1\\n        \\n        count = 0\\n        for i in mydict:\\n            count += (mydict[i]*(mydict[i]-1))/2\\n        return int(count)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mydict = {}",
                "codeTag": "Java"
            },
            {
                "id": 1469620,
                "title": "0-ms-faster-java-hashmap-with-inline-comments",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //declare and initialize a count variable that keeps track of pairs\\n\\t\\tint count = 0;\\n\\t\\t// declare a HashMap that stores <K,V> in form of <nums[i], frequency of nums[i]>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\t\\n\\t\\t//loop once through the array to store <K,V> in map\\n\\t\\tfor(int i = 0 ; i < nums.length; i++) {\\n\\t\\t\\t//check if map contains nums[i]\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n                // increase the count as nums[i] is repeated\\n\\t\\t\\t\\tcount += map.get(nums[i]);\\n\\t\\t\\t\\t//if nums[i] exists; add it to the map and increase it\\'s frequency.\\n\\t\\t\\t\\tmap.put(nums[i], map.get(nums[i]) + 1);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n                //add it to map and initialize count to 1 (first occurence of nums[i])\\n\\t\\t\\t\\tmap.put(nums[i], 1);\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```\\ninputs appreciated.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //declare and initialize a count variable that keeps track of pairs\\n\\t\\tint count = 0;\\n\\t\\t// declare a HashMap that stores <K,V> in form of <nums[i], frequency of nums[i]>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\t\\n\\t\\t//loop once through the array to store <K,V> in map\\n\\t\\tfor(int i = 0 ; i < nums.length; i++) {\\n\\t\\t\\t//check if map contains nums[i]\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n                // increase the count as nums[i] is repeated\\n\\t\\t\\t\\tcount += map.get(nums[i]);\\n\\t\\t\\t\\t//if nums[i] exists; add it to the map and increase it\\'s frequency.\\n\\t\\t\\t\\tmap.put(nums[i], map.get(nums[i]) + 1);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n                //add it to map and initialize count to 1 (first occurence of nums[i])\\n\\t\\t\\t\\tmap.put(nums[i], 1);\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191619,
                "title": "go",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    c:=0\\n    m := make(map[int]int)\\n    for i:=0;i<len(nums);i++{\\n            if _, ok := m[nums[i]]; ok {\\n                c+=m[nums[i]]\\n            } \\n            m[nums[i]]++\\n    }\\n    return c\\n}",
                "solutionTags": [],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    c:=0\\n    m := make(map[int]int)\\n    for i:=0;i<len(nums);i++{\\n            if _, ok := m[nums[i]]; ok {\\n                c+=m[nums[i]]\\n            } \\n            m[nums[i]]++\\n    }\\n    return c\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1148606,
                "title": "rust-one-line-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_identical_pairs(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold([0i32; 101], |mut acc, &x| {\\n                acc[x as usize] += 1;\\n                acc\\n            })\\n            .iter()\\n            .filter(|&&x| x > 1)\\n            .map(|&x| x * (x - 1) / 2)\\n            .sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_identical_pairs(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold([0i32; 101], |mut acc, &x| {\\n                acc[x as usize] += 1;\\n                acc\\n            })\\n            .iter()\\n            .filter(|&&x| x > 1)\\n            .map(|&x| x * (x - 1) / 2)\\n            .sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147877,
                "title": "brute-force-solution",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1 , len(nums)):\\n                if(nums[i] == nums[j]): count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1 , len(nums)):\\n                if(nums[i] == nums[j]): count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123625,
                "title": "64-ms-faster-than-99-80-of-javascript",
                "content": "Runtime: 64 ms, faster than 99.80% of JavaScript online submissions for Number of Good Pairs.\\nMemory Usage: 38.3 MB, less than 86.10% of JavaScript online submissions for Number of Good Pairs.\\n\\n```\\nvar numIdenticalPairs = function(nums) {\\n  let result = 0\\n  nums.forEach((number, index) => {\\n    index = nums.indexOf(number, index + 1)\\n    while(index > 0) {\\n      result++\\n      index = nums.indexOf(number, index + 1)\\n    }\\n  })\\n  return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n  let result = 0\\n  nums.forEach((number, index) => {\\n    index = nums.indexOf(number, index + 1)\\n    while(index > 0) {\\n      result++\\n      index = nums.indexOf(number, index + 1)\\n    }\\n  })\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070483,
                "title": "java-o-n",
                "content": "```\\nimport java.util.HashMap; \\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> h = new HashMap<>();\\n        for (int num:nums){\\n            h.put(num, h.getOrDefault(num, 0) + 1);\\n        }\\n        int sum = 0;\\n        \\n        for(int n: h.values()){\\n            sum += ((n*(n-1))/2);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.HashMap; \\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> h = new HashMap<>();\\n        for (int num:nums){\\n            h.put(num, h.getOrDefault(num, 0) + 1);\\n        }\\n        int sum = 0;\\n        \\n        for(int n: h.values()){\\n            sum += ((n*(n-1))/2);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012671,
                "title": "java-0-ms-using-hashmap",
                "content": "```\\n\\npublic static  int numIdenticalPairs(int [] nums){\\n\\tMap<Integer,Integer> numbersMap = new HashMap<>();\\n\\tint counter = 0;\\n\\t\\n\\tfor(int keys : nums){\\n\\t\\tnumbersMap.put(keys,numbersMap.getOrDefault(keys,0)+1);\\n\\t}\\n\\t\\n\\tfor(int keys : numbersMap.keySet()){\\n\\t\\tint values = numbersMap.get(keys);\\n\\n\\t\\tif(values > 1){\\n\\t\\t\\tcounter += values * (values - 1) / 2;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn counter;\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic static  int numIdenticalPairs(int [] nums){\\n\\tMap<Integer,Integer> numbersMap = new HashMap<>();\\n\\tint counter = 0;\\n\\t\\n\\tfor(int keys : nums){\\n\\t\\tnumbersMap.put(keys,numbersMap.getOrDefault(keys,0)+1);\\n\\t}\\n\\t\\n\\tfor(int keys : numbersMap.keySet()){\\n\\t\\tint values = numbersMap.get(keys);\\n\\n\\t\\tif(values > 1){\\n\\t\\t\\tcounter += values * (values - 1) / 2;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn counter;\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989147,
                "title": "python-3",
                "content": "Runtime: 32 ms\\nMemory Usage: 14.2 MB\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        good_pairs = 0\\n\\t\\t\\n\\t\\t#continue this while loop till the list is empty \\n        while nums != []:\\n\\t\\t\\n\\t\\t#for loop: from 2nd element onwards\\n            for i in range(1, len(nums)):\\n\\t\\t\\t\\n\\t\\t\\t#if first element is equal to the 2nd element\\n                if nums[0] == nums[i]:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#add to good_pairs\\n                    good_pairs+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#after going checking element 1&2, 1&3, til 1&n, remove the first element \\n\\t\\t\\t#this is to prevent counting the same pair twice\\n            nums.remove(nums[0])\\n\\t\\t\\t\\n\\t\\t#while loop continues till we remove all elements\\n\\t\\t\\n        return good_pairs\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        good_pairs = 0\\n\\t\\t\\n\\t\\t#continue this while loop till the list is empty \\n        while nums != []:\\n\\t\\t\\n\\t\\t#for loop: from 2nd element onwards\\n            for i in range(1, len(nums)):\\n\\t\\t\\t\\n\\t\\t\\t#if first element is equal to the 2nd element\\n                if nums[0] == nums[i]:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#add to good_pairs\\n                    good_pairs+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#after going checking element 1&2, 1&3, til 1&n, remove the first element \\n\\t\\t\\t#this is to prevent counting the same pair twice\\n            nums.remove(nums[0])\\n\\t\\t\\t\\n\\t\\t#while loop continues till we remove all elements\\n\\t\\t\\n        return good_pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955727,
                "title": "python-simple-o-n-dict-solution",
                "content": "\\t\\tans = 0\\n        d = {}\\n        for num in nums:\\n            if num in d:\\n                ans += d[num]\\n            d[num] = d.get(num,0) + 1\\n\\n        return ans",
                "solutionTags": [],
                "code": "\\t\\tans = 0\\n        d = {}\\n        for num in nums:\\n            if num in d:\\n                ans += d[num]\\n            d[num] = d.get(num,0) + 1\\n\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 885329,
                "title": "java-solution-hashmap-o-n",
                "content": "Open to optimisations, feel the additional map.get can be removed.\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //we need nested loop to compare OR\\n        //use dictionary to store unique values then see if they come up again, increment, add to final count\\n        \\n        HashMap<Integer, Integer> numSet = new HashMap();\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!numSet.containsKey(nums[i])) numSet.put(nums[i], 1); //marks each unique value\\n            else if(numSet.containsKey(nums[i])){\\n                count += numSet.get(nums[i]); //adds amount of each value\\n                numSet.put(nums[i], numSet.get(nums[i]) + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //we need nested loop to compare OR\\n        //use dictionary to store unique values then see if they come up again, increment, add to final count\\n        \\n        HashMap<Integer, Integer> numSet = new HashMap();\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!numSet.containsKey(nums[i])) numSet.put(nums[i], 1); //marks each unique value\\n            else if(numSet.containsKey(nums[i])){\\n                count += numSet.get(nums[i]); //adds amount of each value\\n                numSet.put(nums[i], numSet.get(nums[i]) + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834972,
                "title": "java-solution-think-bigger",
                "content": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            map.put(i, map.getOrDefault(i,0) + 1);\\n        }\\n           // System.out.print(i + \"\\\\t\" + map.get(i) + \"\\\\n\");\\n        \\n        for(int i: map.keySet()) {\\n            if(map.get(i) > 1) {\\n                int c = map.get(i);\\n                int r = 2;\\n                // int ncr = nCr(c, r);\\n                int ncr = (factorial(c).divide((factorial(c-r).multiply(BigInteger.TWO)))).intValue();\\n                res += ncr;\\n                // System.out.print(i + \"\\\\t\" + map.get(i) + \"\\\\t\" + ncr + \"\\\\n\");\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    /*\\n     * Java method to calculate factorial of a large number\\n     * @return BigInteger factorial of given number\\n     */\\n    public BigInteger factorial(int number) {\\n        BigInteger factorial = BigInteger.ONE;\\n\\n        for (int i = number; i > 0; i--) {\\n            factorial = factorial.multiply(BigInteger.valueOf(i));\\n        }\\n\\n        return factorial;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            map.put(i, map.getOrDefault(i,0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 783177,
                "title": "java-0-n-solution-with-0-1-space-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    //make an integer array of size 101\\n    //iterate over the input array and increment the frequency at the index corresponding to the number in the array.\\n    //Use the formuale freqCount - 1 * freqCount / 2;\\n    //Logic Behind:\\n    //No. of fours = 4, No. of pairs = 6\\n    // No. of ones = 3, No. of pairs = 3\\n    // No. of two\\'s = 2, No, of pairs = 1\\n\\n    // If you try to note this down on a paper and try to work out how the number of pairs are being calculated:\\n    // As an example, Lets use No. of fours = 4:\\n    // there are four fours in our list, ignore the other numbers for now.:\\n    // 4 4 4 4\\n    // how many pairs can we make out of this ?\\n    // You can straight away use combinatorics.\\n\\n    // OR\\n\\n    // If you try to work this out and tell how we came to 6 pairs,\\n    // You can see that first 4 can be paired to the 3 fours in front of it.\\n    // The second four can be paired with the 2 fours in front of it (it has already been paired with the first one)\\n    // The third four can be paired with the last four.\\n    \\n    // If you count= 3 + 2 + 1\\n\\n    // you will immediately make the connection to the summation formulae (n(n+1))/2, but n here is 1 less than the             actual number.\\n\\n    \\n    //keep adding the results of factorial to the result i.e sum\\n    \\n    \\n    //TimeComplexity = O(n);\\n    //SpaceComplexity = O(1);\\n  \\n    public int numIdenticalPairs(int[] nums) {\\n        int goodPairs = 0;\\n        int[] freqCount = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++){\\n            freqCount[nums[i]]++;\\n        }\\n                \\n        int r = 2;\\n        \\n        for(int i=0; i<101; i++){\\n            \\n            if(freqCount[i] > 1){\\n                goodPairs += (freqCount[i] - 1) * (freqCount[i]) / 2;\\n            }\\n            \\n        }\\n        \\n        return goodPairs;\\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    //make an integer array of size 101\\n    //iterate over the input array and increment the frequency at the index corresponding to the number in the array.\\n    //Use the formuale freqCount - 1 * freqCount / 2;\\n    //Logic Behind:\\n    //No. of fours = 4, No. of pairs = 6\\n    // No. of ones = 3, No. of pairs = 3\\n    // No. of two\\'s = 2, No, of pairs = 1\\n\\n    // If you try to note this down on a paper and try to work out how the number of pairs are being calculated:\\n    // As an example, Lets use No. of fours = 4:\\n    // there are four fours in our list, ignore the other numbers for now.:\\n    // 4 4 4 4\\n    // how many pairs can we make out of this ?\\n    // You can straight away use combinatorics.\\n\\n    // OR\\n\\n    // If you try to work this out and tell how we came to 6 pairs,\\n    // You can see that first 4 can be paired to the 3 fours in front of it.\\n    // The second four can be paired with the 2 fours in front of it (it has already been paired with the first one)\\n    // The third four can be paired with the last four.\\n    \\n    // If you count= 3 + 2 + 1\\n\\n    // you will immediately make the connection to the summation formulae (n(n+1))/2, but n here is 1 less than the             actual number.\\n\\n    \\n    //keep adding the results of factorial to the result i.e sum\\n    \\n    \\n    //TimeComplexity = O(n);\\n    //SpaceComplexity = O(1);\\n  \\n    public int numIdenticalPairs(int[] nums) {\\n        int goodPairs = 0;\\n        int[] freqCount = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++){\\n            freqCount[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 776829,
                "title": "java-o-n-solution",
                "content": "The most naive solution is two scan to get the answer. After reviewing other solutions, I get the optimize one.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int pivot = nums[i];\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j] == pivot){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nThe idea of optimze solution is to use hashmap to record the occurrence of each elment of array. We initialize the hashmap with key of array element, value of 1. Each time a same element found, we update the value by add 1. We incrementally update the count to record the occurrence of element so far.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            if(map.containsKey(i)){\\n                count += map.get(i);\\n                map.put(i, map.get(i) + 1);\\n                \\n            }else{\\n                \\n                map.put(i, 1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int pivot = nums[i];\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j] == pivot){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            if(map.containsKey(i)){\\n                count += map.get(i);\\n                map.put(i, map.get(i) + 1);\\n                \\n            }else{\\n                \\n                map.put(i, 1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759183,
                "title": "javascript-map",
                "content": "```\\n\\nvar numIdenticalPairs = function(nums) {\\n    let map = new Map(); //store n,freq\\n    for(let n of nums){\\n        map.set(n, (map.get(n) || 0) + 1);\\n    }\\n    let res = 0;\\n    for(const [k,v] of map){\\n        res += parseInt((map.get(k) * (map.get(k) -1)) / 2);\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar numIdenticalPairs = function(nums) {\\n    let map = new Map(); //store n,freq\\n    for(let n of nums){\\n        map.set(n, (map.get(n) || 0) + 1);\\n    }\\n    let res = 0;\\n    for(const [k,v] of map){\\n        res += parseInt((map.get(k) * (map.get(k) -1)) / 2);\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732511,
                "title": "java-solution-using-hashmap",
                "content": "Here we have used a hashmap to store the number of times one particular element is found in the array.\\nWe store the number of times an elemnts appears in the array. \\nExolaining it with an example:-\\n\\n[1,2,3,1,1,3]\\n\\nStarting with first iteration we will add 1 in hashmap with coressponding value of occurrence i.e 1. \\nSame will happen for 2,3.\\nNow when we will reach 4th iteration 1 has to be updated so we get the value from hashmap and add in the variable sum defining that we have found the first pair(here value of sum is 1 now). Here after adding the value in sum we update the hashmap and put the value against 1 as 2, indicating that if 1 appears again in the array it can form pair with 2 ones. which happens for the case of 5th iteration where we find 1 again and add 2 in sum.(Now the value of sum is 3). In the last iteration we find 3 in hashmap for which 1 is stored which is added in the sum.\\nHence at last we get 4 as value which is the answer.\\n\\n\\n\\'\\'\\'\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        \\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(map.containsKey(nums[i])){               //Here we keep on updating the value in hashmap and keep on adding the value in sum\\n                \\n                \\n                \\n                int temp = map.get(nums[i]);\\n                sum+=temp;\\n                temp++;\\n                map.replace(nums[i],temp);\\n                \\n                \\n            }else{\\n                \\n                \\n                map.put(nums[i],1);  //for the first time value of hashmap for an element is always 1.\\n                \\n            }\\n            \\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        \\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(map.containsKey(nums[i])){               //Here we keep on updating the value in hashmap and keep on adding the value in sum\\n                \\n                \\n                \\n                int temp = map.get(nums[i]);\\n                sum+=temp;\\n                temp++;\\n                map.replace(nums[i],temp);\\n                \\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 731850,
                "title": "javascript-few-solutions-o-n",
                "content": "Using Object:\\n```\\nvar numIdenticalPairs = function(nums) {\\n  let obj = {};\\n  let p = 0;\\n  for (let n of nums) {\\n    if (obj[n]) {\\n      p += obj[n];\\n      obj[n] = obj[n] + 1;\\n    } else obj[n] = 1;\\n  }\\n  return p;\\n};\\n```\\nOne-liner:\\n```\\nlet numIdenticalPairs = A => A.map((_, i) => i + 1 == A.length ? 0 : A.slice(i).map((_, j) => Number(A[i] == A[i + j + 1])).reduce((a, b) => a + b)).reduce((a, b) => a + b);\\n```\\n2-liner:\\n```\\nvar numIdenticalPairs = function(nums, count = 0) {\\n  for (let i = 0; i < nums.length - 1; i += 1) for (let j = i + 1; j < nums.length; j += 1) count += nums[i] === nums[j];\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n  let obj = {};\\n  let p = 0;\\n  for (let n of nums) {\\n    if (obj[n]) {\\n      p += obj[n];\\n      obj[n] = obj[n] + 1;\\n    } else obj[n] = 1;\\n  }\\n  return p;\\n};\\n```\n```\\nlet numIdenticalPairs = A => A.map((_, i) => i + 1 == A.length ? 0 : A.slice(i).map((_, j) => Number(A[i] == A[i + j + 1])).reduce((a, b) => a + b)).reduce((a, b) => a + b);\\n```\n```\\nvar numIdenticalPairs = function(nums, count = 0) {\\n  for (let i = 0; i < nums.length - 1; i += 1) for (let j = i + 1; j < nums.length; j += 1) count += nums[i] === nums[j];\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731674,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        long long ans = 0;\\n        unordered_map<int,int>m;\\n        for(int x:nums) m[x]++;  // count occurance\\n        for(auto p: m){\\n            if(p.second > 1) ans += (p.second * (p.second-1) )/2;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        long long ans = 0;\\n        unordered_map<int,int>m;\\n        for(int x:nums) m[x]++;  // count occurance\\n        for(auto p: m){\\n            if(p.second > 1) ans += (p.second * (p.second-1) )/2;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731559,
                "title": "c-o-n-2-o-n",
                "content": "//TC-O(N^2) , SC-O(1)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int cnt = 0;\\n        for(int i=0; i<nums.size(); ++i)//take each number\\n        {\\n            for(int j=i+1; j<nums.size(); ++j)//check in next numbers\\n            {\\n                if(nums[i]==nums[j])//if they are same increment the counter for good pair\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n//TC-O(N) & SC-O(N)\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hash;\\n        int cnt = 0;\\n        for(auto n:nums)//take each number\\n        {//for 1 occurence add 0, for second occ add 1, for third occ add 2, (1 +2= 3), for 4th occ, add 3.(1+2+3=6)\\n            \\n           cnt += hash[n]++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n//2- 1\\n//3- 3\\n//4- 6\\n//5- 10\\n//6- 15\\n//7- 21\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int cnt = 0;\\n        for(int i=0; i<nums.size(); ++i)//take each number\\n        {\\n            for(int j=i+1; j<nums.size(); ++j)//check in next numbers\\n            {\\n                if(nums[i]==nums[j])//if they are same increment the counter for good pair\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hash;\\n        int cnt = 0;\\n        for(auto n:nums)//take each number\\n        {//for 1 occurence add 0, for second occ add 1, for third occ add 2, (1 +2= 3), for 4th occ, add 3.(1+2+3=6)\\n            \\n           cnt += hash[n]++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n//2- 1\\n//3- 3\\n//4- 6\\n//5- 10\\n//6- 15\\n//7- 21\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072440,
                "title": "easy-without-brute-force-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let holder = new Map();\\n    for(let i=0; i<nums.length; i++) {\\n        if(holder.has(nums[i])) {\\n            holder.set(nums[i], holder.get(nums[i])+1);\\n        }\\n        else {\\n            holder.set(nums[i], 1);\\n        }\\n    }\\n\\n    let count=0;\\n    holder.forEach (function(value, key) {\\n        let val = value-1;\\n        count = count + ((1 + val)/2 * val);\\n\\n    })\\n    return count;\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let holder = new Map();\\n    for(let i=0; i<nums.length; i++) {\\n        if(holder.has(nums[i])) {\\n            holder.set(nums[i], holder.get(nums[i])+1);\\n        }\\n        else {\\n            holder.set(nums[i], 1);\\n        }\\n    }\\n\\n    let count=0;\\n    holder.forEach (function(value, key) {\\n        let val = value-1;\\n        count = count + ((1 + val)/2 * val);\\n\\n    })\\n    return count;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037632,
                "title": "solution-of-number-of-good-pairs-problem",
                "content": "# Approach\\n- Solved using nCr formula.\\n- nCr is the number of ways of selecting some objects out of given objects where the order of the objects does not matter. It is expressed as nCr = n!/(r! * (n-r)!)\\n- You can use math.factorial(n) istead of function \"factorial\" to solve the problem\\n- n is the number of repeating digits\\n- r is the number of things to be chosen out of n things (r is equal to 2 in our case).\\n\\n\\n# Code with factorial()\\n```\\ndef factorial(n):\\n    if n==1 or n==0:\\n        return 1\\n    return n*factorial(n-1)\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = factorial(nums.count(nums[i]))\\n                r_factorial = factorial(nums.count(nums[i]) - 2)\\n                count += n_factorial/(r_factorial * 2)\\n            visited.add(nums[i])\\n        return int(count)   \\n```\\n# Code with math.factorial()\\n```\\nimport math\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = math.factorial(nums.count(nums[i]))\\n                r_factorial = math.factorial(nums.count(nums[i])-2)\\n                count += n_factorial/(r_factorial*2)\\n            visited.add(nums[i])\\n        return int(count)          \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\ndef factorial(n):\\n    if n==1 or n==0:\\n        return 1\\n    return n*factorial(n-1)\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = factorial(nums.count(nums[i]))\\n                r_factorial = factorial(nums.count(nums[i]) - 2)\\n                count += n_factorial/(r_factorial * 2)\\n            visited.add(nums[i])\\n        return int(count)   \\n```\n```\\nimport math\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = math.factorial(nums.count(nums[i]))\\n                r_factorial = math.factorial(nums.count(nums[i])-2)\\n                count += n_factorial/(r_factorial*2)\\n            visited.add(nums[i])\\n        return int(count)          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001148,
                "title": "easy-java-solution-with-simple-concept-for-beginners",
                "content": "# Intuition\\nAs the problem statement was to find the number of pairs so we can use the general array concept to get the pair \\n\\n# Approach\\nFirst initialize the counter and assign for loop and nested for loop \\nand increament the iteration part and check the condition that if itearated value of i and j is equal means return counter iteration.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n- Space complexity:\\n-O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int len =nums.length;\\n        int counter=0;\\n        for (int i =0;i<len;i++){\\n            for (int j=i+1;j<len;j++){\\n                if(nums[i]==nums[j]){\\n                    counter++; \\n                }           \\n            }\\n            \\n        }\\n        return counter;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int len =nums.length;\\n        int counter=0;\\n        for (int i =0;i<len;i++){\\n            for (int j=i+1;j<len;j++){\\n                if(nums[i]==nums[j]){\\n                    counter++; \\n                }           \\n            }\\n            \\n        }\\n        return counter;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690308,
                "title": "easy-javascript-solution-using-creating-map-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numIdenticalPairs(nums: number[]): number {\\n   let goodPair = 0 \\n   let map = {}\\n   for(let num of nums) {\\n     if(map[num]) {\\n       goodPair += map[num]\\n       map[num]++\\n     } else {\\n       map[num] = 1\\n     }\\n   }\\n  return goodPair\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numIdenticalPairs(nums: number[]): number {\\n   let goodPair = 0 \\n   let map = {}\\n   for(let num of nums) {\\n     if(map[num]) {\\n       goodPair += map[num]\\n       map[num]++\\n     } else {\\n       map[num] = 1\\n     }\\n   }\\n  return goodPair\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596640,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int numIdenticalPairs(vector<int>& nums) {\\n\\t\\n        int ans = 0 ; \\n        for(int i=0 ; i<nums.size() ;i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    ans++;\\n                }\\n            }\\n        }return ans; \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numIdenticalPairs(vector<int>& nums) {\\n\\t\\n        int ans = 0 ; \\n        for(int i=0 ; i<nums.size() ;i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3535804,
                "title": "without-hashing-nested-loop-for-beginner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508765,
                "title": "simplest-efficient-c-code-time-o-n-2-space-o-1",
                "content": "# Intuition\\nThe problem is asking to find the number of indices (i,j) such that i < j and nums[i] == nums[j]. One way to approach this problem is to iterate through the array and compare each element with all the elements that come after it. If we find any element that is equal to the current element, we increase a counter. At the end, the counter will hold the number of identical pairs.\\n\\n# Approach\\nThe given code is implementing the above approach. It is using two nested loops to iterate through the array and compare each element with all the elements that come after it. If the elements are equal, it increases the counter. At the end, it returns the counter.\\n\\n# Complexity\\n- Time complexity : $O(n^2)$, where n is the size of the array. This is because we are using two nested loops to iterate through the array.\\n\\n- Space complexity : $O(1)$. The algorithm uses a constant amount of extra space regardless of the size of the input.\\n\\n# Code\\n```\\nint numIdenticalPairs(int* nums, int n)\\n{\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int n)\\n{\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570274,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574043,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1566648,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574190,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1725781,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1576708,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575197,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575646,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574126,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575984,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1570274,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574043,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1566648,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574190,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1725781,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1576708,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575197,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575646,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574126,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575984,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 2065324,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2050477,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2018803,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1988708,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873411,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849584,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1842293,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1831229,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1824255,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1820535,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1801889,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1783702,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1778125,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1778122,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1752985,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1748692,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1744198,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1742060,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1740071,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1734618,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Substrings With Only 1s",
        "question_content": "<p>Given a binary string <code>s</code>, return <em>the number of substrings with all characters</em> <code>1</code><em>&#39;s</em>. Since the answer may be too large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0110111&quot;\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> There are 9 substring in total with only 1&#39;s characters.\n&quot;1&quot; -&gt; 5 times.\n&quot;11&quot; -&gt; 3 times.\n&quot;111&quot; -&gt; 1 time.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;101&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Substring &quot;1&quot; is shown 2 times in s.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;111111&quot;\n<strong>Output:</strong> 21\n<strong>Explanation:</strong> Each substring contains only 1&#39;s characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 731580,
                "title": "java-c-python-count",
                "content": "## **Explanation**\\n`count` the current number of consecutive \"1\".\\nFor each new element,\\nthere will be more `count` substring,\\nwith all characters 1\\'s.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numSub(String s) {\\n        int res = 0, count = 0, mod = (int)1e9 + 7;\\n        for (int i = 0; i < s.length(); ++i) {\\n            count = s.charAt(i) == \\'1\\' ? count + 1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numSub(string s) {\\n        int res = 0, count = 0, mod = 1e9 + 7;\\n        for (char c: s) {\\n            count = c == \\'1\\' ? count + 1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\nO(n) space though\\n```py\\n    def numSub(self, s):\\n        return sum(len(a) * (len(a) + 1) / 2 for a in s.split(\\'0\\')) % (10**9 + 7)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numSub(String s) {\\n        int res = 0, count = 0, mod = (int)1e9 + 7;\\n        for (int i = 0; i < s.length(); ++i) {\\n            count = s.charAt(i) == \\'1\\' ? count + 1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numSub(string s) {\\n        int res = 0, count = 0, mod = 1e9 + 7;\\n        for (char c: s) {\\n            count = c == \\'1\\' ? count + 1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def numSub(self, s):\\n        return sum(len(a) * (len(a) + 1) / 2 for a in s.split(\\'0\\')) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 731558,
                "title": "python-easy-readable-code",
                "content": "The example would be self explanatoy:\\n\"0110111\" can be evaluated to -->\\n0120123\\nNow if we sum up all these digits:\\n1+2+1+2+3 = 9 is the result!\\n\\n```\\nclass Solution(object):\\n    def numSub(self, s):\\n        res, currsum = 0,0\\n        for digit in s:\\n            if digit == \\'0\\':\\n                currsum = 0\\n            else:\\n                currsum += 1 \\n                res+=currsum \\n        return res % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSub(self, s):\\n        res, currsum = 0,0\\n        for digit in s:\\n            if digit == \\'0\\':\\n                currsum = 0\\n            else:\\n                currsum += 1 \\n                res+=currsum \\n        return res % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731633,
                "title": "c-java-sliding-window",
                "content": "Well, it\\'s easy - \\'0\\' cuts the previous string. So, when we see \\'0\\', we calculate how many strings can be formed between `i - 1` and `j`.\\n\\nThe formula is just sum of arithmetic progression (n * (n + 1) /2, or (i - j) * (i - j + 1) /2).\\n\\n**C++**\\n```cpp\\nint numSub(string s) {\\n    long res = 0;\\n    for (long i = 0, j = 0; i <= s.size(); ++i)\\n        if (i == s.size() || s[i] == \\'0\\') {\\n            res = (res + (i - j) * (i - j + 1) / 2) % 1000000007;\\n            j = i + 1;\\n        }\\n    return res;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int numSub(String s) {\\n    long res = 0;\\n    for (long i = 0, j = 0; i <= s.length(); ++i)\\n        if (i == s.length() || s.charAt((int)i) == \\'0\\') {\\n            res = (res + (i - j) * (i - j + 1) / 2) % 1000000007;\\n            j = i + 1;\\n        }\\n    return (int)res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numSub(string s) {\\n    long res = 0;\\n    for (long i = 0, j = 0; i <= s.size(); ++i)\\n        if (i == s.size() || s[i] == \\'0\\') {\\n            res = (res + (i - j) * (i - j + 1) / 2) % 1000000007;\\n            j = i + 1;\\n        }\\n    return res;\\n}\\n```\n```java\\npublic int numSub(String s) {\\n    long res = 0;\\n    for (long i = 0, j = 0; i <= s.length(); ++i)\\n        if (i == s.length() || s.charAt((int)i) == \\'0\\') {\\n            res = (res + (i - j) * (i - j + 1) / 2) % 1000000007;\\n            j = i + 1;\\n        }\\n    return (int)res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731622,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\n\\tint numSub(string s) {\\n        long res = 0;\\n        for(int i =0; i < s.length(); ++i)\\n        {\\n            long count = 0;\\n            while(s[i] == \\'1\\')\\n                count++, i++;\\n            res += count*(count+1)/2;\\n        }\\n        return res%1000000007;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tint numSub(string s) {\\n        long res = 0;\\n        for(int i =0; i < s.length(); ++i)\\n        {\\n            long count = 0;\\n            while(s[i] == \\'1\\')\\n                count++, i++;\\n            res += count*(count+1)/2;\\n        }\\n        return res%1000000007;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 731552,
                "title": "java-1-loop-o-n",
                "content": "```\\n    public int numSub(String s) {\\n        int res = 0, cnt = 0, mod = 1_000_000_007;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'1\\') res = (res + ++cnt) % mod;  // added cnt of subarrays ended with c;\\n            else cnt = 0;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numSub(String s) {\\n        int res = 0, cnt = 0, mod = 1_000_000_007;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'1\\') res = (res + ++cnt) % mod;  // added cnt of subarrays ended with c;\\n            else cnt = 0;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731757,
                "title": "java-python-3-count-continuous-1-s-o-n-one-liner-codes-w-brief-explanation-and-analysis",
                "content": "For `k` continuous `1`s, we have `1,  2, ..., k` substrings ending at `1st, 2nd, ..., kth 1`s, respectively; Therefore, there are `k * (k + 1) / 2` substrings for any `k` continuous `1`.\\n```java\\n    public int numSub(String s) {\\n        int sum = 0;\\n        for (int i = 0, cnt = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'1\\') {\\n                sum += ++cnt;\\n                sum %= 1_000_000_007;\\n            }else {\\n                cnt = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n```\\n```python\\n    def numSub(self, s: str) -> int:\\n        sum = cnt = 0\\n        for c in s:\\n            if c == \\'1\\':\\n                cnt += 1\\n                sum = (sum + cnt) % (10 ** 9 + 7)\\n            else:\\n                cnt = 0\\n        return sum\\n```\\n\\n----\\n**1 liners:**\\n```java\\n    public int numSub(String s) {\\n        return (int)(Arrays.stream(s.split(\"0+\")).mapToLong(u -> u.length() * (u.length() + 1L) / 2).sum() % 1_000_000_007);\\n    }\\n```\\n```python\\n    def numSub(self, s: str) -> int:\\n        return sum(map(lambda x : len(x) * (len(x) + 1) // 2, s.split(\\'0\\'))) % (10 ** 9 + 7)\\n```\\n\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public int numSub(String s) {\\n        int sum = 0;\\n        for (int i = 0, cnt = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'1\\') {\\n                sum += ++cnt;\\n                sum %= 1_000_000_007;\\n            }else {\\n                cnt = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n```\n```python\\n    def numSub(self, s: str) -> int:\\n        sum = cnt = 0\\n        for c in s:\\n            if c == \\'1\\':\\n                cnt += 1\\n                sum = (sum + cnt) % (10 ** 9 + 7)\\n            else:\\n                cnt = 0\\n        return sum\\n```\n```java\\n    public int numSub(String s) {\\n        return (int)(Arrays.stream(s.split(\"0+\")).mapToLong(u -> u.length() * (u.length() + 1L) / 2).sum() % 1_000_000_007);\\n    }\\n```\n```python\\n    def numSub(self, s: str) -> int:\\n        return sum(map(lambda x : len(x) * (len(x) + 1) // 2, s.split(\\'0\\'))) % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 731754,
                "title": "python-sum-of-arithmetic-progression-with-explanation-100-00-faster",
                "content": "There is a ***pattern***, you will find that the ***result is the sum of arithmetic progression***.\\nArithmetic progression: **t(n) = a + d(n-1)**\\nSum of arithmetic progression: **s(n) = (n / 2) * (2a + d(n-1))**\\n\\nIn this problem, the first term(a) will be the the length of \"1\" and the number of terms will also be the length of \"1\".\\n\\nThe common difference(d) is **-1**.\\n\\n**E.g. input is \"111111\"**\\nThen, \\n**n = 6\\na = 6\\nd = -1**\\nAfterthat, calculate the sum of arithmetic progression with the formula of **s(n) = (n / 2) * (2a + d(n-1))**,\\nCalculate step by step:  **(6-0) + (6-1) + (6-2) + (6-3) + (6-4) + (6-5) = 21**,\\nwhich is the result of this problem.\\n\\n***Solution***\\n*100% Faster, Memory Usage less than 100.00% of Python3 online submissions.*\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int: \\n            res = 0\\n            s = s.split(\"0\")\\n\\n            for one in s:\\n                if one == \"\":\\n                    continue\\n                    \\n                n = len(one)\\n                temp = (n / 2)*(2*n + (n-1)*-1)\\n                    \\n                if temp >= 1000000007:\\n                    res += temp % 1000000007\\n                else:\\n                    res += temp\\n            return int(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int: \\n            res = 0\\n            s = s.split(\"0\")\\n\\n            for one in s:\\n                if one == \"\":\\n                    continue\\n                    \\n                n = len(one)\\n                temp = (n / 2)*(2*n + (n-1)*-1)\\n                    \\n                if temp >= 1000000007:\\n                    res += temp % 1000000007\\n                else:\\n                    res += temp\\n            return int(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206806,
                "title": "c-easy-math-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSub(string s) {\\n\\t\\t\\tlong count = 0;\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\tfor(int i  = 0; i < s.size(); i++){\\n\\t\\t\\t\\tif(s[i] == \\'1\\'){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tans += (count * (count + 1)) / 2;\\n\\t\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn (ans + (count * (count + 1)) / 2) % 1000000007;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numSub(string s) {\\n\\t\\t\\tlong count = 0;\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\tfor(int i  = 0; i < s.size(); i++){\\n\\t\\t\\t\\tif(s[i] == \\'1\\'){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 786651,
                "title": "java-counting-linear-time-constant-space-explained",
                "content": "Algorithm ideas:\\neach next consequent 1 contributes to all unique strings with length 1 to k (where k is number of subsequent 1s), k substrings overall. In other words count of possible substrings increased by k\\neach 0 should reset the count of 1s\\n\\nO(n) time - scan every character in S once\\nO(1) space - no extra space\\n\\n```\\n    public int numSub(String s) {\\n        long count = 0;\\n        int ones = 0;\\n        \\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                ones = 0;\\n            } else {\\n                count+=++ones;\\n            }\\n        }\\n        return (int) (count%1_000_000_007);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n    public int numSub(String s) {\\n        long count = 0;\\n        int ones = 0;\\n        \\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                ones = 0;\\n            } else {\\n                count+=++ones;\\n            }\\n        }\\n        return (int) (count%1_000_000_007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304820,
                "title": "c-o-n-full-beginner-friendly-explanation",
                "content": "**Please upvote, if you find the solution helpful !**\\n\\nSolution : \\nLogic : We count the number of total number of 1\\'s in every substring which contain only 1\\'s.\\n\\n **Wait, Let me explain!**\\n Let\\'s take an example : suppose our string is **conscOnes** = \"111\" i.e. comprising of all 1\\'s. \\n\\nNow, \\n**How to calculate  the total number of substrings that contains only 1\\'s?**\\nSimple - we have consider all the substrings, So :-\\nThe number of substrings containing only one 1 will be : 3 (i.e. all individual 1\\'s)\\nThe number of substrings containing two 1\\'s will be : 2 (i.e. combining 2 consecutive 1\\'s at a time )\\nThe number of substrings containing three 1\\'s will be : 1(i.e. combining 3 consecutive 1\\'s at a time)\\nSo, the total number of such substrings would be (3 + 2 + 1 ... in this case). \\n\\nBut can you see a general pattern ??\\nYes, if the size of such a string ( **string conscOnes** ) is **n** then, the number of substrings would be **( n + (n-1) + (n-2) + . . . (1) )** which is = **(n * (n + 1)) / 2 .**\\nSo, if we know the number of 1\\'s in a **conscOnes** string then we can calculate the number of substrings using the above formula.\\n\\nNow, our task is reduced to : **find the number of 1\\'s** in **every conscOnes string** present in string S, and then we know what to do ! (wink!)\\nNow, Do you agree to the fact that, while traversing the string S if a \\'1\\' is encountered then a new conscOnes string will start and if a \\'0\\' is encountered the conscOnes string will end.\\n\\nThat\\'s it : as soon as a conscOnes string start we increment a count variable, and as soon as it ends, we add ( count * ( count + 1 ) ) / 2) to our final ans variable.\\n \\n```\\nint numSub(string s) \\n    {\\n\\t\\t// since the answer can overflow, that\\'s why long long int is taken instead of int\\n        long long int ans = 0, count = 0;\\n        int mod = 1000000007;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                ans += ( (count * (count + 1)) / 2);\\n                count = 0;\\n            }\\n            else\\n                count++;\\n        }\\n        \\n        ans += ( (count * (count + 1)) / 2);\\n        \\n        return ans % mod;\\n    }",
                "solutionTags": [],
                "code": "**Please upvote, if you find the solution helpful !**\\n\\nSolution : \\nLogic : We count the number of total number of 1\\'s in every substring which contain only 1\\'s.\\n\\n **Wait, Let me explain!**\\n Let\\'s take an example : suppose our string is **conscOnes** = \"111\" i.e. comprising of all 1\\'s. \\n\\nNow, \\n**How to calculate  the total number of substrings that contains only 1\\'s?**\\nSimple - we have consider all the substrings, So :-\\nThe number of substrings containing only one 1 will be : 3 (i.e. all individual 1\\'s)\\nThe number of substrings containing two 1\\'s will be : 2 (i.e. combining 2 consecutive 1\\'s at a time )\\nThe number of substrings containing three 1\\'s will be : 1(i.e. combining 3 consecutive 1\\'s at a time)\\nSo, the total number of such substrings would be (3 + 2 + 1 ... in this case). \\n\\nBut can you see a general pattern ??\\nYes, if the size of such a string ( **string conscOnes** ) is **n** then, the number of substrings would be **( n + (n-1) + (n-2) + . . . (1) )** which is = **(n * (n + 1)) / 2 .**\\nSo, if we know the number of 1\\'s in a **conscOnes** string then we can calculate the number of substrings using the above formula.\\n\\nNow, our task is reduced to : **find the number of 1\\'s** in **every conscOnes string** present in string S, and then we know what to do ! (wink!)\\nNow, Do you agree to the fact that, while traversing the string S if a \\'1\\' is encountered then a new conscOnes string will start and if a \\'0\\' is encountered the conscOnes string will end.\\n\\nThat\\'s it : as soon as a conscOnes string start we increment a count variable, and as soon as it ends, we add ( count * ( count + 1 ) ) / 2) to our final ans variable.\\n \\n```\\nint numSub(string s) \\n    {\\n\\t\\t// since the answer can overflow, that\\'s why long long int is taken instead of int\\n        long long int ans = 0, count = 0;\\n        int mod = 1000000007;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                ans += ( (count * (count + 1)) / 2);\\n                count = 0;\\n            }\\n            else\\n                count++;\\n        }\\n        \\n        ans += ( (count * (count + 1)) / 2);\\n        \\n        return ans % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 731593,
                "title": "clean-python-3-counting-ones-with-math-o-n",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        mod = 10 ** 9 + 7\\n        seq = (len(ones) for ones in s.split(\\'0\\') if ones)\\n        return sum((ones * (ones + 1)) // 2 for ones in seq) % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        mod = 10 ** 9 + 7\\n        seq = (len(ones) for ones in s.split(\\'0\\') if ones)\\n        return sum((ones * (ones + 1)) // 2 for ones in seq) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731574,
                "title": "c-o-n-find-the-pattern",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) \\n    {\\n        int res=0;\\n        int i=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long count=0;\\n                while(s[i]==\\'1\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                count=((count*(count+1))%1000000007)/2;  // #substrings in a string of n characters is n*(n+1)/2\\n                res=(res+count)%1000000007;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nderivation of #substrings in a string of length n\\n\\nnumber of substrings in \"1\"=1(1)\\nnumber of substrings in \"11\"=3(1+2)\\nnumber of substrings in \"111\"=6(1+2+3)\\nnumber of substrings in \"1111\"=10(1+2+3+4)\\n.\\n.\\n.\\nnumber of substrings in \"111....n times\"=(1+2+3+...+n=n(n+1)/2)\\n\\nonce we know this,we can easily find the number of substrings with ony 1s in any string,\\n\\ns=\"0110111\"\\n#substrings in \"11\"=3\\n#substrings in \"111\"=6\\ntotal=3+6=9",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) \\n    {\\n        int res=0;\\n        int i=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long count=0;\\n                while(s[i]==\\'1\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                count=((count*(count+1))%1000000007)/2;  // #substrings in a string of n characters is n*(n+1)/2\\n                res=(res+count)%1000000007;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963888,
                "title": "easy-java-solution-tc-o-n-sc-o-1",
                "content": "```\\n  public int numSub(String s) {\\n        int prev=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'1\\'){\\n\\t\\t\\t\\t// If current element =1\\n                prev=prev+1;\\n            }else{\\n\\t\\t\\t\\t// If current element =0, reset prev=0\\n                prev=0;\\n            }\\n           ans+=prev;\\n           ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int numSub(String s) {\\n        int prev=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'1\\'){\\n\\t\\t\\t\\t// If current element =1\\n                prev=prev+1;\\n            }else{\\n\\t\\t\\t\\t// If current element =0, reset prev=0\\n                prev=0;\\n            }\\n           ans+=prev;\\n           ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849450,
                "title": "faster-than-94-2-approach-cpp-easy-understanding",
                "content": "```\\n//1.\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int num=0;\\n        long long count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\')\\n                count++;\\n            else{\\n\\t\\t\\t   // number of all substrings till n  = n * (n+1) / 2 \\n                count=((count*(count+1)%1000000007)/2);\\n                num=(num+count)%1000000007;\\n                count=0;\\n            } \\n        }\\n\\t\\t//to handle the edge case\\n        count=((count*(count+1)%1000000007)/2);\\n        num=(num+count)%1000000007;\\n        return num;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n         int num=0,count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') count++;\\n            else count=0;\\n            num=(num+count)%1000000007;\\n        }\\n        return num;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int num=0;\\n        long long count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\')\\n                count++;\\n            else{\\n\\t\\t\\t   // number of all substrings till n  = n * (n+1) / 2 \\n                count=((count*(count+1)%1000000007)/2);\\n                num=(num+count)%1000000007;\\n                count=0;\\n            } \\n        }\\n\\t\\t//to handle the edge case\\n        count=((count*(count+1)%1000000007)/2);\\n        num=(num+count)%1000000007;\\n        return num;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n         int num=0,count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') count++;\\n            else count=0;\\n            num=(num+count)%1000000007;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623044,
                "title": "java-shortest-solution",
                "content": "### *Please Upvote !!!* **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0, total = 0, mod = 1_000_000_007;\\n        \\n        for (char c : s.toCharArray()) {\\n            count = (c == \\'1\\') ? count + 1 : 0;\\n            total = (total + count) % mod;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0, total = 0, mod = 1_000_000_007;\\n        \\n        for (char c : s.toCharArray()) {\\n            count = (c == \\'1\\') ? count + 1 : 0;\\n            total = (total + count) % mod;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307948,
                "title": "one-liner-faster-than-98-sc-90",
                "content": "```\\n        return sum(map(lambda x: ((1+len(x))*len(x)//2)%(10**9+7), s.split(\\'0\\')))\\n```\\nIF THIS HELP U KINDLY UPVOTE THIS TO HELP OTHERS TO GET THIS SOLUTION\\nIF U DONT GET IT KINDLY COMMENT AND FEEL FREE TO ASK\\nAND CORRECT MEIF I AM WRONG",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        return sum(map(lambda x: ((1+len(x))*len(x)//2)%(10**9+7), s.split(\\'0\\')))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732058,
                "title": "just-a-clever-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        const int m=1000000007;\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        while(j<s.length()){\\n            if(s[j]==\\'1\\'){\\n                while(i<j and s[i]!=\\'1\\')\\n                    i++;\\n                res=(res%m+(j-i+1)%m)%m;\\n            }\\n            else if(s[j]==\\'0\\')\\n                i=j;\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWhen you see  j pointing to 1 reset i to the starting 1 of the chain.\\nand when the chain of one ends reset i to the next zero after the chain of ones.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        const int m=1000000007;\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        while(j<s.length()){\\n            if(s[j]==\\'1\\'){\\n                while(i<j and s[i]!=\\'1\\')\\n                    i++;\\n                res=(res%m+(j-i+1)%m)%m;\\n            }\\n            else if(s[j]==\\'0\\')\\n                i=j;\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731721,
                "title": "c-o-n",
                "content": "Apporach: \\n``array = [0 1 1 0 1 1 1]`` , lengths of subarray are 2 and 3\\nfor n -> (n* n+1 )/2\\n2 -> 3\\n3 -> 6\\n6+3 = 9\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long ans = 0;\\n        int mp = 1000000007;\\n        int n = s.length();\\n        long long count = 0,i=0;\\n        while(i<n && s[i] == \\'0\\') i++;\\n        if(i==n) return 0;\\n        for(;i<n;i++){\\n            if(s[i] == \\'1\\') count++;\\n            else{\\n                ans = (ans % mp + ((count*(count+1))/2 )%mp) % mp;\\n                count = 0;\\n            }\\n        }\\n        if(count > 0) ans = (ans % mp + ((count*(count+1))/2 )%mp) % mp;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long ans = 0;\\n        int mp = 1000000007;\\n        int n = s.length();\\n        long long count = 0,i=0;\\n        while(i<n && s[i] == \\'0\\') i++;\\n        if(i==n) return 0;\\n        for(;i<n;i++){\\n            if(s[i] == \\'1\\') count++;\\n            else{\\n                ans = (ans % mp + ((count*(count+1))/2 )%mp) % mp;\\n                count = 0;\\n            }\\n        }\\n        if(count > 0) ans = (ans % mp + ((count*(count+1))/2 )%mp) % mp;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731600,
                "title": "javascript-python3-c-sum-of-the-series",
                "content": "**Synopsis:**\\n\\nAccumulate the sum of the series for each `run` of consecutive 1s length.\\n\\n---\\n\\n**Contest 197 - Screenshare:** https://www.youtube.com/watch?v=-oXf4Ikou_c&feature=youtu.be\\n\\n---\\n\\n**Solutions:**\\n\\n*Javascript*\\n```\\nlet numSub = s => s.split(\\'0\\').map(run => run.length).reduce((sum, n) => (sum + Math.floor(n * (n + 1) / 2)) % (1e9 + 7), 0);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return reduce(lambda sum, n: (sum + (n * (n + 1)) // 2) % int(1e9 + 7), list(map(lambda run: len(run), s.split(\\'0\\'))), 0)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VLL = vector<LL>;\\n    int numSub(string s, int len = 0, VLL run = {}, int sum = 0) {\\n        s.push_back(\\'0\\'); // sentinel value to terminate the last run (if it exists)\\n        for (auto c: s)\\n            if (c == \\'1\\') ++len; else run.push_back(len), len = 0;\\n        for (auto n: run)\\n            sum = (sum + (n * (n + 1) / 2)) % LL(1e9 + 7);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet numSub = s => s.split(\\'0\\').map(run => run.length).reduce((sum, n) => (sum + Math.floor(n * (n + 1) / 2)) % (1e9 + 7), 0);\\n```\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return reduce(lambda sum, n: (sum + (n * (n + 1)) // 2) % int(1e9 + 7), list(map(lambda run: len(run), s.split(\\'0\\'))), 0)\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VLL = vector<LL>;\\n    int numSub(string s, int len = 0, VLL run = {}, int sum = 0) {\\n        s.push_back(\\'0\\'); // sentinel value to terminate the last run (if it exists)\\n        for (auto c: s)\\n            if (c == \\'1\\') ++len; else run.push_back(len), len = 0;\\n        for (auto n: run)\\n            sum = (sum + (n * (n + 1) / 2)) % LL(1e9 + 7);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829406,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long int ans = 0, i = 0, j= 0, n = s.length(),mod = 1e9+7;\\n        while(i<n){\\n            j = i;\\n            while(j<n && s[i] == s[j]){\\n                j++;\\n                if(s[i]==\\'1\\'){\\n                    ans = (ans+j-i)%mod;\\n                }\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long int ans = 0, i = 0, j= 0, n = s.length(),mod = 1e9+7;\\n        while(i<n){\\n            j = i;\\n            while(j<n && s[i] == s[j]){\\n                j++;\\n                if(s[i]==\\'1\\'){\\n                    ans = (ans+j-i)%mod;\\n                }\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747384,
                "title": "sum-of-n-numbers-python",
                "content": "Basically, the no. of consecutions \\'1\\'s can form n*(n+1)//2 substrings\\n11 -> 2 1s, 1 2s = 2+1\\n111 -> 3 1s, 2 2s, 1 3s = 3+2+1\\n1111 -> 4 1s, 3 2s, 2 3s, 1 4s = 4+3+2+1\\n\\n```\\n    def numSub(self, s: str) -> int:\\n        c=0\\n        ans=[]\\n        for x in s:\\n            if x==\\'1\\':\\n                c=c+1\\n            else:\\n                ans.append(c)\\n                c=0\\n        ans.append(c)\\n        \\n        res=0\\n        for x in ans:\\n            res=res+x*(x+1)//2\\n        return res%1000000007\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def numSub(self, s: str) -> int:\\n        c=0\\n        ans=[]\\n        for x in s:\\n            if x==\\'1\\':\\n                c=c+1\\n            else:\\n                ans.append(c)\\n                c=0\\n        ans.append(c)\\n        \\n        res=0\\n        for x in ans:\\n            res=res+x*(x+1)//2\\n        return res%1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2180878,
                "title": "go-2ms-beats-100",
                "content": "```\\nfunc numSub(s string) int {\\n\\tif len(s) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif len(s) == 1 {\\n\\t\\tif s[0] == 49 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\n\\t\\treturn 0\\n\\t}\\n\\n\\tleft := 0\\n\\n    for left < len(s) && s[left] != 49 {\\n\\t\\tleft++\\n\\t}\\n\\n\\tvar res int\\n\\n\\tfor i := left; i < len(s); i++ {\\n\\t\\tif s[i] == s[left] {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\tif s[i] == 48 {\\n\\t\\t\\t\\tres += helper(i - left)\\n\\t\\t\\t}\\n\\n\\t\\t\\tleft = i\\n\\t\\t}\\n\\t}\\n\\n    if left < len(s) && s[left] == 49 {\\n\\t\\tres += helper(len(s) - left)\\n\\t}\\n\\n\\treturn res % (int(math.Pow10(9)) + 7)\\n}\\n\\nfunc helper(length int) int {\\n\\tif length < 2 {\\n\\t\\treturn length\\n\\t}\\n\\n\\tvar res int\\n\\n\\tfor i := 1; i < length; i++ {\\n\\t\\tres += length - i\\n\\t}\\n\\n\\treturn res + length\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numSub(s string) int {\\n\\tif len(s) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif len(s) == 1 {\\n\\t\\tif s[0] == 49 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\n\\t\\treturn 0\\n\\t}\\n\\n\\tleft := 0\\n\\n    for left < len(s) && s[left] != 49 {\\n\\t\\tleft++\\n\\t}\\n\\n\\tvar res int\\n\\n\\tfor i := left; i < len(s); i++ {\\n\\t\\tif s[i] == s[left] {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\tif s[i] == 48 {\\n\\t\\t\\t\\tres += helper(i - left)\\n\\t\\t\\t}\\n\\n\\t\\t\\tleft = i\\n\\t\\t}\\n\\t}\\n\\n    if left < len(s) && s[left] == 49 {\\n\\t\\tres += helper(len(s) - left)\\n\\t}\\n\\n\\treturn res % (int(math.Pow10(9)) + 7)\\n}\\n\\nfunc helper(length int) int {\\n\\tif length < 2 {\\n\\t\\treturn length\\n\\t}\\n\\n\\tvar res int\\n\\n\\tfor i := 1; i < length; i++ {\\n\\t\\tres += length - i\\n\\t}\\n\\n\\treturn res + length\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128225,
                "title": "python-solution-one-pass",
                "content": "class Solution:\\n\\n    def numSub(self, s: str) -> int:\\n        ans = cum = 0\\n        for x in s:\\n            if x == \"1\":\\n                cum+=1\\n                ans+=cum\\n            else:\\n                cum = 0\\n        return ans%(10**9+7)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def numSub(self, s: str) -> int:\\n        ans = cum = 0\\n        for x in s:\\n            if x == \"1\":\\n                cum+=1\\n                ans+=cum\\n            else:\\n                cum = 0\\n        return ans%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 829441,
                "title": "java-solution-checking-for-consecutive-one",
                "content": "Here , I just counted the number of consecutive 1, and updated a counter varibale whenever we encountered with a 1. This varibale actually keep track of consecutive 1.\\n\\nNow we add this count with our result variable. The moment we see a 0, we reset the counter variable back to 0 and again start counting when we see the next 1.\\n\\n\\n\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        int modulus = (int)1e9 + 7;\\n        int result = 0;\\n        for (int i=0; i<s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\')\\n                count += 1;\\n            else\\n                count = 0;\\n            result = (result + count) % modulus;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        int modulus = (int)1e9 + 7;\\n        int result = 0;\\n        for (int i=0; i<s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\')\\n                count += 1;\\n            else\\n                count = 0;\\n            result = (result + count) % modulus;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734717,
                "title": "javascript-1-line-solution",
                "content": "_Runtime: 80 ms, faster than 100.00% of JavaScript online submissions_\\n_Memory Usage: 37.7 MB, less than 100.00% of JavaScript online submissions_\\n\\n```javascript\\nconst numSub = s =>\\n  s\\n    .split(\\'0\\')\\n    .reduce((cnt, { length: len }) => cnt + (len * (len + 1)) / 2, 0) %\\n  (10 ** 9 + 7);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst numSub = s =>\\n  s\\n    .split(\\'0\\')\\n    .reduce((cnt, { length: len }) => cnt + (len * (len + 1)) / 2, 0) %\\n  (10 ** 9 + 7);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732043,
                "title": "easy-count-and-sum-javascript-solution",
                "content": "```\\nvar numSub = function(s) {\\n    let result = 0;\\n    let len = 0;    \\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"1\") {\\n            len++;\\n            result += len;\\n        } else {\\n            len = 0;\\n        }\\n    }\\n    \\n    return result % 1000000007;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numSub = function(s) {\\n    let result = 0;\\n    let len = 0;    \\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"1\") {\\n            len++;\\n            result += len;\\n        } else {\\n            len = 0;\\n        }\\n    }\\n    \\n    return result % 1000000007;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731679,
                "title": "python-easy-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def numSub(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        arr = s.split(\"0\")\\n        for i in arr:\\n            n = len(i)\\n            if n == 0:\\n                continue\\n            res += n*(n+1)/2\\n            res = res % (10**9 + 7)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSub(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        arr = s.split(\"0\")\\n        for i in arr:\\n            n = len(i)\\n            if n == 0:\\n                continue\\n            res += n*(n+1)/2\\n            res = res % (10**9 + 7)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731634,
                "title": "python3-count-continuous-1",
                "content": "Algo\\nCount number of continuous `1` and use formula `n*(n+1)//2` to compute the answer. \\n\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        ans = n = 0\\n        for c in s:\\n            if c == \"0\": \\n                ans = (ans + n*(n+1)//2) % 1_000_000_007\\n                n = 0\\n            else: n += 1\\n        return (ans + n*(n+1)//2) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        ans = n = 0\\n        for c in s:\\n            if c == \"0\": \\n                ans = (ans + n*(n+1)//2) % 1_000_000_007\\n                n = 0\\n            else: n += 1\\n        return (ans + n*(n+1)//2) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819507,
                "title": "beats-90-cpp-sol",
                "content": "# **Pls Upvote if you found it Helpful \\uD83D\\uDE07**\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int numSub(string s) {\\n\\n        int front = 0;\\n        int back = 0;\\n        int ans = 0;\\n\\n        while(front < s.size()){\\n            while(front<s.size() && s[front] != \\'1\\'){\\n                front++;\\n            }\\n            back = front;\\n            while(front<s.size() && s[front] == \\'1\\'){\\n                ans = ans + (front-back+1);\\n                ans = ans % mod;\\n                front++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int numSub(string s) {\\n\\n        int front = 0;\\n        int back = 0;\\n        int ans = 0;\\n\\n        while(front < s.size()){\\n            while(front<s.size() && s[front] != \\'1\\'){\\n                front++;\\n            }\\n            back = front;\\n            while(front<s.size() && s[front] == \\'1\\'){\\n                ans = ans + (front-back+1);\\n                ans = ans % mod;\\n                front++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757780,
                "title": "easy-peasy-implementation-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.length(), mod = 1e9+7;\\n        int cnt = 0;\\n        long long ans = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'1\\'){\\n                cnt++;\\n                ans += cnt;\\n                ans = ans%mod;\\n            }\\n            else cnt = 0;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.length(), mod = 1e9+7;\\n        int cnt = 0;\\n        long long ans = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'1\\'){\\n                cnt++;\\n                ans += cnt;\\n                ans = ans%mod;\\n            }\\n            else cnt = 0;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730817,
                "title": "q1513-accepted-c-sliding-win-counting-easiest-method",
                "content": "CRUX\\n1) All single 1\\'s are the part of the ans. Inital loop for counting the number of 1\\'s in the string s.\\n2) Keeping the count as 1 and increment if 1\\'s are found consecutively.\\n3) Otherwise put count as 1 again.\\n\\nThe code is very readable, Please go through the code and read the above points again for better understanding .\\n\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numSub(string s) {\\n        int n = s.size();\\n        int ans = 0,count = 1;\\n        for(int i=0;i<n;i++)\\n            if(s[i] == \\'1\\')\\n                ans++;\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i] == \\'1\\' && s[i-1] == \\'1\\'){\\n                ans = (ans+count)%MOD;\\n                count++;\\n            }\\n            else\\n                count = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numSub(string s) {\\n        int n = s.size();\\n        int ans = 0,count = 1;\\n        for(int i=0;i<n;i++)\\n            if(s[i] == \\'1\\')\\n                ans++;\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i] == \\'1\\' && s[i-1] == \\'1\\'){\\n                ans = (ans+count)%MOD;\\n                count++;\\n            }\\n            else\\n                count = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917224,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long c=0, p=0, t = pow(10,9);\\n        for(auto& i : s){\\n            if(i==\\'1\\'){\\n                ++c;\\n            }\\n            else{\\n                p += c*(c+1)/2;\\n                c=0;\\n            }\\n        }\\n        p += c*(c+1)/2;\\n        return p%(t+7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long c=0, p=0, t = pow(10,9);\\n        for(auto& i : s){\\n            if(i==\\'1\\'){\\n                ++c;\\n            }\\n            else{\\n                p += c*(c+1)/2;\\n                c=0;\\n            }\\n        }\\n        p += c*(c+1)/2;\\n        return p%(t+7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827205,
                "title": "beginner-friendly-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n         long long consecutiveOnes = 0, ans = 0, mod = 1e9+7;\\n        for(int i = 0; i < s.size(); i++){\\n            // if the string of consecutiveOnes get broken add the answer\\n            if(s[i] == \\'0\\'){\\n                ans += consecutiveOnes*(consecutiveOnes+1)/2;\\n                consecutiveOnes = 0; //Setting consecutiveOnes to 0 so that next time consecutiveOnes will be calculated from 0 not from a precalculated value\\n            }\\n            else consecutiveOnes++;\\n        }\\n            ans += consecutiveOnes*(consecutiveOnes+1)/2;\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n         long long consecutiveOnes = 0, ans = 0, mod = 1e9+7;\\n        for(int i = 0; i < s.size(); i++){\\n            // if the string of consecutiveOnes get broken add the answer\\n            if(s[i] == \\'0\\'){\\n                ans += consecutiveOnes*(consecutiveOnes+1)/2;\\n                consecutiveOnes = 0; //Setting consecutiveOnes to 0 so that next time consecutiveOnes will be calculated from 0 not from a precalculated value\\n            }\\n            else consecutiveOnes++;\\n        }\\n            ans += consecutiveOnes*(consecutiveOnes+1)/2;\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826045,
                "title": "most-optimal-java-solution",
                "content": "```\\n public int numSub(String s) {\\n        long count = 0 , res = 0 , mod = (int)1e9+7 ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            count+=s.charAt(i)-\\'0\\';\\n            if(s.charAt(i)-\\'0\\'==0){\\n                res+=((count*(count+1))/2);\\n                count = 0 ;\\n            }\\n        }\\n        res+=((count*(count+1))/2);\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public int numSub(String s) {\\n        long count = 0 , res = 0 , mod = (int)1e9+7 ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            count+=s.charAt(i)-\\'0\\';\\n            if(s.charAt(i)-\\'0\\'==0){\\n                res+=((count*(count+1))/2);\\n                count = 0 ;\\n            }\\n        }\\n        res+=((count*(count+1))/2);\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2666927,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        vector<long> dp(s.length(), 0);\\n        if(s[0] == \\'1\\')\\n            dp[0] = 1;\\n        \\n        long sum = 0;\\n        for(int i = 1 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'1\\')\\n                dp[i] = dp[i - 1] + 1;\\n        }\\n        for(int i = 0 ; i < dp.size() - 1; i++)\\n        {\\n            if(dp[i] != 0 and dp[i + 1] == 0)\\n            {\\n                sum += ((dp[i])*(dp[i] + 1)/2)% 1000000007;\\n            }\\n        }\\n        if(dp[dp.size() - 1] != 0)\\n            sum += ((dp[dp.size() - 1])*(dp[dp.size() - 1] + 1)/2)% 1000000007;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        vector<long> dp(s.length(), 0);\\n        if(s[0] == \\'1\\')\\n            dp[0] = 1;\\n        \\n        long sum = 0;\\n        for(int i = 1 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'1\\')\\n                dp[i] = dp[i - 1] + 1;\\n        }\\n        for(int i = 0 ; i < dp.size() - 1; i++)\\n        {\\n            if(dp[i] != 0 and dp[i + 1] == 0)\\n            {\\n                sum += ((dp[i])*(dp[i] + 1)/2)% 1000000007;\\n            }\\n        }\\n        if(dp[dp.size() - 1] != 0)\\n            sum += ((dp[dp.size() - 1])*(dp[dp.size() - 1] + 1)/2)% 1000000007;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540843,
                "title": "java-simple-solution-runtime-7ms",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        if(s.indexOf(\"1\") < 0)\\n            return 0;\\n        int count = 0,res=0, mod = 1_000_000_007;\\n        for(int i=0 ; i < s.length(); i++){\\n            count = s.charAt(i) == \\'1\\' ? count+1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        if(s.indexOf(\"1\") < 0)\\n            return 0;\\n        int count = 0,res=0, mod = 1_000_000_007;\\n        for(int i=0 ; i < s.length(); i++){\\n            count = s.charAt(i) == \\'1\\' ? count+1 : 0;\\n            res = (res + count) % mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430342,
                "title": "help-needed-sliding-window-logic",
                "content": "**54/56 testcases passed!!!**\\n\\n\\'\\'\\'\\nclass Solution {\\n    public int numSub(String s) {\\n        int i,j;\\n    \\n\\t\\ti=0;j=0;\\n\\t\\tint ans=0;\\n\\t\\twhile(j<s.length())\\n\\t\\t{\\n\\t\\t    if(s.charAt(j)==\\'0\\')\\n\\t\\t    {\\n\\t\\t        i=j+1;\\n\\t\\t        j++;\\n\\t\\t    }\\n\\t\\t    \\n\\t\\t    else if(s.charAt(j)==\\'1\\')\\n\\t\\t    {\\n\\t\\t        ans+=j-i+1;\\n\\t\\t        j++;\\n\\t\\t    }\\n\\t\\t}\\n\\t\\t\\n        return ans%1000000007;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int numSub(String s) {\\n        int i,j;\\n    \\n\\t\\ti=0;j=0;\\n\\t\\tint ans=0;\\n\\t\\twhile(j<s.length())\\n\\t\\t{\\n\\t\\t    if(s.charAt(j)==\\'0\\')\\n\\t\\t    {\\n\\t\\t        i=j+1;\\n\\t\\t        j++;\\n\\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 2335800,
                "title": "run-length-counting-c-solution-o-n-and-no-branching",
                "content": "We note that the number of sub-strings is just the partial sum of the natural numbers up until the length of the original string, i.e. given a string of `1`\\'s of length *N* we have *(N + (N + 1)) / 2* sub-strings.\\n\\nLet\\'s look at a few examples.\\n\\n* For the input `1` we have 1 sub-string: `[1]`\\n* For the input `11` we have 3 sub-strings: `[1, 1, 11]`\\n* For the input `111` we have 6 sub-string: `[1, 1, 1, 11, 11, 111]`\\n\\nIn general, for the input `1...11` of length N we have:\\n\\n* *N* sub-strings of length *1*\\n* *N-1* sub-strings of length *2*\\n* *N-2* sub-strings of length *3*\\n* ...\\n* *2* sub-strings of length *N-1*\\n* *1* sub-string of length *N*\\n\\nLooking carefully we see that the number of sub-strings are *1 + 2 + 3 + ... + N*. This is a well-known sum -- often referred to as \"the partial sum of the natural numbers\" or \"the triangle numbers\" [[1](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF)].\\n\\nThe formula to compute the sum is *(N + (N + 1)) / 2*.\\n\\nNow that we can count the number of sub-strings *inside* a string of `1`\\'s we just need a way to count how many there are in a row. This is quite easy.\\n\\nWe loop over the input string and as long as the current character is `1` we increment a *run length* counter. If we encounter a `0` (or the end of the input string) we just add the sub-strings using the formula above.\\n\\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      if S[i] == \"1\"\\n  \\t      run += 1\\n  \\t  else\\n\\t      sum += (run + (run + 1)) / 2\\n\\t      run = 0\\n  sum += (run + (run + 1)) / 2\\n  return sum % (1e9 + 7)\\n```\\n\\nThere\\'s a slight variant (maybe an optimization) that we can do here if we observe that the *run length* counter will be *1, 2, 3, ...* and if we want the sum of that added to the total why not just do that immediately?\\n\\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      if S[i] == \"1\"\\n  \\t      run += 1\\n\\t\\t  sum += run\\n  \\t  else\\n\\t      run = 0\\n  return sum % (1e9 + 7)\\n```\\n\\nAs a final optimization we can get rid of the branch altogether if we carefully update the *run length* counter depending on the current character in the input string. We need to do two things: 1) increment the counter if it\\'s a `1` and 2) reset the counter if it\\'s not a `1`.\\n\\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      run = run * (S[i] == \"1\") + (S[i] == \"1\")\\n\\t  sum += run\\n  return sum % (1e9 + 7)\\n```\\n\\nThis C++ solution uses 64-bit unsigned integers to avoid overflowing, but a more rigurous solution could do the modulo inside the loop.\\n\\n```\\n    int numSub(const string &s) {\\n        uint64_t count = 0;\\n        uint64_t run = 0;\\n        for (auto c : s) {\\n            run = run * (c == \\'1\\') + (c == \\'1\\');\\n            count += run;\\n        }\\n        return (int)(count % 1000000007);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      if S[i] == \"1\"\\n  \\t      run += 1\\n  \\t  else\\n\\t      sum += (run + (run + 1)) / 2\\n\\t      run = 0\\n  sum += (run + (run + 1)) / 2\\n  return sum % (1e9 + 7)\\n```\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      if S[i] == \"1\"\\n  \\t      run += 1\\n\\t\\t  sum += run\\n  \\t  else\\n\\t      run = 0\\n  return sum % (1e9 + 7)\\n```\n```\\nnumSub(S):\\n  sum := 0\\n  run := 0\\n  for i in 0...len(S)-1\\n      run = run * (S[i] == \"1\") + (S[i] == \"1\")\\n\\t  sum += run\\n  return sum % (1e9 + 7)\\n```\n```\\n    int numSub(const string &s) {\\n        uint64_t count = 0;\\n        uint64_t run = 0;\\n        for (auto c : s) {\\n            run = run * (c == \\'1\\') + (c == \\'1\\');\\n            count += run;\\n        }\\n        return (int)(count % 1000000007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307772,
                "title": "c-sliding-window-commented-code-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/0d71b179-e6f6-4131-889e-537be2134a46_1658304703.3028126.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int i=0,j=0;\\n        int n = s.size();\\n        int res=0;\\n        for(;j<=n;j++){\\n            if(s[j]==\\'0\\' or j==n){ // the moment our window breaks we will do our caclulation.\\n                long long len =j-i;\\n                if(len>0){\\n                    long long sum = ((len*(len+1))%1000000007)/2; // as the contribution of the length is (n+1)*n/2;\\n                    res += sum%1000000007;\\n                }\\n                i=j+1;// set lower bound of window to the next of break point.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// TC - O(N)\\n// SC - O(1)\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int i=0,j=0;\\n        int n = s.size();\\n        int res=0;\\n        for(;j<=n;j++){\\n            if(s[j]==\\'0\\' or j==n){ // the moment our window breaks we will do our caclulation.\\n                long long len =j-i;\\n                if(len>0){\\n                    long long sum = ((len*(len+1))%1000000007)/2; // as the contribution of the length is (n+1)*n/2;\\n                    res += sum%1000000007;\\n                }\\n                i=j+1;// set lower bound of window to the next of break point.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// TC - O(N)\\n// SC - O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172856,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long count = 0;\\n        int n = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                count = (count + ++n);\\n            }\\n            else{\\n                n = 0;\\n            }\\n        }\\n        return (int)(count % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long count = 0;\\n        int n = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                count = (count + ++n);\\n            }\\n            else{\\n                n = 0;\\n            }\\n        }\\n        return (int)(count % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140473,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n=s.length();\\n        int c=1;\\n        ll ans=0;\\n        int cnt=0;\\n        for(char ch:s)\\n        {\\n            cnt+=(ch-\\'0\\');\\n        }\\n        if(cnt==0)\\n        return 0;\\n        s+=\\'0\\';\\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(s[i]==s[i-1]&&s[i]==\\'1\\')\\n            {\\n                c++;\\n            }\\n            else if(s[i]==\\'0\\'&&s[i-1]==\\'1\\')\\n            {\\n                ans+=c*(1ll)*(c+1)/2;\\n                ans=ans%mod;\\n                c=1;\\n            }\\n            \\n        }\\n        ans=ans%mod;\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n=s.length();\\n        int c=1;\\n        ll ans=0;\\n        int cnt=0;\\n        for(char ch:s)\\n        {\\n            cnt+=(ch-\\'0\\');\\n        }\\n        if(cnt==0)\\n        return 0;\\n        s+=\\'0\\';\\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(s[i]==s[i-1]&&s[i]==\\'1\\')\\n            {\\n                c++;\\n            }\\n            else if(s[i]==\\'0\\'&&s[i-1]==\\'1\\')\\n            {\\n                ans+=c*(1ll)*(c+1)/2;\\n                ans=ans%mod;\\n                c=1;\\n            }\\n            \\n        }\\n        ans=ans%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830061,
                "title": "number-of-substrings-with-only-1s-c-solution",
                "content": "class Solution {\\npublic:\\n    int numSub(string s) \\n    {\\n         int n=s.length();\\n         vector<int>dp(n+1,0);\\n         for(int i=0;i<n;i++)\\n         {\\n             if(s[i]==\\'1\\')\\n                 dp[i+1]=dp[i]+1;\\n         }\\n         long long int res=0;\\n         for(int i=0;i<=n;i++)\\n            res=(res+dp[i])%1000000007;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int numSub(string s) \\n    {\\n         int n=s.length();\\n         vector<int>dp(n+1,0);\\n         for(int i=0;i<n;i++)\\n         {\\n             if(s[i]==\\'1\\')\\n                 dp[i+1]=dp[i]+1;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1814012,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        cnt, ans = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                cnt = 0\\n            else:\\n                cnt += 1\\n                ans += cnt\\n        return ans % ((10**9)+7)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        cnt, ans = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                cnt = 0\\n            else:\\n                cnt += 1\\n                ans += cnt\\n        return ans % ((10**9)+7)",
                "codeTag": "Java"
            },
            {
                "id": 1785368,
                "title": "c-o-n-time-simple-solution-with-explanation-count-no-math-formula",
                "content": "Just use `cnt` to count # of consecutive 1 and add into `res`\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.size(), cnt = 0, res = 0, mod = 1e9+7;\\n        for (int i = 0; i < n; ++i) {\\n            cnt = s[i] == \\'1\\' ? cnt+1 : 0;\\n            res = (res+cnt) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.size(), cnt = 0, res = 0, mod = 1e9+7;\\n        for (int i = 0; i < n; ++i) {\\n            cnt = s[i] == \\'1\\' ? cnt+1 : 0;\\n            res = (res+cnt) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600322,
                "title": "o-n-time-o-1-space-java-solution",
                "content": "Looking at strings of only 1s:\\n`1` should return 1, `11` should return 3, `111` should return 6, and so on.\\nObserve that for a chain of `k` `1s`, the expected result is `k(k+1)/2`.\\n\\nKeep track of the length of the current chain of `1s` as you iterate through the string. Suppose the current chain of `1s` is of length `k` and you now see a `0`. Add `k(k+1)/2` to the result and reset the chain length count to `0`.\\n\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        long val = 0;\\n        int result = 0;\\n        final int MOD = (int) (Math.pow(10, 9) + 7);\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                val = val * (val + 1) / 2;\\n                result = (int) ((result + val) % MOD);\\n                val = 0;\\n            } else {\\n                val++;\\n            }\\n        }\\n        val = val * (val + 1) / 2;\\n        result = (int) ((result + val) % MOD);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long val = 0;\\n        int result = 0;\\n        final int MOD = (int) (Math.pow(10, 9) + 7);\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                val = val * (val + 1) / 2;\\n                result = (int) ((result + val) % MOD);\\n                val = 0;\\n            } else {\\n                val++;\\n            }\\n        }\\n        val = val * (val + 1) / 2;\\n        result = (int) ((result + val) % MOD);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543983,
                "title": "o-n-monotonic-stack",
                "content": "For each possible index `i` of our string `s`, we can ask the simpler/local question of what is the number of substrings consisting exclusively of `1`\\'s that end at index `i`. If we sum these local counts over all possible indices `i = 0, ...,  n-1`, we will generate our desired answer.\\n\\nThere are two cases to consider, for each index `i`:\\n\\n* **character at `i` is `0`**: in this case, we know there are no substrings that end at index `i` consisting exclusively on `1`\\'s, so we obtain a local count of 0 for this index\\n* **character at `i` is `1`**: in this case, we need to determine the most recently encountered `0` in the string. Once we know such (should it exist), this will tell us how many substrings ending at `i` consist exclusively of `1`\\'s.\\n\\n**MONOTONIC STACK**\\nIn the second case above, the fact we want the most recent occurrence of something (in this case, a `0`) should immediately signal to us that we want to leverage a LIFO data structure. We can use a monotonic stack that is storing previously handled indexes. As we encounter a `1` at some index `i`, we keep popping indexes from the stack that correspond to prior occurrences of `1`\\'s until we finally arrive at either:\\n\\n* an empty stack\\n* the index `j` of the most recent `0`\\n\\nIn the first case, this means we only encountered `1`\\'s up to this point, so every substring ending at index `i` (there are precisely `i+1` of them) will consist of only `1`\\'s.\\n\\nIn the second case, there are precisely `i - j` substrings starting at index `j+1` and ending at index `i`.\\n\\n**CODE**\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        s = [int(c) for c in s]\\n        n = len(s)\\n        \\n        count = 0\\n        stack = []\\n        for i in range(n):\\n            if s[i] == 1:\\n                while len(stack) > 0 and s[stack[-1]] != 0:\\n                    stack.pop(-1)\\n                if len(stack) == 0:\\n                    count += i + 1\\n                else:\\n                    count += i - stack[-1]\\n            stack.append(i)\\n            \\n        return count % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        s = [int(c) for c in s]\\n        n = len(s)\\n        \\n        count = 0\\n        stack = []\\n        for i in range(n):\\n            if s[i] == 1:\\n                while len(stack) > 0 and s[stack[-1]] != 0:\\n                    stack.pop(-1)\\n                if len(stack) == 0:\\n                    count += i + 1\\n                else:\\n                    count += i - stack[-1]\\n            stack.append(i)\\n            \\n        return count % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531077,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int ans=0;\\n        int i=0;\\n        int x=1e9+7;\\n        while(i<s.size()){\\n            if(i<s.size() && s[i]==\\'1\\'){\\n                int no_of_ones=0;\\n                while(i<s.size() && s[i]!=\\'0\\')  {no_of_ones++; i++;}\\n                ans=(ans +(long long) no_of_ones * (no_of_ones+1) /2) % x; \\n            }\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSub(string s) {\\n        int ans=0;\\n        int i=0;\\n        int x=1e9+7;\\n        while(i<s.size()){\\n            if(i<s.size() && s[i]==\\'1\\'){\\n                int no_of_ones=0;\\n                while(i<s.size() && s[i]!=\\'0\\')  {no_of_ones++; i++;}",
                "codeTag": "Java"
            },
            {
                "id": 1502481,
                "title": "c-sol-with-comments",
                "content": "Idea--> find the length of the each substring which consists of 1\\'s and let that length be n and\\n\\t\\t\\twe add n*(n+1)/2 to the sum which we return at last\\n```\\nint numSub(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        long long sum=0,count=0;\\n        int mod=7+pow(10,9);\\n\\t\\t\\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\n            if(s[i]==\\'1\\') count++;  // if s[i] is 1 then increase count\\n\\t\\t\\t\\n            else sum+=((count+1)*count/2)%mod,count=0;\\n\\t\\t\\t// if s[i] is 0 it means the 1\\'s substring is broken so add that to the sum\\n        }\\n        sum+=((count+1)*count/2)%mod;  // if the last character in the string is also 1\\n\\t\\t//then we need to add that also\\n\\t\\t\\n        return sum;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint numSub(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        long long sum=0,count=0;\\n        int mod=7+pow(10,9);\\n\\t\\t\\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\n            if(s[i]==\\'1\\') count++;  // if s[i] is 1 then increase count\\n\\t\\t\\t\\n            else sum+=((count+1)*count/2)%mod,count=0;\\n\\t\\t\\t// if s[i] is 0 it means the 1\\'s substring is broken so add that to the sum\\n        }\\n        sum+=((count+1)*count/2)%mod;  // if the last character in the string is also 1\\n\\t\\t//then we need to add that also\\n\\t\\t\\n        return sum;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1478372,
                "title": "c-simple-to-understand",
                "content": "```\\npublic class Solution {\\n    public int NumSub(string s) {\\n        var result = 0;\\n        var count = 0;\\n        var mod = (int)Math.Pow(10, 9) + 7;\\n        \\n        foreach (var item in s) {\\n            if (item == \\'1\\') {\\n                ++count;\\n            } else {\\n                count = 0;\\n            }            \\n            result = (result + count) % mod;\\n        }\\n        \\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSub(string s) {\\n        var result = 0;\\n        var count = 0;\\n        var mod = (int)Math.Pow(10, 9) + 7;\\n        \\n        foreach (var item in s) {\\n            if (item == \\'1\\') {\\n                ++count;\\n            } else {\\n                count = 0;\\n            }            \\n            result = (result + count) % mod;\\n        }\\n        \\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361689,
                "title": "c",
                "content": "```\\n\\n```public:\\n    int numSub(string s) {\\n        long long int i,f=0,sum=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            f=0;\\n            while(i<s.length()&&s[i]==\\'1\\')\\n            {\\n                f++;\\n                i++;\\n            }\\n            sum=sum+((f*(f+1))/2)%1000000007;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332960,
                "title": "java-easy-trick",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int mod=(int)1e9+7;\\n        int count=0,res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                count=(count+1)%mod;\\n            }\\n            else\\n            {\\n                count=0;\\n            }\\n            res=(res+count)%mod;\\n        }\\n        \\n        return res;        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSub(String s) {\\n        int mod=(int)1e9+7;\\n        int count=0,res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                count=(count+1)%mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1279892,
                "title": "python3-one-pass-30",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        #strategy: One Pass\\n        left = right = -1\\n        answer, mod = 0, 10 ** 9 + 7\\n        for i in range(len(s)):\\n            #create new interval\\n            if s[i] == \\'0\\':\\n                left = right = i\\n            #update right side to keep our interval running\\n            else:\\n                right = i\\n            #find the size of the interval which corresponds to the # of substrings up to pos right\\n            answer = (answer + right - left) % mod\\n        return answer % mod\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        #strategy: One Pass\\n        left = right = -1\\n        answer, mod = 0, 10 ** 9 + 7\\n        for i in range(len(s)):\\n            #create new interval\\n            if s[i] == \\'0\\':\\n                left = right = i\\n            #update right side to keep our interval running\\n            else:\\n                right = i\\n            #find the size of the interval which corresponds to the # of substrings up to pos right\\n            answer = (answer + right - left) % mod\\n        return answer % mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240872,
                "title": "simple-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int i = 0;\\n        int n = s.length();\\n        int result = 0;\\n        while(i<n)\\n        {\\n            int tot = 0;\\n            if(s[i] == \\'1\\')\\n            {\\n                while(s[i] == \\'1\\' and i<n)\\n                {\\n                    tot++;\\n                    result = (result+tot)%1000000007;\\n                    i++;\\n                }\\n            }\\n            tot = 0;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int i = 0;\\n        int n = s.length();\\n        int result = 0;\\n        while(i<n)\\n        {\\n            int tot = 0;\\n            if(s[i] == \\'1\\')\\n            {\\n                while(s[i] == \\'1\\' and i<n)\\n                {\\n                    tot++;\\n                    result = (result+tot)%1000000007;\\n                    i++;\\n                }\\n            }\\n            tot = 0;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232946,
                "title": "c-o-n-99-8-faster-with-comments",
                "content": "```\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        long long int sum=0;\\n        int n=s.size();\\n        long long int count = s[0]==\\'1\\'? 1: 0;\\n        \\n\\t\\t/*\\n\\t\\tSubstring of 1s start: s[0]==\\'1\\' || s[i-1]==\\'0\\'&&s[i]==\\'1\\'\\n\\t\\tSubstring of 1s end : s[n-1]==\\'1\\' || s[i-1]==\\'1\\'&&s[i]==\\'0\\'\\n\\t\\tNumber of permutations of substring of 1s with size count = (count*(count+1))/2\\n\\t\\t*/\\n\\t\\t\\n        for (int i=1; i<n; i++){\\n            if (s[i]==\\'1\\'){\\n                if (s[i-1]==\\'0\\')\\n                    count = 1;\\n                // s[i-1] == \\'1\\'\\n                else\\n                    count++;\\n            }\\n            // s[i] == \\'0\\'\\n            else{\\n                if (s[i-1]= \\'1\\'){\\n                    sum = (sum + (count*(count+1))/2)%MOD;\\n                    count = 0;\\n                }    \\n            }\\n        }\\n        sum = (sum + (count*(count+1))/2)%MOD;\\n        return sum%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        long long int sum=0;\\n        int n=s.size();\\n        long long int count = s[0]==\\'1\\'? 1: 0;\\n        \\n\\t\\t/*\\n\\t\\tSubstring of 1s start: s[0]==\\'1\\' || s[i-1]==\\'0\\'&&s[i]==\\'1\\'\\n\\t\\tSubstring of 1s end : s[n-1]==\\'1\\' || s[i-1]==\\'1\\'&&s[i]==\\'0\\'\\n\\t\\tNumber of permutations of substring of 1s with size count = (count*(count+1))/2\\n\\t\\t*/\\n\\t\\t\\n        for (int i=1; i<n; i++){\\n            if (s[i]==\\'1\\'){\\n                if (s[i-1]==\\'0\\')\\n                    count = 1;\\n                // s[i-1] == \\'1\\'\\n                else\\n                    count++;\\n            }\\n            // s[i] == \\'0\\'\\n            else{\\n                if (s[i-1]= \\'1\\'){\\n                    sum = (sum + (count*(count+1))/2)%MOD;\\n                    count = 0;\\n                }    \\n            }\\n        }\\n        sum = (sum + (count*(count+1))/2)%MOD;\\n        return sum%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225495,
                "title": "javascript-easy-to-understand-solution-61-83",
                "content": "Runtime: 88 ms, faster than 61.70% of JavaScript online submissions for Number of Substrings With Only 1s.\\nMemory Usage: 40.2 MB, less than 87.23% of JavaScript online submissions for Number of Substrings With Only 1s.\\n```\\nvar numSub = function(s) {\\n    let res = 0;\\n    let one = 0;\\n    for(let num of s){\\n        if(num===\"1\") one++, res+=one;\\n        else one = 0;\\n    }\\n    return res%1000000007;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numSub = function(s) {\\n    let res = 0;\\n    let one = 0;\\n    for(let num of s){\\n        if(num===\"1\") one++, res+=one;\\n        else one = 0;\\n    }\\n    return res%1000000007;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1210007,
                "title": "simplest-java-solution-one-pass-no-formula-with-explanation",
                "content": "**Intuition:**  The bruteforce way is to generate all the substrings and count all the substrings will all Ones. Time complexity for this would be :- O(n^3), which could be optimised to O(n^2) if we count while creating substrings.\\n\\nBut from here we can observe that at each index we only want to know all the substrings with one ending there. So, basically we only want the count of strings ending at current index with all ones.\\nSo, now for each index we will have two options:- Either the character is \\'1\\' or \\'0\\'.\\n\\n**Case 1: When current character is one**\\nAssuming  our current index is \\'i\\' and count of substrings with all ones ending at \\'i\\' = count + 1( plus one for one at \\'i\\'). \\n\\n**Case : When current character is zero**\\nSo, if our character at \\'i\\' is \\'0\\' then all the substrings ending at this index would contain zero. And so we cannot add this character to our substrings. And hence because substrings need to be contiguous we can say now we have zero substrings with all one and so we will change the count to 0.\\n\\nFor the final answer at each position we will add the count of substrings ending at the current position to the ans.\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(1)**\\n\\n\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int ans = 0;\\n        int ones = 0;\\n        int MOD = 1000000007;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') ones = 0;\\n            else ones += 1;\\n            ans = (ans + ones) % MOD;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int ans = 0;\\n        int ones = 0;\\n        int MOD = 1000000007;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') ones = 0;\\n            else ones += 1;\\n            ans = (ans + ones) % MOD;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155014,
                "title": "java-clean-solution",
                "content": "**This solution is not mine but i found this solution very interesting as it is beginner friendly**\\n*Solution by : Nidhi_2125*\\n*The Idea is very simple you can count the number of ones and keep on checking the segment of one\\'s (arr[i]==arr[i+1] ) if it is equal you can add this substring into your original substring count*\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n      int count=0;\\n      \\n      char arr[]=s.toCharArray();\\n      int n=arr.length;\\n      for(int i=0;i<n;i++){\\n        if(arr[i]==\\'1\\') count++;\\n      }\\n      int substring=0;\\n      int mod=1000000007;\\n      for(int i=0;i<n-1;i++){\\n        if(arr[i]==\\'1\\' && arr[i]==arr[i+1]){\\n          substring++;\\n        }\\n        else{\\n          substring=0;\\n        }\\n        \\n        count=(count+substring)%mod;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n      int count=0;\\n      \\n      char arr[]=s.toCharArray();\\n      int n=arr.length;\\n      for(int i=0;i<n;i++){\\n        if(arr[i]==\\'1\\') count++;\\n      }\\n      int substring=0;\\n      int mod=1000000007;\\n      for(int i=0;i<n-1;i++){\\n        if(arr[i]==\\'1\\' && arr[i]==arr[i+1]){\\n          substring++;\\n        }\\n        else{\\n          substring=0;\\n        }\\n        \\n        count=(count+substring)%mod;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134272,
                "title": "c-easy-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int cv= 1e9+7;\\n        long long count_ones=0;\\n        long long ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count_ones++;\\n                if(i+1==s.size() || s[i+1]!=\\'1\\')\\n                {\\n                    long long vc=((count_ones)*(count_ones+1))/2;\\n                    ans+=vc;\\n                    count_ones=0;\\n                    continue;\\n                }\\n            }\\n        }\\n        return (ans % cv);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int cv= 1e9+7;\\n        long long count_ones=0;\\n        long long ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count_ones++;\\n                if(i+1==s.size() || s[i+1]!=\\'1\\')\\n                {\\n                    long long vc=((count_ones)*(count_ones+1))/2;\\n                    ans+=vc;\\n                    count_ones=0;\\n                    continue;\\n                }\\n            }\\n        }\\n        return (ans % cv);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116253,
                "title": "easiest-c-solution-4-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int m=1000000007;\\n    int numSub(string s,long long ans=0,long long c=0) {\\n        for(int i=0; i<s.size(); i++) {\\n             s[i]==\\'0\\'?ans+=((c*(c+1))/2)%m:c++; // add sum of length of substring in ans => (n*(n+1))/2\\n             c=s[i]==\\'0\\'?0:c;  // if a 0 occurs just set the substring \\'c\\' var to 0 \\n        }\\n        ans+=((c*(c+1))/2)%m; // for the suffix,if \\'0\\' is not present the last substring is not calculated , ...111 in for loop\\n        return (int) ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m=1000000007;\\n    int numSub(string s,long long ans=0,long long c=0) {\\n        for(int i=0; i<s.size(); i++) {\\n             s[i]==\\'0\\'?ans+=((c*(c+1))/2)%m:c++; // add sum of length of substring in ans => (n*(n+1))/2\\n             c=s[i]==\\'0\\'?0:c;  // if a 0 occurs just set the substring \\'c\\' var to 0 \\n        }\\n        ans+=((c*(c+1))/2)%m; // for the suffix,if \\'0\\' is not present the last substring is not calculated , ...111 in for loop\\n        return (int) ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074140,
                "title": "c-really-hate-the-extreme-test-samples",
                "content": "with 1 \\'1\\'  we got 1 substring\\nwith 2 \\'1\\'  we got 3 (2 + 1)\\nwith 3 \\'1\\'  we got 6 (3+ 2 + 1)\\n...\\nwith n \\'1\\' we got  n*(n+1)/2\\n```\\n    int numSub(string s) {\\n        long cnt = 0;       \\n        for(int i=0; i<s.size(); i++){\\n            long c1 = 0;\\n            while(s[i] == \\'1\\'){\\n                ++c1;\\n                ++i;\\n            }\\n            cnt += c1*(c1+1)/2;    \\n        }        \\n        return cnt%1000000007;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numSub(string s) {\\n        long cnt = 0;       \\n        for(int i=0; i<s.size(); i++){\\n            long c1 = 0;\\n            while(s[i] == \\'1\\'){\\n                ++c1;\\n                ++i;\\n            }\\n            cnt += c1*(c1+1)/2;    \\n        }        \\n        return cnt%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008052,
                "title": "python-o-n-time-o-1-space-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res=0\\n        count=0\\n        for ch in s:\\n            if ch == \\'1\\':\\n                count+=1\\n                res+=count\\n            else:\\n                count=0\\n        \\n        return res % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res=0\\n        count=0\\n        for ch in s:\\n            if ch == \\'1\\':\\n                count+=1\\n                res+=count\\n            else:\\n                count=0\\n        \\n        return res % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998353,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public int numSub(String s) {\\n        long count = 0;\\n\\n        long result = 0;\\n        for(int i = 0; i< s.length() ; i++ ){\\n\\n            if(s.charAt(i) == \\'1\\'){\\n                count++;\\n            }\\n\\n            if(s.charAt(i) == \\'0\\' || i == s.length()-1){\\n                    result = result+find_num(count);\\n                    count = 0;\\n            }\\n\\n\\n\\n\\n        }\\n       int  result1 = (int)(result % ((int)Math.pow(10,9) + 7));\\n        return result1;\\n    }\\n\\n    public long find_num( long n){\\n        if(n == 0){\\n            return 0;\\n        }\\n        long val = 0;\\n        for(int i=1; i<=n ;i++){\\n            val = val + i;\\n        }\\n        return val;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSub(String s) {\\n        long count = 0;\\n\\n        long result = 0;\\n        for(int i = 0; i< s.length() ; i++ ){\\n\\n            if(s.charAt(i) == \\'1\\'){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 937689,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return sum(map(lambda i:(len(i)*(len(i)+1))//2,re.findall(\"[1]+\",s)))%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return sum(map(lambda i:(len(i)*(len(i)+1))//2,re.findall(\"[1]+\",s)))%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898862,
                "title": "cpp-8ms-reason-for-using-mod",
                "content": "**%(mod) 1000000007** is used because it prevents overflow and enables the problem setter to frame his problem for bigger ranges and hence demand a clever algorithm.\\n\\n```\\nclass Solution {\\npublic:\\n    long numSub(string s) {\\n        long i=0,temp = 0,total=0;\\n        while (i<s.length()){\\n            if (s[i]==\\'1\\'){\\n                temp = 0;\\n                while (s[i]==\\'1\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                total += (temp*(temp+1))/2;\\n            }\\n            i++;\\n        }\\n        return total%1000000007; // to prevent overflow\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long numSub(string s) {\\n        long i=0,temp = 0,total=0;\\n        while (i<s.length()){\\n            if (s[i]==\\'1\\'){\\n                temp = 0;\\n                while (s[i]==\\'1\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                total += (temp*(temp+1))/2;\\n            }\\n            i++;\\n        }\\n        return total%1000000007; // to prevent overflow\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862476,
                "title": "easy-peasy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++)\\n        {   long c=0;\\n            while(s[i]==\\'1\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            ans += c*(c+1)/2;\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++)\\n        {   long c=0;\\n            while(s[i]==\\'1\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            ans += c*(c+1)/2;\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776732,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0;\\n        String [] ones = s.split(\"0\");\\n        \\n        for(String one : ones){\\n            int n = one.length();\\n            count += (n * (n + 1.0) / 2) % 1000_000_007;\\n        }\\n      return count;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0;\\n        String [] ones = s.split(\"0\");\\n        \\n        for(String one : ones){\\n            int n = one.length();\\n            count += (n * (n + 1.0) / 2) % 1000_000_007;\\n        }\\n      return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760487,
                "title": "cpp-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long m=pow(10,9)+7;\\n    int numSub(string s) {\\n        long long i=0,j=0;\\n        int c=0;\\n        while(j<s.length()&&i<s.length()){\\n            while(i<s.length()&&s[i]==\\'0\\')\\n                i++;\\n            j=i;\\n            while(j<s.length()&&s[j]==\\'1\\')\\n                j++;\\n            c+=((j-i)*(j-i+1))%m/2;\\n            c%=m;\\n            i=j;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long m=pow(10,9)+7;\\n    int numSub(string s) {\\n        long long i=0,j=0;\\n        int c=0;\\n        while(j<s.length()&&i<s.length()){\\n            while(i<s.length()&&s[i]==\\'0\\')\\n                i++;\\n            j=i;\\n            while(j<s.length()&&s[j]==\\'1\\')\\n                j++;\\n            c+=((j-i)*(j-i+1))%m/2;\\n            c%=m;\\n            i=j;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760020,
                "title": "8ms-faster-than-80-submissions",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0;\\n        String[] ones = s.split(\"0\");\\n        for(String one : ones){\\n            int len = one.length();\\n            if(len >= 1)\\n                count += (len*(len+1.0)/2) % 1000000007;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0;\\n        String[] ones = s.split(\"0\");\\n        for(String one : ones){\\n            int len = one.length();\\n            if(len >= 1)\\n                count += (len*(len+1.0)/2) % 1000000007;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746651,
                "title": "easy-counting-python",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, MOD = 0, 10 ** 9 + 7\\n        for string in s.split(\\'0\\'):\\n            if string:\\n                num = len(string)\\n                res += (1 + num) * num // 2\\n        return res % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, MOD = 0, 10 ** 9 + 7\\n        for string in s.split(\\'0\\'):\\n            if string:\\n                num = len(string)\\n                res += (1 + num) * num // 2\\n        return res % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741782,
                "title": "python-o-n-by-sliding-window-w-comment",
                "content": "Python O(n) sol by sliding window\\n\\n---\\n\\n**Implementation**\\n\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n        # padding one dummy zero as ending symbol\\n        s = s + \\'0\\'\\n        \\n        idx, first_1_idx, last_1_idx = 0, None, None\\n        prev = None\\n        size = len(s)\\n        \\n        counter = 0\\n        \\n        while idx < size:\\n            \\n            if s[idx] == \\'1\\':\\n                if first_1_idx is None:\\n                    # head index of 1s\\n                    first_1_idx = idx\\n                    \\n            else:\\n                if prev == \\'1\\':\\n                    # tail index of 1s\\n                    last_1_idx = idx - 1\\n                    \\n                    # length of current contiguous 1s\\n                    len_of_1 = last_1_idx - first_1_idx + 1\\n                    \\n                    # update count of substrings with 1s\\n                    counter += len_of_1 * ( len_of_1 + 1 ) // 2 \\n                    \\n                    # clear index for new capture of 1s\\n                    first_1_idx, last_1_idx = None, None\\n                    \\n            prev = s[idx]\\n            idx = idx + 1\\n            \\n        return counter % (10**9 + 7)\\n```\\n\\n---\\n\\nShare another solution with counter of contiguous 1s\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n\\t\\t# record of previous digit\\n        prev = 0\\n        \\n        number_of_substrings_of_1 = 0\\n        \\n\\t\\t# linear scan\\n        for char in s:\\n            \\n\\t\\t\\t# type conversion to integer\\n            cur_num = int(char)\\n            \\n            if cur_num:\\n\\t\\t\\t\\t# current digit is 1\\n                \\n                cur_num = prev + 1\\n                \\n\\t\\t\\t\\t# add counter\\n                number_of_substrings_of_1 += cur_num\\n                    \\n            prev = cur_num\\n            \\n        return number_of_substrings_of_1 % (10**9 + 7)\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n        # padding one dummy zero as ending symbol\\n        s = s + \\'0\\'\\n        \\n        idx, first_1_idx, last_1_idx = 0, None, None\\n        prev = None\\n        size = len(s)\\n        \\n        counter = 0\\n        \\n        while idx < size:\\n            \\n            if s[idx] == \\'1\\':\\n                if first_1_idx is None:\\n                    # head index of 1s\\n                    first_1_idx = idx\\n                    \\n            else:\\n                if prev == \\'1\\':\\n                    # tail index of 1s\\n                    last_1_idx = idx - 1\\n                    \\n                    # length of current contiguous 1s\\n                    len_of_1 = last_1_idx - first_1_idx + 1\\n                    \\n                    # update count of substrings with 1s\\n                    counter += len_of_1 * ( len_of_1 + 1 ) // 2 \\n                    \\n                    # clear index for new capture of 1s\\n                    first_1_idx, last_1_idx = None, None\\n                    \\n            prev = s[idx]\\n            idx = idx + 1\\n            \\n        return counter % (10**9 + 7)\\n```\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n\\t\\t# record of previous digit\\n        prev = 0\\n        \\n        number_of_substrings_of_1 = 0\\n        \\n\\t\\t# linear scan\\n        for char in s:\\n            \\n\\t\\t\\t# type conversion to integer\\n            cur_num = int(char)\\n            \\n            if cur_num:\\n\\t\\t\\t\\t# current digit is 1\\n                \\n                cur_num = prev + 1\\n                \\n\\t\\t\\t\\t# add counter\\n                number_of_substrings_of_1 += cur_num\\n                    \\n            prev = cur_num\\n            \\n        return number_of_substrings_of_1 % (10**9 + 7)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 738726,
                "title": "c-one-liner",
                "content": "```\\npublic int NumSub(string s) =>\\n\\t(int)(s.Split(\\'0\\')\\n\\t\\t.Select(x => (long)x.Length * (x.Length + 1) / 2)\\n\\t\\t.Sum() % (1_000_000_000 + 7));\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumSub(string s) =>\\n\\t(int)(s.Split(\\'0\\')\\n\\t\\t.Select(x => (long)x.Length * (x.Length + 1) / 2)\\n\\t\\t.Sum() % (1_000_000_000 + 7));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736191,
                "title": "c-simple-o-n-dp-solution",
                "content": "DP[i]=for every \\'1\\' encountered at **ith position, the number of substrings that can be formed will be equal to the number of substrings formed at (i-1)th position +1.** \\nAt last , the total number of substrings can be found by adding all the values of DP array.\\nPS:- I know , this problem can be done without dp approach, but still its better to visualize a problem thorugh it apart from n*(n+1)/2 method.. (pls upvote if you agree) :)\\n```\\nint numSub(string s) {\\n        long i=0,j=0,n=s.length();\\n        long dp[n];\\n        dp[0]=(s[0]==\\'0\\')?0:1;\\n        \\n        int sum=dp[0];\\n        for(long i=1;i<n;i++){\\n            if(s[i]==\\'1\\')\\n                dp[i]=1+dp[i-1];\\n            else\\n                dp[i]=0;\\n            \\n            sum=(sum+dp[i])%1000000007;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint numSub(string s) {\\n        long i=0,j=0,n=s.length();\\n        long dp[n];\\n        dp[0]=(s[0]==\\'0\\')?0:1;\\n        \\n        int sum=dp[0];\\n        for(long i=1;i<n;i++){\\n            if(s[i]==\\'1\\')\\n                dp[i]=1+dp[i-1];\\n            else\\n                dp[i]=0;\\n            \\n            sum=(sum+dp[i])%1000000007;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734710,
                "title": "python-head-on-explained-with-some-tips",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        d,l = defaultdict(int),0\\n        for i,v in enumerate(s):\\n            if v==\\'1\\':\\n                l+=1\\n            else:\\n                d[l]+=1\\n                l=0\\n        d[l]+=1\\n\\n        return sum( v*((k+1)*k//2) for k,v in d.items() ) % (10**9 + 7)\\n```\\n\\nSo this is the most head-on approach. First, we count number of sequences of `1` for each length.\\n\\nThe dictionary `d` will look like: `length`:`number of occurencies`, `l` is the current lenght of `1`s. Basically if we see `1` - we increament `l` and when we see `0` - we updated our dictionary and reset the counter `l`.\\n\\n```\\n        for i,v in enumerate(s):\\n            if v==\\'1\\':\\n                l+=1\\n            else:\\n                d[l]+=1\\n                l=0\\n```\\n\\nUsing `defaultdict(int)` makes our life easier because we don\\'t need to worry about creating the first entry for a sequence of a particular lenght.\\n\\nThat `for` loop works great if we have a `0` after each seq of `1`s, but if `s` ends with a `1`, we need to add an extra line to handle that case:\\n\\n```\\n        d[l]+=1\\n```\\n\\nOk, now we know the number of sequences and we know that each sequence of lenght `v` will contribute `(k+1)*k//2)` to the end result. We just need to take care of a couple things:\\n\\n1. `sum( v*((k+1)*k//2) for k,v in d.items() )` - the `v*` part simply says multiply by number of sequences.\\n2. in Python the lenght of int is virtually unlimited, so we can apply ` % (10**9 + 7)` only ones to the final result. In other languages with limited int size, we might want to do it along the way.\\n\\nOne more thing. In this approach if we see something like `000` - we\\'ll be incrementing d[0]. Technically this is not needed since those zero lenght sequences will be ignored in the end. So we can add and extra `if` to make sure that we only count non-zero sequences. However, running tests shows that that extra `if` would make it run slower, so it\\'s not needed after all.\\n\\nThat\\'s it!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        d,l = defaultdict(int),0\\n        for i,v in enumerate(s):\\n            if v==\\'1\\':\\n                l+=1\\n            else:\\n                d[l]+=1\\n                l=0\\n        d[l]+=1\\n\\n        return sum( v*((k+1)*k//2) for k,v in d.items() ) % (10**9 + 7)\\n```\n```\\n        for i,v in enumerate(s):\\n            if v==\\'1\\':\\n                l+=1\\n            else:\\n                d[l]+=1\\n                l=0\\n```\n```\\n        d[l]+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734585,
                "title": "c-sliding-window",
                "content": "```\\nint numSub(string s) {\\n\\tint res = 0;\\n\\tlong long curOnes = 0;\\n\\tint mod = 1000000007;\\n\\tfor (char c : s) {\\n\\t\\tif (c == \\'1\\')\\n\\t\\t\\tcurOnes++;\\n\\t\\telse {\\n\\t\\t\\tres += (curOnes * (curOnes + 1) / 2) % mod;\\n\\t\\t\\tcurOnes = 0;\\n\\t\\t}\\n\\t}\\n\\tif (curOnes)\\n\\t\\tres += (curOnes * (curOnes + 1) / 2) % mod;\\n\\treturn res;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint numSub(string s) {\\n\\tint res = 0;\\n\\tlong long curOnes = 0;\\n\\tint mod = 1000000007;\\n\\tfor (char c : s) {\\n\\t\\tif (c == \\'1\\')\\n\\t\\t\\tcurOnes++;\\n\\t\\telse {\\n\\t\\t\\tres += (curOnes * (curOnes + 1) / 2) % mod;\\n\\t\\t\\tcurOnes = 0;\\n\\t\\t}\\n\\t}\\n\\tif (curOnes)\\n\\t\\tres += (curOnes * (curOnes + 1) / 2) % mod;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733710,
                "title": "c-o-n-simple-solution-40ms-time",
                "content": "```\\n int mod=1e9+7;\\n    int numSub(string s) {\\n        vector<long>ans;\\n        long count=0,sum=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch =s[i];\\n            count=0;\\n            if(ch==\\'1\\')\\n            {\\n                count++;\\n                i++;\\n                while(s[i] != \\'0\\' && i<s.length())\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                ans.push_back(count);\\n            }\\n        }\\n        for(long &ele: ans)\\n        {\\n            sum+=(((ele + 1) * ele/2))%mod;\\n        }\\n        return sum%mod;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n int mod=1e9+7;\\n    int numSub(string s) {\\n        vector<long>ans;\\n        long count=0,sum=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch =s[i];\\n            count=0;\\n            if(ch==\\'1\\')\\n            {\\n                count++;\\n                i++;\\n                while(s[i] != \\'0\\' && i<s.length())\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                ans.push_back(count);\\n            }\\n        }\\n        for(long &ele: ans)\\n        {\\n            sum+=(((ele + 1) * ele/2))%mod;\\n        }\\n        return sum%mod;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733563,
                "title": "c-with-some-math",
                "content": "```\\nlong res=0, n=0, len=s.length();\\n        for(int i=0; i<len; i++){\\n            if(s[i]==\\'1\\'){ \\n                n++;\\n                if(i==len-1 || s[i+1]==\\'0\\'){\\n                    res+=n*(n+1)/2;\\n                    n=0;\\n                }\\n            }\\n        }\\n        return res % 1000000007;\\n```",
                "solutionTags": [],
                "code": "```\\nlong res=0, n=0, len=s.length();\\n        for(int i=0; i<len; i++){\\n            if(s[i]==\\'1\\'){ \\n                n++;\\n                if(i==len-1 || s[i+1]==\\'0\\'){\\n                    res+=n*(n+1)/2;\\n                    n=0;\\n                }\\n            }\\n        }\\n        return res % 1000000007;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733052,
                "title": "python-sliding-window",
                "content": "```python\\ndef numSub(self, s: str) -> int:\\n        start = 0\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \"0\": start=i+1\\n            else: result += i-start+1 \\n        return result%(10**9+7)\\n\\n```",
                "solutionTags": [],
                "code": "```python\\ndef numSub(self, s: str) -> int:\\n        start = 0\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \"0\": start=i+1\\n            else: result += i-start+1 \\n        return result%(10**9+7)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 732779,
                "title": "java-dp-o-n-100",
                "content": "```\\nclass Solution {\\n    final int  MOD=1000000007;\\n    public int numSub(String s) {\\n      if(s==null || s.length()==0) return 0;\\n      int n = s.length();\\n      int[] dp = new int[n];\\n      dp[0] = Integer.parseInt(String.valueOf(s.charAt(0)));\\n      for(int i=1; i<n; i++){\\n          if(s.charAt(i)==\\'1\\'){\\n              dp[i] = dp[i-1] + 1;\\n          }else{\\n              dp[i] = 0;\\n          }\\n       }\\n       int res = 0;                         \\n      for(int i=0; i<n; i++){\\n          res = (res+dp[i])%MOD;\\n      }\\n      return res;                         \\n    }                 \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    final int  MOD=1000000007;\\n    public int numSub(String s) {\\n      if(s==null || s.length()==0) return 0;\\n      int n = s.length();\\n      int[] dp = new int[n];\\n      dp[0] = Integer.parseInt(String.valueOf(s.charAt(0)));\\n      for(int i=1; i<n; i++){\\n          if(s.charAt(i)==\\'1\\'){\\n              dp[i] = dp[i-1] + 1;\\n          }else{\\n              dp[i] = 0;\\n          }\\n       }\\n       int res = 0;                         \\n      for(int i=0; i<n; i++){\\n          res = (res+dp[i])%MOD;\\n      }\\n      return res;                         \\n    }                 \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732418,
                "title": "c-code-simple-one-loop",
                "content": "```\\n\\n\\nint numSub(char * s){\\n    size_t res=0;\\n    size_t k=0;\\n    for(size_t i=0;s[i];i++){\\n        if(s[i]==\\'1\\'){\\n            k++;\\n            res+=k;\\n        }\\n        else{\\n            k=0;\\n        }\\n    }\\n    return res%((size_t)(pow(10,9)+7));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nint numSub(char * s){\\n    size_t res=0;\\n    size_t k=0;\\n    for(size_t i=0;s[i];i++){\\n        if(s[i]==\\'1\\'){\\n            k++;\\n            res+=k;\\n        }\\n        else{\\n            k=0;\\n        }\\n    }\\n    return res%((size_t)(pow(10,9)+7));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732191,
                "title": "simple-c-with-left-and-right-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        int len=s.length();\\n        int left=-1,right=0,total=0;\\n        while(right<len)\\n        {\\n            if(s[right]==\\'0\\')\\n                left=right;\\n            else\\n            {\\n                total+=(right-left);\\n                total%=1000000000+7;\\n            }\\n            right=right+1;\\n        }\\n        return total%(1000000000+7);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        int len=s.length();\\n        int left=-1,right=0,total=0;\\n        while(right<len)\\n        {\\n            if(s[right]==\\'0\\')\\n                left=right;\\n            else\\n            {\\n                total+=(right-left);\\n                total%=1000000000+7;\\n            }\\n            right=right+1;\\n        }\\n        return total%(1000000000+7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732008,
                "title": "wrong-answer-not-able-to-figure-out-why-8000x8001",
                "content": "Hello Community,\\n\\nI understand the approach here I am taking is not the most optimized but I am not able to understand why this program is giving wrong answer for one of the input. On debugging the program for input which has  has continuous count of 1 as 8000, the number of substring I am getting is 1052556352 instead of 32004000 (I am using sum of natural number approach). I have added my submitted snippet which gave me wrong answer. \\n\\nOn debugging more I found that somehow program is giving wrong answer for (8000*8001). Not able to understan why. But since it involves very basic misunderstanding from my side  help me out.\\n\\nThank you for the help.\\n\\n\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int result = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s.charAt(i) == \\'0\\'){\\n                i++;\\n            }else{\\n                // find count of continious one\\n                int count = 1;\\n                for(int j = i+1; j < s.length(); j++){\\n                    if(s.charAt(j) != \\'1\\'){\\n                        break;\\n                    }\\n                    count++;\\n                }\\n                int numSubstring = (count * (count+1))/2;\\n                System.out.println(\"i:\"+i+\",numSubstring:\"+numSubstring+\",count:\"+count); // added for debug purpose\\n                result += numSubstring;\\n                result = result % 1000000007;\\n                i += count;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int result = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s.charAt(i) == \\'0\\'){\\n                i++;\\n            }else{\\n                // find count of continious one\\n                int count = 1;\\n                for(int j = i+1; j < s.length(); j++){\\n                    if(s.charAt(j) != \\'1\\'){\\n                        break;\\n                    }\\n                    count++;\\n                }\\n                int numSubstring = (count * (count+1))/2;\\n                System.out.println(\"i:\"+i+\",numSubstring:\"+numSubstring+\",count:\"+count); // added for debug purpose\\n                result += numSubstring;\\n                result = result % 1000000007;\\n                i += count;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731997,
                "title": "simple-c-solution-using-memorization",
                "content": "class Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        long long f=s[0]-\\'0\\';\\n        \\n        long long mod=1000000007;\\n        \\n        long long prev=s[0]-\\'0\\';\\n        \\n        for(int i=1;i<s.length();i++){\\n            \\n            if((s[i]-\\'0\\')==1)\\n            {\\n                if(s[i-1]-\\'0\\'==1)\\n                {\\n                    prev=prev+1;\\n                    \\n                }\\n                \\n                else\\n                    prev=1;\\n                \\n            }\\n            \\n            else\\n            {\\n                prev=0;\\n            }\\n            \\n            \\n            \\n            f=(f%mod+(prev)%mod)%mod;\\n        \\n        }\\n        \\n        \\n        \\n        return f%mod;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        long long f=s[0]-\\'0\\';\\n        \\n        long long mod=1000000007;\\n        \\n        long long prev=s[0]-\\'0\\';\\n        \\n        for(int i=1;i<s.length();i++){\\n            \\n            if((s[i]-\\'0\\')==1)\\n            {\\n                if(s[i-1]-\\'0\\'==1)\\n                {\\n                    prev=prev+1;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 731947,
                "title": "c-step-by-step-explanation-o-n",
                "content": "Find length of each substring containing only 1\\'s.\\nOnce we find a substring of length l with only 1\\'s no. of substrings possible is given by l*(l+1)/2 (sum of numbers from 1 to l)\\nExample - 110111\\nThere are two substrings containing only 1\\'s..i.e., 11 of length 2 and 111 of length 3\\nFor 1st substring \"11\" -\\nNo. of substring which Contain \\'1\\' is - 2\\nNo. of substring which Contain \\'11\\' is - 1\\n\\nTotal No. of substring =2+1 = 2*(2+1)/2 = 3\\n\\nFor 1st substring \"111\" -\\nNo. of substring which Contain \\'1\\' is - 3\\nNo. of substring which Contain \\'11\\' is - 2\\nNo. of substring which Contain \\'111\\' is - 1\\n\\nTotal No. of substring =3+2+1 = 2=3*(3+1)/2 = 6\\n\\nSo. total no. of substrings aren 3+6 = 9\\n\\n```\\nclass Solution {\\npublic:\\n    long long int total(int n){\\n        long long int res=0;\\n        for(int i=1;i<=n;i++){\\n            res+=i;\\n        }\\n        return res;\\n    }\\n    int numSub(string s) {\\n        long long int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            int l =0;\\n            if(s[i]==\\'1\\'){\\n                l++;\\n                while(i+1<s.length() && s[i+1]!=\\'0\\'){\\n                    l++;\\n                    i++;\\n                }\\n            }\\n            ans+=total(l);\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int total(int n){\\n        long long int res=0;\\n        for(int i=1;i<=n;i++){\\n            res+=i;\\n        }\\n        return res;\\n    }\\n    int numSub(string s) {\\n        long long int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            int l =0;\\n            if(s[i]==\\'1\\'){\\n                l++;\\n                while(i+1<s.length() && s[i+1]!=\\'0\\'){\\n                    l++;\\n                    i++;\\n                }\\n            }\\n            ans+=total(l);\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731859,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        int n = s.length();\\n        int ans  = 0, c = 0;\\n        int MOD = 1000000007;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'1\\')\\n                c++;\\n            else\\n                c = 0;\\n            ans = (ans + c)%MOD;\\n        }\\n        \\n        return ans%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        \\n        int n = s.length();\\n        int ans  = 0, c = 0;\\n        int MOD = 1000000007;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'1\\')\\n                c++;\\n            else\\n                c = 0;\\n            ans = (ans + c)%MOD;\\n        }\\n        \\n        return ans%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731822,
                "title": "python-easy-solution-o-n",
                "content": "Approach 1:\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, curr = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                curr += 1\\n            else:\\n                res += (curr * (curr + 1))//2\\n                curr = 0\\n        if curr > 0:\\n            res += (curr * (curr + 1))//2\\n        return res % 1000000007\\n```\\n\\nApproach 2:\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, curr = 0, 0\\n        for i in range(len(s)):\\n            curr = curr + 1 if s[i] == \\'1\\' else 0\\n            res += curr\\n        return res % 1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, curr = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                curr += 1\\n            else:\\n                res += (curr * (curr + 1))//2\\n                curr = 0\\n        if curr > 0:\\n            res += (curr * (curr + 1))//2\\n        return res % 1000000007\\n```\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        res, curr = 0, 0\\n        for i in range(len(s)):\\n            curr = curr + 1 if s[i] == \\'1\\' else 0\\n            res += curr\\n        return res % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731814,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int NumSub(string s) \\n    {\\n        long prev = -1, result = 0, n = s.Length;;\\n        for(int i = 0; i <= n; i++)\\n            if(i == n || s[i] == \\'0\\')\\n            {\\n                long len = (i - prev - 1);\\n                result += (len * (len + 1)) / 2;\\n                result = result % 1_000_000_007;\\n                prev = i;\\n            }\\n        \\n        return (int) result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int NumSub(string s) \\n    {\\n        long prev = -1, result = 0, n = s.Length;;\\n        for(int i = 0; i <= n; i++)\\n            if(i == n || s[i] == \\'0\\')\\n            {\\n                long len = (i - prev - 1);\\n                result += (len * (len + 1)) / 2;\\n                result = result % 1_000_000_007;\\n                prev = i;\\n            }\\n        \\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731811,
                "title": "python-o-n-simple-math-too-easy-i-don-t-like-this-question",
                "content": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        l = len(s)\\n        arr = 0\\n        flag=0\\n        for i in range(l):\\n            if s[i]==\\'1\\':\\n                flag+=1\\n            else:\\n                arr+=flag*(flag+1)//2\\n                flag=0\\n        arr+=flag*(flag+1)//2\\n        return arr % (10**9 + 7)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        l = len(s)\\n        arr = 0\\n        flag=0\\n        for i in range(l):\\n            if s[i]==\\'1\\':\\n                flag+=1\\n            else:\\n                arr+=flag*(flag+1)//2\\n                flag=0\\n        arr+=flag*(flag+1)//2\\n        return arr % (10**9 + 7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 731773,
                "title": "swift",
                "content": "```\\nfunc numSub(_ s: String) -> Int {\\n\\tif s.length == 0 { return 0 }\\n\\tvar currentIndex = 0\\n\\tvar currentLength = 0\\n\\tvar result = 0\\n\\tlet sArray = Array(s)\\n\\tlet modulus = Int(pow(Double(10), Double(9)) + 7)\\n\\twhile currentIndex < sArray.count {\\n\\t\\tlet char = sArray[currentIndex]\\n\\t\\tif char == \"1\" {\\n\\t\\t\\tcurrentLength += 1\\n\\t\\t} else if currentLength > 0 {\\n\\t\\t\\tresult += ((currentLength * (currentLength + 1)) / 2) % modulus\\n\\t\\t\\tcurrentLength = 0\\n\\t\\t}\\n\\t\\tcurrentIndex += 1\\n\\t}\\n\\n\\tif currentLength > 0 {\\n\\t\\tresult += (currentLength * (currentLength + 1)) / 2\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numSub(_ s: String) -> Int {\\n\\tif s.length == 0 { return 0 }\\n\\tvar currentIndex = 0\\n\\tvar currentLength = 0\\n\\tvar result = 0\\n\\tlet sArray = Array(s)\\n\\tlet modulus = Int(pow(Double(10), Double(9)) + 7)\\n\\twhile currentIndex < sArray.count {\\n\\t\\tlet char = sArray[currentIndex]\\n\\t\\tif char == \"1\" {\\n\\t\\t\\tcurrentLength += 1\\n\\t\\t} else if currentLength > 0 {\\n\\t\\t\\tresult += ((currentLength * (currentLength + 1)) / 2) % modulus\\n\\t\\t\\tcurrentLength = 0\\n\\t\\t}\\n\\t\\tcurrentIndex += 1\\n\\t}\\n\\n\\tif currentLength > 0 {\\n\\t\\tresult += (currentLength * (currentLength + 1)) / 2\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731772,
                "title": "easy-java-o-n",
                "content": "\\tpublic int numSub(String s) {\\n            long count = 0;\\n        long local = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                local++;\\n            }else{\\n                long cal = local*(local + 1)/2; \\n                count = count + cal;\\n                //count = count;\\n                local = 0;\\n            }\\n        }\\n        long cal = local*(local + 1)/2;\\n                count = count + cal;\\n\\n        count = count%1000000007;\\n\\n        return (int)count;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int numSub(String s) {\\n            long count = 0;\\n        long local = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                local++;\\n            }else{\\n                long cal = local*(local + 1)/2; \\n                count = count + cal;\\n                //count = count;\\n                local = 0;\\n            }\\n        }\\n        long cal = local*(local + 1)/2;\\n                count = count + cal;\\n\\n        count = count%1000000007;\\n\\n        return (int)count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 731680,
                "title": "python-3-number-of-substring-with-only-1s-easy",
                "content": "**Solution is slow but one of the ways to solve the problem**\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n        res=0\\n        one_rt = 0\\n        \\n        for c in s:\\n            if c == \\'0\\':\\n                one_rt=0\\n            else:\\n                one_rt+=1\\n                res+=one_rt\\n                \\n        return res % 1000000007",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "**Solution is slow but one of the ways to solve the problem**\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        \\n        res=0\\n        one_rt = 0\\n        \\n        for c in s:\\n            if c == \\'0\\':\\n                one_rt=0\\n            else:\\n                one_rt+=1\\n                res+=one_rt\\n                \\n        return res % 1000000007",
                "codeTag": "Java"
            },
            {
                "id": 731654,
                "title": "c-use-previous-calculated-value-if-there-are-consecutive-1s",
                "content": "Example: If we have 1111\\nthen first time we calculate at index 0 we have string of length 1 + 2 + 3 + 4 , total 4\\nthen for index 1 we have strings of lengths 1 + 2 + 3 , total 3\\nthen total 2 and 1\\nThus if we have consecutive 1s then total number of substrings = one at previous index - 1, so we only need to calculate substrings if previous char is 0 and current char is 1.\\n\\n```csharp\\npublic int NumSub(string s)\\n{\\n\\tint MOD = (int)(1E9) + 7;\\n\\tlong count = 0;\\n\\tlong currentCount = 0;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tif (s[i] == \\'1\\')\\n\\t\\t{\\n\\t\\t\\tif (i > 0 && s[i - 1] == \\'1\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentCount--;\\n\\t\\t\\t\\tcount += currentCount;\\n\\t\\t\\t\\tif (count > MOD)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount -= MOD;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = i; j < s.Length && s[j] == \\'1\\'; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentCount++;\\n\\t\\t\\t\\tif (currentCount > MOD)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrentCount -= MOD;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcount += currentCount;\\n\\t\\t\\tif (count > MOD)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrentCount = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int)count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumSub(string s)\\n{\\n\\tint MOD = (int)(1E9) + 7;\\n\\tlong count = 0;\\n\\tlong currentCount = 0;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tif (s[i] == \\'1\\')\\n\\t\\t{\\n\\t\\t\\tif (i > 0 && s[i - 1] == \\'1\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentCount--;\\n\\t\\t\\t\\tcount += currentCount;\\n\\t\\t\\t\\tif (count > MOD)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount -= MOD;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = i; j < s.Length && s[j] == \\'1\\'; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentCount++;\\n\\t\\t\\t\\tif (currentCount > MOD)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrentCount -= MOD;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcount += currentCount;\\n\\t\\t\\tif (count > MOD)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrentCount = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int)count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731641,
                "title": "python-python3-number-of-substrings-with-only-1-s",
                "content": "![image](https://assets.leetcode.com/users/images/04d8842c-66d2-4fb1-97aa-182a43e50d85_1594526517.0796642.png)\\n\\nThis whole problem can be boiled down to finding the consecutive 1\\'s in the string. We need to first find the consecutive 1\\'s in the string. After we do that as shown in the figure, as we keep increase the length of substring in a string of consecutive 1\\'s, we keep getting less number of counts. As the length of substring increases by 1, the count decreaes by 1. This forms an AP and we can use the formula of counting sum of n consecutive numbers where here n would be the length of consecutive 1\\'s we find in the string.\\n\\ni. Using Split\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        j = s.split(\\'0\\')\\n        total = []\\n        for x in j:\\n            if x:\\n                k = len(x)\\n                total.append(((k)*(k+1))//2)\\n\\n        return sum(total)%(10**9+7)\\n```\\n\\nii Sliding Window\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        i, j, total, count_one = 0, 0, 0, 0\\n        \\n        while j < len(s):\\n            if s[j] == \\'1\\':\\n                count_one += 1\\n            elif count_one:\\n                i = j\\n                total += (((count_one)*(count_one+1))//2)\\n                count_one = 0\\n            \\n            j += 1\\n        \\n        total += (((count_one)*(count_one+1))//2)\\n        \\n        return total%(10**9+7)\\n```\\nTime complexity:  ```O(n)```\\nSpace Complexity: ```O(n)```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        j = s.split(\\'0\\')\\n        total = []\\n        for x in j:\\n            if x:\\n                k = len(x)\\n                total.append(((k)*(k+1))//2)\\n\\n        return sum(total)%(10**9+7)\\n```\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        i, j, total, count_one = 0, 0, 0, 0\\n        \\n        while j < len(s):\\n            if s[j] == \\'1\\':\\n                count_one += 1\\n            elif count_one:\\n                i = j\\n                total += (((count_one)*(count_one+1))//2)\\n                count_one = 0\\n            \\n            j += 1\\n        \\n        total += (((count_one)*(count_one+1))//2)\\n        \\n        return total%(10**9+7)\\n```\n```O(n)```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 731636,
                "title": "using-the-trick-of-math",
                "content": "The basic idea here is, we can find **each longest continous \\'1\\' substring** in the given string and do a math calculation, finally add this math result to the final result to output. \\n\\nFor example, if we have \"111\", all we need to do here is find the length of longest \\'1\\' substring, which is 3 and do (3+1) * 3 / 2 = 6, and 6 is the answer for this \"111\" testcase. \\n\\nMath behind this question: if we have a longest continous \\'1\\' substring with length **n**, we can prove that total number of the \"1\" substring is (n + 1) * n / 2. \\n\\n    public int numSub(String s) {\\n        long res = 0, cnt = 0;\\n        char[] ch = s.toCharArray();\\n        int i = 0;\\n     \\n        while (i < ch.length) {\\n            if (ch[i] == \\'1\\') {\\n                cnt += 1;\\n                i++;\\n            } else {\\n                res += helper(cnt);\\n                cnt = 0;\\n                i++;\\n            }\\n        }\\n        if (cnt != 0) res += helper(cnt);\\n        return (int)(res % (1000000000 + 7));\\n    }\\n    \\n    public long helper(long num) {\\n        if (num == 0) return 0;\\n        return (num + 1) * num / 2;\\n    }",
                "solutionTags": [],
                "code": "The basic idea here is, we can find **each longest continous \\'1\\' substring** in the given string and do a math calculation, finally add this math result to the final result to output. \\n\\nFor example, if we have \"111\", all we need to do here is find the length of longest \\'1\\' substring, which is 3 and do (3+1) * 3 / 2 = 6, and 6 is the answer for this \"111\" testcase. \\n\\nMath behind this question: if we have a longest continous \\'1\\' substring with length **n**, we can prove that total number of the \"1\" substring is (n + 1) * n / 2. \\n\\n    public int numSub(String s) {\\n        long res = 0, cnt = 0;\\n        char[] ch = s.toCharArray();\\n        int i = 0;\\n     \\n        while (i < ch.length) {\\n            if (ch[i] == \\'1\\') {\\n                cnt += 1;\\n                i++;\\n            } else {\\n                res += helper(cnt);\\n                cnt = 0;\\n                i++;\\n            }\\n        }\\n        if (cnt != 0) res += helper(cnt);\\n        return (int)(res % (1000000000 + 7));\\n    }\\n    \\n    public long helper(long num) {\\n        if (num == 0) return 0;\\n        return (num + 1) * num / 2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 731618,
                "title": "java-count-o-n",
                "content": "```\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        long res = 0;\\n        int n = s.length();\\n        int len = 0;\\n        for(int i=0; i<n; i++){\\n            char c = s.charAt(i);\\n            if(c==\\'1\\'){\\n                len++;\\n                res = (res+len)%mod;\\n            }\\n            else{\\n                len = 0;\\n            }\\n        }\\n        return (int)res%mod;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        long res = 0;\\n        int n = s.length();\\n        int len = 0;\\n        for(int i=0; i<n; i++){\\n            char c = s.charAt(i);\\n            if(c==\\'1\\'){\\n                len++;\\n                res = (res+len)%mod;\\n            }\\n            else{\\n                len = 0;\\n            }\\n        }\\n        return (int)res%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731579,
                "title": "c-o-n-naive-to-optimized-version-with-full-explanation",
                "content": "```\\n/*\\n - (0) - 0\\n1 - (1) - 1\\n11- (2) - 3\\n111(3)  - 6\\n1111(4) - 10\\n11111(5) -15\\n111111(6)- 21\\n1111111(7)-28*/\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        //Idea is to calculate the number of substring beforhand for given string size\\n        vector<long long> v;\\n        v.push_back(0);      \\n        long long sum =0;\\n        for(int i=1; i<=s.size(); ++i)\\n        {\\n            sum += i;//as given above, we can calculate by just adding the current number with previous sum\\n            v.push_back(sum);\\n        }\\n      \\n        //Now find the contigious 1\\'s and add them into another array\\n        vector<int> contigiuous;\\n        int cnt =0;\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if( s[i] == \\'1\\')\\n                cnt++;\\n            else\\n            {\\n                if(cnt>0)\\n                    contigiuous.push_back(cnt);\\n                cnt = 0;\\n            }\\n        }\\n        \\n        //for the last substring. If cnt>0, add it\\n        if(cnt>0)\\n           contigiuous.push_back(cnt);\\n        \\n        //Now navigate through the contigiuous array, get the number of possilbe sumbstring and add it in final sum\\n        long long output=0;\\n        for(auto c:contigiuous)\\n            output += v[c];\\n        \\n        return output % 1000000007;\\n    }\\n};\\n```\\n\\n//Optimized version. \\n//TC-O(N) and SC-O(1)\\n```\\n/*\\n - (0) - 0\\n1 - (1) - 1\\n11- (2) - 3\\n111(3)  - 6\\n1111(4) - 10\\n11111(5) -15\\n111111(6)- 21\\n1111111(7)-28*/\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n      \\n        long long output=0, sum =0;//sum is to calcuate the accumulative value as given series. n(n+1)/2\\n        int cnt =0;\\n        for(char c:s)\\n        {\\n            if( c == \\'1\\')//if c is \"1\", then incremnt the count and update the sum  \\n            {\\n                cnt++;\\n                sum +=cnt;//this produces the same sequence as above\\n            }\\n            else//else reset sum and cnt to 0 and update the output\\n            {\\n                if(cnt>0)\\n                    output+= sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        //for the last substring. If cnt>0, add it\\n        if(cnt>0)\\n           output+= sum;\\n        \\n        return output % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n - (0) - 0\\n1 - (1) - 1\\n11- (2) - 3\\n111(3)  - 6\\n1111(4) - 10\\n11111(5) -15\\n111111(6)- 21\\n1111111(7)-28*/\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        //Idea is to calculate the number of substring beforhand for given string size\\n        vector<long long> v;\\n        v.push_back(0);      \\n        long long sum =0;\\n        for(int i=1; i<=s.size(); ++i)\\n        {\\n            sum += i;//as given above, we can calculate by just adding the current number with previous sum\\n            v.push_back(sum);\\n        }\\n      \\n        //Now find the contigious 1\\'s and add them into another array\\n        vector<int> contigiuous;\\n        int cnt =0;\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if( s[i] == \\'1\\')\\n                cnt++;\\n            else\\n            {\\n                if(cnt>0)\\n                    contigiuous.push_back(cnt);\\n                cnt = 0;\\n            }\\n        }\\n        \\n        //for the last substring. If cnt>0, add it\\n        if(cnt>0)\\n           contigiuous.push_back(cnt);\\n        \\n        //Now navigate through the contigiuous array, get the number of possilbe sumbstring and add it in final sum\\n        long long output=0;\\n        for(auto c:contigiuous)\\n            output += v[c];\\n        \\n        return output % 1000000007;\\n    }\\n};\\n```\n```\\n/*\\n - (0) - 0\\n1 - (1) - 1\\n11- (2) - 3\\n111(3)  - 6\\n1111(4) - 10\\n11111(5) -15\\n111111(6)- 21\\n1111111(7)-28*/\\n\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n      \\n        long long output=0, sum =0;//sum is to calcuate the accumulative value as given series. n(n+1)/2\\n        int cnt =0;\\n        for(char c:s)\\n        {\\n            if( c == \\'1\\')//if c is \"1\", then incremnt the count and update the sum  \\n            {\\n                cnt++;\\n                sum +=cnt;//this produces the same sequence as above\\n            }\\n            else//else reset sum and cnt to 0 and update the output\\n            {\\n                if(cnt>0)\\n                    output+= sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        //for the last substring. If cnt>0, add it\\n        if(cnt>0)\\n           output+= sum;\\n        \\n        return output % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081584,
                "title": "easy-c-solution-using-subarray-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought of calcualting the number of continous zeros ,then finding the number of subaarys possible with that continuous zeroes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncalculate the running continuos count of zeroes,as we didnt find the zero ,add the c*(c+1)/2 to ans and make the c=0(for again calculating the runnning continuos count of zero).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//using the formula of subarrays->n*(n+1)/2;\\n    int mod=1e9+7;\\n    int numSub(string s) {\\n        int n=s.size();\\n        int c=0;\\n        long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c++;\\n            }\\n            else{\\n                ans+=(c*1LL*(c+1)/2);\\n                c=0;\\n            }\\n        }\\n        ans+=(c*1LL*(c+1)/2);\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//using the formula of subarrays->n*(n+1)/2;\\n    int mod=1e9+7;\\n    int numSub(string s) {\\n        int n=s.size();\\n        int c=0;\\n        long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c++;\\n            }\\n            else{\\n                ans+=(c*1LL*(c+1)/2);\\n                c=0;\\n            }\\n        }\\n        ans+=(c*1LL*(c+1)/2);\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067452,
                "title": "beginner-level-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef count_ones(s):\\n    one_sum = 0\\n    streak = 0\\n    memory = 0\\n    for char in s:\\n        if char == \\'1\\':\\n            streak += 1\\n            memory = streak\\n            \\n        elif char == \\'0\\':\\n            streak = 0\\n            if memory > 0:\\n                one_sum+=memory*(memory+1)/2\\n                memory = 0\\n    \\n    if memory > 0:\\n        one_sum+=memory*(memory+1)/2\\n        print(memory)\\n    return one_sum\\n\\n\\nclass Solution(object):\\n    def numSub(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        num = count_ones(s)\\n        return num%(10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef count_ones(s):\\n    one_sum = 0\\n    streak = 0\\n    memory = 0\\n    for char in s:\\n        if char == \\'1\\':\\n            streak += 1\\n            memory = streak\\n            \\n        elif char == \\'0\\':\\n            streak = 0\\n            if memory > 0:\\n                one_sum+=memory*(memory+1)/2\\n                memory = 0\\n    \\n    if memory > 0:\\n        one_sum+=memory*(memory+1)/2\\n        print(memory)\\n    return one_sum\\n\\n\\nclass Solution(object):\\n    def numSub(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        num = count_ones(s)\\n        return num%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065321,
                "title": "kotlin-one-liner",
                "content": "# Intuition\\nEach series of 1s forms the sum of natural up to number of ones in the series.\\n\\n# Approach\\nuse the formular for the sum of ap or natural numbers with common difference of 1 and first number 1.\\n\\n((it + 1) * it) / 2 \\n\\nI split the input by zeros then map the result list of strings using teh method described above.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun numSub(s: String) = (s.split(Regex(\"0+\")).map { it.length.toLong() }.map { ((it + 1) * it) / 2 }.sum() % (1000000000 + 7)).toInt()\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun numSub(s: String) = (s.split(Regex(\"0+\")).map { it.length.toLong() }.map { ((it + 1) * it) / 2 }.sum() % (1000000000 + 7)).toInt()\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054774,
                "title": "c-beats-100-tc-95-86-sc",
                "content": "![image.png](https://assets.leetcode.com/users/images/dceefcaf-1206-4a08-aad4-4ce184b2104f_1694935668.2804863.png)\\n# Idea\\nLook at each consecutive strings of 1. \\nThe constribution of each block to the final answer is given by the **Triangular Number** T(n) = n * (n + 1) / 2.\\n\\nThis is because, for example, if the length of such a block is five i.e. 11111,\\n- five 1 character strings: 1, 1, 1, 1, 1\\n- four 2 character strings: 11, 11, 11, 11\\n- three 3 character strings: 111, 111, 111\\n- two 4 character strings: 1111, 1111\\n- one 5 character string: 11111\\nfor a total of 1 + 2 + 3 + 4 + 5 = T(5) = 5 * 6 / 2 = 15.\\n\\n\\n# Code\\n**Important**: make sure to pass the string by reference, not by value.\\nBy default it is passed by value!\\n```\\nstatic const auto x = []() {\\n\\tstd::ios::sync_with_stdio(false);\\n\\tstd::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 0;\\n}();\\nstatic const unsigned MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numSub(string& s) { // PASS BY REFERENCE!\\n        int total = 0;\\n        int j = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\'1\\') {\\n                j++;\\n                continue;\\n            } \\n            // 1ll is needed to ensure conversion to long long\\n            // mid-calculation and avoid inteeger overflow\\n            long long n = j * 1ll * (j + 1) / 2 % MOD;\\n            total = (total + n) % MOD;\\n            j = 0;\\n        }\\n        if (j) { // if there are trailing 1s\\n            long long n = j * 1ll * (j + 1) / 2 % MOD;\\n            total = (total + n) % MOD;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic const auto x = []() {\\n\\tstd::ios::sync_with_stdio(false);\\n\\tstd::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 0;\\n}();\\nstatic const unsigned MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numSub(string& s) { // PASS BY REFERENCE!\\n        int total = 0;\\n        int j = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\'1\\') {\\n                j++;\\n                continue;\\n            } \\n            // 1ll is needed to ensure conversion to long long\\n            // mid-calculation and avoid inteeger overflow\\n            long long n = j * 1ll * (j + 1) / 2 % MOD;\\n            total = (total + n) % MOD;\\n            j = 0;\\n        }\\n        if (j) { // if there are trailing 1s\\n            long long n = j * 1ll * (j + 1) / 2 % MOD;\\n            total = (total + n) % MOD;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4047172,
                "title": "string",
                "content": "**Number of substrings with only 1s** \\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod= 1e9+7;\\n    int numSub(string s) {\\n        int n=s.size();\\n        int c=0;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c++;\\n            }else{\\n                c=0;\\n            }\\n            res=(res+c)%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod= 1e9+7;\\n    int numSub(string s) {\\n        int n=s.size();\\n        int c=0;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c++;\\n            }else{\\n                c=0;\\n            }\\n            res=(res+c)%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030530,
                "title": "simple-fast-solution-o-n",
                "content": "# Complexity\\n- **Time complexity: O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int m=pow(10,9)+7;\\n        s+=\\'0\\';\\n        long temp=0,ans=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') temp++;\\n            else{\\n                ans=(ans+(temp*(temp+1)/2)%m);\\n                temp=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int m=pow(10,9)+7;\\n        s+=\\'0\\';\\n        long temp=0,ans=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') temp++;\\n            else{\\n                ans=(ans+(temp*(temp+1)/2)%m);\\n                temp=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026395,
                "title": "nice-game-easy-play-easy-guide",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod = 1000000007;\\n        long long res = 0;\\n        int it = 0;\\n        int count = 0;\\n\\n        s.push_back(\\'0\\');\\n        vector<int> v;\\n\\n        while(it != s.length()){\\n            if(s[it] == \\'0\\'){\\n                v.push_back(count);\\n                res += (count)*1ll*(count+1)*0.5;\\n                res = res%mod;\\n                count = 0;\\n            }\\n\\n            else{\\n                count ++;\\n            }\\n            it++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod = 1000000007;\\n        long long res = 0;\\n        int it = 0;\\n        int count = 0;\\n\\n        s.push_back(\\'0\\');\\n        vector<int> v;\\n\\n        while(it != s.length()){\\n            if(s[it] == \\'0\\'){\\n                v.push_back(count);\\n                res += (count)*1ll*(count+1)*0.5;\\n                res = res%mod;\\n                count = 0;\\n            }\\n\\n            else{\\n                count ++;\\n            }\\n            it++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024510,
                "title": "java-100-faster",
                "content": "# Intuition\\nWe can use the triangular number formula ``n = l * (l + 1) / 2`` to find the number of substrings that can be generated from any string.\\n\\n# Approach\\nWe iterate through the input and count the length of each string of only 1s. For each string, we use the above formula to find the number of substrings. We then add it to the result while performing the appropriate modulus operations.\\n\\n# Complexity\\n- Time complexity : O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int numSub(String s)\\n    {\\n        long c = 0;\\n        int r = 0;\\n        int m = 1000000007;\\n\\n        for(int i=0, l=s.length(); i<l; i++)\\n            if(s.charAt(i)==\\'1\\')\\n                c++;\\n\\n            else\\n            {\\n                r = (r + (int)((c*(c+1)/2)%m))%m;\\n                c = 0;\\n            }\\n\\n        r = (r + (int)((c*(c+1)/2)%m))%m;\\n\\n        return r;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int numSub(String s)\\n    {\\n        long c = 0;\\n        int r = 0;\\n        int m = 1000000007;\\n\\n        for(int i=0, l=s.length(); i<l; i++)\\n            if(s.charAt(i)==\\'1\\')\\n                c++;\\n\\n            else\\n            {\\n                r = (r + (int)((c*(c+1)/2)%m))%m;\\n                c = 0;\\n            }\\n\\n        r = (r + (int)((c*(c+1)/2)%m))%m;\\n\\n        return r;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995718,
                "title": "python-solution-with-split",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        def number_of_substring(n):\\n            return n * (n + 1) // 2\\n        mod = 10 ** 9 + 7\\n        s_split = s.split(\\'0\\')\\n        ans = 0\\n        for substring in s_split:\\n            ans += number_of_substring(len(substring)) % mod\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        def number_of_substring(n):\\n            return n * (n + 1) // 2\\n        mod = 10 ** 9 + 7\\n        s_split = s.split(\\'0\\')\\n        ans = 0\\n        for substring in s_split:\\n            ans += number_of_substring(len(substring)) % mod\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995702,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        def number_of_substring(n):\\n            return n * (n + 1) // 2\\n        mod = 10**9 + 7\\n        ans = 0\\n        s += \\'0\\'\\n        start = 0\\n        flag = True\\n        s = s.lstrip(\\'0\\') # remove leading \\'0\\'\\n        if len(s) == 0:\\n            return 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\' and flag:\\n                start = i\\n                flag = False\\n            elif s[i] == \\'0\\' and not flag:\\n                ans += number_of_substring(i - start) % mod\\n                flag = True\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        def number_of_substring(n):\\n            return n * (n + 1) // 2\\n        mod = 10**9 + 7\\n        ans = 0\\n        s += \\'0\\'\\n        start = 0\\n        flag = True\\n        s = s.lstrip(\\'0\\') # remove leading \\'0\\'\\n        if len(s) == 0:\\n            return 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\' and flag:\\n                start = i\\n                flag = False\\n            elif s[i] == \\'0\\' and not flag:\\n                ans += number_of_substring(i - start) % mod\\n                flag = True\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993819,
                "title": "ruby-solution-with-triangle-numbers-explained-100-50",
                "content": "# Intuition\\nIt\\'s easy to find the number of substrings of a string.  Split the string into sequences that are all ones and find the number of substrings in each.\\n\\n# Approach\\n1. Initialize total and ones to be 0.  Total is the result we\\'ll return; ones is how many consecutive ones are in the current substring.\\n2. Iterate through the string.  For each character:\\n    - If it\\'s a 1, increment ones by 1.\\n    - If not, find how many substrings there are in the current substring of all ones and add that to total.  Then reset ones.\\n3. Find how many substrings there are in the current substring of all ones and add to total.\\n4. Return total mod 10**9+7\\n\\nHelper function:\\nThis function calculates how many substrings there are in a string of length n.  Basically, there are n of length 1, n-1 of length 2, n-2 of length 3, ... and 1 of length n.  So we add the numbers 1 through n.  This formula adds them efficiently (look up \"triangle numbers\" for explanation).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef num_sub(s)\\n    total = 0\\n    ones = 0\\n\\n    s.each_char do |char|\\n        if char == \\'1\\'\\n            ones += 1\\n        else\\n            total += tri(ones)\\n            ones = 0\\n        end\\n    end\\n\\n    total += tri(ones)\\n    \\n    total % 1000000007\\nend\\n\\ndef tri(n)\\n    (n * (n + 1)) / 2\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef num_sub(s)\\n    total = 0\\n    ones = 0\\n\\n    s.each_char do |char|\\n        if char == \\'1\\'\\n            ones += 1\\n        else\\n            total += tri(ones)\\n            ones = 0\\n        end\\n    end\\n\\n    total += tri(ones)\\n    \\n    total % 1000000007\\nend\\n\\ndef tri(n)\\n    (n * (n + 1)) / 2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3976748,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.size();\\n        int right = 0, left = 0, ans=0;\\n        while(right<n){\\n            if(s[right]==\\'1\\'){\\n                left = right;\\n                while(right<n){\\n                    if(s[right]==\\'1\\'){\\n                        ans= (ans)%1000000007 + (right-left+1)%1000000007;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                    right++;\\n                }\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int n = s.size();\\n        int right = 0, left = 0, ans=0;\\n        while(right<n){\\n            if(s[right]==\\'1\\'){\\n                left = right;\\n                while(right<n){\\n                    if(s[right]==\\'1\\'){\\n                        ans= (ans)%1000000007 + (right-left+1)%1000000007;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                    right++;\\n                }\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946601,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int numSub(string s) {\\n        int n = s.size(),i = 0,j = 0,oneCt = 0,ans = 0;\\n        while(j < n){\\n            if(s[j] == \\'1\\') oneCt++;\\n            while(oneCt < j-i+1)\\n                if(s[i++] == \\'1\\') oneCt--;\\n            ans = (ans + (j++) - i + 1)%M;\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int numSub(string s) {\\n        int n = s.size(),i = 0,j = 0,oneCt = 0,ans = 0;\\n        while(j < n){\\n            if(s[j] == \\'1\\') oneCt++;\\n            while(oneCt < j-i+1)\\n                if(s[i++] == \\'1\\') oneCt--;\\n            ans = (ans + (j++) - i + 1)%M;\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945521,
                "title": "super-easy-accumulator-approach",
                "content": "# Approach\\nWe iterate over all chars in string.\\nIf character is 1, we increment our accuumulator by 1.\\nThen we add accumulator to total result amount.\\nThats beacuse in `1` there is 1 variant, then in `11` there are 3 variants (1, 1, 11), but the first `1` we already  count on previous step. So just increment accumulator and add it to result (+2).\\nIn case of 0 we only reset accumulator to 0.\\n\\n# Code\\n```\\n\\tfunction numSub(s: string): number {\\n\\t\\tlet amount = 0;\\n\\t\\tlet count = 0;\\n\\n\\t\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\t\\tif (s[i] === \"0\" && amount > 0) {\\n\\t\\t\\t\\tamount = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif (s[i] === \"1\") {\\n\\t\\t\\t\\tamount++;\\n\\t\\t\\t\\tcount += amount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count % (10 ** 9 + 7);\\n\\t}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\tfunction numSub(s: string): number {\\n\\t\\tlet amount = 0;\\n\\t\\tlet count = 0;\\n\\n\\t\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\t\\tif (s[i] === \"0\" && amount > 0) {\\n\\t\\t\\t\\tamount = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif (s[i] === \"1\") {\\n\\t\\t\\t\\tamount++;\\n\\t\\t\\t\\tcount += amount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count % (10 ** 9 + 7);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932813,
                "title": "easy-java-solution-beats-85-with-explanations-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        long result = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count++;\\n            } else {\\n                result += (long) count * (count + 1) / 2;\\n                result %= mod;\\n                count = 0;\\n            }\\n        }\\n\\n        result += (long) count * (count + 1) / 2;\\n        result %= mod;\\n\\n        return (int) result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        long result = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count++;\\n            } else {\\n                result += (long) count * (count + 1) / 2;\\n                result %= mod;\\n                count = 0;\\n            }\\n        }\\n\\n        result += (long) count * (count + 1) / 2;\\n        result %= mod;\\n\\n        return (int) result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917569,
                "title": "typescript-math",
                "content": "# Code\\n```\\nfunction numSub(s) {\\n    let count = 0;\\n    let permuSum = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] == \\'1\\') {\\n            count = count + 1;\\n        } else {\\n            permuSum = (permuSum + permutation(count)) % (10 ** 9 + 7);\\n            count = 0;\\n        }\\n    }\\n    permuSum = (permuSum + permutation(count)) % (10 ** 9 + 7);\\n    return permuSum;\\n}\\n\\nfunction permutation(n) {\\n    return (n * (n + 1) / 2) % (10 ** 9 + 7);\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Math"
                ],
                "code": "```\\nfunction numSub(s) {\\n    let count = 0;\\n    let permuSum = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] == \\'1\\') {\\n            count = count + 1;\\n        } else {\\n            permuSum = (permuSum + permutation(count)) % (10 ** 9 + 7);\\n            count = 0;\\n        }\\n    }\\n    permuSum = (permuSum + permutation(count)) % (10 ** 9 + 7);\\n    return permuSum;\\n}\\n\\nfunction permutation(n) {\\n    return (n * (n + 1) / 2) % (10 ** 9 + 7);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914009,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int numSub(string s) {\\n        int n = s.size(),i=0,j=0,sum=0,ans=0;\\n        while(j < n){\\n            sum += (s[j]-\\'0\\');\\n            if(sum == j-i+1){\\n                ans = (ans+j-i+1)%M;\\n                j++;\\n            }else{\\n                while(sum < j-i+1 && i <= j){\\n                    sum -= (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9+7;\\n    int numSub(string s) {\\n        int n = s.size(),i=0,j=0,sum=0,ans=0;\\n        while(j < n){\\n            sum += (s[j]-\\'0\\');\\n            if(sum == j-i+1){\\n                ans = (ans+j-i+1)%M;\\n                j++;\\n            }else{\\n                while(sum < j-i+1 && i <= j){\\n                    sum -= (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902557,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int numSub(String s) {\\n    var cur = 0;\\n    var ans = 0;\\n    for (var i in s.split(\\'\\')) {\\n        if (i == \\'1\\') {\\n            cur += 1;\\n            ans += cur;\\n        } else {\\n            cur = 0;\\n        }\\n    }\\n    return ans % (pow(10, 9).toInt() + 7);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int numSub(String s) {\\n    var cur = 0;\\n    var ans = 0;\\n    for (var i in s.split(\\'\\')) {\\n        if (i == \\'1\\') {\\n            cur += 1;\\n            ans += cur;\\n        } else {\\n            cur = 0;\\n        }\\n    }\\n    return ans % (pow(10, 9).toInt() + 7);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885933,
                "title": "easy-python-o-n-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Increment count as you find 1s. Be sure to add this to result.\\n2. Reset count to 0 whenever you encounter 0\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: k\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        count = 0\\n        res = 0\\n\\n        for char in s:\\n            if char == \"1\":\\n                count += 1\\n                res += count\\n            else:\\n                count = 0\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        count = 0\\n        res = 0\\n\\n        for char in s:\\n            if char == \"1\":\\n                count += 1\\n                res += count\\n            else:\\n                count = 0\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871036,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar numSub = function(s) {\\n    const MODULO = 10 ** 9 + 7;\\n    let current = result = 0;\\n\\n    for (let index = 0; index <= s.length; index++) {\\n        const value = s[index];\\n\\n        if (value === \\'1\\') current += 1;\\n        else {\\n            result = (result + (current + 1) * current / 2) % MODULO;\\n            current = 0;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numSub = function(s) {\\n    const MODULO = 10 ** 9 + 7;\\n    let current = result = 0;\\n\\n    for (let index = 0; index <= s.length; index++) {\\n        const value = s[index];\\n\\n        if (value === \\'1\\') current += 1;\\n        else {\\n            result = (result + (current + 1) * current / 2) % MODULO;\\n            current = 0;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865950,
                "title": "python-3-clean-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numSub(self, s):\\n        count = 0\\n        temp = 0\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                temp = temp + 1\\n            else:\\n                count = count + ((temp*(temp+1))//2)\\n                temp = 0\\n        count = count + ((temp*(temp+1))//2)\\n        return count % (10**9 + 7)\\n\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSub(self, s):\\n        count = 0\\n        temp = 0\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                temp = temp + 1\\n            else:\\n                count = count + ((temp*(temp+1))//2)\\n                temp = 0\\n        count = count + ((temp*(temp+1))//2)\\n        return count % (10**9 + 7)\\n\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865668,
                "title": "tc-o-n-sc-o-1-java-easy-7-line-solution",
                "content": "# Intuition\\nIn a series of 1\\'s the position of the respective 1 can make substrings with only 1\\'s\\n\\nE.g\\n101111011\\nthere are threee sets(series) of 1s\\n1) 1\\n2) 1111\\n3) 11\\n\\nfor instance in 2nd series 1111 postions of 1s are 1 , 2 , 3 , 4.\\nHence they will make exactly that many substrings.\\nWe just need to add 1+2+3+4 = 10 , and we get max 1s substring for the given series.\\n\\nDo this for every series and add them together you get the ans.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n) one pass\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n           int count = 0 , ones = 0;\\n           for(int i = 0; i < s.length(); i++){\\n               while(i < s.length() && s.charAt(i)==\\'1\\'){\\n                   ones++;\\n                   count= (count%(1000000007))+ones;\\n                   i++;\\n               }\\n               ones=0;\\n    }\\nreturn count;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n           int count = 0 , ones = 0;\\n           for(int i = 0; i < s.length(); i++){\\n               while(i < s.length() && s.charAt(i)==\\'1\\'){\\n                   ones++;\\n                   count= (count%(1000000007))+ones;\\n                   i++;\\n               }\\n               ones=0;\\n    }\\nreturn count;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864783,
                "title": "c-detailed-solution",
                "content": "# Intuition\\nTo find all required substrings we can just find all possible substrings in every group of 1\\'s between zeros\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLet\\'s look at our possible input string. \\n<h7>000<b>1111</b>000000<b>11</b>0<b>1</b>0000<b>11</b></h7>\\nEvery group of ones is surrounded by zeros. To find number of all substrings with 1\\'s we need just find number of all possible substrings inside those groups of 1\\'s and add them up. Now let\\'s take a look at possible group of ones\\n<h7>11111</h7>\\nWe can have:\\n- 5 substring of \"1\"\\n- 4 substring of \"11\"\\n- 3 substring of \"111\"\\n\\nand so on.\\nSee the pattern? For substring of 1\\'s with length of N we can have\\n1 + 2 + 3 + ... + N = N(N+1)/2 possible substrings.\\n\\nNow we need just find lengthes of all such groups of 1\\'s in our input string, find number of substrings inside each one using our formula and add these numbers up. To do so we need:\\n- create variable to store total number of substrings\\n- create variable to store length of current substring(if you don\\'t understand just look below)\\n- iterate through input string and do following:\\n    - if current character is 1 increment length of current substring(thats why we created this variable before)\\n    - if current character is 0 it means that we iterater through group of 1\\'s and it\\'s time to calculate number of possible substrings, add this number to total number of substrings and set length of current substring of 1\\'s to zero\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    constexpr size_t getNumberOfSubstrings(size_t length) {\\n        return length * (length + 1) / 2;\\n    }\\n\\n    int numSub(const std::string& s) {\\n        size_t total_substrings = 0;\\n        size_t current_substr_len = 0;\\n\\n        // here we just look for each substring of 1\\'s\\n        // we just look through every character\\n        // and just count 1\\'s until we reach 0\\n        for (char c : s) {\\n            if (c == \\'1\\') {\\n                // here we iterating through group of 1\\'s\\n                ++current_substr_len;\\n            } else {\\n                // we reached 0, therefore substring ended and it\\'s time to measure\\n                // number of all possible substrings inside that one group\\n                total_substrings += getNumberOfSubstrings(current_substr_len);\\n                current_substr_len = 0;\\n            }\\n        }\\n\\n        // we add number of substrings in case we have input like \"......0111111...1111\"\\n        // In that case loop above will end before including substrings inside this last group of 1\\'s\\n        return (total_substrings + getNumberOfSubstrings(current_substr_len)) % 1000000007; // don\\'t forget to get modulo as stated in the description\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    constexpr size_t getNumberOfSubstrings(size_t length) {\\n        return length * (length + 1) / 2;\\n    }\\n\\n    int numSub(const std::string& s) {\\n        size_t total_substrings = 0;\\n        size_t current_substr_len = 0;\\n\\n        // here we just look for each substring of 1\\'s\\n        // we just look through every character\\n        // and just count 1\\'s until we reach 0\\n        for (char c : s) {\\n            if (c == \\'1\\') {\\n                // here we iterating through group of 1\\'s\\n                ++current_substr_len;\\n            } else {\\n                // we reached 0, therefore substring ended and it\\'s time to measure\\n                // number of all possible substrings inside that one group\\n                total_substrings += getNumberOfSubstrings(current_substr_len);\\n                current_substr_len = 0;\\n            }\\n        }\\n\\n        // we add number of substrings in case we have input like \"......0111111...1111\"\\n        // In that case loop above will end before including substrings inside this last group of 1\\'s\\n        return (total_substrings + getNumberOfSubstrings(current_substr_len)) % 1000000007; // don\\'t forget to get modulo as stated in the description\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861630,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'1\\') count++;\\n            else count = 0;\\n\\n            ans = (ans+count)%1000000007;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'1\\') count++;\\n            else count = 0;\\n\\n            ans = (ans+count)%1000000007;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854676,
                "title": "c-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int l=0,r=0,sum=0,M=(1e9+7);\\n        \\n        while(r<s.size()){\\n            while(r<s.size() && s[r]==\\'1\\' && s[l]==s[r]){\\n                sum=(sum+(r-l+1))%M;\\n                r++;\\n            }\\n            r++;\\n            l=r;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int l=0,r=0,sum=0,M=(1e9+7);\\n        \\n        while(r<s.size()){\\n            while(r<s.size() && s[r]==\\'1\\' && s[l]==s[r]){\\n                sum=(sum+(r-l+1))%M;\\n                r++;\\n            }\\n            r++;\\n            l=r;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833848,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0, total  = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'1\\'){\\n                count++;\\n            }\\n            else{\\n                count  = 0;\\n            }\\n            total = (total+count) % 1000000007;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count = 0, total  = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'1\\'){\\n                count++;\\n            }\\n            else{\\n                count  = 0;\\n            }\\n            total = (total+count) % 1000000007;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824772,
                "title": "easy-math-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst long long MOD=1000000007;\\n    int numSub(string s) {\\n        \\n        int n=s.size();\\n        long long ans=0,count=0;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                ans+=(count*(count+1))/2;\\n                ans%=MOD;\\n                count=0;\\n            }\\n        }\\n        ans+=(count*(count+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst long long MOD=1000000007;\\n    int numSub(string s) {\\n        \\n        int n=s.size();\\n        long long ans=0,count=0;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                ans+=(count*(count+1))/2;\\n                ans%=MOD;\\n                count=0;\\n            }\\n        }\\n        ans+=(count*(count+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822593,
                "title": "number-of-substrings-with-only-1s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        long count =1;\\n        long max = 0;\\n        long count0 = 0;\\n        ArrayList<Character> arr = new ArrayList<Character>();\\n        arr.add(s.charAt(0));\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\'&&s.charAt(i-1)!=\\'0\\')\\n            arr.add(s.charAt(i));\\n            else if(s.charAt(i)==\\'1\\')\\n            arr.add(s.charAt(i));\\n        }\\n        String s1 = new String();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            s1=s1+arr.get(i);\\n        }\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)==\\'0\\')\\n            count0++;\\n        }\\n        for(int i=1;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)==s1.charAt(i-1))\\n            count++;\\n            else\\n            {\\n                max = max+(count*(count+1)/2);\\n                count =1;\\n            }\\n        }\\n        System.out.println(count0);\\n        if(count>=1)\\n        max = max+(count*(count+1))/2;\\n        return (int)(max%(Math.pow(10,9)+7))-(int)count0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long count =1;\\n        long max = 0;\\n        long count0 = 0;\\n        ArrayList<Character> arr = new ArrayList<Character>();\\n        arr.add(s.charAt(0));\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\'&&s.charAt(i-1)!=\\'0\\')\\n            arr.add(s.charAt(i));\\n            else if(s.charAt(i)==\\'1\\')\\n            arr.add(s.charAt(i));\\n        }\\n        String s1 = new String();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            s1=s1+arr.get(i);\\n        }\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)==\\'0\\')\\n            count0++;\\n        }\\n        for(int i=1;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)==s1.charAt(i-1))\\n            count++;\\n            else\\n            {\\n                max = max+(count*(count+1)/2);\\n                count =1;\\n            }\\n        }\\n        System.out.println(count0);\\n        if(count>=1)\\n        max = max+(count*(count+1))/2;\\n        return (int)(max%(Math.pow(10,9)+7))-(int)count0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806758,
                "title": "line-sweep-solution-different-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This solution is completely different from any other solution from the solution forum. I used line sweep to store the count of each type of substring count in a array.\\n- Though this solution is not efficient, we should try to implement different algorithms.\\n- My idea is when we get a substring --> \"1\" we need to increment its count by 1.\\n- When we get a substr --> \"11\" we need to increment \"11\" count by 1 as well as \"1\" count by one.\\n- When we get a substr --> \"111\" we do incrementation to counts of \"11\" and \"1\".\\n- So, by observation I made a arr of len s.length()+1 as the substr cant exceed the str len.\\n- We keep a count variable to count the consecutive one\\'s. But we encounter a zero we reset it to 0;\\n- This count variable acts as our upper bound in the line_sweep but the lower bound is always fixed to 0.\\n- Ex: When we have count=3, we increment line_sweep[0]++ and decrement line_sweep[count]--. In this way we can increment the range of sizes of substrings of one\\'s. \\n- Comment for further questions. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        long ans=0;\\n        int mod=(int)(1e9+7);\\n        int n=s.length();\\n        int count=0;\\n        int[] line_sweep=new int[n+1];\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'0\\'){\\n                count=0;\\n                continue;\\n            }\\n            count++;\\n            line_sweep[0]++;\\n            line_sweep[count]--;\\n        }\\n        ans=line_sweep[0];\\n        for(int i=1;i<line_sweep.length;i++)\\n        {\\n            line_sweep[i]+=line_sweep[i-1];\\n            ans+=line_sweep[i];\\n        }\\n        \\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long ans=0;\\n        int mod=(int)(1e9+7);\\n        int n=s.length();\\n        int count=0;\\n        int[] line_sweep=new int[n+1];\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'0\\'){\\n                count=0;\\n                continue;\\n            }\\n            count++;\\n            line_sweep[0]++;\\n            line_sweep[count]--;\\n        }\\n        ans=line_sweep[0];\\n        for(int i=1;i<line_sweep.length;i++)\\n        {\\n            line_sweep[i]+=line_sweep[i-1];\\n            ans+=line_sweep[i];\\n        }\\n        \\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787330,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe needed number of substrings is the sum of the number of substrings in the contunuous chunks of 1\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSplit s into chunks of adjacent 1\\'s. For each such chunk of length k the number of substrings is 1+2+...+k = (k+1) * k // 2. Calculate the sum over all chunks and return it mod 10^9+7.\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return sum([(len(w)+1) * len(w) // 2 for w in s.split(\\'0\\')]) % 1000000007\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        return sum([(len(w)+1) * len(w) // 2 for w in s.split(\\'0\\')]) % 1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783079,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n      int i=0;\\n      int j=0;\\n      int ans=0;\\n      int mod=1000000007;\\n      while(j<s.length()){\\nif(s.charAt(j)==\\'0\\'){\\n  i=j+1;\\n  j++;\\n}else{\\n  ans=(ans+j-i+1)%mod;\\nj++;\\n}\\n      }\\n       \\n        return ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n      int i=0;\\n      int j=0;\\n      int ans=0;\\n      int mod=1000000007;\\n      while(j<s.length()){\\nif(s.charAt(j)==\\'0\\'){\\n  i=j+1;\\n  j++;\\n}else{\\n  ans=(ans+j-i+1)%mod;\\nj++;\\n}\\n      }\\n       \\n        return ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782959,
                "title": "o-n-solution-using-java-and-some-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to iterate through the input string s and count the number of substrings with all characters as 1\\'s. The approach keeps track of the count of consecutive 1\\'s encountered and adds it to the total count. When a \\'0\\' is encountered, the count is reset to 0 since consecutive 1\\'s have been interrupted. The modulo operation is performed to keep the total count within the specified range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize totalCount to keep track of the total count of substrings with all characters as 1\\'s.\\nInitialize count to track the count of consecutive 1\\'s encountered.\\nIterate through each character in the input string s.\\nIf the character is \\'1\\', increment count by 1 and add it to totalCount.\\nPerform the modulo operation totalCount %= MOD to keep the value of totalCount within the range.\\nIf the character is \\'0\\', reset count to 0 since consecutive 1\\'s have been interrupted.\\nReturn the final value of totalCount casted to an int as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through each character of the input string once, resulting in a time complexity of O(n), where n is the length of the input string.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a fixed amount of additional space for the totalCount and count variables, resulting in a space complexity of O(1), constant space.\\nOverall, the code has a time complexity of O(n) and a space complexity of O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        final int MOD = 1000000007;\\n        long totalCount = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count++;\\n                totalCount += count;\\n                totalCount %= MOD;\\n            } else {\\n                count = 0;\\n            }\\n        }\\n\\n        return (int) totalCount;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        final int MOD = 1000000007;\\n        long totalCount = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count++;\\n                totalCount += count;\\n                totalCount %= MOD;\\n            } else {\\n                count = 0;\\n            }\\n        }\\n\\n        return (int) totalCount;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782043,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod=1e9+7;\\n        int ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(j<s.size()){\\n            \\n            if(s[j]==\\'1\\'){\\n                ans=(ans%mod+(j-i)+1)%mod;\\n            }\\n            \\n            else{\\n                i=j+1;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod=1e9+7;\\n        int ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(j<s.size()){\\n            \\n            if(s[j]==\\'1\\'){\\n                ans=(ans%mod+(j-i)+1)%mod;\\n            }\\n            \\n            else{\\n                i=j+1;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768292,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod = 1000000007;\\n        int count = 0;\\n        long long ans = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'1\\'){\\n                count++;\\n                ans += count;\\n                ans = ans % mod;\\n            }\\n            else count = 0;\\n        }\\n        return ans % mod;\\n        \\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/bc642078-9fda-4441-a03e-86790e86fc72_1694616297.536215.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int mod = 1000000007;\\n        int count = 0;\\n        long long ans = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'1\\'){\\n                count++;\\n                ans += count;\\n                ans = ans % mod;\\n            }\\n            else count = 0;\\n        }\\n        return ans % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760120,
                "title": "sliding-window-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n        int mod = 1000000007;\\n        while(j<s.length()){\\n            if(s.charAt(j) == \\'0\\'){\\n                i = j+1;\\n                j++;\\n            }else{\\n                ans = (ans + j-i+1)%mod;\\n                j++;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n        int mod = 1000000007;\\n        while(j<s.length()){\\n            if(s.charAt(j) == \\'0\\'){\\n                i = j+1;\\n                j++;\\n            }else{\\n                ans = (ans + j-i+1)%mod;\\n                j++;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749094,
                "title": "solution-explained-for-all-languages-implementation-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        count = 0\\n        for n in map(len, s.split(\\'0\\')):\\n            count += n * (n + 1) // 2\\n        return count % (10**9 + 7)\\n```\\n\\nThe number of substrings with all ones *in the input string* $S$ is sum of the number of substrings with all ones *in each group of ones* $OS$\\n\\n$$\\n\\\\text{SubstrOfOnesCount}(S)\\n= \\\\sum\\\\limits_{OS} \\\\text{SubstrOfOnesCount}(OS)\\n.$$\\n> E.g. in a string `10111011`\\n> $$\\n> \\\\begin{align}\\n> \\\\text{SubstrOfOnesCount}(\"10111011\")\\n> &= \\\\text{SubstrOfOnesCount}(\"1\")\\n> \\\\\\\\ &+ \\\\text{SubstrOfOnesCount}(\"111\")\\n> \\\\\\\\ &+ \\\\text{SubstrOfOnesCount}(\"11\")\\n> \\\\end{align}\\n> $$\\n\\nSo, we have to find $\\\\text{SubstrOfOnesCount}(x)$, where $x$ is string of ones with length $n \\\\ge 1$, $x = n \\\\times \"1\"$. \\n\\nLet\\'s denote the length of a substring by $m$. In a string of length $n$ there are\\n$$\\nn - m + 1\\n$$\\nsubstrings of length $m$.\\n> E.g. in a string `abcd` there are 4 substrings of length 1, 3 substrings of length 2, 2 substrings of length 3 and 1 substring of length 4.\\n\\nIn a string of length $n$ substrings may have length from 1 to $n$, so\\n$$\\n\\\\text{SubstrOfOnesCount}(n \\\\times \"1\")\\n= \\\\sum\\\\limits_{m = 1}^{n} (n - m + 1)\\n= \\\\sum\\\\limits_{m = 1}^{n} n\\n- \\\\sum\\\\limits_{m = 1}^{n} m\\n+ \\\\sum\\\\limits_{m = 1}^{n} 1\\n\\\\\\\\ = n^2 - \\\\dfrac{n (n+1)}{2} + n\\n= \\\\dfrac{n^2}{2} + \\\\dfrac{n}{2}\\n= \\\\dfrac{n(n+1)}{2}.\\n$$\\n\\n# Complexity\\n- Time complexity: $O(|S| + \\\\text{number of groups})$\\n\\n# Consider further\\n- Cache $\\\\text{SubstrOfOnesCount}$. Also, you may use\\n$$\\n\\\\text{SubstrOfOnesCount}((n+1) \\\\times \"1\")\\n= \\\\\\\\ \\\\text{SubstrOfOnesCount}(n \\\\times \"1\") + (n + 1)\\n$$\\n- For Python, replace for cycle with a reducing operation, e.g. `sum`.\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        count = 0\\n        for n in map(len, s.split(\\'0\\')):\\n            count += n * (n + 1) // 2\\n        return count % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735388,
                "title": "q-1513-number-of-substrings-with-only-1s-easy-implementation-code-just-an-obseravation",
                "content": "Approach : Just an observation that using n number of consecutive 1\\'s you can form n*(n+1)/2 combinations.\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int MOD=1e9+7;\\n        long res=0;\\n        long cnt=0;\\n        for(auto i:s){\\n            if(i==\\'1\\'){\\n                cnt++;\\n            }\\n            else{\\n                res=(res+(cnt*(cnt+1))/2)%MOD;\\n                cnt=0;\\n            }\\n        }\\n        return (res+(cnt*(cnt+1))/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int MOD=1e9+7;\\n        long res=0;\\n        long cnt=0;\\n        for(auto i:s){\\n            if(i==\\'1\\'){\\n                cnt++;\\n            }\\n            else{\\n                res=(res+(cnt*(cnt+1))/2)%MOD;\\n                cnt=0;\\n            }\\n        }\\n        return (res+(cnt*(cnt+1))/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682642,
                "title": "java-simple-and-clean-code",
                "content": "# Approach\\n1. Determine the length of each continous 1 segment. Once you have it (eg:next char is 0) calculate the natural sum of 1 ..l of that segment.\\n    - EG: 111 can form 1 segment of 3 1s, 2 segments of 2 and 3 segments of 1 => 1 + 2 + 3.\\n    - Thus, l * (l+1) / 2. As an optimization, you can actually add each step (1,2,3) to the total length while traversing the string\\n2. Traverse s and keep track of the lengths of a continuous 1s segment.\\n3. If current char is 0, reset length to 0, else incremenent it\\n4. After each char, add the current length to the totalLength\\n    - EG: \"111\"\\n    - i = 0 => total += 1;\\n    - i = 1 => total += 2;\\n    - i = 2 => total += 3\\n    - => total = 6. (3 segments of 1, 2 of 2 and 1 of 3 elements)\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        long total = 0L; \\n        int sequenceLength = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                sequenceLength++;\\n            } else {\\n                sequenceLength = 0;\\n            }\\n            total += sequenceLength;\\n        }\\n        return  (int)(total % 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        long total = 0L; \\n        int sequenceLength = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                sequenceLength++;\\n            } else {\\n                sequenceLength = 0;\\n            }\\n            total += sequenceLength;\\n        }\\n        return  (int)(total % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676514,
                "title": "java-solution-two-approaches-count-and-sliding-window",
                "content": "# code using sliding window\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        int l=0;\\n        int mod=1000_000_007;\\n        while(j<n)\\n        {\\n            \\n            if(s.charAt(j)==\\'0\\')\\n            {\\n                i=j;\\n            }\\n            while(i<n && s.charAt(i)==\\'0\\')\\n            {\\n                i++;\\n                l++;\\n            }\\n            if(j<n && s.charAt(j)!=\\'0\\')\\n            {res=(res%mod+(j-i+1)%mod);\\n             //System.out.println(i+\" \"+j);\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n# code using count \\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        int cnt=0;\\n        int mod=1000_000_007;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n                cnt++;\\n            else \\n                cnt=0;\\n            res=(res+cnt)%mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        int l=0;\\n        int mod=1000_000_007;\\n        while(j<n)\\n        {\\n            \\n            if(s.charAt(j)==\\'0\\')\\n            {\\n                i=j;\\n            }\\n            while(i<n && s.charAt(i)==\\'0\\')\\n            {\\n                i++;\\n                l++;\\n            }\\n            if(j<n && s.charAt(j)!=\\'0\\')\\n            {res=(res%mod+(j-i+1)%mod);\\n             //System.out.println(i+\" \"+j);\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int n=s.length();\\n        int res=0;\\n        int i=0,j=0;\\n        int cnt=0;\\n        int mod=1000_000_007;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n                cnt++;\\n            else \\n                cnt=0;\\n            res=(res+cnt)%mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671327,
                "title": "solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmy Approach is too simple am loop through the string and increment +1\\nwhen we get 1 in string otherwise reset the count 0 .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numSub = function(s) {\\n    let count =0;\\n    let mod = 1e9 + 7;\\n    let result = 0    \\n    for(let i=0;i<s.length;i++){\\n        if(s[i] === \"1\"){\\n            count++;\\n            result =( result + count) % mod;\\n        }else{\\n            count = 0;\\n        }\\n    }\\n        \\n\\n   \\n    \\nreturn result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numSub = function(s) {\\n    let count =0;\\n    let mod = 1e9 + 7;\\n    let result = 0    \\n    for(let i=0;i<s.length;i++){\\n        if(s[i] === \"1\"){\\n            count++;\\n            result =( result + count) % mod;\\n        }else{\\n            count = 0;\\n        }\\n    }\\n        \\n\\n   \\n    \\nreturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663830,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint numSub(string s) {\\n\\t\\tlong count = 0;\\n\\t\\tlong ans = 0;\\n\\t\\tfor(int i  = 0; i < s.size(); i++){\\n\\t\\t\\tif(s[i] == \\'1\\'){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans += (count * (count + 1)) / 2;\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (ans + (count * (count + 1)) / 2) % 1000000007;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint numSub(string s) {\\n\\t\\tlong count = 0;\\n\\t\\tlong ans = 0;\\n\\t\\tfor(int i  = 0; i < s.size(); i++){\\n\\t\\t\\tif(s[i] == \\'1\\'){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans += (count * (count + 1)) / 2;\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (ans + (count * (count + 1)) / 2) % 1000000007;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657024,
                "title": "beginner-friendly-number-of-substrings-with-only-1s-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    int numSub(string s) {\\n        int n = s.size();\\n        long long ans=0, curr=0;\\n        for(int i=0; i<n; ++i){\\n            if(s[i]==\\'0\\'){\\n                ans = (ans + (curr*(curr+1))/2) % MOD;\\n                curr=0;\\n                continue;\\n            }\\n            curr++;\\n        }\\n        ans = (ans + (curr*(curr+1))/2) % MOD;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    int numSub(string s) {\\n        int n = s.size();\\n        long long ans=0, curr=0;\\n        for(int i=0; i<n; ++i){\\n            if(s[i]==\\'0\\'){\\n                ans = (ans + (curr*(curr+1))/2) % MOD;\\n                curr=0;\\n                continue;\\n            }\\n            curr++;\\n        }\\n        ans = (ans + (curr*(curr+1))/2) % MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654309,
                "title": "c-super-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int x = 0, ans = 0, m = 1e9 + 7;\\n        for (auto& c : s)\\n            ans = (ans + (x = c == \\'1\\' ? x + 1 : 0)) % m;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        int x = 0, ans = 0, m = 1e9 + 7;\\n        for (auto& c : s)\\n            ans = (ans + (x = c == \\'1\\' ? x + 1 : 0)) % m;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606467,
                "title": "two-pointers-python-math",
                "content": "This is with string, so don\\'t forget \"\" in s[i] == \"1\"\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        # same with 1759, 1) add counter of 1\\'s or \\n        # 2) sum(range(1, n+1)); n = length of same numbers\\n\\n        \\n        counter = 0 \\n        res = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                counter += 1\\n                res += counter\\n            else:\\n                counter = 0\\n            \\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        # same with 1759, 1) add counter of 1\\'s or \\n        # 2) sum(range(1, n+1)); n = length of same numbers\\n\\n        \\n        counter = 0 \\n        res = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"1\":\\n                counter += 1\\n                res += counter\\n            else:\\n                counter = 0\\n            \\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601847,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        HashMap<Character, Integer> lst = new HashMap<>();\\n        int left = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); i++){\\n            char letter = s.charAt(i);\\n            if (letter == \\'0\\') {\\n                while (left <= i){\\n                    char let = s.charAt(left);\\n                    lst.put(let, lst.getOrDefault(let, 0) - 1);\\n                    if (lst.get(let) == 0) {\\n                        lst.remove(let);\\n                    }\\n                    left++;\\n                }\\n            }\\n            else if (letter == \\'1\\'){\\n                lst.put(letter, lst.getOrDefault(letter, 0) + 1);\\n                //System.out.print(i + \" \" + left + \"\\\\n\");\\n                ans += i - left + 1;\\n                ans %= 1_000_000_007;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        HashMap<Character, Integer> lst = new HashMap<>();\\n        int left = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); i++){\\n            char letter = s.charAt(i);\\n            if (letter == \\'0\\') {\\n                while (left <= i){\\n                    char let = s.charAt(left);\\n                    lst.put(let, lst.getOrDefault(let, 0) - 1);\\n                    if (lst.get(let) == 0) {\\n                        lst.remove(let);\\n                    }\\n                    left++;\\n                }\\n            }\\n            else if (letter == \\'1\\'){\\n                lst.put(letter, lst.getOrDefault(letter, 0) + 1);\\n                //System.out.print(i + \" \" + left + \"\\\\n\");\\n                ans += i - left + 1;\\n                ans %= 1_000_000_007;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588501,
                "title": "shortest-code-beats-89-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count =0 , total = 0 , mod = 1_000_000_007;\\n        for(char c : s.toCharArray()){\\n            count = c ==\\'1\\' ? count +1 : 0;\\n            total = (total + count) % mod;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numSub(String s) {\\n        int count =0 , total = 0 , mod = 1_000_000_007;\\n        for(char c : s.toCharArray()){\\n            count = c ==\\'1\\' ? count +1 : 0;\\n            total = (total + count) % mod;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585937,
                "title": "golang-simple-and-quick-beats-87",
                "content": "\\n# Code\\n```\\nconst modulo = 1000000007\\n\\nfunc numSub(s string) int {\\n    var sum int64\\n\\n    prev := int64(0)\\n    for i := 0; i < len(s); i ++ {\\n        if prev > 1 {\\n            prev --\\n            sum += prev\\n        } else {\\n            j := i\\n            for ; j < len(s); j ++ {\\n                if s[j] != \\'1\\' {\\n                    break;\\n                }\\n            }\\n            cnt := int64(j - i)\\n            prev = cnt\\n            sum += cnt\\n        }\\n    }\\n\\n    return int(sum % modulo)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst modulo = 1000000007\\n\\nfunc numSub(s string) int {\\n    var sum int64\\n\\n    prev := int64(0)\\n    for i := 0; i < len(s); i ++ {\\n        if prev > 1 {\\n            prev --\\n            sum += prev\\n        } else {\\n            j := i\\n            for ; j < len(s); j ++ {\\n                if s[j] != \\'1\\' {\\n                    break;\\n                }\\n            }\\n            cnt := int64(j - i)\\n            prev = cnt\\n            sum += cnt\\n        }\\n    }\\n\\n    return int(sum % modulo)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580497,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long i=0,j=0,n = s.length(),mod = 1e9+7;\\n        long long int ans = 0;\\n        long long x;\\n        while(i < n)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                j = i + 1;\\n                while(j < n && s[j] == \\'1\\')\\n                {\\n                    j++;\\n                }\\n                x = (j - i + 1) * (j - i) / 2;\\n                ans = (ans + x) % mod;\\n                i = j;\\n            }\\n            else{i++;}\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n        long long i=0,j=0,n = s.length(),mod = 1e9+7;\\n        long long int ans = 0;\\n        long long x;\\n        while(i < n)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                j = i + 1;\\n                while(j < n && s[j] == \\'1\\')\\n                {\\n                    j++;\\n                }\\n                x = (j - i + 1) * (j - i) / 2;\\n                ans = (ans + x) % mod;\\n                i = j;\\n            }\\n            else{i++;}\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552365,
                "title": "easy-way-to-solve-find-substring-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        s  = s + \"0\"\\n        i, res = 0,0\\n        for ch in s:\\n            if ch == \"1\": i+=1\\n            else:\\n                res += int((i+1)*i/2)\\n                i = 0\\n        return res % (10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSub(self, s: str) -> int:\\n        s  = s + \"0\"\\n        i, res = 0,0\\n        for ch in s:\\n            if ch == \"1\": i+=1\\n            else:\\n                res += int((i+1)*i/2)\\n                i = 0\\n        return res % (10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508550,
                "title": "java-easy-understanding",
                "content": "```\\nclass Solution {\\n\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        int count = 1;\\n        int ans = 0;\\n        for(int i = 0 ; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                ans= (ans + (count%mod))%mod;\\n                count++;\\n            }else{\\n                count = 1;\\n            }    \\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int numSub(String s) {\\n        int mod = 1000000007;\\n        int count = 1;\\n        int ans = 0;\\n        for(int i = 0 ; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                ans= (ans + (count%mod))%mod;\\n                count++;\\n            }else{\\n                count = 1;\\n            }    \\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504448,
                "title": "kotlin-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    val mod = 1_000_000_007\\n\\n    fun numSub(s: String): Int {\\n        var result = 0\\n\\n        var left = -1\\n        for (right in 0 until s.length) {\\n            if (s[right] == \\'0\\') {\\n                left = -1\\n                continue\\n            }\\n\\n            if (left == -1) left = right\\n            result += right - left + 1\\n            result %= mod\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    val mod = 1_000_000_007\\n\\n    fun numSub(s: String): Int {\\n        var result = 0\\n\\n        var left = -1\\n        for (right in 0 until s.length) {\\n            if (s[right] == \\'0\\') {\\n                left = -1\\n                continue\\n            }\\n\\n            if (left == -1) left = right\\n            result += right - left + 1\\n            result %= mod\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502485,
                "title": "java-4-lines-sliding-window",
                "content": "```\\npublic int numSub(String s) {\\n\\tint res=0, conseq=0; \\n\\tfor (int i=0;i<s.length();i++)\\n\\t\\tif (s.charAt(i)==\\'1\\') { conseq++; res=(res+conseq)%1_000_000_007; } else conseq=0; \\n\\treturn res;\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int numSub(String s) {\\n\\tint res=0, conseq=0; \\n\\tfor (int i=0;i<s.length();i++)\\n\\t\\tif (s.charAt(i)==\\'1\\') { conseq++; res=(res+conseq)%1_000_000_007; } else conseq=0; \\n\\treturn res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500234,
                "title": "easy-java-solution-2-approach",
                "content": "```\\nTC: O(N)\\nSC: O(1)\\n\\n**Approach 1:- **\\n\\n\\t public int numSub(String s) {\\n        long count = 0;\\n        int mod = 1000_000_007;\\n        int N = s.length();\\n\\t\\tint res = 0;\\n        for(int i=0; i<N; i++) {\\n            if(s.charAt(i)==\\'1\\') {\\n                res++;\\n                count = (count+res)%mod;\\n            } else {\\n                res=0;\\n            }\\n        }\\n        return (int)count;\\n    }\\n\\t\\n**Approach 2:-**\\n\\npublic int numSub(String s) {\\n        long count = 0;\\n        int mod = 1000_000_007;\\n        int N = s.length();\\n        int i = 0;\\n        int j = 0;;\\n        while(i<N) {\\n            if(s.charAt(i)==\\'1\\') {\\n                j = i;\\n                while(j<N) {\\n                    if(s.charAt(j)==\\'1\\') {\\n                        j++;\\n                    } else {\\n                        break;\\n                    }  \\n                }\\n                j--;\\n                int len = j-i+1;\\n                count = count + ((1l* (len)) * (len+1)/2)%mod;\\n                i = j;\\n            }\\n            i++;\\n        }\\n\\t\\treturn (int)count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nTC: O(N)\\nSC: O(1)\\n\\n**Approach 1:- **\\n\\n\\t public int numSub(String s) {\\n        long count = 0;\\n        int mod = 1000_000_007;\\n        int N = s.length();\\n\\t\\tint res = 0;\\n        for(int i=0; i<N; i++) {\\n            if(s.charAt(i)==\\'1\\') {\\n                res++;\\n                count = (count+res)%mod;\\n            } else {\\n                res=0;\\n            }\\n        }\\n        return (int)count;\\n    }\\n\\t\\n**Approach 2:-**\\n\\npublic int numSub(String s) {\\n        long count = 0;\\n        int mod = 1000_000_007;\\n        int N = s.length();\\n        int i = 0;\\n        int j = 0;;\\n        while(i<N) {\\n            if(s.charAt(i)==\\'1\\') {\\n                j = i;\\n                while(j<N) {\\n                    if(s.charAt(j)==\\'1\\') {\\n                        j++;\\n                    } else {\\n                        break;\\n                    }  \\n                }\\n                j--;\\n                int len = j-i+1;\\n                count = count + ((1l* (len)) * (len+1)/2)%mod;\\n                i = j;\\n            }\\n            i++;\\n        }\\n\\t\\treturn (int)count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475124,
                "title": "easy-math-solution-mod",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n       long long cnt=0;\\n      long long ans=0;\\n       for(long long i=0;i<s.length();i++){\\n           if(s[i]==\\'0\\') cnt=0;\\n           else {\\n               cnt++;\\n               ans+=cnt% 1000000007;\\n           }\\n       }\\n       return ans% 1000000007; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSub(string s) {\\n       long long cnt=0;\\n      long long ans=0;\\n       for(long long i=0;i<s.length();i++){\\n           if(s[i]==\\'0\\') cnt=0;\\n           else {\\n               cnt++;\\n               ans+=cnt% 1000000007;\\n           }\\n       }\\n       return ans% 1000000007; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456212,
                "title": "very-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int numSub(string s) \\n    {\\n        int mod=1e9+7;\\n        int ans=0;\\n        for(int x=0; x<s.size(); x++)\\n        {\\n            if(s[x]==\\'1\\')\\n            {\\n                int st=x;\\n                int en=st;\\n                while(s[en]==\\'1\\')\\n                {\\n                    ans=(ans+en-st+1)%mod;\\n                    en++;\\n                }\\n                x=en;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numSub(string s) \\n    {\\n        int mod=1e9+7;\\n        int ans=0;\\n        for(int x=0; x<s.size(); x++)\\n        {\\n            if(s[x]==\\'1\\')\\n            {\\n                int st=x;\\n                int en=st;\\n                while(s[en]==\\'1\\')\\n                {\\n                    ans=(ans+en-st+1)%mod;\\n                    en++;\\n                }\\n                x=en;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1689109,
                "content": [
                    {
                        "username": "kinetic_dev",
                        "content": "how you mod in this case\\n"
                    },
                    {
                        "username": "vixeyfox",
                        "content": " answer_sum += how_many_substrings_of_1s\\n                                \\n                        # use modulo to prevent overflow\\n                        answer_sum = answer_sum % (10**9 + 7)\\nThis is because it is a large prime number that is easily expressed\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "This could possibly be moved to easy. I solved this in fewer than five minutes while distracted. "
                    },
                    {
                        "username": "khe1154",
                        "content": "almost same as: https://leetcode.com/problems/number-of-zero-filled-subarrays/"
                    }
                ]
            },
            {
                "id": 1794920,
                "content": [
                    {
                        "username": "kinetic_dev",
                        "content": "how you mod in this case\\n"
                    },
                    {
                        "username": "vixeyfox",
                        "content": " answer_sum += how_many_substrings_of_1s\\n                                \\n                        # use modulo to prevent overflow\\n                        answer_sum = answer_sum % (10**9 + 7)\\nThis is because it is a large prime number that is easily expressed\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "This could possibly be moved to easy. I solved this in fewer than five minutes while distracted. "
                    },
                    {
                        "username": "khe1154",
                        "content": "almost same as: https://leetcode.com/problems/number-of-zero-filled-subarrays/"
                    }
                ]
            },
            {
                "id": 2043166,
                "content": [
                    {
                        "username": "kinetic_dev",
                        "content": "how you mod in this case\\n"
                    },
                    {
                        "username": "vixeyfox",
                        "content": " answer_sum += how_many_substrings_of_1s\\n                                \\n                        # use modulo to prevent overflow\\n                        answer_sum = answer_sum % (10**9 + 7)\\nThis is because it is a large prime number that is easily expressed\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "This could possibly be moved to easy. I solved this in fewer than five minutes while distracted. "
                    },
                    {
                        "username": "khe1154",
                        "content": "almost same as: https://leetcode.com/problems/number-of-zero-filled-subarrays/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Path with Maximum Probability",
        "question_content": "<p>You are given an undirected weighted graph of&nbsp;<code>n</code>&nbsp;nodes (0-indexed), represented by an edge list where&nbsp;<code>edges[i] = [a, b]</code>&nbsp;is an undirected edge connecting the nodes&nbsp;<code>a</code>&nbsp;and&nbsp;<code>b</code>&nbsp;with a probability of success of traversing that edge&nbsp;<code>succProb[i]</code>.</p>\n\n<p>Given two nodes&nbsp;<code>start</code>&nbsp;and&nbsp;<code>end</code>, find the path with the maximum probability of success to go from&nbsp;<code>start</code>&nbsp;to&nbsp;<code>end</code>&nbsp;and return its success probability.</p>\n\n<p>If there is no path from&nbsp;<code>start</code>&nbsp;to&nbsp;<code>end</code>, <strong>return&nbsp;0</strong>. Your answer will be accepted if it differs from the correct answer by at most <strong>1e-5</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png\" style=\"width: 187px; height: 186px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\n<strong>Output:</strong> 0.25000\n<strong>Explanation:</strong>&nbsp;There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png\" style=\"width: 189px; height: 186px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\n<strong>Output:</strong> 0.30000\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png\" style=\"width: 215px; height: 191px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\n<strong>Output:</strong> 0.00000\n<strong>Explanation:</strong>&nbsp;There is no path between 0 and 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= start, end &lt; n</code></li>\n\t<li><code>start != end</code></li>\n\t<li><code>0 &lt;= a, b &lt; n</code></li>\n\t<li><code>a != b</code></li>\n\t<li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li>\n\t<li><code>0 &lt;= succProb[i] &lt;= 1</code></li>\n\t<li>There is at most one edge between every two nodes.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 731767,
                "title": "java-python-3-2-codes-bellman-ford-and-dijkstra-s-algorithm-w-brief-explanation-and-analysis",
                "content": "**Update:**\\n\\n**Q & A**\\n`Q1`: Why negative weights can be used in Dijkstra\\'s algorithm here in Python 3 code? I thought it\\'s not allowed.\\n`A1`: Excellent question, negative weight is used ONLY in `heapq` to order its priority by reversed weight order. In fact, when calculating Prob., we still use positive value `-prob`.\\n\\n----\\n\\n`Q2`: Why Belman Ford actually works when vertices and edges can be as large as `10000` and `20000`, respectively? If algo is `O(n * E)` it would be at least `200 000 000` operations, which is too much.\\n`A2`:  - credit to **@Binga45**: `O(n * E)` is a very loose upper bound, and the code actually prunes enough branches to make itself run fast; Specifically, the bellman ford code won\\'t add already visited vertices in most of the scenarios as we are enforcing below condition before adding to the queue.\\n```\\n\\tif (p[cur] * succProb[index] > p[neighbor]) {\\n\\t\\tp[neighbor] = p[cur] * succProb[index];\\n\\t\\tq.offer(neighbor);\\n\\t}\\n```\\nSo, let\\'s imagine an edge v-t and the probability connecting them to be 1. We have visited `v `and based on probability p[v], we updated p[t] also to the same value as p[v] as the edge connecting them has a prob of 1. Now, when we add `t` to the queue, we won\\'t revisit the already visited neighbor v as p[t] * 1 is not > p[v].\\n\\nThe only exception to the above scenario is when we have another vertex `u` in the same level(depth) as `v` with a p[u] > p[v] and probability of edge u-t is 1. Then, we will revisit `v` from `t`, because in this scenario, p[t] * 1 > p[v] as p[t] is updated by `u` vertex. -- credit to **@Binga45**\\n\\n----\\n\\n`Q3`: Isn\\'t this problem similar to Finding longest path in undirected graph which is a NP hard problem - [Longest Path Problem](https://en.m.wikipedia.org/wiki/Longest_path_problem) ?\\n\\n`A3`: The problem says: \"...Given two nodes `start` and `end`, ...\". Therefore, it is similar to [Shortest Path Problem](https://en.m.wikipedia.org/wiki/Shortest_path_problem). In contrast, in [Longest Path Problem](https://en.m.wikipedia.org/wiki/Longest_path_problem) neither `start` nor `end` is specified. Hence it is very different from this problem.\\n\\n**@stslxg** provids the following perspicacious insight:\\n\\nYou can transform this problem into a shortest path problem by taking - log of each edge.\\nThat is, if the prob on edge (u, v) is x in (0,1), we change it into - log x, which is in (0, +infinity).\\nThen the problem of finding the max prob path is becoming the problem of finding the shortest path in a graph with non-negative weights.\\n\\n----\\n\\n*Q4:* Why did you choose to use `Map.computeIfAbsent(key, mappingFunction)` in Java codes?\\n*A4:* Just for simplicity. In fact, we could use the following two line codes\\n```java\\ng.putIfAbsent(e[0], new HashMap<>());\\ng.get(e[0]).put(e[1], succProb[i]);\\n```\\nto replace\\n```java\\ng.computeIfAbsent(e[0], m -> new HashMap<>()).put(e[1], succProb[i]);\\n```\\nfor more details of `Map.computeIfAbsent(key, mappingFunction)`, plesase refer to \\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#computeIfAbsent(K,java.util.function.Function)\\n\\n**End of Q & A.**\\n\\n----\\n\\nIn case you are NOT familiar with Bellman Ford and Dijkstra\\'s algorithm, the following links are excellent materials for you to learn:\\n\\n**Bellman Ford algorithm:**\\nhttps://algs4.cs.princeton.edu/44sp/\\nhttps://algs4.cs.princeton.edu/44sp/BellmanFordSP.java.html\\nhttps://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture14.pdf\\nhttps://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\\nhttps://www.geeks for geeks.org/bellman-ford-algorithm-dp-23/(remove the 2 spaces among the links to make it valid)\\n\\n**Dijkstra\\'s algorithm:**\\nhttps://algs4.cs.princeton.edu/44sp/\\nhttps://algs4.cs.princeton.edu/44sp/DijkstraSP.java.html\\nhttps://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\\nhttps://www.geeks for geeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/ (remove the 2 spaces among the links to make it valid)\\n\\nSimilar problems:\\n\\n[407. Trapping Rain Water II](https://leetcode.com/problems/trapping-rain-water-ii)\\n[499. The Maze III](https://leetcode.com/problems/the-maze-iii)\\n[505. The Maze II](https://leetcode.com/problems/the-maze-ii)\\n[743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)\\n[778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/description/)\\n[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)\\n[1102. Path With Maximum Minimum Value](https://leetcode.com/problems/path-with-maximum-minimum-value) **Premium**\\n[1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/discuss/731767/JavaPython-3-2-codes%3A-Bellman-Ford-and-Dijkstra\\'s-algorithm-w-brief-explanation-and-analysis.)\\n[1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/discuss/909002/JavaPython-3-3-codes%3A-Binary-Search-Bellman-Ford-and-Dijkstra-w-brief-explanation-and-analysis.)\\n[2290. Minimum Obstacle Removal to Reach Corner](https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/discuss/2085640/JavaPython-3-Shortest-Path-w-brief-explanation-and-analysis.)\\n\\n----\\n\\n**Note:** It is necessary to build a graph in order to quickly locate relevant edges for a specific vertex; otherwise, it would cost too much time, say O(E), to search the input `edges` all way for even one vertex.\\n\\n----\\n**Bellman Ford:**\\n1. Initialize all vertices probabilities as `0`, except `start`, which is `1`;\\n2. Use BFS to traverse all reachable vertices from `start`, update the corresponding probilities whenever we can have a higher probability; otherwise, ignore that vertex; *Note: when forwarding one step, multiply the corresponding `succProb` value with the probaboility of current vertex;*\\n3. Repeat 2 till all probabilities reach their maximum values.\\n4. Return the probability of `end` as solution.\\n\\n```java\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<int[]>> g = new HashMap<>();\\n        for (int i = 0; i < edges.length; ++i) {\\n            int a = edges[i][0], b = edges[i][1];\\n            g.computeIfAbsent(a, l -> new ArrayList<>()).add(new int[]{b, i});\\n            g.computeIfAbsent(b, l -> new ArrayList<>()).add(new int[]{a, i});\\n        }\\n        double[] p = new double[n];\\n        p[start] = 1d;\\n        Queue<Integer> q = new LinkedList<>(Arrays.asList(start));\\n        while (!q.isEmpty()) {\\n            int cur = q.poll();\\n            for (int[] a : g.getOrDefault(cur, Collections.emptyList())) {\\n                int neighbor = a[0], index = a[1];\\n                if (p[cur] * succProb[index] > p[neighbor]) {\\n                    p[neighbor] = p[cur] * succProb[index];\\n                    q.offer(neighbor);\\n                }\\n            }\\n        }\\n        return p[end];\\n    }\\n```\\n```python\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        g, dq = defaultdict(list), deque([start])\\n        for i, (a, b) in enumerate(edges):\\n            g[a].append([b, i])\\n            g[b].append([a, i])\\n        p = [0.0] * n    \\n        p[start] = 1.0\\n        while dq:\\n            cur = dq.popleft()\\n            for neighbor, i in g[cur]:\\n                if p[cur] * succProb[i] > p[neighbor]:\\n                    p[neighbor] = p[cur] * succProb[i]\\n                    dq.append(neighbor)\\n        return p[end]\\n```\\n**Analysis:**\\nTime: O(n * E), space: O(n + E), where E =  edges.length.\\n\\n----\\n\\n**Dijkstra:**\\n1. Initialize all vertices probabilities as `0`, except `start`, which is `1`;\\n2. Put all currently reachable vertices into a Priority Queue/heap, priority ordered by the corresponding current probability, REVERSELY;\\n3. Whenever popped out a vertex with currently highest probability, check if it is the `end` vertex; If yes, we have already found the solution; otherwise, traverse all its neighbors to update neighbors\\' probabilities if necessary; *Note: when forwarding one step, multiply the corresponding `succProb` value with the probaboility of current vertex.*\\n4. Repeat 2 & 3 to find the max probability for `end`; If can NOT, return `0.0d`.\\n```java\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, Map<Integer, Double>> g = new HashMap<>();\\n        for (int i = 0; i < edges.length; ++i) {\\n            int[] e = edges[i];\\n            g.computeIfAbsent(e[0], m -> new HashMap<>()).put(e[1], succProb[i]);\\n            g.computeIfAbsent(e[1], m -> new HashMap<>()).put(e[0], succProb[i]);\\n        }\\n        PriorityQueue<double[]> pq = new PriorityQueue<>(Comparator.comparingDouble(a -> -a[0]));\\n        double[] prob = new double[n];\\n        pq.offer(new double[]{1, start});\\n        while (!pq.isEmpty()) {\\n            double[] cur = pq.poll();\\n            int v = (int)cur[1];\\n            if (v == end) {\\n                return cur[0];\\n            }\\n            if (cur[0] > prob[v]) {\\n                prob[v] = cur[0];\\n                for (var entry : g.getOrDefault(v, Map.of()).entrySet()) {\\n                    int nb = entry.getKey();\\n                    double p = entry.getValue();\\n                    pq.offer(new double[]{cur[0] * p, nb});\\n                }\\n            }\\n        }\\n        return 0d;\\n    }\\n```\\n```python\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        p, g = [0.0] * n, defaultdict(list)\\n        for index, (a, b) in enumerate(edges):\\n            g[a].append((b, index))\\n            g[b].append((a, index))\\n        p[start] = 1.0\\n        heap = [(-p[start], start)]    \\n        while heap:\\n            prob, cur = heapq.heappop(heap)\\n            if cur == end:\\n                return -prob\\n            for neighbor, index in g.get(cur, []):\\n                if -prob * succProb[index] > p[neighbor]:\\n                    p[neighbor] = -prob * succProb[index]\\n                    heapq.heappush(heap, (-p[neighbor], neighbor))\\n        return 0.0\\n```\\n**Analysis:**\\nTime: O((n + E) * logE), space: O(n + E), where E =  edges.length.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n\\tif (p[cur] * succProb[index] > p[neighbor]) {\\n\\t\\tp[neighbor] = p[cur] * succProb[index];\\n\\t\\tq.offer(neighbor);\\n\\t}\\n```\n```java\\ng.putIfAbsent(e[0], new HashMap<>());\\ng.get(e[0]).put(e[1], succProb[i]);\\n```\n```java\\ng.computeIfAbsent(e[0], m -> new HashMap<>()).put(e[1], succProb[i]);\\n```\n```java\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<int[]>> g = new HashMap<>();\\n        for (int i = 0; i < edges.length; ++i) {\\n            int a = edges[i][0], b = edges[i][1];\\n            g.computeIfAbsent(a, l -> new ArrayList<>()).add(new int[]{b, i});\\n            g.computeIfAbsent(b, l -> new ArrayList<>()).add(new int[]{a, i});\\n        }\\n        double[] p = new double[n];\\n        p[start] = 1d;\\n        Queue<Integer> q = new LinkedList<>(Arrays.asList(start));\\n        while (!q.isEmpty()) {\\n            int cur = q.poll();\\n            for (int[] a : g.getOrDefault(cur, Collections.emptyList())) {\\n                int neighbor = a[0], index = a[1];\\n                if (p[cur] * succProb[index] > p[neighbor]) {\\n                    p[neighbor] = p[cur] * succProb[index];\\n                    q.offer(neighbor);\\n                }\\n            }\\n        }\\n        return p[end];\\n    }\\n```\n```python\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        g, dq = defaultdict(list), deque([start])\\n        for i, (a, b) in enumerate(edges):\\n            g[a].append([b, i])\\n            g[b].append([a, i])\\n        p = [0.0] * n    \\n        p[start] = 1.0\\n        while dq:\\n            cur = dq.popleft()\\n            for neighbor, i in g[cur]:\\n                if p[cur] * succProb[i] > p[neighbor]:\\n                    p[neighbor] = p[cur] * succProb[i]\\n                    dq.append(neighbor)\\n        return p[end]\\n```\n```java\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, Map<Integer, Double>> g = new HashMap<>();\\n        for (int i = 0; i < edges.length; ++i) {\\n            int[] e = edges[i];\\n            g.computeIfAbsent(e[0], m -> new HashMap<>()).put(e[1], succProb[i]);\\n            g.computeIfAbsent(e[1], m -> new HashMap<>()).put(e[0], succProb[i]);\\n        }\\n        PriorityQueue<double[]> pq = new PriorityQueue<>(Comparator.comparingDouble(a -> -a[0]));\\n        double[] prob = new double[n];\\n        pq.offer(new double[]{1, start});\\n        while (!pq.isEmpty()) {\\n            double[] cur = pq.poll();\\n            int v = (int)cur[1];\\n            if (v == end) {\\n                return cur[0];\\n            }\\n            if (cur[0] > prob[v]) {\\n                prob[v] = cur[0];\\n                for (var entry : g.getOrDefault(v, Map.of()).entrySet()) {\\n                    int nb = entry.getKey();\\n                    double p = entry.getValue();\\n                    pq.offer(new double[]{cur[0] * p, nb});\\n                }\\n            }\\n        }\\n        return 0d;\\n    }\\n```\n```python\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        p, g = [0.0] * n, defaultdict(list)\\n        for index, (a, b) in enumerate(edges):\\n            g[a].append((b, index))\\n            g[b].append((a, index))\\n        p[start] = 1.0\\n        heap = [(-p[start], start)]    \\n        while heap:\\n            prob, cur = heapq.heappop(heap)\\n            if cur == end:\\n                return -prob\\n            for neighbor, index in g.get(cur, []):\\n                if -prob * succProb[index] > p[neighbor]:\\n                    p[neighbor] = -prob * succProb[index]\\n                    heapq.heappush(heap, (-p[neighbor], neighbor))\\n        return 0.0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 731626,
                "title": "java-detailed-explanation-bfs",
                "content": "**Key notes:**\\n- Markov Chain\\n- Simply BFS, at every stage, you need to remember 2 things: **current node** + **current probability** at this node\\n- One node can be reached from mulitple paths, we cannot simply use a visited array or a set to avoid repeatness.\\n\\t- What we can do is to record \"**best probability so far for each node**\". Then add to queue for BFS only if: it can make a better prob for this current node.\\n# **Bellman Ford Algorithm: BFS with Queue**\\n```java\\nclass State {\\n\\tint node;\\n\\tdouble prob;\\n\\tState(int _node, double _prob) {\\n\\t\\tnode = _node;\\n\\t\\tprob = _prob;\\n\\t}\\n}\\n\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n\\n\\t// build graph -> double[0]: node, double[1]: edge prob\\n\\tMap<Integer, List<double[]>> map = new HashMap<>();\\n\\tfor (int i = 0; i < edges.length; ++i) {\\n\\t\\tint[] edge = edges[i];\\n\\n\\t\\tmap.putIfAbsent(edge[0], new ArrayList<>());\\n\\t\\tmap.putIfAbsent(edge[1], new ArrayList<>());\\n\\n\\t\\tmap.get(edge[0]).add(new double[] {edge[1], succProb[i]});\\n\\t\\tmap.get(edge[1]).add(new double[] {edge[0], succProb[i]});\\n\\t}\\n\\n\\tdouble[] probs = new double[n];  // best prob so far for each node\\n\\tQueue<State> queue = new LinkedList<>();\\n\\tqueue.add(new State(start, 1.0));\\n\\n\\twhile (!queue.isEmpty()) {\\n\\n\\t\\tState state = queue.poll();\\n\\t\\tint parent = state.node;\\n\\t\\tdouble prob = state.prob;\\n\\n\\t\\tfor (double[] child : map.getOrDefault(parent, new ArrayList<>())) {\\n\\t\\t\\t// add to queue only if: it can make a better prob\\n\\t\\t\\tif (probs[(int) child[0]] >= prob * child[1]) continue;\\n\\n\\t\\t\\tqueue.add(new State((int) child[0], prob * child[1]));\\n\\t\\t\\tprobs[(int) child[0]] = prob * child[1];\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn probs[end];\\n}\\n```\\n# **Dijkstra Algorithm: PriorityQueue to Save Some Searches**\\n```java\\nclass State {\\n\\tint node;\\n\\tdouble prob;\\n\\tState(int _node, double _prob) {\\n\\t\\tnode = _node;\\n\\t\\tprob = _prob;\\n\\t}\\n}\\n\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n\\n\\t// build graph -> double[0]: node, double[1]: parent-to-node prob\\n\\tMap<Integer, List<double[]>> map = new HashMap<>();\\n\\tfor (int i = 0; i < edges.length; ++i) {\\n\\t\\tint[] edge = edges[i];\\n\\n\\t\\tmap.putIfAbsent(edge[0], new ArrayList<>());\\n\\t\\tmap.putIfAbsent(edge[1], new ArrayList<>());\\n\\n\\t\\tmap.get(edge[0]).add(new double[] {edge[1], succProb[i]});\\n\\t\\tmap.get(edge[1]).add(new double[] {edge[0], succProb[i]});\\n\\t}\\n\\n\\tdouble[] probs = new double[n];  // best prob so far for each node\\n\\tPriorityQueue<State> pq = new PriorityQueue<>((a, b) -> (((Double) b.prob).compareTo((Double) a.prob)));\\n\\tpq.add(new State(start, 1.0));\\n\\n\\twhile (!pq.isEmpty()) {\\n\\n\\t\\tState state = pq.poll();\\n\\t\\tint parent = state.node;\\n\\t\\tdouble prob = state.prob;\\n\\n\\t\\tif (parent == end) return prob;\\n\\n\\t\\tfor (double[] child : map.getOrDefault(parent, new ArrayList<>())) {\\n\\t\\t\\t// add to pq only if: it can make a better prob\\n\\t\\t\\tif (probs[(int) child[0]] >= prob * child[1]) continue;\\n\\n\\t\\t\\tpq.add(new State((int) child[0], prob * child[1]));\\n\\t\\t\\tprobs[(int) child[0]] = prob * child[1];\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn 0;\\n}\\n```\\n\\n# **Floyd\\u2013Warshall Algorithm for Every Pair of Nodes**\\nIf you want to calculate Maximum Probability for every pair of nodes, **Floyd\\u2013Warshall Algorithm** can help. But it will TLE in this question, just for your reference.\\n```java\\ndouble[][] probs = new double[n][n];\\n\\nfor (int i = 0; i < succProb.length; ++i) {\\n\\tint a = edges[i][0];\\n\\tint b = edges[i][1];\\n\\tprobs[a][b] = probs[b][a] = succProb[i];\\n}\\n\\nfor (int k = 0; k < n; ++k) {\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\tprobs[i][j] = Math.max(probs[i][j], probs[i][k] * probs[k][j]);\\n\\t\\t}\\n\\t}\\n}\\n\\nreturn probs[start][end];\\n```",
                "solutionTags": [],
                "code": "```java\\nclass State {\\n\\tint node;\\n\\tdouble prob;\\n\\tState(int _node, double _prob) {\\n\\t\\tnode = _node;\\n\\t\\tprob = _prob;\\n\\t}\\n}\\n\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n\\n\\t// build graph -> double[0]: node, double[1]: edge prob\\n\\tMap<Integer, List<double[]>> map = new HashMap<>();\\n\\tfor (int i = 0; i < edges.length; ++i) {\\n\\t\\tint[] edge = edges[i];\\n\\n\\t\\tmap.putIfAbsent(edge[0], new ArrayList<>());\\n\\t\\tmap.putIfAbsent(edge[1], new ArrayList<>());\\n\\n\\t\\tmap.get(edge[0]).add(new double[] {edge[1], succProb[i]});\\n\\t\\tmap.get(edge[1]).add(new double[] {edge[0], succProb[i]});\\n\\t}\\n\\n\\tdouble[] probs = new double[n];  // best prob so far for each node\\n\\tQueue<State> queue = new LinkedList<>();\\n\\tqueue.add(new State(start, 1.0));\\n\\n\\twhile (!queue.isEmpty()) {\\n\\n\\t\\tState state = queue.poll();\\n\\t\\tint parent = state.node;\\n\\t\\tdouble prob = state.prob;\\n\\n\\t\\tfor (double[] child : map.getOrDefault(parent, new ArrayList<>())) {\\n\\t\\t\\t// add to queue only if: it can make a better prob\\n\\t\\t\\tif (probs[(int) child[0]] >= prob * child[1]) continue;\\n\\n\\t\\t\\tqueue.add(new State((int) child[0], prob * child[1]));\\n\\t\\t\\tprobs[(int) child[0]] = prob * child[1];\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn probs[end];\\n}\\n```\n```java\\nclass State {\\n\\tint node;\\n\\tdouble prob;\\n\\tState(int _node, double _prob) {\\n\\t\\tnode = _node;\\n\\t\\tprob = _prob;\\n\\t}\\n}\\n\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n\\n\\t// build graph -> double[0]: node, double[1]: parent-to-node prob\\n\\tMap<Integer, List<double[]>> map = new HashMap<>();\\n\\tfor (int i = 0; i < edges.length; ++i) {\\n\\t\\tint[] edge = edges[i];\\n\\n\\t\\tmap.putIfAbsent(edge[0], new ArrayList<>());\\n\\t\\tmap.putIfAbsent(edge[1], new ArrayList<>());\\n\\n\\t\\tmap.get(edge[0]).add(new double[] {edge[1], succProb[i]});\\n\\t\\tmap.get(edge[1]).add(new double[] {edge[0], succProb[i]});\\n\\t}\\n\\n\\tdouble[] probs = new double[n];  // best prob so far for each node\\n\\tPriorityQueue<State> pq = new PriorityQueue<>((a, b) -> (((Double) b.prob).compareTo((Double) a.prob)));\\n\\tpq.add(new State(start, 1.0));\\n\\n\\twhile (!pq.isEmpty()) {\\n\\n\\t\\tState state = pq.poll();\\n\\t\\tint parent = state.node;\\n\\t\\tdouble prob = state.prob;\\n\\n\\t\\tif (parent == end) return prob;\\n\\n\\t\\tfor (double[] child : map.getOrDefault(parent, new ArrayList<>())) {\\n\\t\\t\\t// add to pq only if: it can make a better prob\\n\\t\\t\\tif (probs[(int) child[0]] >= prob * child[1]) continue;\\n\\n\\t\\t\\tpq.add(new State((int) child[0], prob * child[1]));\\n\\t\\t\\tprobs[(int) child[0]] = prob * child[1];\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn 0;\\n}\\n```\n```java\\ndouble[][] probs = new double[n][n];\\n\\nfor (int i = 0; i < succProb.length; ++i) {\\n\\tint a = edges[i][0];\\n\\tint b = edges[i][1];\\n\\tprobs[a][b] = probs[b][a] = succProb[i];\\n}\\n\\nfor (int k = 0; k < n; ++k) {\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\tprobs[i][j] = Math.max(probs[i][j], probs[i][k] * probs[k][j]);\\n\\t\\t}\\n\\t}\\n}\\n\\nreturn probs[start][end];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731706,
                "title": "c-modified-djikstra-o-edges-log-n-max-heap-explanations",
                "content": "Note : In general djikstra algorithm, you will find the shortest path from `start` to `end` and update the \"minimum distance\" array accordingly for each \"from -> to\" pair.\\n\\nHere I am doing the same except the probablity array (`mx`) only stores the maximum probablity in each case and it\\'s compared in this line of the code :\\n\\nTime Complexity : `O(edges*log(n))`\\nSpace Complexity: `O(n)`\\n```\\nif (mx[to.first] < to.second*proba) {\\n\\tmx[to.first] = to.second*proba;\\n    q.push({mx[to.first], to.first});\\n}\\n```\\n\\nThe C++ Code ->\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& pro, int start, int end) {\\n        vector<vector<pair<int, double>>> g(n);\\n        for(int i=0; i<edges.size(); i++) {\\n            g[edges[i][0]].push_back({edges[i][1], pro[i]});\\n            g[edges[i][1]].push_back({edges[i][0], pro[i]});   \\n        }\\n        vector<int> seen(n, 0);\\n        \\n        priority_queue<pair<double, int>> q;\\n        q.push({(double)1.0, start});\\n        \\n        vector<double> mx(n, (double)0.0);\\n        mx[start] = 1.0;\\n        \\n        while(!q.empty()) {\\n            auto top = q.top();\\n            q.pop();\\n            double proba = top.first;\\n            int node = top.second;\\n            if(!seen[node]) {\\n                seen[node]++;\\n                for(auto &to: g[node]) {\\n                    if (mx[to.first] < to.second*proba) {\\n                        mx[to.first] = to.second*proba;\\n\\t\\t\\t\\t\\t\\tq.push({mx[to.first], to.first});\\n                    }\\n                }\\n            }\\n        }\\n        return mx[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nif (mx[to.first] < to.second*proba) {\\n\\tmx[to.first] = to.second*proba;\\n    q.push({mx[to.first], to.first});\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& pro, int start, int end) {\\n        vector<vector<pair<int, double>>> g(n);\\n        for(int i=0; i<edges.size(); i++) {\\n            g[edges[i][0]].push_back({edges[i][1], pro[i]});\\n            g[edges[i][1]].push_back({edges[i][0], pro[i]});   \\n        }\\n        vector<int> seen(n, 0);\\n        \\n        priority_queue<pair<double, int>> q;\\n        q.push({(double)1.0, start});\\n        \\n        vector<double> mx(n, (double)0.0);\\n        mx[start] = 1.0;\\n        \\n        while(!q.empty()) {\\n            auto top = q.top();\\n            q.pop();\\n            double proba = top.first;\\n            int node = top.second;\\n            if(!seen[node]) {\\n                seen[node]++;\\n                for(auto &to: g[node]) {\\n                    if (mx[to.first] < to.second*proba) {\\n                        mx[to.first] = to.second*proba;\\n\\t\\t\\t\\t\\t\\tq.push({mx[to.first], to.first});\\n                    }\\n                }\\n            }\\n        }\\n        return mx[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731538,
                "title": "python-o-len-edges-log-n-dijkstra-s-algorithm-with-explanations",
                "content": "The idea here is to apply Dijkstra\\'s Algorithm in an efficient way. Now, if the probability of an edge is `p`, we make the weight of that edge as `log2(1/p)`. This is because we want to find the path with max probability, i.e, we want to find the path with min inverse probabilities. Now, since Dijkstra\\'s algorithm uses sum of the weights we use `log2` so that later on we can get the product of the probabilities. \\n\\n\\n```python\\nfrom heapq import heappush, heappop\\nfrom math import log2\\n\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        AdjList = [set() for _ in range(n)]\\n        for (u, v), p in zip(edges, succProb):\\n            AdjList[u].add((v, log2(1/p)))\\n            AdjList[v].add((u, log2(1/p)))\\n        dist = [float(\\'inf\\') for _ in range(n)]\\n        dist[start] = 0\\n        h = [(0, start)]\\n        while h:\\n            d, u = heappop(h)\\n            if d == dist[u]:\\n                for (v, p) in AdjList[u]:\\n                    if dist[u] + p < dist[v]:\\n                        dist[v] = dist[u] + p\\n                        heappush(h, (dist[v], v))\\n        return 1 / (2 ** dist[end])\\n```\\n\\nPlease `upvote` if u find this useful. ^_^ .",
                "solutionTags": [],
                "code": "```python\\nfrom heapq import heappush, heappop\\nfrom math import log2\\n\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        AdjList = [set() for _ in range(n)]\\n        for (u, v), p in zip(edges, succProb):\\n            AdjList[u].add((v, log2(1/p)))\\n            AdjList[v].add((u, log2(1/p)))\\n        dist = [float(\\'inf\\') for _ in range(n)]\\n        dist[start] = 0\\n        h = [(0, start)]\\n        while h:\\n            d, u = heappop(h)\\n            if d == dist[u]:\\n                for (v, p) in AdjList[u]:\\n                    if dist[u] + p < dist[v]:\\n                        dist[v] = dist[u] + p\\n                        heappush(h, (dist[v], v))\\n        return 1 / (2 ** dist[end])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731544,
                "title": "c-bfs-explanation-in-comments",
                "content": "```\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        //create own graph\\n        vector<unordered_map<int, double>> graph(n);\\n        for(int i = 0; i < edges.size(); ++i) {\\n            graph[edges[i][0]][edges[i][1]] = succProb[i];\\n            graph[edges[i][1]][edges[i][0]] = succProb[i];\\n        }\\n        \\n        //functionality wise, this array works as a visited array, \\n        //only when we find a larger probability than the stored value\\n        //we will need to push next node into the queue\\n        vector<double> ps(n, 0.0);  ///probability of reaching each node\\n        \\n        ps[start] = 1.0; //important intilization\\n        \\n        queue<int> q;\\n        q.push(start);\\n        double res = 0;\\n        while(!q.empty()) {\\n            int nd = q.front();\\n            q.pop();\\n            for(auto& it: graph[nd]) {\\n                int next = it.first;\\n                double pro = it.second;\\n                //ok, we can reach this node with a larger probability, try starting from it\\n                //a node might be pushed into the queue more than once\\n                if(ps[nd] * pro > ps[next]) {\\n                    q.push(next);\\n                    ps[next] = ps[nd] * pro;\\n                }\\n            }\\n        }\\n        \\n        return ps[end];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        //create own graph\\n        vector<unordered_map<int, double>> graph(n);\\n        for(int i = 0; i < edges.size(); ++i) {\\n            graph[edges[i][0]][edges[i][1]] = succProb[i];\\n            graph[edges[i][1]][edges[i][0]] = succProb[i];\\n        }\\n        \\n        //functionality wise, this array works as a visited array, \\n        //only when we find a larger probability than the stored value\\n        //we will need to push next node into the queue\\n        vector<double> ps(n, 0.0);  ///probability of reaching each node\\n        \\n        ps[start] = 1.0; //important intilization\\n        \\n        queue<int> q;\\n        q.push(start);\\n        double res = 0;\\n        while(!q.empty()) {\\n            int nd = q.front();\\n            q.pop();\\n            for(auto& it: graph[nd]) {\\n                int next = it.first;\\n                double pro = it.second;\\n                //ok, we can reach this node with a larger probability, try starting from it\\n                //a node might be pushed into the queue more than once\\n                if(ps[nd] * pro > ps[next]) {\\n                    q.push(next);\\n                    ps[next] = ps[nd] * pro;\\n                }\\n            }\\n        }\\n        \\n        return ps[end];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731655,
                "title": "python3-dijkstra-s-algo",
                "content": "Algo\\nThe solution is based on Dijkstra\\'s algo. Starting from `start`, we push all unvisited points to a heap. At each step, we pop out the one with highest probability and mark the node \"visited\". Iteratively perform such operations until reaching `end`. If `end` is not reachable, return 0. \\n\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph, prob = dict(), dict() #graph with prob\\n        for i, (u, v) in enumerate(edges):\\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n            prob[u, v] = prob[v, u] = succProb[i]\\n        \\n        h = [(-1, start)] #Dijkstra\\'s algo\\n        seen = set()\\n        while h: \\n            p, n = heappop(h)\\n            if n == end: return -p\\n            seen.add(n)\\n            for nn in graph.get(n, []):\\n                if nn in seen: continue \\n                heappush(h, (p * prob.get((n, nn), 0), nn))\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph, prob = dict(), dict() #graph with prob\\n        for i, (u, v) in enumerate(edges):\\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n            prob[u, v] = prob[v, u] = succProb[i]\\n        \\n        h = [(-1, start)] #Dijkstra\\'s algo\\n        seen = set()\\n        while h: \\n            p, n = heappop(h)\\n            if n == end: return -p\\n            seen.add(n)\\n            for nn in graph.get(n, []):\\n                if nn in seen: continue \\n                heappush(h, (p * prob.get((n, nn), 0), nn))\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732667,
                "title": "logarithm-dijkstra-great-idea",
                "content": "There is a bit of a math involved in this. \\n\\n1. Convert your probabilities to log space (the log base doesn\\'t matter). \\n2. The probability of a path becomes the sum of the log space weights (because log(ab) = log(a) + log(b) . Since the weights/probabilities are < 1 the weights in log space will all be negative and the path has the highest weight.\\n3. To bring it more into the regular problem you can negate all the log space weights so that they are all positive and you are looking for the lowest sum. At this point you can run standard algorithms (Dijkstra would be simple and very fast) to find the path you are looking for. \\n4. If you have the sum then negate it and calculate exponential to get the probability.\\nPS: Replace all weight w with -log(w) and run Dijkstra with the new weights.\\n\\n\\n```\\n\\tstatic class Node {\\n        public int node;\\n        public double cost;\\n\\n        public Node() {\\n        }\\n\\n        public Node(int node, double cost) {\\n            this.node = node;\\n            this.cost = cost;\\n        }\\n    }\\n\\n    private double[] dist; // single source shortest distance\\n    private Set<Integer> settled;\\n    private PriorityQueue<Node> pq;\\n    private int V; // Number of vertices\\n    List<List<Node>> adj; // adjacency list\\n\\n    // Function for Dijkstra\\'s Algorithm\\n    public void dijkstra(int src) {\\n\\n        for (int i = 0; i < V; i++)\\n            dist[i] = Integer.MAX_VALUE;\\n\\n        // Add source node to the priority queue\\n        pq.add(new Node(src, 0.0));\\n\\n        // Distance to the source is 0\\n        dist[src] = 0;\\n        while (settled.size() != V && !pq.isEmpty()) {\\n\\n            // remove the minimum distance node\\n            // from the priority queue\\n            int u = pq.remove().node;\\n\\n            // adding the node whose distance is\\n            // finalized\\n            settled.add(u);\\n\\n            exploreNeighbours(u);\\n        }\\n    }\\n\\n    // Function to process all the neighbours\\n    // of the passed node\\n    private void exploreNeighbours(int u) {\\n        // All the neighbors of v\\n        for (int i = 0; i < adj.get(u).size(); i++) {\\n            Node v = adj.get(u).get(i);\\n\\n            // If current node hasn\\'t already been processed\\n            if (!settled.contains(v.node)) {\\n                double edgeDistance = v.cost;\\n                double newDistance = dist[u] + edgeDistance;\\n\\n                // If new distance is cheaper in cost\\n                if (newDistance < dist[v.node])\\n                    dist[v.node] = newDistance;\\n\\n                // Add the current node to the queue\\n                pq.add(new Node(v.node, dist[v.node]));\\n            }\\n        }\\n    }\\n\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        this.V = n;\\n        dist = new double[n];\\n        settled = new HashSet<>();\\n        pq = new PriorityQueue<>(V, Comparator.comparingDouble(a -> a.cost)); // Take a note, Has a comparator.\\n        adj = new ArrayList<>(n);\\n\\n        for (int i = 0; i < n; ++i) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < edges.length; ++i) {\\n            if (edges[i].length > 0) {\\n                int u = edges[i][0], v = edges[i][1];\\n                adj.get(u).add(new Node(v, Math.log10(succProb[i]) * -1));\\n                adj.get(v).add(new Node(u, Math.log10(succProb[i]) * -1));\\n            }\\n        }\\n        dijkstra(start);\\n        return Math.pow(10, -1 * dist[end]);\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\tstatic class Node {\\n        public int node;\\n        public double cost;\\n\\n        public Node() {\\n        }\\n\\n        public Node(int node, double cost) {\\n            this.node = node;\\n            this.cost = cost;\\n        }\\n    }\\n\\n    private double[] dist; // single source shortest distance\\n    private Set<Integer> settled;\\n    private PriorityQueue<Node> pq;\\n    private int V; // Number of vertices\\n    List<List<Node>> adj; // adjacency list\\n\\n    // Function for Dijkstra\\'s Algorithm\\n    public void dijkstra(int src) {\\n\\n        for (int i = 0; i < V; i++)\\n            dist[i] = Integer.MAX_VALUE;\\n\\n        // Add source node to the priority queue\\n        pq.add(new Node(src, 0.0));\\n\\n        // Distance to the source is 0\\n        dist[src] = 0;\\n        while (settled.size() != V && !pq.isEmpty()) {\\n\\n            // remove the minimum distance node\\n            // from the priority queue\\n            int u = pq.remove().node;\\n\\n            // adding the node whose distance is\\n            // finalized\\n            settled.add(u);\\n\\n            exploreNeighbours(u);\\n        }\\n    }\\n\\n    // Function to process all the neighbours\\n    // of the passed node\\n    private void exploreNeighbours(int u) {\\n        // All the neighbors of v\\n        for (int i = 0; i < adj.get(u).size(); i++) {\\n            Node v = adj.get(u).get(i);\\n\\n            // If current node hasn\\'t already been processed\\n            if (!settled.contains(v.node)) {\\n                double edgeDistance = v.cost;\\n                double newDistance = dist[u] + edgeDistance;\\n\\n                // If new distance is cheaper in cost\\n                if (newDistance < dist[v.node])\\n                    dist[v.node] = newDistance;\\n\\n                // Add the current node to the queue\\n                pq.add(new Node(v.node, dist[v.node]));\\n            }\\n        }\\n    }\\n\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        this.V = n;\\n        dist = new double[n];\\n        settled = new HashSet<>();\\n        pq = new PriorityQueue<>(V, Comparator.comparingDouble(a -> a.cost)); // Take a note, Has a comparator.\\n        adj = new ArrayList<>(n);\\n\\n        for (int i = 0; i < n; ++i) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < edges.length; ++i) {\\n            if (edges[i].length > 0) {\\n                int u = edges[i][0], v = edges[i][1];\\n                adj.get(u).add(new Node(v, Math.log10(succProb[i]) * -1));\\n                adj.get(v).add(new Node(u, Math.log10(succProb[i]) * -1));\\n            }\\n        }\\n        dijkstra(start);\\n        return Math.pow(10, -1 * dist[end]);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731607,
                "title": "c-bfs",
                "content": "This is similar to Dijkstra, but instead of adding distance we multiply probabilities.\\n\\nWe store our travel probabilities in an adjacency list `al`. The maximum probability of reaching each node is recorded in `prob`. Note that `prob[start] == 1`.\\n\\nWe start with `start` and do DFS. For each node `from` in the queue, we process its neighbors and add them to the queue. Note that we add a neighbor `to` only if the highest probability of reaching it (`prob[to]`) is less than probability of reaching `to` from `from`.\\n\\n```cpp\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n    vector<vector<pair<int, double>>> al(n);\\n    for (auto i = 0; i < edges.size(); ++i) {\\n        if (succProb[i] != 0) {\\n            al[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            al[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n    }\\n    vector<double> probs(n);\\n    probs[start] = 1;\\n    vector<int> q{start};\\n    while(!q.empty()) {\\n        vector<int> q1;\\n        for (auto from : q) {\\n            for (auto [to, prob] : al[from]) {\\n                if (probs[to] < probs[from] * prob) {\\n                    probs[to] = probs[from] * prob;\\n                    q1.push_back(to);\\n                }\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return probs[end];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n    vector<vector<pair<int, double>>> al(n);\\n    for (auto i = 0; i < edges.size(); ++i) {\\n        if (succProb[i] != 0) {\\n            al[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            al[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n    }\\n    vector<double> probs(n);\\n    probs[start] = 1;\\n    vector<int> q{start};\\n    while(!q.empty()) {\\n        vector<int> q1;\\n        for (auto from : q) {\\n            for (auto [to, prob] : al[from]) {\\n                if (probs[to] < probs[from] * prob) {\\n                    probs[to] = probs[from] * prob;\\n                    q1.push_back(to);\\n                }\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return probs[end];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731659,
                "title": "python-djikstra-with-explanation",
                "content": "Time Complexity - O(E logV)\\n\\nThis can be solved using standard Djikstra\\'s algorithm with a slight difference in how we calculate the weight.\\n\\nIn the usual algorithm, in each step we try to get the vertex with the min distance to it.\\nHere, all we need to do is change that to the next vertex with the max probability.\\n\\nSo, we use a max heap and instead of sums of distances, we use products of the probabilites of each edge.\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = self.build_graph(edges, succProb)\\n        seen = set()\\n        \\n\\t\\t# Start with 1 since we are dealing with probabilites.\\n\\t\\t# -ve sign to make python\\'s min heap work as a max heap\\n        max_heap = [(-1, start)]\\n        \\n        while max_heap:\\n            prob, cur = heappop(max_heap)\\n\\t\\t\\t# Maintain a seen set so that we do not visit a vertex we already processed\\n\\t\\t\\t# This is to avoid putting us in an infinite loop since a path from start to end is not always guaranteed\\n            seen.add(cur)\\n            if cur == end:\\n                return -prob\\n            for neigh, p in graph.get(cur, []):\\n                if not neigh in seen:\\n                    new_prob = -1 * abs(prob*p)\\n                    heappush(max_heap, (new_prob, neigh))\\n\\t\\t\\t\\t\\t\\n\\t\\t# No path from start to end\\n        return 0\\n    \\n    def build_graph(self, edges, succProb):\\n        graph = {}\\n        for i in range(len(edges)):\\n            cur_edge = edges[i]\\n            cur_prob = succProb[i]\\n            graph.setdefault(cur_edge[0], []).append((cur_edge[1], cur_prob))\\n            graph.setdefault(cur_edge[1], []).append((cur_edge[0], cur_prob))\\n        return graph\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = self.build_graph(edges, succProb)\\n        seen = set()\\n        \\n\\t\\t# Start with 1 since we are dealing with probabilites.\\n\\t\\t# -ve sign to make python\\'s min heap work as a max heap\\n        max_heap = [(-1, start)]\\n        \\n        while max_heap:\\n            prob, cur = heappop(max_heap)\\n\\t\\t\\t# Maintain a seen set so that we do not visit a vertex we already processed\\n\\t\\t\\t# This is to avoid putting us in an infinite loop since a path from start to end is not always guaranteed\\n            seen.add(cur)\\n            if cur == end:\\n                return -prob\\n            for neigh, p in graph.get(cur, []):\\n                if not neigh in seen:\\n                    new_prob = -1 * abs(prob*p)\\n                    heappush(max_heap, (new_prob, neigh))\\n\\t\\t\\t\\t\\t\\n\\t\\t# No path from start to end\\n        return 0\\n    \\n    def build_graph(self, edges, succProb):\\n        graph = {}\\n        for i in range(len(edges)):\\n            cur_edge = edges[i]\\n            cur_prob = succProb[i]\\n            graph.setdefault(cur_edge[0], []).append((cur_edge[1], cur_prob))\\n            graph.setdefault(cur_edge[1], []).append((cur_edge[0], cur_prob))\\n        return graph\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731614,
                "title": "java-dijkstra",
                "content": "Reason to of HashSet vs:\\npriorityqueue always poll the searched node with highest prob, and put it in vs. since any revisit of this node later will be with lower prob, where we skip it for a better performance.\\n\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        PriorityQueue<double[]> pq = new PriorityQueue<double[]>((a, b) -> ((int)((b[1] - a[1]) * 1000000000)));\\n        Map<Integer, Map<Integer, Double>> g = buildGraph(edges, succProb);\\n        pq.offer(new double[]{start, 1.0});\\n        Set<Integer> vs = new HashSet<>();\\n        Map<Integer, Double> probs = new HashMap<>();\\n        probs.put(start, 1.0);\\n        while (!pq.isEmpty()){\\n            double[] curr = pq.poll();\\n            if (vs.contains((int) curr[0])) continue;\\n            vs.add((int) curr[0]);\\n            if (((int) curr[0]) == end) return curr[1];\\n            for (int neig : g.getOrDefault((int) curr[0], new HashMap<>()).keySet()) {\\n                if (vs.contains(neig)) continue;\\n                double prob = curr[1] * g.get((int) curr[0]).get(neig);\\n                if (prob > probs.getOrDefault(neig, 0.0)) {\\n                    probs.put(neig, prob);\\n                    pq.offer(new double[]{neig, prob});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    private Map<Integer, Map<Integer, Double>> buildGraph(int[][] edges, double[] succProb) {\\n        Map<Integer, Map<Integer, Double>> g = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            g.computeIfAbsent(edges[i][0], k -> new HashMap<>());\\n            g.computeIfAbsent(edges[i][1], k -> new HashMap<>());\\n            g.get(edges[i][0]).put(edges[i][1], succProb[i]);\\n            g.get(edges[i][1]).put(edges[i][0], succProb[i]);\\n        }\\n        return g;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        PriorityQueue<double[]> pq = new PriorityQueue<double[]>((a, b) -> ((int)((b[1] - a[1]) * 1000000000)));\\n        Map<Integer, Map<Integer, Double>> g = buildGraph(edges, succProb);\\n        pq.offer(new double[]{start, 1.0});\\n        Set<Integer> vs = new HashSet<>();\\n        Map<Integer, Double> probs = new HashMap<>();\\n        probs.put(start, 1.0);\\n        while (!pq.isEmpty()){\\n            double[] curr = pq.poll();\\n            if (vs.contains((int) curr[0])) continue;\\n            vs.add((int) curr[0]);\\n            if (((int) curr[0]) == end) return curr[1];\\n            for (int neig : g.getOrDefault((int) curr[0], new HashMap<>()).keySet()) {\\n                if (vs.contains(neig)) continue;\\n                double prob = curr[1] * g.get((int) curr[0]).get(neig);\\n                if (prob > probs.getOrDefault(neig, 0.0)) {\\n                    probs.put(neig, prob);\\n                    pq.offer(new double[]{neig, prob});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    private Map<Integer, Map<Integer, Double>> buildGraph(int[][] edges, double[] succProb) {\\n        Map<Integer, Map<Integer, Double>> g = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            g.computeIfAbsent(edges[i][0], k -> new HashMap<>());\\n            g.computeIfAbsent(edges[i][1], k -> new HashMap<>());\\n            g.get(edges[i][0]).put(edges[i][1], succProb[i]);\\n            g.get(edges[i][1]).put(edges[i][0], succProb[i]);\\n        }\\n        return g;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731776,
                "title": "java-60ms-beat-100-20-lines-clean-clode-using-dijkstra-algorithm-o-e-logv",
                "content": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        List<Map<Integer, Double>> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) list.add(new HashMap<>());\\n        for (int i = 0; i < edges.length; i++) {\\n            list.get(edges[i][0]).put(edges[i][1], succProb[i]);\\n            list.get(edges[i][1]).put(edges[i][0], succProb[i]);\\n        }\\n        PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[1], a[1]));\\n        Set<Integer> visited = new HashSet<>();\\n        pq.offer(new double[]{start, 1});\\n        \\n        while (!pq.isEmpty()) {\\n            double[] cur = pq.poll();\\n            int node = (int)cur[0];\\n            double prob = cur[1];\\n            if (node == end) return prob;\\n            \\n            if (!visited.add(node)) continue;\\n            \\n            for (Map.Entry<Integer, Double> next: list.get(node).entrySet()) {\\n                pq.offer(new double[]{next.getKey(), prob * next.getValue()});\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        List<Map<Integer, Double>> list = new ArrayList<>();\\n        for (int i = 0; i < n; i++) list.add(new HashMap<>());\\n        for (int i = 0; i < edges.length; i++) {\\n            list.get(edges[i][0]).put(edges[i][1], succProb[i]);\\n            list.get(edges[i][1]).put(edges[i][0], succProb[i]);\\n        }\\n        PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[1], a[1]));\\n        Set<Integer> visited = new HashSet<>();\\n        pq.offer(new double[]{start, 1});\\n        \\n        while (!pq.isEmpty()) {\\n            double[] cur = pq.poll();\\n            int node = (int)cur[0];\\n            double prob = cur[1];\\n            if (node == end) return prob;\\n            \\n            if (!visited.add(node)) continue;\\n            \\n            for (Map.Entry<Integer, Double> next: list.get(node).entrySet()) {\\n                pq.offer(new double[]{next.getKey(), prob * next.getValue()});\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691291,
                "title": "c-code-with-comments-dijkstra-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n]; //Creating adjacency list\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>>pq; //Use maxHeap for path with the maximum probability\\n        pq.push({1.0,start}); //{probability,node}\\n        vector<double>dist(n,INT_MIN);\\n        dist[start]=1;\\n        while(!pq.empty()){\\n            auto itr=pq.top();\\n            pq.pop();\\n            double dis=itr.first;\\n            int node=itr.second;\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                double edW=it.second;\\n                if(dist[adjNode]<dis*edW){ //If greater probability is found then update probability of adjacent node & push adjacent node in maxHeap\\n                    dist[adjNode]=dis*edW;\\n                    pq.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }        \\n        if(dist[end]==INT_MIN) return 0.00000; //If there is no path from start to end\\n        else return dist[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n]; //Creating adjacency list\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>>pq; //Use maxHeap for path with the maximum probability\\n        pq.push({1.0,start}); //{probability,node}\\n        vector<double>dist(n,INT_MIN);\\n        dist[start]=1;\\n        while(!pq.empty()){\\n            auto itr=pq.top();\\n            pq.pop();\\n            double dis=itr.first;\\n            int node=itr.second;\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                double edW=it.second;\\n                if(dist[adjNode]<dis*edW){ //If greater probability is found then update probability of adjacent node & push adjacent node in maxHeap\\n                    dist[adjNode]=dis*edW;\\n                    pq.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }        \\n        if(dist[end]==INT_MIN) return 0.00000; //If there is no path from start to end\\n        else return dist[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381633,
                "title": "dijkstra-s-algorithm-using-max-heap",
                "content": "*IMPORTANT*\\nUse dijkstra algo\\nUse Max priority queue instead of min\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<vector<pair<int, double>>> graph(n);\\n        vector<double> maxProbablity(n, 0);\\n        priority_queue<pair<double, int>> pq;\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            graph[edges[i][1]].push_back({edges[i][0], succProb[i]});   \\n        }\\n    \\n        pq.push({1.0, start});\\n        \\n           // can\\'t intiaize it with 0 as it we are using multiplication\\n        maxProbablity[start] = 1;  \\n        \\n        while(!pq.empty()){\\n            int current = pq.top().second;\\n            double prevProbability = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto it : graph[current]){\\n                if(prevProbability * it.second > maxProbablity[it.first]){\\n                    maxProbablity[it.first] = prevProbability * it.second;\\n                    pq.push(make_pair(maxProbablity[it.first], it.first));\\n                }\\n            }\\n        }\\n        \\n        return maxProbablity[end];\\n    }\\n};\\n\\nComment Down it\\'s time complexity in an intuitive manner.\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<vector<pair<int, double>>> graph(n);\\n        vector<double> maxProbablity(n, 0);\\n        priority_queue<pair<double, int>> pq;\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][0]].push_back({edges[i][1], succProb[i]}",
                "codeTag": "Java"
            },
            {
                "id": 732293,
                "title": "dijkstra-s-algorithm-implementation-c",
                "content": "I know Dijkstra\\'s algorithm isn\\'t the best solution for this problem, but it passes any way. I believe the implementataion of Dijkstra\\'s algorithm isn\\'t straight-forward for most people. This post tries to show different C++ implementations.\\n```C++\\n/**\\n * Dijkstra\\'s algorithm. \\n * In essence, Dijkstra\\'s algorithm maintains two sets: one set of nodes whose\\n * distance from source is NOT finalized, one set of nodes whose distance\\n * from source IS finalized. \\n * In implementation, we keep track of the two sets explicitly or implicitly. \\n * \\n * Reference: \\n * https://www.***.org/dijkstras-shortest-path-algorithm-greedy-algo-7/\\n */\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n// Helper functions\\nvector<vector<pair<int, int>>> buildGraph(int n, vector<vector<int>>& edges, vector<int>& weights) {\\n    vector<vector<pair<int, int>>> graph(n);\\n    for (int i = 0; i < edges.size(); i++) {\\n        vector<int> edge = edges[i];\\n        graph[edge[0]].push_back({edge[1], weights[i]});\\n        graph[edge[1]].push_back({edge[0], weights[i]});\\n    }\\n    return graph;\\n}\\n\\nvoid printSolution(vector<int>& dist) {\\n    printf(\"Vertex \\\\t\\\\t Distance from Source\\\\n\");\\n    for (int i = 0; i < dist.size(); i++)\\n        printf(\"%d \\\\t\\\\t %d\\\\n\", i, dist[i]);\\n}\\n\\nclass Solution {\\n   public:\\n    /**\\n     * - Input: adjacency matrix. \\n     * - Data structure: Only vector: `finalized` array.\\n     * - Time complexity: O(V^2). Each iteration of outer loop marks one node as\\n     * finalized, in total V iterations. Each iteration of inner loop is O(V). \\n     * - Note: the inner loop does two main things: (1) Finding un-finalized \\n     * node of min distance, and (2) iterating through neighbors. If we use\\n     * adjacency list instead of adjacency matrix, exactly E neighbors would\\n     * be iterated through for (2). If we consider (1) and (2) separately, this\\n     * reduces time from O(V^2) + O(V^2) to O(V^2) + O(E). \\n     * - Reference: https://www.***.org/dijkstras-shortest-path-algorithm-greedy-algo-7/\\n     */\\n    void naiveMatrix(vector<vector<int>>& graph, int src) {\\n        int n = graph.size();\\n        vector<int> dist(n, INT_MAX);      // distance from source\\n        vector<bool> finalized(n, false);  // if the distance is finalized\\n        dist[src] = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Get UN-finalized node with min distance\\n            int minDis = INT_MAX, minIndex;\\n            for (int node = 0; node < n; node++) {\\n                if (!finalized[node] && dist[node] < minDis) {\\n                    minDis = dist[node];\\n                    minIndex = node;\\n                }\\n            }\\n\\n            // Distance to this node is finalized\\n            finalized[minIndex] = true;\\n\\n            // Update it\\'s neighbors, IF UN-finazlied\\n            for (int node = 0; node < n; node++) {\\n                if (!finalized[node] && graph[minIndex][node] &&\\n                    dist[minIndex] + graph[minIndex][node] < dist[node]) {\\n                    dist[node] = dist[minIndex] + graph[minIndex][node];\\n                }\\n            }\\n        }\\n        printSolution(dist);\\n    }\\n\\n    /**\\n     * - Input: adjacency list.\\n     * - Data structure: set in C++: `unfinalized` set.\\n     * - Time complexity: O(E * logV). Set operation is O(logV). The outer loop\\n     * is executed V times, so extracting min takes O(VlogV). The inner for \\n     * loop is executed, in total, E times. The reason is that each edge is\\n     * traversed at most twice in the algorithm: When a edge is traversed, it \\n     * means one of its endpoint is finalized. The next time this edge is\\n     * traversed, it means the other endpoint is finalized. So the total time\\n     * is O(2ElogV + VlogV). As E >= V-1, time complexity is O(ElogV).\\n     * - Note: as mentioned in previous approach, adjacency list enables more \\n     * efficient traversal over neighbors. C++ set enables finding unfinalized \\n     * node with min distance in constant time, with O(logV) for insertion or \\n     * deletion. https://stackoverflow.com/a/54537313/9057530\\n     * In Dijkstra\\u2019s algorithm, we need a priority queue and below operations:\\n     *   ExtractMin: from vertices whose shortest distance is not finalized.\\n     *   DecreaseKey: Update distance for neighbors.\\n     * C++ STL set keeps all its keys in sorted order, so min distant vertex \\n     * will always be at beginning, which is the ExtractMin operation. Updating \\n     * other adjacent vertex can be done by deleting its previous entry and \\n     * insert new updated entry, which is DecreaseKey operation.\\n     * The implementation is slightly different from the link: we add all nodes\\n     * to `unfinalized` at the beginning.\\n     * - Reference: https://www.***.org/dijkstras-shortest-path-algorithm-using-set-in-stl/\\n     */\\n    void setList(vector<vector<pair<int, int>>>& graph, int src) {\\n        // graph: each pair<int, int> is <node, weight>\\n        int n = graph.size();\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        set<pair<int, int>> unfinalized;  // <distance, node>\\n        for (int node = 0; node < n; node++)\\n            unfinalized.insert({node == src ? 0 : INT_MAX, node});\\n\\n        while (!unfinalized.empty()) {\\n            pair<int, int> p = *(unfinalized.begin());\\n            unfinalized.erase(unfinalized.begin());\\n            int u = p.second;\\n\\n            for (int i = 0; i < graph[u].size(); i++) {\\n                int v = graph[u][i].first, weight = graph[u][i].second;\\n                if (dist[u] + weight < dist[v]) {\\n                    // v cannot be finalized, so must be in finalized\\n                    unfinalized.erase(unfinalized.find({dist[v], v}));\\n                    dist[v] = dist[u] + weight;\\n                    unfinalized.insert({dist[v], v});\\n                }\\n            }\\n        }\\n\\n        printSolution(dist);\\n    }\\n\\n    /**\\n     * - Input: adjacency list\\n     * - Data structure: C++ priority_queue\\n     * - Time complexity: O(ElogE) = O(ElogV). In the worst case, O(E) = O(V^2), \\n     * so O(logE) = 2 * O(logV) = O(logV).\\n     * As mentioned in the previous approach, the priority queue should provide\\n     * two operations: ExtractMin and DecreaseKey. However, C++ priority_queue\\n     * doesn\\'t support DecreaseKey. Solution: do not update a key, but insert \\n     * one more copy of it. We can have multiple instances of the same node. The\\n     * result is that:\\n     *   - When the distance of a vertex is reduced, we insert a new copy to the\\n     *   priority_queue. Only the instance with min distance is considered, \\n     *   while others are ignored.\\n     *   - The time complexity becomes O(ElogE), as the priority_queue can\\n     *   contains O(E) vertices. \\n     * - Note: C++ priority_queue.\\n     * The default comparator for prirority_queue is less<T>, so priority_queue \\n     * should be viewd as: \\n     *      [smallest --> largest] top()\\n     * where top() refers to the largest. \\n     * - Reference: https://www.***.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/\\n     */ \\n    void priorityQueueList(vector<vector<pair<int, int>>>& graph, int src) {\\n        auto comp = [](const pair<int, int>& p1, const pair<int, int>& p2) {\\n            return p1.first > p2.first; // <distance, node>\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> unfinalized(comp);\\n        int n = graph.size();\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        unfinalized.push({0, src});\\n\\n        while (!unfinalized.empty()) {\\n            int u = unfinalized.top().second;\\n            unfinalized.pop();\\n\\n            for (int i = 0; i < graph[u].size(); i++) {\\n                int v = graph[u][i].first, weight = graph[u][i].second;\\n                if (dist[u] + weight < dist[v]) {\\n                    dist[v] = dist[u] + weight;\\n                    unfinalized.push({dist[v], v});\\n                }\\n            }\\n        }\\n\\n        printSolution(dist);\\n    }\\n};\\n\\nint main() {\\n    Solution sol;\\n    int n = 9;\\n    vector<vector<int>> matrix({{0, 4, 0, 0, 0, 0, 0, 8, 0},\\n                                {4, 0, 8, 0, 0, 0, 0, 11, 0},\\n                                {0, 8, 0, 7, 0, 4, 0, 0, 2},\\n                                {0, 0, 7, 0, 9, 14, 0, 0, 0},\\n                                {0, 0, 0, 9, 0, 10, 0, 0, 0},\\n                                {0, 0, 4, 14, 10, 0, 2, 0, 0},\\n                                {0, 0, 0, 0, 0, 2, 0, 1, 6},\\n                                {8, 11, 0, 0, 0, 0, 1, 0, 7},\\n                                {0, 0, 2, 0, 0, 0, 6, 7, 0}});\\n    vector<vector<int>> edges({{0, 1},\\n                               {0, 7},\\n                               {1, 2},\\n                               {1, 7},\\n                               {2, 3},\\n                               {2, 8},\\n                               {2, 5},\\n                               {3, 4},\\n                               {3, 5},\\n                               {4, 5},\\n                               {5, 6},\\n                               {6, 7},\\n                               {6, 8},\\n                               {7, 8}});\\n    vector<int> weights({4, 8, 8, 11, 7, 2, 4, 9, 14, 10, 2, 1, 6, 7});\\n    vector<vector<pair<int, int>>> graph = buildGraph(n, edges, weights);\\n\\n    // adjacency matrix, naive implementation\\n    sol.naiveMatrix(matrix, 0);\\n\\n    // adjacency list, with C++ set\\n    sol.setList(graph, 0);\\n\\n    // adjacency list, with C++ priority_queue\\n    sol.priorityQueueList(graph, 0);\\n}\\n```\\nFor this particular problem, solution using set:\\n```C++\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int src, int end) {\\n        // Build adjancency list\\n        vector<vector<pair<int, double>>> graph(n);\\n        for (int i = 0; i < edges.size(); i++) {\\n            double prob = succProb[i];\\n            int node1 = edges[i][0], node2 = edges[i][1];\\n            graph[node1].push_back({node2, prob});\\n            graph[node2].push_back({node1, prob});\\n        }\\n        \\n        vector<double> probs(n, 0.0);\\n        probs[src] = 1.0;\\n        auto comp = [](const pair<double, int>& p1, const pair<double, int>& p2) { \\n            return p1.first != p2.first ? p1.first > p2.first : p1.second > p2.second; \\n        };\\n        set<pair<double, int>, decltype(comp)> unfinalized(comp); // <probability, node>\\n        for (int node = 0; node < n; node++) unfinalized.insert({node == src ? 1.0 : 0.0, node});\\n\\n        while (!unfinalized.empty()) {\\n            pair<double, int> p = *(unfinalized.begin());\\n            unfinalized.erase(unfinalized.begin());\\n            int u = p.second;\\n\\n            for (int i = 0; i < graph[u].size(); i++) {\\n                int v = graph[u][i].first;\\n                double prob = graph[u][i].second;\\n                if (prob * probs[u] > probs[v]) {\\n                    unfinalized.erase(unfinalized.find({probs[v], v}));\\n                    probs[v] = prob * probs[u];\\n                    unfinalized.insert({probs[v], v});\\n                }\\n            }\\n        }\\n\\n        return probs[end];\\n    }\\n};\\n```\\nNote that `comp` should be defined such that it resolves all conflicts! If you do:\\n```C++\\nauto comp = [](const pair<double, int>& p1, const pair<double, int>& p2) { \\n\\treturn p1.first > p2.first; \\n};\\n```\\nthe code wouldn\\'t behave has expected. The reason is that the above `comp` essentially means using the probability to be the key! So if you insert `{0.0, 1}` and `{0.0, 2}`, only `{0.0, 1}` gets inserted!",
                "solutionTags": [],
                "code": "```C++\\n/**\\n * Dijkstra\\'s algorithm. \\n * In essence, Dijkstra\\'s algorithm maintains two sets: one set of nodes whose\\n * distance from source is NOT finalized, one set of nodes whose distance\\n * from source IS finalized. \\n * In implementation, we keep track of the two sets explicitly or implicitly. \\n * \\n * Reference: \\n * https://www.***.org/dijkstras-shortest-path-algorithm-greedy-algo-7/\\n */\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n// Helper functions\\nvector<vector<pair<int, int>>> buildGraph(int n, vector<vector<int>>& edges, vector<int>& weights) {\\n    vector<vector<pair<int, int>>> graph(n);\\n    for (int i = 0; i < edges.size(); i++) {\\n        vector<int> edge = edges[i];\\n        graph[edge[0]].push_back({edge[1], weights[i]});\\n        graph[edge[1]].push_back({edge[0], weights[i]});\\n    }\\n    return graph;\\n}\\n\\nvoid printSolution(vector<int>& dist) {\\n    printf(\"Vertex \\\\t\\\\t Distance from Source\\\\n\");\\n    for (int i = 0; i < dist.size(); i++)\\n        printf(\"%d \\\\t\\\\t %d\\\\n\", i, dist[i]);\\n}\\n\\nclass Solution {\\n   public:\\n    /**\\n     * - Input: adjacency matrix. \\n     * - Data structure: Only vector: `finalized` array.\\n     * - Time complexity: O(V^2). Each iteration of outer loop marks one node as\\n     * finalized, in total V iterations. Each iteration of inner loop is O(V). \\n     * - Note: the inner loop does two main things: (1) Finding un-finalized \\n     * node of min distance, and (2) iterating through neighbors. If we use\\n     * adjacency list instead of adjacency matrix, exactly E neighbors would\\n     * be iterated through for (2). If we consider (1) and (2) separately, this\\n     * reduces time from O(V^2) + O(V^2) to O(V^2) + O(E). \\n     * - Reference: https://www.***.org/dijkstras-shortest-path-algorithm-greedy-algo-7/\\n     */\\n    void naiveMatrix(vector<vector<int>>& graph, int src) {\\n        int n = graph.size();\\n        vector<int> dist(n, INT_MAX);      // distance from source\\n        vector<bool> finalized(n, false);  // if the distance is finalized\\n        dist[src] = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Get UN-finalized node with min distance\\n            int minDis = INT_MAX, minIndex;\\n            for (int node = 0; node < n; node++) {\\n                if (!finalized[node] && dist[node] < minDis) {\\n                    minDis = dist[node];\\n                    minIndex = node;\\n                }\\n            }\\n\\n            // Distance to this node is finalized\\n            finalized[minIndex] = true;\\n\\n            // Update it\\'s neighbors, IF UN-finazlied\\n            for (int node = 0; node < n; node++) {\\n                if (!finalized[node] && graph[minIndex][node] &&\\n                    dist[minIndex] + graph[minIndex][node] < dist[node]) {\\n                    dist[node] = dist[minIndex] + graph[minIndex][node];\\n                }\\n            }\\n        }\\n        printSolution(dist);\\n    }\\n\\n    /**\\n     * - Input: adjacency list.\\n     * - Data structure: set in C++: `unfinalized` set.\\n     * - Time complexity: O(E * logV). Set operation is O(logV). The outer loop\\n     * is executed V times, so extracting min takes O(VlogV). The inner for \\n     * loop is executed, in total, E times. The reason is that each edge is\\n     * traversed at most twice in the algorithm: When a edge is traversed, it \\n     * means one of its endpoint is finalized. The next time this edge is\\n     * traversed, it means the other endpoint is finalized. So the total time\\n     * is O(2ElogV + VlogV). As E >= V-1, time complexity is O(ElogV).\\n     * - Note: as mentioned in previous approach, adjacency list enables more \\n     * efficient traversal over neighbors. C++ set enables finding unfinalized \\n     * node with min distance in constant time, with O(logV) for insertion or \\n     * deletion. https://stackoverflow.com/a/54537313/9057530\\n     * In Dijkstra\\u2019s algorithm, we need a priority queue and below operations:\\n     *   ExtractMin: from vertices whose shortest distance is not finalized.\\n     *   DecreaseKey: Update distance for neighbors.\\n     * C++ STL set keeps all its keys in sorted order, so min distant vertex \\n     * will always be at beginning, which is the ExtractMin operation. Updating \\n     * other adjacent vertex can be done by deleting its previous entry and \\n     * insert new updated entry, which is DecreaseKey operation.\\n     * The implementation is slightly different from the link: we add all nodes\\n     * to `unfinalized` at the beginning.\\n     * - Reference: https://www.***.org/dijkstras-shortest-path-algorithm-using-set-in-stl/\\n     */\\n    void setList(vector<vector<pair<int, int>>>& graph, int src) {\\n        // graph: each pair<int, int> is <node, weight>\\n        int n = graph.size();\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        set<pair<int, int>> unfinalized;  // <distance, node>\\n        for (int node = 0; node < n; node++)\\n            unfinalized.insert({node == src ? 0 : INT_MAX, node});\\n\\n        while (!unfinalized.empty()) {\\n            pair<int, int> p = *(unfinalized.begin());\\n            unfinalized.erase(unfinalized.begin());\\n            int u = p.second;\\n\\n            for (int i = 0; i < graph[u].size(); i++) {\\n                int v = graph[u][i].first, weight = graph[u][i].second;\\n                if (dist[u] + weight < dist[v]) {\\n                    // v cannot be finalized, so must be in finalized\\n                    unfinalized.erase(unfinalized.find({dist[v], v}));\\n                    dist[v] = dist[u] + weight;\\n                    unfinalized.insert({dist[v], v});\\n                }\\n            }\\n        }\\n\\n        printSolution(dist);\\n    }\\n\\n    /**\\n     * - Input: adjacency list\\n     * - Data structure: C++ priority_queue\\n     * - Time complexity: O(ElogE) = O(ElogV). In the worst case, O(E) = O(V^2), \\n     * so O(logE) = 2 * O(logV) = O(logV).\\n     * As mentioned in the previous approach, the priority queue should provide\\n     * two operations: ExtractMin and DecreaseKey. However, C++ priority_queue\\n     * doesn\\'t support DecreaseKey. Solution: do not update a key, but insert \\n     * one more copy of it. We can have multiple instances of the same node. The\\n     * result is that:\\n     *   - When the distance of a vertex is reduced, we insert a new copy to the\\n     *   priority_queue. Only the instance with min distance is considered, \\n     *   while others are ignored.\\n     *   - The time complexity becomes O(ElogE), as the priority_queue can\\n     *   contains O(E) vertices. \\n     * - Note: C++ priority_queue.\\n     * The default comparator for prirority_queue is less<T>, so priority_queue \\n     * should be viewd as: \\n     *      [smallest --> largest] top()\\n     * where top() refers to the largest. \\n     * - Reference: https://www.***.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/\\n     */ \\n    void priorityQueueList(vector<vector<pair<int, int>>>& graph, int src) {\\n        auto comp = [](const pair<int, int>& p1, const pair<int, int>& p2) {\\n            return p1.first > p2.first; // <distance, node>\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> unfinalized(comp);\\n        int n = graph.size();\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        unfinalized.push({0, src});\\n\\n        while (!unfinalized.empty()) {\\n            int u = unfinalized.top().second;\\n            unfinalized.pop();\\n\\n            for (int i = 0; i < graph[u].size(); i++) {\\n                int v = graph[u][i].first, weight = graph[u][i].second;\\n                if (dist[u] + weight < dist[v]) {\\n                    dist[v] = dist[u] + weight;\\n                    unfinalized.push({dist[v], v});\\n                }\\n            }\\n        }\\n\\n        printSolution(dist);\\n    }\\n};\\n\\nint main() {\\n    Solution sol;\\n    int n = 9;\\n    vector<vector<int>> matrix({{0, 4, 0, 0, 0, 0, 0, 8, 0},\\n                                {4, 0, 8, 0, 0, 0, 0, 11, 0},\\n                                {0, 8, 0, 7, 0, 4, 0, 0, 2},\\n                                {0, 0, 7, 0, 9, 14, 0, 0, 0},\\n                                {0, 0, 0, 9, 0, 10, 0, 0, 0},\\n                                {0, 0, 4, 14, 10, 0, 2, 0, 0},\\n                                {0, 0, 0, 0, 0, 2, 0, 1, 6},\\n                                {8, 11, 0, 0, 0, 0, 1, 0, 7},\\n                                {0, 0, 2, 0, 0, 0, 6, 7, 0}});\\n    vector<vector<int>> edges({{0, 1},\\n                               {0, 7},\\n                               {1, 2},\\n                               {1, 7},\\n                               {2, 3},\\n                               {2, 8},\\n                               {2, 5},\\n                               {3, 4},\\n                               {3, 5},\\n                               {4, 5},\\n                               {5, 6},\\n                               {6, 7},\\n                               {6, 8},\\n                               {7, 8}});\\n    vector<int> weights({4, 8, 8, 11, 7, 2, 4, 9, 14, 10, 2, 1, 6, 7});\\n    vector<vector<pair<int, int>>> graph = buildGraph(n, edges, weights);\\n\\n    // adjacency matrix, naive implementation\\n    sol.naiveMatrix(matrix, 0);\\n\\n    // adjacency list, with C++ set\\n    sol.setList(graph, 0);\\n\\n    // adjacency list, with C++ priority_queue\\n    sol.priorityQueueList(graph, 0);\\n}\\n```\n```C++\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int src, int end) {\\n        // Build adjancency list\\n        vector<vector<pair<int, double>>> graph(n);\\n        for (int i = 0; i < edges.size(); i++) {\\n            double prob = succProb[i];\\n            int node1 = edges[i][0], node2 = edges[i][1];\\n            graph[node1].push_back({node2, prob});\\n            graph[node2].push_back({node1, prob});\\n        }\\n        \\n        vector<double> probs(n, 0.0);\\n        probs[src] = 1.0;\\n        auto comp = [](const pair<double, int>& p1, const pair<double, int>& p2) { \\n            return p1.first != p2.first ? p1.first > p2.first : p1.second > p2.second; \\n        };\\n        set<pair<double, int>, decltype(comp)> unfinalized(comp); // <probability, node>\\n        for (int node = 0; node < n; node++) unfinalized.insert({node == src ? 1.0 : 0.0, node});\\n\\n        while (!unfinalized.empty()) {\\n            pair<double, int> p = *(unfinalized.begin());\\n            unfinalized.erase(unfinalized.begin());\\n            int u = p.second;\\n\\n            for (int i = 0; i < graph[u].size(); i++) {\\n                int v = graph[u][i].first;\\n                double prob = graph[u][i].second;\\n                if (prob * probs[u] > probs[v]) {\\n                    unfinalized.erase(unfinalized.find({probs[v], v}));\\n                    probs[v] = prob * probs[u];\\n                    unfinalized.insert({probs[v], v});\\n                }\\n            }\\n        }\\n\\n        return probs[end];\\n    }\\n};\\n```\n```C++\\nauto comp = [](const pair<double, int>& p1, const pair<double, int>& p2) { \\n\\treturn p1.first > p2.first; \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3691382,
                "title": "c-priority-queue-easy-to-understand-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        \\n        // Build the graph using an adjacency list representation\\n        // Each edge is represented as a pair (neighbor node, edge index)\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\\n            graph[u].push_back({v, edgeIdx});\\n            graph[v].push_back({u, edgeIdx});\\n        }\\n        \\n        vector<double> probabilities(n, 0.0);\\n        probabilities[start] = 1.0;\\n        \\n        priority_queue<pair<double, int>> nodesToExplore;\\n        // Add the start node to the priority queue with probability 1.0\\n        nodesToExplore.push({1.0, start});\\n        \\n        while (!nodesToExplore.empty()) {\\n            auto [prob, u] = nodesToExplore.top();\\n            nodesToExplore.pop();\\n            \\n            // If we\\'ve reached the end node, return the probability\\n            if (u == end) \\n                return prob;\\n            // If we\\'ve already explored this node with a higher probability, skip it\\n            if (probabilities[u] > prob) \\n                continue;\\n                \\n            // Explore the neighbors of the current node\\n            for (auto [v, edgeIdx] : graph[u]) {\\n                double newProb = prob * succProb[edgeIdx];\\n                \\n                // Update the probability of the neighbor node if we\\'ve found a higher probability\\n                if (newProb > probabilities[v]) {\\n                    probabilities[v] = newProb;\\n                    \\n                    // Add the neighbor node to the priority queue with its new probability\\n                    nodesToExplore.push({newProb, v});\\n                }\\n            }\\n        }\\n        \\n        // If we\\'ve explored all nodes and haven\\'t reached the end node, return 0.0\\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        \\n        // Build the graph using an adjacency list representation\\n        // Each edge is represented as a pair (neighbor node, edge index)\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\\n            graph[u].push_back({v, edgeIdx});\\n            graph[v].push_back({u, edgeIdx});\\n        }\\n        \\n        vector<double> probabilities(n, 0.0);\\n        probabilities[start] = 1.0;\\n        \\n        priority_queue<pair<double, int>> nodesToExplore;\\n        // Add the start node to the priority queue with probability 1.0\\n        nodesToExplore.push({1.0, start});\\n        \\n        while (!nodesToExplore.empty()) {\\n            auto [prob, u] = nodesToExplore.top();\\n            nodesToExplore.pop();\\n            \\n            // If we\\'ve reached the end node, return the probability\\n            if (u == end) \\n                return prob;\\n            // If we\\'ve already explored this node with a higher probability, skip it\\n            if (probabilities[u] > prob) \\n                continue;\\n                \\n            // Explore the neighbors of the current node\\n            for (auto [v, edgeIdx] : graph[u]) {\\n                double newProb = prob * succProb[edgeIdx];\\n                \\n                // Update the probability of the neighbor node if we\\'ve found a higher probability\\n                if (newProb > probabilities[v]) {\\n                    probabilities[v] = newProb;\\n                    \\n                    // Add the neighbor node to the priority queue with its new probability\\n                    nodesToExplore.push({newProb, v});\\n                }\\n            }\\n        }\\n        \\n        // If we\\'ve explored all nodes and haven\\'t reached the end node, return 0.0\\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567147,
                "title": "python-clean-dijkstra-algorithm",
                "content": "```\\nimport heapq as hq\\n\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        adj_list = {i: [] for i in range(0, n)}\\n        \\n        for e, w in zip(edges, succProb):\\n            v1, v2 = e\\n            adj_list[v1].append((w, v2))\\n            adj_list[v2].append((w, v1))\\n        \\n        max_heap = [(-1, start)]\\n        seen = set()\\n\\n        \\n        while max_heap:\\n            weight, v = hq.heappop(max_heap)            \\n            \\n            if v in seen: continue\\n            if v == end: return -weight\\n            \\n            seen.add(v)\\n            \\n            for neighbor_weight, neighbor in adj_list[v]:\\n                if neighbor not in seen:\\n                    hq.heappush(max_heap, (weight * neighbor_weight, neighbor))\\n        \\n        return 0.0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq as hq\\n\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        adj_list = {i: [] for i in range(0, n)}\\n        \\n        for e, w in zip(edges, succProb):\\n            v1, v2 = e\\n            adj_list[v1].append((w, v2))\\n            adj_list[v2].append((w, v1))\\n        \\n        max_heap = [(-1, start)]\\n        seen = set()\\n\\n        \\n        while max_heap:\\n            weight, v = hq.heappop(max_heap)            \\n            \\n            if v in seen: continue\\n            if v == end: return -weight\\n            \\n            seen.add(v)\\n            \\n            for neighbor_weight, neighbor in adj_list[v]:\\n                if neighbor not in seen:\\n                    hq.heappush(max_heap, (weight * neighbor_weight, neighbor))\\n        \\n        return 0.0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734234,
                "title": "c-dijkstra-algo-fastest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> graph(n, vector<pair<int, double>>());\\n        for (int i = 0, size = edges.size(); i < size; i++) {\\n            vector<int>& e = edges[i];\\n            graph[e[0]].push_back({e[1], succProb[i]});\\n            graph[e[1]].push_back({e[0], succProb[i]});\\n        }\\n        vector<bool> vis(n, false);\\n        priority_queue<pair<double, int>> que;\\n        que.push({1.0, start});\\n        while (que.size() != 0) {\\n            int size = que.size();\\n            while (size-- > 0) {\\n                pair<double, int> rvtx = que.top();\\n                que.pop();\\n                if (rvtx.second == end) {\\n                    return rvtx.first;\\n                }\\n                vis[rvtx.second] = true;\\n                for (pair<int, double>& e : graph[rvtx.second]) {\\n                    if (!vis[e.first]) {\\n                        que.push({e.second * rvtx.first, e.first});\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> graph(n, vector<pair<int, double>>());\\n        for (int i = 0, size = edges.size(); i < size; i++) {\\n            vector<int>& e = edges[i];\\n            graph[e[0]].push_back({e[1], succProb[i]});\\n            graph[e[1]].push_back({e[0], succProb[i]});\\n        }\\n        vector<bool> vis(n, false);\\n        priority_queue<pair<double, int>> que;\\n        que.push({1.0, start});\\n        while (que.size() != 0) {\\n            int size = que.size();\\n            while (size-- > 0) {\\n                pair<double, int> rvtx = que.top();\\n                que.pop();\\n                if (rvtx.second == end) {\\n                    return rvtx.first;\\n                }\\n                vis[rvtx.second] = true;\\n                for (pair<int, double>& e : graph[rvtx.second]) {\\n                    if (!vis[e.first]) {\\n                        que.push({e.second * rvtx.first, e.first});\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731881,
                "title": "c-bfs-clean-code",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n    vector<vector<pair<int, double>>> to(n);\\n        for(int i=0;i<edges.size();i++){\\n            to[edges[i][0]].emplace_back(edges[i][1], succProb[i]);\\n            to[edges[i][1]].emplace_back(edges[i][0], succProb[i]);\\n        }\\n        vector<double> Prob(n, 0);\\n        queue<int> Q;\\n        Q.push(start);\\n        Prob[start] = 1;\\n        while (!Q.empty()){\\n            int node = Q.front();\\n            Q.pop();\\n            for (auto child : to[node]){\\n                int nxt = child.first;\\n                double p = child.second;\\n                if (Prob[nxt] < Prob[node] * p) Prob[nxt] = Prob[node] * p, Q.push(nxt);\\n            }\\n        }\\n        return Prob[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n    vector<vector<pair<int, double>>> to(n);\\n        for(int i=0;i<edges.size();i++){\\n            to[edges[i][0]].emplace_back(edges[i][1], succProb[i]);\\n            to[edges[i][1]].emplace_back(edges[i][0], succProb[i]);\\n        }\\n        vector<double> Prob(n, 0);\\n        queue<int> Q;\\n        Q.push(start);\\n        Prob[start] = 1;\\n        while (!Q.empty()){\\n            int node = Q.front();\\n            Q.pop();\\n            for (auto child : to[node]){\\n                int nxt = child.first;\\n                double p = child.second;\\n                if (Prob[nxt] < Prob[node] * p) Prob[nxt] = Prob[node] * p, Q.push(nxt);\\n            }\\n        }\\n        return Prob[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690944,
                "title": "easy-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2KyPWznW3kA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int [] edge;\\n        for(int  i = 0;i< edges.length;i++){\\n            edge = edges[i];\\n            graph.computeIfAbsent(edge[0],k->new ArrayList<>()).add(new Pair<>(edge[1],succProb[i]));\\n            graph.computeIfAbsent(edge[1],k->new ArrayList<>()).add(new Pair<>(edge[0],succProb[i]));\\n        }\\n        //System.out.println(graph);\\n        double [] maxProb = new double[n];\\n        maxProb[start] = 1.0;\\n        \\n        PriorityQueue<Pair<Integer,Double>> pq = new PriorityQueue<>((a,b)->-Double.compare(a.getValue(),b.getValue()));\\n        pq.add(new Pair<>(start,1.0));\\n        while (!pq.isEmpty()){\\n            \\n            Pair<Integer,Double> curr = pq.remove();\\n            if(curr.getKey()==end)return curr.getValue();\\n            for(Pair<Integer,Double> path: graph.getOrDefault(curr.getKey(),new ArrayList<>())){\\n                if(curr.getValue()* path.getValue()>maxProb[path.getKey()]){\\n                    maxProb[path.getKey()] = (double)curr.getValue()* path.getValue();\\n                    pq.add(new Pair<>(path.getKey(), maxProb[path.getKey()]));\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, double>>> graph;\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double prob = succProb[i];\\n            graph[u].push_back(make_pair(v, prob));\\n            graph[v].push_back(make_pair(u, prob));\\n        }\\n        \\n        vector<double> maxProb(n, 0.0);\\n        maxProb[start] = 1.0;\\n        \\n        priority_queue<pair<double, int>> pq;\\n        pq.push(make_pair(1.0, start));\\n        while (!pq.empty()) {\\n            pair<double, int> curr = pq.top();\\n            pq.pop();\\n            double currProb = curr.first;\\n            int currNode = curr.second;\\n            \\n            if (currNode == end) {\\n                return currProb;\\n            }\\n            \\n            for (pair<int, double> path : graph[currNode]) {\\n                int nextNode = path.first;\\n                double nextProb = currProb * path.second;\\n                \\n                if (nextProb > maxProb[nextNode]) {\\n                    maxProb[nextNode] = nextProb;\\n                    pq.push(make_pair(nextProb, nextNode));\\n                }\\n            }\\n        }\\n        \\n        return 0.0;\\n    }\\n};\\n```\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = defaultdict(list)\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            prob = succProb[i]\\n            graph[u].append((v, prob))\\n            graph[v].append((u, prob))\\n\\n        maxProb = [0.0] * n\\n        maxProb[start] = 1.0\\n\\n        pq = [(-1.0, start)]\\n        heapq.heapify(pq)\\n        while pq:\\n            currProb, currNode = heapq.heappop(pq)\\n            currProb = -currProb\\n\\n            if currNode == end:\\n                return currProb\\n\\n            for nextNode, nextProb in graph[currNode]:\\n                nextProb *= currProb\\n\\n                if nextProb > maxProb[nextNode]:\\n                    maxProb[nextNode] = nextProb\\n                    heapq.heappush(pq, (-nextProb, nextNode))\\n\\n        return 0.0\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int [] edge;\\n        for(int  i = 0;i< edges.length;i++){\\n            edge = edges[i];\\n            graph.computeIfAbsent(edge[0],k->new ArrayList<>()).add(new Pair<>(edge[1],succProb[i]));\\n            graph.computeIfAbsent(edge[1],k->new ArrayList<>()).add(new Pair<>(edge[0],succProb[i]));\\n        }\\n        //System.out.println(graph);\\n        double [] maxProb = new double[n];\\n        maxProb[start] = 1.0;\\n        \\n        PriorityQueue<Pair<Integer,Double>> pq = new PriorityQueue<>((a,b)->-Double.compare(a.getValue(),b.getValue()));\\n        pq.add(new Pair<>(start,1.0));\\n        while (!pq.isEmpty()){\\n            \\n            Pair<Integer,Double> curr = pq.remove();\\n            if(curr.getKey()==end)return curr.getValue();\\n            for(Pair<Integer,Double> path: graph.getOrDefault(curr.getKey(),new ArrayList<>())){\\n                if(curr.getValue()* path.getValue()>maxProb[path.getKey()]){\\n                    maxProb[path.getKey()] = (double)curr.getValue()* path.getValue();\\n                    pq.add(new Pair<>(path.getKey(), maxProb[path.getKey()]));\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, double>>> graph;\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double prob = succProb[i];\\n            graph[u].push_back(make_pair(v, prob));\\n            graph[v].push_back(make_pair(u, prob));\\n        }\\n        \\n        vector<double> maxProb(n, 0.0);\\n        maxProb[start] = 1.0;\\n        \\n        priority_queue<pair<double, int>> pq;\\n        pq.push(make_pair(1.0, start));\\n        while (!pq.empty()) {\\n            pair<double, int> curr = pq.top();\\n            pq.pop();\\n            double currProb = curr.first;\\n            int currNode = curr.second;\\n            \\n            if (currNode == end) {\\n                return currProb;\\n            }\\n            \\n            for (pair<int, double> path : graph[currNode]) {\\n                int nextNode = path.first;\\n                double nextProb = currProb * path.second;\\n                \\n                if (nextProb > maxProb[nextNode]) {\\n                    maxProb[nextNode] = nextProb;\\n                    pq.push(make_pair(nextProb, nextNode));\\n                }\\n            }\\n        }\\n        \\n        return 0.0;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = defaultdict(list)\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            prob = succProb[i]\\n            graph[u].append((v, prob))\\n            graph[v].append((u, prob))\\n\\n        maxProb = [0.0] * n\\n        maxProb[start] = 1.0\\n\\n        pq = [(-1.0, start)]\\n        heapq.heapify(pq)\\n        while pq:\\n            currProb, currNode = heapq.heappop(pq)\\n            currProb = -currProb\\n\\n            if currNode == end:\\n                return currProb\\n\\n            for nextNode, nextProb in graph[currNode]:\\n                nextProb *= currProb\\n\\n                if nextProb > maxProb[nextNode]:\\n                    maxProb[nextNode] = nextProb\\n                    heapq.heappush(pq, (-nextProb, nextNode))\\n\\n        return 0.0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731797,
                "title": "java-super-easy-bellman-ford-solution-c-dijkstra",
                "content": "```\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) \\n    {\\n        double[] ret=new double[n];\\n        ret[start]=1;\\n        for(int i=0;i<n;++i)\\n            for(int j=0;j<edges.length;++j)\\n            {\\n                int[] e=edges[j];\\n                if(ret[e[1]]<ret[e[0]]*succProb[j])\\n                    ret[e[1]]=ret[e[0]]*succProb[j]; \\n                else if(ret[e[0]]<ret[e[1]]*succProb[j])\\n                    ret[e[0]]=ret[e[1]]*succProb[j];\\n            }\\n        return ret[end];\\n    }  \\n```\\nEDIT: I\\'ve noticed that this solution isn\\'t accepted anymore, so I\\'m adding a Dijkstra solution also, with similiar distance function as the Bellman-Ford mentioned here.\\n```\\nstruct compare\\n{\\n\\tbool operator()(pair<int,double>& p1,pair<int,double>& p2)\\n\\t{\\n\\t\\treturn p1.second<p2.second;\\n\\t}\\n};\\ndouble dijkstra(int n,vector<vector<pair<int,double>>>& adj,int start,int end)\\n{\\n\\tvector<double> d(n,(double)0);\\n\\tpriority_queue<pair<int,double>,vector<pair<int,double>>,compare> q;\\n\\tq.push((make_pair(start,1)));\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tauto [u,prob]=q.top();\\n\\t\\tq.pop();\\n\\t\\tif(prob<=d[u])\\n\\t\\t\\tcontinue;\\n\\t\\td[u]=prob;\\n\\t\\tfor(auto [v,newProb]:adj[u])\\n\\t\\t\\tif(d[v]<d[u]*newProb)\\n\\t\\t\\t\\tq.push(make_pair(v,d[u]*newProb));\\n\\t}\\n\\treturn d[end];\\n}\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end)\\n{\\n\\tint i=0;\\n\\tvector<vector<pair<int,double>>> adj(n);\\n\\tfor(auto& x:edges)\\n\\t{\\n\\t\\tadj[x[0]].push_back(make_pair(x[1],succProb[i]));\\n\\t\\tadj[x[1]].push_back(make_pair(x[0],succProb[i++]));\\n\\t}\\n\\treturn dijkstra(n,adj,start,end);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) \\n    {\\n        double[] ret=new double[n];\\n        ret[start]=1;\\n        for(int i=0;i<n;++i)\\n            for(int j=0;j<edges.length;++j)\\n            {\\n                int[] e=edges[j];\\n                if(ret[e[1]]<ret[e[0]]*succProb[j])\\n                    ret[e[1]]=ret[e[0]]*succProb[j]; \\n                else if(ret[e[0]]<ret[e[1]]*succProb[j])\\n                    ret[e[0]]=ret[e[1]]*succProb[j];\\n            }\\n        return ret[end];\\n    }  \\n```\n```\\nstruct compare\\n{\\n\\tbool operator()(pair<int,double>& p1,pair<int,double>& p2)\\n\\t{\\n\\t\\treturn p1.second<p2.second;\\n\\t}\\n};\\ndouble dijkstra(int n,vector<vector<pair<int,double>>>& adj,int start,int end)\\n{\\n\\tvector<double> d(n,(double)0);\\n\\tpriority_queue<pair<int,double>,vector<pair<int,double>>,compare> q;\\n\\tq.push((make_pair(start,1)));\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tauto [u,prob]=q.top();\\n\\t\\tq.pop();\\n\\t\\tif(prob<=d[u])\\n\\t\\t\\tcontinue;\\n\\t\\td[u]=prob;\\n\\t\\tfor(auto [v,newProb]:adj[u])\\n\\t\\t\\tif(d[v]<d[u]*newProb)\\n\\t\\t\\t\\tq.push(make_pair(v,d[u]*newProb));\\n\\t}\\n\\treturn d[end];\\n}\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end)\\n{\\n\\tint i=0;\\n\\tvector<vector<pair<int,double>>> adj(n);\\n\\tfor(auto& x:edges)\\n\\t{\\n\\t\\tadj[x[0]].push_back(make_pair(x[1],succProb[i]));\\n\\t\\tadj[x[1]].push_back(make_pair(x[0],succProb[i++]));\\n\\t}\\n\\treturn dijkstra(n,adj,start,end);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731555,
                "title": "java-dijkstra-s-algorithm-any-comments-are-welcome",
                "content": "This problem reminds me of [743.\\xA0Network Delay Time](https://leetcode.com/problems/network-delay-time/) and [787.\\xA0Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/) that use Dijkstra\\'s algorithm, so I try to implement this algorithm. \\n\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] s, int start, int end) {\\n        //build adjList, g[i] stores {neib of i, weigth}\\n        List<Pair>[] g = new ArrayList[n];\\n        for(int i=0; i<n; i++){\\n            g[i] = new ArrayList<>();\\n        }\\n        for(int i = 0; i<edges.length; i++){\\n            g[edges[i][0]].add(new Pair(edges[i][1], s[i]));\\n            g[edges[i][1]].add(new Pair(edges[i][0], s[i]));\\n        }\\n        \\n        // init a pq, put {parent node, probability}, bigger probability will be polled out first\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {  \\n            public int compare(Pair a, Pair b) {\\n                if(a.prob < b.prob) return 1;\\n                else if(a.prob > b.prob) return -1;\\n                return 0;\\n            }\\n        }); \\n        //add start node, init probability = 1\\n        pq.offer(new Pair(start, 1));\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        \\n        double res = Integer.MIN_VALUE;\\n        \\n        while(!pq.isEmpty()){\\n            Pair cur = pq.poll();\\n            if(cur.node == end) res = Math.max(res, cur.prob);\\n            visited.add(cur.node);\\n            for(Pair next : g[cur.node]){\\n                if(!visited.contains(next.node)){\\n                    pq.offer(new Pair(next.node, next.prob * cur.prob));\\n                }\\n            }\\n            \\n        }\\n        //if res is MIN, it means we cannot reach the end node     \\n        return res== Integer.MIN_VALUE? 0 : res;\\n    }\\n\\t\\n    class Pair{\\n        int node;\\n        double prob;\\n        Pair(int node, double prob){\\n            this.node = node;\\n            this.prob = prob;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] s, int start, int end) {\\n        //build adjList, g[i] stores {neib of i, weigth}\\n        List<Pair>[] g = new ArrayList[n];\\n        for(int i=0; i<n; i++){\\n            g[i] = new ArrayList<>();\\n        }\\n        for(int i = 0; i<edges.length; i++){\\n            g[edges[i][0]].add(new Pair(edges[i][1], s[i]));\\n            g[edges[i][1]].add(new Pair(edges[i][0], s[i]));\\n        }\\n        \\n        // init a pq, put {parent node, probability}, bigger probability will be polled out first\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {  \\n            public int compare(Pair a, Pair b) {\\n                if(a.prob < b.prob) return 1;\\n                else if(a.prob > b.prob) return -1;\\n                return 0;\\n            }\\n        }); \\n        //add start node, init probability = 1\\n        pq.offer(new Pair(start, 1));\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        \\n        double res = Integer.MIN_VALUE;\\n        \\n        while(!pq.isEmpty()){\\n            Pair cur = pq.poll();\\n            if(cur.node == end) res = Math.max(res, cur.prob);\\n            visited.add(cur.node);\\n            for(Pair next : g[cur.node]){\\n                if(!visited.contains(next.node)){\\n                    pq.offer(new Pair(next.node, next.prob * cur.prob));\\n                }\\n            }\\n            \\n        }\\n        //if res is MIN, it means we cannot reach the end node     \\n        return res== Integer.MIN_VALUE? 0 : res;\\n    }\\n\\t\\n    class Pair{\\n        int node;\\n        double prob;\\n        Pair(int node, double prob){\\n            this.node = node;\\n            this.prob = prob;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691184,
                "title": "c-easy-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& e, vector<double>& p, int s, int end) {\\n        vector<pair<int,double>>ad[n+1];\\n        for(int i=0;i<e.size();i++){\\n            ad[e[i][0]].push_back({e[i][1],p[i]});\\n            ad[e[i][1]].push_back({e[i][0],p[i]});\\n        }\\n        priority_queue<pair<double,int>>pq;\\n        pq.push({1.0,s});\\n        vector<double>pro(n+1,0.0);\\n        pro[s]=1.0;\\n        while(pq.size()){\\n            auto x = pq.top();\\n            pq.pop();\\n            double pb = x.first;\\n            int in = x.second;\\n            if(in==end)continue;\\n            for(auto k:ad[in]){\\n                double pp = pb * k.second;\\n                if(pro[k.first]<pp){\\n                    pro[k.first] = pp;\\n                    pq.push({pro[k.first],k.first});\\n                }\\n            }\\n        }\\n        return pro[end];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/995741f8-97e3-4fe1-b7e4-bd875e344298_1687924568.5877004.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& e, vector<double>& p, int s, int end) {\\n        vector<pair<int,double>>ad[n+1];\\n        for(int i=0;i<e.size();i++){\\n            ad[e[i][0]].push_back({e[i][1],p[i]});\\n            ad[e[i][1]].push_back({e[i][0],p[i]});\\n        }\\n        priority_queue<pair<double,int>>pq;\\n        pq.push({1.0,s});\\n        vector<double>pro(n+1,0.0);\\n        pro[s]=1.0;\\n        while(pq.size()){\\n            auto x = pq.top();\\n            pq.pop();\\n            double pb = x.first;\\n            int in = x.second;\\n            if(in==end)continue;\\n            for(auto k:ad[in]){\\n                double pp = pb * k.second;\\n                if(pro[k.first]<pp){\\n                    pro[k.first] = pp;\\n                    pq.push({pro[k.first],k.first});\\n                }\\n            }\\n        }\\n        return pro[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691148,
                "title": "java-easy-solution",
                "content": "# Intuition\\nThe problem can be solved using a modified version of Dijkstra\\'s algorithm. We can treat the success probabilities as weights on the edges of the graph and find the path with the maximum probability of success from the start node to the end node.\\n\\n# Approach\\n1. Create an adjacency list representation of the graph, where each node is associated with a list of its neighbors and the corresponding success probabilities.\\n2. Initialize an array called distance with all elements set to 0.0, except for the start node which is set to 1.0. This array will store the best probability for reaching each node from the start node.\\n3. Create a queue and add the start node to it.\\n4. Perform a breadth-first search (BFS) starting from the start node.\\n5. While the queue is not empty, dequeue a node from the queue and process its neighbors.\\n6. For each neighbor, calculate the new probability by multiplying the probability of reaching the current node with the success probability of the edge connecting the current node and the neighbor.\\n7. If the new probability is greater than the existing probability stored in the distance array for the neighbor, update the distance array with the new probability and enqueue the neighbor.\\n8. Repeat steps 5-7 until the queue becomes empty.\\n9. Finally, return the value stored in the distance array for the end node, which represents the maximum probability of success from the start to the end node.\\n\\n# Complexity\\n- Time complexity: O(E + V log V), \\n  where E is the number of edges and V is the number of vertices. This is because we are performing a BFS traversal, which takes O(V + E) time, and the priority queue used in Dijkstra\\'s algorithm takes O(V log V) time.\\n\\n- Space complexity: O(V), \\nwhere V is the number of vertices. We are using additional space to store the adjacency list, the distance array, and the queue, all of which require O(V) space.\\n\\n# Code\\n```\\n// Making the class Pair for storing the solution\\nclass Pair{\\n    int node;\\n    double probability;\\n    Pair(int node,double probability){\\n        this.node = node;\\n        this.probability = probability;\\n    }\\n}\\n\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        \\n        // Making the adjaceny list where we are storing the Pair of neighbor and their probability reaching their for every node \\n        List<List<Pair>> list = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++) list.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double prob = succProb[i];\\n            list.get(u).add(new Pair(v,prob));\\n            list.get(v).add(new Pair(u,prob));\\n        }\\n\\n        // Here we are going to store the best probability for every node\\n        double[] distance = new double[n];\\n        Arrays.fill(distance,0.0);\\n        distance[start] = 1;\\n\\n        // Starting with the start node\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n\\n        while(!queue.isEmpty()){\\n            int curr_node = queue.poll();\\n            List<Pair> neighbor_list = list.get(curr_node);\\n            // getting all the pairs of neighbor nodes and their probabilities respectively \\n            for(Pair pair:neighbor_list){\\n                int neighbor = pair.node;\\n                double prob = pair.probability;\\n                double new_prob = distance[curr_node]*prob;\\n                // if the new probability is greater than the existing one\\n                if(new_prob>distance[neighbor]){\\n                    distance[neighbor] = new_prob;\\n                    queue.add(neighbor);\\n                }\\n\\n            }\\n        }\\n\\n        // returning the end node \\n        return distance[end];\\n    }\\n}\\n```\\n\\n\\n![plz upvote.jpeg](https://assets.leetcode.com/users/images/aaab5acc-0de8-4ca6-9f70-c99fdf388296_1687929871.6126626.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\n// Making the class Pair for storing the solution\\nclass Pair{\\n    int node;\\n    double probability;\\n    Pair(int node,double probability){\\n        this.node = node;\\n        this.probability = probability;\\n    }\\n}\\n\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        \\n        // Making the adjaceny list where we are storing the Pair of neighbor and their probability reaching their for every node \\n        List<List<Pair>> list = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++) list.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double prob = succProb[i];\\n            list.get(u).add(new Pair(v,prob));\\n            list.get(v).add(new Pair(u,prob));\\n        }\\n\\n        // Here we are going to store the best probability for every node\\n        double[] distance = new double[n];\\n        Arrays.fill(distance,0.0);\\n        distance[start] = 1;\\n\\n        // Starting with the start node\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n\\n        while(!queue.isEmpty()){\\n            int curr_node = queue.poll();\\n            List<Pair> neighbor_list = list.get(curr_node);\\n            // getting all the pairs of neighbor nodes and their probabilities respectively \\n            for(Pair pair:neighbor_list){\\n                int neighbor = pair.node;\\n                double prob = pair.probability;\\n                double new_prob = distance[curr_node]*prob;\\n                // if the new probability is greater than the existing one\\n                if(new_prob>distance[neighbor]){\\n                    distance[neighbor] = new_prob;\\n                    queue.add(neighbor);\\n                }\\n\\n            }\\n        }\\n\\n        // returning the end node \\n        return distance[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954614,
                "title": "path-with-maximum-probability-using-dijkstra-algorithm",
                "content": "# Intuition\\nDijkstra algorithm using simple queue and a vector for storing the maximum probability of ith node.\\n\\n# Approach\\nOnly change is that instead of checking for minimum value we check the maximum value.\\nProbability of reaching next node is multiplication of reaching probability of current node and probability of edge between next node and current node.\\n\\n# Complexity\\n- Time complexity:\\nO(V + ElogV)\\n\\n- Space complexity:\\n O(V^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int , double>>adj[n];\\n        for(int i = 0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back({edges[i][1] , succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0] , succProb[i]});\\n        }\\n        queue<pair<int , double>>q;\\n        vector<double>dis(n , 0.0); \\n        dis[start] = 1.0;  \\n        q.push({start , 1.0});\\n        while(!q.empty())\\n        {\\n            int node = q.front().first;\\n            double d = q.front().second;\\n            q.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(d * it.second > dis[it.first])\\n                {\\n                    dis[it.first] = d * it.second;\\n                    q.push({it.first , dis[it.first]});\\n                }\\n            }\\n        }\\n        if(dis[end] == 1e9)\\n        return 0.0;\\n        return dis[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int , double>>adj[n];\\n        for(int i = 0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back({edges[i][1] , succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0] , succProb[i]});\\n        }\\n        queue<pair<int , double>>q;\\n        vector<double>dis(n , 0.0); \\n        dis[start] = 1.0;  \\n        q.push({start , 1.0});\\n        while(!q.empty())\\n        {\\n            int node = q.front().first;\\n            double d = q.front().second;\\n            q.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(d * it.second > dis[it.first])\\n                {\\n                    dis[it.first] = d * it.second;\\n                    q.push({it.first , dis[it.first]});\\n                }\\n            }\\n        }\\n        if(dis[end] == 1e9)\\n        return 0.0;\\n        return dis[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585282,
                "title": "javascript-solution-dijkstra-s-algorithm",
                "content": "```\\nvar maxProbability = function(n, edges, succProb, start, end) {\\n    const MIN = Number.MIN_SAFE_INTEGER;\\n    const m = edges.length;\\n\\t\\n    const adjList = {};\\n    const dists = new Array(n).fill(MIN);\\n    \\n    for (let i = 0; i < n; i++) {\\n        adjList[i] = [];\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        const [u, v] = edges[i];\\n        const weight = succProb[i];\\n        \\n        adjList[u].push([v, weight]);\\n        adjList[v].push([u, weight]);\\n    }\\n    \\n    const maxHeap = new MaxPriorityQueue({ priority: x => x[1] });\\n    \\n    maxHeap.enqueue([ start, 1 ]);\\n    \\n    while (!maxHeap.isEmpty()) {\\n        const [ node, prob ] = maxHeap.dequeue().element;\\n        \\n        if (node === end) return prob;\\n        if (dists[node] > prob) continue;\\n        \\n        for (const [nei, weight] of adjList[node]) {\\n            if (prob * weight > dists[nei]) {\\n                dists[nei] = prob * weight;\\n                maxHeap.enqueue([nei, dists[nei]]);\\n            }\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar maxProbability = function(n, edges, succProb, start, end) {\\n    const MIN = Number.MIN_SAFE_INTEGER;\\n    const m = edges.length;\\n\\t\\n    const adjList = {};\\n    const dists = new Array(n).fill(MIN);\\n    \\n    for (let i = 0; i < n; i++) {\\n        adjList[i] = [];\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        const [u, v] = edges[i];\\n        const weight = succProb[i];\\n        \\n        adjList[u].push([v, weight]);\\n        adjList[v].push([u, weight]);\\n    }\\n    \\n    const maxHeap = new MaxPriorityQueue({ priority: x => x[1] });\\n    \\n    maxHeap.enqueue([ start, 1 ]);\\n    \\n    while (!maxHeap.isEmpty()) {\\n        const [ node, prob ] = maxHeap.dequeue().element;\\n        \\n        if (node === end) return prob;\\n        if (dists[node] > prob) continue;\\n        \\n        for (const [nei, weight] of adjList[node]) {\\n            if (prob * weight > dists[nei]) {\\n                dists[nei] = prob * weight;\\n                maxHeap.enqueue([nei, dists[nei]]);\\n            }\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732812,
                "title": "solution-using-c-with-explanation",
                "content": "**HINT:** Straight Dijkstra Modification \\n\\n**MODIFCATIONS**\\n* Use max priority queue because we need to maximise probability.\\n* Instead of addition use product operation.\\n\\n**CODE**\\n```\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector< pair<int,double> > g[n]; //Initializing graph for n vertices.\\n\\t\\t//Adding each weighted edge to graph g.\\n        for(int i=0;i<edges.size();i++){\\n            g[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            g[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue< pair<int,double>, vector <pair<int,double> > > pq; //Initializing max priority queue.\\n        vector<double> dist(n, 0); // Initializing distance vector to store probability of each node \\n        pq.push(make_pair(1, start)); \\n        dist[start] = 1;\\n        while (!pq.empty()){ \\n            int u = pq.top().second; \\n            pq.pop(); \\n            for (auto x : g[u]) {\\n                int v = x.first; \\n                double weight = x.second;\\n                if (dist[v] < dist[u] * weight) \\n                {\\n                    dist[v] = dist[u] * weight; \\n                    pq.push({dist[v], v}); \\n                } \\n            } \\n        }\\n        return dist[end];//returning probability of destination node.\\n    }\\n```\\n\\nStill facing any problem, comment below :).\\nThanks for upvote.",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector< pair<int,double> > g[n]; //Initializing graph for n vertices.\\n\\t\\t//Adding each weighted edge to graph g.\\n        for(int i=0;i<edges.size();i++){\\n            g[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            g[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue< pair<int,double>, vector <pair<int,double> > > pq; //Initializing max priority queue.\\n        vector<double> dist(n, 0); // Initializing distance vector to store probability of each node \\n        pq.push(make_pair(1, start)); \\n        dist[start] = 1;\\n        while (!pq.empty()){ \\n            int u = pq.top().second; \\n            pq.pop(); \\n            for (auto x : g[u]) {\\n                int v = x.first; \\n                double weight = x.second;\\n                if (dist[v] < dist[u] * weight) \\n                {\\n                    dist[v] = dist[u] * weight; \\n                    pq.push({dist[v], v}); \\n                } \\n            } \\n        }\\n        return dist[end];//returning probability of destination node.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465835,
                "title": "simple-dfs-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    double ans;\\n    double mn=1e-5;\\n    void f(vector<pair<int,double>> adj[], int node, int end, double sum, vector<int> &vis)\\n    {\\n        if(sum<=mn) return;\\n        if(node==end) \\n        {\\n            ans=max(ans,sum);\\n            return;\\n        }\\n        vis[node]=1;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it.first] && (sum*it.second)>=ans) f(adj,it.first,end,sum*it.second,vis);\\n        }\\n        vis[node]=0;\\n    }\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) \\n    {\\n        vector<pair<int,double>> adj[n];\\n        int i=0;\\n        for(auto edge: edges)\\n        {\\n            adj[edge[0]].push_back({edge[1],succProb[i]});\\n            adj[edge[1]].push_back({edge[0],succProb[i]});\\n            i++;\\n        }\\n        vector<int> vis(n,0);\\n        ans=0;\\n        f(adj,start,end,1,vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    double ans;\\n    double mn=1e-5;\\n    void f(vector<pair<int,double>> adj[], int node, int end, double sum, vector<int> &vis)\\n    {\\n        if(sum<=mn) return;\\n        if(node==end) \\n        {\\n            ans=max(ans,sum);\\n            return;\\n        }\\n        vis[node]=1;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it.first] && (sum*it.second)>=ans) f(adj,it.first,end,sum*it.second,vis);\\n        }\\n        vis[node]=0;\\n    }\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) \\n    {\\n        vector<pair<int,double>> adj[n];\\n        int i=0;\\n        for(auto edge: edges)\\n        {\\n            adj[edge[0]].push_back({edge[1],succProb[i]});\\n            adj[edge[1]].push_back({edge[0],succProb[i]});\\n            i++;\\n        }\\n        vector<int> vis(n,0);\\n        ans=0;\\n        f(adj,start,end,1,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735913,
                "title": "python-dijkstras-algorithm",
                "content": "Python heapq supports  minheap by default, but we want the max prob as answer,so we just use negative numbers in the minheap which indirectly acts like maxheap.\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maxProbability(self, n, edges, succProb, start, end) :\\n\\t\\t\\t\\t#This is a variation of std djikstra\\'s \\n\\t\\t\\t\\t#dijkstra\\'s use: find the shortest path from a source to all other nodes.\\n\\t\\t\\t\\t#here,the distance is measured by prob.\\n\\n\\t\\t\\t\\t#create a Adjacency-list from the edges\\n\\t\\t\\t\\tgraph = [[] for _ in range(n)]\\n\\t\\t\\t\\tfor i,(u,v) in enumerate(edges):\\n\\t\\t\\t\\t\\tgraph[u].append([v,succProb[i]])\\n\\t\\t\\t\\t\\tgraph[v].append([u,succProb[i]])\\n\\n\\t\\t\\t\\t#so,use a priorityQueue,for relaxation of edges\\n\\t\\t\\t\\tpq = [[-1,start]]\\n\\n\\t\\t\\t\\t#distance vector from start to all other nodes\\n\\t\\t\\t\\tdist = collections.defaultdict(int)\\n\\t\\t\\t\\tdist[start] = -1\\n\\n\\t\\t\\t\\twhile pq:\\n\\t\\t\\t\\t\\td,node = heapq.heappop(pq)            \\n\\t\\t\\t\\t\\tfor nei,w in graph[node]:\\n\\t\\t\\t\\t\\t\\td2 = d*w\\n\\t\\t\\t\\t\\t\\tif d2 < dist[nei]:\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(pq,[d2,nei])\\n\\t\\t\\t\\t\\t\\t\\tdist[nei] = d2\\n\\n\\t\\t\\t\\treturn -dist[end]\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "Python heapq supports  minheap by default, but we want the max prob as answer,so we just use negative numbers in the minheap which indirectly acts like maxheap.\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maxProbability(self, n, edges, succProb, start, end) :\\n\\t\\t\\t\\t#This is a variation of std djikstra\\'s \\n\\t\\t\\t\\t#dijkstra\\'s use: find the shortest path from a source to all other nodes.\\n\\t\\t\\t\\t#here,the distance is measured by prob.\\n\\n\\t\\t\\t\\t#create a Adjacency-list from the edges\\n\\t\\t\\t\\tgraph = [[] for _ in range(n)]\\n\\t\\t\\t\\tfor i,(u,v) in enumerate(edges):\\n\\t\\t\\t\\t\\tgraph[u].append([v,succProb[i]])\\n\\t\\t\\t\\t\\tgraph[v].append([u,succProb[i]])\\n\\n\\t\\t\\t\\t#so,use a priorityQueue,for relaxation of edges\\n\\t\\t\\t\\tpq = [[-1,start]]\\n\\n\\t\\t\\t\\t#distance vector from start to all other nodes\\n\\t\\t\\t\\tdist = collections.defaultdict(int)\\n\\t\\t\\t\\tdist[start] = -1\\n\\n\\t\\t\\t\\twhile pq:\\n\\t\\t\\t\\t\\td,node = heapq.heappop(pq)            \\n\\t\\t\\t\\t\\tfor nei,w in graph[node]:\\n\\t\\t\\t\\t\\t\\td2 = d*w\\n\\t\\t\\t\\t\\t\\tif d2 < dist[nei]:\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(pq,[d2,nei])\\n\\t\\t\\t\\t\\t\\t\\tdist[nei] = d2\\n\\n\\t\\t\\t\\treturn -dist[end]\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3753103,
                "title": "c-easy-code-dijkstra-using-sets",
                "content": "# Complexity\\n- Time complexity:\\nO((V + E) log V)\\n\\n- Space complexity:\\nO(V + E)\\n\\n# Code\\n```\\nclass  Solution {\\n public:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        vector<double>prob(n,0);\\n        prob[start]=1;\\n        priority_queue<pair<double,int>>pq;\\n        pq.push({1,start});   //prob & node\\n        while(!pq.empty()){\\n            auto u =pq.top();\\n           pq.pop();\\n            for(auto it:adj[u.second]){\\n                if(u.first*it.second>prob[it.first]){\\n                    prob[it.first]=u.first*it.second;\\n                    pq.push({prob[it.first],it.first});\\n                }\\n            }\\n        }\\n        return prob[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set",
                    "Shortest Path"
                ],
                "code": "```\\nclass  Solution {\\n public:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        vector<double>prob(n,0);\\n        prob[start]=1;\\n        priority_queue<pair<double,int>>pq;\\n        pq.push({1,start});   //prob & node\\n        while(!pq.empty()){\\n            auto u =pq.top();\\n           pq.pop();\\n            for(auto it:adj[u.second]){\\n                if(u.first*it.second>prob[it.first]){\\n                    prob[it.first]=u.first*it.second;\\n                    pq.push({prob[it.first],it.first});\\n                }\\n            }\\n        }\\n        return prob[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691953,
                "title": "c-dijkstra-s-algorithm-priority-queue",
                "content": "# Intuition\\nWe use dijkstra\\'s algo to find out the max probability from start node to end node . We use priority queue(max heap) to traverse the nodes ,keep the max probability on top and maintain an array to store the probability\\n\\n# Approach\\n\\n1) We create an adjacency list where each vertice stores the neighboring node and their corrosponding probability\\n\\n2) Create a max heap \\n\\n3) Push the starting node in the heap , and probability of start node to start node is one\\n\\n4) Traversal of priority qeue :\\n    - Extract the probability and node from the top of heap \\n    - Now loop over the neighboring nodes of ```node```\\n    - Now do the same step as we did in step 1\\n    - Calculate the new probability as ``` neigh_prob * node_prob```\\n        and check if it\\'s greater than ``` prob[neigh_prob]```\\n    - if it\\'s greater , then update and push it in queue to check       further \\n\\n5) Return the probabilty of end node\\n# Complexity\\n- Time complexity:$$O(n + m.logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> prob(n + 1,0.0);//probability array of all the vertices - initially 0\\n        vector<pair<int,double>> adj[n + 1]; // adjacency list\\n\\n        // creation of adjacency list\\n        for(int i = 0;i < edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        \\n\\n        priority_queue<pair<double,int>>pq;\\n\\n        // pushing the starting node and prob of going from start node to start node is obviously 1\\n        pq.push({1.0,start});\\n        \\n        //prob of going from start node to start node is obviously 1\\n        prob[start] = 1.0;\\n\\n        while(!pq.empty()){\\n            int node = pq.top().second; // node \\n            double node_prob = pq.top().first;// probabilty of that node\\n\\n            pq.pop();\\n\\n            // travelling the neighboring nodes\\n            for(auto it : adj[node]){\\n                int neigh_node = it.first; //neighboring node\\n                double neigh_prob = it.second;// probability of going from node to neighboring node\\n\\n                double new_prob = neigh_prob * node_prob; // new probability - multiplication of the all the other paths to reach this neighboring node\\n                \\n                // checking if it\\'s larger than the already present then we update it and we travel further \\n                if(prob[neigh_node] < new_prob) {\\n                    prob[neigh_node] = new_prob;\\n                    pq.push({prob[neigh_node],neigh_node});\\n                }\\n\\n            }\\n        } \\n\\n        // return the probability of going to the end node\\'\\n        return prob[end];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```node```\n``` neigh_prob * node_prob```\n``` prob[neigh_prob]```\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> prob(n + 1,0.0);//probability array of all the vertices - initially 0\\n        vector<pair<int,double>> adj[n + 1]; // adjacency list\\n\\n        // creation of adjacency list\\n        for(int i = 0;i < edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        \\n\\n        priority_queue<pair<double,int>>pq;\\n\\n        // pushing the starting node and prob of going from start node to start node is obviously 1\\n        pq.push({1.0,start});\\n        \\n        //prob of going from start node to start node is obviously 1\\n        prob[start] = 1.0;\\n\\n        while(!pq.empty()){\\n            int node = pq.top().second; // node \\n            double node_prob = pq.top().first;// probabilty of that node\\n\\n            pq.pop();\\n\\n            // travelling the neighboring nodes\\n            for(auto it : adj[node]){\\n                int neigh_node = it.first; //neighboring node\\n                double neigh_prob = it.second;// probability of going from node to neighboring node\\n\\n                double new_prob = neigh_prob * node_prob; // new probability - multiplication of the all the other paths to reach this neighboring node\\n                \\n                // checking if it\\'s larger than the already present then we update it and we travel further \\n                if(prob[neigh_node] < new_prob) {\\n                    prob[neigh_node] = new_prob;\\n                    pq.push({prob[neigh_node],neigh_node});\\n                }\\n\\n            }\\n        } \\n\\n        // return the probability of going to the end node\\'\\n        return prob[end];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691404,
                "title": "c-depth-first-search-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon reviewing the code, here are my initial thoughts on how to solve this problem:\\n\\n1. The code appears to use a depth-first search (DFS) approach to explore paths in the graph. It starts from the `start` node and recursively explores neighboring nodes, keeping track of the maximum probability encountered (`ans`).\\n\\n2. The graph is represented using an adjacency list (`adj`) where each node is associated with a vector of its adjacent nodes and their corresponding probabilities.\\n\\n3. The `f` function is the core recursive function that performs the DFS traversal. It uses backtracking to mark nodes as visited (`vis`) and then unmark them after exploring all possible paths.\\n\\n4. The termination condition of the DFS is reaching the `end` node. At this point, the function updates the maximum probability (`ans`) if the current probability (`sum`) is greater.\\n\\n5. The code maintains a minimum threshold (`mn`) for the probability. If the current probability falls below this threshold, the function returns, which helps prune unnecessary paths.\\n\\n6. The `maxProbability` function initializes the visited array (`vis`), creates the adjacency list (`adj`), and calls the `f` function to find the maximum probability.\\n\\n7. The overall complexity of the code seems to be dependent on the size of the graph, as the DFS explores all possible paths. Therefore, the time complexity is likely to be high.\\n\\nTo validate these initial thoughts and gain a better understanding of the code, it would be helpful to analyze the input/output examples, clarify the problem statement, and review the context in which this code is used.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem of finding the maximum probability of reaching a specific node in a graph, my approach would involve modifying the given code slightly. Here\\'s a step-by-step description of the approach:\\n\\n1. Initialize the `ans` variable to 0. This variable will keep track of the maximum probability encountered during the DFS traversal.\\n\\n2. Set a minimum threshold value (`mn`) to determine when to stop exploring a path. If the current probability falls below this threshold, there is no need to continue exploring that path.\\n\\n3. Implement a modified version of the `f` function, which performs a depth-first search (DFS) traversal. The function takes the following parameters:\\n   - `start`: The current node being explored.\\n   - `end`: The destination node.\\n   - `vis`: A vector to keep track of visited nodes.\\n   - `adj`: The adjacency list representing the graph.\\n   - `sum`: The current probability product.\\n\\n4. Inside the `f` function, include the following steps:\\n   - If the current `sum` is less than or equal to the minimum threshold (`mn`), return.\\n   - If the current node is the destination node (`start == end`), update the maximum probability (`ans`) if the current `sum` is greater.\\n   - Mark the current node as visited (`vis[start] = true`).\\n   - Iterate over the adjacent nodes of the current node using the adjacency list `adj[start]`.\\n     - For each adjacent node, obtain the child node index (`child`) and the probability (`p`).\\n     - If the child node is not visited (`vis[child] == false`) and the current probability times the edge probability is greater than the current answer (`sum * p >= ans`), recursively call the `f` function with the child node, updated `vis` vector, and updated probability (`sum * p`).\\n   - After exploring all possible paths from the current node, mark the current node as not visited again (`vis[start] = false`) before returning.\\n\\n5. In the `maxProbability` function, create the adjacency list `adj` based on the given edges and probabilities.\\n   - Initialize the visited vector (`vis`) with all nodes set to `false`.\\n   - Call the `f` function with the start node, end node, `vis`, `adj`, and an initial probability of 1.\\n   - Return the maximum probability (`ans`) calculated by the `f` function.\\n\\nThis modified approach retains the essence of the original code but ensures that the maximum probability is accurately calculated by using the `ans` variable and the minimum threshold (`mn`) to prune unnecessary paths.\\n\\n# Complexity\\n- Time complexity: O(E * 2^V) or O(E * P)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(V + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double ans = 0;\\n    double mn = 1e-5;\\n\\n    // Recursive function to find the maximum probability\\n    void f(int start, int end, vector<bool> &vis, vector<pair<int, double>> adj[], double sum) {\\n        // If the current sum is less than or equal to the minimum threshold, return\\n        if (sum <= mn) return;\\n\\n        // If we have reached the destination node, update the answer if the current sum is greater\\n        if (start == end) {\\n            ans = max(ans, sum);\\n            return;\\n        }\\n\\n        vis[start] = true;\\n        for (auto node : adj[start]) {\\n            int child = node.first;\\n            double p = node.second;\\n\\n            // If the child node is not visited and the current sum times the probability is greater than the current answer,\\n            // recursively explore the child node\\n            if (vis[child] == false && sum * p >= ans) {\\n                f(child, end, vis, adj, sum * p);\\n            }\\n        }\\n        vis[start] = false;\\n    }\\n\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end)\\n     {\\n        // Create an adjacency list to represent the graph\\n        vector<pair<int, double>> adj[n];\\n        for (int i = 0; i < edges.size(); i++) \\n        {\\n            adj[edges[i][0]].push_back({ edges[i][1], succProb[i] });\\n            adj[edges[i][1]].push_back({ edges[i][0], succProb[i] });\\n        }\\n\\n        // Initialize the visited array\\n        vector<bool> vis(n, false);\\n\\n        // Call the recursive function to find the maximum probability\\n        f(start, end, vis, adj, 1);\\n        return ans;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/1886aab6-7143-408a-b40a-6e8331d757ee_1687929322.411037.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double ans = 0;\\n    double mn = 1e-5;\\n\\n    // Recursive function to find the maximum probability\\n    void f(int start, int end, vector<bool> &vis, vector<pair<int, double>> adj[], double sum) {\\n        // If the current sum is less than or equal to the minimum threshold, return\\n        if (sum <= mn) return;\\n\\n        // If we have reached the destination node, update the answer if the current sum is greater\\n        if (start == end) {\\n            ans = max(ans, sum);\\n            return;\\n        }\\n\\n        vis[start] = true;\\n        for (auto node : adj[start]) {\\n            int child = node.first;\\n            double p = node.second;\\n\\n            // If the child node is not visited and the current sum times the probability is greater than the current answer,\\n            // recursively explore the child node\\n            if (vis[child] == false && sum * p >= ans) {\\n                f(child, end, vis, adj, sum * p);\\n            }\\n        }\\n        vis[start] = false;\\n    }\\n\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end)\\n     {\\n        // Create an adjacency list to represent the graph\\n        vector<pair<int, double>> adj[n];\\n        for (int i = 0; i < edges.size(); i++) \\n        {\\n            adj[edges[i][0]].push_back({ edges[i][1], succProb[i] });\\n            adj[edges[i][1]].push_back({ edges[i][0], succProb[i] });\\n        }\\n\\n        // Initialize the visited array\\n        vector<bool> vis(n, false);\\n\\n        // Call the recursive function to find the maximum probability\\n        f(start, end, vis, adj, 1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036302,
                "title": "my-java-solution-using-djikstra-with-some-comments-as-explanation",
                "content": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        // construct the map\\n        Map<Integer, List<int[]>> graph = generateGraph(edges);\\n        // generate a probability array to track down the probability\\n        double [] probability = new double[n];\\n        // make the prob of start as 1 and all others 0\\n        probability[start] = 1d;\\n        // use a priorityQueue\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparingDouble(i -> -probability[i]));\\n        pq.offer(start);\\n        while (!pq.isEmpty()) {\\n            int current = pq.poll();\\n            // if reached the end position\\n            if (current == end)\\n                return probability[end];\\n            for (int [] child : graph.getOrDefault(current, Collections.emptyList())) {\\n                int neighbour = child[0];\\n                int neighbourIndex = child[1];\\n                // check if the product of currentProb and value at the succprob of neighbor index > probability of neighbour\\n                // if yes, update the probability of neighbour\\n                // add the neighbour to the pq\\n                double currentProb = probability[current] * succProb[neighbourIndex];\\n                if (currentProb > probability[neighbour]) {\\n                    probability[neighbour] = currentProb;\\n                    pq.offer(neighbour);\\n                }\\n            }\\n        }\\n        return 0d;\\n    }\\n    \\n    public Map<Integer, List<int[]>> generateGraph(int [][] edges) {\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int i=0; i<edges.length; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            // we need an undirected graph -> we add neighbours, index\\n            graph.computeIfAbsent(a, x -> new ArrayList<>()).add(new int []{b, i});\\n            graph.computeIfAbsent(b, x -> new ArrayList<>()).add(new int []{a, i});\\n        }\\n        return graph;\\n    }\\n}\\n```\\nThis code gets wrong answer for the test case :\\n6\\n[[2,0],[2,3],[2,5],[2,4],[5,3],[3,1],[0,3],[4,5],[5,0]]\\n[0.8701,0.9375,0.5994,0.1174,0.6767,0.6912,0.0488,0.1562,0.9872]\\n5\\n3\\n\\n```java\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        double [] distance = new double [n];\\n        distance[start] = 1.0;\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            int s = edges[i][0];\\n            int d = edges[i][1];\\n            double weight = succProb[i];\\n            graph.get(s).add(new Pair(d, weight));\\n            graph.get(d).add(new Pair(s, weight));\\n        }\\n        \\n        // here we need max probability, so we use maxHeap\\n        PriorityQueue<Pair> maxHeap = new PriorityQueue<>((t1, t2) -> Double.compare(t2.weight, t1.weight));\\n        maxHeap.offer(new Pair(start, distance[start]));\\n        while (!maxHeap.isEmpty()) {\\n            Pair current = maxHeap.poll();\\n            int s = current.start;\\n            double weight = current.weight;\\n            if (s == end) {\\n                return weight;\\n            }\\n            List<Pair> children = graph.get(s);\\n            for (Pair child : children) {\\n                int childNode = child.start;\\n                double childWeight =  child.weight;\\n                if (distance[s] * childWeight > distance[childNode]) {\\n                    distance[childNode] = distance[s] * childWeight;\\n                    maxHeap.offer(new Pair(childNode, distance[childNode]));\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n\\nclass Pair {\\n    int start;\\n    double weight;\\n    \\n    public Pair(int start, double weight) {\\n        this.start = start;\\n        this.weight = weight;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        // construct the map\\n        Map<Integer, List<int[]>> graph = generateGraph(edges);\\n        // generate a probability array to track down the probability\\n        double [] probability = new double[n];\\n        // make the prob of start as 1 and all others 0\\n        probability[start] = 1d;\\n        // use a priorityQueue\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparingDouble(i -> -probability[i]));\\n        pq.offer(start);\\n        while (!pq.isEmpty()) {\\n            int current = pq.poll();\\n            // if reached the end position\\n            if (current == end)\\n                return probability[end];\\n            for (int [] child : graph.getOrDefault(current, Collections.emptyList())) {\\n                int neighbour = child[0];\\n                int neighbourIndex = child[1];\\n                // check if the product of currentProb and value at the succprob of neighbor index > probability of neighbour\\n                // if yes, update the probability of neighbour\\n                // add the neighbour to the pq\\n                double currentProb = probability[current] * succProb[neighbourIndex];\\n                if (currentProb > probability[neighbour]) {\\n                    probability[neighbour] = currentProb;\\n                    pq.offer(neighbour);\\n                }\\n            }\\n        }\\n        return 0d;\\n    }\\n    \\n    public Map<Integer, List<int[]>> generateGraph(int [][] edges) {\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int i=0; i<edges.length; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            // we need an undirected graph -> we add neighbours, index\\n            graph.computeIfAbsent(a, x -> new ArrayList<>()).add(new int []{b, i});\\n            graph.computeIfAbsent(b, x -> new ArrayList<>()).add(new int []{a, i});\\n        }\\n        return graph;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        double [] distance = new double [n];\\n        distance[start] = 1.0;\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            int s = edges[i][0];\\n            int d = edges[i][1];\\n            double weight = succProb[i];\\n            graph.get(s).add(new Pair(d, weight));\\n            graph.get(d).add(new Pair(s, weight));\\n        }\\n        \\n        // here we need max probability, so we use maxHeap\\n        PriorityQueue<Pair> maxHeap = new PriorityQueue<>((t1, t2) -> Double.compare(t2.weight, t1.weight));\\n        maxHeap.offer(new Pair(start, distance[start]));\\n        while (!maxHeap.isEmpty()) {\\n            Pair current = maxHeap.poll();\\n            int s = current.start;\\n            double weight = current.weight;\\n            if (s == end) {\\n                return weight;\\n            }\\n            List<Pair> children = graph.get(s);\\n            for (Pair child : children) {\\n                int childNode = child.start;\\n                double childWeight =  child.weight;\\n                if (distance[s] * childWeight > distance[childNode]) {\\n                    distance[childNode] = distance[s] * childWeight;\\n                    maxHeap.offer(new Pair(childNode, distance[childNode]));\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n\\nclass Pair {\\n    int start;\\n    double weight;\\n    \\n    public Pair(int start, double weight) {\\n        this.start = start;\\n        this.weight = weight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691374,
                "title": "c-dijkstra-easy-approach",
                "content": "### \\uD83D\\uDD25 Donn forget to Upvote if you liked the code \\uD83D\\uDD25\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>v[n];\\n        vector<int> visited(n,0);\\n        vector<double> ans(n,0);\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            v[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            v[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1,start});\\n        \\n        while(pq.size())\\n        {\\n            pair<double,int> z=pq.top();\\n            pq.pop();\\n            ans[z.second]=max(ans[z.second],z.first);\\n\\n            if(visited[z.second]) continue;\\n            visited[z.second]=1;\\n\\n            for(int i=0;i<v[z.second].size();i++)\\n            {\\n                pq.push({z.first*v[z.second][i].second,v[z.second][i].first});\\n            }\\n        }\\n\\n        return ans[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>v[n];\\n        vector<int> visited(n,0);\\n        vector<double> ans(n,0);\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            v[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            v[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1,start});\\n        \\n        while(pq.size())\\n        {\\n            pair<double,int> z=pq.top();\\n            pq.pop();\\n            ans[z.second]=max(ans[z.second],z.first);\\n\\n            if(visited[z.second]) continue;\\n            visited[z.second]=1;\\n\\n            for(int i=0;i<v[z.second].size();i++)\\n            {\\n                pq.push({z.first*v[z.second][i].second,v[z.second][i].first});\\n            }\\n        }\\n\\n        return ans[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691175,
                "title": "c-solution-for-path-with-minimum-probability-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be framed as a graph problem, where each node represents a city and each edge represents a path between cities.\\nThe edge weights represent the probability of successfully traveling along that path.\\nWe need to find the maximum probability of reaching the end city starting from the start city.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The solution starts by building a graph using a dictionary. Each key in the dictionary represents a city, and the corresponding value is a list of tuples containing the neighboring city and the probability of reaching that neighbor.\\n1. The graph is constructed by iterating over the given edges and adding the neighbors and probabilities to the corresponding city in the dictionary.\\n1. Next, a \"maxProb\" array is initialized to store the maximum probability of reaching each city. The start city is set to have a probability of 1, and all other cities have a probability of 0 initially.\\n1. A queue is used to perform a breadth-first search (BFS) traversal of the graph.\\n1. The BFS starts from the start city and iterates over its neighbors. For each neighbor, the probability of reaching it is calculated by multiplying the probability of reaching the current city (curNode) by the probability of the edge connecting them.\\n1. If the calculated probability is greater than the current maximum probability of reaching the neighbor, it is updated, and the neighbor is enqueued to explore its neighbors in the next iterations.\\n1. The BFS continues until all reachable cities are visited, and the maximum probability of reaching the end city is stored in the maxProb[end] value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nConstructing the graph takes O(E) time, where E is the number of edges. The BFS traversal visits each edge and node once, resulting in a time complexity of O(V + E), where V is the number of vertices (cities) and E is the number of edges (paths).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(V + E) because of the graph representation using a dictionary, where V is the number of vertices and E is the number of edges. Additionally, the \"maxProb\" array and the queue require O(V) space. Therefore, the overall space complexity is O(V + E).\\n\\n# Code\\n```\\npublic class Solution {\\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n         Dictionary<int, List<(int, double)>> graph = new Dictionary<int, List<(int, double)>>();\\n\\n        for (int i = 0; i < edges.Length; i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double pathProb = succProb[i];\\n\\n            if (!graph.ContainsKey(u))\\n                graph[u] = new List<(int, double)>();\\n\\n            if (!graph.ContainsKey(v))\\n                graph[v] = new List<(int, double)>();\\n\\n            graph[u].Add((v, pathProb));\\n            graph[v].Add((u, pathProb));\\n        }\\n\\n        double[] maxProb = new double[n];\\n        maxProb[start] = 1d;\\n\\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(start);\\n\\n        while (queue.Count > 0)\\n        {\\n            int curNode = queue.Dequeue();\\n            foreach ((int nxtNode, double pathProb) in graph.GetValueOrDefault(curNode, new List<(int, double)>()))\\n            {\\n                // Only update maxProb[nxtNode] if the current path increases\\n                // the probability of reaching nxtNode.\\n                if (maxProb[curNode] * pathProb > maxProb[nxtNode])\\n                {\\n                    maxProb[nxtNode] = maxProb[curNode] * pathProb;\\n                    queue.Enqueue(nxtNode);\\n                }\\n            }\\n        }\\n\\n        return maxProb[end];\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n         Dictionary<int, List<(int, double)>> graph = new Dictionary<int, List<(int, double)>>();\\n\\n        for (int i = 0; i < edges.Length; i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double pathProb = succProb[i];\\n\\n            if (!graph.ContainsKey(u))\\n                graph[u] = new List<(int, double)>();\\n\\n            if (!graph.ContainsKey(v))\\n                graph[v] = new List<(int, double)>();\\n\\n            graph[u].Add((v, pathProb));\\n            graph[v].Add((u, pathProb));\\n        }\\n\\n        double[] maxProb = new double[n];\\n        maxProb[start] = 1d;\\n\\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(start);\\n\\n        while (queue.Count > 0)\\n        {\\n            int curNode = queue.Dequeue();\\n            foreach ((int nxtNode, double pathProb) in graph.GetValueOrDefault(curNode, new List<(int, double)>()))\\n            {\\n                // Only update maxProb[nxtNode] if the current path increases\\n                // the probability of reaching nxtNode.\\n                if (maxProb[curNode] * pathProb > maxProb[nxtNode])\\n                {\\n                    maxProb[nxtNode] = maxProb[curNode] * pathProb;\\n                    queue.Enqueue(nxtNode);\\n                }\\n            }\\n        }\\n\\n        return maxProb[end];\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235638,
                "title": "python3-i-know-what-u-want",
                "content": "```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        ed,suc,s,e=edges,succProb,start,end\\n        d=defaultdict(list)\\n        for (a,b),prob in zip(ed,suc):\\n            d[a].append((b,prob))\\n            d[b].append((a,prob))\\n        heap=[(-1,s)]\\n        seen=set()\\n        while heap:\\n            prob,cur=heappop(heap)\\n            seen.add(cur)\\n            if cur==end:\\n                return -prob\\n            for neigh,p in d[cur]:\\n                if not neigh in seen:\\n                    new_prob=-1*abs(prob*p)\\n                    heappush(heap,(new_prob,neigh))\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        ed,suc,s,e=edges,succProb,start,end\\n        d=defaultdict(list)\\n        for (a,b),prob in zip(ed,suc):\\n            d[a].append((b,prob))\\n            d[b].append((a,prob))\\n        heap=[(-1,s)]\\n        seen=set()\\n        while heap:\\n            prob,cur=heappop(heap)\\n            seen.add(cur)\\n            if cur==end:\\n                return -prob\\n            for neigh,p in d[cur]:\\n                if not neigh in seen:\\n                    new_prob=-1*abs(prob*p)\\n                    heappush(heap,(new_prob,neigh))\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891135,
                "title": "easy-to-understand-java-code-with-comments-dijsktra",
                "content": "```\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n         // create adjacency list\\n        List<double[]>[] adjList = new ArrayList[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            adjList[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            adjList[edges[i][0]].add(new double[] {edges[i][1],succProb[i]});\\n            adjList[edges[i][1]].add(new double[] {edges[i][0],succProb[i]});\\n        }\\n        // adjacency list created\\n\\n\\n\\n        // probability to reach any node : store in prob array at corresponding position\\n        double[] prob = new double[n];\\n        prob[start] = 1.0;  // start to start prabability = 1.0\\n\\n        // for not coming to already visited number mark that visited\\n        boolean[] vis = new boolean[n];\\n\\n\\n\\n        // simple priorityQueue\\n        Queue <double[]> queue = new PriorityQueue<>(Collections.reverseOrder((a, b) -> Double.compare(a[1],b[1])));\\n        queue.add(new double[]{start,1.0});\\n\\n\\n        while (!queue.isEmpty()){\\n            double[] cur = queue.poll();\\n            int curNode = (int) cur[0];\\n            if(curNode == end) return cur[1];  // if we reach at end node/number return pcorreponding probability\\n            if(vis[curNode] == true) continue; // if already visited node skip it.\\n            vis[curNode] = true; // if not visited before then mark it as  visited\\n\\n            double curProb = cur[1];\\n\\n\\n            for (double[] g : adjList[curNode]) {\\n                int nxt = (int)g[0];\\n                double p = g[1];\\n                double val = prob[nxt];\\n                if(curProb*p > prob[nxt]){  // if you are getting more value for corresponding position in prob array update that and add new pair in that\\n                    queue.add(new double[]{nxt,curProb*p});\\n                }\\n            }\\n\\n        }\\n\\n        // If there is no path from start to end, return 0\\n        return 0.0;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n         // create adjacency list\\n        List<double[]>[] adjList = new ArrayList[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            adjList[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            adjList[edges[i][0]].add(new double[] {edges[i][1],succProb[i]});\\n            adjList[edges[i][1]].add(new double[] {edges[i][0],succProb[i]});\\n        }\\n        // adjacency list created\\n\\n\\n\\n        // probability to reach any node : store in prob array at corresponding position\\n        double[] prob = new double[n];\\n        prob[start] = 1.0;  // start to start prabability = 1.0\\n\\n        // for not coming to already visited number mark that visited\\n        boolean[] vis = new boolean[n];\\n\\n\\n\\n        // simple priorityQueue\\n        Queue <double[]> queue = new PriorityQueue<>(Collections.reverseOrder((a, b) -> Double.compare(a[1],b[1])));\\n        queue.add(new double[]{start,1.0});\\n\\n\\n        while (!queue.isEmpty()){\\n            double[] cur = queue.poll();\\n            int curNode = (int) cur[0];\\n            if(curNode == end) return cur[1];  // if we reach at end node/number return pcorreponding probability\\n            if(vis[curNode] == true) continue; // if already visited node skip it.\\n            vis[curNode] = true; // if not visited before then mark it as  visited\\n\\n            double curProb = cur[1];\\n\\n\\n            for (double[] g : adjList[curNode]) {\\n                int nxt = (int)g[0];\\n                double p = g[1];\\n                double val = prob[nxt];\\n                if(curProb*p > prob[nxt]){  // if you are getting more value for corresponding position in prob array update that and add new pair in that\\n                    queue.add(new double[]{nxt,curProb*p});\\n                }\\n            }\\n\\n        }\\n\\n        // If there is no path from start to end, return 0\\n        return 0.0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1804460,
                "title": "java-dijkstra-s-algorithm",
                "content": "```java\\nclass Node implements Comparator<Node> {\\n    private int v;\\n    private double weight;\\n    \\n    Node(int v, double weight) {\\n        this.v = v;\\n        this.weight = weight;\\n    }\\n    Node() {\\n        \\n    }\\n    int getV() {\\n        return v;\\n    }\\n    double getWeight() {\\n        return weight;\\n    }\\n    @Override\\n    public int compare(Node n1, Node n2) { // max heap\\n        if(n1.weight < n2.weight) {\\n            return 1;\\n        }\\n        if(n1.weight > n2.weight) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n}\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        List<List<Node>> adj = new ArrayList<>();\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0 ; i<edges.length ; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double wt = succProb[i];\\n\\n            adj.get(u).add(new Node(v, wt));\\n            adj.get(v).add(new Node(u, wt));\\n        }\\n\\n        PriorityQueue<Node> pq = new PriorityQueue<>(n, new Node());\\n        pq.add(new Node(start, 1));\\n        \\n        HashSet<Integer> pst = new HashSet<>();\\n        \\n        while(!pq.isEmpty()) {\\n            Node node = pq.poll();\\n            int num = node.getV();\\n            double prob = node.getWeight();\\n            \\n            pst.add(num);\\n            \\n            if(num == end) {\\n                return prob;\\n            }\\n            \\n            if(adj.get(num) != null) {\\n                for(Node it : adj.get(num)) {\\n                    if(!pst.contains(it.getV())) {\\n                        pq.add(new Node(it.getV(), prob * it.getWeight()));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Node implements Comparator<Node> {\\n    private int v;\\n    private double weight;\\n    \\n    Node(int v, double weight) {\\n        this.v = v;\\n        this.weight = weight;\\n    }\\n    Node() {\\n        \\n    }\\n    int getV() {\\n        return v;\\n    }\\n    double getWeight() {\\n        return weight;\\n    }\\n    @Override\\n    public int compare(Node n1, Node n2) { // max heap\\n        if(n1.weight < n2.weight) {\\n            return 1;\\n        }\\n        if(n1.weight > n2.weight) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n}\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        List<List<Node>> adj = new ArrayList<>();\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0 ; i<edges.length ; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double wt = succProb[i];\\n\\n            adj.get(u).add(new Node(v, wt));\\n            adj.get(v).add(new Node(u, wt));\\n        }\\n\\n        PriorityQueue<Node> pq = new PriorityQueue<>(n, new Node());\\n        pq.add(new Node(start, 1));\\n        \\n        HashSet<Integer> pst = new HashSet<>();\\n        \\n        while(!pq.isEmpty()) {\\n            Node node = pq.poll();\\n            int num = node.getV();\\n            double prob = node.getWeight();\\n            \\n            pst.add(num);\\n            \\n            if(num == end) {\\n                return prob;\\n            }\\n            \\n            if(adj.get(num) != null) {\\n                for(Node it : adj.get(num)) {\\n                    if(!pst.contains(it.getV())) {\\n                        pq.add(new Node(it.getV(), prob * it.getWeight()));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316345,
                "title": "c-djikstra-s-approach-with-max-heap-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    void djikstraPath(vector<pair<int, double>> adj[], int totalNodes, int source, vector<double> &dist) {\\n        priority_queue<pair<double, int>,vector <pair<double, int>>> pq;\\n        pq.push(make_pair(1, source));\\n        dist[source] = 1;\\n        while(!pq.empty()) {\\n            int u = pq.top().second;\\n            pq.pop();\\n            for(int v = 0; v < adj[u].size(); ++v) {\\n                int neighbour= adj[u][v].first;\\n                double weight = adj[u][v].second;\\n                if(dist[neighbour] < dist[u] * weight) {\\n                    dist[neighbour] = dist[u] * weight;\\n                    pq.push({dist[neighbour],neighbour});\\n                }\\n            }\\n        }\\n    }\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int, double>> adj[n];\\n        vector<double> dist(n, 0);\\n        int i;\\n        for(i = 0; i < edges.size(); ++i) {\\n            adj[edges[i][0]].push_back(make_pair(edges[i][1], succProb[i]));\\n            adj[edges[i][1]].push_back(make_pair(edges[i][0], succProb[i]));\\n        }\\n        djikstraPath(adj, n, start, dist);\\n        return dist[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void djikstraPath(vector<pair<int, double>> adj[], int totalNodes, int source, vector<double> &dist) {\\n        priority_queue<pair<double, int>,vector <pair<double, int>>> pq;\\n        pq.push(make_pair(1, source));\\n        dist[source] = 1;\\n        while(!pq.empty()) {\\n            int u = pq.top().second;\\n            pq.pop();\\n            for(int v = 0; v < adj[u].size(); ++v) {\\n                int neighbour= adj[u][v].first;\\n                double weight = adj[u][v].second;\\n                if(dist[neighbour] < dist[u] * weight) {\\n                    dist[neighbour] = dist[u] * weight;\\n                    pq.push({dist[neighbour],neighbour});\\n                }\\n            }\\n        }\\n    }\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int, double>> adj[n];\\n        vector<double> dist(n, 0);\\n        int i;\\n        for(i = 0; i < edges.size(); ++i) {\\n            adj[edges[i][0]].push_back(make_pair(edges[i][1], succProb[i]));\\n            adj[edges[i][1]].push_back(make_pair(edges[i][0], succProb[i]));\\n        }\\n        djikstraPath(adj, n, start, dist);\\n        return dist[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262898,
                "title": "dijkstra-and-bellman-ford-algorithm-c",
                "content": "My first(failed) intuition was to create an adjacency matrix and perform Dijkstra algorithm without priority queue.\\nHowever, since number of nodes could be 10^4, it led to memory limit exceeded error.\\nSo, I decided to use priority queue on adjacency list graph. The Dijkstra code is as follows :\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        int s = edges.size();\\n        \\n        vector<vector<pair<int, double>>> graph(n);\\n        \\n        int i = 0;\\n        for(auto e : edges){//creating adjacency list\\n            int a = e[0];\\n            int b = e[1];\\n            graph[a].push_back({b , succProb[i]});\\n            graph[b].push_back({a , succProb[i]});\\n            i += 1;\\n        }\\n        \\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1.0, start});\\n        vector<double> distance(n, 0.0);\\n        distance[start] = 1.0;\\n        \\n        while(!pq.empty()){\\n            auto [d , x] = pq.top();\\n            pq.pop();\\n            \\n            if(x == end)\\n                return d;//early exit\\n            for(auto a : graph[x]){\\n                double nd = d * a.second;\\n                if(nd > distance[a.first]){//relaxing the distance\\n                    distance[a.first] = nd;\\n                    pq.push({nd , a.first});\\n                }        \\n            }\\n            \\n        }\\n        return 0.0;\\n    }\\n};\\n```\\nThe Bellman Ford algorithm requires precisely 3 changes to the above code:\\n1. Replace priority_queue with queue,\\n2. Replace pq.top() with pq.front()\\n3. Remove early exit condition and return only at the end of while loop.\\n\\nHere is the code:\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        int s = edges.size();\\n        \\n        vector<vector<pair<int, double>>> graph(n);\\n        \\n        int i = 0;\\n        for(auto e : edges){//creating adjacency list\\n            int a = e[0];\\n            int b = e[1];\\n            graph[a].push_back({b , succProb[i]});\\n            graph[b].push_back({a , succProb[i]});\\n            i += 1;\\n        }\\n        \\n        queue<pair<double, int>> pq;\\n        pq.push({1.0, start});\\n        vector<double> distance(n, 0.0);\\n        distance[start] = 1.0;\\n        \\n        while(!pq.empty()){\\n            auto [d , x] = pq.front();\\n            pq.pop();\\n            \\n            for(auto a : graph[x]){\\n                double nd = d * a.second;\\n                if(nd > distance[a.first]){//relaxing the distance\\n                    distance[a.first] = nd;\\n                    pq.push({nd , a.first});\\n                }        \\n            }\\n            \\n        }\\n        return distance[end];\\n    }\\n};\\n```\\nBellman Ford was slower than Dijkstra though both passed all the test cases.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        int s = edges.size();\\n        \\n        vector<vector<pair<int, double>>> graph(n);\\n        \\n        int i = 0;\\n        for(auto e : edges){//creating adjacency list\\n            int a = e[0];\\n            int b = e[1];\\n            graph[a].push_back({b , succProb[i]});\\n            graph[b].push_back({a , succProb[i]});\\n            i += 1;\\n        }\\n        \\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1.0, start});\\n        vector<double> distance(n, 0.0);\\n        distance[start] = 1.0;\\n        \\n        while(!pq.empty()){\\n            auto [d , x] = pq.top();\\n            pq.pop();\\n            \\n            if(x == end)\\n                return d;//early exit\\n            for(auto a : graph[x]){\\n                double nd = d * a.second;\\n                if(nd > distance[a.first]){//relaxing the distance\\n                    distance[a.first] = nd;\\n                    pq.push({nd , a.first});\\n                }        \\n            }\\n            \\n        }\\n        return 0.0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        int s = edges.size();\\n        \\n        vector<vector<pair<int, double>>> graph(n);\\n        \\n        int i = 0;\\n        for(auto e : edges){//creating adjacency list\\n            int a = e[0];\\n            int b = e[1];\\n            graph[a].push_back({b , succProb[i]});\\n            graph[b].push_back({a , succProb[i]});\\n            i += 1;\\n        }\\n        \\n        queue<pair<double, int>> pq;\\n        pq.push({1.0, start});\\n        vector<double> distance(n, 0.0);\\n        distance[start] = 1.0;\\n        \\n        while(!pq.empty()){\\n            auto [d , x] = pq.front();\\n            pq.pop();\\n            \\n            for(auto a : graph[x]){\\n                double nd = d * a.second;\\n                if(nd > distance[a.first]){//relaxing the distance\\n                    distance[a.first] = nd;\\n                    pq.push({nd , a.first});\\n                }        \\n            }\\n            \\n        }\\n        return distance[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175437,
                "title": "python-bfs",
                "content": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution(object):\\n    def maxProbability(self, n, edges, succProb, start, end):\\n        g = defaultdict(list)\\n\\n        for i in range(len(edges)):\\n            src, dst = edges[i][0], edges[i][1]\\n            prob = succProb[i]\\n            g[src].append((dst, prob))\\n            g[dst].append((src, prob))\\n\\n        q = deque()\\n        q.append((start, 1))\\n        visited = defaultdict(int)\\n\\n        while q:\\n            node, prob = q.popleft()\\n            if visited[node] > prob:\\n                continue\\n            else:\\n                visited[node] = prob\\n\\n            for adj, nextProb in g[node]:\\n                if visited[adj] < prob * nextProb:\\n                    q.append((adj, prob * nextProb))\\n\\n        return visited[end]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution(object):\\n    def maxProbability(self, n, edges, succProb, start, end):\\n        g = defaultdict(list)\\n\\n        for i in range(len(edges)):\\n            src, dst = edges[i][0], edges[i][1]\\n            prob = succProb[i]\\n            g[src].append((dst, prob))\\n            g[dst].append((src, prob))\\n\\n        q = deque()\\n        q.append((start, 1))\\n        visited = defaultdict(int)\\n\\n        while q:\\n            node, prob = q.popleft()\\n            if visited[node] > prob:\\n                continue\\n            else:\\n                visited[node] = prob\\n\\n            for adj, nextProb in g[node]:\\n                if visited[adj] < prob * nextProb:\\n                    q.append((adj, prob * nextProb))\\n\\n        return visited[end]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747199,
                "title": "c-modifies-dijkstra-with-comment-98-time-and-100-space",
                "content": "```\\n#include<bits/stdc++.h>\\n#define mod 1000000007\\n#define pb push_back\\n#define infinte 2147483647\\n#define fon(i,n) for(unsigned int i=0 ; i<n ; i++)\\n#define ui\\tunsigned int\\n#define ll long long\\n#define ull unsigned long long \\n#define uos unordered_set\\n#define ump unordered_map\\n#define mp make_pair\\nusing namespace std;\\ninline int max(int a,int b){ return (a>b)?a:b;}\\ninline int min(int a,int b){ return (a>b)?b:a;}\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n\\tvector<pair<int,double>> *adjList=new vector<pair<int,double>>[n];\\n\\t//make an adjaceny list \\n\\tfon(i,edges.size()){\\n\\t\\t \\tadjList[edges[i][0]].pb(mp(edges[i][1],succProb[i]));\\n\\t\\t \\tadjList[edges[i][1]].pb(mp(edges[i][0],succProb[i]));\\n\\t}\\n\\tbool *visited=new bool[n];//represent weather our current vertex is included in mst or not\\n\\tdouble *prob=new double[n];//give the max probibilty from start to end\\n\\tfon(i,n)visited[i]=false ,prob[i]=0.0000;\\n\\tprob[start]=1;//current node is always a reachable with current node\\n\\tpriority_queue<pair<double ,int>> pq;\\n\\tpq.push(mp(1 ,start));//insert pq with 1 probability and start node\\n\\twhile(pq.size()){\\n\\t\\tint u=pq.top().second;\\n\\t\\tvisited[u]=true;\\n\\t\\tdouble probU=pq.top().first;\\n\\t\\tpq.pop();\\n\\t\\tfon(i,adjList[u].size()){\\n\\t\\t\\tint v=adjList[u][i].first;\\n\\t\\t\\t//if v already in mst just ingore that avoid same comparison \\n\\t\\t\\tif(visited[v]) continue;\\n\\t\\t\\tdouble probV=adjList[u][i].second;\\n\\t\\t\\t//if probability of start to v is lesser than the probability start to u and u to v..\\n\\t\\t\\t//this step called as relaxation\\n\\t\\t\\tif(prob[v]<(probU*probV)){\\n\\t\\t\\t\\tprob[v]=probU*probV;\\n\\t\\t\\t\\tpq.push(mp(prob[v] ,v));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tdouble ans=prob[end];\\n\\tdelete []prob;\\n\\tdelete []visited;\\n\\tdelete []adjList;\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\n#define mod 1000000007\\n#define pb push_back\\n#define infinte 2147483647\\n#define fon(i,n) for(unsigned int i=0 ; i<n ; i++)\\n#define ui\\tunsigned int\\n#define ll long long\\n#define ull unsigned long long \\n#define uos unordered_set\\n#define ump unordered_map\\n#define mp make_pair\\nusing namespace std;\\ninline int max(int a,int b){ return (a>b)?a:b;}\\ninline int min(int a,int b){ return (a>b)?b:a;}\\ndouble maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n\\tvector<pair<int,double>> *adjList=new vector<pair<int,double>>[n];\\n\\t//make an adjaceny list \\n\\tfon(i,edges.size()){\\n\\t\\t \\tadjList[edges[i][0]].pb(mp(edges[i][1],succProb[i]));\\n\\t\\t \\tadjList[edges[i][1]].pb(mp(edges[i][0],succProb[i]));\\n\\t}\\n\\tbool *visited=new bool[n];//represent weather our current vertex is included in mst or not\\n\\tdouble *prob=new double[n];//give the max probibilty from start to end\\n\\tfon(i,n)visited[i]=false ,prob[i]=0.0000;\\n\\tprob[start]=1;//current node is always a reachable with current node\\n\\tpriority_queue<pair<double ,int>> pq;\\n\\tpq.push(mp(1 ,start));//insert pq with 1 probability and start node\\n\\twhile(pq.size()){\\n\\t\\tint u=pq.top().second;\\n\\t\\tvisited[u]=true;\\n\\t\\tdouble probU=pq.top().first;\\n\\t\\tpq.pop();\\n\\t\\tfon(i,adjList[u].size()){\\n\\t\\t\\tint v=adjList[u][i].first;\\n\\t\\t\\t//if v already in mst just ingore that avoid same comparison \\n\\t\\t\\tif(visited[v]) continue;\\n\\t\\t\\tdouble probV=adjList[u][i].second;\\n\\t\\t\\t//if probability of start to v is lesser than the probability start to u and u to v..\\n\\t\\t\\t//this step called as relaxation\\n\\t\\t\\tif(prob[v]<(probU*probV)){\\n\\t\\t\\t\\tprob[v]=probU*probV;\\n\\t\\t\\t\\tpq.push(mp(prob[v] ,v));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tdouble ans=prob[end];\\n\\tdelete []prob;\\n\\tdelete []visited;\\n\\tdelete []adjList;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 742828,
                "title": "very-efficient-and-easy-to-undersand-bfs",
                "content": "Easy to understand BFS:\\n\\n```js\\nvar maxProbability = function(n, edges, succProb, start, end) {\\n  const p = Array(n).fill(0);\\n  const graph = p.reduce((m, _, i) => m.set(i, []), new Map());\\n  edges.forEach(([u, v], i) => {\\n    graph.get(u).push([v, succProb[i]]);\\n    graph.get(v).push([u, succProb[i]]);\\n  });\\n  \\n  const queue = [[start, 1]];\\n  p[start] = 1;\\n  \\n  for (let [node, currP] of queue) {   \\n    for (let [adj, nextP] of graph.get(node)) {\\n      if (currP * nextP > p[adj]) {\\n        p[adj] = currP * nextP;\\n        queue.push([adj, p[adj]]);\\n      }\\n    }\\n  }\\n  \\n  return p[end];\\n};\\n```\\n\\nNotes:\\n- BFS more efficient for shortest path. DFS tries too many paths and will TLE\\n- We need to keep track of the computed max probability per node. So we initialize and array `p` with all `0`. Then as we visit we update the prob with the max number. If a path doesn\\'t lead to a better prob, we don\\'t include it on the path.\\n- At the end we return the best probability found for the targeted node",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```js\\nvar maxProbability = function(n, edges, succProb, start, end) {\\n  const p = Array(n).fill(0);\\n  const graph = p.reduce((m, _, i) => m.set(i, []), new Map());\\n  edges.forEach(([u, v], i) => {\\n    graph.get(u).push([v, succProb[i]]);\\n    graph.get(v).push([u, succProb[i]]);\\n  });\\n  \\n  const queue = [[start, 1]];\\n  p[start] = 1;\\n  \\n  for (let [node, currP] of queue) {   \\n    for (let [adj, nextP] of graph.get(node)) {\\n      if (currP * nextP > p[adj]) {\\n        p[adj] = currP * nextP;\\n        queue.push([adj, p[adj]]);\\n      }\\n    }\\n  }\\n  \\n  return p[end];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732188,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end) \\n    {\\n        var graph = new Dictionary<int, Dictionary<int, double>>();\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new Dictionary<int, double>();\\n        \\n        for(int i = 0; i < edges.Length; i++)\\n        {\\n            int u = edges[i][0], v = edges[i][1];\\n            graph[u][v] = succProb[i];\\n            graph[v][u] = succProb[i];\\n        }\\n        \\n        var prob = new Dictionary<int, double>();\\n        for(int i = 0; i < n; i++)\\n            prob[i] = 0;\\n        prob[start] = 1.0;\\n        var queue = new Queue<int>();\\n        queue.Enqueue(start);\\n\\n        while(queue.Count != 0)\\n        {\\n            var curr = queue.Dequeue();\\n            foreach(var edge in graph[curr])\\n            {\\n                int next = edge.Key;\\n                double p = edge.Value;\\n                if(prob[next] < (prob[curr] * p))\\n                {\\n                    queue.Enqueue(next);\\n                    prob[next] = prob[curr] * p;\\n                }\\n            }\\n        }\\n        \\n        return prob[end];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end) \\n    {\\n        var graph = new Dictionary<int, Dictionary<int, double>>();\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new Dictionary<int, double>();\\n        \\n        for(int i = 0; i < edges.Length; i++)\\n        {\\n            int u = edges[i][0], v = edges[i][1];\\n            graph[u][v] = succProb[i];\\n            graph[v][u] = succProb[i];\\n        }\\n        \\n        var prob = new Dictionary<int, double>();\\n        for(int i = 0; i < n; i++)\\n            prob[i] = 0;\\n        prob[start] = 1.0;\\n        var queue = new Queue<int>();\\n        queue.Enqueue(start);\\n\\n        while(queue.Count != 0)\\n        {\\n            var curr = queue.Dequeue();\\n            foreach(var edge in graph[curr])\\n            {\\n                int next = edge.Key;\\n                double p = edge.Value;\\n                if(prob[next] < (prob[curr] * p))\\n                {\\n                    queue.Enqueue(next);\\n                    prob[next] = prob[curr] * p;\\n                }\\n            }\\n        }\\n        \\n        return prob[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731630,
                "title": "python-dijkstra-heap-commented",
                "content": "It\\'s a quite typical \\'shortest\\' path problem for a undirected graph. [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) works well.\\n\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        # construct the graph\\n        graph = collections.defaultdict(list)\\n        prob = collections.defaultdict(dict)\\n        for i,(p,[a,b]) in enumerate(zip(succProb,edges)):\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            prob[a][b] = prob[b][a] = p\\n        # apply dijkstra\\n        dis = {start:1}\\n        for i in range(n):\\n            dis[i] = 0\\n        visited = set([])\\n        # note that Python only supports min-heap\\n        # so some tricks here to get a max-heap\\n        pq = [(-1,start)]\\n        while pq:\\n            _p, node = heapq.heappop(pq)\\n            visited.add(node)\\n            for child in graph[node]:\\n                if child not in visited:\\n                    if dis[child] < -1 * _p * prob[node][child]:\\n                        heapq.heappush(pq,(_p * prob[node][child],child))\\n                        dis[child] = -1 * _p * prob[node][child]\\n\\n        return dis[end]\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        # construct the graph\\n        graph = collections.defaultdict(list)\\n        prob = collections.defaultdict(dict)\\n        for i,(p,[a,b]) in enumerate(zip(succProb,edges)):\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            prob[a][b] = prob[b][a] = p\\n        # apply dijkstra\\n        dis = {start:1}\\n        for i in range(n):\\n            dis[i] = 0\\n        visited = set([])\\n        # note that Python only supports min-heap\\n        # so some tricks here to get a max-heap\\n        pq = [(-1,start)]\\n        while pq:\\n            _p, node = heapq.heappop(pq)\\n            visited.add(node)\\n            for child in graph[node]:\\n                if child not in visited:\\n                    if dis[child] < -1 * _p * prob[node][child]:\\n                        heapq.heappush(pq,(_p * prob[node][child],child))\\n                        dis[child] = -1 * _p * prob[node][child]\\n\\n        return dis[end]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731563,
                "title": "clean-python-3-bfs",
                "content": "```\\nimport collections\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = collections.defaultdict(dict)\\n        for i, (u, v) in enumerate(edges):\\n            graph[u][v] = succProb[i]\\n            graph[v][u] = succProb[i]\\n        queue = collections.deque([(start, 1)])\\n        possibility = [0] * n\\n        possibility[start] = 1\\n        while queue:\\n            u, pos = queue.popleft()\\n            if u == end: continue\\n            for v, p in graph[u].items():\\n                if p * pos > possibility[v]:\\n                    queue.append((v, p * pos))\\n                    possibility[v] = p * pos\\n        return possibility[end]\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = collections.defaultdict(dict)\\n        for i, (u, v) in enumerate(edges):\\n            graph[u][v] = succProb[i]\\n            graph[v][u] = succProb[i]\\n        queue = collections.deque([(start, 1)])\\n        possibility = [0] * n\\n        possibility[start] = 1\\n        while queue:\\n            u, pos = queue.popleft()\\n            if u == end: continue\\n            for v, p in graph[u].items():\\n                if p * pos > possibility[v]:\\n                    queue.append((v, p * pos))\\n                    possibility[v] = p * pos\\n        return possibility[end]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692387,
                "title": "c-java-python-modified-dijakstra-algorithm-fully-explained",
                "content": "\\n# Explanation\\n- The maxProbability function takes in the following parameters:\\n    - n: An integer representing the number of nodes in the graph.\\n    - eg: A 2D vector of integers representing the edges of the graph.\\n    - p: A vector of doubles representing the probabilities associated with each edge.\\n    - src: An integer representing the source node.\\n    - e: An integer representing the destination node.\\n- The function calculates the maximum probability of reaching the destination node e from the source node src in the given graph.\\n- The graph is represented using an adjacency list g, where each node is associated with a list of pairs (neighbor, probability).\\n- The graph is constructed by iterating over the edges eg and adding the corresponding nodes and probabilities to the adjacency list.\\n- The function uses Dijkstra\\'s algorithm to find the maximum probability. It maintains a priority queue pq to process nodes in the order of decreasing probabilities.\\n- The function initializes the distance vector dis with 0 for all nodes except the source node, which is set to 1.\\n- The function starts by pushing the source node with a probability of 1 to the priority queue.\\n- While the priority queue is not empty, it retrieves the top element, which represents the node with the highest probability so far.\\n- If the retrieved node is the destination node e, the function returns the maximum probability encountered so far.\\n- Otherwise, the function iterates over the neighbors of the current node and checks if the probability of reaching a neighbor through the current node is higher than the previously calculated probability.\\n- If it is, the distance is updated, and the neighbor is added to the priority queue with the new probability.\\n- Finally, if the destination node e is not reached, the function returns 0.\\n\\n# Complexity\\n- Time complexity: **O((V + E) log V)**\\n\\n- Space complexity: **O(V + E)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\n    #define x first\\n    #define y second\\npublic:\\n    double maxProbability(int n, vector<vector<int>>&eg, vector<double>&p, int src, int e) {\\n        vector<pair<int,double>>g[n];\\n        // Creating an adjacency list representation of the graph\\n        // based on the given edges and probabilities\\n        for(int i=0; i<eg.size(); i++){\\n            g[eg[i][0]].push_back({eg[i][1], p[i]});\\n            g[eg[i][1]].push_back({eg[i][0], p[i]});\\n        }\\n        \\n        vector<double>dis(n,0); // Initializing distances from source to all nodes as 0\\n        priority_queue<pair<double,int>>pq; // Priority queue to store nodes based on their maximum probability\\n        \\n        pq.push({1, src}); // Pushing the source node with a probability of 1\\n        dis[src] = 1; // Updating the distance of the source node as 1\\n        \\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            double NodeDis = top.x; // Current maximum probability\\n            int Node = top.y; // Current node\\n            pq.pop();\\n            \\n            if(Node == e) return NodeDis; // If the current node is the destination, return its maximum probability\\n            \\n            // Traverse all the neighboring nodes of the current node\\n            for(auto child : g[Node]){\\n                int ChildNode = child.x; // Neighboring node\\n                double ChildWt = child.y; // Probability of reaching the neighboring node\\n                \\n                // If the current maximum probability multiplied by the probability of reaching the neighboring node\\n                // is greater than the previously calculated maximum probability for the neighboring node,\\n                // update the maximum probability and push the neighboring node into the priority queue\\n                if(ChildWt * NodeDis > dis[ChildNode]){\\n                    dis[ChildNode] = ChildWt * NodeDis;\\n                    pq.push({dis[ChildNode], ChildNode});\\n                }\\n            }\\n        }\\n        \\n        return 0; // If no path is found from source to destination, return 0\\n    }\\n};\\n\\n```\\n```python []\\nimport heapq\\n\\nclass Solution:\\n    def maxProbability(self, n, eg, p, src, e):\\n        g = [[] for _ in range(n)]\\n        \\n        # Creating an adjacency list representation of the graph\\n        # based on the given edges and probabilities\\n        for i in range(len(eg)):\\n            g[eg[i][0]].append((eg[i][1], p[i]))\\n            g[eg[i][1]].append((eg[i][0], p[i]))\\n        \\n        dis = [0] * n  # Initializing distances from source to all nodes as 0\\n        pq = []  # Priority queue to store nodes based on their maximum probability\\n        \\n        heapq.heappush(pq, (-1, src))  # Pushing the source node with a probability of 1\\n        dis[src] = 1  # Updating the distance of the source node as 1\\n        \\n        while pq:\\n            node_dis, node = heapq.heappop(pq)\\n            node_dis *= -1  # Current maximum probability\\n            \\n            if node == e:\\n                return node_dis  # If the current node is the destination, return its maximum probability\\n            \\n            # Traverse all the neighboring nodes of the current node\\n            for child_node, child_wt in g[node]:\\n                # Neighboring node\\n                # Probability of reaching the neighboring node\\n                \\n                # If the current maximum probability multiplied by the probability of reaching the neighboring node\\n                # is greater than the previously calculated maximum probability for the neighboring node,\\n                # update the maximum probability and push the neighboring node into the priority queue\\n                if child_wt * node_dis > dis[child_node]:\\n                    dis[child_node] = child_wt * node_dis\\n                    heapq.heappush(pq, (-dis[child_node], child_node))\\n        \\n        return 0  # If no path is found from source to destination, return 0\\n\\n```\\n```java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n    class Edge {\\n        int node;\\n        double weight;\\n        \\n        public Edge(int node, double weight) {\\n            this.node = node;\\n            this.weight = weight;\\n        }\\n    }\\n    \\n    public double maxProbability(int n, int[][] eg, double[] p, int src, int e) {\\n        List<Edge>[] g = new ArrayList[n];\\n        \\n        // Creating an adjacency list representation of the graph\\n        // based on the given edges and probabilities\\n        for (int i = 0; i < n; i++) {\\n            g[i] = new ArrayList<>();\\n        }\\n        \\n        for (int i = 0; i < eg.length; i++) {\\n            g[eg[i][0]].add(new Edge(eg[i][1], p[i]));\\n            g[eg[i][1]].add(new Edge(eg[i][0], p[i]));\\n        }\\n        \\n        double[] dis = new double[n]; // Initializing distances from source to all nodes as 0\\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> Double.compare(b.weight, a.weight)); // Priority queue to store nodes based on their maximum probability\\n        \\n        pq.offer(new Edge(src, 1)); // Pushing the source node with a probability of 1\\n        dis[src] = 1; // Updating the distance of the source node as 1\\n        \\n        while (!pq.isEmpty()) {\\n            Edge top = pq.poll();\\n            double nodeDis = top.weight; // Current maximum probability\\n            int node = top.node; // Current node\\n            \\n            if (node == e) {\\n                return nodeDis; // If the current node is the destination, return its maximum probability\\n            }\\n            \\n            // Traverse all the neighboring nodes of the current node\\n            for (Edge child : g[node]) {\\n                int childNode = child.node; // Neighboring node\\n                double childWt = child.weight; // Probability of reaching the neighboring node\\n                \\n                // If the current maximum probability multiplied by the probability of reaching the neighboring node\\n                // is greater than the previously calculated maximum probability for the neighboring node,\\n                // update the maximum probability and push the neighboring node into the priority queue\\n                if (childWt * nodeDis > dis[childNode]) {\\n                    dis[childNode] = childWt * nodeDis;\\n                    pq.offer(new Edge(childNode, dis[childNode]));\\n                }\\n            }\\n        }\\n        \\n        return 0; // If no path is found from source to destination, return 0\\n    }\\n}\\n\\n```\\n\\n```\\nPlease upvote if it is helpful\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```C++ []\\nclass Solution {\\n    #define x first\\n    #define y second\\npublic:\\n    double maxProbability(int n, vector<vector<int>>&eg, vector<double>&p, int src, int e) {\\n        vector<pair<int,double>>g[n];\\n        // Creating an adjacency list representation of the graph\\n        // based on the given edges and probabilities\\n        for(int i=0; i<eg.size(); i++){\\n            g[eg[i][0]].push_back({eg[i][1], p[i]});\\n            g[eg[i][1]].push_back({eg[i][0], p[i]});\\n        }\\n        \\n        vector<double>dis(n,0); // Initializing distances from source to all nodes as 0\\n        priority_queue<pair<double,int>>pq; // Priority queue to store nodes based on their maximum probability\\n        \\n        pq.push({1, src}); // Pushing the source node with a probability of 1\\n        dis[src] = 1; // Updating the distance of the source node as 1\\n        \\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            double NodeDis = top.x; // Current maximum probability\\n            int Node = top.y; // Current node\\n            pq.pop();\\n            \\n            if(Node == e) return NodeDis; // If the current node is the destination, return its maximum probability\\n            \\n            // Traverse all the neighboring nodes of the current node\\n            for(auto child : g[Node]){\\n                int ChildNode = child.x; // Neighboring node\\n                double ChildWt = child.y; // Probability of reaching the neighboring node\\n                \\n                // If the current maximum probability multiplied by the probability of reaching the neighboring node\\n                // is greater than the previously calculated maximum probability for the neighboring node,\\n                // update the maximum probability and push the neighboring node into the priority queue\\n                if(ChildWt * NodeDis > dis[ChildNode]){\\n                    dis[ChildNode] = ChildWt * NodeDis;\\n                    pq.push({dis[ChildNode], ChildNode});\\n                }\\n            }\\n        }\\n        \\n        return 0; // If no path is found from source to destination, return 0\\n    }\\n};\\n\\n```\n```python []\\nimport heapq\\n\\nclass Solution:\\n    def maxProbability(self, n, eg, p, src, e):\\n        g = [[] for _ in range(n)]\\n        \\n        # Creating an adjacency list representation of the graph\\n        # based on the given edges and probabilities\\n        for i in range(len(eg)):\\n            g[eg[i][0]].append((eg[i][1], p[i]))\\n            g[eg[i][1]].append((eg[i][0], p[i]))\\n        \\n        dis = [0] * n  # Initializing distances from source to all nodes as 0\\n        pq = []  # Priority queue to store nodes based on their maximum probability\\n        \\n        heapq.heappush(pq, (-1, src))  # Pushing the source node with a probability of 1\\n        dis[src] = 1  # Updating the distance of the source node as 1\\n        \\n        while pq:\\n            node_dis, node = heapq.heappop(pq)\\n            node_dis *= -1  # Current maximum probability\\n            \\n            if node == e:\\n                return node_dis  # If the current node is the destination, return its maximum probability\\n            \\n            # Traverse all the neighboring nodes of the current node\\n            for child_node, child_wt in g[node]:\\n                # Neighboring node\\n                # Probability of reaching the neighboring node\\n                \\n                # If the current maximum probability multiplied by the probability of reaching the neighboring node\\n                # is greater than the previously calculated maximum probability for the neighboring node,\\n                # update the maximum probability and push the neighboring node into the priority queue\\n                if child_wt * node_dis > dis[child_node]:\\n                    dis[child_node] = child_wt * node_dis\\n                    heapq.heappush(pq, (-dis[child_node], child_node))\\n        \\n        return 0  # If no path is found from source to destination, return 0\\n\\n```\n```java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n    class Edge {\\n        int node;\\n        double weight;\\n        \\n        public Edge(int node, double weight) {\\n            this.node = node;\\n            this.weight = weight;\\n        }\\n    }\\n    \\n    public double maxProbability(int n, int[][] eg, double[] p, int src, int e) {\\n        List<Edge>[] g = new ArrayList[n];\\n        \\n        // Creating an adjacency list representation of the graph\\n        // based on the given edges and probabilities\\n        for (int i = 0; i < n; i++) {\\n            g[i] = new ArrayList<>();\\n        }\\n        \\n        for (int i = 0; i < eg.length; i++) {\\n            g[eg[i][0]].add(new Edge(eg[i][1], p[i]));\\n            g[eg[i][1]].add(new Edge(eg[i][0], p[i]));\\n        }\\n        \\n        double[] dis = new double[n]; // Initializing distances from source to all nodes as 0\\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> Double.compare(b.weight, a.weight)); // Priority queue to store nodes based on their maximum probability\\n        \\n        pq.offer(new Edge(src, 1)); // Pushing the source node with a probability of 1\\n        dis[src] = 1; // Updating the distance of the source node as 1\\n        \\n        while (!pq.isEmpty()) {\\n            Edge top = pq.poll();\\n            double nodeDis = top.weight; // Current maximum probability\\n            int node = top.node; // Current node\\n            \\n            if (node == e) {\\n                return nodeDis; // If the current node is the destination, return its maximum probability\\n            }\\n            \\n            // Traverse all the neighboring nodes of the current node\\n            for (Edge child : g[node]) {\\n                int childNode = child.node; // Neighboring node\\n                double childWt = child.weight; // Probability of reaching the neighboring node\\n                \\n                // If the current maximum probability multiplied by the probability of reaching the neighboring node\\n                // is greater than the previously calculated maximum probability for the neighboring node,\\n                // update the maximum probability and push the neighboring node into the priority queue\\n                if (childWt * nodeDis > dis[childNode]) {\\n                    dis[childNode] = childWt * nodeDis;\\n                    pq.offer(new Edge(childNode, dis[childNode]));\\n                }\\n            }\\n        }\\n        \\n        return 0; // If no path is found from source to destination, return 0\\n    }\\n}\\n\\n```\n```\\nPlease upvote if it is helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692270,
                "title": "c-graph-max-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& prob, int start, int end) {\\n        //Adjacency list\\n        vector<pair<double, int>> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            double wt=prob[i];\\n            adj[a].push_back({wt, b});\\n            adj[b].push_back({wt, a});\\n        }\\n        //visited nodes\\n        vector<int> vis(n, 0);\\n\\n        //Max heap for finding maximum probability\\n        priority_queue<pair<double, int>>pq;\\n        pq.push({(double)1, start}); //push the starting element with the probability 1\\n        while(pq.size()!=0){\\n            auto i=pq.top();\\n            pq.pop();\\n            int node=i.second;\\n            double p=i.first;\\n            vis[node]=1; //mark visited nodes here\\n            if(node==end)return p; //the moment the priority queue have the end node return the probability (as it is a max heap, it will contain the maximum probability at the top to reach that node)\\n\\n            //run a loop for the edges of the top node \\n            for(auto it : adj[node]){\\n                double curp=it.first;\\n                int curnode=it.second;\\n                if(vis[curnode]!=1){\\n                    //push the nodes in the queue which are not visited yet\\n                    pq.push({p*curp, curnode});\\n                }\\n            }\\n        }\\n\\n        //if the priority queue gets empty and while loop ends that means we cannot reach end if we start from strt node so return 0\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& prob, int start, int end) {\\n        //Adjacency list\\n        vector<pair<double, int>> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            double wt=prob[i];\\n            adj[a].push_back({wt, b});\\n            adj[b].push_back({wt, a});\\n        }\\n        //visited nodes\\n        vector<int> vis(n, 0);\\n\\n        //Max heap for finding maximum probability\\n        priority_queue<pair<double, int>>pq;\\n        pq.push({(double)1, start}); //push the starting element with the probability 1\\n        while(pq.size()!=0){\\n            auto i=pq.top();\\n            pq.pop();\\n            int node=i.second;\\n            double p=i.first;\\n            vis[node]=1; //mark visited nodes here\\n            if(node==end)return p; //the moment the priority queue have the end node return the probability (as it is a max heap, it will contain the maximum probability at the top to reach that node)\\n\\n            //run a loop for the edges of the top node \\n            for(auto it : adj[node]){\\n                double curp=it.first;\\n                int curnode=it.second;\\n                if(vis[curnode]!=1){\\n                    //push the nodes in the queue which are not visited yet\\n                    pq.push({p*curp, curnode});\\n                }\\n            }\\n        }\\n\\n        //if the priority queue gets empty and while loop ends that means we cannot reach end if we start from strt node so return 0\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692172,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn this problem, we are supposed to find the maximum probability of the path between start and end node. As we have to traverse through every connected node of the graph and find the required path, this hints towards BFS and Dijkstra\\'s Algorithm.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe working is as follows:\\n1) We first create the graph representation from the given edges and probabilities.\\n2) We initialize a path array to keep track of the maximum probability from the start node to each node in the graph. Initially, all probabilities are set to 0 except for the start node, which is set to 1.\\n3) We use a queue to perform a BFS traversal of the graph. Starting with the start node, we explore its neighbors and update the maximum probability if a higher probability is found.\\n4) The BFS continues until the queue is empty, ensuring that we explore all reachable nodes from the start node and update their maximum probabilities.\\n5) Finally, we return the maximum probability stored in the path array for the end node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity of the solution is O(V + E), where V is the number of nodes and E is the number of edges in the graph.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(V), where V is the number of nodes, as we store the path array to keep track of the maximum probabilities for each node.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int,double>>> graph(n);\\n        for(int i=0;i<edges.size();i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            graph[x].push_back({y,succProb[i]});\\n            graph[y].push_back({x,succProb[i]});\\n        }\\n        vector<double> path(n,0.0);\\n        path[start]=1.0;\\n        queue<int> q;\\n        q.push(start);\\n\\n        while(!q.empty()){\\n            int curr=q.front();\\n            q.pop();\\n            for(auto it:graph[curr]){\\n                double currNode=it.first;\\n                double currProb=it.second;\\n                double newProb=path[curr]*currProb;\\n                if(newProb>path[currNode]){\\n                    path[currNode]=newProb;\\n                    q.push(currNode);\\n                }\\n            }\\n        }\\n        return path[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int,double>>> graph(n);\\n        for(int i=0;i<edges.size();i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            graph[x].push_back({y,succProb[i]});\\n            graph[y].push_back({x,succProb[i]});\\n        }\\n        vector<double> path(n,0.0);\\n        path[start]=1.0;\\n        queue<int> q;\\n        q.push(start);\\n\\n        while(!q.empty()){\\n            int curr=q.front();\\n            q.pop();\\n            for(auto it:graph[curr]){\\n                double currNode=it.first;\\n                double currProb=it.second;\\n                double newProb=path[curr]*currProb;\\n                if(newProb>path[currNode]){\\n                    path[currNode]=newProb;\\n                    q.push(currNode);\\n                }\\n            }\\n        }\\n        return path[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691932,
                "title": "maximum-probability-path-in-a-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code implements a solution to find the maximum probability of reaching the \"end\" node from the \"start\" node in a graph. The graph is represented using an adjacency list, where each vertex is associated with a list of pairs representing its neighboring vertices and the corresponding success probabilities of transitioning from the current vertex to its neighbors.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nHere\\'s a step-by-step explanation of the approach:\\n\\n1. Create an adjacency list \"adj\" to represent the graph. Initialize it with empty lists for each vertex (0 to n-1).\\n\\n2. Iterate through the \"edges\" array, which contains pairs of vertices representing the edges in the graph. For each edge (u, v) at index i, retrieve the corresponding success probability \"p\" from the \"succProb\" array.\\n\\n3. Add an entry to the adjacency list for vertex u, containing the pair (v, p) to indicate that there is an edge from u to v with success probability p. Also, add an entry to the adjacency list for vertex v, containing the pair (u, p) to represent the reverse edge.\\n\\n4. Create a \"dist\" array of size n to store the maximum probabilities of reaching each vertex from the start vertex. Initialize all values to 0.0 except for the start vertex, which is set to 1.0 since the probability of reaching itself is 1.\\n\\n5. Create a queue \"queue\" (implemented as a LinkedList) and enqueue the start vertex.\\n\\n6. Perform a BFS (Breadth-First Search) starting from the start vertex. While the queue is not empty, dequeue a vertex \"curr\" from the queue.\\n\\n7. Iterate through the neighboring vertices of \"curr\" using the adjacency list. For each neighbor vertex \"node\" and its associated success probability \"prob\":\\n\\n   - Calculate the new probability \"newProb\" by multiplying the probability of reaching \"curr\" (dist[curr]) with the success probability \"prob\".\\n\\n   - If \"newProb\" is greater than the current probability stored in the \"dist\" array for \"node\", update \"dist[node]\" with the new probability and enqueue \"node\" to explore its neighbors later.\\n\\n8. After the BFS completes, the \"dist\" array will contain the maximum probabilities of reaching each vertex from the start vertex. Return the value stored in \"dist[end]\", which represents the maximum probability of reaching the \"end\" vertex from the \"start\" vertex.\\n\\n9. The code also defines a Pair class to represent a key-value pair. It has a constructor, getter methods for the key and value, and is used to store the neighboring vertices and their associated success probabilities in the adjacency list.\\n\\nOverall, the code performs a modified BFS to calculate the maximum probabilities of reaching each vertex from the start vertex and returns the maximum probability of reaching the end vertex.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        // Adjacency list\\n        List<List<Pair<Integer, Double>>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double p = succProb[i];\\n            adj.get(u).add(new Pair<>(v, p));\\n            adj.get(v).add(new Pair<>(u, p));\\n        }\\n\\n        // Distances array\\n        double[] dist = new double[n];\\n        Arrays.fill(dist, 0.0);\\n        dist[start] = 1.0;\\n\\n        // Queue for BFS\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(start);\\n\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n\\n            for (Pair<Integer, Double> pair : adj.get(curr)) {\\n                int node = pair.getKey();\\n                double prob = pair.getValue();\\n                double newProb = dist[curr] * prob;\\n\\n                if (newProb > dist[node]) {\\n                    dist[node] = newProb;\\n                    queue.offer(node);\\n                }\\n            }\\n        }\\n\\n        return dist[end];\\n    }\\n\\n    private class Pair<K, V> {\\n        private K key;\\n        private V value;\\n\\n        public Pair(K key, V value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n\\n        public K getKey() {\\n            return key;\\n        }\\n\\n        public V getValue() {\\n            return value;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        // Adjacency list\\n        List<List<Pair<Integer, Double>>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double p = succProb[i];\\n            adj.get(u).add(new Pair<>(v, p));\\n            adj.get(v).add(new Pair<>(u, p));\\n        }\\n\\n        // Distances array\\n        double[] dist = new double[n];\\n        Arrays.fill(dist, 0.0);\\n        dist[start] = 1.0;\\n\\n        // Queue for BFS\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(start);\\n\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n\\n            for (Pair<Integer, Double> pair : adj.get(curr)) {\\n                int node = pair.getKey();\\n                double prob = pair.getValue();\\n                double newProb = dist[curr] * prob;\\n\\n                if (newProb > dist[node]) {\\n                    dist[node] = newProb;\\n                    queue.offer(node);\\n                }\\n            }\\n        }\\n\\n        return dist[end];\\n    }\\n\\n    private class Pair<K, V> {\\n        private K key;\\n        private V value;\\n\\n        public Pair(K key, V value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n\\n        public K getKey() {\\n            return key;\\n        }\\n\\n        public V getValue() {\\n            return value;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691591,
                "title": "optimized-solution-daily-leetcode-challenge",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<int,double>> adj[n];\\n        int m = edges.size();\\n        for(int i = 0; i < m; i++){\\n            int u = edges[i][0], v = edges[i][1];\\n            double p = succProb[i];\\n            adj[u].push_back({v, p});\\n            adj[v].push_back({u, p});\\n        }\\n        \\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0, start}); // probability of reaching start node is 1\\n        \\n        vector<double> prob(n,0); // maintains the max probability of reaching any node\\n        prob[start] = 1; // probability of reaching start node\\n        \\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            int node = top.second;\\n            double currProb = top.first;\\n            pq.pop();\\n            \\n            if(node == end) return currProb; /* as the priority queue is a max heap it will always give\\n\\t\\t\\ta maximum probability of reaching curr node the first time we encounter it */\\n            \\n            for(auto &i:adj[node]){\\n                int adjNode = i.first;\\n                double p = i.second;\\n                if(prob[adjNode] < p*currProb){\\n                    prob[adjNode] = p*currProb;\\n                    pq.push({p*currProb, adjNode});\\n                }\\n            }\\n        }\\n        \\n        return 0; // if end node is unreachable then probability of reaching it is zero\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<int,double>> adj[n];\\n        int m = edges.size();\\n        for(int i = 0; i < m; i++){\\n            int u = edges[i][0], v = edges[i][1];\\n            double p = succProb[i];\\n            adj[u].push_back({v, p});\\n            adj[v].push_back({u, p});\\n        }\\n        \\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0, start}); // probability of reaching start node is 1\\n        \\n        vector<double> prob(n,0); // maintains the max probability of reaching any node\\n        prob[start] = 1; // probability of reaching start node\\n        \\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            int node = top.second;\\n            double currProb = top.first;\\n            pq.pop();\\n            \\n            if(node == end) return currProb; /* as the priority queue is a max heap it will always give\\n\\t\\t\\ta maximum probability of reaching curr node the first time we encounter it */\\n            \\n            for(auto &i:adj[node]){\\n                int adjNode = i.first;\\n                double p = i.second;\\n                if(prob[adjNode] < p*currProb){\\n                    prob[adjNode] = p*currProb;\\n                    pq.push({p*currProb, adjNode});\\n                }\\n            }\\n        }\\n        \\n        return 0; // if end node is unreachable then probability of reaching it is zero\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691325,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProbability(self, n, edges, succProb, start, end):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type succProb: List[float]\\n        :type start: int\\n        :type end: int\\n        :rtype: float\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        for i in range(len(edges)):\\n            s, e = edges[i]\\n            graph[s].append((-succProb[i], e))\\n            graph[e].append((-succProb[i], s))\\n        max_heap = [(-1, start)]\\n        visited = set()\\n        while max_heap:\\n            p, node = heapq.heappop(max_heap)\\n            if node == end:\\n                return -p\\n            visited.add(node)\\n            for q, adj in graph[node]:\\n                if adj not in visited:\\n                    heapq.heappush(max_heap, (-(p*q), adj))\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProbability(self, n, edges, succProb, start, end):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type succProb: List[float]\\n        :type start: int\\n        :type end: int\\n        :rtype: float\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        for i in range(len(edges)):\\n            s, e = edges[i]\\n            graph[s].append((-succProb[i], e))\\n            graph[e].append((-succProb[i], s))\\n        max_heap = [(-1, start)]\\n        visited = set()\\n        while max_heap:\\n            p, node = heapq.heappop(max_heap)\\n            if node == end:\\n                return -p\\n            visited.add(node)\\n            for q, adj in graph[node]:\\n                if adj not in visited:\\n                    heapq.heappush(max_heap, (-(p*q), adj))\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691147,
                "title": "c-similar-to-dijkstra-striver-graph-solution-commented-easy-to-understandd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n      //we have created an adjancey list to store the graph it is of int,double as proba is in double  \\n        vector<vector<pair<int, double>>> adj(n);\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n\\n      // we need dist array to store probability till that node with max\\n        vector<double> dist(n, 0.0);\\n// probabilty of source is 1\\n        dist[start] = 1.0;\\n        //for traversal we will use queue\\n        queue<int> q;\\n        q.push(start);\\n        \\n        while (!q.empty()) {\\n\\n            int curr = q.front();\\n            q.pop();\\n            // from q top node to all its adjacent nodes\\n            for (auto it : adj[curr]) {\\n\\n                int nextNode = it.first;\\n                double prob = it.second;\\n               //checking new prob with all option\\n                double newProb = dist[curr] * prob;\\n                // storin the max one\\n                if (newProb > dist[nextNode]) {\\n                    dist[nextNode] = newProb;\\n                    q.push(nextNode);\\n                }\\n            }\\n        }\\n        //return prob to reach end\\n        return dist[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n      //we have created an adjancey list to store the graph it is of int,double as proba is in double  \\n        vector<vector<pair<int, double>>> adj(n);\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n\\n      // we need dist array to store probability till that node with max\\n        vector<double> dist(n, 0.0);\\n// probabilty of source is 1\\n        dist[start] = 1.0;\\n        //for traversal we will use queue\\n        queue<int> q;\\n        q.push(start);\\n        \\n        while (!q.empty()) {\\n\\n            int curr = q.front();\\n            q.pop();\\n            // from q top node to all its adjacent nodes\\n            for (auto it : adj[curr]) {\\n\\n                int nextNode = it.first;\\n                double prob = it.second;\\n               //checking new prob with all option\\n                double newProb = dist[curr] * prob;\\n                // storin the max one\\n                if (newProb > dist[nextNode]) {\\n                    dist[nextNode] = newProb;\\n                    q.push(nextNode);\\n                }\\n            }\\n        }\\n        //return prob to reach end\\n        return dist[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691042,
                "title": "c-using-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Dijkstra\\'s algorithm to find the maximum probability path from a given start node to an end node in a graph. The graph is represented using an adjacency list, where each node is associated with a list of adjacent nodes and their corresponding success probabilities.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    using v = pair<double, int>;  // Define a pair type for probability and node index\\n    vector<vector<v>> adj;  // Adjacency list to store the graph\\n\\n    void create_adj(int n, vector<vector<int>>& edges, vector<double>& succProb) {\\n        adj.resize(n);  // Resize the adjacency list to the number of nodes\\n        int eN = edges.size();\\n        for (int i = 0; i < eN; i++) {\\n            int v0 = edges[i][0], v1 = edges[i][1];  // Get the source and target nodes of the edge\\n            adj[v0].push_back({succProb[i], v1});  // Add the target node and its success probability to the adjacency list of the source node\\n            adj[v1].push_back({succProb[i], v0});  // Add the source node and its success probability to the adjacency list of the target node\\n        }\\n    }\\n\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> prob(n, 0);  // Initialize the probability vector for each node as 0\\n        create_adj(n, edges, succProb);  // Create the adjacency list for the graph\\n        priority_queue<v, vector<v>> pq;  // Priority queue to store nodes based on their probabilities in descending order\\n\\n        pq.push({1.0, start});  // Push the start node with probability 1 to the priority queue\\n        prob[start] = 1.0;  // Set the probability of the start node as 1\\n\\n        while (!pq.empty()) {\\n            auto [cur_prob, i] = pq.top();  // Get the node with the highest probability from the priority queue\\n            pq.pop();\\n\\n            if (i == end) {  // If the current node is the end node, return its probability\\n                return cur_prob;\\n            }\\n\\n            for (auto [next_prob, j] : adj[i]) {  // Iterate through the adjacent nodes of the current node\\n                double new_prob = cur_prob * next_prob;  // Calculate the new probability by multiplying the current probability with the success probability of the edge\\n                if (new_prob > prob[j]) {  // If the new probability is higher than the existing probability of the adjacent node\\n                    prob[j] = new_prob;  // Update the probability of the adjacent node\\n                    pq.push({new_prob, j});  // Push the adjacent node with its new probability to the priority queue for further exploration\\n                }\\n            }\\n        }\\n        return 0.0;  // If the end node is not reachable, return 0 as the maximum probability\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using v = pair<double, int>;  // Define a pair type for probability and node index\\n    vector<vector<v>> adj;  // Adjacency list to store the graph\\n\\n    void create_adj(int n, vector<vector<int>>& edges, vector<double>& succProb) {\\n        adj.resize(n);  // Resize the adjacency list to the number of nodes\\n        int eN = edges.size();\\n        for (int i = 0; i < eN; i++) {\\n            int v0 = edges[i][0], v1 = edges[i][1];  // Get the source and target nodes of the edge\\n            adj[v0].push_back({succProb[i], v1});  // Add the target node and its success probability to the adjacency list of the source node\\n            adj[v1].push_back({succProb[i], v0});  // Add the source node and its success probability to the adjacency list of the target node\\n        }\\n    }\\n\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> prob(n, 0);  // Initialize the probability vector for each node as 0\\n        create_adj(n, edges, succProb);  // Create the adjacency list for the graph\\n        priority_queue<v, vector<v>> pq;  // Priority queue to store nodes based on their probabilities in descending order\\n\\n        pq.push({1.0, start});  // Push the start node with probability 1 to the priority queue\\n        prob[start] = 1.0;  // Set the probability of the start node as 1\\n\\n        while (!pq.empty()) {\\n            auto [cur_prob, i] = pq.top();  // Get the node with the highest probability from the priority queue\\n            pq.pop();\\n\\n            if (i == end) {  // If the current node is the end node, return its probability\\n                return cur_prob;\\n            }\\n\\n            for (auto [next_prob, j] : adj[i]) {  // Iterate through the adjacent nodes of the current node\\n                double new_prob = cur_prob * next_prob;  // Calculate the new probability by multiplying the current probability with the success probability of the edge\\n                if (new_prob > prob[j]) {  // If the new probability is higher than the existing probability of the adjacent node\\n                    prob[j] = new_prob;  // Update the probability of the adjacent node\\n                    pq.push({new_prob, j});  // Push the adjacent node with its new probability to the priority queue for further exploration\\n                }\\n            }\\n        }\\n        return 0.0;  // If the end node is not reachable, return 0 as the maximum probability\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690915,
                "title": "c-easy-dijkstra",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> pro(n + 1, 0);\\n        \\n        vector<pair<int,double>> adj[n + 1];\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>> pq;\\n        pro[start] = 1;\\n        pq.push({1, start});\\n        while (!pq.empty()) {\\n            int node = pq.top().second;\\n            double p = pq.top().first;\\n            pq.pop();\\n            for (auto it : adj[node]) {\\n                if (pro[it.first] < (it.second * pro[node])) {\\n                    pro[it.first] = (it.second * pro[node]);\\n                    pq.push({pro[it.first], it.first});\\n                }\\n            }\\n        }\\n        return pro[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> pro(n + 1, 0);\\n        \\n        vector<pair<int,double>> adj[n + 1];\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>> pq;\\n        pro[start] = 1;\\n        pq.push({1, start});\\n        while (!pq.empty()) {\\n            int node = pq.top().second;\\n            double p = pq.top().first;\\n            pq.pop();\\n            for (auto it : adj[node]) {\\n                if (pro[it.first] < (it.second * pro[node])) {\\n                    pro[it.first] = (it.second * pro[node]);\\n                    pq.push({pro[it.first], it.first});\\n                }\\n            }\\n        }\\n        return pro[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690835,
                "title": "c-solution",
                "content": "# Intuition\\nThis problem can be solved using Dijkstra\\u2019s algorithm. The idea is to treat the probabilities as weights on the edges and find the path with the maximum product of weights.\\n\\n# Approach\\nSince Dijkstra\\u2019s algorithm works with sums, we can take the logarithm of the probabilities and negate them to convert products into sums. \\nThen, we can run Dijkstra\\u2019s algorithm to find the shortest path from start to end in the transformed graph.\\n The final result is obtained by taking the exponential of the negated distance and returning it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n    vector<vector<pair<int, double>>> graph(n);\\n    for (int i = 0; i < edges.size(); i++) {\\n        int a = edges[i][0];\\n        int b = edges[i][1];\\n        double w = -log(succProb[i]);\\n        graph[a].push_back({b, w});\\n        graph[b].push_back({a, w});\\n    }\\n\\n    vector<double> dist(n, numeric_limits<double>::max());\\n    dist[start] = 0;\\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> heap;\\n    heap.push({0, start});\\n    while (!heap.empty()) {\\n        auto [d, u] = heap.top();\\n        heap.pop();\\n        if (d > dist[u]) {\\n            continue;\\n        }\\n        for (auto [v, w] : graph[u]) {\\n            if (dist[v] > dist[u] + w) {\\n                dist[v] = dist[u] + w;\\n                heap.push({dist[v], v});\\n            }\\n        }\\n    }\\n\\n    return dist[end] == numeric_limits<double>::max() ? 0 : exp(-dist[end]);\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n    vector<vector<pair<int, double>>> graph(n);\\n    for (int i = 0; i < edges.size(); i++) {\\n        int a = edges[i][0];\\n        int b = edges[i][1];\\n        double w = -log(succProb[i]);\\n        graph[a].push_back({b, w});\\n        graph[b].push_back({a, w});\\n    }\\n\\n    vector<double> dist(n, numeric_limits<double>::max());\\n    dist[start] = 0;\\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> heap;\\n    heap.push({0, start});\\n    while (!heap.empty()) {\\n        auto [d, u] = heap.top();\\n        heap.pop();\\n        if (d > dist[u]) {\\n            continue;\\n        }\\n        for (auto [v, w] : graph[u]) {\\n            if (dist[v] > dist[u] + w) {\\n                dist[v] = dist[u] + w;\\n                heap.push({dist[v], v});\\n            }\\n        }\\n    }\\n\\n    return dist[end] == numeric_limits<double>::max() ? 0 : exp(-dist[end]);\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754529,
                "title": "c-djikstras-modified-version-max-heap-with-explanation",
                "content": "```\\ntypedef pair<int,double> pi;\\ntypedef pair<double,int> pi1;\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pi>> adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pi1,vector<pi1>> pq;\\n        pq.push({1.00,start});//initially taking probabaility as 1 therfore pushing 1.00 and start\\n        vector<double> dist(n,0.00); // storing maximum probability\\n        dist[start]=1.00;//initially taking probabaility as 1\\n        while(!pq.empty())\\n        {\\n            double wt=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(dist[it.first]<dist[node]*it.second) // if probability greater than present then pushing in the priority queue.\\n                {\\n                    dist[it.first]=dist[node]*it.second;\\n                    pq.push({dist[it.first],it.first});\\n                }\\n            }\\n        }\\n        return dist[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,double> pi;\\ntypedef pair<double,int> pi1;\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pi>> adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pi1,vector<pi1>> pq;\\n        pq.push({1.00,start});//initially taking probabaility as 1 therfore pushing 1.00 and start\\n        vector<double> dist(n,0.00); // storing maximum probability\\n        dist[start]=1.00;//initially taking probabaility as 1\\n        while(!pq.empty())\\n        {\\n            double wt=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[node])\\n            {\\n                if(dist[it.first]<dist[node]*it.second) // if probability greater than present then pushing in the priority queue.\\n                {\\n                    dist[it.first]=dist[node]*it.second;\\n                    pq.push({dist[it.first],it.first});\\n                }\\n            }\\n        }\\n        return dist[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658592,
                "title": "easy-dijastra-code",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back({v,succProb[i]});\\n            adj[v].push_back({u,succProb[i]});\\n        }\\n        priority_queue<pair<double,int>> pq;\\n        vector<double> dist(n,0.0);\\n        pq.push({1.0,start});\\n        dist[start]=1.0;\\n        while(!pq.empty()){\\n            double cost=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                if(dist[it.first]<it.second*cost){\\n                    dist[it.first]=it.second*cost;\\n                    pq.push({dist[it.first],it.first});\\n                }\\n            }\\n        }\\n        return dist[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back({v,succProb[i]});\\n            adj[v].push_back({u,succProb[i]});\\n        }\\n        priority_queue<pair<double,int>> pq;\\n        vector<double> dist(n,0.0);\\n        pq.push({1.0,start});\\n        dist[start]=1.0;\\n        while(!pq.empty()){\\n            double cost=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                if(dist[it.first]<it.second*cost){\\n                    dist[it.first]=it.second*cost;\\n                    pq.push({dist[it.first],it.first});\\n                }\\n            }\\n        }\\n        return dist[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236476,
                "title": "c-dijkstra-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pii;\\n    vector<vector<pair<int,double>>> buildGraph(int n,vector<vector<int>>& roads,vector<double>&prob){\\n        vector<vector<pair<int,double>>> graph(n);\\n        for(int i=0;i<roads.size();++i){\\n            graph[roads[i][0]].push_back({roads[i][1],prob[i]});\\n            graph[roads[i][1]].push_back({roads[i][0],prob[i]});\\n        }    \\n        return graph;\\n    }\\n    \\n    double maxProbability(int n,vector<vector<int>>& edges,vector<double>& prob,int s,int e) {\\n        vector<vector<pair<int,double>>> g = buildGraph(n,edges,prob);\\n        vector<double> probTo(n,0);\\n        priority_queue<pii> q;\\n        q.push({1,s});\\n        probTo[s] = 1;\\n        while(q.size()>0){\\n            int curr = q.top().second;\\n            q.pop();\\n            for(auto it : g[curr]){\\n                int next = it.first;\\n                double nextProb = it.second;\\n                if(probTo[next] < probTo[curr]*nextProb){\\n                    probTo[next] = probTo[curr]*nextProb;\\n                    q.push({probTo[next],next});\\n                }\\n            }\\n        }\\n        return probTo[e];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pii;\\n    vector<vector<pair<int,double>>> buildGraph(int n,vector<vector<int>>& roads,vector<double>&prob){\\n        vector<vector<pair<int,double>>> graph(n);\\n        for(int i=0;i<roads.size();++i){\\n            graph[roads[i][0]].push_back({roads[i][1],prob[i]});\\n            graph[roads[i][1]].push_back({roads[i][0],prob[i]});\\n        }    \\n        return graph;\\n    }\\n    \\n    double maxProbability(int n,vector<vector<int>>& edges,vector<double>& prob,int s,int e) {\\n        vector<vector<pair<int,double>>> g = buildGraph(n,edges,prob);\\n        vector<double> probTo(n,0);\\n        priority_queue<pii> q;\\n        q.push({1,s});\\n        probTo[s] = 1;\\n        while(q.size()>0){\\n            int curr = q.top().second;\\n            q.pop();\\n            for(auto it : g[curr]){\\n                int next = it.first;\\n                double nextProb = it.second;\\n                if(probTo[next] < probTo[curr]*nextProb){\\n                    probTo[next] = probTo[curr]*nextProb;\\n                    q.push({probTo[next],next});\\n                }\\n            }\\n        }\\n        return probTo[e];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125617,
                "title": "c-clear-dijkstra-algo-easy-to-understand-explained",
                "content": "**Explaination :**\\nFor Shortest Path we are using Dijkstra algorithm and in which we choose minimum distance node and if minimum distance possible then we change it to minimum.\\n\\n```\\nif(distance[u] + weight < distance[v])\\n\\tdistance[v] = distance[u] + weight ;\\n```\\n\\n\\nIn this problem we have to find maximum probability so we have to apply dijkstra algorithms but we have to choose maximum probability node and if maximum probabilty possible then change it to maximum. Rest of things remain same.\\n\\n```\\nif(prob[u] * weight > prob[v])\\n\\tprob[v] = prob[u] * weight ;\\n```\\n\\n\\n**Code :**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<vector<pair<int,double>>> adj(n);\\n\\n        int m = edges.size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int u = edges[i][0], v = edges[i][1];\\n            double w = succProb[i];\\n            \\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        \\n        // Dijkstra Start ----  \\n        \\n        vector<double> prob(n,0.0);\\n        vector<int> visited(n,0);\\n        \\n        set<pair<double,int>> st;\\n        st.insert({0,start});\\n        prob[start] = 1.0;\\n         // initially probability is 1\\n        \\n        while(st.size() > 0)\\n        {\\n            auto node = *st.begin();\\n            st.erase(st.begin());\\n            \\n            int u = node.second;\\n            \\n            if(visited[u])\\n                continue;\\n            \\n            visited[u] = 1;\\n            \\n            for(auto &child : adj[u])\\n            {\\n                int v = child.first;\\n                double weight = child.second;\\n                \\n                // if probability increase then make change\\n                \\n                if(prob[u] * weight > prob[v])\\n                {\\n                    prob[v] = prob[u] * weight ;\\n\\t\\t\\t\\t\\t// choose node which has maximum probability but set gives minimum so we will use ( 1 - probability ) so that maximum probability node appears first\\n                    st.insert({1.0 - prob[v],v});   \\n                }\\n            }\\n        }\\n        \\n        return prob[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nif(distance[u] + weight < distance[v])\\n\\tdistance[v] = distance[u] + weight ;\\n```\n```\\nif(prob[u] * weight > prob[v])\\n\\tprob[v] = prob[u] * weight ;\\n```\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<vector<pair<int,double>>> adj(n);\\n\\n        int m = edges.size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int u = edges[i][0], v = edges[i][1];\\n            double w = succProb[i];\\n            \\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        \\n        // Dijkstra Start ----  \\n        \\n        vector<double> prob(n,0.0);\\n        vector<int> visited(n,0);\\n        \\n        set<pair<double,int>> st;\\n        st.insert({0,start});\\n        prob[start] = 1.0;\\n         // initially probability is 1\\n        \\n        while(st.size() > 0)\\n        {\\n            auto node = *st.begin();\\n            st.erase(st.begin());\\n            \\n            int u = node.second;\\n            \\n            if(visited[u])\\n                continue;\\n            \\n            visited[u] = 1;\\n            \\n            for(auto &child : adj[u])\\n            {\\n                int v = child.first;\\n                double weight = child.second;\\n                \\n                // if probability increase then make change\\n                \\n                if(prob[u] * weight > prob[v])\\n                {\\n                    prob[v] = prob[u] * weight ;\\n\\t\\t\\t\\t\\t// choose node which has maximum probability but set gives minimum so we will use ( 1 - probability ) so that maximum probability node appears first\\n                    st.insert({1.0 - prob[v],v});   \\n                }\\n            }\\n        }\\n        \\n        return prob[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936253,
                "title": "c-priority-queue-max-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end)\\n    {\\n        vector<vector<pair<int,double>>> g(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            g[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            g[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({(double)1.0,start});//prob,edgs\\n        \\n        vector<int> vis(n,0);\\n        vector<double> mx(n,(double)0.0);\\n        mx[start]=1.0;\\n        while(!pq.empty())\\n        {\\n            pair<double,int> p=pq.top();\\n            pq.pop();\\n            double prob=p.first;\\n            int node=p.second;\\n            if(!vis[node])\\n            {\\n                vis[node]=1;\\n                for(auto &to:g[node])\\n                {\\n                    if(mx[to.first]<to.second*prob)\\n                    {\\n                        mx[to.first]=to.second*prob;\\n                        pq.push({mx[to.first],to.first});\\n                    }\\n                }\\n            }\\n        }\\n        return mx[end];\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end)\\n    {\\n        vector<vector<pair<int,double>>> g(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            g[edges[i][0]].push_back({edges[i][1],succProb[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1859845,
                "title": "java-clean-djikstra-solution",
                "content": "![image](https://assets.leetcode.com/users/images/abe1f195-1da6-4e0d-acae-7e3f5659864a_1647583730.2075415.png)\\n\\n```java\\nclass Solution {\\n  public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n    List<double[]>[] graph = new List[n];\\n    for (int i = 0; i < n; i++) {\\n      graph[i] = new ArrayList<>();\\n    }\\n    for (int i = 0; i < edges.length; i++) {\\n      int[] edge = edges[i];\\n      int u = edge[0], v = edge[1];\\n      double w = succProb[i];\\n      \\n      graph[u].add(new double[]{v, w});\\n      graph[v].add(new double[]{u, w});\\n    }\\n\\n    Queue<double[]> queue = new PriorityQueue<>((a, b) -> Double.compare(a[1], b[1]));\\n    double[] dist = new double[n];\\n    Arrays.fill(dist, Double.MAX_VALUE);\\n    \\n    dist[start] = 1.0;\\n    queue.add(new double[]{start, dist[start]});\\n\\n    double esp = 1e-5;\\n    while (!queue.isEmpty()) {\\n      double[] curr = queue.poll();\\n      int u = (int) curr[0];\\n      double d = curr[1];\\n\\n      if (Math.abs(d - dist[u]) > esp) continue;\\n\\n      for (double[] next : graph[u]) {\\n        int v = (int) next[0];\\n        double w = next[1];\\n\\n        if (dist[u] / w < dist[v]) {\\n          dist[v] = dist[u] / w;\\n          queue.add(new double[]{v, dist[v]});\\n        }\\n      }\\n    }\\n\\n    return 1.0 / dist[end];\\n  }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n    List<double[]>[] graph = new List[n];\\n    for (int i = 0; i < n; i++) {\\n      graph[i] = new ArrayList<>();\\n    }\\n    for (int i = 0; i < edges.length; i++) {\\n      int[] edge = edges[i];\\n      int u = edge[0], v = edge[1];\\n      double w = succProb[i];\\n      \\n      graph[u].add(new double[]{v, w});\\n      graph[v].add(new double[]{u, w});\\n    }\\n\\n    Queue<double[]> queue = new PriorityQueue<>((a, b) -> Double.compare(a[1], b[1]));\\n    double[] dist = new double[n];\\n    Arrays.fill(dist, Double.MAX_VALUE);\\n    \\n    dist[start] = 1.0;\\n    queue.add(new double[]{start, dist[start]});\\n\\n    double esp = 1e-5;\\n    while (!queue.isEmpty()) {\\n      double[] curr = queue.poll();\\n      int u = (int) curr[0];\\n      double d = curr[1];\\n\\n      if (Math.abs(d - dist[u]) > esp) continue;\\n\\n      for (double[] next : graph[u]) {\\n        int v = (int) next[0];\\n        double w = next[1];\\n\\n        if (dist[u] / w < dist[v]) {\\n          dist[v] = dist[u] / w;\\n          queue.add(new double[]{v, dist[v]});\\n        }\\n      }\\n    }\\n\\n    return 1.0 / dist[end];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325259,
                "title": "c-easy-solution-clean-concise-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& e, vector<double>& succ, int start, int end) {\\n        \\n        //similar algorithm to dijkstra \\n        //use max heap instead of min heap\\n        \\n        //create adjacency list\\n        vector<vector<pair<int,double>>> adj(n);\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            adj[e[i][0]].push_back({e[i][1],succ[i]});\\n            adj[e[i][1]].push_back({e[i][0],succ[i]});\\n        }\\n        \\n        vector<double> res(n,0.0);\\n        res[start]=1.0;\\n        \\n        priority_queue<pair<double,int>> pq;\\n        \\n        pq.push({1.0,start});\\n        \\n        while(!pq.empty())\\n        {\\n            //get the element which has maximum probablity\\n            \\n            //update the adjacent nodes probability\\n            auto [prob,node]= pq.top();\\n            pq.pop();\\n            for(auto [i,p]:adj[node])\\n            {\\n                //if the prob through the current node is greater then update and push it to queue\\n                if(res[i]< prob*p)\\n                {\\n                    res[i]=prob*p;\\n                    pq.push({res[i],i});\\n                }\\n            }\\n        }\\n        return res[end];        \\n    }\\n};\\n```\\n**Upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& e, vector<double>& succ, int start, int end) {\\n        \\n        //similar algorithm to dijkstra \\n        //use max heap instead of min heap\\n        \\n        //create adjacency list\\n        vector<vector<pair<int,double>>> adj(n);\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            adj[e[i][0]].push_back({e[i][1],succ[i]});\\n            adj[e[i][1]].push_back({e[i][0],succ[i]});\\n        }\\n        \\n        vector<double> res(n,0.0);\\n        res[start]=1.0;\\n        \\n        priority_queue<pair<double,int>> pq;\\n        \\n        pq.push({1.0,start});\\n        \\n        while(!pq.empty())\\n        {\\n            //get the element which has maximum probablity\\n            \\n            //update the adjacent nodes probability\\n            auto [prob,node]= pq.top();\\n            pq.pop();\\n            for(auto [i,p]:adj[node])\\n            {\\n                //if the prob through the current node is greater then update and push it to queue\\n                if(res[i]< prob*p)\\n                {\\n                    res[i]=prob*p;\\n                    pq.push({res[i],i});\\n                }\\n            }\\n        }\\n        return res[end];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873747,
                "title": "c-easy-to-understand-djikstra",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int,double>>> map(n);\\n        for(int i=0;i<edges.size();i++){\\n            map[edges[i][0]].push_back(pair(edges[i][1], succProb[i]));\\n            map[edges[i][1]].push_back(pair(edges[i][0], succProb[i]));\\n        }\\n        vector<bool> vis(n,false);\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0,start});\\n        while(!pq.empty())\\n        {\\n            auto [prob,i]=pq.top();\\n            pq.pop();\\n            vis[i]=true;\\n            if(i==end)return prob;\\n            for(auto [j,probj]:map[i])\\n            {\\n                if(!vis[j])\\n                    pq.push({prob*probj,j});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int,double>>> map(n);\\n        for(int i=0;i<edges.size();i++){\\n            map[edges[i][0]].push_back(pair(edges[i][1], succProb[i]));\\n            map[edges[i][1]].push_back(pair(edges[i][0], succProb[i]));\\n        }\\n        vector<bool> vis(n,false);\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0,start});\\n        while(!pq.empty())\\n        {\\n            auto [prob,i]=pq.top();\\n            pq.pop();\\n            vis[i]=true;\\n            if(i==end)return prob;\\n            for(auto [j,probj]:map[i])\\n            {\\n                if(!vis[j])\\n                    pq.push({prob*probj,j});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822423,
                "title": "python3-dijkstra-path-with-maximum-probability",
                "content": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], prob: List[float], start: int, end: int) -> float:\\n        weights = list(map(lambda x:-math.log2(x), prob))\\n        g = defaultdict(list)\\n        for (u, v), w in zip(edges, weights):\\n            g[u].append([v, w])\\n            g[v].append([u, w])\\n        dist = {}\\n        q = [(0, start)]\\n        while q:\\n            w, u = heapq.heappop(q)\\n            if u in dist:\\n                continue\\n            dist[u] = w\\n            if u == end:\\n                break\\n            for v, w in g[u]:\\n                if v not in dist or dist[v] > dist[u] + w:\\n                    heapq.heappush(q, (dist[u] + w, v))\\n        return 2 ** (-dist[end]) if end in dist else 0.0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], prob: List[float], start: int, end: int) -> float:\\n        weights = list(map(lambda x:-math.log2(x), prob))\\n        g = defaultdict(list)\\n        for (u, v), w in zip(edges, weights):\\n            g[u].append([v, w])\\n            g[v].append([u, w])\\n        dist = {}\\n        q = [(0, start)]\\n        while q:\\n            w, u = heapq.heappop(q)\\n            if u in dist:\\n                continue\\n            dist[u] = w\\n            if u == end:\\n                break\\n            for v, w in g[u]:\\n                if v not in dist or dist[v] > dist[u] + w:\\n                    heapq.heappush(q, (dist[u] + w, v))\\n        return 2 ** (-dist[end]) if end in dist else 0.0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742139,
                "title": "c-o-eloge-using-dijkstra-with-log-and-exp",
                "content": "We need to use `-log(p)`  since `log(p)` when `p < 1` is always negative.\\nWe use `log` to avoid precision problems and finally inverse it using `1 / exp(cummulative_probablity)`.\\n\\n```\\nclass Solution {\\npublic:\\n    using Node = pair<int,double>;\\n    using Graph = vector<vector<Node>>;\\n    using NodeDistPair = pair<double,int>;\\n\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        Graph graph(n);\\n        for (int i = 0; i < edges.size(); i++) {\\n            auto edge = edges[i];\\n            double w = -log(succProb[i]);\\n            graph[edge[0]].push_back({ edge[1], w });\\n            graph[edge[1]].push_back({ edge[0], w });\\n        }\\n\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0;\\n\\n        priority_queue<NodeDistPair, vector<NodeDistPair>, greater<NodeDistPair>> pq;\\n        pq.push({ 0, start });\\n\\n        while (!pq.empty()) {\\n            int nodeId = pq.top().second;\\n            pq.pop();\\n\\n            for (auto [adjNodeId, adjNodeProb]: graph[nodeId]) {\\n                if (dist[adjNodeId] > dist[nodeId] + adjNodeProb) {\\n                    dist[adjNodeId] = dist[nodeId] + adjNodeProb;\\n                    pq.push({ dist[adjNodeId], adjNodeId });\\n                }\\n            }\\n        }\\n\\n        return dist[end] == DBL_MAX ? 0 : 1 / exp(dist[end]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using Node = pair<int,double>;\\n    using Graph = vector<vector<Node>>;\\n    using NodeDistPair = pair<double,int>;\\n\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        Graph graph(n);\\n        for (int i = 0; i < edges.size(); i++) {\\n            auto edge = edges[i];\\n            double w = -log(succProb[i]);\\n            graph[edge[0]].push_back({ edge[1], w });\\n            graph[edge[1]].push_back({ edge[0], w });\\n        }\\n\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0;\\n\\n        priority_queue<NodeDistPair, vector<NodeDistPair>, greater<NodeDistPair>> pq;\\n        pq.push({ 0, start });\\n\\n        while (!pq.empty()) {\\n            int nodeId = pq.top().second;\\n            pq.pop();\\n\\n            for (auto [adjNodeId, adjNodeProb]: graph[nodeId]) {\\n                if (dist[adjNodeId] > dist[nodeId] + adjNodeProb) {\\n                    dist[adjNodeId] = dist[nodeId] + adjNodeProb;\\n                    pq.push({ dist[adjNodeId], adjNodeId });\\n                }\\n            }\\n        }\\n\\n        return dist[end] == DBL_MAX ? 0 : 1 / exp(dist[end]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732577,
                "title": "java-dfs-with-memo",
                "content": "During the contest I used dfs plus a boolean array but I got a TLE beacuse use boolean array for this question with have many dmplicat calculation(the probabailty has already illegas calculate before).\\n```\\n//this is the tle code\\n double ans = 0, threashold = 1e-5;\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer,Map<Integer,Double>> map = new HashMap<>();\\n        for(int i=0;i<n;i++) map.put(i,new HashMap<>());\\n        for(int i=0;i<edges.length;i++){\\n            int[] e = edges[i];double cost = succProb[i];\\n            map.get(e[0]).put(e[1],cost);\\n            map.get(e[1]).put(e[0],cost);\\n        }\\n        boolean[] visited = new boolean[n];\\n        helper(map,start,end,1,visited);\\n        return ans;\\n    }\\n    private void helper(Map<Integer,Map<Integer,Double>> map,int cur, int end,double val,boolean[] visited){\\n        if(val <= threashold) return;\\n        visited[cur] = true;\\n        if(cur == end){\\n            ans = Math.max(ans,val);\\n            visited[cur] = false;\\n            return;\\n        }\\n        Map<Integer,Double> next = map.get(cur);\\n        for(Map.Entry<Integer,Double> entry : next.entrySet()){\\n            int nxt = entry.getKey();\\n            double cost = entry.getValue();\\n            if(visited[nxt]) continue;\\n            if(val * cost < ans) continue;\\n            helper(map,nxt,end,val * cost,visited);\\n        }\\n        visited[cur] = false;\\n    }\\n```\\n```\\n// this is the right code\\ndouble ans = 0, threashold = 1e-5;\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer,Map<Integer,Double>> map = new HashMap<>();\\n        for(int i=0;i<n;i++) map.put(i,new HashMap<>());\\n        for(int i=0;i<edges.length;i++){\\n            int[] e = edges[i]; double p = succProb[i]; \\n            map.get(e[0]).put(e[1],p);\\n            map.get(e[1]).put(e[0],p);\\n        }\\n        double[] memo = new double[n];\\n        helper(map,start,end,1,memo);\\n        return ans;\\n    }\\n    private void helper(Map<Integer,Map<Integer,Double>> map,int start,int end,double p,double[] memo){\\n        if(p <= 1e-5) return;\\n        if(memo[start] >= p || ans >= p) return; \\n        memo[start] = p;\\n        if(start==end){\\n            ans = p;\\n            return;\\n        }\\n        Map<Integer,Double> next = map.get(start);\\n        for(Map.Entry<Integer,Double> entry : next.entrySet()){\\n            helper(map,entry.getKey(),end,p*entry.getValue(),memo);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n//this is the tle code\\n double ans = 0, threashold = 1e-5;\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer,Map<Integer,Double>> map = new HashMap<>();\\n        for(int i=0;i<n;i++) map.put(i,new HashMap<>());\\n        for(int i=0;i<edges.length;i++){\\n            int[] e = edges[i];double cost = succProb[i];\\n            map.get(e[0]).put(e[1],cost);\\n            map.get(e[1]).put(e[0],cost);\\n        }\\n        boolean[] visited = new boolean[n];\\n        helper(map,start,end,1,visited);\\n        return ans;\\n    }\\n    private void helper(Map<Integer,Map<Integer,Double>> map,int cur, int end,double val,boolean[] visited){\\n        if(val <= threashold) return;\\n        visited[cur] = true;\\n        if(cur == end){\\n            ans = Math.max(ans,val);\\n            visited[cur] = false;\\n            return;\\n        }\\n        Map<Integer,Double> next = map.get(cur);\\n        for(Map.Entry<Integer,Double> entry : next.entrySet()){\\n            int nxt = entry.getKey();\\n            double cost = entry.getValue();\\n            if(visited[nxt]) continue;\\n            if(val * cost < ans) continue;\\n            helper(map,nxt,end,val * cost,visited);\\n        }\\n        visited[cur] = false;\\n    }\\n```\n```\\n// this is the right code\\ndouble ans = 0, threashold = 1e-5;\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer,Map<Integer,Double>> map = new HashMap<>();\\n        for(int i=0;i<n;i++) map.put(i,new HashMap<>());\\n        for(int i=0;i<edges.length;i++){\\n            int[] e = edges[i]; double p = succProb[i]; \\n            map.get(e[0]).put(e[1],p);\\n            map.get(e[1]).put(e[0],p);\\n        }\\n        double[] memo = new double[n];\\n        helper(map,start,end,1,memo);\\n        return ans;\\n    }\\n    private void helper(Map<Integer,Map<Integer,Double>> map,int start,int end,double p,double[] memo){\\n        if(p <= 1e-5) return;\\n        if(memo[start] >= p || ans >= p) return; \\n        memo[start] = p;\\n        if(start==end){\\n            ans = p;\\n            return;\\n        }\\n        Map<Integer,Double> next = map.get(start);\\n        for(Map.Entry<Integer,Double> entry : next.entrySet()){\\n            helper(map,entry.getKey(),end,p*entry.getValue(),memo);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731788,
                "title": "java-clean-bellman-ford-100-faster",
                "content": "Due to the not strong test case, we only need 10 loop to get accepted. In the algorithem itself the worst case would be at most n times loop\\nJust like bubble sort, every loop we move one step toward final answer, it is guarantee the final answer will be in n steps.\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        double[] cost = new double[n];\\n        cost[start] = 1;\\n        for (int i = 0; i < 10; i++)\\n            for (int j = 0; j < edges.length; j++) {\\n                int[] edge = edges[j];\\n                double prob = succProb[j];\\n                cost[edge[1]] = Math.max(cost[edge[1]], cost[edge[0]] * prob);\\n                cost[edge[0]] = Math.max(cost[edge[0]], cost[edge[1]] * prob);\\n            }\\n        return cost[end];\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        double[] cost = new double[n];\\n        cost[start] = 1;\\n        for (int i = 0; i < 10; i++)\\n            for (int j = 0; j < edges.length; j++) {\\n                int[] edge = edges[j];\\n                double prob = succProb[j];\\n                cost[edge[1]] = Math.max(cost[edge[1]], cost[edge[0]] * prob);\\n                cost[edge[0]] = Math.max(cost[edge[0]], cost[edge[1]] * prob);\\n            }\\n        return cost[end];\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731781,
                "title": "c-bfs",
                "content": "Runtime: 564 ms\\nMemory Usage: 46.6 MB\\n\\n```\\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        \\n        Dictionary<int, List<Tuple<int,double>>> adj = new Dictionary<int, List<Tuple<int,double>>>();\\n        \\n        for(int i=0; i< edges.Length; i++)\\n        {\\n            if (!adj.ContainsKey(edges[i][0])) { adj[edges[i][0]] = new List<Tuple<int,double>>(); }\\n            if (!adj.ContainsKey(edges[i][1])) { adj[edges[i][1]] = new List<Tuple<int,double>>(); }\\n            \\n            adj[edges[i][0]].Add(new Tuple<int,double>(edges[i][1], succProb[i]));\\n            adj[edges[i][1]].Add(new Tuple<int,double>(edges[i][0], succProb[i]));\\n        }\\n        \\n        double[] val = new double[n];\\n        val[start] = 1;\\n       \\n        \\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(start);\\n        \\n        int idx;\\n        \\n        while(queue.Count > 0)\\n        {\\n            idx = queue.Dequeue();\\n            \\n            if (!adj.ContainsKey(idx)) { continue; }\\n            \\n            foreach(Tuple<int,double> t in adj[idx])\\n            {\\n                if (val[idx] * t.Item2 > val[t.Item1])\\n                {\\n                    val[t.Item1] = val[idx] * t.Item2;\\n                    queue.Enqueue(t.Item1);\\n                }\\n            }\\n        }\\n        \\n        return val[end];\\n    }\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "Runtime: 564 ms\\nMemory Usage: 46.6 MB\\n\\n```\\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        \\n        Dictionary<int, List<Tuple<int,double>>> adj = new Dictionary<int, List<Tuple<int,double>>>();\\n        \\n        for(int i=0; i< edges.Length; i++)\\n        {\\n            if (!adj.ContainsKey(edges[i][0])) { adj[edges[i][0]] = new List<Tuple<int,double>>(); }\\n            if (!adj.ContainsKey(edges[i][1])) { adj[edges[i][1]] = new List<Tuple<int,double>>(); }\\n            \\n            adj[edges[i][0]].Add(new Tuple<int,double>(edges[i][1], succProb[i]));\\n            adj[edges[i][1]].Add(new Tuple<int,double>(edges[i][0], succProb[i]));\\n        }\\n        \\n        double[] val = new double[n];\\n        val[start] = 1;\\n       \\n        \\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(start);\\n        \\n        int idx;\\n        \\n        while(queue.Count > 0)\\n        {\\n            idx = queue.Dequeue();\\n            \\n            if (!adj.ContainsKey(idx)) { continue; }\\n            \\n            foreach(Tuple<int,double> t in adj[idx])\\n            {\\n                if (val[idx] * t.Item2 > val[t.Item1])\\n                {\\n                    val[t.Item1] = val[idx] * t.Item2;\\n                    queue.Enqueue(t.Item1);\\n                }\\n            }\\n        }\\n        \\n        return val[end];\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 731557,
                "title": "c-dijkstra-approach-use-logarithmic-sum-to-maximize-product-of-path",
                "content": "To get max(p1 * p2 * p3) you should get max(log(p1) + log(p2) + log(p3))\\n\\n```\\n        public class Solution\\n        {\\n\\n            public class Heap<T>\\n            {\\n                private readonly IList<T> _data;\\n                private readonly IComparer<T> _comparer;\\n\\n                public int Count => _data.Count;\\n                public T Peek => _data[0];\\n\\n                public Heap(IList<T> inputs, IComparer<T> comparer = null)\\n                {\\n                    _comparer = comparer ?? Comparer<T>.Default;\\n                    _data = inputs;\\n                    for (int i = Count / 2; i >= 0; i--)\\n                    {\\n                        SiftDown(i);\\n                    }\\n                }\\n\\n                public Heap(IEnumerable<T> inputs, IComparer<T> comparer = null) : this(inputs.ToList(), comparer)\\n                {\\n                }\\n\\n                private void Swap(int i, int j)\\n                {\\n                    var tmp = _data[i];\\n                    _data[i] = _data[j];\\n                    _data[j] = tmp;\\n                }\\n\\n                private void SiftDown(int i)\\n                {\\n                    while (2 * i + 1 < _data.Count)\\n                    {\\n                        int left = 2 * i + 1;\\n                        int right = 2 * i + 2;\\n                        int j = left;\\n\\n                        if (right < _data.Count && _comparer.Compare(_data[right], _data[left]) < 0)\\n                        {\\n                            j = right;\\n                        }\\n\\n                        if (_comparer.Compare(_data[i], _data[j]) <= 0)\\n                        {\\n                            break;\\n                        }\\n\\n                        Swap(i, j);\\n                        i = j;\\n                    }\\n                }\\n\\n                private void SiftUp(int i)\\n                {\\n                    while (_comparer.Compare(_data[i], _data[(i - 1) / 2]) < 0)\\n                    {\\n                        Swap(i, (i - 1) / 2);\\n                        i = (i - 1) / 2;\\n                    }\\n                }\\n\\n                public T Pop()\\n                {\\n                    T top = Peek;\\n                    _data[0] = _data.Last();\\n                    _data.RemoveAt(Count - 1);\\n                    SiftDown(0);\\n                    return top;\\n                }\\n\\n                public void Push(T value)\\n                {\\n                    _data.Add(value);\\n                    SiftUp(Count - 1);\\n                }\\n            }\\n\\n            private class TupleComparer : IComparer<(int dst, double lgSum, double prod)>\\n            {\\n                public int Compare((int dst, double lgSum, double prod) x, (int dst, double lgSum, double prod) y) => y.lgSum.CompareTo(x.lgSum);\\n            }\\n\\n            private const double EPS = 1e-6;\\n\\n            private (double lgSum, double prod)[] Dijkstra(int[][] edges, double[] succProb, int n, int k)\\n            {\\n                IDictionary<int, IList<(int dst, double lgSum, double prod)>> graph = new Dictionary<int, IList<(int dst, double lgSum, double prod)>>();\\n\\n                for (int i = 0; i < edges.Length; i++)\\n                {\\n                    var edge = edges[i];\\n                    if (!graph.ContainsKey(edge[0]))\\n                    {\\n                        graph[edge[0]] = new List<(int dst, double lgSum, double prod)>();\\n                    }\\n\\n                    if (!graph.ContainsKey(edge[1]))\\n                    {\\n                        graph[edge[1]] = new List<(int dst, double lgSum, double prod)>();\\n                    }\\n\\n                    graph[edge[0]].Add((edge[1], Math.Log10(succProb[i]), succProb[i]));\\n                    graph[edge[1]].Add((edge[0], Math.Log10(succProb[i]), succProb[i]));\\n                }\\n                \\n\\n                (double lgSum, double prod)[] res = new (double lgSum, double prod)[n];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    res[i] = (double.MinValue, 0);\\n                }\\n\\n                res[k] = (Math.Log10(1), 1);\\n\\n                IList<(int dst, double lgSum, double prod)> distNodes = new List<(int dst, double lgSum, double prod)>(res.Length);\\n                for (int i = 0; i < res.Length; i++)\\n                {\\n                    distNodes.Add((i, res[i].lgSum, res[i].prod));\\n                }\\n\\n                Heap<(int dst, double lgSum, double prod)> heap = new Heap<(int dst, double lgSum, double prod)>(distNodes, new TupleComparer());\\n\\n                while (heap.Count > 0)\\n                {\\n                    var top = heap.Pop();\\n\\n                    var resData = res[top.dst];\\n                    //inactual data\\n                    if (Math.Abs(resData.lgSum - top.lgSum) > EPS)\\n                    {\\n                        continue;\\n                    }\\n\\n                    int shifted = top.dst;\\n\\n                    if (graph.ContainsKey(shifted))\\n                    {\\n                        foreach (var edge in graph[shifted])\\n                        {\\n                            int dst = edge.dst;\\n                            double lgSum = edge.lgSum;\\n\\n                            var possibleWeight = resData.lgSum + lgSum;\\n\\n                            if (possibleWeight > res[dst].lgSum)\\n                            {\\n                                res[dst] = (possibleWeight, resData.prod * edge.prod);\\n                                heap.Push((dst, res[dst].lgSum, res[dst].prod));\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                return res;\\n            }\\n\\n\\n            public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end)\\n            {\\n                var res = Dijkstra(edges, succProb, n, start);\\n                return res[end].prod;\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public class Solution\\n        {\\n\\n            public class Heap<T>\\n            {\\n                private readonly IList<T> _data;\\n                private readonly IComparer<T> _comparer;\\n\\n                public int Count => _data.Count;\\n                public T Peek => _data[0];\\n\\n                public Heap(IList<T> inputs, IComparer<T> comparer = null)\\n                {\\n                    _comparer = comparer ?? Comparer<T>.Default;\\n                    _data = inputs;\\n                    for (int i = Count / 2; i >= 0; i--)\\n                    {\\n                        SiftDown(i);\\n                    }\\n                }\\n\\n                public Heap(IEnumerable<T> inputs, IComparer<T> comparer = null) : this(inputs.ToList(), comparer)\\n                {\\n                }\\n\\n                private void Swap(int i, int j)\\n                {\\n                    var tmp = _data[i];\\n                    _data[i] = _data[j];\\n                    _data[j] = tmp;\\n                }\\n\\n                private void SiftDown(int i)\\n                {\\n                    while (2 * i + 1 < _data.Count)\\n                    {\\n                        int left = 2 * i + 1;\\n                        int right = 2 * i + 2;\\n                        int j = left;\\n\\n                        if (right < _data.Count && _comparer.Compare(_data[right], _data[left]) < 0)\\n                        {\\n                            j = right;\\n                        }\\n\\n                        if (_comparer.Compare(_data[i], _data[j]) <= 0)\\n                        {\\n                            break;\\n                        }\\n\\n                        Swap(i, j);\\n                        i = j;\\n                    }\\n                }\\n\\n                private void SiftUp(int i)\\n                {\\n                    while (_comparer.Compare(_data[i], _data[(i - 1) / 2]) < 0)\\n                    {\\n                        Swap(i, (i - 1) / 2);\\n                        i = (i - 1) / 2;\\n                    }\\n                }\\n\\n                public T Pop()\\n                {\\n                    T top = Peek;\\n                    _data[0] = _data.Last();\\n                    _data.RemoveAt(Count - 1);\\n                    SiftDown(0);\\n                    return top;\\n                }\\n\\n                public void Push(T value)\\n                {\\n                    _data.Add(value);\\n                    SiftUp(Count - 1);\\n                }\\n            }\\n\\n            private class TupleComparer : IComparer<(int dst, double lgSum, double prod)>\\n            {\\n                public int Compare((int dst, double lgSum, double prod) x, (int dst, double lgSum, double prod) y) => y.lgSum.CompareTo(x.lgSum);\\n            }\\n\\n            private const double EPS = 1e-6;\\n\\n            private (double lgSum, double prod)[] Dijkstra(int[][] edges, double[] succProb, int n, int k)\\n            {\\n                IDictionary<int, IList<(int dst, double lgSum, double prod)>> graph = new Dictionary<int, IList<(int dst, double lgSum, double prod)>>();\\n\\n                for (int i = 0; i < edges.Length; i++)\\n                {\\n                    var edge = edges[i];\\n                    if (!graph.ContainsKey(edge[0]))\\n                    {\\n                        graph[edge[0]] = new List<(int dst, double lgSum, double prod)>();\\n                    }\\n\\n                    if (!graph.ContainsKey(edge[1]))\\n                    {\\n                        graph[edge[1]] = new List<(int dst, double lgSum, double prod)>();\\n                    }\\n\\n                    graph[edge[0]].Add((edge[1], Math.Log10(succProb[i]), succProb[i]));\\n                    graph[edge[1]].Add((edge[0], Math.Log10(succProb[i]), succProb[i]));\\n                }\\n                \\n\\n                (double lgSum, double prod)[] res = new (double lgSum, double prod)[n];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    res[i] = (double.MinValue, 0);\\n                }\\n\\n                res[k] = (Math.Log10(1), 1);\\n\\n                IList<(int dst, double lgSum, double prod)> distNodes = new List<(int dst, double lgSum, double prod)>(res.Length);\\n                for (int i = 0; i < res.Length; i++)\\n                {\\n                    distNodes.Add((i, res[i].lgSum, res[i].prod));\\n                }\\n\\n                Heap<(int dst, double lgSum, double prod)> heap = new Heap<(int dst, double lgSum, double prod)>(distNodes, new TupleComparer());\\n\\n                while (heap.Count > 0)\\n                {\\n                    var top = heap.Pop();\\n\\n                    var resData = res[top.dst];\\n                    //inactual data\\n                    if (Math.Abs(resData.lgSum - top.lgSum) > EPS)\\n                    {\\n                        continue;\\n                    }\\n\\n                    int shifted = top.dst;\\n\\n                    if (graph.ContainsKey(shifted))\\n                    {\\n                        foreach (var edge in graph[shifted])\\n                        {\\n                            int dst = edge.dst;\\n                            double lgSum = edge.lgSum;\\n\\n                            var possibleWeight = resData.lgSum + lgSum;\\n\\n                            if (possibleWeight > res[dst].lgSum)\\n                            {\\n                                res[dst] = (possibleWeight, resData.prod * edge.prod);\\n                                heap.Push((dst, res[dst].lgSum, res[dst].prod));\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                return res;\\n            }\\n\\n\\n            public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end)\\n            {\\n                var res = Dijkstra(edges, succProb, n, start);\\n                return res[end].prod;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731545,
                "title": "python-modified-dijkstra-s-algorithm",
                "content": "**Intuition/Algorithms**\\n\\nWe can use a modified Dijkstra\\'s algorithm. Dijkstra\\'s algorithm finds the shortest path from the start node to all other nodes. We can slightly modify the algorithm to find the highest probability from start node to all other nodes. Instead of using minimum heap, we use maximum heap to keep track of the maximum probability.\\n\\nJust as in the Dijkstra\\'s algorithm, we pick the node with the most extreme value (maximum probability in this case) and try to compute the upcoming cost from this node to its adjacent nodes. We update the value if it has a higher probabiltiy. If we repeat this until we reach the destination node, we will get the maximum probability from the `start` node to the `end` node. \\n\\nAlso, note that it is important not to multiply the probability by 0 when we are computing the next node\\'s probability from the start node.\\n\\n**Complexties**\\n\\nTime: Dijkstra\\'s algorithm is `O(ElogN)` where `N` is the number of nodes and `E` is the total number of edges\\nSpace: Graph + MaxHeap + Distance Table = `O(N + E + N + N)` = `O(N + E)`\\n\\n**Code**\\n\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        dist = [-math.inf for _ in range(n)]\\n        dist[start] = 1\\n        max_heap = [(1, start)]\\n        graph = collections.defaultdict(list)\\n        for (u, v), w in zip(edges, succProb):\\n            graph[u].append((v, w))\\n            graph[v].append((u, w))\\n        while max_heap:\\n            prob, node = heapq.heappop(max_heap)\\n            prob = abs(prob) # make it positive to avoid confusion\\n            if node == end:\\n                return prob\\n            for adj, next_prob in graph[node]:\\n                # if we are coming from the start node, make sure we don\\'t multiply it by 0\\n                next_prob *= prob\\n                if dist[adj] < next_prob:\\n                    dist[adj] = next_prob\\n                    heapq.heappush(max_heap, (-next_prob, adj))\\n        return 0.0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        dist = [-math.inf for _ in range(n)]\\n        dist[start] = 1\\n        max_heap = [(1, start)]\\n        graph = collections.defaultdict(list)\\n        for (u, v), w in zip(edges, succProb):\\n            graph[u].append((v, w))\\n            graph[v].append((u, w))\\n        while max_heap:\\n            prob, node = heapq.heappop(max_heap)\\n            prob = abs(prob) # make it positive to avoid confusion\\n            if node == end:\\n                return prob\\n            for adj, next_prob in graph[node]:\\n                # if we are coming from the start node, make sure we don\\'t multiply it by 0\\n                next_prob *= prob\\n                if dist[adj] < next_prob:\\n                    dist[adj] = next_prob\\n                    heapq.heappush(max_heap, (-next_prob, adj))\\n        return 0.0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731543,
                "title": "java-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    \\n    class Path {\\n        int start, end;\\n        double prob;\\n        Path(int start, int end, double prob) {\\n            this.start = start;\\n            this.end = end;\\n            this.prob = prob;\\n        }\\n    }\\n    \\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        if(start == end) return 1.0;\\n        Map<Integer, List<Path>> graph = buildGraph(n, edges, succProb);\\n        PriorityQueue<Path> pq = new PriorityQueue<>(1, new ComparePath()); // contains the path from start node to all reached node.\\n        for(Path p : graph.get(start)) {\\n            pq.add(p);\\n        }\\n        Map<Integer, Double> visited = new HashMap<>(); // the max probability to reach a node.\\n        visited.put(start, 1.0);\\n        while(!pq.isEmpty()) {\\n            Path curr = pq.poll();\\n            if(visited.containsKey(curr.end)) continue;\\n            visited.put(curr.end, curr.prob);\\n            if(curr.end == end) return visited.get(end);\\n            for(Path next : graph.get(curr.end)) {\\n                pq.add(new Path(curr.start, next.end, curr.prob * next.prob));\\n            }\\n        }\\n        return 0.0;\\n    }\\n    \\n    // Mapping from a node to all the paths to its neighbors.\\n    private Map<Integer, List<Path>> buildGraph(int n, int[][] edges, double[] suc) {\\n        Map<Integer, List<Path>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) map.put(i, new ArrayList<>());\\n        for(int i = 0; i < edges.length; i++) {\\n            map.get(edges[i][0]).add(new Path(edges[i][0], edges[i][1], suc[i]));\\n            map.get(edges[i][1]).add(new Path(edges[i][1], edges[i][0], suc[i]));\\n        }\\n        return map;\\n    }\\n    \\n    public class ComparePath implements Comparator<Path> {\\n        @Override\\n        public int compare(Path a, Path b) {\\n            if(a.prob < b.prob) return 1;\\n            else if(a.prob > b.prob) return -1;\\n            else return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Path {\\n        int start, end;\\n        double prob;\\n        Path(int start, int end, double prob) {\\n            this.start = start;\\n            this.end = end;\\n            this.prob = prob;\\n        }\\n    }\\n    \\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        if(start == end) return 1.0;\\n        Map<Integer, List<Path>> graph = buildGraph(n, edges, succProb);\\n        PriorityQueue<Path> pq = new PriorityQueue<>(1, new ComparePath()); // contains the path from start node to all reached node.\\n        for(Path p : graph.get(start)) {\\n            pq.add(p);\\n        }\\n        Map<Integer, Double> visited = new HashMap<>(); // the max probability to reach a node.\\n        visited.put(start, 1.0);\\n        while(!pq.isEmpty()) {\\n            Path curr = pq.poll();\\n            if(visited.containsKey(curr.end)) continue;\\n            visited.put(curr.end, curr.prob);\\n            if(curr.end == end) return visited.get(end);\\n            for(Path next : graph.get(curr.end)) {\\n                pq.add(new Path(curr.start, next.end, curr.prob * next.prob));\\n            }\\n        }\\n        return 0.0;\\n    }\\n    \\n    // Mapping from a node to all the paths to its neighbors.\\n    private Map<Integer, List<Path>> buildGraph(int n, int[][] edges, double[] suc) {\\n        Map<Integer, List<Path>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) map.put(i, new ArrayList<>());\\n        for(int i = 0; i < edges.length; i++) {\\n            map.get(edges[i][0]).add(new Path(edges[i][0], edges[i][1], suc[i]));\\n            map.get(edges[i][1]).add(new Path(edges[i][1], edges[i][0], suc[i]));\\n        }\\n        return map;\\n    }\\n    \\n    public class ComparePath implements Comparator<Path> {\\n        @Override\\n        public int compare(Path a, Path b) {\\n            if(a.prob < b.prob) return 1;\\n            else if(a.prob > b.prob) return -1;\\n            else return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693513,
                "title": "readable-javascript-solution-using-dijkstra-s-algorithm",
                "content": "```js\\n// use Dijkstra\\'s algorithm to find max probability path\\nconst maxProbability = (n, edges, succProb, start, end) => {\\n    // convert edges to graph with weights\\n    const graph = getGraph(n, edges, succProb);\\n\\n    // create map of probabilities, initializing all nodes to 0%\\n    const succs = Object.keys(graph).reduce((a, b) => {\\n        a[b] = 0;\\n        return a;\\n    }, {});\\n\\n    // create max heap to process nodes\\n    const heap = new MaxPriorityQueue({ compare: (a, b) => b[1] - a[1] });\\n\\n    // initialize neighboring nodes of start to their edge weights\\n    for (const [neighbor, w] of graph[start]) {\\n        succs[neighbor] = w;\\n        heap.enqueue([neighbor, w]);\\n    }\\n\\n    // traverse graph with priority for highest probability nodes\\n    while (heap.size()) {\\n        const [ node, prob ] = heap.dequeue();\\n\\n        // relax nodes to higher probability by updating their values when better path found\\n        for (const [neighbor, w] of graph[node]) {\\n            const newProb = prob * w;\\n            if (succs[neighbor] < newProb) {\\n                succs[neighbor] = newProb;\\n                heap.enqueue([neighbor, newProb]);\\n            }\\n        }\\n    }\\n\\n    // end node will have highest possible probability\\n    return succs[end];\\n};\\n\\nconst getGraph = (n, edges, succProb) => {\\n    const graph = {};\\n\\n    for (let i = 0; i < n; i++) {\\n        graph[i] = [];\\n    }\\n\\n    for (const [ i, edge ] of edges.entries()) {\\n        const [a, b] = edge;\\n        const cost = succProb[i];\\n        graph[a].push([b, cost]);\\n        graph[b].push([a, cost]);\\n    }\\n\\n    return graph;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```js\\n// use Dijkstra\\'s algorithm to find max probability path\\nconst maxProbability = (n, edges, succProb, start, end) => {\\n    // convert edges to graph with weights\\n    const graph = getGraph(n, edges, succProb);\\n\\n    // create map of probabilities, initializing all nodes to 0%\\n    const succs = Object.keys(graph).reduce((a, b) => {\\n        a[b] = 0;\\n        return a;\\n    }, {});\\n\\n    // create max heap to process nodes\\n    const heap = new MaxPriorityQueue({ compare: (a, b) => b[1] - a[1] });\\n\\n    // initialize neighboring nodes of start to their edge weights\\n    for (const [neighbor, w] of graph[start]) {\\n        succs[neighbor] = w;\\n        heap.enqueue([neighbor, w]);\\n    }\\n\\n    // traverse graph with priority for highest probability nodes\\n    while (heap.size()) {\\n        const [ node, prob ] = heap.dequeue();\\n\\n        // relax nodes to higher probability by updating their values when better path found\\n        for (const [neighbor, w] of graph[node]) {\\n            const newProb = prob * w;\\n            if (succs[neighbor] < newProb) {\\n                succs[neighbor] = newProb;\\n                heap.enqueue([neighbor, newProb]);\\n            }\\n        }\\n    }\\n\\n    // end node will have highest possible probability\\n    return succs[end];\\n};\\n\\nconst getGraph = (n, edges, succProb) => {\\n    const graph = {};\\n\\n    for (let i = 0; i < n; i++) {\\n        graph[i] = [];\\n    }\\n\\n    for (const [ i, edge ] of edges.entries()) {\\n        const [a, b] = edge;\\n        const cost = succProb[i];\\n        graph[a].push([b, cost]);\\n        graph[b].push([a, cost]);\\n    }\\n\\n    return graph;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692412,
                "title": "java-solution-using-dijkstra-s-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        \\n        List<double []>[] graph = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            graph[edges[i][0]].add(new double[]{edges[i][1],succProb[i]});\\n            graph[edges[i][1]].add(new double[]{edges[i][0],succProb[i]});\\n        }\\n        boolean []vis = new boolean[n];\\n        PriorityQueue<double[]> pq = new PriorityQueue<>((a,b)->Double.compare(b[1],a[1]));\\n        pq.add(new double[]{start,1});\\n\\n        while(pq.size()!=0){\\n\\n            double [] temp = pq.poll();\\n            if(temp[0] == end){\\n                return temp[1];\\n            }\\n            if(vis[(int)temp[0]]){\\n                continue;\\n            }\\n            vis[(int)temp[0]] = true;\\n            for(double []nbr : graph[(int)temp[0]]){\\n                pq.add(new double[]{nbr[0],temp[1]*nbr[1]});\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        \\n        List<double []>[] graph = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            graph[edges[i][0]].add(new double[]{edges[i][1],succProb[i]});\\n            graph[edges[i][1]].add(new double[]{edges[i][0],succProb[i]});\\n        }\\n        boolean []vis = new boolean[n];\\n        PriorityQueue<double[]> pq = new PriorityQueue<>((a,b)->Double.compare(b[1],a[1]));\\n        pq.add(new double[]{start,1});\\n\\n        while(pq.size()!=0){\\n\\n            double [] temp = pq.poll();\\n            if(temp[0] == end){\\n                return temp[1];\\n            }\\n            if(vis[(int)temp[0]]){\\n                continue;\\n            }\\n            vis[(int)temp[0]] = true;\\n            for(double []nbr : graph[(int)temp[0]]){\\n                pq.add(new double[]{nbr[0],temp[1]*nbr[1]});\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692353,
                "title": "plain-simple-dijkastra-s-well-explained-c",
                "content": "# Pre-Requisite\\n[Dijkstra\\'s](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)\\n\\n# Intuition\\nThe above problem seems familiar to finding the shortest distance in  undirected weighted graphs. Hence, our first guess could be a BFS kind of approach. The only thing that we need to take care of is that for all the paths possible between a pair of nodes, we need to store the path with the maximum probability . That is, say we have a node that has been reached by two paths, one with a probability of 0.7 and another with a probability of say 0.3. It is obvious that the path with a probability of 0.7 would be more optimal than the path with a probability of 0.3.\\n\\nSince probability can never be -ve we use Dijkstra\\'s to do this.\\nIf in some absurd scenario we get a problem in which the probability (or the edge weights) can be negative we will have to use bellman ford Algo.\\n\\n# Approach\\nWe\\u2019ll be using max heap in this approach for finding the path with maximum probabilty from the source node to every other node through Dijkstra\\u2019s Algorithm.\\n\\nSince max prob is required, we maintain a max heap.\\nWe push the source node to the heap along with its probabilty which is set to 0. (As we need max probability)\\n\\nFor each of it\\'s neighbouring nodes we update the dis data structure only when the probability of reaching the neighbouring node is more than what we have previously computed or we could say that \\nFor every node at the top of the heap, we pop the element out and look out for its adjacent nodes. If the current reachable node probability is more  than the previous probability indicated by the dis array, we update the probability and push it into the queue.\\n\\nOnce we are done with this our dis array would represent maximum probability to reach  each node from start node. \\n\\n# Complexity\\n- Time complexity:\\n    - O((V+E)logV) (if we use adjacency list)\\n    - O(V^2) (if we use adjacency matrix)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere V is number of nodes and E is number of Edges.\\n\\nP.S. Note that probability is in decimal hence we\\'ll have to use double.\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<pair<int, double>>> adj;\\n    vector<bool> vis;\\n    vector<double> dis;\\n\\n    void dijkstra(int s, int e, int n) \\n    {\\n        dis.resize(n, 0.0);\\n        dis[s] = 1.0;\\n\\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1.0, s});\\n\\n        while (!pq.empty()) \\n        {\\n            double wt_u = pq.top().first;\\n            int u = pq.top().second;\\n            pq.pop();\\n            if (!vis[u]) \\n            {\\n                vis[u] = 1;\\n                for (auto& i : adj[u]) \\n                {\\n                    int v = i.first;\\n                    double wt_v = i.second;\\n                \\n                    //probability of completing both task A and task B is p(a)*p(b)\\n                    if (wt_u * wt_v > dis[v]) \\n                    {\\n                        dis[v] = wt_u * wt_v;\\n                        pq.push({dis[v], v});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    double maxProbability(int n, vector<vector<int>>& ed, vector<double>& p, int s, int e) \\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n\\n        adj.resize(n);\\n        vis.resize(n, 0);\\n\\n        for (int i = 0; i < ed.size(); i++) \\n        {\\n            int u = ed[i][0];\\n            int v = ed[i][1];\\n            double weight = p[i];\\n\\n            adj[u].push_back({v, weight});\\n            adj[v].push_back({u, weight});\\n        }\\n\\n        dijkstra(s, e, n);\\n\\n        return dis[e];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<pair<int, double>>> adj;\\n    vector<bool> vis;\\n    vector<double> dis;\\n\\n    void dijkstra(int s, int e, int n) \\n    {\\n        dis.resize(n, 0.0);\\n        dis[s] = 1.0;\\n\\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1.0, s});\\n\\n        while (!pq.empty()) \\n        {\\n            double wt_u = pq.top().first;\\n            int u = pq.top().second;\\n            pq.pop();\\n            if (!vis[u]) \\n            {\\n                vis[u] = 1;\\n                for (auto& i : adj[u]) \\n                {\\n                    int v = i.first;\\n                    double wt_v = i.second;\\n                \\n                    //probability of completing both task A and task B is p(a)*p(b)\\n                    if (wt_u * wt_v > dis[v]) \\n                    {\\n                        dis[v] = wt_u * wt_v;\\n                        pq.push({dis[v], v});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    double maxProbability(int n, vector<vector<int>>& ed, vector<double>& p, int s, int e) \\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n\\n        adj.resize(n);\\n        vis.resize(n, 0);\\n\\n        for (int i = 0; i < ed.size(); i++) \\n        {\\n            int u = ed[i][0];\\n            int v = ed[i][1];\\n            double weight = p[i];\\n\\n            adj[u].push_back({v, weight});\\n            adj[v].push_back({u, weight});\\n        }\\n\\n        dijkstra(s, e, n);\\n\\n        return dis[e];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692267,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n]; //Creating adjacency list\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>>pq; //Use maxHeap for path with the maximum probability\\n        pq.push({1.0,start}); //{probability,node}\\n        vector<double>dist(n,INT_MIN);\\n        dist[start]=1;\\n        while(!pq.empty()){\\n            auto itr=pq.top();\\n            pq.pop();\\n            double dis=itr.first;\\n            int node=itr.second;\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                double edW=it.second;\\n                if(dist[adjNode]<dis*edW){ //If greater probability is found then update probability of adjacent node & push adjacent node in maxHeap\\n                    dist[adjNode]=dis*edW;\\n                    pq.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }        \\n        if(dist[end]==INT_MIN) return 0.00000; //If there is no path from start to end\\n        else return dist[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n]; //Creating adjacency list\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>>pq; //Use maxHeap for path with the maximum probability\\n        pq.push({1.0,start}); //{probability,node}\\n        vector<double>dist(n,INT_MIN);\\n        dist[start]=1;\\n        while(!pq.empty()){\\n            auto itr=pq.top();\\n            pq.pop();\\n            double dis=itr.first;\\n            int node=itr.second;\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                double edW=it.second;\\n                if(dist[adjNode]<dis*edW){ //If greater probability is found then update probability of adjacent node & push adjacent node in maxHeap\\n                    dist[adjNode]=dis*edW;\\n                    pq.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }        \\n        if(dist[end]==INT_MIN) return 0.00000; //If there is no path from start to end\\n        else return dist[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691989,
                "title": "implementation-of-bellman-ford",
                "content": "\\n# Java\\n```\\npublic double maxProbability(int n, int[][] edges, double[] successProbability, int start, int end) {\\n    Map<Integer, List<Edge>> edgeInfo = new HashMap<>();\\n    for (int index = 0; index < edges.length; ++index) {\\n      int from = edges[index][0], to = edges[index][1]; \\n      double probability = successProbability[index];\\n\\n      edgeInfo.computeIfAbsent(from, p -> new ArrayList<>()).add(new Edge(to, probability));\\n      edgeInfo.computeIfAbsent(to, p -> new ArrayList<>()).add(new Edge(from, probability));\\n    }\\n\\n    double[] probabilities = new double[n]; probabilities[start] = 1.0;\\n    Queue<Integer> queue = new LinkedList<>(List.of(start));\\n    while (!queue.isEmpty()) {\\n      int current = queue.poll();\\n\\n      for (Edge edge : edgeInfo.getOrDefault(current, List.of())) {\\n        if (probabilities[edge.to] < probabilities[current] * edge.probability) {\\n          probabilities[edge.to] = probabilities[current] * edge.probability;\\n          queue.offer(edge.to);\\n        }\\n      }\\n    }\\n    return probabilities[end];\\n  }\\n\\n  private record Edge(int to, double probability) { }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic double maxProbability(int n, int[][] edges, double[] successProbability, int start, int end) {\\n    Map<Integer, List<Edge>> edgeInfo = new HashMap<>();\\n    for (int index = 0; index < edges.length; ++index) {\\n      int from = edges[index][0], to = edges[index][1]; \\n      double probability = successProbability[index];\\n\\n      edgeInfo.computeIfAbsent(from, p -> new ArrayList<>()).add(new Edge(to, probability));\\n      edgeInfo.computeIfAbsent(to, p -> new ArrayList<>()).add(new Edge(from, probability));\\n    }\\n\\n    double[] probabilities = new double[n]; probabilities[start] = 1.0;\\n    Queue<Integer> queue = new LinkedList<>(List.of(start));\\n    while (!queue.isEmpty()) {\\n      int current = queue.poll();\\n\\n      for (Edge edge : edgeInfo.getOrDefault(current, List.of())) {\\n        if (probabilities[edge.to] < probabilities[current] * edge.probability) {\\n          probabilities[edge.to] = probabilities[current] * edge.probability;\\n          queue.offer(edge.to);\\n        }\\n      }\\n    }\\n    return probabilities[end];\\n  }\\n\\n  private record Edge(int to, double probability) { }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691834,
                "title": "easy-shortest-path-c-using-heap",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        //For storing Probabilities\\n        vector<double> prob(n,0); \\n\\n        // Construct Adjacency Matrix\\n        vector<vector<pair<int,double>>> adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            double w=succProb[i];\\n\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n\\n        //Construct a Priority Queue which will give the node with Maximum probability\\n        priority_queue<pair<double,int>> q;\\n\\n        //Probability of Start will be 1 as we are already on that node\\n        prob[start]=1;\\n        q.push({1,start});\\n        \\n        while(!q.empty())\\n        {\\n            auto top=q.top();\\n            double p=top.first;\\n            int node=top.second;\\n            q.pop();\\n            for(auto nbr:adj[node])\\n            {\\n                int adjNode=nbr.first;\\n                double adjP=nbr.second;\\n                cout<<p<<\" \"<<adjP<<endl;\\n                if(prob[adjNode]<p*adjP)\\n                {\\n                    prob[adjNode]=p*adjP;\\n                    q.push({prob[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        return prob[end];\\n    }\\n};\\n```\\n# **Kindly Upvote if found this Helpful :P**",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        //For storing Probabilities\\n        vector<double> prob(n,0); \\n\\n        // Construct Adjacency Matrix\\n        vector<vector<pair<int,double>>> adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            double w=succProb[i];\\n\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n\\n        //Construct a Priority Queue which will give the node with Maximum probability\\n        priority_queue<pair<double,int>> q;\\n\\n        //Probability of Start will be 1 as we are already on that node\\n        prob[start]=1;\\n        q.push({1,start});\\n        \\n        while(!q.empty())\\n        {\\n            auto top=q.top();\\n            double p=top.first;\\n            int node=top.second;\\n            q.pop();\\n            for(auto nbr:adj[node])\\n            {\\n                int adjNode=nbr.first;\\n                double adjP=nbr.second;\\n                cout<<p<<\" \"<<adjP<<endl;\\n                if(prob[adjNode]<p*adjP)\\n                {\\n                    prob[adjNode]=p*adjP;\\n                    q.push({prob[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        return prob[end];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3691641,
                "title": "rust-dijkstra",
                "content": "Note that Rust\\'s `f64` does not implement the `Ord` trait because the `f64::NAN` can not be properly compared. We need to manually implement a wrap struct `NonNan` to implement the `Ord` trait so that we can use the `BinaryHeap`.\\n# Code\\n```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\n\\n#[derive(PartialEq)]\\nstruct NonNan(f64);\\n\\nimpl PartialOrd for NonNan {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        self.0.partial_cmp(&other.0)\\n    }\\n}\\n\\nimpl Ord for NonNan {\\n    fn cmp(&self, other: &NonNan) -> Ordering {\\n        self.partial_cmp(other).unwrap()\\n    }\\n}\\nimpl Eq for NonNan {}\\n\\nimpl Solution {\\n    pub fn max_probability(\\n        n: i32,\\n        edges: Vec<Vec<i32>>,\\n        succ_prob: Vec<f64>,\\n        start: i32,\\n        end: i32,\\n    ) -> f64 {\\n        let mut graph: Vec<Vec<(i32, f64)>> = vec![vec![]; n as usize];\\n        let mut queue: BinaryHeap<(NonNan, i32)> = BinaryHeap::new();\\n        for i in 0..edges.len() {\\n            graph[edges[i][0] as usize].push((edges[i][1], succ_prob[i]));\\n            graph[edges[i][1] as usize].push((edges[i][0], succ_prob[i]));\\n        }\\n        let mut max_res = vec![0.0; n as usize];\\n        max_res[start as usize] = 1.0;\\n        queue.push((NonNan(1.0), start));\\n        while let Some((NonNan(prob), cur)) = queue.pop() {\\n            if cur == end {\\n                return prob;\\n            }\\n            for adj in &graph[cur as usize] {\\n                if prob * adj.1 > max_res[adj.0 as usize] {\\n                    max_res[adj.0 as usize] = prob * adj.1;\\n                    queue.push((NonNan(max_res[adj.0 as usize]), adj.0));\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\n\\n#[derive(PartialEq)]\\nstruct NonNan(f64);\\n\\nimpl PartialOrd for NonNan {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        self.0.partial_cmp(&other.0)\\n    }\\n}\\n\\nimpl Ord for NonNan {\\n    fn cmp(&self, other: &NonNan) -> Ordering {\\n        self.partial_cmp(other).unwrap()\\n    }\\n}\\nimpl Eq for NonNan {}\\n\\nimpl Solution {\\n    pub fn max_probability(\\n        n: i32,\\n        edges: Vec<Vec<i32>>,\\n        succ_prob: Vec<f64>,\\n        start: i32,\\n        end: i32,\\n    ) -> f64 {\\n        let mut graph: Vec<Vec<(i32, f64)>> = vec![vec![]; n as usize];\\n        let mut queue: BinaryHeap<(NonNan, i32)> = BinaryHeap::new();\\n        for i in 0..edges.len() {\\n            graph[edges[i][0] as usize].push((edges[i][1], succ_prob[i]));\\n            graph[edges[i][1] as usize].push((edges[i][0], succ_prob[i]));\\n        }\\n        let mut max_res = vec![0.0; n as usize];\\n        max_res[start as usize] = 1.0;\\n        queue.push((NonNan(1.0), start));\\n        while let Some((NonNan(prob), cur)) = queue.pop() {\\n            if cur == end {\\n                return prob;\\n            }\\n            for adj in &graph[cur as usize] {\\n                if prob * adj.1 > max_res[adj.0 as usize] {\\n                    max_res[adj.0 as usize] = prob * adj.1;\\n                    queue.push((NonNan(max_res[adj.0 as usize]), adj.0));\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691280,
                "title": "daily-coding-challenge-java-easy-approach-bellman-ford-algorithm",
                "content": "\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code | Do upvote if u find this solution easy\\n\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n          double[] dp = new double[n];\\n    dp[start] = 1;\\n    while (true) {\\n        boolean k = false;\\n        for (int j = 0; j < edges.length; j++) {\\n            if (dp[edges[j][0]] * succProb[j] > dp[edges[j][1]]) {\\n                dp[edges[j][1]] = dp[edges[j][0]] * succProb[j];\\n                k = true;\\n            }\\n            if (dp[edges[j][1]] * succProb[j] > dp[edges[j][0]]) {\\n                dp[edges[j][0]] = dp[edges[j][1]] * succProb[j];\\n                k = true;\\n            }\\n        }\\n        if (!k) break;\\n    }\\n    return dp[end];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n          double[] dp = new double[n];\\n    dp[start] = 1;\\n    while (true) {\\n        boolean k = false;\\n        for (int j = 0; j < edges.length; j++) {\\n            if (dp[edges[j][0]] * succProb[j] > dp[edges[j][1]]) {\\n                dp[edges[j][1]] = dp[edges[j][0]] * succProb[j];\\n                k = true;\\n            }\\n            if (dp[edges[j][1]] * succProb[j] > dp[edges[j][0]]) {\\n                dp[edges[j][0]] = dp[edges[j][1]] * succProb[j];\\n                k = true;\\n            }\\n        }\\n        if (!k) break;\\n    }\\n    return dp[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691131,
                "title": "c-dfs-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double ans=0;\\n    double mn = 1e-5;\\n    void f(int start, int end, vector<bool> &vis, vector<pair<int,double>> adj[],double sum){\\n\\n        if(sum<=mn) return;\\n\\n        if(start==end){\\n            ans = max(ans,sum);\\n            return;\\n        }\\n        \\n        vis[start] = true;\\n        for(auto node: adj[start]){\\n            \\n            int child = node.first;\\n            double p = node.second;\\n           \\n            if(vis[child]==false && sum*p>=ans){\\n               f(child,end,vis,adj,sum*p);\\n            }\\n        }\\n        vis[start] = false;\\n    }\\n\\n\\n\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<int,double>> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        vector<bool> vis(n,false);\\n\\n        f(start,end,vis,adj,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double ans=0;\\n    double mn = 1e-5;\\n    void f(int start, int end, vector<bool> &vis, vector<pair<int,double>> adj[],double sum){\\n\\n        if(sum<=mn) return;\\n\\n        if(start==end){\\n            ans = max(ans,sum);\\n            return;\\n        }\\n        \\n        vis[start] = true;\\n        for(auto node: adj[start]){\\n            \\n            int child = node.first;\\n            double p = node.second;\\n           \\n            if(vis[child]==false && sum*p>=ans){\\n               f(child,end,vis,adj,sum*p);\\n            }\\n        }\\n        vis[start] = false;\\n    }\\n\\n\\n\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<int,double>> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        vector<bool> vis(n,false);\\n\\n        f(start,end,vis,adj,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690951,
                "title": "daily-leetcode-solution-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<int,double>> adj[n];\\n        int m = edges.size();\\n        for(int i = 0; i < m; i++){\\n            int u = edges[i][0], v = edges[i][1];\\n            double p = succProb[i];\\n            adj[u].push_back({v, p});\\n            adj[v].push_back({u, p});\\n        }\\n        \\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0, start}); // probability of reaching start node is 1\\n        \\n        vector<double> prob(n,0); // maintains the max probability of reaching any node\\n        prob[start] = 1; // probability of reaching start node\\n        \\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            int node = top.second;\\n            double currProb = top.first;\\n            pq.pop();\\n            \\n            if(node == end) return currProb; /* as the priority queue is a max heap it will always give\\n\\t\\t\\ta maximum probability of reaching curr node the first time we encounter it */\\n            \\n            for(auto &i:adj[node]){\\n                int adjNode = i.first;\\n                double p = i.second;\\n                if(prob[adjNode] < p*currProb){\\n                    prob[adjNode] = p*currProb;\\n                    pq.push({p*currProb, adjNode});\\n                }\\n            }\\n        }\\n        \\n        return 0; // if end node is unreachable then probability of reaching it is zero\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<int,double>> adj[n];\\n        int m = edges.size();\\n        for(int i = 0; i < m; i++){\\n            int u = edges[i][0], v = edges[i][1];\\n            double p = succProb[i];\\n            adj[u].push_back({v, p});\\n            adj[v].push_back({u, p});\\n        }\\n        \\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0, start}); // probability of reaching start node is 1\\n        \\n        vector<double> prob(n,0); // maintains the max probability of reaching any node\\n        prob[start] = 1; // probability of reaching start node\\n        \\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            int node = top.second;\\n            double currProb = top.first;\\n            pq.pop();\\n            \\n            if(node == end) return currProb; /* as the priority queue is a max heap it will always give\\n\\t\\t\\ta maximum probability of reaching curr node the first time we encounter it */\\n            \\n            for(auto &i:adj[node]){\\n                int adjNode = i.first;\\n                double p = i.second;\\n                if(prob[adjNode] < p*currProb){\\n                    prob[adjNode] = p*currProb;\\n                    pq.push({p*currProb, adjNode});\\n                }\\n            }\\n        }\\n        \\n        return 0; // if end node is unreachable then probability of reaching it is zero\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690912,
                "title": "best-code-in-c-java-python-maxheap-dijkshtra",
                "content": "### Connect with me on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n- Time complexity: **O(edges*log(n))**\\n\\n- Space complexity: **O(n)**\\n\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n# In C++ :-\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> distance(n,0);\\n        vector<vector<pair<int,double>>> adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1,start});\\n        while(pq.size()){\\n            auto [dis,u] = pq.top();\\n            pq.pop();\\n            if(u == end)\\n                return distance[u];\\n            for(auto [v,weight]:adj[u]){\\n                if(dis * weight > distance[v]){\\n                    distance[v] = dis * weight;\\n                    pq.push({distance[v],v});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n# In JAVA :-\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        PriorityQueue<Pair<Double, Integer>> pq = new PriorityQueue<>(new Comparator<Pair<Double, Integer>>() {\\n            public int compare(Pair<Double, Integer> p1, Pair<Double, Integer> p2) {\\n                return Double.compare(p2.getKey(), p1.getKey());\\n            }\\n        });\\n        \\n        List<Map<Integer, Double>> g = new ArrayList<>();\\n        double[] prob = new double[n];\\n        Arrays.fill(prob, -1);\\n        \\n        for (int i = 0; i < n; i++) {\\n            g.add(new HashMap<>());\\n        }\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            int u = edges[i][0], v = edges[i][1];\\n            double p = succProb[i];\\n            g.get(u).put(v, p);\\n            g.get(v).put(u, p);\\n        }\\n        \\n        pq.add(new Pair<>(1.0, start));\\n        \\n        while (!pq.isEmpty()) {\\n            Pair<Double, Integer> pair = pq.poll();\\n            double sp = pair.getKey();\\n            int u = pair.getValue();\\n            \\n            if (prob[u] != -1) {\\n                continue;\\n            }\\n            \\n            prob[u] = sp;\\n            \\n            for (Map.Entry<Integer, Double> entry : g.get(u).entrySet()) {\\n                int v = entry.getKey();\\n                double p = entry.getValue();\\n                \\n                if (prob[v] == -1) {\\n                    pq.add(new Pair<>(sp * p, v));\\n                }\\n            }\\n        }\\n        return Math.max(prob[end], 0.0);\\n    }\\n}\\n```\\n# In Python :-\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        g = [{} for _ in range(n)]\\n        prob = [-1] * n\\n        pq = []\\n\\n        for i in range(len(edges)):\\n            u, v = edges[i][0], edges[i][1]\\n            p = succProb[i]\\n            g[u][v] = p\\n            g[v][u] = p\\n\\n        heapq.heappush(pq, (-1, start))\\n        while pq:\\n            sp, u = heapq.heappop(pq)\\n            sp = -sp\\n\\n            if prob[u] != -1:\\n                continue\\n\\n            prob[u] = sp\\n\\n            for v, p in g[u].items():\\n                if prob[v] == -1:\\n                    heapq.heappush(pq, (-sp * p, v))\\n\\n        return max(prob[end], 0.0)\\n\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/7feed655-bc14-48e7-baef-9eee46811d1d_1687915896.354272.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> distance(n,0);\\n        vector<vector<pair<int,double>>> adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1,start});\\n        while(pq.size()){\\n            auto [dis,u] = pq.top();\\n            pq.pop();\\n            if(u == end)\\n                return distance[u];\\n            for(auto [v,weight]:adj[u]){\\n                if(dis * weight > distance[v]){\\n                    distance[v] = dis * weight;\\n                    pq.push({distance[v],v});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        PriorityQueue<Pair<Double, Integer>> pq = new PriorityQueue<>(new Comparator<Pair<Double, Integer>>() {\\n            public int compare(Pair<Double, Integer> p1, Pair<Double, Integer> p2) {\\n                return Double.compare(p2.getKey(), p1.getKey());\\n            }\\n        });\\n        \\n        List<Map<Integer, Double>> g = new ArrayList<>();\\n        double[] prob = new double[n];\\n        Arrays.fill(prob, -1);\\n        \\n        for (int i = 0; i < n; i++) {\\n            g.add(new HashMap<>());\\n        }\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            int u = edges[i][0], v = edges[i][1];\\n            double p = succProb[i];\\n            g.get(u).put(v, p);\\n            g.get(v).put(u, p);\\n        }\\n        \\n        pq.add(new Pair<>(1.0, start));\\n        \\n        while (!pq.isEmpty()) {\\n            Pair<Double, Integer> pair = pq.poll();\\n            double sp = pair.getKey();\\n            int u = pair.getValue();\\n            \\n            if (prob[u] != -1) {\\n                continue;\\n            }\\n            \\n            prob[u] = sp;\\n            \\n            for (Map.Entry<Integer, Double> entry : g.get(u).entrySet()) {\\n                int v = entry.getKey();\\n                double p = entry.getValue();\\n                \\n                if (prob[v] == -1) {\\n                    pq.add(new Pair<>(sp * p, v));\\n                }\\n            }\\n        }\\n        return Math.max(prob[end], 0.0);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        g = [{} for _ in range(n)]\\n        prob = [-1] * n\\n        pq = []\\n\\n        for i in range(len(edges)):\\n            u, v = edges[i][0], edges[i][1]\\n            p = succProb[i]\\n            g[u][v] = p\\n            g[v][u] = p\\n\\n        heapq.heappush(pq, (-1, start))\\n        while pq:\\n            sp, u = heapq.heappop(pq)\\n            sp = -sp\\n\\n            if prob[u] != -1:\\n                continue\\n\\n            prob[u] = sp\\n\\n            for v, p in g[u].items():\\n                if prob[v] == -1:\\n                    heapq.heappush(pq, (-sp * p, v))\\n\\n        return max(prob[end], 0.0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690875,
                "title": "dijkstra-s-algorithm-with-explanations",
                "content": "# Intuition\\nThe problem can be modelled as a classic shortest path algorithm between a start and an end node in a given graph, with two caveats - \\n1. Path Lengths don\\'t add up but factor on top of each other (0.5 * 0.5 = 0.25 instead of 0.5 + 0.5 = 1, see sample examples). \\n2. We are interested in the \\'longest\\' path instead of the usual \\'shortest\\' path in such algorithms.\\n\\n\\n# Approach\\nWe can use the classic Dijkstra\\'s Algorithm. Dijikstra\\'s is a greedy algorithm which looks similar to a classic BFS algorithm, except it always chooses the shortest unexplored edge available at any given moment. To do this, we use a min heap (In BFS algorithm we don\\'t need to use heap as any explored edge is sufficient for exploration). As we are interested in the longest path in this problem, we will use a max heap implementation instead.\\n\\n# Complexity\\n- Time complexity:\\nO(V + ElogE)\\nwhere E is the number of edges in the graph and V is the number of nodes in the graph.\\n- Space complexity:\\nO(V)\\n\\n# Code\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:       \\n        # build graph\\n        graph = defaultdict(list)\\n        for (u,v), probability in zip(edges, succProb):\\n            graph[u].append([v, probability])\\n            graph[v].append([u, probability])\\n\\n        # initialize priority queue, starting with -1 to mimic max heap behaviour for negative values\\n        pq = [[-1, start]]\\n        visited = set()\\n\\n        while pq:\\n            prob, node = heappop(pq)\\n            if node in visited:\\n                continue\\n            visited.add(node)\\n            if node == end:\\n                return -prob  # maximum probability , don\\'t forget the - here !        \\n            for adj_node, path_prob in graph.get(node, []):\\n                heappush(pq, [prob * path_prob, adj_node]) \\n        return 0 # end node not found\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:       \\n        # build graph\\n        graph = defaultdict(list)\\n        for (u,v), probability in zip(edges, succProb):\\n            graph[u].append([v, probability])\\n            graph[v].append([u, probability])\\n\\n        # initialize priority queue, starting with -1 to mimic max heap behaviour for negative values\\n        pq = [[-1, start]]\\n        visited = set()\\n\\n        while pq:\\n            prob, node = heappop(pq)\\n            if node in visited:\\n                continue\\n            visited.add(node)\\n            if node == end:\\n                return -prob  # maximum probability , don\\'t forget the - here !        \\n            for adj_node, path_prob in graph.get(node, []):\\n                heappush(pq, [prob * path_prob, adj_node]) \\n        return 0 # end node not found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690848,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn max_probability(n: i32, edges: Vec<Vec<i32>>, succ_prob: Vec<f64>, start: i32, end: i32) -> f64 {\\n        use std::collections::VecDeque;\\n\\n        let mut probs = vec![0.; n as usize];\\n\\n        let mut G = vec![vec![]; n as usize];\\n        for (edge, p) in edges.into_iter().zip(succ_prob.into_iter()) {\\n            G[edge[0] as usize].push((edge[1] as usize, p));\\n            G[edge[1] as usize].push((edge[0] as usize, p));\\n        }\\n\\n        let mut queue = VecDeque::new();\\n        queue.push_back((start as usize, 1.));\\n        probs[start as usize] = 1.;\\n        \\n        while let Some((i, p)) = queue.pop_front() {\\n            if p < probs[i] {\\n                continue;\\n            }\\n\\n            for &(j, prob) in &G[i] {\\n                if p * prob > probs[j] {\\n                    queue.push_back((j, p * prob));\\n                    probs[j] = p * prob;\\n                }\\n            }\\n        }\\n\\n        probs[end as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_probability(n: i32, edges: Vec<Vec<i32>>, succ_prob: Vec<f64>, start: i32, end: i32) -> f64 {\\n        use std::collections::VecDeque;\\n\\n        let mut probs = vec![0.; n as usize];\\n\\n        let mut G = vec![vec![]; n as usize];\\n        for (edge, p) in edges.into_iter().zip(succ_prob.into_iter()) {\\n            G[edge[0] as usize].push((edge[1] as usize, p));\\n            G[edge[1] as usize].push((edge[0] as usize, p));\\n        }\\n\\n        let mut queue = VecDeque::new();\\n        queue.push_back((start as usize, 1.));\\n        probs[start as usize] = 1.;\\n        \\n        while let Some((i, p)) = queue.pop_front() {\\n            if p < probs[i] {\\n                continue;\\n            }\\n\\n            for &(j, prob) in &G[i] {\\n                if p * prob > probs[j] {\\n                    queue.push_back((j, p * prob));\\n                    probs[j] = p * prob;\\n                }\\n            }\\n        }\\n\\n        probs[end as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476867,
                "title": "golang-dijkstra-priorityqueue",
                "content": "```\\ntype Vertex struct {\\n    node int\\n    probFromStart float64\\n}\\ntype Edge struct {\\n    destNode int\\n    prob float64\\n}\\n\\ntype PriorityQueue []*Vertex\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i].probFromStart > pq[j].probFromStart }\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i]\\n}\\nfunc (pq *PriorityQueue) Push(x any) {\\n    *pq = append(*pq, x.(*Vertex))\\n}\\nfunc (pq *PriorityQueue) Pop() any {\\n    n := len(*pq)\\n    vertex := (*pq)[n-1]\\n    *pq = (*pq)[:n-1]\\n    return vertex\\n}\\n\\nfunc maxProbability(n int, edges [][]int, succProb []float64, start int, end int) float64 {\\n    edgesFrom := make([][]Edge, n)\\n    for u := range edgesFrom { edgesFrom[u] = []Edge{} }\\n    for i := range edges {\\n        u, v, w := edges[i][0], edges[i][1], succProb[i]\\n        if w == 0 { continue }\\n        edgesFrom[u] = append(edgesFrom[u], Edge{v, w})\\n        edgesFrom[v] = append(edgesFrom[v], Edge{u, w})\\n    }\\n\\n    visited := make([]bool, n)  // initially all false\\n    maxProbFromStart := make([]float64, n)  // initially all 0\\n    pq := PriorityQueue{&Vertex{start, 1}}\\n\\n    for pq.Len() > 0 {\\n        vertex := heap.Pop(&pq).(*Vertex)\\n\\n        if vertex.node == end { return vertex.probFromStart }\\n\\n        if visited[vertex.node] { continue }\\n        visited[vertex.node] = true\\n\\n        for _, e := range edgesFrom[vertex.node] {\\n            if visited[e.destNode] { continue }\\n            newProbFromStart := vertex.probFromStart * e.prob\\n            if newProbFromStart <= maxProbFromStart[e.destNode] { continue }\\n            maxProbFromStart[e.destNode] = newProbFromStart\\n            heap.Push(&pq, &Vertex{e.destNode, newProbFromStart})\\n        }\\n    }\\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype Vertex struct {\\n    node int\\n    probFromStart float64\\n}\\ntype Edge struct {\\n    destNode int\\n    prob float64\\n}\\n\\ntype PriorityQueue []*Vertex\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i].probFromStart > pq[j].probFromStart }\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i]\\n}\\nfunc (pq *PriorityQueue) Push(x any) {\\n    *pq = append(*pq, x.(*Vertex))\\n}\\nfunc (pq *PriorityQueue) Pop() any {\\n    n := len(*pq)\\n    vertex := (*pq)[n-1]\\n    *pq = (*pq)[:n-1]\\n    return vertex\\n}\\n\\nfunc maxProbability(n int, edges [][]int, succProb []float64, start int, end int) float64 {\\n    edgesFrom := make([][]Edge, n)\\n    for u := range edgesFrom { edgesFrom[u] = []Edge{} }\\n    for i := range edges {\\n        u, v, w := edges[i][0], edges[i][1], succProb[i]\\n        if w == 0 { continue }\\n        edgesFrom[u] = append(edgesFrom[u], Edge{v, w})\\n        edgesFrom[v] = append(edgesFrom[v], Edge{u, w})\\n    }\\n\\n    visited := make([]bool, n)  // initially all false\\n    maxProbFromStart := make([]float64, n)  // initially all 0\\n    pq := PriorityQueue{&Vertex{start, 1}}\\n\\n    for pq.Len() > 0 {\\n        vertex := heap.Pop(&pq).(*Vertex)\\n\\n        if vertex.node == end { return vertex.probFromStart }\\n\\n        if visited[vertex.node] { continue }\\n        visited[vertex.node] = true\\n\\n        for _, e := range edgesFrom[vertex.node] {\\n            if visited[e.destNode] { continue }\\n            newProbFromStart := vertex.probFromStart * e.prob\\n            if newProbFromStart <= maxProbFromStart[e.destNode] { continue }\\n            maxProbFromStart[e.destNode] = newProbFromStart\\n            heap.Push(&pq, &Vertex{e.destNode, newProbFromStart})\\n        }\\n    }\\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272566,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        var visited = new bool[n];\\n        var profit = new double[n];\\n        var pq = new PriorityQueue<int, double>();\\n        var graph = new Dictionary<int, Dictionary<int, double>>();\\n\\n        pq.Enqueue(start, 0);\\n        profit[start] = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            profit[start] = 0;\\n\\n        for(int i = 0; i < succProb.Length; i++) {\\n            if(!graph.ContainsKey(edges[i][0]))\\n                graph[edges[i][0]] = new Dictionary<int, double>();\\n            if(!graph.ContainsKey(edges[i][1]))\\n                graph[edges[i][1]] = new Dictionary<int, double>();\\n            graph[edges[i][0]][edges[i][1]] = succProb[i];\\n            graph[edges[i][1]][edges[i][0]] = succProb[i];\\n        }\\n        \\n        while(pq.Count > 0) {\\n            var node = pq.Dequeue();\\n            if(visited[node])\\n                continue;\\n            \\n            visited[node] = true;\\n\\n            if(graph.ContainsKey(node)) {\\n                foreach(var vertex in graph[node]) {\\n                    var temp = (profit[node] == 0 ? 1 : profit[node]) * vertex.Value;\\n                    if(!visited[vertex.Key] && temp > profit[vertex.Key]) {\\n                        profit[vertex.Key] = temp;\\n                        pq.Enqueue(vertex.Key, -temp);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return profit[end];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    public double MaxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        var visited = new bool[n];\\n        var profit = new double[n];\\n        var pq = new PriorityQueue<int, double>();\\n        var graph = new Dictionary<int, Dictionary<int, double>>();\\n\\n        pq.Enqueue(start, 0);\\n        profit[start] = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            profit[start] = 0;\\n\\n        for(int i = 0; i < succProb.Length; i++) {\\n            if(!graph.ContainsKey(edges[i][0]))\\n                graph[edges[i][0]] = new Dictionary<int, double>();\\n            if(!graph.ContainsKey(edges[i][1]))\\n                graph[edges[i][1]] = new Dictionary<int, double>();\\n            graph[edges[i][0]][edges[i][1]] = succProb[i];\\n            graph[edges[i][1]][edges[i][0]] = succProb[i];\\n        }\\n        \\n        while(pq.Count > 0) {\\n            var node = pq.Dequeue();\\n            if(visited[node])\\n                continue;\\n            \\n            visited[node] = true;\\n\\n            if(graph.ContainsKey(node)) {\\n                foreach(var vertex in graph[node]) {\\n                    var temp = (profit[node] == 0 ? 1 : profit[node]) * vertex.Value;\\n                    if(!visited[vertex.Key] && temp > profit[vertex.Key]) {\\n                        profit[vertex.Key] = temp;\\n                        pq.Enqueue(vertex.Key, -temp);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return profit[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172507,
                "title": "using-djikstras-and-also-why-using-priorityqueue-will-give-tle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the Djikstra\\'s Algorithm in a max-heap concept\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar to Djikstra\\'s. \\n**But a point to note is using priorityQueue will give TLE due to the extra logarithminc factor in getting the max element out**\\n\\n# Complexity\\n- Time complexity: O(n* m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    double second;\\n    public Pair(int first,double second){\\n        this.first = first;\\n        this.second =second;\\n    }\\n}\\nclass Solution {\\n    \\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        List<List<Pair>> adjList = new ArrayList<>();\\n        for(int i =0;i<n;i++){\\n            adjList.add(new ArrayList<>());\\n        }\\n        int m = edges.length;\\n        for(int i = 0;i<m;i++){\\n            adjList.get(edges[i][0]).add(new Pair(edges[i][1],succProb[i]));\\n            adjList.get(edges[i][1]).add(new Pair(edges[i][0],succProb[i]));\\n        }\\n        double[] probArr = new double[n];\\n        Arrays.fill(probArr,Double.MIN_VALUE);\\n        probArr[start] = 1;//reaching the start is proabability 1\\n        //max-heap\\n        //(a,b) ->(int)b.second -(int)a.second\\n        Queue<Pair> pq = new LinkedList<>();\\n        pq.offer(new Pair(start,1));\\n        while(!pq.isEmpty()){\\n            int node = pq.peek().first;\\n            double prob = pq.peek().second;\\n            pq.poll();\\n            for(Pair adj: adjList.get(node)){\\n                int adjNode = adj.first;\\n                double currProb = adj.second;\\n                double probIfPathTaken = prob * currProb;\\n                if(probIfPathTaken > probArr[adjNode]){\\n                    probArr[adjNode] = probIfPathTaken;\\n                    pq.offer(new Pair(adjNode,probIfPathTaken));\\n                }\\n            }\\n        }\\n        return probArr[end] == Integer.MIN_VALUE?-0:probArr[end];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    double second;\\n    public Pair(int first,double second){\\n        this.first = first;\\n        this.second =second;\\n    }\\n}\\nclass Solution {\\n    \\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        List<List<Pair>> adjList = new ArrayList<>();\\n        for(int i =0;i<n;i++){\\n            adjList.add(new ArrayList<>());\\n        }\\n        int m = edges.length;\\n        for(int i = 0;i<m;i++){\\n            adjList.get(edges[i][0]).add(new Pair(edges[i][1],succProb[i]));\\n            adjList.get(edges[i][1]).add(new Pair(edges[i][0],succProb[i]));\\n        }\\n        double[] probArr = new double[n];\\n        Arrays.fill(probArr,Double.MIN_VALUE);\\n        probArr[start] = 1;//reaching the start is proabability 1\\n        //max-heap\\n        //(a,b) ->(int)b.second -(int)a.second\\n        Queue<Pair> pq = new LinkedList<>();\\n        pq.offer(new Pair(start,1));\\n        while(!pq.isEmpty()){\\n            int node = pq.peek().first;\\n            double prob = pq.peek().second;\\n            pq.poll();\\n            for(Pair adj: adjList.get(node)){\\n                int adjNode = adj.first;\\n                double currProb = adj.second;\\n                double probIfPathTaken = prob * currProb;\\n                if(probIfPathTaken > probArr[adjNode]){\\n                    probArr[adjNode] = probIfPathTaken;\\n                    pq.offer(new Pair(adjNode,probIfPathTaken));\\n                }\\n            }\\n        }\\n        return probArr[end] == Integer.MIN_VALUE?-0:probArr[end];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110864,
                "title": "python-solution-dijkstra-s-algorithm-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind this problem is to find the maximum probability of getting from one node to another. \\nTo do this, we can use Dijkstra\\'s algorithm, which is an algorithm for finding the shortest path between two nodes in a graph. Dijkstra\\'s algorithm works by exploring all the possible paths from a given source node to a given destination node, and then selecting the path with the maximum probability. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use Dijkstra\\'s algorithm. First, we create a graph from the input edges and the given probabilities. Then, we use Dijkstra\\'s algorithm to find the maximum probability of getting from the start node to the end node. \\n# Complexity\\n- Time complexity: $$O(|E| + |V|log|V|)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere $$|E|$$ is the number of edges in the graph and $$|V|$$ is the number of nodes in the graph. \\n- Space complexity: $$O(|V|)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere $$|V|$$ is the number of nodes in the graph. This is because we need to store the graph as well as\\n# Code\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        # Create graph\\n        g = collections.defaultdict(dict)\\n        for i, (u, v) in enumerate(edges):\\n            g[u][v] = succProb[i]\\n            g[v][u] = succProb[i]\\n        # Dijkstra\\n        visited = set()\\n        q = [(-1, start)]\\n        while q:\\n            p, node = heapq.heappop(q)\\n            if node in visited:\\n                continue\\n            if node == end:\\n                return -p\\n            visited.add(node)\\n            for nei in g[node]:\\n                heapq.heappush(q, (p*g[node][nei], nei))\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        # Create graph\\n        g = collections.defaultdict(dict)\\n        for i, (u, v) in enumerate(edges):\\n            g[u][v] = succProb[i]\\n            g[v][u] = succProb[i]\\n        # Dijkstra\\n        visited = set()\\n        q = [(-1, start)]\\n        while q:\\n            p, node = heapq.heappop(q)\\n            if node in visited:\\n                continue\\n            if node == end:\\n                return -p\\n            visited.add(node)\\n            for nei in g[node]:\\n                heapq.heappush(q, (p*g[node][nei], nei))\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943083,
                "title": "c-bfs-dijkstra-algorithm-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        double ans=0;\\n        priority_queue<pair<double, int>>q;\\n        q.push({1, start});\\n        vector<pair<int, double>>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        vector<double>v(n, 0);\\n        v[start]=1;\\n        while(!q.empty()){\\n            int pos=q.top().second;\\n            double cnt=q.top().first;\\n            q.pop();\\n            if(pos==end){ans=max(ans, cnt);}\\n            for(auto it: adj[pos]){\\n                if(cnt*it.second>v[it.first]){\\n                    v[it.first]=(double)cnt*it.second;\\n                    q.push({v[it.first], it.first});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        double ans=0;\\n        priority_queue<pair<double, int>>q;\\n        q.push({1, start});\\n        vector<pair<int, double>>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        vector<double>v(n, 0);\\n        v[start]=1;\\n        while(!q.empty()){\\n            int pos=q.top().second;\\n            double cnt=q.top().first;\\n            q.pop();\\n            if(pos==end){ans=max(ans, cnt);}\\n            for(auto it: adj[pos]){\\n                if(cnt*it.second>v[it.first]){\\n                    v[it.first]=(double)cnt*it.second;\\n                    q.push({v[it.first], it.first});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781469,
                "title": "max-heap-dijkstra-s-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int, double>> adj[n];\\n        for(int i=0; i<edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        vector<double> d(n, 0);\\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1, start});\\n\\n        while(pq.size()) {\\n            double dis = pq.top().first;\\n            int node = pq.top().second; pq.pop();\\n\\n            if(node == end) return dis;\\n\\n            for(auto ad : adj[node]) {\\n                if(dis * ad.second > d[ad.first]) d[ad.first] = dis * ad.second, pq.push({d[ad.first], ad.first});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int, double>> adj[n];\\n        for(int i=0; i<edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        vector<double> d(n, 0);\\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1, start});\\n\\n        while(pq.size()) {\\n            double dis = pq.top().first;\\n            int node = pq.top().second; pq.pop();\\n\\n            if(node == end) return dis;\\n\\n            for(auto ad : adj[node]) {\\n                if(dis * ad.second > d[ad.first]) d[ad.first] = dis * ad.second, pq.push({d[ad.first], ad.first});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777824,
                "title": "simple-c-solution-bfs-memo",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void bfs(vector<pair<int,double>>adj[],int start,vector<double>&prob){\\n        queue<int>q;\\n        q.push(start);\\n        while(!q.empty()){\\n            int qf = q.front();\\n            q.pop();\\n\\n            for(auto it : adj[qf]){\\n                int u = it.first;\\n                double p = it.second;\\n\\n                if(prob[u] < p*prob[qf]){\\n                    prob[u] = p*prob[qf];\\n                    q.push(u);\\n                }\\n            }\\n        }\\n    }\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back({v,succProb[i]});\\n            adj[v].push_back({u,succProb[i]});\\n        }\\n\\n        vector<double>prob(n,0);\\n        prob[start] = 1;\\n        bfs(adj,start,prob);\\n        return prob[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void bfs(vector<pair<int,double>>adj[],int start,vector<double>&prob){\\n        queue<int>q;\\n        q.push(start);\\n        while(!q.empty()){\\n            int qf = q.front();\\n            q.pop();\\n\\n            for(auto it : adj[qf]){\\n                int u = it.first;\\n                double p = it.second;\\n\\n                if(prob[u] < p*prob[qf]){\\n                    prob[u] = p*prob[qf];\\n                    q.push(u);\\n                }\\n            }\\n        }\\n    }\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back({v,succProb[i]});\\n            adj[v].push_back({u,succProb[i]});\\n        }\\n\\n        vector<double>prob(n,0);\\n        prob[start] = 1;\\n        bfs(adj,start,prob);\\n        return prob[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661225,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    double dijikstra(int n,vector<pair<int,double>> g[],int start,int end){\\n        vector<bool> vis(n+1,false);\\n        vector<double> probabilities(n+1,-1);\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0,start});\\n        probabilities[start] = 1.0;\\n        while(!pq.empty()){\\n          auto node = pq.top();\\n          double prob = node.first;\\n          int vertex = node.second;\\n          pq.pop();\\n          if(vis[end]) break;\\n          if(vis[vertex]) continue;\\n          vis[vertex] = true;\\n          for(auto child: g[vertex]){\\n             double curr_prob = child.second;\\n             int curr_vertex = child.first;\\n             if(probabilities[curr_vertex] < probabilities[vertex] * curr_prob){\\n                probabilities[curr_vertex] = probabilities[vertex] * curr_prob;\\n                pq.push({probabilities[curr_vertex],curr_vertex});\\n             }\\n          }\\n        }\\n        return probabilities[end]==-1?0:probabilities[end];\\n    }\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>> g[2*n+1];\\n        for(int i=0; i<edges.size(); ++i){\\n          g[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n          g[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        return dijikstra(n,g,start,end);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    double dijikstra(int n,vector<pair<int,double>> g[],int start,int end){\\n        vector<bool> vis(n+1,false);\\n        vector<double> probabilities(n+1,-1);\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0,start});\\n        probabilities[start] = 1.0;\\n        while(!pq.empty()){\\n          auto node = pq.top();\\n          double prob = node.first;\\n          int vertex = node.second;\\n          pq.pop();\\n          if(vis[end]) break;\\n          if(vis[vertex]) continue;\\n          vis[vertex] = true;\\n          for(auto child: g[vertex]){\\n             double curr_prob = child.second;\\n             int curr_vertex = child.first;\\n             if(probabilities[curr_vertex] < probabilities[vertex] * curr_prob){\\n                probabilities[curr_vertex] = probabilities[vertex] * curr_prob;\\n                pq.push({probabilities[curr_vertex],curr_vertex});\\n             }\\n          }\\n        }\\n        return probabilities[end]==-1?0:probabilities[end];\\n    }\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>> g[2*n+1];\\n        for(int i=0; i<edges.size(); ++i){\\n          g[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n          g[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        return dijikstra(n,g,start,end);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600888,
                "title": "c-dijkstras-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& ed, vector<double>& suc, int start, int end) {\\n        vector<vector<pair<int,double>>>adj(n);\\n        for(int i=0;i<ed.size();i++)\\n        {\\n            int u=ed[i][0];\\n            int v=ed[i][1];\\n            double p=suc[i];\\n            adj[u].push_back({v,p});\\n            adj[v].push_back({u,p});\\n        }\\n        vector<double>pro(n,0);\\n        pro[start]=1;\\n        set<pair<double,int>>st;\\n        st.insert({pro[start],start});\\n        pair<double,int>p;\\n        while(!st.empty())\\n        {\\n            double src_pro=0;\\n            int src=-1;\\n            p=*(st.rbegin());\\n            src_pro=p.first;\\n            src=p.second;\\n            st.erase(p);\\n            for(auto it:adj[src])\\n            {\\n                double curr_pro=it.second;\\n                int curr=it.first;\\n                if((curr_pro*src_pro)>pro[curr])\\n                {\\n                    if(st.find({pro[curr],curr})==st.end())\\n                    {\\n                        st.insert({curr_pro*src_pro,curr});\\n                        pro[curr]=curr_pro*src_pro;\\n                    }\\n                    else\\n                    {\\n                        st.erase({pro[curr],curr});\\n                        st.insert({curr_pro*src_pro,curr});\\n                        pro[curr]=curr_pro*src_pro;\\n                    }\\n                }\\n            }\\n        }\\n        return pro[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& ed, vector<double>& suc, int start, int end) {\\n        vector<vector<pair<int,double>>>adj(n);\\n        for(int i=0;i<ed.size();i++)\\n        {\\n            int u=ed[i][0];\\n            int v=ed[i][1];\\n            double p=suc[i];\\n            adj[u].push_back({v,p});\\n            adj[v].push_back({u,p});\\n        }\\n        vector<double>pro(n,0);\\n        pro[start]=1;\\n        set<pair<double,int>>st;\\n        st.insert({pro[start],start});\\n        pair<double,int>p;\\n        while(!st.empty())\\n        {\\n            double src_pro=0;\\n            int src=-1;\\n            p=*(st.rbegin());\\n            src_pro=p.first;\\n            src=p.second;\\n            st.erase(p);\\n            for(auto it:adj[src])\\n            {\\n                double curr_pro=it.second;\\n                int curr=it.first;\\n                if((curr_pro*src_pro)>pro[curr])\\n                {\\n                    if(st.find({pro[curr],curr})==st.end())\\n                    {\\n                        st.insert({curr_pro*src_pro,curr});\\n                        pro[curr]=curr_pro*src_pro;\\n                    }\\n                    else\\n                    {\\n                        st.erase({pro[curr],curr});\\n                        st.insert({curr_pro*src_pro,curr});\\n                        pro[curr]=curr_pro*src_pro;\\n                    }\\n                }\\n            }\\n        }\\n        return pro[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600886,
                "title": "c-dijkstras-algorithm-set-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succ, int start, int end) \\n{\\n    unordered_map<int,vector<pair<int,double>>>mp;   //u ---  (v,w)\\n    vector<double>prob(n,0);\\n    \\n    for(int i=0;i<edges.size();i++)\\n    {\\n    \\tint u=edges[i][0];\\n    \\tint v=edges[i][1];\\n    \\tdouble w=succ[i];\\n    \\t\\n    \\tmp[u].push_back(make_pair(v,w));\\n    \\tmp[v].push_back(make_pair(u,w));\\n\\t}\\n\\t\\n\\tset<pair<double,int>>st;   // distance , node\\n\\t//we will push the start with its node distance \\n\\tst.insert(make_pair(1,start));\\n\\tprob[start]=1;\\n\\t\\n\\n\\twhile(!st.empty())\\n\\t{\\n       auto it=(st.rbegin());\\n       auto p=*(it);\\n        \\n       double currnode_prob=p.first;\\n       int currnode=p.second;\\n        \\n       st.erase(p);\\n       \\n       for(auto x : mp[currnode])  //this will retrun pair\\n       {\\n          if((currnode_prob*x.second)>prob[x.first])\\n\\t\\t  {\\n\\t\\t\\t if(st.find(make_pair(prob[x.first],x.first))!=st.end())\\n\\t\\t\\t {\\n\\t\\t\\t    st.erase(st.find(make_pair(prob[x.first],x.first)));\\t\\n\\t\\t     }\\t\\n\\t\\t     prob[x.first]=(currnode_prob*x.second);\\n\\t\\t     st.insert(make_pair(prob[x.first],x.first));\\n\\t      }\\t  \\n\\t   }\\n\\t}    \\n\\treturn prob[end];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Graph",
                    "Ordered Set",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succ, int start, int end) \\n{\\n    unordered_map<int,vector<pair<int,double>>>mp;   //u ---  (v,w)\\n    vector<double>prob(n,0);\\n    \\n    for(int i=0;i<edges.size();i++)\\n    {\\n    \\tint u=edges[i][0];\\n    \\tint v=edges[i][1];\\n    \\tdouble w=succ[i];\\n    \\t\\n    \\tmp[u].push_back(make_pair(v,w));\\n    \\tmp[v].push_back(make_pair(u,w));\\n\\t}\\n\\t\\n\\tset<pair<double,int>>st;   // distance , node\\n\\t//we will push the start with its node distance \\n\\tst.insert(make_pair(1,start));\\n\\tprob[start]=1;\\n\\t\\n\\n\\twhile(!st.empty())\\n\\t{\\n       auto it=(st.rbegin());\\n       auto p=*(it);\\n        \\n       double currnode_prob=p.first;\\n       int currnode=p.second;\\n        \\n       st.erase(p);\\n       \\n       for(auto x : mp[currnode])  //this will retrun pair\\n       {\\n          if((currnode_prob*x.second)>prob[x.first])\\n\\t\\t  {\\n\\t\\t\\t if(st.find(make_pair(prob[x.first],x.first))!=st.end())\\n\\t\\t\\t {\\n\\t\\t\\t    st.erase(st.find(make_pair(prob[x.first],x.first)));\\t\\n\\t\\t     }\\t\\n\\t\\t     prob[x.first]=(currnode_prob*x.second);\\n\\t\\t     st.insert(make_pair(prob[x.first],x.first));\\n\\t      }\\t  \\n\\t   }\\n\\t}    \\n\\treturn prob[end];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508729,
                "title": "1514-python-explanation",
                "content": "# Idea: Construct a graph where each node is connected to its adjacent node with corresponding weight\\n# use dijkstras algorithm, But here it is maximum what is required so take the negative of probability and apply same dijkstras algorithm\\n# start from start node assign its probability as -1\\n# pop least value of probability (since probability  is  stored as negative max probability will be poped)\\n# assign that probability as permanent probability and check its adjacent nodes, if they are not visited append those node with probability = probability[prevnode] * probaility of that edge\\n# continue this while stack is not empty\\n# So we will be left with -(max probaility) in the list\\n# return - probability of end\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n\\t\\t\\tgraph = defaultdict(list)\\n\\n\\t\\t\\tfor idx, (i,j) in enumerate(edges):\\n\\t\\t\\t\\tgraph[i].append((j,succProb[idx]))\\n\\t\\t\\t\\tgraph[j].append((i,succProb[idx]))\\n\\n\\n\\t\\t\\tstack = [(-1,start)]\\n\\t\\t\\tvisit = set([start])\\n\\t\\t\\tprobability = [0]*n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tprob,a= heapq.heappop(stack)\\n\\t\\t\\t\\tif probability[a] != 0:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tprobability[a] = prob\\n\\n\\t\\t\\t\\tfor v,p in graph[a]:\\n\\t\\t\\t\\t\\tif probability[v] == 0:\\n\\t\\t\\t\\t\\t\\tvisit.add(v)\\n\\t\\t\\t\\t\\t\\theapq.heappush(stack,(prob*p,v))\\n\\n\\t\\t\\treturn - probability[end]",
                "solutionTags": [
                    "Python"
                ],
                "code": "# Idea: Construct a graph where each node is connected to its adjacent node with corresponding weight\\n# use dijkstras algorithm, But here it is maximum what is required so take the negative of probability and apply same dijkstras algorithm\\n# start from start node assign its probability as -1\\n# pop least value of probability (since probability  is  stored as negative max probability will be poped)\\n# assign that probability as permanent probability and check its adjacent nodes, if they are not visited append those node with probability = probability[prevnode] * probaility of that edge\\n# continue this while stack is not empty\\n# So we will be left with -(max probaility) in the list\\n# return - probability of end\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n\\t\\t\\tgraph = defaultdict(list)\\n\\n\\t\\t\\tfor idx, (i,j) in enumerate(edges):\\n\\t\\t\\t\\tgraph[i].append((j,succProb[idx]))\\n\\t\\t\\t\\tgraph[j].append((i,succProb[idx]))\\n\\n\\n\\t\\t\\tstack = [(-1,start)]\\n\\t\\t\\tvisit = set([start])\\n\\t\\t\\tprobability = [0]*n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tprob,a= heapq.heappop(stack)\\n\\t\\t\\t\\tif probability[a] != 0:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tprobability[a] = prob\\n\\n\\t\\t\\t\\tfor v,p in graph[a]:\\n\\t\\t\\t\\t\\tif probability[v] == 0:\\n\\t\\t\\t\\t\\t\\tvisit.add(v)\\n\\t\\t\\t\\t\\t\\theapq.heappush(stack,(prob*p,v))\\n\\n\\t\\t\\treturn - probability[end]",
                "codeTag": "Java"
            },
            {
                "id": 2440627,
                "title": "java-dijkstra-algorithm",
                "content": "import java.util.*;\\nclass pair{\\n    int key;\\n    double value;\\n    \\n    public pair(int key,double value){\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey(){return key;}\\n    public double getValue(){return value;}\\n}\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        \\n        ArrayList<ArrayList<pair>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++) adj.add(new ArrayList<>());\\n        \\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(new pair(edges[i][1],succProb[i]));\\n            adj.get(edges[i][1]).add(new pair(edges[i][0],succProb[i]));\\n        }\\n        \\n        double prob[] = new double[n];\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b)->{\\n            if(b.getValue()>a.getValue()){\\n                return 1;\\n            }\\n            return -1;\\n            \\n        });\\n        Arrays.fill(prob,0);\\n        prob[start]=1;\\n        pq.offer(new pair(start,1));\\n        \\n        while(!pq.isEmpty()){\\n            int u = pq.poll().getKey();\\n            \\n            for(pair p :adj.get(u)){\\n                int v = p.getKey();\\n                double cost = p.getValue();\\n                \\n                if(prob[v]==0){\\n                    prob[v] = prob[u]*cost;\\n                    pq.offer(new pair(v,prob[v]));\\n                }else{\\n                    if(prob[u]*cost>prob[v]){\\n                        prob[v] = prob[u]*cost;\\n                        pq.offer(new pair(v,prob[v]));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return prob[end];\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        \\n        ArrayList<ArrayList<pair>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++) adj.add(new ArrayList<>());\\n        \\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(new pair(edges[i][1],succProb[i]));\\n            adj.get(edges[i][1]).add(new pair(edges[i][0],succProb[i]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2278605,
                "title": "java-dijkstra",
                "content": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        \\n        for (int i = 0; i < n; ++i) \\n            graph.put(i, new ArrayList<>());\\n        \\n        for (int i = 0; i < edges.length; ++i) {\\n            int src = edges[i][0];\\n            int dest = edges[i][1];\\n            graph.get(src).add(new Pair(dest, succProb[i]));\\n            graph.get(dest).add(new Pair(src, succProb[i]));\\n        }\\n        \\n        PriorityQueue<Pair<Integer, Double>> maxHeap = new PriorityQueue<>((a, b) -> Double.compare(b.getValue(), a.getValue()));\\n        \\n        maxHeap.add(new Pair(start, 1.0));\\n        boolean[] visited = new boolean[n];\\n        double ans = 0.0;\\n        while(!maxHeap.isEmpty()) {\\n            Pair<Integer, Double> pair = maxHeap.poll();\\n            int src = pair.getKey();\\n            double cost = pair.getValue();\\n            if(visited[src]) {\\n                continue;\\n            }\\n            visited[src] = true;\\n            if(src == end) {\\n                return cost;\\n            }\\n            List<Pair<Integer, Double>> nbrs = graph.get(src);\\n            for(int i = 0; i < nbrs.size(); i++) {\\n                int nsrc = nbrs.get(i).getKey();\\n                double ncost= nbrs.get(i).getValue();\\n                if(!visited[nsrc]) {\\n                    maxHeap.add(new Pair(nsrc, cost * ncost));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        \\n        for (int i = 0; i < n; ++i) \\n            graph.put(i, new ArrayList<>());\\n        \\n        for (int i = 0; i < edges.length; ++i) {\\n            int src = edges[i][0];\\n            int dest = edges[i][1];\\n            graph.get(src).add(new Pair(dest, succProb[i]));\\n            graph.get(dest).add(new Pair(src, succProb[i]));\\n        }\\n        \\n        PriorityQueue<Pair<Integer, Double>> maxHeap = new PriorityQueue<>((a, b) -> Double.compare(b.getValue(), a.getValue()));\\n        \\n        maxHeap.add(new Pair(start, 1.0));\\n        boolean[] visited = new boolean[n];\\n        double ans = 0.0;\\n        while(!maxHeap.isEmpty()) {\\n            Pair<Integer, Double> pair = maxHeap.poll();\\n            int src = pair.getKey();\\n            double cost = pair.getValue();\\n            if(visited[src]) {\\n                continue;\\n            }\\n            visited[src] = true;\\n            if(src == end) {\\n                return cost;\\n            }\\n            List<Pair<Integer, Double>> nbrs = graph.get(src);\\n            for(int i = 0; i < nbrs.size(); i++) {\\n                int nsrc = nbrs.get(i).getKey();\\n                double ncost= nbrs.get(i).getValue();\\n                if(!visited[nsrc]) {\\n                    maxHeap.add(new Pair(nsrc, cost * ncost));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828908,
                "title": "c-modified-dijkstra-o-edges-log-n-max-heap-explained",
                "content": "**Modified Djikstra Approach:**\\nIn general djikstra algorithm, we find the shortest path from start to end and update the `minimum distance` array accordingly for each edge. In this problem we need to find something like longest path from start to end.\\nIn Traditional Dijkstra, we use Min Heap to maintain our queue. On the contrary, in this problem, we use Max heap.\\n\\nTime Complexity : `O(edges*log(n))`\\nSpace Complexity : `O(n)`\\n\\n**C++ Code:**\\n```\\nclass Solution {\\n    using pi = pair<double,int>;\\n    double BFS(int start, int end,vector<vector<pi>> &graph )  {\\n        vector<int> visited(graph.size(),0);\\n        priority_queue<pi> pq;\\n        pq.push({1.0,start});\\n        \\n        \\n        while(!pq.empty())  {\\n            int top = pq.top().second;\\n            double psf = pq.top().first;\\n            pq.pop();\\n            \\n            if(visited[top])\\n                continue;\\n            visited[top] = 1;\\n            if(top == end)  {\\n                return psf;\\n            }\\n            \\n            for(auto &e: graph[top])  {\\n                if(visited[e.second]==0)\\n                    pq.push({psf * e.first, e.second});\\n            }\\n        }\\n        return 0.0;\\n    }\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pi>> graph(n);\\n        \\n        for(int i=0; i<edges.size(); ++i)  {\\n            graph[edges[i][0]].push_back({succProb[i], edges[i][1]});\\n            graph[edges[i][1]].push_back({succProb[i], edges[i][0]});\\n        }\\n        \\n        double ans = BFS(start, end, graph);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\nPlease Upvote if my solution helped!\\nP.S.: Comment for any Clarification.\\nHave a great day ;)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    using pi = pair<double,int>;\\n    double BFS(int start, int end,vector<vector<pi>> &graph )  {\\n        vector<int> visited(graph.size(),0);\\n        priority_queue<pi> pq;\\n        pq.push({1.0,start});\\n        \\n        \\n        while(!pq.empty())  {\\n            int top = pq.top().second;\\n            double psf = pq.top().first;\\n            pq.pop();\\n            \\n            if(visited[top])\\n                continue;\\n            visited[top] = 1;\\n            if(top == end)  {\\n                return psf;\\n            }\\n            \\n            for(auto &e: graph[top])  {\\n                if(visited[e.second]==0)\\n                    pq.push({psf * e.first, e.second});\\n            }\\n        }\\n        return 0.0;\\n    }\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pi>> graph(n);\\n        \\n        for(int i=0; i<edges.size(); ++i)  {\\n            graph[edges[i][0]].push_back({succProb[i], edges[i][1]});\\n            graph[edges[i][1]].push_back({succProb[i], edges[i][0]});\\n        }\\n        \\n        double ans = BFS(start, end, graph);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725503,
                "title": "normal-queue-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<float,int>> adj[n];\\n        vector<bool> vis(n,false);\\n        int k=0;\\n        for(auto i:edges){\\n            adj[i[0]].push_back({succProb[k],i[1]});\\n            \\n            adj[i[1]].push_back({succProb[k],i[0]});\\n            k++;\\n        }\\n        \\n        \\n        \\n        priority_queue<pair<float,int>> pq;\\n        for(auto i:adj[start]){\\n            pq.push(i);\\n        }\\n        \\n        while(!pq.empty()){\\n            \\n            \\n            auto a=pq.top();\\n            vis[a.second]=true;\\n            if(a.second==end){\\n                return a.first;\\n            }\\n            pq.pop();\\n            for(auto i:adj[a.second]){\\n               \\n                if(vis[i.second]==false)\\n                    pq.push({a.first*i.first,i.second});\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<float,int>> adj[n];\\n        vector<bool> vis(n,false);\\n        int k=0;\\n        for(auto i:edges){\\n            adj[i[0]].push_back({succProb[k],i[1]}",
                "codeTag": "Java"
            },
            {
                "id": 1580787,
                "title": "c-most-basic-dijkstra-log-probability-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    //Approach\\n    /*\\n    1. modify the edge weights to -log(probability)\\n    2. problem reduces to find the sssp from source to destination\\n    3. use dijkstra to find the minimum distance (minDist) from src to dst\\n    4. return max probability = e^(-minDist)\\n    \\n    */\\n    \\n    int n;\\n    vector< vector< pair<int, double> > > adj; \\n    \\n    \\n    double dijkstra(int src, int des){\\n        vector<double> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        \\n        priority_queue<pair<double,int>, vector<pair<double,int>>, greater<pair<double,int>>> minheap;\\n        minheap.push({0,src});\\n        \\n        while(minheap.size()){\\n            auto [currDist, currNode] = minheap.top();\\n            minheap.pop();\\n            \\n            for(auto [adjNode, weight] : adj[currNode]){\\n                if(currDist + weight < dist[adjNode]){\\n                    dist[adjNode] = currDist + weight;\\n                    minheap.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        \\n        return dist[des];\\n    }\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        this->n = n;\\n        adj.resize(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            auto e = edges[i];\\n            int u = e[0];\\n            int v = e[1];\\n            double w = -1 * log(succProb[i]);  // NOTE 1\\n            \\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n            \\n        }\\n        \\n        int src = start;\\n        int dest = end;\\n        \\n        double minDist = dijkstra(start, end);\\n        \\n        if(minDist==INT_MAX) return 0;\\n        \\n        else return exp(-1*minDist);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //Approach\\n    /*\\n    1. modify the edge weights to -log(probability)\\n    2. problem reduces to find the sssp from source to destination\\n    3. use dijkstra to find the minimum distance (minDist) from src to dst\\n    4. return max probability = e^(-minDist)\\n    \\n    */\\n    \\n    int n;\\n    vector< vector< pair<int, double> > > adj; \\n    \\n    \\n    double dijkstra(int src, int des){\\n        vector<double> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        \\n        priority_queue<pair<double,int>, vector<pair<double,int>>, greater<pair<double,int>>> minheap;\\n        minheap.push({0,src});\\n        \\n        while(minheap.size()){\\n            auto [currDist, currNode] = minheap.top();\\n            minheap.pop();\\n            \\n            for(auto [adjNode, weight] : adj[currNode]){\\n                if(currDist + weight < dist[adjNode]){\\n                    dist[adjNode] = currDist + weight;\\n                    minheap.push({dist[adjNode],adjNode});\\n                }\\n            }\\n        }\\n        \\n        return dist[des];\\n    }\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        this->n = n;\\n        adj.resize(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            auto e = edges[i];\\n            int u = e[0];\\n            int v = e[1];\\n            double w = -1 * log(succProb[i]);  // NOTE 1\\n            \\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n            \\n        }\\n        \\n        int src = start;\\n        int dest = end;\\n        \\n        double minDist = dijkstra(start, end);\\n        \\n        if(minDist==INT_MAX) return 0;\\n        \\n        else return exp(-1*minDist);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540200,
                "title": "dijkastra-small-code-fast-and-simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> dist;\\n    vector<pair<int,double>> *adj;\\n    \\n    void dijkstra(int start,int end){\\n        set<pair<double,int>> s;\\n        s.insert({1.0,start});\\n      \\n        while(s.size()){\\n\\t\\t\\n            //picking node with largest weigth\\n            auto p = *prev(s.end());\\n            double nodeDist = p.first;\\n            int node = p.second;\\n            s.erase(prev(s.end()));\\n            \\n            for(auto nbr : adj[node]){\\n\\t\\t\\t//checking new distance of next node is greater then old distance\\n                if(nbr.second * nodeDist > dist[nbr.first]){\\n                    int dest = nbr.first;\\n                    auto f = s.find({dist[dest],dest});\\n                    if(f != s.end())\\n                        s.erase(f);\\n                    dist[dest] = nbr.second * nodeDist;\\n                    s.insert({dist[dest],dest});\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n    }\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        dist = vector<double> (n,INT_MIN);\\n        adj = new vector<pair<int,double>>[n];\\n        \\n\\t\\t//creating adj list of graph\\'s edge\\n        for(int i = 0 ; i <edges.size() ;i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        \\n        dijkstra( start, end);\\n        \\n\\t\\t//if there is no path from start to end then distance will be -infinity\\n        if(dist[end] == INT_MIN)\\n            return 0;\\n        return dist[end];\\n        \\n    }\\n \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> dist;\\n    vector<pair<int,double>> *adj;\\n    \\n    void dijkstra(int start,int end){\\n        set<pair<double,int>> s;\\n        s.insert({1.0,start});\\n      \\n        while(s.size()){\\n\\t\\t\\n            //picking node with largest weigth\\n            auto p = *prev(s.end());\\n            double nodeDist = p.first;\\n            int node = p.second;\\n            s.erase(prev(s.end()));\\n            \\n            for(auto nbr : adj[node]){\\n\\t\\t\\t//checking new distance of next node is greater then old distance\\n                if(nbr.second * nodeDist > dist[nbr.first]){\\n                    int dest = nbr.first;\\n                    auto f = s.find({dist[dest],dest});\\n                    if(f != s.end())\\n                        s.erase(f);\\n                    dist[dest] = nbr.second * nodeDist;\\n                    s.insert({dist[dest],dest});\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n    }\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        dist = vector<double> (n,INT_MIN);\\n        adj = new vector<pair<int,double>>[n];\\n        \\n\\t\\t//creating adj list of graph\\'s edge\\n        for(int i = 0 ; i <edges.size() ;i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        \\n        dijkstra( start, end);\\n        \\n\\t\\t//if there is no path from start to end then distance will be -infinity\\n        if(dist[end] == INT_MIN)\\n            return 0;\\n        return dist[end];\\n        \\n    }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218532,
                "title": "c-dijkstra-algorithm-modified-max-heap-clean",
                "content": "I have used dijkstra here because the probabilities are in range (0,1] and we know that we have reached the destination via the path with maximum probability then any other path would have lesser probability and this is ensured because when we multiply a number by a number smaller than 0 its value decreases so the maxheap picks up the max probability edge everytime and after that the endpoint of that edge never gets added back to the maxheap and this ensures that we only take the max prob path and all other paths are not explored which is exactly the case in dijkstra.\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<vector<pair<int,double>>> graph(n,vector<pair<int,double>>());\\n        \\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            graph[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        \\n        priority_queue<pair<double,int>> maxheap;\\n                \\n        double prob[n];\\n        \\n        for(int i=0;i<n;i++)\\n            prob[i]=(double)0.0;\\n        \\n        prob[start]=(double)1.0;\\n        \\n        maxheap.push({prob[start],start});\\n        \\n        while(!maxheap.empty()){\\n            \\n            auto p=maxheap.top();\\n            \\n            maxheap.pop();\\n                    \\n            for(auto i:graph[p.second]){\\n                if(prob[i.first]<prob[p.second]*i.second){\\n                    prob[i.first]=prob[p.second]*i.second;\\n                    maxheap.push({prob[i.first],i.first});\\n                }\\n            }\\n        }\\n        \\n        return prob[end];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<vector<pair<int,double>>> graph(n,vector<pair<int,double>>());\\n        \\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],succProb[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1174834,
                "title": "java-ezy-and-intuitive-dijkstra-s",
                "content": "class Solution {\\n\\n    public static class pair{\\n        int src;\\n        int dest;\\n        Double prob;\\n        pair(int src,int dest,Double prob)\\n        {\\n            this.src=src;\\n            this.dest=dest;\\n            this.prob=prob;\\n        } \\n    }\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        ArrayList<pair> graph[]=new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            graph[i]=new ArrayList<>();\\n        int index=0;\\n        for(int edge[]:edges)\\n        {\\n            int src=edge[0];\\n            int dest=edge[1];\\n            graph[src].add(new pair(src,dest,succProb[index]));\\n            graph[dest].add(new pair(dest,src,succProb[index]));\\n            index++;\\n        }\\n        \\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->{\\n            if(a.prob<=b.prob)\\n                return 1;\\n            return -1;\\n       \\n    });\\n        \\n        pq.add(new pair(start,start,1.0));\\n        int visited[]=new int[n];\\n        while(pq.size()>0)\\n        {\\n            pair p=pq.remove();\\n            if(p.dest==end)\\n                return p.prob;\\n            if(visited[p.dest]==0)\\n            {\\n                visited[p.dest]=1;   \\n                for(pair child:graph[p.dest])\\n                    pq.add(new pair(p.dest,child.dest,p.prob*child.prob));\\n            }\\n        }\\n     return 0;       \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public static class pair{\\n        int src;\\n        int dest;\\n        Double prob;\\n        pair(int src,int dest,Double prob)\\n        {\\n            this.src=src;\\n            this.dest=dest;\\n            this.prob=prob;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1032897,
                "title": "dijkstra-python-solution",
                "content": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        self.graph = dict()\\n        for i in range(n):\\n            self.graph[i] = []\\n            \\n        for idx, (u, v) in enumerate(edges):\\n            self.graph[u].append((v, succProb[idx]))\\n            self.graph[v].append((u, succProb[idx]))\\n        \\n        self.dist = [0] * n\\n        \\n        import heapq\\n        deque = list()\\n        heapq.heappush(deque, (-1, start, 1))\\n        \\n        visited = [False] * n\\n        \\n        while deque:\\n            _, x, old_wt = heapq.heappop(deque)\\n            visited[x] = True\\n            for neighbor, wt in self.graph[x]:\\n                if not visited[neighbor] and self.dist[neighbor] < old_wt * wt:\\n                    self.dist[neighbor] = old_wt * wt\\n                    heapq.heappush(deque, (-1 * self.dist[neighbor], neighbor, self.dist[neighbor]))\\n                    \\n        return self.dist[end]\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        self.graph = dict()\\n        for i in range(n):\\n            self.graph[i] = []\\n            \\n        for idx, (u, v) in enumerate(edges):\\n            self.graph[u].append((v, succProb[idx]))\\n            self.graph[v].append((u, succProb[idx]))\\n        \\n        self.dist = [0] * n\\n        \\n        import heapq\\n        deque = list()\\n        heapq.heappush(deque, (-1, start, 1))\\n        \\n        visited = [False] * n\\n        \\n        while deque:\\n            _, x, old_wt = heapq.heappop(deque)\\n            visited[x] = True\\n            for neighbor, wt in self.graph[x]:\\n                if not visited[neighbor] and self.dist[neighbor] < old_wt * wt:\\n                    self.dist[neighbor] = old_wt * wt\\n                    heapq.heappush(deque, (-1 * self.dist[neighbor], neighbor, self.dist[neighbor]))\\n                    \\n        return self.dist[end]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011001,
                "title": "python-simple-djikstra-s-and-bellman-ford-algorithm",
                "content": "```\\nclass Solution:\\n    # Djikstras\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        \\n        graph = defaultdict(list)\\n        for edge, prob in zip(edges, succProb):\\n            s, d = edge\\n            graph[s].append((d, prob))\\n            graph[d].append((s, prob))\\n        \\n        dist = {i: 0 for i in range(n)}\\n        dist[start] = 1\\n        heap = [(-1, start)]\\n        \\n        while heap:\\n            \\n            prob, node = heappop(heap)\\n            \\n            if node == end:\\n                return -prob\\n            \\n            for neigh, next_prob in graph[node]:\\n                if dist[neigh] < abs(next_prob * prob):\\n                    dist[neigh] = abs(next_prob * prob)            \\n                    heappush(heap, (-abs(next_prob * prob), neigh))\\n            \\n        return 0\\n    \\n    # Bellman-Ford\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = defaultdict(list)\\n        dist = [0] * n\\n        dist[start] = 1\\n        \\n        for i in range(n-1):\\n            for edge, prob in zip(edges, succProb):\\n                s, d = edge\\n                if dist[s] != 0 and dist[s] * prob > dist[d]:\\n                    dist[d] = dist[s] * prob\\n                if dist[d] != 0 and dist[d] * prob > dist[s]:\\n                    dist[s] = dist[d] * prob\\n        \\n        return dist[end]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Djikstras\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        \\n        graph = defaultdict(list)\\n        for edge, prob in zip(edges, succProb):\\n            s, d = edge\\n            graph[s].append((d, prob))\\n            graph[d].append((s, prob))\\n        \\n        dist = {i: 0 for i in range(n)}\\n        dist[start] = 1\\n        heap = [(-1, start)]\\n        \\n        while heap:\\n            \\n            prob, node = heappop(heap)\\n            \\n            if node == end:\\n                return -prob\\n            \\n            for neigh, next_prob in graph[node]:\\n                if dist[neigh] < abs(next_prob * prob):\\n                    dist[neigh] = abs(next_prob * prob)            \\n                    heappush(heap, (-abs(next_prob * prob), neigh))\\n            \\n        return 0\\n    \\n    # Bellman-Ford\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = defaultdict(list)\\n        dist = [0] * n\\n        dist[start] = 1\\n        \\n        for i in range(n-1):\\n            for edge, prob in zip(edges, succProb):\\n                s, d = edge\\n                if dist[s] != 0 and dist[s] * prob > dist[d]:\\n                    dist[d] = dist[s] * prob\\n                if dist[d] != 0 and dist[d] * prob > dist[s]:\\n                    dist[s] = dist[d] * prob\\n        \\n        return dist[end]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998475,
                "title": "simple-c-solution-dijkstra-algorithm",
                "content": "```\\n\\nclass Solution {\\npublic:\\ndouble maxProbability(int n,vector<vector<int>>&edges,vector<double>&succProb,int start,int end) {\\n    unordered_map<int, list < pair <int, double> > > m;\\n    unordered_map<int, double> dist;\\n    set <pair<double, int>> ss;\\n    \\n    for(int i = 0; i < edges.size(); i++)      \\n        m[edges[i][0]].push_back({edges[i][1], succProb[i]}),\\n        m[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n    \\n    for(int i = 0; i < n; i++) \\n        dist[i] = 0;\\n    \\n    ss.insert({1, start});\\n    \\n    while(!ss.empty()) {\\n        auto itr = ss.end();\\n        itr--;\\n        auto p = *(itr);\\n        ss.erase(itr);\\n\\n        double nodeDist = p.first;\\n        int node = p.second;\\n        \\n        for(auto childPair : m[node]) {\\n            if(nodeDist * (childPair.second) <= 1 &&\\n               nodeDist * (childPair.second) > dist[childPair.first]) {\\n                \\n                int dest = childPair.first;\\n                auto ff = ss.find({dist[dest], dest});\\n            \\n                if(ff != ss.end())\\n                    ss.erase(ff);\\n                \\n                dist[dest] = nodeDist * childPair.second;\\n                ss.insert({dist[dest], dest});\\n            }\\n        }\\n    } \\n    return dist[end];      \\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\ndouble maxProbability(int n,vector<vector<int>>&edges,vector<double>&succProb,int start,int end) {\\n    unordered_map<int, list < pair <int, double> > > m;\\n    unordered_map<int, double> dist;\\n    set <pair<double, int>> ss;\\n    \\n    for(int i = 0; i < edges.size(); i++)      \\n        m[edges[i][0]].push_back({edges[i][1], succProb[i]}),\\n        m[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n    \\n    for(int i = 0; i < n; i++) \\n        dist[i] = 0;\\n    \\n    ss.insert({1, start});\\n    \\n    while(!ss.empty()) {\\n        auto itr = ss.end();\\n        itr--;\\n        auto p = *(itr);\\n        ss.erase(itr);\\n\\n        double nodeDist = p.first;\\n        int node = p.second;\\n        \\n        for(auto childPair : m[node]) {\\n            if(nodeDist * (childPair.second) <= 1 &&\\n               nodeDist * (childPair.second) > dist[childPair.first]) {\\n                \\n                int dest = childPair.first;\\n                auto ff = ss.find({dist[dest], dest});\\n            \\n                if(ff != ss.end())\\n                    ss.erase(ff);\\n                \\n                dist[dest] = nodeDist * childPair.second;\\n                ss.insert({dist[dest], dest});\\n            }\\n        }\\n    } \\n    return dist[end];      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917112,
                "title": "cpp-dijkstras",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succprob, int start, int end) {\\n        vector<vector<pair<int , double>>> adjlist(n);\\n        \\n        for(int i = 0 ; i < edges.size() ; i++){\\n            adjlist[edges[i][0]].push_back({edges[i][1] , succprob[i]});\\n            adjlist[edges[i][1]].push_back({edges[i][0] , succprob[i]});\\n        }\\n        \\n        vector<double> prob(n , 0);\\n        prob[start] = 1;\\n        \\n        priority_queue<pair<int, double>, vector<pair<int, double>>, greater<pair<int , double>>> pq;\\n        pq.push({start , 1});\\n        \\n        while(!pq.empty()){\\n            auto p = pq.top();\\n            int a = p.first;\\n            double b = p.second;\\n            \\n            pq.pop();\\n            \\n            for(auto childpair : adjlist[a]){\\n                if(b*childpair.second > prob[childpair.first]){\\n                    int dest = childpair.first;\\n                    prob[dest] = b*childpair.second;\\n                    pq.push(make_pair(dest , prob[dest]));\\n                }\\n            }\\n        }\\n        \\n        return prob[end];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succprob, int start, int end) {\\n        vector<vector<pair<int , double>>> adjlist(n);\\n        \\n        for(int i = 0 ; i < edges.size() ; i++){\\n            adjlist[edges[i][0]].push_back({edges[i][1] , succprob[i]});\\n            adjlist[edges[i][1]].push_back({edges[i][0] , succprob[i]});\\n        }\\n        \\n        vector<double> prob(n , 0);\\n        prob[start] = 1;\\n        \\n        priority_queue<pair<int, double>, vector<pair<int, double>>, greater<pair<int , double>>> pq;\\n        pq.push({start , 1});\\n        \\n        while(!pq.empty()){\\n            auto p = pq.top();\\n            int a = p.first;\\n            double b = p.second;\\n            \\n            pq.pop();\\n            \\n            for(auto childpair : adjlist[a]){\\n                if(b*childpair.second > prob[childpair.first]){\\n                    int dest = childpair.first;\\n                    prob[dest] = b*childpair.second;\\n                    pq.push(make_pair(dest , prob[dest]));\\n                }\\n            }\\n        }\\n        \\n        return prob[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818701,
                "title": "java-dijkstra-template",
                "content": "This is a classic problem which we could apply Dijkstra algorithm to solve. \\nThe same as another classic problem: Network Delay Time. \\n\\nBoth of the two problems can use the following template to solve, very straightforward. \\n1. build graph (adjacent lists)\\n2. use PriorityQueue to BFS each vertex \\n\\n```\\n//build graph \\n        Map<Integer, Map<Integer, Double>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < edges.length; i++){\\n            int[] edge = edges[i];\\n            map.putIfAbsent( edge[0],  new HashMap<>() );\\n            map.get(edge[0]).put(edge[1], succProb[i]);\\n            map.putIfAbsent( edge[1],  new HashMap<>() );\\n            map.get(edge[1]).put(edge[0], succProb[i]);\\n            \\n        }\\n        \\n        PriorityQueue< Double[]> pq = new PriorityQueue< >( (a,b)->(b[0].compareTo(a[0])));\\n        \\n        pq.offer( new Double[] { 1.0, new Double(start) } );\\n        Set<Integer> set = new HashSet<>();\\n        \\n        while(!pq.isEmpty()){\\n            Double[ ] current = pq.poll();\\n            \\n            double possibility = current[0];\\n            int node = current[1].intValue();\\n            \\n            if(node == end)\\n                return possibility;\\n            \\n            if(set.contains(node))\\n                continue;\\n            \\n            set.add(node);\\n            \\n            if(map.containsKey(node)){\\n                for( int neighbour : map.get(node).keySet( )) {\\n                    pq.offer( new Double[] { map.get(node).get(neighbour) * possibility,  new Double(neighbour)});\\n                }\\n            }\\n        }\\n        \\n        return 0.0;\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n//build graph \\n        Map<Integer, Map<Integer, Double>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < edges.length; i++){\\n            int[] edge = edges[i];\\n            map.putIfAbsent( edge[0],  new HashMap<>() );\\n            map.get(edge[0]).put(edge[1], succProb[i]);\\n            map.putIfAbsent( edge[1],  new HashMap<>() );\\n            map.get(edge[1]).put(edge[0], succProb[i]);\\n            \\n        }\\n        \\n        PriorityQueue< Double[]> pq = new PriorityQueue< >( (a,b)->(b[0].compareTo(a[0])));\\n        \\n        pq.offer( new Double[] { 1.0, new Double(start) } );\\n        Set<Integer> set = new HashSet<>();\\n        \\n        while(!pq.isEmpty()){\\n            Double[ ] current = pq.poll();\\n            \\n            double possibility = current[0];\\n            int node = current[1].intValue();\\n            \\n            if(node == end)\\n                return possibility;\\n            \\n            if(set.contains(node))\\n                continue;\\n            \\n            set.add(node);\\n            \\n            if(map.containsKey(node)){\\n                for( int neighbour : map.get(node).keySet( )) {\\n                    pq.offer( new Double[] { map.get(node).get(neighbour) * possibility,  new Double(neighbour)});\\n                }\\n            }\\n        }\\n        \\n        return 0.0;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 740901,
                "title": "a-few-solutions",
                "content": "Use [Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) to relax all edges `N - 1` times.  Since this results in TLE, a natural progression from [Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) is [shortest path faster algorithm (SPFA)](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm), ie. simply enqueue `v` for each relaxed edge `u -> v`, thus improving the overall runtime by cherry picking the subsequent edges under consideration to be relaxed (rather than arbitrarily attempting to relax every edge via [Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)).\\n\\n---\\n\\n**`\\u2B50\\uFE0F` Solution #1:** [**Bellman-Ford**](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) (TLE)\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxProbability(N: Int, E: Array<IntArray>, A: DoubleArray, s: Int, t: Int): Double {\\n        var dist = DoubleArray(N) { 0.0 }\\n        dist[s] = 1.0\\n        for (i in 0 until N - 1) { // \\u2B50\\uFE0F relax edges N - 1 times\\n            E.forEachIndexed { i, (u, v) ->\\n                var w = A[i]\\n                if (dist[v] < dist[u] * w) dist[v] = dist[u] * w\\n                if (dist[u] < dist[v] * w) dist[u] = dist[v] * w\\n            }\\n        }\\n        return dist[t]\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxProbability = (N, E, A, s, t) => {\\n    let dist = Array(N).fill(0)\\n    dist[s] = 1;\\n    while (0 < N--) { // \\u2B50\\uFE0F relax edges N - 1 times\\n        E.forEach(([u, v], i) => {\\n            let w = A[i];\\n            dist[u] = Math.max(dist[u], dist[v] * w);\\n            dist[v] = Math.max(dist[v], dist[u] * w);\\n        });\\n    }\\n    return dist[t];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxProbability(self, N: int, E: List[List[int]], A: List[float], s: int, t: int) -> float:\\n        dist = [0] * N;\\n        dist[s] = 1\\n        for _ in range(N - 1): # \\u2B50\\uFE0F relax edges N - 1 times\\n            for i, [u, v] in enumerate(E):\\n                w = A[i]\\n                dist[u] = max(dist[u], dist[v] * w)\\n                dist[v] = max(dist[v], dist[u] * w)\\n        return dist[t]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Dist = vector<double>;\\n    using Edges = vector<vector<int>>;\\n    using Prob = vector<double>;\\n    double maxProbability(int N, Edges& E, Prob& A, int s, int t) {\\n        Dist dist(N);\\n        dist[s] = 1;\\n        while (0 < N--) { // \\u2B50\\uFE0F relax edges N - 1 times\\n            auto i{ 0 };\\n            for (auto& edge: E) {\\n                auto [u, v] = tie(edge[0], edge[1]);\\n                auto w = A[i++];\\n                dist[u] = max(dist[u], dist[v] * w);\\n                dist[v] = max(dist[v], dist[u] * w);\\n            }\\n        }\\n        return dist[t];\\n    }\\n};\\n```\\n\\n---\\n\\n**`\\u2B50\\uFE0F` Solution #2:** [**SPFA**](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm) (AC)\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxProbability(N: Int, E: Array<IntArray>, A: DoubleArray, s: Int, t: Int): Double {\\n        var dist = DoubleArray(N) { 0.0 }\\n        dist[s] = 1.0\\n        var adj = Array(N) { mutableListOf<Pair<Int, Double>>() }\\n        E.forEachIndexed { i, (u, v) ->\\n            var w = A[i]\\n            adj[u].add(v to w)\\n            adj[v].add(u to w)\\n        }\\n        var q: Queue<Int> = LinkedList<Int>(mutableListOf<Int>(s))\\n        while (0 < q.size) {\\n            var u = q.poll()\\n            adj[u].forEach { (v, w) ->\\n                if (dist[v] < dist[u] * w) {\\n                    dist[v] = dist[u] * w; q.add(v) // \\u2B50\\uFE0F cherry pick v for subsequent edges under consideration to be relaxed\\n                }\\n            }\\n        }\\n        return dist[t]\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxProbability = (N, E, A, s, t) => {\\n    let adj = [...Array(N)].map(_ => []);\\n    E.forEach(([u, v], i) => {\\n        let w = A[i];\\n        adj[u].push([ v, w ]);\\n        adj[v].push([ u, w ]);\\n    })\\n    let dist = Array(N).fill(0)\\n    dist[s] = 1;\\n    let q = [ s ];\\n    while (q.length) {\\n        let u = q.shift();\\n        for (let [v, w] of adj[u])\\n            if (dist[v] < dist[u] * w)\\n                dist[v] = dist[u] * w, q.push(v); // \\u2B50\\uFE0F cherry pick v for subsequent edges under consideration to be relaxed\\n    }\\n    return dist[t];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxProbability(self, N: int, E: List[List[int]], A: List[float], s: int, t: int) -> float:\\n        adj = list(map(lambda _: [], [None] * N))\\n        for i, [u, v] in enumerate(E):\\n            w = A[i]\\n            adj[u].append([ v, w ])\\n            adj[v].append([ u, w ])\\n        dist = [0] * N;\\n        dist[s] = 1\\n        q = collections.deque([s])\\n        while len(q):\\n            u = q.popleft()\\n            for [v, w] in adj[u]:\\n                if dist[v] < dist[u] * w:\\n                    dist[v] = dist[u] * w\\n                    q.append(v) # \\u2B50\\uFE0F cherry pick v for subsequent edges under consideration to be relaxed\\n        return dist[t]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Dist = vector<double>;\\n    using Edges = vector<vector<int>>;\\n    using Prob = vector<double>;\\n    using Adj = unordered_map<int, vector<tuple<int, double>>>;\\n    double maxProbability(int N, Edges& E, Prob& A, int s, int t, Adj adj = {}) {\\n        auto i{ 0 };\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            auto w = A[i++];\\n            adj[u].push_back({ v, w });\\n            adj[v].push_back({ u, w });\\n        }\\n        Dist dist(N);\\n        dist[s] = 1;\\n        queue<int> q{{{ s }}};\\n        while (q.size()) {\\n            auto u = q.front(); q.pop();\\n            for (auto [v, w]: adj[u])\\n                if (dist[v] < dist[u] * w)\\n                    dist[v] = dist[u] * w, q.push(v); // \\u2B50\\uFE0F cherry pick v for subsequent edges under consideration to be relaxed\\n        }\\n        return dist[t];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProbability(N: Int, E: Array<IntArray>, A: DoubleArray, s: Int, t: Int): Double {\\n        var dist = DoubleArray(N) { 0.0 }\\n        dist[s] = 1.0\\n        for (i in 0 until N - 1) { // \\u2B50\\uFE0F relax edges N - 1 times\\n            E.forEachIndexed { i, (u, v) ->\\n                var w = A[i]\\n                if (dist[v] < dist[u] * w) dist[v] = dist[u] * w\\n                if (dist[u] < dist[v] * w) dist[u] = dist[v] * w\\n            }\\n        }\\n        return dist[t]\\n    }\\n}\\n```\n```\\nlet maxProbability = (N, E, A, s, t) => {\\n    let dist = Array(N).fill(0)\\n    dist[s] = 1;\\n    while (0 < N--) { // \\u2B50\\uFE0F relax edges N - 1 times\\n        E.forEach(([u, v], i) => {\\n            let w = A[i];\\n            dist[u] = Math.max(dist[u], dist[v] * w);\\n            dist[v] = Math.max(dist[v], dist[u] * w);\\n        });\\n    }\\n    return dist[t];\\n};\\n```\n```\\nclass Solution:\\n    def maxProbability(self, N: int, E: List[List[int]], A: List[float], s: int, t: int) -> float:\\n        dist = [0] * N;\\n        dist[s] = 1\\n        for _ in range(N - 1): # \\u2B50\\uFE0F relax edges N - 1 times\\n            for i, [u, v] in enumerate(E):\\n                w = A[i]\\n                dist[u] = max(dist[u], dist[v] * w)\\n                dist[v] = max(dist[v], dist[u] * w)\\n        return dist[t]\\n```\n```\\nclass Solution {\\npublic:\\n    using Dist = vector<double>;\\n    using Edges = vector<vector<int>>;\\n    using Prob = vector<double>;\\n    double maxProbability(int N, Edges& E, Prob& A, int s, int t) {\\n        Dist dist(N);\\n        dist[s] = 1;\\n        while (0 < N--) { // \\u2B50\\uFE0F relax edges N - 1 times\\n            auto i{ 0 };\\n            for (auto& edge: E) {\\n                auto [u, v] = tie(edge[0], edge[1]);\\n                auto w = A[i++];\\n                dist[u] = max(dist[u], dist[v] * w);\\n                dist[v] = max(dist[v], dist[u] * w);\\n            }\\n        }\\n        return dist[t];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun maxProbability(N: Int, E: Array<IntArray>, A: DoubleArray, s: Int, t: Int): Double {\\n        var dist = DoubleArray(N) { 0.0 }\\n        dist[s] = 1.0\\n        var adj = Array(N) { mutableListOf<Pair<Int, Double>>() }\\n        E.forEachIndexed { i, (u, v) ->\\n            var w = A[i]\\n            adj[u].add(v to w)\\n            adj[v].add(u to w)\\n        }\\n        var q: Queue<Int> = LinkedList<Int>(mutableListOf<Int>(s))\\n        while (0 < q.size) {\\n            var u = q.poll()\\n            adj[u].forEach { (v, w) ->\\n                if (dist[v] < dist[u] * w) {\\n                    dist[v] = dist[u] * w; q.add(v) // \\u2B50\\uFE0F cherry pick v for subsequent edges under consideration to be relaxed\\n                }\\n            }\\n        }\\n        return dist[t]\\n    }\\n}\\n```\n```\\nlet maxProbability = (N, E, A, s, t) => {\\n    let adj = [...Array(N)].map(_ => []);\\n    E.forEach(([u, v], i) => {\\n        let w = A[i];\\n        adj[u].push([ v, w ]);\\n        adj[v].push([ u, w ]);\\n    })\\n    let dist = Array(N).fill(0)\\n    dist[s] = 1;\\n    let q = [ s ];\\n    while (q.length) {\\n        let u = q.shift();\\n        for (let [v, w] of adj[u])\\n            if (dist[v] < dist[u] * w)\\n                dist[v] = dist[u] * w, q.push(v); // \\u2B50\\uFE0F cherry pick v for subsequent edges under consideration to be relaxed\\n    }\\n    return dist[t];\\n};\\n```\n```\\nclass Solution:\\n    def maxProbability(self, N: int, E: List[List[int]], A: List[float], s: int, t: int) -> float:\\n        adj = list(map(lambda _: [], [None] * N))\\n        for i, [u, v] in enumerate(E):\\n            w = A[i]\\n            adj[u].append([ v, w ])\\n            adj[v].append([ u, w ])\\n        dist = [0] * N;\\n        dist[s] = 1\\n        q = collections.deque([s])\\n        while len(q):\\n            u = q.popleft()\\n            for [v, w] in adj[u]:\\n                if dist[v] < dist[u] * w:\\n                    dist[v] = dist[u] * w\\n                    q.append(v) # \\u2B50\\uFE0F cherry pick v for subsequent edges under consideration to be relaxed\\n        return dist[t]\\n```\n```\\nclass Solution {\\npublic:\\n    using Dist = vector<double>;\\n    using Edges = vector<vector<int>>;\\n    using Prob = vector<double>;\\n    using Adj = unordered_map<int, vector<tuple<int, double>>>;\\n    double maxProbability(int N, Edges& E, Prob& A, int s, int t, Adj adj = {}) {\\n        auto i{ 0 };\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            auto w = A[i++];\\n            adj[u].push_back({ v, w });\\n            adj[v].push_back({ u, w });\\n        }\\n        Dist dist(N);\\n        dist[s] = 1;\\n        queue<int> q{{{ s }}};\\n        while (q.size()) {\\n            auto u = q.front(); q.pop();\\n            for (auto [v, w]: adj[u])\\n                if (dist[v] < dist[u] * w)\\n                    dist[v] = dist[u] * w, q.push(v); // \\u2B50\\uFE0F cherry pick v for subsequent edges under consideration to be relaxed\\n        }\\n        return dist[t];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736421,
                "title": "php-solution-based-on-dijkstra-s-algorithm",
                "content": "```\\nfunction maxProbability($n, $edges, $succProb, $start, $end) \\n{\\n\\tforeach($edges as $key => $item) {\\n\\t\\t$map[$item[0]][$item[1]] = $succProb[$key];\\n\\t\\t$map[$item[1]][$item[0]] = $succProb[$key];\\n\\t}\\n\\n\\t$queue[] = $start;\\n\\t$max[$start] = 1;\\n\\n\\twhile(count($queue)) {\\n\\t\\t$current = array_shift($queue);\\n\\t\\tforeach($map[$current] as $next => $succ) {\\n\\t\\t\\t$val = $succ * $max[$current];\\n\\t\\t\\tif(!array_key_exists($next, $max) || $val > $max[$next]) {\\n\\t\\t\\t\\t$max[$next] = $val;\\n\\t\\t\\t\\t$queue[] = $next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn $max[$end];\\n}",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction maxProbability($n, $edges, $succProb, $start, $end) \\n{\\n\\tforeach($edges as $key => $item) {\\n\\t\\t$map[$item[0]][$item[1]] = $succProb[$key];\\n\\t\\t$map[$item[1]][$item[0]] = $succProb[$key];\\n\\t}\\n\\n\\t$queue[] = $start;\\n\\t$max[$start] = 1;\\n\\n\\twhile(count($queue)) {\\n\\t\\t$current = array_shift($queue);\\n\\t\\tforeach($map[$current] as $next => $succ) {\\n\\t\\t\\t$val = $succ * $max[$current];\\n\\t\\t\\tif(!array_key_exists($next, $max) || $val > $max[$next]) {\\n\\t\\t\\t\\t$max[$next] = $val;\\n\\t\\t\\t\\t$queue[] = $next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn $max[$end];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 734438,
                "title": "java-bellman-ford-algorithm",
                "content": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        //bellman-ford \\n        double[] cost = new double[n];\\n        cost[start] = 1;\\n        for(int i = 0; i < n-1; i++){ \\n            boolean flag = false;\\n            for(int j = 0; j < edges.length; j++){\\n                if(cost[edges[j][0]] < cost[edges[j][1]]*succProb[j]){\\n                    cost[edges[j][0]] = cost[edges[j][1]]*succProb[j];\\n                    flag = true;\\n                }\\n                if(cost[edges[j][1]] < cost[edges[j][0]]*succProb[j]){\\n                    cost[edges[j][1]] = cost[edges[j][0]]*succProb[j];\\n                    flag = true;\\n                }\\n            }\\n            if(flag == false) break;\\n        }\\n        return cost[end];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        //bellman-ford \\n        double[] cost = new double[n];\\n        cost[start] = 1;\\n        for(int i = 0; i < n-1; i++){ \\n            boolean flag = false;\\n            for(int j = 0; j < edges.length; j++){\\n                if(cost[edges[j][0]] < cost[edges[j][1]]*succProb[j]){\\n                    cost[edges[j][0]] = cost[edges[j][1]]*succProb[j];\\n                    flag = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 734248,
                "title": "java-using-hashmap-and-priorityqueue-only",
                "content": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        //dp[i] records the success probabilites from 0 to i\\n        double[] dp = new double[n];\\n        \\n        //source - adjacent nodes with probabilities\\n        Map<Integer,Map<Integer,Double>> map = new HashMap<>();\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            int[] pairs = edges[i];\\n            Map<Integer,Double> paths = map.getOrDefault(pairs[0],new HashMap<>());\\n            paths.put(pairs[1],succProb[i]);\\n            Map<Integer,Double> paths2 = map.getOrDefault(pairs[1],new HashMap<>());\\n            paths2.put(pairs[0],succProb[i]);\\n            map.put(pairs[0],paths);\\n            map.put(pairs[1],paths2);\\n        }\\n        //no such path\\n        if(map.get(start)==null||map.get(end)==null)\\n            return 0;\\n        \\n        dp[start] = 1;\\n        \\n        //store from highest probability to lowest\\n        PriorityQueue<double[]> queue = new PriorityQueue<>((a,b)->Double.compare(b[1],a[1]));\\n        queue.offer(new double[]{start,1});\\n        \\n\\t\\t//always get the max probability unvisited node and update its adjacent nodes prob\\n        while(!queue.isEmpty())\\n        {\\n            double[] pair = queue.poll();\\n            int src = (int)pair[0];\\n            Map<Integer,Double> paths = map.get(src);\\n            for(int dest: paths.keySet())\\n            {\\n                if(dp[dest] < paths.get(dest) * pair[1])\\n                {\\n                    dp[dest] = paths.get(dest) * pair[1];\\n                    queue.offer(new double[]{dest,dp[dest]});\\n                }\\n            }\\n        }\\n        \\n        return dp[end];\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        //dp[i] records the success probabilites from 0 to i\\n        double[] dp = new double[n];\\n        \\n        //source - adjacent nodes with probabilities\\n        Map<Integer,Map<Integer,Double>> map = new HashMap<>();\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            int[] pairs = edges[i];\\n            Map<Integer,Double> paths = map.getOrDefault(pairs[0],new HashMap<>());\\n            paths.put(pairs[1],succProb[i]);\\n            Map<Integer,Double> paths2 = map.getOrDefault(pairs[1],new HashMap<>());\\n            paths2.put(pairs[0],succProb[i]);\\n            map.put(pairs[0],paths);\\n            map.put(pairs[1],paths2);\\n        }\\n        //no such path\\n        if(map.get(start)==null||map.get(end)==null)\\n            return 0;\\n        \\n        dp[start] = 1;\\n        \\n        //store from highest probability to lowest\\n        PriorityQueue<double[]> queue = new PriorityQueue<>((a,b)->Double.compare(b[1],a[1]));\\n        queue.offer(new double[]{start,1});\\n        \\n\\t\\t//always get the max probability unvisited node and update its adjacent nodes prob\\n        while(!queue.isEmpty())\\n        {\\n            double[] pair = queue.poll();\\n            int src = (int)pair[0];\\n            Map<Integer,Double> paths = map.get(src);\\n            for(int dest: paths.keySet())\\n            {\\n                if(dp[dest] < paths.get(dest) * pair[1])\\n                {\\n                    dp[dest] = paths.get(dest) * pair[1];\\n                    queue.offer(new double[]{dest,dp[dest]});\\n                }\\n            }\\n        }\\n        \\n        return dp[end];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733858,
                "title": "easy-to-understand-dijkstra-solution-in-c-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, double>>> m;\\n        for(int i = 0; i < edges.size(); i++) {\\n            m[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            m[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        vector<double> dist(n, 0);\\n        dist[start] = 1;\\n        set<pair<double, int>> s;\\n        s.insert({1, start});\\n        while(!s.empty()) {\\n            auto p = *(s.rbegin());\\n            int node = p.second;\\n            double prob = p.first;\\n            s.erase(prev(s.end()));\\n            for(auto child : m[node]) {\\n                if(prob * child.second > dist[child.first]) {\\n                    int dest = child.first;\\n                    auto f = s.find({dist[dest], dest});\\n                    if(f != s.end()) {\\n                        s.erase(f);\\n                    }\\n                    dist[dest] = prob * child.second;\\n                    s.insert({dist[dest], dest});\\n                }\\n            }\\n        }\\n        return dist[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, double>>> m;\\n        for(int i = 0; i < edges.size(); i++) {\\n            m[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            m[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        vector<double> dist(n, 0);\\n        dist[start] = 1;\\n        set<pair<double, int>> s;\\n        s.insert({1, start});\\n        while(!s.empty()) {\\n            auto p = *(s.rbegin());\\n            int node = p.second;\\n            double prob = p.first;\\n            s.erase(prev(s.end()));\\n            for(auto child : m[node]) {\\n                if(prob * child.second > dist[child.first]) {\\n                    int dest = child.first;\\n                    auto f = s.find({dist[dest], dest});\\n                    if(f != s.end()) {\\n                        s.erase(f);\\n                    }\\n                    dist[dest] = prob * child.second;\\n                    s.insert({dist[dest], dest});\\n                }\\n            }\\n        }\\n        return dist[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732844,
                "title": "help-dfs-memo-doesn-t-work",
                "content": "The code works fine with the most case, but can\\'t pass the longest case. \\nI don\\'t think the problem is in the visited array, since the visited array will be reset to false when coming back from the current path. Anything wrong with memo[]? I have no clue at all. \\n\\n```\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        boolean[] visited = new boolean[n];\\n        Map<Integer, Map<Integer, Double>> graph = buildMap(edges, succProb);\\n        double[] memo = new double[n];\\n        return dfs(graph, visited, end, start, memo);\\n    }\\n\\t\\n    private double dfs(Map<Integer, Map<Integer, Double>> graph, boolean[] visited,int end, int cur, double[] memo) {\\n        if (cur == end) {\\n            return 1;\\n        }\\n        if (memo[cur] != 0) {\\n            return memo[cur];\\n        }\\n    \\n        visited[cur] = true;\\n        double m = 0;\\n        Map<Integer, Double> nexts = graph.get(cur);\\n        if (nexts != null) {\\n            for (Map.Entry<Integer, Double> entry : nexts.entrySet()) {\\n                int next = entry.getKey();\\n                double p = entry.getValue();\\n                if (!visited[next]) {\\n                    m = Math.max(m, dfs(graph, visited, end, next, memo) * p) ;\\n                }\\n            }\\n        }\\n        memo[cur] = m;\\n        visited[cur] = false;\\n        return m;\\n    }\\n    \\n    private Map<Integer, Map<Integer, Double>> buildMap(int[][] edges, double[] succProb){\\n        Map<Integer, Map<Integer, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            graph.putIfAbsent(a, new HashMap<Integer, Double>());\\n            graph.putIfAbsent(b, new HashMap<Integer, Double>());\\n            graph.get(a).put(b, succProb[i]);\\n            graph.get(b).put(a, succProb[i]);\\n        }\\n        return graph;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        boolean[] visited = new boolean[n];\\n        Map<Integer, Map<Integer, Double>> graph = buildMap(edges, succProb);\\n        double[] memo = new double[n];\\n        return dfs(graph, visited, end, start, memo);\\n    }\\n\\t\\n    private double dfs(Map<Integer, Map<Integer, Double>> graph, boolean[] visited,int end, int cur, double[] memo) {\\n        if (cur == end) {\\n            return 1;\\n        }\\n        if (memo[cur] != 0) {\\n            return memo[cur];\\n        }\\n    \\n        visited[cur] = true;\\n        double m = 0;\\n        Map<Integer, Double> nexts = graph.get(cur);\\n        if (nexts != null) {\\n            for (Map.Entry<Integer, Double> entry : nexts.entrySet()) {\\n                int next = entry.getKey();\\n                double p = entry.getValue();\\n                if (!visited[next]) {\\n                    m = Math.max(m, dfs(graph, visited, end, next, memo) * p) ;\\n                }\\n            }\\n        }\\n        memo[cur] = m;\\n        visited[cur] = false;\\n        return m;\\n    }\\n    \\n    private Map<Integer, Map<Integer, Double>> buildMap(int[][] edges, double[] succProb){\\n        Map<Integer, Map<Integer, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            graph.putIfAbsent(a, new HashMap<Integer, Double>());\\n            graph.putIfAbsent(b, new HashMap<Integer, Double>());\\n            graph.get(a).put(b, succProb[i]);\\n            graph.get(b).put(a, succProb[i]);\\n        }\\n        return graph;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732402,
                "title": "c-using-priority-queue-tuple-sorting-of-priority-queue",
                "content": "```\\nclass comp{\\npublic:\\n    bool operator()(tuple<int,double> t1, tuple<int,double> t2){\\n        return get<1>(t1)<get<1>(t2);\\n    }\\n};\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int,vector<pair<int,double>>> hg;\\n        unordered_map<int,bool>gh;\\n        for(int i=0;i<n;i++){\\n            gh[i]=false;\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            hg[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            hg[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        \\n        priority_queue<tuple<int,double>, vector<tuple<int,double>>,comp> pq;\\n        pq.push(tuple<int,double>{start,1});\\n        \\n        while(!pq.empty()){\\n            auto num = pq.top();\\n            pq.pop();\\n            int cur = get<0>(num);\\n            gh[cur]=true;\\n            double cost = get<1>(num);\\n            if(cur==end){\\n                return cost;\\n            }\\n            if(hg.find(cur)==hg.end())continue;\\n            for(auto n:hg[cur]){\\n                if(gh[n.first]==false){\\n                    pq.push(tuple<int,double>{n.first,n.second*cost});\\n                }\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass comp{\\npublic:\\n    bool operator()(tuple<int,double> t1, tuple<int,double> t2){\\n        return get<1>(t1)<get<1>(t2);\\n    }\\n};\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int,vector<pair<int,double>>> hg;\\n        unordered_map<int,bool>gh;\\n        for(int i=0;i<n;i++){\\n            gh[i]=false;\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            hg[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            hg[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        \\n        priority_queue<tuple<int,double>, vector<tuple<int,double>>,comp> pq;\\n        pq.push(tuple<int,double>{start,1});\\n        \\n        while(!pq.empty()){\\n            auto num = pq.top();\\n            pq.pop();\\n            int cur = get<0>(num);\\n            gh[cur]=true;\\n            double cost = get<1>(num);\\n            if(cur==end){\\n                return cost;\\n            }\\n            if(hg.find(cur)==hg.end())continue;\\n            for(auto n:hg[cur]){\\n                if(gh[n.first]==false){\\n                    pq.push(tuple<int,double>{n.first,n.second*cost});\\n                }\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731996,
                "title": "python-dijkstra-with-min-heap-90",
                "content": "\\tPython Dijkstra flip probabilities negative to work with min heapq\\n\\t\\t \\n\\t\\tgraph = collections.defaultdict(list)\\n        \\n        for i,e in enumerate(edges):\\n            graph[e[0]].append((e[1],succProb[i]))\\n            graph[e[1]].append((e[0],succProb[i]))\\n        \\n        if end not in graph:\\n            return 0.0\\n        \\n        d = { vertex: float(\\'inf\\')  for vertex in graph.keys()}\\n        d[start] = -1.0\\n        pq = [(-1.0, start)]\\n        \\n        while pq:\\n            curr_p, curr_e = heapq.heappop(pq)\\n            for edges in graph[curr_e]:\\n                vertex, p = edges\\n                distance = curr_p*p\\n                if distance < d[vertex]:\\n                    d[vertex] = distance\\n                    heapq.heappush(pq, (distance, vertex))\\n        if d[end] == float(\\'inf\\'):\\n            return 0.0\\n        return -d[end]\\n",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tPython Dijkstra flip probabilities negative to work with min heapq\\n\\t\\t \\n\\t\\tgraph = collections.defaultdict(list)\\n        \\n        for i,e in enumerate(edges):\\n            graph[e[0]].append((e[1],succProb[i]))\\n            graph[e[1]].append((e[0],succProb[i]))\\n        \\n        if end not in graph:\\n            return 0.0\\n        \\n        d = { vertex: float(\\'inf\\')  for vertex in graph.keys()}\\n        d[start] = -1.0\\n        pq = [(-1.0, start)]\\n        \\n        while pq:\\n            curr_p, curr_e = heapq.heappop(pq)\\n            for edges in graph[curr_e]:\\n                vertex, p = edges\\n                distance = curr_p*p\\n                if distance < d[vertex]:\\n                    d[vertex] = distance\\n                    heapq.heappush(pq, (distance, vertex))\\n        if d[end] == float(\\'inf\\'):\\n            return 0.0\\n        return -d[end]\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 731966,
                "title": "c-dfs",
                "content": "```\\n\\nstruct mygraph\\n{\\n    double next;\\n    double val;\\n}mygraph;\\n\\nvoid help(int n, struct mygraph** graph, int index, int end, double *state, double current, double *xx,int *col)\\n{\\n    if(current<=0.00005) return;\\n    if(state[index]>=current) \\n    {\\n        return;\\n    }\\n    \\n    state[index] = current;\\n    if(index == end)\\n    {\\n        if(*xx<current) *xx = current;\\n        return ;\\n    }\\n    \\n\\n    int i;\\n    \\n    for(i=0;i<col[index];i++)\\n    {\\n        \\n  \\n            help(n, graph, graph[index][i].next, end, state, current*graph[index][i].val, xx,col);\\n\\n\\n    }\\n    \\n \\n}\\n\\n\\n\\ndouble maxProbability(int n, int** edges, int edgesSize, int* edgesColSize, double* succProb, int succProbSize, int start, int end){\\n\\n    double *state = (double*)calloc(sizeof(double) , n);\\n    \\n    struct mygraph **graph = ( struct mygraph**)calloc(sizeof( struct mygraph*), n);\\n    int *col  = (int*)calloc(sizeof(int),n);\\n    int i;\\n    for(i=0;i<edgesSize;i++)\\n    {\\n        int temp0 = edges[i][0];\\n        int temp1 = edges[i][1];\\n        if(col[temp0]==0)\\n        {\\n            graph[temp0] = ( struct mygraph*)malloc(sizeof( struct mygraph) );\\n            \\n        }\\n        else\\n            graph[temp0] = ( struct mygraph*)realloc(graph[temp0],sizeof( struct mygraph) *(1+col[temp0]));\\n        if(col[temp1]==0)\\n        {\\n            graph[temp1] = ( struct mygraph*)malloc(sizeof( struct mygraph));\\n            \\n        }\\n        else\\n            graph[temp1] = ( struct mygraph*)realloc(graph[temp1],sizeof( struct mygraph) *(1+col[temp1]));\\n        graph[temp0][col[temp0]].next=temp1;\\n        graph[temp0][col[temp0]++].val  = succProb[i];\\n        graph[temp1][col[temp1]].next=temp0;\\n        graph[temp1][col[temp1]++].val  = succProb[i];\\n        \\n    }\\n    double max=-1;\\n    \\n    help(n, graph, start, end, state, 1, &max,col);\\n    \\n    \\n    return max==-1?0:max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct mygraph\\n{\\n    double next;\\n    double val;\\n}mygraph;\\n\\nvoid help(int n, struct mygraph** graph, int index, int end, double *state, double current, double *xx,int *col)\\n{\\n    if(current<=0.00005) return;\\n    if(state[index]>=current) \\n    {\\n        return;\\n    }\\n    \\n    state[index] = current;\\n    if(index == end)\\n    {\\n        if(*xx<current) *xx = current;\\n        return ;\\n    }\\n    \\n\\n    int i;\\n    \\n    for(i=0;i<col[index];i++)\\n    {\\n        \\n  \\n            help(n, graph, graph[index][i].next, end, state, current*graph[index][i].val, xx,col);\\n\\n\\n    }\\n    \\n \\n}\\n\\n\\n\\ndouble maxProbability(int n, int** edges, int edgesSize, int* edgesColSize, double* succProb, int succProbSize, int start, int end){\\n\\n    double *state = (double*)calloc(sizeof(double) , n);\\n    \\n    struct mygraph **graph = ( struct mygraph**)calloc(sizeof( struct mygraph*), n);\\n    int *col  = (int*)calloc(sizeof(int),n);\\n    int i;\\n    for(i=0;i<edgesSize;i++)\\n    {\\n        int temp0 = edges[i][0];\\n        int temp1 = edges[i][1];\\n        if(col[temp0]==0)\\n        {\\n            graph[temp0] = ( struct mygraph*)malloc(sizeof( struct mygraph) );\\n            \\n        }\\n        else\\n            graph[temp0] = ( struct mygraph*)realloc(graph[temp0],sizeof( struct mygraph) *(1+col[temp0]));\\n        if(col[temp1]==0)\\n        {\\n            graph[temp1] = ( struct mygraph*)malloc(sizeof( struct mygraph));\\n            \\n        }\\n        else\\n            graph[temp1] = ( struct mygraph*)realloc(graph[temp1],sizeof( struct mygraph) *(1+col[temp1]));\\n        graph[temp0][col[temp0]].next=temp1;\\n        graph[temp0][col[temp0]++].val  = succProb[i];\\n        graph[temp1][col[temp1]].next=temp0;\\n        graph[temp1][col[temp1]++].val  = succProb[i];\\n        \\n    }\\n    double max=-1;\\n    \\n    help(n, graph, start, end, state, 1, &max,col);\\n    \\n    \\n    return max==-1?0:max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731827,
                "title": "java-bellman-ford",
                "content": "```\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n\\tdouble[] prob = new double[n];\\n\\tprob[start] = 1;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tboolean keepGoing = false;\\n\\t\\tfor (int j = 0; j < edges.length; j++) {\\n\\t\\t\\tint[] e = edges[j];\\n\\t\\t\\tif (prob[e[1]] < prob[e[0]] * succProb[j]) {\\n\\t\\t\\t\\tprob[e[1]] = prob[e[0]] * succProb[j];\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t}\\n\\t\\t\\tif (prob[e[0]] < prob[e[1]] * succProb[j]) {\\n\\t\\t\\t\\tprob[e[0]] = prob[e[1]] * succProb[j];\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!keepGoing) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\treturn prob[end];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n\\tdouble[] prob = new double[n];\\n\\tprob[start] = 1;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tboolean keepGoing = false;\\n\\t\\tfor (int j = 0; j < edges.length; j++) {\\n\\t\\t\\tint[] e = edges[j];\\n\\t\\t\\tif (prob[e[1]] < prob[e[0]] * succProb[j]) {\\n\\t\\t\\t\\tprob[e[1]] = prob[e[0]] * succProb[j];\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t}\\n\\t\\t\\tif (prob[e[0]] < prob[e[1]] * succProb[j]) {\\n\\t\\t\\t\\tprob[e[0]] = prob[e[1]] * succProb[j];\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!keepGoing) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\treturn prob[end];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731765,
                "title": "python-easy-to-understand-bfs",
                "content": "\\t\\n\\tdef maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = collections.defaultdict(list)\\n\\t\\t\\n\\t\\t# adding all edges with probability to graph\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            graph[u].append([v, succProb[i]])\\n            graph[v].append([u, succProb[i]])\\n        \\n\\t\\t# initializing queue with start node\\n        queue = collections.deque([[start, 1]])\\n        visited = {}\\n        \\n\\t\\t# iterating thru the queue and adding visited nodes and there probability\\n        while(queue):\\n            node, prob = queue.popleft()\\n\\t\\t\\t\\n\\t\\t\\t#if the node is already visited and the probability is higher than current probability then continue\\n            if(node in visited and visited[node] >= prob):\\n                continue\\n\\t\\t\\t\\t\\n            visited[node] = prob\\n            for nei, nei_prob in graph[node]:\\n                queue.append([nei, prob * nei_prob])                \\n                                   \\n        return visited.get(end, 0)",
                "solutionTags": [],
                "code": "\\t\\n\\tdef maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = collections.defaultdict(list)\\n\\t\\t\\n\\t\\t# adding all edges with probability to graph\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            graph[u].append([v, succProb[i]])\\n            graph[v].append([u, succProb[i]])\\n        \\n\\t\\t# initializing queue with start node\\n        queue = collections.deque([[start, 1]])\\n        visited = {}\\n        \\n\\t\\t# iterating thru the queue and adding visited nodes and there probability\\n        while(queue):\\n            node, prob = queue.popleft()\\n\\t\\t\\t\\n\\t\\t\\t#if the node is already visited and the probability is higher than current probability then continue\\n            if(node in visited and visited[node] >= prob):\\n                continue\\n\\t\\t\\t\\t\\n            visited[node] = prob\\n            for nei, nei_prob in graph[node]:\\n                queue.append([nei, prob * nei_prob])                \\n                                   \\n        return visited.get(end, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 731684,
                "title": "c-ac-with-easy-explanation-dijkstra-s-but-minimizing-inverse-of-probabilities-o-e-lg-n",
                "content": "Given problem is maximizing the probabilty of the path.\\n\\nCan\\'t use BFS directly as that\\'s for finding min-distance path with non-weighted edges.\\n\\nIf use BFS by running it till end, that\\'d make it O(E* E) which can TLE.\\n\\nSo, use Dijkstra\\'s that\\'s used for min-distance path where edges have weights (here probabilities).\\n\\nTransform max-probability path problem to min-distance path problem by associating with each edge the inverse of probability as the weight. The distance on a path to a node is the cumulative-multiplication of weights of the edges on that path.\\n\\nSo 2 changes needed to transform this so you get right answer:\\n\\n- use dijkstra\\'s to handle weighted edges (here probabilities associated with edges can be seen as weights).\\n\\n- the problem given is max-distance problem, so you need to translate it to a form that lends itself to min-distance. I did that by inversing the cumumulative probability. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edgs, vector<double>& succp, int s, int e) {\\n        gr.assign(n, vector<int>());\\n        rprob.assign(n, vector<double>());\\n        for (int i = 0; i < edgs.size(); i++) {\\n            int v1 = edgs[i][0], v2 = edgs[i][1];\\n            gr[v1].push_back(v2);\\n            gr[v2].push_back(v1);\\n            rprob[v1].push_back(1/succp[i]);\\n            rprob[v2].push_back(1/succp[i]);\\n        }\\n        rpDist.assign(n, INF);\\n        vstd.assign(n, 0);\\n        priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq; // min-heap\\n        \\n        // apply Dijkstra\\'s but to minimize reverse of probability distance\\n        rpDist[s] = 1;\\n        pq.emplace(1, s);\\n        while (pq.size()) {\\n            auto t = pq.top();\\n            double curd = t.first;\\n            int v = t.second;\\n            pq.pop();\\n            if (vstd[v]) continue;\\n            \\n            if (v == e) { \\n                return 1/rpDist[v];\\n            }\\n            vstd[v] = 1;\\n            \\n            for (int i = 0; i < gr[v].size(); i++) {\\n                int v2 = gr[v][i];\\n                if (vstd[v2]) continue;\\n        \\n                if (rpDist[v2] > curd*rprob[v][i]) {\\n                        rpDist[v2] = curd*rprob[v][i];\\n                        pq.emplace(rpDist[v2], v2);   \\n                }\\n            }  \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    \\n    double INF = std::numeric_limits<double>::infinity();\\n    vector<int> vstd;\\n    vector<double> rpDist;      // reverse probabilty distance\\n    vector<vector<int>> gr;\\n    vector<vector<double>> rprob; // inverse of prob for that edge\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edgs, vector<double>& succp, int s, int e) {\\n        gr.assign(n, vector<int>());\\n        rprob.assign(n, vector<double>());\\n        for (int i = 0; i < edgs.size(); i++) {\\n            int v1 = edgs[i][0], v2 = edgs[i][1];\\n            gr[v1].push_back(v2);\\n            gr[v2].push_back(v1);\\n            rprob[v1].push_back(1/succp[i]);\\n            rprob[v2].push_back(1/succp[i]);\\n        }\\n        rpDist.assign(n, INF);\\n        vstd.assign(n, 0);\\n        priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq; // min-heap\\n        \\n        // apply Dijkstra\\'s but to minimize reverse of probability distance\\n        rpDist[s] = 1;\\n        pq.emplace(1, s);\\n        while (pq.size()) {\\n            auto t = pq.top();\\n            double curd = t.first;\\n            int v = t.second;\\n            pq.pop();\\n            if (vstd[v]) continue;\\n            \\n            if (v == e) { \\n                return 1/rpDist[v];\\n            }\\n            vstd[v] = 1;\\n            \\n            for (int i = 0; i < gr[v].size(); i++) {\\n                int v2 = gr[v][i];\\n                if (vstd[v2]) continue;\\n        \\n                if (rpDist[v2] > curd*rprob[v][i]) {\\n                        rpDist[v2] = curd*rprob[v][i];\\n                        pq.emplace(rpDist[v2], v2);   \\n                }\\n            }  \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    \\n    double INF = std::numeric_limits<double>::infinity();\\n    vector<int> vstd;\\n    vector<double> rpDist;      // reverse probabilty distance\\n    vector<vector<int>> gr;\\n    vector<vector<double>> rprob; // inverse of prob for that edge\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731663,
                "title": "why-doesn-t-dfs-memo-work",
                "content": "Could anyone help to explain what\\'s wrong using DFS with memorisation? I passed most test cases except for last one.\\n\\n```\\nclass Solution {\\n    double max = 0;\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        Map<Integer, Map<Integer, Double>> prob = new HashMap<>();\\n        for (int i = 0; i < succProb.length; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            map.putIfAbsent(a, new ArrayList<>());\\n            map.putIfAbsent(b, new ArrayList<>());\\n            map.get(a).add(b);\\n            map.get(b).add(a);\\n            prob.putIfAbsent(a, new HashMap<>());\\n            prob.putIfAbsent(b, new HashMap<>());\\n            prob.get(a).put(b, succProb[i]);\\n            prob.get(b).put(a, succProb[i]);\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        Map<Integer, Double> cache = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            cache.put(i, Double.MIN_VALUE);\\n        }\\n        return helper(map, prob,\\n                      start, end, start, 1, visited, cache);\\n    }\\n    \\n    private double helper(Map<Integer, List<Integer>> map, Map<Integer, Map<Integer, Double>> prob,\\n                        int start, int end, int curr, double currProb, Set<Integer> visited, Map<Integer, Double> cache) {\\n        // System.out.println(\"curr:\" + curr + \", currProb: \" + currProb);\\n        if (cache.get(curr) != Double.MIN_VALUE) {\\n            return currProb * cache.get(curr);\\n        }\\n        if (curr == end) {\\n            return currProb;\\n        }\\n        if (map.containsKey(curr)) {\\n            for (int neighbor : map.get(curr)) {\\n                if (!visited.contains(neighbor)) {\\n                    visited.add(neighbor);\\n                    double temp = helper(map, prob, start, end, neighbor, currProb * prob.get(curr).get(neighbor), visited, cache);\\n                    if (cache.get(curr) < temp) {\\n                        // System.out.println(\"curr: \" + curr + \", neighbor: \" + neighbor + \", temp: \" + temp);\\n                        cache.put(curr, temp);\\n                    }\\n                    visited.remove(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return cache.get(curr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double max = 0;\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        Map<Integer, Map<Integer, Double>> prob = new HashMap<>();\\n        for (int i = 0; i < succProb.length; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            map.putIfAbsent(a, new ArrayList<>());\\n            map.putIfAbsent(b, new ArrayList<>());\\n            map.get(a).add(b);\\n            map.get(b).add(a);\\n            prob.putIfAbsent(a, new HashMap<>());\\n            prob.putIfAbsent(b, new HashMap<>());\\n            prob.get(a).put(b, succProb[i]);\\n            prob.get(b).put(a, succProb[i]);\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        Map<Integer, Double> cache = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            cache.put(i, Double.MIN_VALUE);\\n        }\\n        return helper(map, prob,\\n                      start, end, start, 1, visited, cache);\\n    }\\n    \\n    private double helper(Map<Integer, List<Integer>> map, Map<Integer, Map<Integer, Double>> prob,\\n                        int start, int end, int curr, double currProb, Set<Integer> visited, Map<Integer, Double> cache) {\\n        // System.out.println(\"curr:\" + curr + \", currProb: \" + currProb);\\n        if (cache.get(curr) != Double.MIN_VALUE) {\\n            return currProb * cache.get(curr);\\n        }\\n        if (curr == end) {\\n            return currProb;\\n        }\\n        if (map.containsKey(curr)) {\\n            for (int neighbor : map.get(curr)) {\\n                if (!visited.contains(neighbor)) {\\n                    visited.add(neighbor);\\n                    double temp = helper(map, prob, start, end, neighbor, currProb * prob.get(curr).get(neighbor), visited, cache);\\n                    if (cache.get(curr) < temp) {\\n                        // System.out.println(\"curr: \" + curr + \", neighbor: \" + neighbor + \", temp: \" + temp);\\n                        cache.put(curr, temp);\\n                    }\\n                    visited.remove(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return cache.get(curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731658,
                "title": "python-heap-dijkstra",
                "content": "```\\nclass Solution(object):\\n    def maxProbability(self, n, edges, succProb, start, end):\\n\\n        self.g = collections.defaultdict(set)\\n        for (x, y), z in zip(edges, succProb):\\n            self.g[x].add((y, z))\\n            self.g[y].add((x, z))\\n        \\n        heap = [(-1, start)]\\n        from heapq import heappush, heappop\\n        prob = [0]*n\\n        prob[start] = 1\\n        while heap:\\n            curr_prob, node = heappop(heap)\\n            if prob[node] > -curr_prob: continue\\n            for nei, p in self.g[node]:\\n                if prob[node]*p > prob[nei]:\\n                    prob[nei] = prob[node]*p\\n                    heappush(heap, (-prob[nei], nei))\\n        \\n        return prob[end]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProbability(self, n, edges, succProb, start, end):\\n\\n        self.g = collections.defaultdict(set)\\n        for (x, y), z in zip(edges, succProb):\\n            self.g[x].add((y, z))\\n            self.g[y].add((x, z))\\n        \\n        heap = [(-1, start)]\\n        from heapq import heappush, heappop\\n        prob = [0]*n\\n        prob[start] = 1\\n        while heap:\\n            curr_prob, node = heappop(heap)\\n            if prob[node] > -curr_prob: continue\\n            for nei, p in self.g[node]:\\n                if prob[node]*p > prob[nei]:\\n                    prob[nei] = prob[node]*p\\n                    heappush(heap, (-prob[nei], nei))\\n        \\n        return prob[end]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731611,
                "title": "java-dijkstra-s-algorithm-o-e-log-v",
                "content": "```\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        List<double[]>[] graph = new List[n];\\n        for(int i=0; i<n; i++){\\n            graph[i] = new ArrayList();\\n        }\\n        for(int i=0; i<edges.length; i++){\\n            int[] e = edges[i];\\n            double w = succProb[i];\\n            graph[e[0]].add(new double[]{e[1], w});\\n            graph[e[1]].add(new double[]{e[0], w});\\n        }\\n        double[] p = new double[n];\\n        PriorityQueue<double[]> pq = new PriorityQueue<double[]>((a,b)->Double.compare(b[1],a[1]));\\n        p[start] = 1.0;\\n        pq.offer(new double[]{start, 1.0});\\n        while(!pq.isEmpty()){\\n            double[] cur = pq.poll();\\n            int curNode = (int)cur[0];\\n            if(curNode==end){\\n                return cur[1];\\n            }\\n            for(double[] next : graph[curNode]){\\n                int nextNode = (int)next[0];\\n                double w = next[1];\\n                if(w*cur[1] > p[nextNode]){\\n                    p[nextNode] = w*cur[1];\\n                    pq.offer(new double[]{nextNode, p[nextNode]});\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        List<double[]>[] graph = new List[n];\\n        for(int i=0; i<n; i++){\\n            graph[i] = new ArrayList();\\n        }\\n        for(int i=0; i<edges.length; i++){\\n            int[] e = edges[i];\\n            double w = succProb[i];\\n            graph[e[0]].add(new double[]{e[1], w});\\n            graph[e[1]].add(new double[]{e[0], w});\\n        }\\n        double[] p = new double[n];\\n        PriorityQueue<double[]> pq = new PriorityQueue<double[]>((a,b)->Double.compare(b[1],a[1]));\\n        p[start] = 1.0;\\n        pq.offer(new double[]{start, 1.0});\\n        while(!pq.isEmpty()){\\n            double[] cur = pq.poll();\\n            int curNode = (int)cur[0];\\n            if(curNode==end){\\n                return cur[1];\\n            }\\n            for(double[] next : graph[curNode]){\\n                int nextNode = (int)next[0];\\n                double w = next[1];\\n                if(w*cur[1] > p[nextNode]){\\n                    p[nextNode] = w*cur[1];\\n                    pq.offer(new double[]{nextNode, p[nextNode]});\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 731604,
                "title": "python-solution-doesn-t-work-for-1000-nodes-case-someone-help",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        if edges is None or succProb is None or n is None or start is None or end is None:\\n            return 0.0\\n        d = defaultdict(list)\\n        for i in range(len(edges)):\\n            d[edges[i][0]].append([edges[i][1],succProb[i]])\\n            d[edges[i][1]].append([edges[i][0],succProb[i]])\\n        result = []\\n        self.traverse(start,1,result,d,start,end,defaultdict(set),[start])\\n        if len(result)==0:\\n            return 0.0\\n        return max(result)\\n        \\n    def traverse(self, cur, curProb, result, d, start, end, visited,path):\\n        if cur == end:\\n            result.append(curProb)\\n            return\\n        for i in d[cur]:\\n            if i[0] not in visited[cur] and i[0] not in path:\\n                visited[cur].add(i[0])\\n                kcopy = path.copy()\\n                kcopy.append(i[0])\\n                self.traverse(i[0],curProb*i[1], result,d,start,end,visited,kcopy)\\n        return\\n```\\n\\n\\nSolution doesn\\'t work for a case with 1000 nodes. If someone can help me understand why, I will be grateful. Thanks\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        if edges is None or succProb is None or n is None or start is None or end is None:\\n            return 0.0\\n        d = defaultdict(list)\\n        for i in range(len(edges)):\\n            d[edges[i][0]].append([edges[i][1],succProb[i]])\\n            d[edges[i][1]].append([edges[i][0],succProb[i]])\\n        result = []\\n        self.traverse(start,1,result,d,start,end,defaultdict(set),[start])\\n        if len(result)==0:\\n            return 0.0\\n        return max(result)\\n        \\n    def traverse(self, cur, curProb, result, d, start, end, visited,path):\\n        if cur == end:\\n            result.append(curProb)\\n            return\\n        for i in d[cur]:\\n            if i[0] not in visited[cur] and i[0] not in path:\\n                visited[cur].add(i[0])\\n                kcopy = path.copy()\\n                kcopy.append(i[0])\\n                self.traverse(i[0],curProb*i[1], result,d,start,end,visited,kcopy)\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795480,
                "title": "easy-maximum-dijkstra-solution-with-proper-explanation-tc-sc-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question wants the best path from a start to end. So the first algorithm that comes to my mind was Dijkstra.\\nThe only barrier is the confusion between float and int. Rest is pretty straightforward\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Constructe a graph as is given : *[node1, node2, probability]*\\n2. Declare a float type vector(prob) : *size = n* *initial value = 0* \\n> (We haven\\'t reached any node as of now so prob of reaching all nodes = 0).\\n3. Declare a priority queue : *{probability(float), node(int)}*\\n4. Push {1.0, start_node} as now probability to react the start_node from start_node = 1 and update the vector(prob).\\n5. Loop while pq has elements\\n6. Get the top contents of pq and pop()\\n7. Loop for all the children of curNode\\n8. If new probability is greater than the previously stored probability then update and push into the queue.\\n9. Return prob[end_node]\\n\\n# Complexity\\n- Time complexity: O(V+ElogV) (Dijkstra Algorithm)\\n\\n- Space complexity: O(V+V*E*2) to store the dist and to make the Graph.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {\\n        // Making a Graph (Adjacency List)\\n        vector<pair<int, float>> graph[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            //graph[node1] = {node2, edgeProb}\\n            graph[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            //graph[node2] = {node1, edgeProb}\\n            graph[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n\\n        // Maximum Dijkstra Algorithm\\n\\n        vector<float> prob(n, 0.0);             //Probability vector = Stores the max. Probabilities\\n        priority_queue<pair<float, int>> pq;    //pq = {prob(float), node(int)}\\n        pq.push({1.0, start_node});             \\n        prob[start_node]=1;\\n        // Probability to reach start_node from itself = 1\\n\\n        while(!pq.empty())\\n        {\\n            auto p = pq.top();\\n            float curProb = p.first;\\n            int curNode = p.second;\\n            pq.pop();\\n\\n            for(auto child:graph[curNode])\\n            {\\n                int childNode = child.first;\\n                float childProb = child.second;\\n                // if(previously stored probability < new probability) then update and push\\n                if(prob[childNode] < prob[curNode]*childProb)\\n                {\\n                    prob[childNode] = prob[curNode]*childProb;\\n                    pq.push({prob[childNode], childNode});\\n                }\\n            }\\n        }\\n        return prob[end_node];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {\\n        // Making a Graph (Adjacency List)\\n        vector<pair<int, float>> graph[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            //graph[node1] = {node2, edgeProb}\\n            graph[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            //graph[node2] = {node1, edgeProb}\\n            graph[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n\\n        // Maximum Dijkstra Algorithm\\n\\n        vector<float> prob(n, 0.0);             //Probability vector = Stores the max. Probabilities\\n        priority_queue<pair<float, int>> pq;    //pq = {prob(float), node(int)}\\n        pq.push({1.0, start_node});             \\n        prob[start_node]=1;\\n        // Probability to reach start_node from itself = 1\\n\\n        while(!pq.empty())\\n        {\\n            auto p = pq.top();\\n            float curProb = p.first;\\n            int curNode = p.second;\\n            pq.pop();\\n\\n            for(auto child:graph[curNode])\\n            {\\n                int childNode = child.first;\\n                float childProb = child.second;\\n                // if(previously stored probability < new probability) then update and push\\n                if(prob[childNode] < prob[curNode]*childProb)\\n                {\\n                    prob[childNode] = prob[curNode]*childProb;\\n                    pq.push({prob[childNode], childNode});\\n                }\\n            }\\n        }\\n        return prob[end_node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696461,
                "title": "c-dijkstras-with-maximum-distance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(Elog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>> graph[n];  // node(u)--> {node(v),prob};\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            graph[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n \\n           vector<int> vis(n,0);\\n          priority_queue<pair<double,int>> pq;\\n          vector<double> dist(n,0);\\n          pq.push({1.00,start});\\n\\n           while(!pq.empty()){\\n               auto top=pq.top();\\n               pq.pop();\\n               int node=top.second;\\n               double currdist=top.first;\\n                vis[node]=1;\\n               for(auto x:graph[node]){\\n                   int child= x.first;\\n                   double pathprob=x.second;\\n\\n                   if(vis[child]==0){\\n                        if(currdist*pathprob>dist[child]){\\n                            dist[child]= currdist*pathprob;\\n                            pq.push({dist[child],child});\\n                        }\\n                   }\\n               }\\n\\n           }\\n           return dist[end];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>> graph[n];  // node(u)--> {node(v),prob};\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            graph[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n \\n           vector<int> vis(n,0);\\n          priority_queue<pair<double,int>> pq;\\n          vector<double> dist(n,0);\\n          pq.push({1.00,start});\\n\\n           while(!pq.empty()){\\n               auto top=pq.top();\\n               pq.pop();\\n               int node=top.second;\\n               double currdist=top.first;\\n                vis[node]=1;\\n               for(auto x:graph[node]){\\n                   int child= x.first;\\n                   double pathprob=x.second;\\n\\n                   if(vis[child]==0){\\n                        if(currdist*pathprob>dist[child]){\\n                            dist[child]= currdist*pathprob;\\n                            pq.push({dist[child],child});\\n                        }\\n                   }\\n               }\\n\\n           }\\n           return dist[end];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694393,
                "title": "easy-c-solution-using-dijkstra-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n\\n        // Dijkstra hai ye\\n        // max heap le k kar lo\\n        unordered_map<int, list<pair<int, double>>> adj;\\n        for(int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        vector<double> distance(n, INT_MIN);\\n        distance[start] = 0.0;\\n       \\n       // Make a priority queue i.e. max heap\\n       priority_queue<pair<int, double>, vector<pair<int, double>>> q;\\n      \\n       q.push({start, 1.0});\\n      \\n        while(!q.empty()) {\\n            \\n            pair<int, double> f = q.top();\\n            double dist = f.second;\\n            int node = f.first;\\n            q.pop();\\n            \\n            for(auto n: adj[node]) {\\n                int nei = n.first;\\n                double prob = dist * n.second;\\n                \\n                // Update the distance;\\n                if(distance[nei] < prob) {\\n                    distance[nei] = prob;\\n                    q.push({nei, distance[nei],});\\n                }\\n            }\\n        }\\n\\n        if(distance[end] == INT_MIN) {\\n            return 0.0;\\n        }\\n\\n        return distance[end];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n\\n        // Dijkstra hai ye\\n        // max heap le k kar lo\\n        unordered_map<int, list<pair<int, double>>> adj;\\n        for(int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        vector<double> distance(n, INT_MIN);\\n        distance[start] = 0.0;\\n       \\n       // Make a priority queue i.e. max heap\\n       priority_queue<pair<int, double>, vector<pair<int, double>>> q;\\n      \\n       q.push({start, 1.0});\\n      \\n        while(!q.empty()) {\\n            \\n            pair<int, double> f = q.top();\\n            double dist = f.second;\\n            int node = f.first;\\n            q.pop();\\n            \\n            for(auto n: adj[node]) {\\n                int nei = n.first;\\n                double prob = dist * n.second;\\n                \\n                // Update the distance;\\n                if(distance[nei] < prob) {\\n                    distance[nei] = prob;\\n                    q.push({nei, distance[nei],});\\n                }\\n            }\\n        }\\n\\n        if(distance[end] == INT_MIN) {\\n            return 0.0;\\n        }\\n\\n        return distance[end];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694222,
                "title": "java-10ms-fast-dp-no-dijkstra-no-queue-no-lists",
                "content": "The Dynamic Programming array `dp[]`, for any node `i`, `dp[i]` contains the probability of reaching that node from the `start` node.  Initially `dp[]` is all zeroes, except for the start node, where `dp[start]=1.0`, because the probability of reaching the start node from the same start node is 1.0.\\n\\nThe algorithm repeatedly processes **all** of the edges, to update the probabilities in the `dp[]` array, until there are no more update changes to `dp[]`.  To process the edges, for each edge, that edge has the two end nodes and a probability.  If the probability multiplied by an end node\\'s `dp[]` value is greater than the other end node\\'s `dp[]` value, than update the other end node\\'s `dp[]` value.  Also try this update by reversing the nodes.  When all nodes are processed, but no update changes have happened, then all of the probabilities in `dp[]` are complete with the maximum probability of reaching each node on the graph, starting from the `start` node.  So we simply return the maximum probability of reaching the end node, which is `dp[end]`.\\n\\nUsing this method with the current June 2023 test cases, the `while` loop in the code below, will be repeated a maximum of 17 times for the worst case problem, because the longest minimum path through any test case\\'s graph to reach the farthest node is 16 edges, plus one more time through the loop to realize there are no more probability updates.  If the longest minimum number of edges starting from `start` to reach all other node in the graph is `longestMinEdges`, then this code has runtime of **O(edges.length\\\\*longestMinEdges)**.  So the worst case test case for this DP solution would be a graph with 10_000 nodes, with `start` at node 0, and `end` at node 9_999, with edges only from a node to the next higher node number.  This would result in a path of 9_999 edges needing to be traversed to get from `start` to `end`.  In the code below, the `while` loop would be repeated 10_000 times, which would require processing all of the 9_999 edges 10_000 times.  But fortunately, the test cases only have a longest minimum number of edges from `start` to all other nodes, being 17.  So this DP solution runs fast until someone creates the worst case test case.\\n\\nThis code has a runtime of 9ms in June 2023.  Runtime 10ms in August 2023, with new test cases.\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, \\n                                 int start, int end) {\\n        double dp[] = new double[n];\\n        dp[start] = 1.0;\\n        boolean changes = true;\\n        while (changes) {\\n            changes = false;\\n            for (int edgeIdx = edges.length - 1; edgeIdx >= 0; edgeIdx--) {\\n                int u = edges[edgeIdx][0];\\n                int v = edges[edgeIdx][1];\\n                double prob = succProb[edgeIdx];\\n                if (dp[v] * prob > dp[u]) {\\n                    dp[u] = dp[v] * prob;\\n                    changes = true;\\n                }\\n                if (dp[u] * prob > dp[v]) {\\n                    dp[v] = dp[u] * prob;\\n                    changes = true;\\n                }\\n            }\\n        }\\n        return dp[end];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, \\n                                 int start, int end) {\\n        double dp[] = new double[n];\\n        dp[start] = 1.0;\\n        boolean changes = true;\\n        while (changes) {\\n            changes = false;\\n            for (int edgeIdx = edges.length - 1; edgeIdx >= 0; edgeIdx--) {\\n                int u = edges[edgeIdx][0];\\n                int v = edges[edgeIdx][1];\\n                double prob = succProb[edgeIdx];\\n                if (dp[v] * prob > dp[u]) {\\n                    dp[u] = dp[v] * prob;\\n                    changes = true;\\n                }\\n                if (dp[u] * prob > dp[v]) {\\n                    dp[v] = dp[u] * prob;\\n                    changes = true;\\n                }\\n            }\\n        }\\n        return dp[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694214,
                "title": "c-solution-maxheap-in-graph-easy-explaination",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a visited array of size n to keep track of visited vertices. Initially, all elements are set to false.\\n\\n2. Create a `graph` vector of vectors to represent the adjacency list of the graph. Each element of the graph vector is a pair representing an edge: the first value is the neighbor vertex, and the second value is the probability of the edge.\\n\\n3. Iterate over the edges vector and populate the graph vector accordingly. For each edge, retrieve the source vertex `u`, target vertex `v`, and success probability `p`. Add the pair `{v, p}` to the adjacency list of u, and vice versa since the graph is undirected.\\n\\n4. Create a `probas` vector of size n to store the probabilities of reaching each vertex from the start vertex. Initialize all elements to 0.0, except for the start vertex, which is set to 1.0.\\n\\n5. Create a priority queue (`pq`) of pairs, where the first value is the probability and the second value is the vertex. Push the pair {1.0, start} onto the priority queue to start the exploration from the start vertex with a probability of 1.0.\\nPerform a loop while the priority queue is not empty.\\n\\n6. Extract the pair with the highest probability from the priority queue. Assign the probability to p and the vertex to curr.\\nIf the current vertex is equal to the end vertex, return the probability since we have found the maximum probability path.\\nIf the current vertex has already been visited, skip the rest of the loop and continue to the next iteration.\\n7. Mark the current vertex as visited by setting `visi[curr]` to true.\\nIterate over the neighbors of the current vertex using a range-based for loop.\\n8. Retrieve the neighbor vertex nbh and the probability of the edge connecting the current vertex to the neighbor vertex (`edgeProb`).\\nCalculate the new probability (`newProb`) by multiplying the current probability p with the edge probability edgeProb.\\n9. If the new probability is greater than the previously stored probability in the probas array for the neighbor vertex, update the probability in the probas array and push the pair `{newProb, nbh}` onto the priority queue.\\n10. If no path from the start to the end vertex is found, return 0.0.\\n\\n# Complexity\\n Let $$n$$ be the number of nodes and $$m$$ be the number of edges.\\n- Time complexity:$$O(m+n\\u22C5logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<bool> visi(n,false);\\n\\n        vector<vector<pair<int,double>>> graph(n);\\n\\n        for(int i=0;i<edges.size();i++){\\n            \\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n\\n            double p=succProb[i];\\n\\n            graph[u].push_back({v,p});\\n            graph[v].push_back({u,p});\\n\\n        }\\n\\n        vector<double> probas(n,0.0);\\n\\n        probas[start]=1;\\n\\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1.0, start});\\n\\n\\n        while(!pq.empty()){\\n\\n            double p=pq.top().first;\\n            int curr=pq.top().second;\\n             pq.pop();\\n\\n            if(curr==end){\\n                return p;\\n            } \\n\\n            if(visi[curr]){\\n                continue;\\n            }\\n\\n            visi[curr]=true;\\n\\n            for(auto next:graph[curr]){\\n\\n                int nbh=next.first;\\n                double edgeProb=next.second;\\n                double newProb=p*edgeProb;\\n\\n                if(newProb>probas[nbh]){\\n                    probas[nbh]=newProb;\\n                    pq.push({newProb,nbh});\\n                }\\n            }\\n\\n        }\\n\\n// If no path from start to end is found\\n    return 0.0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<bool> visi(n,false);\\n\\n        vector<vector<pair<int,double>>> graph(n);\\n\\n        for(int i=0;i<edges.size();i++){\\n            \\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n\\n            double p=succProb[i];\\n\\n            graph[u].push_back({v,p});\\n            graph[v].push_back({u,p});\\n\\n        }\\n\\n        vector<double> probas(n,0.0);\\n\\n        probas[start]=1;\\n\\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1.0, start});\\n\\n\\n        while(!pq.empty()){\\n\\n            double p=pq.top().first;\\n            int curr=pq.top().second;\\n             pq.pop();\\n\\n            if(curr==end){\\n                return p;\\n            } \\n\\n            if(visi[curr]){\\n                continue;\\n            }\\n\\n            visi[curr]=true;\\n\\n            for(auto next:graph[curr]){\\n\\n                int nbh=next.first;\\n                double edgeProb=next.second;\\n                double newProb=p*edgeProb;\\n\\n                if(newProb>probas[nbh]){\\n                    probas[nbh]=newProb;\\n                    pq.push({newProb,nbh});\\n                }\\n            }\\n\\n        }\\n\\n// If no path from start to end is found\\n    return 0.0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693999,
                "title": "python-bfs-solution-with-intuition-and-approach",
                "content": "# Intuition and Approach\\nStart by building a `hashmap (graph)`, where `key` is the `node` and value is the value of `(probability, neighbor_node)`\\n\\nNext just like in a `standard breadth first search` we use a `queue` in this we will use a `priority queue` aka a `maxHeap`.\\n\\nKeep a dictionary `dist` to keep track of value of `probability` it took to reach the node. (Remember the probability of our `start` node is `1` as in maximum).\\n\\nEverytime we pop from `minHeap` we have 2 options. If the node has never been visited before according to our `dist` dictionary, then we will multiply `current node\\'s probability` and the `node we are trying to visit\\'s probability` and add them to our `heap` and `dist` dictionary.\\nOtherwise if the multiplication of `current node\\'s probability` and the `node we are trying to visit\\'s probability` is greater than the value in our dictionary then we update the value and add the node to our `heap`.\\nIn summary this is the implementation of `Djikstra\\'s shortest path algorithm`.\\n\\nNote: In python there is no maxHeap, so we have to negate our values to pretend like we are using the maximum. For example `prob=1` becomes `prob=-1`\\n\\n# Complexity\\n- Time complexity:\\nE*logV (Time complexity of Djikstra)\\n\\n- Space complexity:\\nO(edges + n) Since to build the graph we atleast need to store n nodes and it\\'s edges.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        def build_graph(n, edges, probability):\\n            graph = {}\\n            for i in range(n):\\n                graph[i] = []\\n            for i in range(len(edges)):\\n                frm, to = edges[i]\\n                graph[frm].append((probability[i], to))\\n                graph[to].append((probability[i], frm))\\n            return graph\\n        def bfs(graph):\\n            import heapq as hq\\n            dist = {start:-1}\\n            heap = [(-1, start)]\\n            hq.heapify(heap)\\n            while len(heap) > 0:\\n                prob, node = hq.heappop(heap)\\n                for child in graph[node]:\\n                    p,c = child\\n                    if c in dist:\\n                        if abs(p*prob) > abs(dist[c]):\\n                            hq.heappush(heap, (-abs(p*prob), c))\\n                            dist[c] = -abs(p*prob)\\n                    else:\\n                        hq.heappush(heap, (-abs(p * prob), c))\\n                        dist[c] = -abs(p * prob)\\n            return 0 if end not in dist else -dist[end]\\n\\n        return bfs(build_graph(n, edges, succProb))\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        def build_graph(n, edges, probability):\\n            graph = {}\\n            for i in range(n):\\n                graph[i] = []\\n            for i in range(len(edges)):\\n                frm, to = edges[i]\\n                graph[frm].append((probability[i], to))\\n                graph[to].append((probability[i], frm))\\n            return graph\\n        def bfs(graph):\\n            import heapq as hq\\n            dist = {start:-1}\\n            heap = [(-1, start)]\\n            hq.heapify(heap)\\n            while len(heap) > 0:\\n                prob, node = hq.heappop(heap)\\n                for child in graph[node]:\\n                    p,c = child\\n                    if c in dist:\\n                        if abs(p*prob) > abs(dist[c]):\\n                            hq.heappush(heap, (-abs(p*prob), c))\\n                            dist[c] = -abs(p*prob)\\n                    else:\\n                        hq.heappush(heap, (-abs(p * prob), c))\\n                        dist[c] = -abs(p * prob)\\n            return 0 if end not in dist else -dist[end]\\n\\n        return bfs(build_graph(n, edges, succProb))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693539,
                "title": "c-solution-using-dijkstra-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n\\t\\tvector<vector<pair<int, double>>> graph(n, vector<pair<int, double>>());\\n        for(int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            graph[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n    \\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1, start});\\n        \\n        vector<double> nodeProbsArr(n);\\n        nodeProbsArr[start] = 1;\\n        \\n        while(!pq.empty()) {\\n            \\n            auto tp = pq.top();\\n            pq.pop(); \\n            double currNodeProb = tp.first;\\n            int currNode = tp.second;\\n            \\n            if(currNode == end) return currNodeProb;\\n            \\n            for(auto neighbour: graph[currNode]) {\\n                \\n                int nextNode = neighbour.first;\\n                double nextNodeProb = neighbour.second;\\n                if(nodeProbsArr[nextNode] < nextNodeProb*currNodeProb) {\\n                    nodeProbsArr[nextNode] = nextNodeProb*currNodeProb;\\n                    pq.push({nodeProbsArr[nextNode], nextNode});\\n                }\\n                \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n\\t\\tvector<vector<pair<int, double>>> graph(n, vector<pair<int, double>>());\\n        for(int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            graph[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n    \\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1, start});\\n        \\n        vector<double> nodeProbsArr(n);\\n        nodeProbsArr[start] = 1;\\n        \\n        while(!pq.empty()) {\\n            \\n            auto tp = pq.top();\\n            pq.pop(); \\n            double currNodeProb = tp.first;\\n            int currNode = tp.second;\\n            \\n            if(currNode == end) return currNodeProb;\\n            \\n            for(auto neighbour: graph[currNode]) {\\n                \\n                int nextNode = neighbour.first;\\n                double nextNodeProb = neighbour.second;\\n                if(nodeProbsArr[nextNode] < nextNodeProb*currNodeProb) {\\n                    nodeProbsArr[nextNode] = nextNodeProb*currNodeProb;\\n                    pq.push({nodeProbsArr[nextNode], nextNode});\\n                }\\n                \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693486,
                "title": "c-super-easy-max-heap-dijkstra-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<int,double>> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double prob = succProb[i];\\n\\n            adj[u].push_back({v,prob});\\n            adj[v].push_back({u,prob});\\n        }\\n        \\n        double prob[10001] = {0};\\n        prob[start] = 1.0;\\n\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0,start});\\n\\n        while(!pq.empty()){\\n            double p = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n\\n            if(node == end) return prob[end];\\n\\n            for(auto it : adj[node]){\\n                int nbr = it.first;\\n                double np = it.second;\\n\\n                if(prob[nbr] < p * np){\\n                    prob[nbr] = p * np;\\n                    pq.push({prob[nbr],nbr});\\n                }\\n\\n            }\\n        }\\n\\n        return prob[end];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        \\n        vector<pair<int,double>> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            double prob = succProb[i];\\n\\n            adj[u].push_back({v,prob});\\n            adj[v].push_back({u,prob});\\n        }\\n        \\n        double prob[10001] = {0};\\n        prob[start] = 1.0;\\n\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0,start});\\n\\n        while(!pq.empty()){\\n            double p = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n\\n            if(node == end) return prob[end];\\n\\n            for(auto it : adj[node]){\\n                int nbr = it.first;\\n                double np = it.second;\\n\\n                if(prob[nbr] < p * np){\\n                    prob[nbr] = p * np;\\n                    pq.push({prob[nbr],nbr});\\n                }\\n\\n            }\\n        }\\n\\n        return prob[end];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693473,
                "title": "c-easy-dijsktra",
                "content": "\\n# Complexity\\n- Time complexity:\\n  O(N+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> pro(n+1,-1e5);\\n        vector<pair<int,double>> adj[n+1];\\n        for(int i  = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        queue<pair<int,double>> q;\\n        q.push({start,1});\\n        pro[start] = 1;\\n        while(!q.empty()){\\n            auto node = q.front().first;\\n            auto p = q.front().second;\\n            q.pop();\\n            for(auto i: adj[node]){\\n                auto cnode = i.first;\\n                auto cp = i.second;\\n                if(p*cp>pro[cnode]){\\n                    pro[cnode] = p*cp;\\n                    q.push({cnode,pro[cnode]});\\n                }\\n            }\\n        }\\n        return pro[end]== -1e5 ? 0: pro[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> pro(n+1,-1e5);\\n        vector<pair<int,double>> adj[n+1];\\n        for(int i  = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        queue<pair<int,double>> q;\\n        q.push({start,1});\\n        pro[start] = 1;\\n        while(!q.empty()){\\n            auto node = q.front().first;\\n            auto p = q.front().second;\\n            q.pop();\\n            for(auto i: adj[node]){\\n                auto cnode = i.first;\\n                auto cp = i.second;\\n                if(p*cp>pro[cnode]){\\n                    pro[cnode] = p*cp;\\n                    q.push({cnode,pro[cnode]});\\n                }\\n            }\\n        }\\n        return pro[end]== -1e5 ? 0: pro[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693137,
                "title": "1514-path-with-maximum-probability-java",
                "content": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        double[] prob=new double[n];\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->Double.compare(prob[b],prob[a]));\\n        List<int []>[]adj=new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            adj[i]=new ArrayList();\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj[edges[i][0]].add(new int []{edges[i][1],i});\\n            adj[edges[i][1]].add(new int []{edges[i][0],i});\\n        }\\n        prob[start]=1;\\n        pq.offer(start);\\n        while(!pq.isEmpty())\\n        {\\n            int cur=pq.poll();\\n            for(int [] x:adj[cur])\\n            {\\n                if(prob[cur]*succProb[x[1]]>prob[x[0]])\\n                {\\n                    prob[x[0]]=prob[cur]*succProb[x[1]];\\n                    pq.offer(x[0]);\\n                }\\n            }\\n        }\\n        return prob[end];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        double[] prob=new double[n];\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->Double.compare(prob[b],prob[a]));\\n        List<int []>[]adj=new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            adj[i]=new ArrayList();\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj[edges[i][0]].add(new int []{edges[i][1],i});\\n            adj[edges[i][1]].add(new int []{edges[i][0],i});\\n        }\\n        prob[start]=1;\\n        pq.offer(start);\\n        while(!pq.isEmpty())\\n        {\\n            int cur=pq.poll();\\n            for(int [] x:adj[cur])\\n            {\\n                if(prob[cur]*succProb[x[1]]>prob[x[0]])\\n                {\\n                    prob[x[0]]=prob[cur]*succProb[x[1]];\\n                    pq.offer(x[0]);\\n                }\\n            }\\n        }\\n        return prob[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693122,
                "title": "finding-path-w-maximum-probability-of-success-in-an-undirected-weighted-graph-using-djikstra-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse Dijkstra\\'s algorithm to find the path with the maximum probability of success in an undirected weighted graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an adjacency list to represent the graph. Populate it with the edges and corresponding success probabilities.\\n2. Initialize an array to store the maximum probabilities for each vertex. Set the starting vertex\\'s probability to 1.\\n3. Create a priority queue to store vertices based on their maximum probabilities.\\n4. Start from the starting vertex and traverse the graph using Dijkstra\\'s algorithm:\\n    - At each vertex, calculate the new probability by multiplying the current probability with the edge success probability.\\n    - If the new probability is greater than the previous maximum probability for the next vertex, update it and add the next vertex to the priority queue.\\n5. Return the maximum probability for the end vertex if a path exists, otherwise return 0.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(E log V)$$, where E is the number of edges and V is the number of vertices.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(V)$$, where V is the number of vertices\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} succProb\\n * @param {number} start\\n * @param {number} end\\n * @return {number}\\n */\\nvar maxProbability = function(n, edges, succProb, start, end) {\\n   const graph =  new Array(n).fill(null).map(()=>[]);\\n\\n   for(let i=0;i<edges.length;i++){\\n     const [a, b] = edges[i];\\n     graph[a].push([b, succProb[i]]);\\n     graph[b].push([a, succProb[i]])\\n   } \\n   const maxProb = new Array(n).fill(0);\\n\\n   maxProb[start] = 1;\\n\\n   const queue = [[start, 1]];\\n\\n   while(queue.length>0){\\n     const [current, currentProb] = queue.shift();\\n\\n     if(current === end){\\n       return currentProb;\\n     }\\n     for(const[next, prob] of graph[current]){\\n       const newProb = currentProb * prob;\\n\\n       if(newProb > maxProb[next]){\\n         maxProb[next] = newProb;\\n         queue.push([next, newProb]);\\n       }\\n     }\\n     queue.sort((a, b) =>{\\n       return b[1]-a[1];\\n     })\\n   }\\n   return 0;\\n};\\n```\\n![Untitled.jpg](https://assets.leetcode.com/users/images/bfd1f637-ebd5-4fae-9617-3936b93a15a6_1687957848.0458975.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} succProb\\n * @param {number} start\\n * @param {number} end\\n * @return {number}\\n */\\nvar maxProbability = function(n, edges, succProb, start, end) {\\n   const graph =  new Array(n).fill(null).map(()=>[]);\\n\\n   for(let i=0;i<edges.length;i++){\\n     const [a, b] = edges[i];\\n     graph[a].push([b, succProb[i]]);\\n     graph[b].push([a, succProb[i]])\\n   } \\n   const maxProb = new Array(n).fill(0);\\n\\n   maxProb[start] = 1;\\n\\n   const queue = [[start, 1]];\\n\\n   while(queue.length>0){\\n     const [current, currentProb] = queue.shift();\\n\\n     if(current === end){\\n       return currentProb;\\n     }\\n     for(const[next, prob] of graph[current]){\\n       const newProb = currentProb * prob;\\n\\n       if(newProb > maxProb[next]){\\n         maxProb[next] = newProb;\\n         queue.push([next, newProb]);\\n       }\\n     }\\n     queue.sort((a, b) =>{\\n       return b[1]-a[1];\\n     })\\n   }\\n   return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692227,
                "title": "minor-change-in-djikstra-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn djikstra, we choose the node having minimum distance from source in every iteration but here,we ned to choose the path having largest probability.\\n**so,we just need to replace MIN HEAP with MAX HEAP**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSame as Djikstra but use MAX HEAP instead of MIN heap and choose the path with highest probabilty in every iteration.\\n# Complexity\\n- Time complexity: ElogE\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<double>>adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(succProb[i]!=0)adj[edges[i][0]].push_back({(double)edges[i][1],succProb[i]});\\n            if(succProb[i]!=0)adj[edges[i][1]].push_back({(double)edges[i][0],succProb[i]});\\n        }\\n        //In djikstra we use MIN HEAP,here we use MAX heap\\n        priority_queue<pair<double,double>>pq;\\n        vector<double>dist(n,0);\\n        dist[start]=1;\\n        pq.push({1,start});\\n        while(!pq.empty())\\n        {\\n            auto it =pq.top();\\n            double node = it.second;\\n            double cost = it.first;\\n            pq.pop();\\n            if(dist[node]>cost)continue;\\n            for(auto it:adj[(int)node])\\n            {\\n                //In djikstra we change dist if we encounter a smaller \\n                //distance but here we change dist if we encounter \\n                // higher probability\\n                if(cost*it[1] > dist[it[0]])\\n                {\\n                    dist[it[0]] = cost*it[1];\\n                    pq.push({dist[it[0]],it[0]});\\n                }\\n            }\\n        }\\n        return dist[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<double>>adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(succProb[i]!=0)adj[edges[i][0]].push_back({(double)edges[i][1],succProb[i]});\\n            if(succProb[i]!=0)adj[edges[i][1]].push_back({(double)edges[i][0],succProb[i]});\\n        }\\n        //In djikstra we use MIN HEAP,here we use MAX heap\\n        priority_queue<pair<double,double>>pq;\\n        vector<double>dist(n,0);\\n        dist[start]=1;\\n        pq.push({1,start});\\n        while(!pq.empty())\\n        {\\n            auto it =pq.top();\\n            double node = it.second;\\n            double cost = it.first;\\n            pq.pop();\\n            if(dist[node]>cost)continue;\\n            for(auto it:adj[(int)node])\\n            {\\n                //In djikstra we change dist if we encounter a smaller \\n                //distance but here we change dist if we encounter \\n                // higher probability\\n                if(cost*it[1] > dist[it[0]])\\n                {\\n                    dist[it[0]] = cost*it[1];\\n                    pq.push({dist[it[0]],it[0]});\\n                }\\n            }\\n        }\\n        return dist[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692162,
                "title": "beats-95-c-beginner-friendly-please-do-give-me-an-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Implement the shortest path algorithm with a slight change in conditions. We have to maximize the total probabilty by multiplying as we traverse through any edge.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Same as Dijkstra\\'s alogrithm using priority queue (max heap) to get the maximum probability, apply the dijkstra\\'s Algorithm. Make probabilty of start node equal to 1 and all other nodes equal to -1e6 (similar to distance array in Dijkstra\\'s). Since it is a max heap, we get the maximum probabilty. Just multiply each probabilty as you traverse through any edge in the path.\\n\\n# Complexity\\n- Time complexity:       E*log(V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:      E*V\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\npair<double, int> pi;\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n       vector<pair<int,double>>adj[n];\\n       int e=edges.size();\\n       vector<double>prob(n,-1e5);\\n       prob[start]=1;\\n       for(int i=0;i<e;i++){\\n           adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n           adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n       }\\npriority_queue<pair<double,int>> pq;\\npq.push({1,start});\\nwhile(!pq.empty()){\\n    int node=pq.top().second;\\n    double p=pq.top().first;\\n    pq.pop();\\n    if(node==end)return p;\\n    for(auto it:adj[node]){\\nif(prob[it.first]<p*(it.second)){\\n    prob[it.first]=p*(it.second);\\n    pq.push({prob[it.first],it.first});\\n}\\n    }\\n}\\nreturn 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\npair<double, int> pi;\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n       vector<pair<int,double>>adj[n];\\n       int e=edges.size();\\n       vector<double>prob(n,-1e5);\\n       prob[start]=1;\\n       for(int i=0;i<e;i++){\\n           adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n           adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n       }\\npriority_queue<pair<double,int>> pq;\\npq.push({1,start});\\nwhile(!pq.empty()){\\n    int node=pq.top().second;\\n    double p=pq.top().first;\\n    pq.pop();\\n    if(node==end)return p;\\n    for(auto it:adj[node]){\\nif(prob[it.first]<p*(it.second)){\\n    prob[it.first]=p*(it.second);\\n    pq.push({prob[it.first],it.first});\\n}\\n    }\\n}\\nreturn 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692012,
                "title": "ruby-dp",
                "content": "# Intuition\\nDP\\n\\n# Approach\\nDP\\n\\n# Code\\n```ruby\\nrequire \\'set\\'\\n\\nclass Array\\n    def add_edge(a, b, w)\\n        self[a] << [b, w]\\n        self[b] << [a, w]\\n    end\\nend\\n\\nclass Solver\\n    attr_reader :n, :edges, :succ_prob, :neighbs\\n    def initialize(n, edges, succ_prob)\\n        @n, @edges, @succ_prob = n, edges, succ_prob\\n        @neighbs = edges.each_with_index.each_with_object(Array.new(n) {|_| Array.new }) {|((a, b), idx), res| \\n            res.add_edge(a, b, succ_prob[idx])\\n        }\\n    end\\n\\n    def solve(s, e)\\n        (dp = Array.new(n))[s] = 1.0\\n        cur = [s]\\n        until cur.empty? do\\n            cur = cur.inject(Set[]) {|res, c|\\n                res.merge(neighbs[c].filter {|(ne, w)| \\n                        dp[ne].nil? || dp[c] * w > dp[ne] \\n                    }.collect {|(ne, w)|\\n                            dp[ne] = dp[c] * w\\n                            ne\\n                    })\\n            }\\n        end\\n        dp[e]\\n    end\\nend\\n\\ndef max_probability(n, edges, succ_prob, s, e)\\n    Solver.new(n, edges, succ_prob).solve(s, e) || 0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nrequire \\'set\\'\\n\\nclass Array\\n    def add_edge(a, b, w)\\n        self[a] << [b, w]\\n        self[b] << [a, w]\\n    end\\nend\\n\\nclass Solver\\n    attr_reader :n, :edges, :succ_prob, :neighbs\\n    def initialize(n, edges, succ_prob)\\n        @n, @edges, @succ_prob = n, edges, succ_prob\\n        @neighbs = edges.each_with_index.each_with_object(Array.new(n) {|_| Array.new }) {|((a, b), idx), res| \\n            res.add_edge(a, b, succ_prob[idx])\\n        }\\n    end\\n\\n    def solve(s, e)\\n        (dp = Array.new(n))[s] = 1.0\\n        cur = [s]\\n        until cur.empty? do\\n            cur = cur.inject(Set[]) {|res, c|\\n                res.merge(neighbs[c].filter {|(ne, w)| \\n                        dp[ne].nil? || dp[c] * w > dp[ne] \\n                    }.collect {|(ne, w)|\\n                            dp[ne] = dp[c] * w\\n                            ne\\n                    })\\n            }\\n        end\\n        dp[e]\\n    end\\nend\\n\\ndef max_probability(n, edges, succ_prob, s, e)\\n    Solver.new(n, edges, succ_prob).solve(s, e) || 0\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691860,
                "title": "c-3-and-half-solutions-dijkstra-s-spfa-bellman-ford-dfs",
                "content": "# DFS (hits TLE)\\nLet\\'s start with a brute-force DFS. But it hits TLE :(\\n```\\nclass Solution {\\n    double dfs(vector<vector<pair<int, double>>>& adj, int cur, int end, double prob, vector<bool>& visited) {\\n        if (cur == end || prob == 0.0) {\\n            return prob;\\n        }\\n\\n        visited[cur] = true;\\n\\n        double pmax = 0.0;\\n        for (auto [nbr, nprob] : adj[cur]) {\\n            if (!visited[nbr]) {\\n                pmax = max(pmax, dfs(adj, nbr, end, prob * nprob, visited));\\n            }\\n        }\\n\\n        visited[cur] = false;\\n\\n        return pmax;\\n\\n    }\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adj(n);\\n        for (int i = 0; i < edges.size(); ++i) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        return dfs(adj, start, end, 1.0, visited);\\n    }\\n};\\n```\\n\\n\\n# Bellman-Ford\\nBrute force did not work. Let\\'s bring on DP.\\n\\nWhat to memoize?\\nMax probability of each node.\\n\\nSeed values?\\nMax probability of ```start``` node is 1, rest 0.\\n\\nHow to tabulate, in which order?\\nRun through each edge and check if it can increase the probability (relax) of any of the ends. Keep repeating till no increase in probability happens any more.\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> max_prob(n, 0.0);\\n        max_prob[start] = 1.0;\\n\\n        auto relax = [&](int s, int d, double p) -> bool {\\n            double prob = max_prob[s] * p;\\n            if (prob > max_prob[d]) {\\n                max_prob[d] = prob;\\n                return true;\\n            }\\n            return false;\\n        };\\n\\n        bool relaxed = true;\\n        for (int i = 0; (i < n - 1) && (relaxed == true); ++i) {\\n            relaxed = false;\\n            for (int j = 0; j < edges.size(); ++j) {\\n                if (relax(edges[j][0], edges[j][1], succProb[j])) relaxed = true;\\n                if (relax(edges[j][1], edges[j][0], succProb[j])) relaxed = true;\\n            }\\n        }\\n\\n        return max_prob[end];\\n    }\\n};\\n```\\n\\n# Shortest Path Faster Algo (SPFA)\\nTry optimizing the order of edge traversal of Bellman-Ford. Start with the ```start``` node in a queue. Iterate over its outgoing edges and check if the probability of the neighbor can be increased. If yes, put the neighbor in the queue. Keep repeating untill the queue is empty. \\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adj(n);\\n        for (int i = 0; i < edges.size(); ++i) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n\\n        vector<double> max_prob(n, 0.0);\\n        max_prob[start] = 1.0;\\n\\n        queue<int> q;\\n        q.push(start);\\n\\n        while (!q.empty()) {\\n            auto cur = q.front(); q.pop();\\n            double cprob = max_prob[cur];\\n            for (auto [nbr, nprob] : adj[cur]) {\\n                auto prob = cprob * nprob;\\n                if (prob > max_prob[nbr]) {\\n                    max_prob[nbr] = prob;\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n\\n        return max_prob[end];\\n\\n    }\\n};\\n```\\n\\n\\n\\n# Dijkstra\\'s\\nLet\\'s finish with the classic. Instead of iterating over the edges in an arbitrary manner, process the edges in the order of the source node\\'s probability. Use a heap to extract the node with highest probability quickly.\\n\\nA node\\'s probability may get increased while it is already in somewhere down the heap. We need to bring the node up to its proper position in the heap based on its increased priority. Normal C++ priority_queue does not have a facility to do this efficiently. We can use something called as an indexed priority queue or a Fibonacci heap. But implementing them in an interview could be too much. Instead, keep track of nodes that are already visited. If a node has already been visited (with a higher probability value) we need not visit it again (with a lower probability value that got added to the heap at an earlier time). However, if the probability of a node gets increased, it needs to be visited again even if it was visited earlier (with a lower probability value).\\n\\n``` \\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adj(n);\\n        for (int i = 0; i < edges.size(); ++i) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n\\n        vector<double> max_prob(n, 0.0);\\n        max_prob[start] = 1.0;\\n\\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1.0, start});\\n\\n        vector<bool> visited(n, false);\\n\\n        while (!pq.empty()) {\\n            auto [_, cur] = pq.top(); pq.pop();\\n            if (visited[cur]) continue;\\n            visited[cur] = true;\\n            double cprob = max_prob[cur];\\n            for (auto [nbr, nprob] : adj[cur]) {\\n                auto prob = cprob * nprob;\\n                if (prob > max_prob[nbr]) {\\n                    max_prob[nbr] = prob;\\n                    visited[nbr] = false; // Priority increased.\\n                    pq.push({max_prob[nbr], nbr});\\n                }\\n            }\\n        }\\n\\n        return max_prob[end];\\n\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    double dfs(vector<vector<pair<int, double>>>& adj, int cur, int end, double prob, vector<bool>& visited) {\\n        if (cur == end || prob == 0.0) {\\n            return prob;\\n        }\\n\\n        visited[cur] = true;\\n\\n        double pmax = 0.0;\\n        for (auto [nbr, nprob] : adj[cur]) {\\n            if (!visited[nbr]) {\\n                pmax = max(pmax, dfs(adj, nbr, end, prob * nprob, visited));\\n            }\\n        }\\n\\n        visited[cur] = false;\\n\\n        return pmax;\\n\\n    }\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adj(n);\\n        for (int i = 0; i < edges.size(); ++i) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        return dfs(adj, start, end, 1.0, visited);\\n    }\\n};\\n```\n```start```\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double> max_prob(n, 0.0);\\n        max_prob[start] = 1.0;\\n\\n        auto relax = [&](int s, int d, double p) -> bool {\\n            double prob = max_prob[s] * p;\\n            if (prob > max_prob[d]) {\\n                max_prob[d] = prob;\\n                return true;\\n            }\\n            return false;\\n        };\\n\\n        bool relaxed = true;\\n        for (int i = 0; (i < n - 1) && (relaxed == true); ++i) {\\n            relaxed = false;\\n            for (int j = 0; j < edges.size(); ++j) {\\n                if (relax(edges[j][0], edges[j][1], succProb[j])) relaxed = true;\\n                if (relax(edges[j][1], edges[j][0], succProb[j])) relaxed = true;\\n            }\\n        }\\n\\n        return max_prob[end];\\n    }\\n};\\n```\n```start```\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adj(n);\\n        for (int i = 0; i < edges.size(); ++i) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n\\n        vector<double> max_prob(n, 0.0);\\n        max_prob[start] = 1.0;\\n\\n        queue<int> q;\\n        q.push(start);\\n\\n        while (!q.empty()) {\\n            auto cur = q.front(); q.pop();\\n            double cprob = max_prob[cur];\\n            for (auto [nbr, nprob] : adj[cur]) {\\n                auto prob = cprob * nprob;\\n                if (prob > max_prob[nbr]) {\\n                    max_prob[nbr] = prob;\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n\\n        return max_prob[end];\\n\\n    }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adj(n);\\n        for (int i = 0; i < edges.size(); ++i) {\\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n\\n        vector<double> max_prob(n, 0.0);\\n        max_prob[start] = 1.0;\\n\\n        priority_queue<pair<double, int>> pq;\\n        pq.push({1.0, start});\\n\\n        vector<bool> visited(n, false);\\n\\n        while (!pq.empty()) {\\n            auto [_, cur] = pq.top(); pq.pop();\\n            if (visited[cur]) continue;\\n            visited[cur] = true;\\n            double cprob = max_prob[cur];\\n            for (auto [nbr, nprob] : adj[cur]) {\\n                auto prob = cprob * nprob;\\n                if (prob > max_prob[nbr]) {\\n                    max_prob[nbr] = prob;\\n                    visited[nbr] = false; // Priority increased.\\n                    pq.push({max_prob[nbr], nbr});\\n                }\\n            }\\n        }\\n\\n        return max_prob[end];\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691817,
                "title": "c-bfs-easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double>v(n+1,0);\\n\\n        vector<pair<int,double>>adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n\\n        }\\n\\n        priority_queue<pair<double,int>>pq;\\n        v[start]=1;\\n        pq.push({1,start});\\n        while(!pq.empty()){\\n           int node=pq.top().second;\\n           double p=pq.top().first;\\n           pq.pop();\\n\\n           for(auto it:adj[node]){\\n               if(v[it.first]<(it.second*v[node])){\\n                   v[it.first]=(it.second*v[node]);\\n                   pq.push({v[it.first],it.first});\\n               }\\n           }\\n        }\\n        return v[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<double>v(n+1,0);\\n\\n        vector<pair<int,double>>adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n\\n        }\\n\\n        priority_queue<pair<double,int>>pq;\\n        v[start]=1;\\n        pq.push({1,start});\\n        while(!pq.empty()){\\n           int node=pq.top().second;\\n           double p=pq.top().first;\\n           pq.pop();\\n\\n           for(auto it:adj[node]){\\n               if(v[it.first]<(it.second*v[node])){\\n                   v[it.first]=(it.second*v[node]);\\n                   pq.push({v[it.first],it.first});\\n               }\\n           }\\n        }\\n        return v[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691787,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        weights=list(map(lambda x:-math.log2(x),succProb))\\n        graph=defaultdict(list)\\n        for (u,v),w in zip(edges,weights):\\n            graph[u].append([v,w])\\n            graph[v].append([u,w])\\n\\n        dist={}\\n        q=[(0,start)]\\n        while q:\\n            w,u=heapq.heappop(q)\\n            if u in dist:\\n                continue\\n\\n            dist[u]=w\\n            if u==end:\\n                break\\n\\n            for v,w in graph[u]:\\n                if v not in dist or dist[v]>dist[u]+w:\\n                    heapq.heappush(q,(dist[u]+w,v))\\n\\n        return 2**(-dist[end]) if end in dist else 0.0                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        weights=list(map(lambda x:-math.log2(x),succProb))\\n        graph=defaultdict(list)\\n        for (u,v),w in zip(edges,weights):\\n            graph[u].append([v,w])\\n            graph[v].append([u,w])\\n\\n        dist={}\\n        q=[(0,start)]\\n        while q:\\n            w,u=heapq.heappop(q)\\n            if u in dist:\\n                continue\\n\\n            dist[u]=w\\n            if u==end:\\n                break\\n\\n            for v,w in graph[u]:\\n                if v not in dist or dist[v]>dist[u]+w:\\n                    heapq.heappush(q,(dist[u]+w,v))\\n\\n        return 2**(-dist[end]) if end in dist else 0.0                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691569,
                "title": "2588ms-long-typescript-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet dijkstra = (n: number, map: any, s: number, d: number) => {\\n    let visited = new Array(n).fill(0);\\n    let costs = new Array(n).fill(0);\\n    costs[s] = 1;\\n    while(true) {\\n        let node;\\n        for(let i=0; i<visited.length; i++) {\\n            if(visited[i]) continue;\\n            if(node === undefined) node = i;\\n            else node = costs[node] < costs[i] ? i: node;\\n        }\\n        if(node === undefined) break;\\n        if(node === d) return costs[d];\\n        visited[node] = 1;\\n        if(map[node] === undefined) continue;\\n        let adjNodes = Object.keys(map[node]);\\n        for(let adj of adjNodes) {\\n            if(visited[adj]) continue;\\n            let w = map[node][adj] * costs[node];\\n            costs[adj] = Math.max(costs[adj], w);\\n        }\\n    }\\n    return costs[d];\\n}\\n\\nfunction maxProbability(n: number, edges: number[][], succProb: number[], start: number, end: number): number {\\n    let map = {};\\n    for (let i = 0; i < edges.length; i++) {\\n        let [f, t] = edges[i];\\n        if (map[f] === undefined) map[f] = {};\\n        if (map[t] === undefined) map[t] = {};\\n        map[f][t] = succProb[i];\\n        map[t][f] = succProb[i];\\n    }\\n    if(map[end] === undefined) return 0;\\n    let res = dijkstra(n, map, start, end);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nlet dijkstra = (n: number, map: any, s: number, d: number) => {\\n    let visited = new Array(n).fill(0);\\n    let costs = new Array(n).fill(0);\\n    costs[s] = 1;\\n    while(true) {\\n        let node;\\n        for(let i=0; i<visited.length; i++) {\\n            if(visited[i]) continue;\\n            if(node === undefined) node = i;\\n            else node = costs[node] < costs[i] ? i: node;\\n        }\\n        if(node === undefined) break;\\n        if(node === d) return costs[d];\\n        visited[node] = 1;\\n        if(map[node] === undefined) continue;\\n        let adjNodes = Object.keys(map[node]);\\n        for(let adj of adjNodes) {\\n            if(visited[adj]) continue;\\n            let w = map[node][adj] * costs[node];\\n            costs[adj] = Math.max(costs[adj], w);\\n        }\\n    }\\n    return costs[d];\\n}\\n\\nfunction maxProbability(n: number, edges: number[][], succProb: number[], start: number, end: number): number {\\n    let map = {};\\n    for (let i = 0; i < edges.length; i++) {\\n        let [f, t] = edges[i];\\n        if (map[f] === undefined) map[f] = {};\\n        if (map[t] === undefined) map[t] = {};\\n        map[f][t] = succProb[i];\\n        map[t][f] = succProb[i];\\n    }\\n    if(map[end] === undefined) return 0;\\n    let res = dijkstra(n, map, start, end);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691567,
                "title": "simple-bfs-dijkstra-s-shortest-path-c",
                "content": "# if it helps you, Please Upvote Me... \\uD83E\\uDDE1\\uD83E\\uDD0D\\uD83D\\uDC9A\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I apply **BFS traversal** to traverse the nodes, and also **Dijkstra\\'s** algorithm to find the path with the **maximum probability score**.\\n\\n# Complexity\\n- Time complexity:O(V*E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(V*E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double solve(vector<pair<int,double>> adj[],int start,int end,int n)\\n    {\\n        queue<pair<int,double>> q;\\n        vector<double> p(n,0);\\n        q.push({start,1});\\n        p[start] = 1;\\n        double ans = 0;\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front().first;\\n            double prob = q.front().second;\\n            q.pop();\\n\\n            if(node==end)\\n            ans = max(ans,prob);\\n\\n            for(auto x  : adj[node])\\n            {\\n                int nd = x.first;\\n                double pb = x.second;\\n                if(p[nd]<pb*prob)\\n                {\\n                    q.push({nd,pb*prob});\\n                    p[nd] = pb*prob;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    double maxProbability(int n, vector<vector<int>>& e, vector<double>& sp, int start, int end) {\\n        vector<pair<int,double>> adj[n];\\n\\n        for(int i = 0;i<e.size();i++)\\n        {\\n            adj[e[i][0]].push_back({e[i][1],sp[i]});\\n            adj[e[i][1]].push_back({e[i][0],sp[i]});\\n        }\\n\\n        return solve(adj,start,end,n);  \\n       \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/832d52c6-fa81-491e-a8fb-ddd7fb9b97f2_1687931606.8884685.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double solve(vector<pair<int,double>> adj[],int start,int end,int n)\\n    {\\n        queue<pair<int,double>> q;\\n        vector<double> p(n,0);\\n        q.push({start,1});\\n        p[start] = 1;\\n        double ans = 0;\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front().first;\\n            double prob = q.front().second;\\n            q.pop();\\n\\n            if(node==end)\\n            ans = max(ans,prob);\\n\\n            for(auto x  : adj[node])\\n            {\\n                int nd = x.first;\\n                double pb = x.second;\\n                if(p[nd]<pb*prob)\\n                {\\n                    q.push({nd,pb*prob});\\n                    p[nd] = pb*prob;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    double maxProbability(int n, vector<vector<int>>& e, vector<double>& sp, int start, int end) {\\n        vector<pair<int,double>> adj[n];\\n\\n        for(int i = 0;i<e.size();i++)\\n        {\\n            adj[e[i][0]].push_back({e[i][1],sp[i]});\\n            adj[e[i][1]].push_back({e[i][0],sp[i]});\\n        }\\n\\n        return solve(adj,start,end,n);  \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691559,
                "title": "simple-c-dijkstra-s-algo-fast",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n+m)\\n\\n- Space complexity:\\nO(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0],v=edges[i][1];\\n            adj[u].push_back({v,succProb[i]});\\n            adj[v].push_back({u,succProb[i]});\\n        }\\n\\n        priority_queue<pair<double,int>>q;\\n\\n        vector<double>prob(n,0);\\n\\n        q.push({1.0,start});\\n\\n        prob[start]=1.0;\\n\\n        while(!q.empty()){\\n            double p=q.top().first;\\n            int node=q.top().second;\\n            q.pop();\\n            for(auto i:adj[node]){\\n                if(prob[i.first]<p*i.second){\\n                    prob[i.first]=p*i.second;\\n                    q.push({p*i.second,i.first});\\n                }\\n            }\\n        }\\n\\n        return prob[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<pair<int,double>>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0],v=edges[i][1];\\n            adj[u].push_back({v,succProb[i]});\\n            adj[v].push_back({u,succProb[i]});\\n        }\\n\\n        priority_queue<pair<double,int>>q;\\n\\n        vector<double>prob(n,0);\\n\\n        q.push({1.0,start});\\n\\n        prob[start]=1.0;\\n\\n        while(!q.empty()){\\n            double p=q.top().first;\\n            int node=q.top().second;\\n            q.pop();\\n            for(auto i:adj[node]){\\n                if(prob[i.first]<p*i.second){\\n                    prob[i.first]=p*i.second;\\n                    q.push({p*i.second,i.first});\\n                }\\n            }\\n        }\\n\\n        return prob[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691555,
                "title": "easy-c-solution-using-dijkstra-s-algorithm",
                "content": "# Intuition\\nUsing Dijkstra\\'s Algorithm\\n\\n# Approach\\nLike we add node dis to source curr dis and compare with destination node distance in dijkstra\\'s, here we just find probability and compare.\\n\\n# Complexity\\n- Time complexity:\\nO(E + Elog(V)) -> O(ElogV) -> same as dijkstra\\'s\\n- Space complexity:\\nO(k(E+V)) where k is any constant, thus we can say O(E+V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb,\\n    int start, int end){\\n        // using dijsktra\\'s algorithm using minHeap\\n        // first creating adjacency list\\n        vector<pair<int,double>> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        vector<double> Prob(n,0.0);\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0,start});\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            double p=it.first;\\n            int s=it.second;\\n            for(auto i: adj[s]){\\n                int node=i.first;\\n                double nodeProb=i.second;\\n                if(nodeProb*p>Prob[node]){\\n                    Prob[node]=nodeProb*p;\\n                    pq.push({Prob[node],node});\\n                }\\n            }\\n        }\\n        return Prob[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb,\\n    int start, int end){\\n        // using dijsktra\\'s algorithm using minHeap\\n        // first creating adjacency list\\n        vector<pair<int,double>> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            adj[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        vector<double> Prob(n,0.0);\\n        priority_queue<pair<double,int>> pq;\\n        pq.push({1.0,start});\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            double p=it.first;\\n            int s=it.second;\\n            for(auto i: adj[s]){\\n                int node=i.first;\\n                double nodeProb=i.second;\\n                if(nodeProb*p>Prob[node]){\\n                    Prob[node]=nodeProb*p;\\n                    pq.push({Prob[node],node});\\n                }\\n            }\\n        }\\n        return Prob[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691458,
                "title": "python-dijkstra-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using Dijkstra\\'s algorithm to find the path with the maximum probability of success. We can represent the graph as an adjacency list, where each node has a list of its neighbors and the corresponding edge probabilities.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of Dijkstra\\'s algorithm is O((V+E)logV), where V is the number of nodes and E is the number of edges in the graph. In the worst case, all edges need to be explored.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(V) to store the adjacency list, probabilities array, and priority queue, where V is the number of nodes in the graph.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        # Step 1: Create adjacency list\\n        adj = [[] for _ in range(n)]  # Initialize adjacency list\\n        for i, (a, b) in enumerate(edges):\\n            adj[a].append((b, succProb[i]))  # Add neighbor and edge probability to adjacency list of node \\'a\\'\\n            adj[b].append((a, succProb[i]))  # Add neighbor and edge probability to adjacency list of node \\'b\\'\\n\\n        # Step 2: Initialize probabilities\\n        probabilities = [0] * n  # Initialize probability array\\n        probabilities[start] = 1  # Set probability of start node to 1\\n\\n        # Step 3: Initialize priority queue\\n        pq = []  # Initialize priority queue\\n        heapq.heappush(pq, (-1, start))  # Push start node to priority queue with probability -1 (negative for max heap)\\n\\n        # Step 4: Dijkstra\\'s algorithm\\n        while pq:\\n            probability, node = heapq.heappop(pq)  # Pop node with highest probability from priority queue\\n            probability *= -1  # Invert probability back to positive\\n\\n            if node == end:  # If end node is reached, return the probability\\n                return probability\\n\\n            if probability < probabilities[node]:  # If a lower probability is already recorded, skip this node\\n                continue\\n\\n            for neighbor, edge_prob in adj[node]:  # Iterate through neighbors of the current node\\n                new_prob = probability * edge_prob  # Calculate the new probability to reach the neighbor\\n                if new_prob > probabilities[neighbor]:  # If the new probability is higher than the recorded probability\\n                    probabilities[neighbor] = new_prob  # Update the probability of reaching the neighbor\\n                    heapq.heappush(pq, (-new_prob, neighbor))  # Push the neighbor to the priority queue with the new probability\\n\\n        # Step 5: No path found\\n        return 0",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using Dijkstra\\'s algorithm to find the path with the maximum probability of success. We can represent the graph as an adjacency list, where each node has a list of its neighbors and the corresponding edge probabilities.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of Dijkstra\\'s algorithm is O((V+E)logV), where V is the number of nodes and E is the number of edges in the graph. In the worst case, all edges need to be explored.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(V) to store the adjacency list, probabilities array, and priority queue, where V is the number of nodes in the graph.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        # Step 1: Create adjacency list\\n        adj = [[] for _ in range(n)]  # Initialize adjacency list\\n        for i, (a, b) in enumerate(edges):\\n            adj[a].append((b, succProb[i]))  # Add neighbor and edge probability to adjacency list of node \\'a\\'\\n            adj[b].append((a, succProb[i]))  # Add neighbor and edge probability to adjacency list of node \\'b\\'\\n\\n        # Step 2: Initialize probabilities\\n        probabilities = [0] * n  # Initialize probability array\\n        probabilities[start] = 1  # Set probability of start node to 1\\n\\n        # Step 3: Initialize priority queue\\n        pq = []  # Initialize priority queue\\n        heapq.heappush(pq, (-1, start))  # Push start node to priority queue with probability -1 (negative for max heap)\\n\\n        # Step 4: Dijkstra\\'s algorithm\\n        while pq:\\n            probability, node = heapq.heappop(pq)  # Pop node with highest probability from priority queue\\n            probability *= -1  # Invert probability back to positive\\n\\n            if node == end:  # If end node is reached, return the probability\\n                return probability\\n\\n            if probability < probabilities[node]:  # If a lower probability is already recorded, skip this node\\n                continue\\n\\n            for neighbor, edge_prob in adj[node]:  # Iterate through neighbors of the current node\\n                new_prob = probability * edge_prob  # Calculate the new probability to reach the neighbor\\n                if new_prob > probabilities[neighbor]:  # If the new probability is higher than the recorded probability\\n                    probabilities[neighbor] = new_prob  # Update the probability of reaching the neighbor\\n                    heapq.heappush(pq, (-new_prob, neighbor))  # Push the neighbor to the priority queue with the new probability\\n\\n        # Step 5: No path found\\n        return 0",
                "codeTag": "Java"
            },
            {
                "id": 3691448,
                "title": "c-bfs-shortest-path",
                "content": "# Intuition\\n##### Since we have to multiply probability of weights in path from start to end what we can do is --> we can take log of weights between edges and form graph (more specifically absolute of log to avoide negative negative cycle) and then can find shortest path from start to end and can later convert the distance to probability.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n         double result = 0;\\n         if(start == end) return (double)1;\\n         vector<pair<int , double>> adj[n];\\n         for(int i = 0 ; i < edges.size() ; i++)\\n         {\\n             int u = edges[i][0];\\n             int v = edges[i][1];\\n\\n             double prob = abs(log10(succProb[i]));\\n             adj[u].push_back({v , prob});\\n             adj[v].push_back({u , prob});\\n         }\\n         vector<double> distance(n , INT_MAX);\\n         distance[start] = 0;\\n         queue<int> q;\\n         q.push(start);\\n         while(q.size())\\n         {\\n             int node = q.front();\\n             q.pop();\\n             for(auto x : adj[node])\\n             {\\n                 int node2 = x.first;\\n                 double wt = x.second;\\n\\n                 if(distance[node2]==INT_MAX || distance[node]+wt < distance[node2])\\n                 {\\n                     distance[node2] = distance[node] + wt;\\n                     q.push(node2);\\n                 }\\n             }\\n         }\\n         if(distance[end] == INT_MAX) return (double)0;\\n         return double(pow(10 , -1*distance[end]));\\n         return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n         double result = 0;\\n         if(start == end) return (double)1;\\n         vector<pair<int , double>> adj[n];\\n         for(int i = 0 ; i < edges.size() ; i++)\\n         {\\n             int u = edges[i][0];\\n             int v = edges[i][1];\\n\\n             double prob = abs(log10(succProb[i]));\\n             adj[u].push_back({v , prob});\\n             adj[v].push_back({u , prob});\\n         }\\n         vector<double> distance(n , INT_MAX);\\n         distance[start] = 0;\\n         queue<int> q;\\n         q.push(start);\\n         while(q.size())\\n         {\\n             int node = q.front();\\n             q.pop();\\n             for(auto x : adj[node])\\n             {\\n                 int node2 = x.first;\\n                 double wt = x.second;\\n\\n                 if(distance[node2]==INT_MAX || distance[node]+wt < distance[node2])\\n                 {\\n                     distance[node2] = distance[node] + wt;\\n                     q.push(node2);\\n                 }\\n             }\\n         }\\n         if(distance[end] == INT_MAX) return (double)0;\\n         return double(pow(10 , -1*distance[end]));\\n         return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691442,
                "title": "java-dijkstra-solution",
                "content": "\\n# Complexity\\n- Time complexity:   O((V + E) log V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(V + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        ArrayList<ArrayList<Pair>> list = new ArrayList<>();\\n        for(int i=0 ; i<n ; i++){\\n            list.add(new ArrayList<Pair>());\\n        }\\n\\n        for(int i=0 ; i<edges.length ; i++){\\n            list.get(edges[i][0]).add(new Pair(edges[i][1],succProb[i]));\\n            list.get(edges[i][1]).add(new Pair(edges[i][0],succProb[i]));\\n        }\\n        \\n        double [] prob = dij(list,start,n);\\n        return prob[end];\\n        \\n    }\\n    double[] dij(ArrayList<ArrayList<Pair>> list , int src ,int n){\\n\\n        double [] prob = new double [n];\\n        PriorityQueue<Pair> q = new PriorityQueue<>(Comparator.comparingDouble((Pair p) -> p.b).reversed());\\n        prob[src] = 1;\\n        q.add(new Pair(src,1));\\n\\n        while(!q.isEmpty()){\\n            int u = q.poll().a;\\n            for(Pair v: list.get(u)){\\n                if(prob[v.a]<v.b*prob[u]){\\n                    prob[v.a]=v.b*prob[u];\\n                    q.add(new Pair(v.a,prob[v.a]));\\n                }\\n            }\\n        }\\n        return prob;\\n    }\\n}\\n\\nclass Pair{\\n    int a ;\\n    double b ;\\n    Pair(int a, double b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        ArrayList<ArrayList<Pair>> list = new ArrayList<>();\\n        for(int i=0 ; i<n ; i++){\\n            list.add(new ArrayList<Pair>());\\n        }\\n\\n        for(int i=0 ; i<edges.length ; i++){\\n            list.get(edges[i][0]).add(new Pair(edges[i][1],succProb[i]));\\n            list.get(edges[i][1]).add(new Pair(edges[i][0],succProb[i]));\\n        }\\n        \\n        double [] prob = dij(list,start,n);\\n        return prob[end];\\n        \\n    }\\n    double[] dij(ArrayList<ArrayList<Pair>> list , int src ,int n){\\n\\n        double [] prob = new double [n];\\n        PriorityQueue<Pair> q = new PriorityQueue<>(Comparator.comparingDouble((Pair p) -> p.b).reversed());\\n        prob[src] = 1;\\n        q.add(new Pair(src,1));\\n\\n        while(!q.isEmpty()){\\n            int u = q.poll().a;\\n            for(Pair v: list.get(u)){\\n                if(prob[v.a]<v.b*prob[u]){\\n                    prob[v.a]=v.b*prob[u];\\n                    q.add(new Pair(v.a,prob[v.a]));\\n                }\\n            }\\n        }\\n        return prob;\\n    }\\n}\\n\\nclass Pair{\\n    int a ;\\n    double b ;\\n    Pair(int a, double b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691365,
                "title": "problem-of-the-day-28-06-2023",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        # Adjacency list\\n        adj = [[] for _ in range(n)]\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            p = succProb[i]\\n            adj[u].append((v, p))\\n            adj[v].append((u, p))\\n\\n        # Distances array\\n        dist = [0.0] * n\\n        dist[start] = 1.0\\n\\n        # Queue for BFS\\n        queue = deque([start])\\n\\n        while queue:\\n            curr = queue.popleft()\\n\\n            for node, prob in adj[curr]:\\n                new_prob = dist[curr] * prob\\n\\n                if new_prob > dist[node]:\\n                    dist[node] = new_prob\\n                    queue.append(node)\\n\\n        return dist[end]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        # Adjacency list\\n        adj = [[] for _ in range(n)]\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            p = succProb[i]\\n            adj[u].append((v, p))\\n            adj[v].append((u, p))\\n\\n        # Distances array\\n        dist = [0.0] * n\\n        dist[start] = 1.0\\n\\n        # Queue for BFS\\n        queue = deque([start])\\n\\n        while queue:\\n            curr = queue.popleft()\\n\\n            for node, prob in adj[curr]:\\n                new_prob = dist[curr] * prob\\n\\n                if new_prob > dist[node]:\\n                    dist[node] = new_prob\\n                    queue.append(node)\\n\\n        return dist[end]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691305,
                "title": "modified-dijkstra-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int,double>>>graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            graph[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>>pq;\\n        pq.push({1,start});\\n        vector<double>prob(n,0);\\n        while(!pq.empty())\\n        {\\n            auto [probability,node]=pq.top();\\n            pq.pop();\\n            for(auto [child,p]:graph[node])\\n            {\\n                if((probability*p)>prob[child])\\n                {\\n                    prob[child]=probability*p;\\n                    pq.push({prob[child],child});\\n                }\\n            }\\n        }\\n        return prob[end];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int,double>>>graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1],succProb[i]});\\n            graph[edges[i][1]].push_back({edges[i][0],succProb[i]});\\n        }\\n        priority_queue<pair<double,int>>pq;\\n        pq.push({1,start});\\n        vector<double>prob(n,0);\\n        while(!pq.empty())\\n        {\\n            auto [probability,node]=pq.top();\\n            pq.pop();\\n            for(auto [child,p]:graph[node])\\n            {\\n                if((probability*p)>prob[child])\\n                {\\n                    prob[child]=probability*p;\\n                    pq.push({prob[child],child});\\n                }\\n            }\\n        }\\n        return prob[end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565248,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947308,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947563,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1576403,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947804,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947345,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947608,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568589,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947756,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947422,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1565248,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947308,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947563,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1576403,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947804,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947345,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947608,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568589,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947756,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1947422,
                "content": [
                    {
                        "username": "watson99",
                        "content": "A standard setup for Dijkstra\\'s algorithm is as follows:\\n1. We have a graph with weighted, non-negative edges (usually directed).\\n2. The cost of a route is computed by **summing up the weights along the route**\\n3. We are interested in finding the routes with **minimal** cost from a `source` node.\\n\\nIn this question, however, we have quite a different setup:\\n* The cost of the route is determined by **multiplying** the weights along the route, instead of a summation.\\n* We are interested in finding the routes that have **maximal** cost rather than minimal.\\n* The weights are between 0 and 1, as they represent probabilities.\\n\\nHow do we know Dijkstra\\'s algorithm is applicable to this problem? \\n\\nMany solutions here are using a slightly modified version of Dijkstra\\'s algorithm, by using a)  `MaxHeap` instead of `MinHeap` data structure (or, equivalently, putting `negative probability` values as keys in a min heap) and  b) computing the cost of the path by multiplication, rather than summation. These modifications are not immediately trivial. Is the resulting solution still considered as an application of Dijkstra\\'s algorithm? How do we prove its correctness? Does it have the same time complexity?\\n\\nLet\\'s have a different perspective on what we need the next item that we pop from the queue to be like:\\nIt has to be the node **that we can not improve the cost of getting to this node on a different path**. For the original algorithm, it is the node that is closest to the `source`, and, since there are no negative edges in the graph, we are confident that we can not improve on this cost. In the modified version, the next node is one with the highest probability that we know so far. Is there a chance to improve on this probability from another route? No! Because all the weights are probabilities and are in the range [0,1]. Multiplying by such number will never give a better probability.\\nSo, the key point here is: **the requirement of non negative weights in the original setup is equivalent to a requirement of weights in range [0,1] for this question.**\\n\\nHow about multiplication vs summation? The key point is the observation that for the algorithm to work, we need the routes to get **monotonically \"worse\"** after every hop. For the original setup, every hop adds to the cost of the route (or it stays the same if w=0) and by going further the route gets more expensive, so we aim to find cheaper (shorter) routes. In the modified version, every hop decreases the probability (or it stays the same if p=1) and by going further the route gets more expensive, so we aim to find cheaper (more probable) routes.\\nSo, the key point here is: **the summation of non-negative weights in the original setup is equivalent to a multiplication of probabilities in this question, because both operations maintain the monotonic nature of routes getting more expensive as we go.**\\n\\nThese 2 points show the equivalency between this question and the standard shortest paths problem. By having the weights constrained between [0, 1], by using multiplication instead of summation, and by utilizing MaxHeap instead of MinHeap, we can use the modified Dijkstra\\'s algorithm and have the same time complexity of `O(ElogV)`"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "medium my ass "
                    },
                    {
                        "username": "droshux",
                        "content": "[@ursachu](/ursachu)[@phamtuan199911](/phamtuan199911)  Most people don\\'t just *know* Dijkstra, I had to google some of the more specifics. If this was a verbal / worded interview question then yeah you can just say: \"I do [clever thing to reframe the problem so that dijkstra\\'s actually works here] and then apply dijkstras\" then yeah it would be medium or easy because that clever shift in perspective isn\\'t that hard but then after that you have to write a whole dijkstras implelentation. \\nOR: https://pypi.org/project/Dijkstar/, although I\\'m not sure you can import that in leetcode"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "if you know Dijkstra, it is considered easy as it is just a modified \"shortest path\" problem. But if you didn\\'t solve this type of problem then it\\'s medium"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@ursachu](/ursachu) ahhh yess... standard medium "
                    },
                    {
                        "username": "ursachu",
                        "content": "It is medium bruh, standard dfs with corner cases or apply djikshtra"
                    },
                    {
                        "username": "rebooter",
                        "content": "Completed the first week of my LeetCode 365-day challenge, with 51 more weeks to go.):"
                    },
                    {
                        "username": "ShadowFax0205",
                        "content": "Fine"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "ok."
                    },
                    {
                        "username": "MojoAlpha",
                        "content": "This article doesn\\'t contain any code... it\\'s just my point of view of shortest/longest path graph algorithms.\\n## General Why?\\nSo, most of the people solving this problem must be already familiar with djikstra... and then comes this mysterious question with product of edge weights, which is difficult to comprehend at first. So, many of you people must be thinking of cramming the logic of the  problem, that this is it and let\\'s learn this case of djikstra for the future. If you are one of them, this article is not for you.\\nSingle source shortest path algorithm (or Dijkstra algorithm) works on the pretext that \"if any node has the shortest distance from the source, then all the vertex which i can visit directly from this node, would also yield shortest path till that node\". This thing works perfectly well, & is logical, but it fails if i want to find the longest path in a general graph, although if we modify the pretext accordingly it seems correct!! \\nIn the longest path problem, the difficulty lies in the cycles. If there\\'s a cycle in that graph with positve weight, the normal djikstra algorithm(with max-heap) will enter an infinite loop. **Max-heap logic works totally fine for DAGs.**\\nI hope my logic is making sense. Some people might be thinking of using a visited array of tackling the case of cycles in longest path problem, but that won\\'t work, as that would be similar to DFS, which obviously is not going to give a correct answer. Therefore, this problem of longest path problem is a NP-hard problem which cannot be solved in polynomial time.\\n## Why Related To Problem?\\nNow, after this long discussion, let\\'s jump to the original problem. So the question arises, **why is normal djikstra algorithm working fine for this?**\\nObserve, that in normal djikstra algorithm, we don\\'t have a visited array. So, the graph is scanned with the assurance that the visited node wouldn\\'t be visited again. This is logical, as in normal djikstra, as the edge weights are positive why would we visited the already visited nodes already having shorter path length from source that current one. This logic can help you determine if you can apply djikstra in a problem or not.\\nIn this question, the probablity of **start** node would be 1. Thus in every node we visit after it the probablity is going to be less than the node we are visiting from (edge weights are smaller than 1). Thus, we can simply apply djikstra algorithm and get the required answer here.\\nA goodbye question for you...\\n* Would simple djikstra have worked if the edge weights were > 1? (If you can\\'t answer this with confidence, you need to read it again !)"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@prototye](/prototye) i agree with your ans. You\\'re claiming this for Dijkstra with MaxHeap right?"
                    },
                    {
                        "username": "prototye",
                        "content": "Me trying to ans your last ques: Simple Dijikstra wouldn\\'t have worked because revisiting a node will always increase its visiting factor(probability here) hence we will get stuck in a cycle of revisiting the same node again and again, therefore we need to maintain a visited array to avoid this cycle. Is my explanation good enough from interview perspective?"
                    },
                    {
                        "username": "GD18",
                        "content": "hehe........succProb lol"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bloke named Prob ;)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Original Dijkstra's algorithm finds the shortest path between two given nodes. Using \n-log(d) as in hint is not necessary! Just set a usual priority_queue for the pair<double, int> !!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Worked out the DFS, beats only 6%. Felt sad. Opened editorial only to discover who the hell is Bellman-Ford?"
                    },
                    {
                        "username": "mscientist12",
                        "content": "[@breathermachine](/breathermachine) respect++;"
                    },
                    {
                        "username": "vvakhlyuev",
                        "content": "Tried Python BFS-like, beats 90%: https://leetcode.com/submissions/detail/981579419/\n\nEdit: found out the approach is described in Editorial => Shortest Path Faster Algorithm (SPFA)."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Richard Bellman, the father of dynamic programming"
                    },
                    {
                        "username": "notthereyet",
                        "content": "I see that there are both the types of solutions; one with `visited` implementation and another without it. Both the solutions are accepted. I am not able to understand why we shouldn\\'t use `visited` in this case.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yep I don\\'t know why some solutions use visited. Regular dijkstras check for shortest paths; this problem we check for longest. \\n\\nSo if the new probability is larger than what we have, we add it to the queue. Otherwise, we ignore it so we won\\'t have a cycle problem"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "My version of code with visited isn\\'t working can someone help me out??\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of a \"visited\" set in graph algorithms typically helps to avoid redundant work or, in the worst case, infinite loops. However, whether to use a \"visited\" set or not depends on the specifics of the problem and the algorithm. \\n\\nIn the context of Dijkstra\\'s algorithm, a \"visited\" set is usually not necessary because of how the algorithm works. Specifically, Dijkstra\\'s algorithm uses a priority queue (or a heap) to always select the node with the smallest distance (or in this problem, highest probability) to process next. Once a node has been processed, there is no need to revisit it because we have already found the shortest path (or maximum probability path) to it. \\n\\nIn the case of this problem, where edge weights represent probabilities and are less than 1, once we have found the maximum probability path to a node, we know that any other path to this node would have a lower probability. This is because multiplying by a number less than 1 will only decrease the value. Thus, revisiting a node will not lead us to a path with a higher probability.\\n\\nHowever, it\\'s also possible to maintain a \"visited\" set as a safety measure to ensure that no node gets processed more than once. This will not change the outcome of the algorithm, but it may add some unnecessary overhead, especially if the graph is large.\\n\\nIn short, while using a \"visited\" set might not hurt, it\\'s usually not necessary for Dijkstra\\'s algorithm and might add some unnecessary overhead."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "multiply `prob` on a value ` 0 <= x <  1` will always less then current `prob`. So, cycles are impossible if we are looking for bigger values always. "
                    },
                    {
                        "username": "MohammadOTaha",
                        "content": "Dijkstra\\'s algorithm in general can work without a `visited` array."
                    },
                    {
                        "username": "seeker_747",
                        "content": "Good problem to revise dijkstra algorithm. I started by reversing the logic , because this time we dont want minimum but maximum.So,i used a max heap and the probability of start node will always be 1 (maximum probabilty); \\nAll other nodes with probability of reaching =0.0000 in starting; \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely correct! This problem is indeed an excellent one to revise and expand your understanding of Dijkstra\\'s algorithm. As you\\'ve noted, the logic here is reversed from the standard Dijkstra\\'s algorithm because we want the maximum probability rather than the minimum path cost.\\n\\nHere, initializing the probability of reaching the start node to 1 is a key observation, as this reflects the fact that we\\'re already at the start node, so the probability is 100%. For all other nodes, we can start with a probability of 0 because we haven\\'t found any path to them yet.\\n\\nApplying Dijkstra\\'s algorithm in this manner, with these initial probability values and using a max heap instead of a min heap, allows us to effectively find the path with the maximum probability from the start to the end node. This modified algorithm, as applied to this problem, provides a solid example of how classical algorithms can be adjusted to fit new problem constraints."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "may god bless you when u get such questions in interview\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1662099,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 1947625,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 1947516,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 1947367,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 1576185,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 1778032,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 2061391,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 2038849,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 1948313,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 1948294,
                "content": [
                    {
                        "username": "gaikwad_pranav",
                        "content": "Would a DFS solution with memoization work in this case? I came up with one which isn\\'t working:\\n\\n```\\n    def _dfs(self, g: \\'Graph\\', visited: set, cache: dict, curr: int, end: int) -> int:\\n        if curr == end:\\n            return 1\\n\\n        if curr in cache:\\n            return cache[curr]\\n\\n        visited.add(curr)\\n        max_prob = 0\\n        for neighbor, weight in g.nodes[curr]:\\n            if neighbor in visited:\\n                continue\\n            max_prob = max(max_prob, weight*self._dfs(g, visited, cache, neighbor, end))\\n        cache[curr] = max_prob\\n        return max_prob\\n```"
                    },
                    {
                        "username": "ivzap",
                        "content": "[@user6157L](/user6157L) I did something similar to what you said any ideas whats flawed in my logic? Only passing 12 test cases(wrong answer). https://leetcode.com/problems/path-with-maximum-probability/submissions/981884091/"
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS works. No need to memoize. [visited] should save the max probability, and only DFS into it if current probability is larger than the one saved in [visited]. My DFS solution passed but only beats 6%."
                    },
                    {
                        "username": "user6157L",
                        "content": "Because you eliminating the optimal path due to the visited nodes set. You need to keep a separate set of visited nodes for the recursive dfs calls, so you won't be able to memoize it."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "DFS does not guarantee that shortest path to any vertex will be traversed first"
                    },
                    {
                        "username": "Eternal19",
                        "content": "Even i am not able to understand why dfs + memo doesn't work.\nGives wrong answer when n=5000\n```\nclass Solution {\npublic:\n    map<int, map<int,double>>mp;\n    double dfs(int curr, int end, vector<vector<pair<int,double>>>&adj, vector<int>&vis){\n        if(curr==end)return 1;\n        vis[curr] = 1;\n        double ans = 0;\n        for(auto child: adj[curr]){\n            if(vis[child.first]!=1){\n                if(mp[curr].find(child.first)!=mp[curr].end()){\n                    ans = max(ans, mp[curr][child.first]);\n                    continue;\n                }\n                mp[curr][child.first] = child.second*dfs(child.first, end, adj, vis);\n                ans = max(mp[curr][child.first], ans);\n            }\n        }\n        vis[curr] = 0;\n        return  ans;\n    }\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector<pair<int, double>>>adj(n);\n        int m = edges.size();\n        for(int i=0; i<m; i++){\n            adj[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            adj[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        vector<int>vis(n, 0);\n        return dfs(start, end, adj, vis);\n    }\n};\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "IS THERE A FLAW IN MY ALGORITHM?\n\nMy reasoning is that if Psx is the max probability of going from start to Node X and Pxe the probability of going directly from Node X to the end node then Psx * Pxe is the maximum probability of going from the start node to the end node via node X.\n\nSo all you need to do is calculate the maximum probabilities from the start Node to each node that has a direct path to the end node, multiply their probabilities and choose the maximum result. To do this, you need a visited array and a probability array. When a node is visited, it is marked visited and its probability initially set to zero (so that it won't play a part in its own calculation). The start Node automatically is marked as visited and its probability set to 1.0 (it is certain you can get from start to start) before doing the dfs.\n\nThis algorithm worked for 9 out of the 18 testcases. Unfortunately, the testcase where it failed has 1000 nodes so code tracing is out.\n\nCan anybody see something that I have missed?\n\nhttps://leetcode.com/submissions/detail/981317381/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thank you for helping me with my logic. Although I won\\'t get my daily points (unless I copy the answer) I still regard this as a success because of what I have learned."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) I don\\'t think that this is the case. My code would multiply the probability from start to x by the probability from x to end, do the same thing for y and choose the larger answer.\\n\\nHowever, if a direct path exists between x and y then that may introduce branches that my code won\\'t consider."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Thanks for the counter example. I see where my logic has failed now."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is on the right track but there\\'s a small but significant flaw in it. The flaw lies in the assumption that the maximum probability path to the end node must pass through some intermediate node \\'X\\' such that the path from the start node to \\'X\\' has maximum probability. This is not necessarily true in this case.\\n\\nConsider a situation where the path from the start node to an intermediate node \\'X\\' has high probability but the path from \\'X\\' to the end node has very low probability. There might be another path from the start node to \\'Y\\' which has slightly lesser probability than the path to \\'X\\', but the path from \\'Y\\' to the end node might have high probability, making the overall path from the start node to the end node via \\'Y\\' having higher probability than the path via \\'X\\'.\\n\\nSo, in this case, calculating the maximum probabilities from the start node to each node that has a direct path to the end node, multiplying their probabilities and choosing the maximum result won\\'t work.\\n\\nThis is why we need to use a modified Dijkstra\\'s algorithm to ensure that we consider all possible paths to find the path with maximum probability.\\n\\nTo avoid going into an infinite loop due to cycles, you can use a visited array or a distance array where you update the maximum probability of reaching each node. If during the traversal, you come across a state that you\\'ve visited before with a higher or equal probability, then you don\\'t need to visit it again. This ensures that each state is visited at most once, preventing infinite loops."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> Here\\'s an even tinier test case:\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3\\n\\n![graph.JPG](https://assets.leetcode.com/users/images/d0081025-2250-4f9b-89b2-66a5f30378a7_1687957507.2473462.jpeg)"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\\nHere\\'s an even tinier test case:\\n\\nn = 4\\nedges = [[0,2],[1,2],[1,3],[2,3]]\\nsuccProb = [0.2,1.0,0.6,0.5]\\nstart = 0\\nend = 3"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0)\nHere's a small counterexample:\nn = 4\nedges = [[0,1],[0,2],[1,2],[1,3],[2,3]]\nweights = [0.1,0.2,1.0,0.6,0.5]\nstart = 0\nend = 3\n\nYour algorithm will return 0.1 instead of 0.12. It's because the other path of index 2 (via 0->2->1->3) wasn't considered anymore because of the visited flag was set too early, when your algorithm marked the (0 -> 2 -> 3) path"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) But visited nodes are not being dismissed. The maximum probability of going from the start node to the visited node has been calculated and stored in the probability list so that the node can play its part in any future DFS searches."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can't dismiss a node from consideration just because it has already been visited once. There may be other, more cost-effective ways to reach it. DFS in no way guarantee that first discovered path to a node will be the best one."
                    },
                    {
                        "username": "indrazit",
                        "content": "The hint is weird.  Of course it is true that multiplying floating-point values will result in precision errors, but summing-up floating-point values also result in precision errors, and when one floating-point value is much smaller than the other value, multiplication is more reliable than addition."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right, both multiplication and addition of floating-point values can result in precision errors. However, there are some differences that might make one operation more prone to errors than the other in certain contexts.\\n\\nWhen you add two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being added. So if you\\'re adding a very small number to a very large number, the small number might not affect the large number at all due to the limitations of floating-point precision. This is known as catastrophic cancellation.\\n\\nOn the other hand, when you multiply two floating-point numbers, the relative error of the result is about the sum of the relative errors of the numbers being multiplied. So if one of your numbers has a large relative error, the result will also have a large relative error.\\n\\nIn the case of this problem, where we are multiplying probabilities together (which are always between 0 and 1), the results can get very small very quickly when dealing with a large number of edges. This can lead to a loss of precision. However, in this case, the precision of the floating-point representation is not the main concern.\\n\\nThe hint likely refers to the fact that using multiplication to calculate the cost of a path (as in this problem) fundamentally changes the problem from a standard shortest path problem, where costs are calculated by summing edge weights. This affects how the problem can be solved algorithmically. For example, algorithms like Dijkstra\\'s or the Bellman-Ford algorithm, which are designed for problems where path costs are calculated by summing edge weights, may not be directly applicable or may need modification."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yeah, especially that the probabilities are constrained in the range [0, 1], meaning the products also stay within this range. Very weird indeed."
                    },
                    {
                        "username": "hbhutta",
                        "content": "I am very new to this type of problem..\\nI thought I could just do DFS/BFS for all possible paths, store all the probabilities for each path, then return the maximum probability.. Why is not a viable approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested, which involves using depth-first search (DFS) or breadth-first search (BFS) to find all possible paths from the start to the end node, then computing and comparing the probabilities for each path to find the maximum one, is theoretically correct. However, it is highly inefficient and may not be feasible for larger graphs due to the time and space complexity.\\n\\nThe reason is that in a graph with \\'n\\' nodes and \\'m\\' edges, there can be up to O(n!) different paths (considering a full graph scenario). Trying to explore all of them would require exponential time, which is not acceptable for larger inputs as per the problem constraints (2 <= n <= 10^4, succProb.length == edges.length <= 2*10^4).\\n\\nThis is why we employ algorithms like Dijkstra\\'s or variants of it. Dijkstra\\'s algorithm, for instance, works by iteratively picking the \"most promising\" node (the node with the maximum probability in this case) and updating the probabilities of its neighboring nodes. This way, it ensures that once it has processed a node, it has found the path with the maximum probability to that node. This strategy, known as a greedy strategy, allows Dijkstra\\'s algorithm to solve the problem in polynomial time (O(n^2) or O(m log m) with a binary heap), making it much more efficient for larger graphs.\\n\\nIn conclusion, while your approach is theoretically correct, it would not be efficient or practical for larger graphs due to its exponential time complexity. A more efficient approach would be to use a modified version of Dijkstra\\'s algorithm as discussed."
                    },
                    {
                        "username": "lz315",
                        "content": "[@maroshim](/maroshim) same ..."
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "You can use Dijkstra\\'s algorithm or Bellman ford Algorithm.\\n"
                    },
                    {
                        "username": "maroshim",
                        "content": "with DFS/BFS, you will get TLE..."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "DFS/BFS find shortest paths based on number of nodes along the path\\nBut in this problem the goal is to find path based on maximum product along the path => DFS\\\\BFS are inapplicable  "
                    },
                    {
                        "username": "breathermachine",
                        "content": "DFS/BFS doesn\\'t efficiently choose the next smallest node (it\\'s a linear search). Dijkstra\\'s algorithm does (it\\'s a logarithmic search, thanks to priority heap)"
                    },
                    {
                        "username": "srivasrrahul",
                        "content": "This path requires one to understand that shortest path is a minimization problem but given problem is a maximization problem.\\nSo how to convert from maximization problem to minimization problem with following constraints:\\n\\na) Resulting graph can\\'t have a negative weight cycle.\\n\\nAs this is a undirected graph hence there would be cycles so straightforward conversion from positive probability to negative probabiity doesnt work. So two steps:\\n\\na) Take log of the probability. This will be negative as probability max-value is 1.0\\nb) Negate the value obtained from above step. Resulting step is positive.\\n\\nPost above algorithm is running shortest-parth.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Yes, you\\'re right! It\\'s another valid approach to transform this problem to a minimization one. Specifically, since the probabilities are all between 0 and 1, subtracting each probability from 1 will give you a new weight for each edge. The edge with the highest probability becomes the edge with the smallest weight in the new graph. \\n\\nHence, the problem can now be viewed as a shortest path problem, and Dijkstra\\'s algorithm can be applied. \\n\\nHowever, please note that there\\'s a small difference between these two methods: when we use logarithms, we are transforming multiplications into additions, which fits directly into Dijkstra\\'s algorithm structure (summing up edge weights). If you just use `(1 - probability)`, you\\'ll still have to deal with the product of probabilities when calculating the cost for a path, which might require an additional step to correctly maintain and compare these products.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "...or just compare (1 - probability) and now it's a minimization problem without any logarithms."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Wow just solved this question without any errors.  came from linkedin post and able to solve this within minutes. Applied Dijsktra\\'s Algo.  "
                    },
                    {
                        "username": "shrined",
                        "content": "Same. You\\'re not special I promise. This problem is an easy if you know Djikstra\\'s. "
                    },
                    {
                        "username": "leetcancode",
                        "content": "Hi Guys,\\nHow can we use memoization for this solution:\\n <pre>\\npublic double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Vertex>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        int i = 0;\\n        for (int edge[]: edges) {\\n            map.get(edge[0]).add(new Vertex(edge[1], succProb[i]));\\n            map.get(edge[1]).add(new Vertex(edge[0], succProb[i]));\\n            i++;\\n        }\\n\\n        return dfs(map, start, end, new boolean[n]);\\n    }\\n\\n    private double dfs(Map<Integer, List<Vertex>> map, int vertex, int end, boolean[] visited) {\\n        if (vertex == end) {\\n            return 1;\\n        }\\n\\n        if (visited[vertex]) {\\n            return 0;\\n        }\\n\\n        visited[vertex] = true;\\n        List<Vertex> adj = map.get(vertex);\\n        double max = 0;\\n        for (int i = 0; i < adj.size(); i++) {\\n            int adjPoint = adj.get(i).point;\\n            double dfs = dfs(map, adjPoint, end, visited);\\n            max = Math.max(max, adj.get(i).weight * dfs);\\n        }\\n        visited[vertex] = false;\\n\\n        return max;\\n    }\\n\\n    private class Vertex {\\n        int point;\\n        double weight;\\n\\n        public Vertex(int point, double weight) {\\n            this.point = point;\\n            this.weight = weight;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "Hayleyy",
                        "content": "Can I get a help on below naive dfs method - why it failed on 11st with input = 1000 test case - it gives wrong answer:\\n```\\nclass Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int i = 0;\\n        for (int[] edge : edges) {\\n            int src = edge[0], dest = edge[1];\\n            List<Pair<Integer, Double>> nexts = graph.getOrDefault(src, new LinkedList<>());\\n            nexts.add(new Pair<>(dest, succProb[i]));\\n            graph.put(src, nexts);\\n            nexts = graph.getOrDefault(dest, new LinkedList<>());\\n            nexts.add(new Pair<>(src, succProb[i]));\\n            graph.put(dest, nexts);\\n            i++;\\n        }\\n\\n        double ret = dfs(new HashSet<>(), new double[n], start, end, graph);\\n        return ret == -1 ? 0 : ret;        \\n    }\\n\\n    public double dfs(Set<Integer> visited, double[] memo, int node, int end, Map<Integer, List<Pair<Integer, Double>>> graph) {\\n        if (memo[node] != 0) return memo[node];\\n        if (node == end) return 1;\\n        visited.add(node);\\n\\n        List<Pair<Integer, Double>> nexts = graph.get(node);\\n        double curposs = -1;\\n        if (nexts != null) {\\n            for (Pair<Integer, Double> next : nexts) {\\n                int nextNode = next.getKey();\\n                if (visited.contains(nextNode)) continue;\\n                double pos = next.getValue();\\n                double curPosstoEnd = dfs(visited, memo, nextNode, end, graph);\\n                if (curPosstoEnd != -1) curposs = Math.max(curposs, curPosstoEnd * pos);\\n            }\\n        }\\n\\n        visited.remove(node);\\n        return memo[node] = curposs;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Destravna",
                        "content": "time complexity of dijkstra is v + elogv whereas the time complexity of bfs will be v+e, doesn\\'t that mean bfs has a better time complexity and and hence is a better solution , or am I missing something here "
                    },
                    {
                        "username": "ivzap",
                        "content": "Why can we not cache the state for a dfs backtracking as [parent, child] which will be the max probability to reach the end from parent to child?"
                    }
                ]
            },
            {
                "id": 1948257,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1948165,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1948151,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1948126,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1947942,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1947910,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1947880,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1947704,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1947639,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            },
            {
                "id": 1947577,
                "content": [
                    {
                        "username": "rekkles_21",
                        "content": "getting memory limit exceeded error on dijkstras alogirthm.\\nCode :\\n\\n\\nclass Solution {\\npublic:\\n    typedef pair<double,int> pi; //probablity , node \\ndouble maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)\\n{\\n    //converting the edges to a 2d adjacency matrix\\n    double res=0;\\n    vector<vector<double>> graph (n,vector<double>(n,0)); //0 means no edge exists\\n    for(int i=0;i<edges.size();i++){\\n        int parent=edges[i][0];\\n        int child=edges[i][1];\\n        graph[parent][child]=succProb[i];\\n        graph[child][parent]=succProb[i];\\n    }\\n    //undirected graph is ready\\n    //print2d(graph);\\n    \\n    //time to write a diakstra code\\n    //we want max probablity upwards\\n    priority_queue<pi> pq;\\n    //initialising distance as -1\\n    vector<double> ans(n,0);\\n    ans[start]=1;\\n    pq.push({1,start});\\n    while(pq.empty()==false){\\n        double p=pq.top().first;\\n        int node=pq.top().second;\\n        pq.pop();\\n        //obtaining all children of node\\n        for(int i=0;i<n;i++){\\n            if(graph[node][i]!=0){\\n                double prob=graph[node][i];\\n                double BayesProbability=ans[node]*prob; //this is probablity from source to i\\n                if(ans[i]<BayesProbability){ //relation performed\\n                    ans[i]=BayesProbability;\\n                    pq.push({BayesProbability,i});\\n                }\\n            }\\n            if(i==end){\\n                break;\\n            }\\n        }\\n    }\\n\\n    res=ans[end];\\n    return res;\\n}\\n};"
                    },
                    {
                        "username": "breathermachine",
                        "content": "2d adjacency matrix costs too much space, convert it to a list instead."
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Why this code is not working in 9th testcase, it have 1000 nodes.\\n\\n```class Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        map<int, vector<pair<int, double>>> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i][0]].push_back({edges[i][1], succProb[i]});\\n            mp[edges[i][1]].push_back({edges[i][0], succProb[i]});\\n        }\\n        queue<pair<int, double>> q;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < mp[start].size(); i++){\\n            q.push({mp[start][i].first, mp[start][i].second});\\n        }\\n        double ans = 0;\\n        while(q.size()){\\n            auto tp = q.front();\\n            q.pop();\\n            if(tp.first == end) ans = max(ans, tp.second);\\n            else{\\n                for(int i = 0; i < mp[tp.first].size(); i++){\\n                    cout<<mp[tp.first][i].first<<endl;\\n                    if(!visited[mp[tp.first][i].first]){\\n                        visited[mp[tp.first][i].first] = true;\\n                        q.push({mp[tp.first][i].first, mp[tp.first][i].second * tp.second});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "n=4\\nedges=[[0,2],[1,2],[1,3],[2,3]]\\nsuccProb=[0.2,1.0,0.6,0.5]\\nstart=0\\nend=3"
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case:\\n```text\\n5\\n[[1,4],[2,4],[0,4],[0,3],[0,2],[2,3]]\\n[0.37,0.17,0.93,0.23,0.39,0.04]\\n3\\n4\\n```"
                    },
                    {
                        "username": "ShaliniNair",
                        "content": "The problem has been incorrectly set in Ruby. \\'end\\' is a keyword in Ruby and unless the argument \\'end\\' in the initial/ default code definition is changed, the code will red flag a syntax error.  "
                    },
                    {
                        "username": "khe1154",
                        "content": "the hints are not very helpful."
                    },
                    {
                        "username": "avneets2103",
                        "content": "class cmp{\\n    public:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second > p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost>dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n\\nCan someone pls find the issue here"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems to correctly implement a variation of Dijkstra\\'s algorithm, transforming the probabilities into a minimization problem by taking the logarithm and changing the sign. However, there may be an issue with your priority queue comparator.\\n\\nYou\\'re currently using a less-than comparison in the custom comparator for your priority queue. This is the default behavior for a priority queue in C++, which always gives the maximum element. However, Dijkstra\\'s algorithm needs a min-heap, not a max-heap.\\n\\nTherefore, your comparator function should return `p1.second < p2.second` instead of `p1.second > p2.second`.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nclass cmp{\\npublic:\\n    bool operator() (const pair<int, double>& p1, const pair<int, double>& p2) {\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        vector<vector<pair<int, double>>> adjList(n);\\n        for(int i =0; i<edges.size(); i++){\\n            adjList[edges[i][0]].push_back({edges[i][1], -1*log(succProb[i])});\\n            adjList[edges[i][1]].push_back({edges[i][0], -1*log(succProb[i])});\\n        }\\n\\n        priority_queue<pair<int, double>, vector<pair<int, double>>, cmp> pq; // srcNode, distance\\n        pq.push({start, 0});\\n        vector<double> dist(n, DBL_MAX);\\n        dist[start] = 0.0;\\n\\n        while(!pq.empty()){\\n            pair<int, double> p = pq.top();\\n            int currentNode = p.first;\\n            pq.pop();\\n            double distance = p.second;\\n            for(auto neighour: adjList[currentNode]){\\n                double newCost = distance + neighour.second;\\n                if(newCost < dist[neighour.first]){\\n                    dist[neighour.first] = newCost;\\n                    pq.push({neighour.first, dist[neighour.first]});\\n                }\\n            }\\n        }\\n\\n        double val = dist[end];\\n        val = exp(-val);\\n        return val;\\n    }\\n};\\n```\\nThis change should make your priority queue behave as a min-heap, which is necessary for Dijkstra\\'s algorithm to work correctly."
                    },
                    {
                        "username": "codebuster420",
                        "content": "there goes my streak.... i dont know graphs"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "damn, this problem is like, you know how to do it, but you can\\'t do it.\\n\\nI know what to do, but I am trying for around 4 hours, but to no avail. I am gonna skip it, its my most hated problem from now on.\\nDon\\'t know what mistake I am doing, always get either runtime error, or wrong error, or answer = 0 for all answers, or some test case fail, some pass."
                    },
                    {
                        "username": "virner_72",
                        "content": "Bellman Ford is giving TLE in this question :\nclass Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        // create adjacency list\n        ArrayList<ArrayList<Double>> adj = new ArrayList<>();\n        for (int i = 0; i < edges.length; i++) {\n            ArrayList<Double> undirected_1 = new ArrayList<>();\n            ArrayList<Double> undirected_2 = new ArrayList<>();\n\n            undirected_1.add(1.0 * edges[i][0]);\n            undirected_1.add(1.0 * edges[i][1]);\n            undirected_1.add(succProb[i]);\n\n            undirected_2.add(1.0 * edges[i][1]);\n            undirected_2.add(1.0 * edges[i][0]);\n            undirected_2.add(succProb[i]);\n\n            adj.add(undirected_1);\n            adj.add(undirected_2);\n        }\n       // apply bellman Ford Algorithm \n        double[] dist = new double[n];\n        Arrays.fill(dist, 0.0);\n        dist[start] = 1.0;\n        //modify the relaxation codition\n        for (int i = 0; i < n - 1; i++) {\n            for (ArrayList<Double> list : adj) {\n                double u = list.get(0);\n                double v = list.get(1);\n                double wt = list.get(2);\n                if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                    dist[(int) v] = dist[(int) u] * wt;\n                }\n            }\n        }\n\n        // Check for negative cycle\n        for (ArrayList<Double> list : adj) {\n            double u = list.get(0);\n            double v = list.get(1);\n            double wt = list.get(2);\n            if (dist[(int) u] != 0.0 && dist[(int) u] * wt > dist[(int) v]) {\n                return 0.0;\n            }\n        }\n        // return\n        return dist[end];\n    }\n}"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "You can delete negative cycle check. There won\\'t be any, as probability can only decrease as we go."
                    },
                    {
                        "username": "breathermachine",
                        "content": "Bellman ford is O(V * E), which will TLE given the constraints of 10^4 vertices and 2*10^4 edges. Dijkstra will be faster at O(E + V log V). You don't need bellman ford here as the edge values are constrained to the range [0, 1]"
                    },
                    {
                        "username": "tehreemakhtar44",
                        "content": "I just wish that I should have spend more time on leetcode during college. I just can't figure out problems without looking at solutions."
                    },
                    {
                        "username": "psionl0",
                        "content": "Keep practising. In due course you should find that the number of problems you can tackle here without assistance will increase."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Never too late to learn. I\\'m doing this 10 years after my college. It was hell for the first few months. I\\'m still burning in that hell but feeling a little accustomed to it."
                    }
                ]
            }
        ]
    }
]