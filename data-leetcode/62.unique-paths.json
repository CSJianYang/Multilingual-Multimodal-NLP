[
    {
        "title": "Unique Paths",
        "question_content": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\n&nbsp;\nExample 1:\n\nInput: m = 3, n = 7\nOutput: 28\n\nExample 2:\n\nInput: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n&nbsp;\nConstraints:\n\n\t1 <= m, n <= 100",
        "solutions": [
            {
                "id": 22954,
                "title": "c-dp",
                "content": "Since the robot can only move right and down, when it arrives at a point, it either arrives from left or above. If we use `dp[i][j]` for the number of unique paths to arrive at the point `(i, j)`, then the state equation is `dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`. Moreover, we have the base cases `dp[0][j] = dp[i][0] = 1` for all valid `i` and `j`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\\n\\nThe above solution runs in `O(m * n)` time and costs `O(m * n)` space. However, you may have noticed that each time when we update `dp[i][j]`, we only need `dp[i - 1][j]` (at the previous row) and `dp[i][j - 1]` (at the current row). So we can reduce the memory usage to just two rows (`O(n)`).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> pre(n, 1), cur(n, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                cur[j] = pre[j] + cur[j - 1];\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[n - 1];\\n    }\\n};\\n```\\n\\nFurther inspecting the above code, `pre[j]` is just the `cur[j]` before the update. So we can further reduce the memory usage to one row.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> cur(n, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                cur[j] += cur[j - 1];\\n            }\\n        }\\n        return cur[n - 1];\\n    }\\n};\\n```\\n\\nNow, you may wonder whether we can further reduce the memory usage to just `O(1)` space since the above code seems to use only two variables (`cur[j]` and `cur[j - 1]`). However, since the whole row `cur` needs to be updated for `m - 1` times (the outer loop) based on old values, all of its values need to be saved and thus `O(1)`-space is impossible. However, if you are having a DP problem without the outer loop and just the inner one, then it will be possible.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> pre(n, 1), cur(n, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                cur[j] = pre[j] + cur[j - 1];\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> cur(n, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                cur[j] += cur[j - 1];\\n            }\\n        }\\n        return cur[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581998,
                "title": "c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math",
                "content": "We are given a `m x n` grid where we start at cell `(0, 0)` (top-left) and are required to move to the cell `(m-1, n-1)` (bottom-right). We can only move to the right or to the bottom. We need to return total unique paths from start to end using these moves.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force) [TLE]***\\n\\nLet\\'s start with brute-force solution. For a path to be unique, at atleast 1 of move must differ at some cell within that path. \\n* At each cell we can either move down or move right. \\n* Choosing either of these moves could lead us to an unique path\\n* So we consider both of these moves. \\n* If the series of moves leads to a cell outside the grid\\'s boundary, we can return 0 denoting no valid path was found.\\n* If the series of moves leads us to the target cell `(m-1, n-1)`, we return 1 denoting we found a valid unique path from start to end.\\n\\n<p align=middle>\\n<img src=\"https://assets.leetcode.com/users/images/d974e3c6-3aca-4652-9811-d5505d963526_1637119284.4824865.png\" />\\n</p>\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;                                    // reached out of bounds - invalid\\n        if(i == m-1 && j == n-1) return 1;                                // reached the destination - valid solution\\n        return uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);     // try both down and right\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n, i=0, j=0):\\n        if i >= m or j >= n:      return 0\\n        if i == m-1 and j == n-1: return 1\\n        return self.uniquePaths(m, n, i+1, j) + self.uniquePaths(m, n, i, j+1)\\n```\\n\\n\\n***Time Complexity :*** **<code>O(2<sup>m+n</sup>)</code>**, where `m` and `n` are the given input dimensions of the grid\\n***Space Complexity :*** **<code>O(m+n)</code>**, required by implicit recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nThe above solution had a lot of redundant calculations. There are many cells which we reach multiple times and calculate the answer for it over and over again. However, the number of unique paths from a given cell `(i,j)` to the end cell is always fixed. So, we dont need to calculate and repeat the same process for a given cell multiple times. We can just store (or memoize) the result calculated for cell `(i, j)` and use that result in the future whenever required.\\n\\nThus, here we use a 2d array `dp`, where `dp[i][j]` denote the number of unique paths from cell `(i, j)` to the end cell `(m-1, n-1)`. Once we get an answer for cell `(i, j)`, we store the result in `dp[i][j]` and reuse it instead of recalculating it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int dp[101][101]{};\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\\n    }\\n};\\n```\\n\\nA more generalized solution should be as follows -\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        return dfs(dp, 0, 0);\\n    }\\n    int dfs(vector<vector<int>>& dp, int i, int j) {\\n        if(i >= size(dp)   || j >= size(dp[0]))   return 0;     // out of bounds - invalid\\n        if(i == size(dp)-1 && j == size(dp[0])-1) return 1;     // reached end - valid path\\n        if(dp[i][j]) return dp[i][j];                           // directly return if already calculated\\n        return dp[i][j] = dfs(dp, i+1, j) + dfs(dp, i, j+1);    // store the result in dp[i][j] and then return\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        @cache\\n        def dfs(i, j):\\n            if i >= m or j >= n:      return 0\\n            if i == m-1 and j == n-1: return 1\\n            return dfs(i+1, j) + dfs(i, j+1)\\n        return dfs(0, 0)\\n```\\n\\n\\n***Time Complexity :*** **<code>O(m*n)</code>**, the answer to each of cell is calculated only once and memoized. There are `m*n` cells in total and thus this process takes `O(m*n)` time.\\n***Space Complexity :*** **<code>O(m*n)</code>**, required to maintain `dp`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Tabulation)***\\n\\nWe can also convert the above appraoch to an iterative version. Here, we will solve it in bottom-up manner by iteratively calculating the number of unique paths to reach cell `(i, j)` starting from `(0, 0)` where `0 <= i <= m-1` and `0 <= j <= n-1`. We will again use dynamic programming here using a `dp` matrix where `dp[i][j]` will denote the number of unique paths from cell `(0, 0)` the cell `(i, j)`. (Note this differs from memoization appraoch where `dp[i][j]` denoted number of unique paths from cell `(i, j)` to the cell `(m-1,n-1)`)\\n\\nIn this case, we first establish some base conditions first. \\n* We start at cell `(0, 0)`, so `dp[0][0] = 1`. \\n* Since we can only move right or down, there is only one way to reach a cell  `(i, 0)` or `(0, j)`. Thus, we also initialize `dp[i][0] = 1` and `dp[0][j]=1`.\\n* For every other cell `(i, j)` (where `1 <= i  <= m-1` and `1 <= j <= n-1`), we can reach here either from the top cell `(i-1, j)` or the left cell `(i, j-1)`. So the result for number of unique paths to arrive at `(i, j)` is the summation of both, i.e, `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];   // sum of unique paths ending at adjacent top and left cells\\n        return dp[m-1][n-1];         // return unique paths ending at cell (m-1, n-1)\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1]*n for i in range(m)]\\n        for i, j in product(range(1, m), range(1, n)):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[-1][-1]\\n```\\n\\n***Time Complexity :*** **<code>O(m*n)</code>**, we are computing `dp` values for each of the `m*n` cells from the previous cells value. Thus, the total number of iterations performed is requires a time of `O(m*n)`.\\n***Space Complexity :*** **<code>O(m*n)</code>**, required to maintain the `dp` matrix\\n\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - IV (Space Optimized Dynamic Programming)***\\n\\nIn the above solution, we can observe that to compute the `dp` matrix, we are only ever using the cells from previous row and the current row. So, we don\\'t really need to maintain the entire `m x n` matrix of `dp`. We can optimize the space usage by only keeping the current and previous rows.\\n\\nA common way in `dp` problems to optimize space from 2d dp is just to convert the `dp` matrix from `m x n` grid to `2 x n` grid denoting the values for current and previous row. We can just overwrite the previous row and use the current row as the previous row for next iteration. We can simply alternate between these rows using the `& (AND)` operator as can be seen below -\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(2, vector<int>(n,1));\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i & 1][j] = dp[(i-1) & 1][j] + dp[i & 1][j-1];   // <- &  used to alternate between rows\\n        return dp[(m-1) & 1][n-1];\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1]*n for i in range(2)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i&1][j] = dp[(i-1)&1][j] + dp[i&1][j-1]\\n        return dp[(m-1)&1][-1]\\n```\\n\\nOr still better yet, in this case, you can use a single vector as well. We are only accessing same column from previous row which can be given by `dp[j]` and previous column of current row which can be given by `dp[j-1]`. So the above code can be further simplfied to (Credits - [@zayne-siew](https://leetcode.com/zayne-siew)) -\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n, 1);\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[j] += dp[j-1];   \\n        return dp[n-1];\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [1]*n\\n        for _, j in product(range(1, m), range(1, n)):\\n            dp[j] += dp[j-1]\\n        return dp[-1]\\n```\\n\\n***Time Complexity :*** **<code>O(m*n)</code>**, for computing dp values for each of the `m*n` cells.\\n***Space Complexity :*** **<code>O(n)</code>**, required to maintain `dp`. We are only keeping two rows of length `n` giving space complexity of `O(n)`.\\nThere\\'s a small change that can allow us to optimize the space complexity down to `O(min(m, n))`. \\n*Comment below if you can figure it out :)*\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Math)***\\n\\nThis problem can be modelled as a math combinatorics problem. \\n\\n<p align=middle>\\n<img src=\"https://assets.leetcode.com/users/images/2a074864-a70f-462f-a351-531fa191b157_1637118583.158331.png\" width=560 />\\n</p>\\n\\n* We start at `(0, 0)` cell and move to `(m-1, n-1)` cell. \\n* We need to make **`m-1` down-moves** and **`n-1` right-moves** to reach the destination cell. \\n* Thus, we need to perform a **total number of `m+n-2` moves**.\\n* At each cell along the path, we can choose either the right-move or down-move and we need to find the number of unique combinations of these choices (which eventually leads to unique paths).\\n* This is nothing but calculating the **number of different ways to choose `m-1` down-moves and `n-1` right-moves from a total of `m+n-2` moves**. Mathematically, this can be represented as -\\n\\n\\n\\n\\n<p align=middle>\\n<img src=\"https://assets.leetcode.com/users/images/8b8a877c-f29f-46a9-b541-149ae4ee3468_1637114902.8508475.png\" width=700 />\\n</p>\\n\\nWe could cancel out the `(n-1)!` as well  in the above evaluation. We will do one of those based on min(m,n) to give best time complexity in the solution below.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for(int i = m+n-2, j = 1; i >= max(m, n); i--, j++) \\n            ans = (ans * i) / j;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        return factorial(m+n-2) // factorial(m-1) // factorial(n-1)\\n```\\n\\n\\n***Time Complexity :*** **<code>O(min(m,n))</code>** for C++, and **<code>O(m+n)</code>** for Python. We could do it in `O(min(m,n))` for python as well using technique used in C++.\\n***Space Complexity :*** **<code>O(1)</code>**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;                                    // reached out of bounds - invalid\\n        if(i == m-1 && j == n-1) return 1;                                // reached the destination - valid solution\\n        return uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);     // try both down and right\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n, i=0, j=0):\\n        if i >= m or j >= n:      return 0\\n        if i == m-1 and j == n-1: return 1\\n        return self.uniquePaths(m, n, i+1, j) + self.uniquePaths(m, n, i, j+1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int dp[101][101]{};\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        return dfs(dp, 0, 0);\\n    }\\n    int dfs(vector<vector<int>>& dp, int i, int j) {\\n        if(i >= size(dp)   || j >= size(dp[0]))   return 0;     // out of bounds - invalid\\n        if(i == size(dp)-1 && j == size(dp[0])-1) return 1;     // reached end - valid path\\n        if(dp[i][j]) return dp[i][j];                           // directly return if already calculated\\n        return dp[i][j] = dfs(dp, i+1, j) + dfs(dp, i, j+1);    // store the result in dp[i][j] and then return\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        @cache\\n        def dfs(i, j):\\n            if i >= m or j >= n:      return 0\\n            if i == m-1 and j == n-1: return 1\\n            return dfs(i+1, j) + dfs(i, j+1)\\n        return dfs(0, 0)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];   // sum of unique paths ending at adjacent top and left cells\\n        return dp[m-1][n-1];         // return unique paths ending at cell (m-1, n-1)\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1]*n for i in range(m)]\\n        for i, j in product(range(1, m), range(1, n)):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[-1][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(2, vector<int>(n,1));\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i & 1][j] = dp[(i-1) & 1][j] + dp[i & 1][j-1];   // <- &  used to alternate between rows\\n        return dp[(m-1) & 1][n-1];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1]*n for i in range(2)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i&1][j] = dp[(i-1)&1][j] + dp[i&1][j-1]\\n        return dp[(m-1)&1][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n, 1);\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[j] += dp[j-1];   \\n        return dp[n-1];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [1]*n\\n        for _, j in product(range(1, m), range(1, n)):\\n            dp[j] += dp[j-1]\\n        return dp[-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for(int i = m+n-2, j = 1; i >= max(m, n); i--, j++) \\n            ans = (ans * i) / j;\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        return factorial(m+n-2) // factorial(m-1) // factorial(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22958,
                "title": "math-solution-o-1-space",
                "content": "This is a combinatorial problem and can be solved without DP. For mxn grid, robot has to move exactly m-1 steps down and n-1 steps right and these can be done in any order.\\n\\nFor the eg., given in question, 3x7 matrix, robot needs to take 2+6 = 8 steps with 2 down and 6 right in any order. That is nothing but a permutation problem. Denote down as 'D' and right as 'R', following is one of the path :-\\n\\nD R R R D R R R\\n\\nWe have to tell the total number of permutations of the above given word. So, decrease both m & n by 1 and apply following formula:-\\n\\nTotal permutations = (m+n)! / (m! * n!)\\n\\nFollowing is my code doing the same :-\\n\\n    public class Solution {\\n        public int uniquePaths(int m, int n) {\\n            if(m == 1 || n == 1)\\n                return 1;\\n            m--;\\n            n--;\\n            if(m < n) {              // Swap, so that m is the bigger number\\n                m = m + n;\\n                n = m - n;\\n                m = m - n;\\n            }\\n            long res = 1;\\n            int j = 1;\\n            for(int i = m+1; i <= m+n; i++, j++){       // Instead of taking factorial, keep on multiply & divide\\n                res *= i;\\n                res /= j;\\n            }\\n                \\n            return (int)res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Combinatorics"
                ],
                "code": "class Solution {\\n        public int uniquePaths(int m, int n) {\\n            if(m == 1 || n == 1)\\n                return 1;\\n            m--;\\n            n--;\\n            if(m < n) {              // Swap, so that m is the bigger number\\n                m = m + n;\\n                n = m - n;\\n                m = m - n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 182143,
                "title": "recursive-memoization-and-dynamic-programming-solutions",
                "content": "Recursive (Time limit exceed for bigger values) \\n```\\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    return uniquePathsHelper(m - 1, n - 1);\\n  }\\n  \\n  private int uniquePathsHelper(int m, int n) {\\n    if (m < 0 || n < 0) {\\n      return 0;\\n    } else if (m == 0 || n == 0) {\\n      return 1;\\n    } else {\\n      return uniquePathsHelper(m - 1, n) + uniquePathsHelper(m, n - 1);\\n    }\\n  }\\n}\\n```\\n\\nMemoization (Runtime 0 ms, Time complexity m x n, Space complexity: m x n):\\n```\\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    return uniquePathsHelper(m - 1, n - 1, new int[n][m]);\\n  }\\n  \\n  private int uniquePathsHelper(int m, int n, int[][] memo) {\\n    if (m < 0 || n < 0) {\\n      return 0;\\n    } else if (m == 0 || n == 0) {\\n      return 1;\\n    } else if (memo[n][m] > 0) {\\n      return memo[n][m];\\n    } else {\\n      memo[n][m] = uniquePathsHelper(m - 1, n, memo) + uniquePathsHelper(m, n - 1, memo);\\n      return memo[n][m];\\n    }\\n  }\\n} \\n```\\n\\nDynamic programming (Runtime 1 ms, Time complexity m x n, Space complexity: m x n)\\n``` \\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    int[][] grid = new int[n][m];\\n    \\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (i == 0) grid[0][j] = 1;\\n        if (j == 0) grid[i][j] = 1;\\n        if (i != 0 && j != 0) {\\n          int up = grid[i - 1][j];\\n          int left = grid[i][j - 1];\\n          grid[i][j] = up + left;\\n        }\\n      }\\n    }\\n    return grid[n - 1][m - 1];\\n  }\\n} \\n```\\n\\nUpdate: Apologies for not checking the comments and for not updating the solution(s). I performed a small refactor for the third one (seems cleaner to me now). As per Recursive time complexity we have O(2 ^ (m + n)) - we know that the formula we use to determine the time complexity for recursivity is branches ^ depth. In our case we have 2 possible branches (going up and going left), while for the depth, is the maximum possible distance taken to get 0,0 which is m + n. Given this, we can also mention the space complexity taken on the stack O(m + n);\\n\\nAlso: https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming\\n\\nThank you for the comments and useful hints!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    return uniquePathsHelper(m - 1, n - 1);\\n  }\\n  \\n  private int uniquePathsHelper(int m, int n) {\\n    if (m < 0 || n < 0) {\\n      return 0;\\n    } else if (m == 0 || n == 0) {\\n      return 1;\\n    } else {\\n      return uniquePathsHelper(m - 1, n) + uniquePathsHelper(m, n - 1);\\n    }\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    return uniquePathsHelper(m - 1, n - 1, new int[n][m]);\\n  }\\n  \\n  private int uniquePathsHelper(int m, int n, int[][] memo) {\\n    if (m < 0 || n < 0) {\\n      return 0;\\n    } else if (m == 0 || n == 0) {\\n      return 1;\\n    } else if (memo[n][m] > 0) {\\n      return memo[n][m];\\n    } else {\\n      memo[n][m] = uniquePathsHelper(m - 1, n, memo) + uniquePathsHelper(m, n - 1, memo);\\n      return memo[n][m];\\n    }\\n  }\\n} \\n```\n``` \\nclass Solution {\\n  public int uniquePaths(int m, int n) {\\n    int[][] grid = new int[n][m];\\n    \\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (i == 0) grid[0][j] = 1;\\n        if (j == 0) grid[i][j] = 1;\\n        if (i != 0 && j != 0) {\\n          int up = grid[i - 1][j];\\n          int left = grid[i][j - 1];\\n          grid[i][j] = up + left;\\n        }\\n      }\\n    }\\n    return grid[n - 1][m - 1];\\n  }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 22981,
                "title": "my-ac-solution-using-formula",
                "content": "Binomial coefficient:\\n \\n\\n    class Solution {\\n        public:\\n            int uniquePaths(int m, int n) {\\n                int N = n + m - 2;// how much steps we need to do\\n                int k = m - 1; // number of steps that need to go down\\n                double res = 1;\\n                // here we calculate the total possible path number \\n                // Combination(N, k) = n! / (k!(n - k)!)\\n                // reduce the numerator and denominator and get\\n                // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k!\\n                for (int i = 1; i <= k; i++)\\n                    res = res * (N - k + i) / i;\\n                return (int)res;\\n            }\\n        };\\n\\nFirst of all you should understand that we need to do n + m - 2 movements : m - 1 down, n - 1 right, because we start from cell (1, 1).\\n\\nSecondly, the path it is the sequence of movements( go down / go right), \\ntherefore we can say that two paths are different \\nwhen there is  i-th (1 .. m + n - 2)  movement in path1 differ  i-th movement in path2.\\n\\nSo, how we can build paths.\\nLet's choose (n - 1) movements(number of steps to the right) from (m + n - 2), \\nand rest (m - 1) is (number of steps down).\\n\\nI think now it is obvious that count of different paths are all combinations (n - 1) movements from (m + n-2).",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int uniquePaths(int m, int n) {\\n                int N = n + m - 2;// how much steps we need to do\\n                int k = m - 1; // number of steps that need to go down\\n                double res = 1;\\n                // here we calculate the total possible path number \\n                // Combination(N, k) = n! / (k!(n - k)!)\\n                // reduce the numerator and denominator and get\\n                // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k!\\n                for (int i = 1; i <= k; i++)\\n                    res = res * (N - k + i) / i;\\n                return (int)res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 22953,
                "title": "java-dp-solution-with-complexity-o-n-m",
                "content": "   \\n\\n     public class Solution {\\n        public int uniquePaths(int m, int n) {\\n            Integer[][] map = new Integer[m][n];\\n            for(int i = 0; i<m;i++){\\n                map[i][0] = 1;\\n            }\\n            for(int j= 0;j<n;j++){\\n                map[0][j]=1;\\n            }\\n            for(int i = 1;i<m;i++){\\n                for(int j = 1;j<n;j++){\\n                    map[i][j] = map[i-1][j]+map[i][j-1];\\n                }\\n            }\\n            return map[m-1][n-1];\\n        }\\n    }\\n\\n\\nThe assumptions are \\n\\n 1. When (n==0||m==0) the function always returns 1 since the robot\\n    can't go left or up.\\n 2. For all other cells. The result = uniquePaths(m-1,n)+uniquePaths(m,n-1)\\n\\nTherefore I populated the edges with 1 first and use DP to get the full 2-D array.\\n\\nPlease give any suggestions on improving the code.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int uniquePaths(int m, int n) {\\n            Integer[][] map = new Integer[m][n];\\n            for(int i = 0; i<m;i++){\\n                map[i][0] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1582051,
                "title": "c-easy-intuitive-solution-combinatorics-tc-o-min-m-n-sc-o-1-beats-100",
                "content": "Hello everyone, I hope you all are doing great.\\n***Note: Please do upvote if you find this post helpful!***\\n\\nThis is a combinatorics problem that can be easily solved without DP or recursion.\\n\\n**Observation:** If you observe it care fully, our robot has to move `n-1` steps right and `m-1` steps down in any order to reach the right bottom of the grid. You will understand this more with the following example.\\n\\n**Example:** We had `3x7` grid, robot needs to take `(3-1) = 2` steps down overall and `7-1 = 6` steps right overall to reach the bottom right of the grid. This is a total of 8 steps. And the ordering doesn\\'t matter like: `D D R R R R R R` or `D R D R R R R R` or `R R R R R R D D` will all do the job, and all of this is noting but the permutation of total steps. So this is nothing but number of ways of choose `D` in the `8` blanks or number of ways of choosing `R` in the 8 blanks which is nothing but `8C6` or `8C2` ` = 28` (both will do the job) [Someone please tell me how to type nCr the way it looks on this discussion post \\uD83D\\uDE02]\\n\\n**Approach:** So, we only need to choose number of ways of picking **right** from the total steps or number of ways of choosing **down** from the total steps. Which is nothing but `(total) C (right)` or `(total) C (down)`.\\n\\nCode for the implementation of my approach:\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N = n+m-2; // total steps = n-1 + m-1\\n        int r = min(n,m) - 1; // will iterate on the minimum for efficiency = (total) C (min(right, down))\\n        \\n        double res = 1;\\n        \\n\\t\\t// compute nCr\\n        for(int i=1; i<=r; ++i, N--){\\n            \\n            res = res * (N) / i;\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(min(n, m))***\\n**Space Complexity:** ***O(1)***\\n\\n***Note: Please do upvote if you find this post helpful!***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N = n+m-2; // total steps = n-1 + m-1\\n        int r = min(n,m) - 1; // will iterate on the minimum for efficiency = (total) C (min(right, down))\\n        \\n        double res = 1;\\n        \\n\\t\\t// compute nCr\\n        for(int i=1; i<=r; ++i, N--){\\n            \\n            res = res * (N) / i;\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254228,
                "title": "python-3-solutions-bottom-up-dp-math-picture-explained-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bottom up DP**\\n- Let `dp[r][c]` is number of paths to move from `[0, 0]` to `[r, c]`.\\n- Then `dp[m-1][n-1]` is our result.\\n- There are maximum 2 ways to cell `(r, c)`, that is:\\n\\t- From upper cell, `dp[r][c] += dp[r-1][c]`\\n\\t- From left cell, `dp[r][c] += dp[r][c-1]`\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = dp[r-1][c] + dp[r][c-1]\\n        return dp[m-1][n-1]\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 100` is number of rows, `N <= 100` is number of columns.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP (Space Optimized)**\\n- Since we only access 2 states: current state `dp` and previous state `dpPrev`, we can reduce the space complexity to `O(M)`.\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp, dpPrev = [0] * n, [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[c] = 1\\n                else:\\n                    dp[c] = dpPrev[c] + dp[c-1]\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n-1]\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 100` is number of rows, `N <= 100` is number of columns.\\n- Space: `O(M)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Math Solution**\\n- There are total `m+n-2` moves to go from **Top-Left** to **Bottom-Right**. \\n- In `m+n-2` moves, there are `m-1` **down moves** and `n-1` **right moves**.\\n- You can imagine there are `m+n-2` moves as: `X X X ... X X X`\\n\\t- `X` can be one of two values: down `D` or right `R`.\\n\\t- So, basically, it means we need to calculate how many ways we could choose `m-1` **down moves** from `m+n-2` moves, or `n-1` **right moves** from `m+n-2` moves.\\n- So total ways = `C(m+n-2, m-1)` = `C(m+n-2, n-1)` = `(m+n-2)! / (m-1)! / (n-1)!`.\\n\\n![image](https://assets.leetcode.com/users/images/625a19e1-383a-41a9-8628-0850e390cf91_1632765391.8825638.png)\\n\\n\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return factorial(m+n-2) // factorial(n-1) // factorial(m-1)\\n```\\nOr\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        ans = 1\\n        j = 1\\n        for i in range(m, m+n-2 + 1):\\n            ans *= i\\n            ans //= j\\n            j += 1\\n            \\n        return ans\\n```\\n**Complexity**\\n- Time: `O(M + N)`, where `M <= 100` is number of rows, `N <= 100` is number of columns.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = dp[r-1][c] + dp[r][c-1]\\n        return dp[m-1][n-1]\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp, dpPrev = [0] * n, [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[c] = 1\\n                else:\\n                    dp[c] = dpPrev[c] + dp[c-1]\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n-1]\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return factorial(m+n-2) // factorial(n-1) // factorial(m-1)\\n```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        ans = 1\\n        j = 1\\n        for i in range(m, m+n-2 + 1):\\n            ans *= i\\n            ans //= j\\n            j += 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22980,
                "title": "clean-and-simple-dp-java",
                "content": "    public class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] grid = new int[m][n];\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0||j==0)\\n                    grid[i][j] = 1;\\n                else\\n                    grid[i][j] = grid[i][j-1] + grid[i-1][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] grid = new int[m][n];\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0||j==0)\\n                    grid[i][j] = 1;\\n                else\\n                    grid[i][j] = grid[i][j-1] + grid[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 23234,
                "title": "accpeted-simple-python-dp-solution",
                "content": "    class Solution:\\n        # @return an integer\\n        def uniquePaths(self, m, n):\\n            aux = [[1 for x in range(n)] for x in range(m)]\\n            for i in range(1, m):\\n                for j in range(1, n):\\n                    aux[i][j] = aux[i][j-1]+aux[i-1][j]\\n            return aux[-1][-1]",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return an integer\\n        def uniquePaths(self, m, n):\\n            aux = [[1 for x in range(n)] for x in range(m)]\\n            for i in range(1, m):\\n                for j in range(1, n):\\n                    aux[i][j] = aux[i][j-1]+aux[i-1][j]\\n            return aux[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 405983,
                "title": "easy-understand-java-solutions-with-explanations-dp-top-down-bottom-up-linear-space",
                "content": "## Problem\\n\\n> A robot is located at the top-left corner of a `m x n` grid (marked \\'Start\\' in the diagram below).\\n\\n> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \\'Finish\\' in the diagram below).\\n\\n> How many possible unique paths are there?\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bu9wv.jpg)\\n\\n**Note:** `m` and `n` will be at most 100.\\n\\n**Example:** \\n\\n```java\\nInput: m = 1, n = 1\\nOutput: 1\\n\\nInput: m = 3, n = 2\\nOutput: 3\\n\\nInput: m = 7, n = 3\\nOutput: 28\\n```\\n\\n\\n## Analysis\\n\\n### Recursion\\n\\nCheck out the comments.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ljcsc.png)\\n\\n```java\\n// Define: opt(i, j) the number of ways to the point (i, j)\\n// (0, 0) is the starting point, (m - 1, n - 1) is the finish point\\n// Recurrence: opt(i, j) = opt(i - 1, j) + opt(i, j - 1)\\n// Init: opt(0, 0) = 1, opt(0, j) = opt(i, 0) = 1\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  return numPaths(m - 1, n - 1);\\n}\\n\\nprivate int numPaths(int i, int j) {\\n  if (i == 0 || j == 0) { // includes the row 0 and col 0\\n    return 1;\\n  }\\n  return numPaths(i - 1, j) + numPaths(i, j - 1);\\n}\\n```\\n\\n**Time:** `O(2^{M + N})`\\n**Space:** `O(M + N)`\\n\\nRecurrence Tree for complexity analysis:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/8pax9.jpg)\\n\\n\\n\\n### DP (Top-down with Memoization)\\n\\nUse an 2D array `mem` to do memoization.\\n\\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[][] mem = new int[m][n];\\n  for (int i = 0; i < m; ++i) { // init\\n    for (int j = 0; j < n; ++j) {\\n      mem[i][j] = -1;\\n    }\\n  }\\n  return numPaths(m - 1, n - 1, mem);\\n}\\n\\nprivate int numPaths(int i, int j, int[][] mem) {\\n  if (i == 0 || j == 0) {\\n    return 1;\\n  }\\n  if (mem[i - 1][j] == -1) mem[i - 1][j] = numPaths(i - 1, j, mem);\\n  if (mem[i][j - 1] == -1) mem[i][j - 1] = numPaths(i, j - 1, mem);\\n  return mem[i - 1][j] + mem[i][j - 1];\\n}\\n```\\n\\n**Time:** `O(MN)` where `MN` is the number of subproblems.\\n**Space:** `O(MN)`\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/fbu40.jpg)\\n\\n### DP (Bottom-up)\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bckom.png)\\n\\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[][] dp = new int[m][n];\\n  // init\\n  for (int i = 0; i < m; ++i) dp[i][0] = 1;\\n  for (int i = 0; i < n; ++i) dp[0][i] = 1;\\n  // dp\\n  for (int i = 1; i < m; ++i) {\\n    for (int j = 1; j < n; ++j) {\\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n    }\\n  }\\n  return dp[m - 1][n - 1];\\n}\\n```\\n\\n**Time:** `O(MN)`\\n**Space:** `O(MN)`\\n\\n\\n\\n\\n### DP (Bottom-up, Linear Space)\\n\\nReduce the $O(MN)$ space complexity to $O(N)$ (a row) or $O(M)$ (a column). In terms of a row, we would update `dp[j]` by its old value plus `dp[j - 1]`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/2usv6.png)\\n\\n\\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[] dp = new int[n]; // row\\n  // init\\n  for (int i = 0; i < n; ++i) dp[i] = 1;\\n  // dp\\n  for (int i = 1; i < m; ++i) {\\n    for (int j = 1; j < n; ++j) {\\n      dp[j] = dp[j] + dp[j - 1];\\n    }\\n  }\\n  return dp[n - 1];\\n}\\n```\\n\\n**Time:** `O(MN)`\\n**Space:** `O(N)` or `O(M)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: m = 1, n = 1\\nOutput: 1\\n\\nInput: m = 3, n = 2\\nOutput: 3\\n\\nInput: m = 7, n = 3\\nOutput: 28\\n```\n```java\\n// Define: opt(i, j) the number of ways to the point (i, j)\\n// (0, 0) is the starting point, (m - 1, n - 1) is the finish point\\n// Recurrence: opt(i, j) = opt(i - 1, j) + opt(i, j - 1)\\n// Init: opt(0, 0) = 1, opt(0, j) = opt(i, 0) = 1\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  return numPaths(m - 1, n - 1);\\n}\\n\\nprivate int numPaths(int i, int j) {\\n  if (i == 0 || j == 0) { // includes the row 0 and col 0\\n    return 1;\\n  }\\n  return numPaths(i - 1, j) + numPaths(i, j - 1);\\n}\\n```\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[][] mem = new int[m][n];\\n  for (int i = 0; i < m; ++i) { // init\\n    for (int j = 0; j < n; ++j) {\\n      mem[i][j] = -1;\\n    }\\n  }\\n  return numPaths(m - 1, n - 1, mem);\\n}\\n\\nprivate int numPaths(int i, int j, int[][] mem) {\\n  if (i == 0 || j == 0) {\\n    return 1;\\n  }\\n  if (mem[i - 1][j] == -1) mem[i - 1][j] = numPaths(i - 1, j, mem);\\n  if (mem[i][j - 1] == -1) mem[i][j - 1] = numPaths(i, j - 1, mem);\\n  return mem[i - 1][j] + mem[i][j - 1];\\n}\\n```\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[][] dp = new int[m][n];\\n  // init\\n  for (int i = 0; i < m; ++i) dp[i][0] = 1;\\n  for (int i = 0; i < n; ++i) dp[0][i] = 1;\\n  // dp\\n  for (int i = 1; i < m; ++i) {\\n    for (int j = 1; j < n; ++j) {\\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n    }\\n  }\\n  return dp[m - 1][n - 1];\\n}\\n```\n```java\\npublic int uniquePaths(int m, int n) {\\n  if (m == 0 || n == 0) {\\n    throw new IllegalArgumentException(\"m or n can\\'t be 0\");\\n  }\\n  int[] dp = new int[n]; // row\\n  // init\\n  for (int i = 0; i < n; ++i) dp[i] = 1;\\n  // dp\\n  for (int i = 1; i < m; ++i) {\\n    for (int j = 1; j < n; ++j) {\\n      dp[j] = dp[j] + dp[j - 1];\\n    }\\n  }\\n  return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374942,
                "title": "c-solution-using-3-different-appraoches",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\n//Recursive Appraoch\\n//This will give a TLE\\n  int solve(int i,int j,int m,int n)\\n    {\\n        if(i>=m||j>=n)\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        return solve(i+1,j,m,n)+solve(i,j+1,m,n);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return solve(0,0,m,n);\\n    }\\n\\n//DP(recursive+memoization)\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp)\\n    {\\n        if(i>=m||j>=n)\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        return dp[i][j]=solve(i+1,j,m,n,dp)+solve(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n      vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return solve(0,0,m,n,dp);\\n    }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n\\n//DP(Bottom-Up Appraoch)\\n  int uniquePaths(int m, int n) {\\n     int dp[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0||j==0)\\n                    dp[i][j]=1;\\n                else\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Recursive Appraoch\\n//This will give a TLE\\n  int solve(int i,int j,int m,int n)\\n    {\\n        if(i>=m||j>=n)\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        return solve(i+1,j,m,n)+solve(i,j+1,m,n);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return solve(0,0,m,n);\\n    }\\n\\n//DP(recursive+memoization)\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp)\\n    {\\n        if(i>=m||j>=n)\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        return dp[i][j]=solve(i+1,j,m,n,dp)+solve(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n      vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return solve(0,0,m,n,dp);\\n    }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n\\n//DP(Bottom-Up Appraoch)\\n  int uniquePaths(int m, int n) {\\n     int dp[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0||j==0)\\n                    dp[i][j]=1;\\n                else\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22975,
                "title": "python-easy-to-understand-solutions-math-dp-o-m-n-and-o-n-space",
                "content": "        \\n    # math C(m+n-2,n-1)\\n    def uniquePaths1(self, m, n):\\n        if not m or not n:\\n            return 0\\n        return math.factorial(m+n-2)/(math.factorial(n-1) * math.factorial(m-1))\\n     \\n    # O(m*n) space   \\n    def uniquePaths2(self, m, n):\\n        if not m or not n:\\n            return 0\\n        dp = [[1 for _ in xrange(n)] for _ in xrange(m)]\\n        for i in xrange(1, m):\\n            for j in xrange(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[-1][-1]\\n    \\n    # O(n) space \\n    def uniquePaths(self, m, n):\\n        if not m or not n:\\n            return 0\\n        cur = [1] * n\\n        for i in xrange(1, m):\\n            for j in xrange(1, n):\\n                cur[j] += cur[j-1]\\n        return cur[-1]",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # math C(m+n-2,n-1)\\n    def uniquePaths1(self, m, n):\\n        if not m or not n:\\n            return 0\\n        return math.factorial(m+n-2)/(math.factorial(n-1) * math.factorial(m-1))\\n     \\n    # O(m*n) space   \\n    def uniquePaths2(self, m, n):\\n        if not m or not n:\\n            return 0\\n        dp = [[1 for _ in xrange(n)] for _ in xrange(m)]\\n        for i in xrange(1, m):\\n            for j in xrange(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[-1][-1]\\n    \\n    # O(n) space \\n    def uniquePaths(self, m, n):\\n        if not m or not n:\\n            return 0\\n        cur = [1] * n\\n        for i in xrange(1, m):\\n            for j in xrange(1, n):\\n                cur[j] += cur[j-1]\\n        return cur[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3994523,
                "title": "98-83-easy-dp-math",
                "content": "# Interview Guide - Unique Paths in a Grid\\n\\n## Problem Understanding\\n\\nThe problem describes a robot situated on a $$ m \\\\times n $$ grid, starting at the top-left corner (i.e., $$ \\\\text{grid}[0][0] $$). The robot can move either to the right or downwards at any given time, and the objective is to reach the bottom-right corner of the grid. The challenge is to find the number of unique paths the robot can take to reach this goal.\\n\\n### Key Points to Consider\\n\\n1. **Grid Dimensions**:  \\n   The grid dimensions are $$ m $$ (rows) and $$ n $$ (columns), with $$ 1 \\\\leq m, n \\\\leq 100 $$.\\n  \\n2. **Movement Constraints**:  \\n   The robot can only move either down or to the right at any given point. It cannot move diagonally or backwards.\\n\\n3. **Dynamic Programming and Combinatorial Mathematics**:  \\n   The problem can be solved using either a Dynamic Programming approach or using Combinatorial Mathematics.\\n\\n---\\n\\n## Live Coding & More - 3 Solutions\\nhttps://youtu.be/-0OSF4u0cjQ?si=zup18xLotShahabI\\n\\n## Solution #1: Dynamic Programming\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe idea behind this approach is to use a 2D Dynamic Programming (DP) array to store the number of unique paths to each cell. A cell $$ (i, j) $$ can be reached either from $$ (i-1, j) $$ or $$ (i, j-1) $$, and thus the number of unique paths to $$ (i, j) $$ is the sum of the number of unique paths to these two cells.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: \\n    - Create a $$ m \\\\times n $$ DP array, initializing the first row and first column to 1 because there\\'s only one way to reach those cells from the starting point.\\n\\n2. **Main Algorithm**:  \\n    - Iterate over the DP array starting from cell $$ (1, 1) $$.\\n    - For each cell $$ (i, j) $$, set $$ \\\\text{dp}[i][j] = \\\\text{dp}[i-1][j] + \\\\text{dp}[i][j-1] $$.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(m \\\\times n) $$ \\u2014 We iterate through each cell once.\\n- **Space Complexity**: $$ O(m \\\\times n) $$ \\u2014 For the DP array.\\n\\n---\\n\\n## Solution #2: Memory-Optimized Dynamic Programming\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe original DP solution used a $$ m \\\\times n $$ array to store the number of unique paths to each cell. However, since we only need information from the previous row and the current row to compute the number of unique paths for a given cell, we can optimize the solution to use only two rows at a time. This reduces the space complexity from $$ O(m \\\\times n) $$ to $$ O(n) $$.\\n\\n### Transitioning from $$ O(m \\\\times n) $$ to $$ O(n) $$\\n\\nIn the original $$ O(m \\\\times n) $$ approach, we used a 2D array `dp` where $$ \\\\text{dp}[i][j] $$ represented the number of unique paths to reach cell $$ (i, j) $$. To optimize this to $$ O(n) $$, we can maintain only two 1D arrays: `prev_row` and `curr_row`, each of length $$ n $$.\\n\\n- `prev_row[j]` will represent $$ \\\\text{dp}[i-1][j] $$, the number of unique paths to reach the cell in the previous row and $$ j $$-th column.\\n- `curr_row[j]` will represent $$ \\\\text{dp}[i][j] $$, the number of unique paths to reach the cell in the current row and $$ j $$-th column.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**:  \\n   - Initialize two 1D arrays `curr_row` and `prev_row` with $$ n $$ elements, setting all elements to 1.\\n\\n2. **Main Algorithm**:  \\n   - Iterate over the rows starting from 1 (the second row).\\n   - For each cell $$ (i, j) $$, set  `curr_row[j] = curr_row[j-1] + prev_row[j]` .\\n   - Swap `curr_row` and `prev_row` for the next iteration.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(m \\\\times n) $$ \\u2014 We still iterate through each cell once.\\n- **Space Complexity**: $$ O(n) $$ \\u2014 For the two 1D arrays.\\n\\n---\\n\\n## Solution #3: Combinatorial Mathematics\\n\\n### Intuition\\n\\nThe number of unique paths can be seen as the number of ways to choose $$ m-1 $$ downs and $$ n-1 $$ rights, regardless of the order. In combinatorial terms, this is equivalent to $$ \\\\binom{m+n-2}{m-1} $$.\\n\\n### Algorithm\\n\\n1. **Use the Combinatorial Formula**:  \\n   $$ \\\\binom{m+n-2}{m-1} $$ or $$ \\\\binom{m+n-2}{n-1} $$ to calculate the number of unique paths.\\n\\n2. **Python\\'s Math Library**:  \\n   Python provides a built-in function $$ \\\\text{math.comb(n, k)} $$ to calculate $$ \\\\binom{n}{k} $$ efficiently.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(m) $$ or $$ O(n) $$ \\u2014 For calculating the combination.\\n- **Space Complexity**: $$ O(1) $$ \\u2014 Constant space.\\n\\n---\\n\\n# Performance\\n### Dynamic Programming\\n\\n| Language  | Time (ms) | Memory (MB) |\\n|-----------|-----------|-------------|\\n| Rust      | 0 ms      | 2.2 MB      |\\n| C++       | 0 ms      | 6.5 MB      |\\n| Java      | 0 ms      | 39.9 MB     |\\n| Go        | 1 ms      | 2.1 MB      |\\n| PHP       | 10 ms     | 19.3 MB     |\\n| C#        | 23 ms     | 26.6 MB     |\\n| Python3 (1D)   | 26 ms     | 16.3 MB     |\\n| Python3 (2D)  | 28 ms     | 16.3 MB     |\\n| JavaScript| 52 ms     | 41.6 MB     |\\n\\n![dp.png](https://assets.leetcode.com/users/images/5add1caa-9acf-421d-9e0b-2cd8b6497b8f_1693701064.4193008.png)\\n\\n\\n## Combinatorial Mathematics\\n\\n| Language  | Time (ms) | Memory (MB) |\\n|-----------|-----------|-------------|\\n| Rust      | 0 ms      | 2.2 MB      |\\n| C++       | 0 ms      | 5.9 MB      |\\n| PHP       | 0 ms      | 18.9 MB     |\\n| Java      | 0 ms      | 39.8 MB     |\\n| Go        | 1 ms      | 1.9 MB      |\\n| C#        | 22 ms     | 26.5 MB     |\\n| Python3   | 27 ms     | 16.4 MB     |\\n| JavaScript| 55 ms     | 41.3 MB     |\\n\\n![mt.png](https://assets.leetcode.com/users/images/4949037f-4f74-43a6-ae38-afc9f1455847_1693701121.4660912.png)\\n\\n# Code Math\\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m+n-2, m-1)\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\\n        let mut ans: i64 = 1;\\n        for i in 1..=m as i64 - 1 {\\n            ans = ans * (n as i64 - 1 + i) / i;\\n        }\\n        ans as i32\\n    }\\n}\\n```\\n``` Go []\\nfunc uniquePaths(m int, n int) int {\\n    ans := 1\\n    for i := 1; i <= m - 1; i++ {\\n        ans = ans * (n - 1 + i) / i\\n    }\\n    return ans\\n}\\n```\\n``` C++ []\\n#include <cmath>\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        long long ans = 1;\\n        for (int i = 1; i <= m - 1; ++i) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function uniquePaths($m, $n) {\\n        $ans = 1;\\n        for ($i = 1; $i <= $m - 1; ++$i) {\\n            $ans = $ans * ($n - 1 + $i) / $i;\\n        }\\n        return (int)$ans;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    let ans = 1;\\n    for (let i = 1; i <= m - 1; i++) {\\n        ans = ans * (n - 1 + i) / i;\\n    }\\n    return ans;\\n};\\n```\\n# Code DP - 2D\\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[1 if i == 0 or j == 0 else 0 for j in range(n)] for i in range(m)]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            dp[i][0] = 1;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            dp[0][j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dp[i][0] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\\n        let mut dp: Vec<Vec<i32>> = vec![vec![1; n as usize]; m as usize];\\n        \\n        for i in 1..m as usize {\\n            for j in 1..n as usize {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        dp[(m-1) as usize][(n-1) as usize]\\n    }\\n}\\n```\\n``` Go []\\nfunc uniquePaths(m int, n int) int {\\n    dp := make([][]int, m)\\n    for i := range dp {\\n        dp[i] = make([]int, n)\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        dp[i][0] = 1\\n    }\\n    for j := 0; j < n; j++ {\\n        dp[0][j] = 1\\n    }\\n    \\n    for i := 1; i < m; i++ {\\n        for j := 1; j < n; j++ {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        }\\n    }\\n    \\n    return dp[m-1][n-1]\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        int[,] dp = new int[m, n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dp[i, 0] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[0, j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i, j] = dp[i-1, j] + dp[i, j-1];\\n            }\\n        }\\n        \\n        return dp[m-1, n-1];\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function uniquePaths($m, $n) {\\n        $dp = array_fill(0, $m, array_fill(0, $n, 0));\\n        \\n        for ($i = 0; $i < $m; ++$i) {\\n            $dp[$i][0] = 1;\\n        }\\n        for ($j = 0; $j < $n; ++$j) {\\n            $dp[0][$j] = 1;\\n        }\\n        \\n        for ($i = 1; $i < $m; ++$i) {\\n            for ($j = 1; $j < $n; ++$j) {\\n                $dp[$i][$j] = $dp[$i-1][$j] + $dp[$i][$j-1];\\n            }\\n        }\\n        \\n        return $dp[$m-1][$n-1];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    const dp = Array.from({ length: m }, () => Array(n).fill(0));\\n    \\n    for (let i = 0; i < m; ++i) {\\n        dp[i][0] = 1;\\n    }\\n    for (let j = 0; j < n; ++j) {\\n        dp[0][j] = 1;\\n    }\\n    \\n    for (let i = 1; i < m; ++i) {\\n        for (let j = 1; j < n; ++j) {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        }\\n    }\\n    \\n    return dp[m-1][n-1];\\n};\\n```\\n# Code DP - 1D\\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        curr_row = [1] * n\\n        prev_row = [1] * n\\n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                curr_row[j] = curr_row[j - 1] + prev_row[j]    \\n            curr_row, prev_row = prev_row, curr_row\\n        \\n        return prev_row[-1]\\n```\\n\\n## Final Thoughts\\n\\nBoth solutions are valid for the given problem constraints. The Dynamic Programming approach is more general and can be extended to more complex scenarios, such as when some cells are blocked. On the other hand, the Combinatorial Mathematics approach is more efficient for this specific problem.\\n\\nTackling this problem offers a deep dive into Dynamic Programming and Combinatorial Mathematics. Whether you use a dynamic table or mathematical combinations, each approach is a lesson in computational thinking. This isn\\'t just a problem; it\\'s a tool for honing your optimization and math skills. So dive in and advance your algorithm mastery. \\uD83D\\uDE80\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\uD83C\\uDF1F",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m+n-2, m-1)\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\\n        let mut ans: i64 = 1;\\n        for i in 1..=m as i64 - 1 {\\n            ans = ans * (n as i64 - 1 + i) / i;\\n        }\\n        ans as i32\\n    }\\n}\\n```\n``` Go []\\nfunc uniquePaths(m int, n int) int {\\n    ans := 1\\n    for i := 1; i <= m - 1; i++ {\\n        ans = ans * (n - 1 + i) / i\\n    }\\n    return ans\\n}\\n```\n``` C++ []\\n#include <cmath>\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        long long ans = 1;\\n        for (int i = 1; i <= m - 1; ++i) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function uniquePaths($m, $n) {\\n        $ans = 1;\\n        for ($i = 1; $i <= $m - 1; ++$i) {\\n            $ans = $ans * ($n - 1 + $i) / $i;\\n        }\\n        return (int)$ans;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    let ans = 1;\\n    for (let i = 1; i <= m - 1; i++) {\\n        ans = ans * (n - 1 + i) / i;\\n    }\\n    return ans;\\n};\\n```\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[1 if i == 0 or j == 0 else 0 for j in range(n)] for i in range(m)]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            dp[i][0] = 1;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            dp[0][j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dp[i][0] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\\n        let mut dp: Vec<Vec<i32>> = vec![vec![1; n as usize]; m as usize];\\n        \\n        for i in 1..m as usize {\\n            for j in 1..n as usize {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        dp[(m-1) as usize][(n-1) as usize]\\n    }\\n}\\n```\n``` Go []\\nfunc uniquePaths(m int, n int) int {\\n    dp := make([][]int, m)\\n    for i := range dp {\\n        dp[i] = make([]int, n)\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        dp[i][0] = 1\\n    }\\n    for j := 0; j < n; j++ {\\n        dp[0][j] = 1\\n    }\\n    \\n    for i := 1; i < m; i++ {\\n        for j := 1; j < n; j++ {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        }\\n    }\\n    \\n    return dp[m-1][n-1]\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        int[,] dp = new int[m, n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dp[i, 0] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[0, j] = 1;\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i, j] = dp[i-1, j] + dp[i, j-1];\\n            }\\n        }\\n        \\n        return dp[m-1, n-1];\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function uniquePaths($m, $n) {\\n        $dp = array_fill(0, $m, array_fill(0, $n, 0));\\n        \\n        for ($i = 0; $i < $m; ++$i) {\\n            $dp[$i][0] = 1;\\n        }\\n        for ($j = 0; $j < $n; ++$j) {\\n            $dp[0][$j] = 1;\\n        }\\n        \\n        for ($i = 1; $i < $m; ++$i) {\\n            for ($j = 1; $j < $n; ++$j) {\\n                $dp[$i][$j] = $dp[$i-1][$j] + $dp[$i][$j-1];\\n            }\\n        }\\n        \\n        return $dp[$m-1][$n-1];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    const dp = Array.from({ length: m }, () => Array(n).fill(0));\\n    \\n    for (let i = 0; i < m; ++i) {\\n        dp[i][0] = 1;\\n    }\\n    for (let j = 0; j < n; ++j) {\\n        dp[0][j] = 1;\\n    }\\n    \\n    for (let i = 1; i < m; ++i) {\\n        for (let j = 1; j < n; ++j) {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        }\\n    }\\n    \\n    return dp[m-1][n-1];\\n};\\n```\n``` Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        curr_row = [1] * n\\n        prev_row = [1] * n\\n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                curr_row[j] = curr_row[j - 1] + prev_row[j]    \\n            curr_row, prev_row = prev_row, curr_row\\n        \\n        return prev_row[-1]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1175465,
                "title": "java-3-approaches-dp-recursion-memoization",
                "content": "# Recursive approach:\\nThis approach will lead to TLE as we are calculating the same subproblems again and again. \\n\\nFor e.g. when m = 3 and n = 3, then we evaluate the function call with (m, n) as (2, 2) twice.\\n\\n![image](https://assets.leetcode.com/users/images/beaf8366-60b5-4a6a-9515-e1e850743950_1619423613.0065389.png)\\n\\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n\\t\\t// base case\\n        if(m == 1 || n == 1) return 1;\\n        \\n\\t\\t// move up\\n        int upMove = uniquePaths(m-1, n);\\n\\t\\t// move left\\n        int leftMove = uniquePaths(m, n-1);\\n        \\n        return upMove + leftMove;\\n    }\\n}\\n```\\n\\nTime Complexity : `O(2^(m * n))`\\nSpace Complexity : `O(m + n)`\\n\\n# Memoization approach:\\n\\nHere, we store the value for number of unique paths calculated for cell(i, j), so that if we encounter same subproblem in further recursive calls, we can directly use the calculated value instead of re-calculating for that cell. \\n\\n```\\nclass Solution {\\n    private Map<String, Integer> map = new HashMap<String, Integer>();\\n    public int uniquePaths(int m, int n) {\\n        // base case       \\n        if(m == 1 || n == 1) return 1;\\n        \\n        // check if we have already calculated unique paths for cell(m, n)\\n        String cell = new String(m + \",\" + n);\\n        // if yes, then get its value from our memoization table\\n        if(map.containsKey(cell)) \\n            return map.get(cell);\\n        \\n        // else, explore the up move\\n        int upMove = uniquePaths(m-1, n);\\n        // explore the left move\\n        int leftMove = uniquePaths(m, n-1);\\n        \\n        // put the value obtained for unique paths from cell(m, n)\\n        map.put(cell, upMove + leftMove);\\n        \\n        return upMove + leftMove;\\n    }    \\n}\\n```\\n\\nTime Complexity : `O(m * n)`\\nSpace Complexity : `O(m * n)`\\n\\n# DP approach:\\n\\nUsing DP, we find the number of unique paths from a given cell is equal to as the sum of the values of its previous possible states.\\n<code>dp[i,j] = dp[i-1,j] + dp[i,j-1]</code> gives us the idea. To reach the position (i, j), the path should either be coming from (i-1, j) or (i, j-1).\\n\\nNow, we can tabulate number of paths in two methods:\\n1. We start from top-left corner i.e. (0, 0) and finding paths in forward approach by using the formula <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>. The base case here is when <code>i == 0 || j == 0</code>, <code>dp[i][j] = 1</code>. Here, <code>dp[i][j]</code> represents the number of paths from cell (0, 0) to cell (i, j). \\n\\n![image](https://assets.leetcode.com/users/images/94a2048d-9abe-41fb-be2d-d011a810ba59_1619336032.060753.png)\\n\\n2. We will start from the bottom-left corner (m, n) and find finding paths using backward approach using the formula <code>dp[i][j] = dp[i+1][j] + dp[i][j+1]</code>, where m = no. of rows and n = no. of columns. The base case here is when <code>i == m-1 || j == n-1</code>, <code>dp[i][j] = 1</code>. Here, <code>dp[i][j]</code> \\xA0represents the number of paths from cell (m, n) to cell (i, j).\\n\\n![image](https://assets.leetcode.com/users/images/b1a2dc40-e197-4f3a-acda-8ae59e242038_1619336059.7530973.png)\\n\\n\\n**Method 1:**\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n ; j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n**Method 2:**\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--){\\n                if(i == m - 1 || j == n - 1)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i][j+1] + dp[i+1][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\\nTime Complexity : `O(m * n)`\\nSpace Complexity : `O(m * n)`\\n\\n**Please UPVOTE if you like the solution :)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n\\t\\t// base case\\n        if(m == 1 || n == 1) return 1;\\n        \\n\\t\\t// move up\\n        int upMove = uniquePaths(m-1, n);\\n\\t\\t// move left\\n        int leftMove = uniquePaths(m, n-1);\\n        \\n        return upMove + leftMove;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Map<String, Integer> map = new HashMap<String, Integer>();\\n    public int uniquePaths(int m, int n) {\\n        // base case       \\n        if(m == 1 || n == 1) return 1;\\n        \\n        // check if we have already calculated unique paths for cell(m, n)\\n        String cell = new String(m + \",\" + n);\\n        // if yes, then get its value from our memoization table\\n        if(map.containsKey(cell)) \\n            return map.get(cell);\\n        \\n        // else, explore the up move\\n        int upMove = uniquePaths(m-1, n);\\n        // explore the left move\\n        int leftMove = uniquePaths(m, n-1);\\n        \\n        // put the value obtained for unique paths from cell(m, n)\\n        map.put(cell, upMove + leftMove);\\n        \\n        return upMove + leftMove;\\n    }    \\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n ; j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--){\\n                if(i == m - 1 || j == n - 1)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i][j+1] + dp[i+1][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994830,
                "title": "step-by-step-beginner-friendly-dp-3-approaches-full-explanation-dp",
                "content": "# Question Understanding-\\n\\n**Given are only two valid moves :**\\n- **Move right**\\n- **Move down**\\nHence, it is clear number of paths from cell (i,j) = sum of paths from cell( i+1,j) and cell(i,j+1)\\n\\n**It becomes a DP problem.**\\nBut implementing DP directly **will lead to TLE**.\\n**So memoization is useful -> Storing a result** so that we donot need to calculate it again.\\n\\ndp[i][j] = d[i+1][j] + dp[i][j+1]\\n\\n# BASE CASES\\n\\n**If we are in last row**, i == m-1, we only have the choice to move RIGHT, Hence number of moves will be 1.\\n**If we are in last column**, j == n-1, we only have the choice to move DOWN, Hence number of moves will be 1.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Step-by-Step Solution:\\n\\n---\\n\\n\\n---\\n# **Bottom-Up Dynamic Programming:**\\n\\n**Step 1: Initialize the DP Table**\\n- Create a 2D DP (dynamic programming) table of **size m x n** to store the number of unique paths for each cell.\\n- **Initialize the rightmost column and bottom row of the DP table to 1** because there\\'s only one way to reach each cell in those rows/columns (by moving all the way right or all the way down).\\n\\n**Step 2: Fill in the DP Table**\\n\\n- **Start from the second-to-last** row and second-to-last column (i.e., i = m - 2 and j = n - 2).\\n- **For each cell (i, j) in the grid:**\\n    - Calculate the **number of unique paths to reach (i, j)** as the sum of the unique paths from the cell below (i+1, j) and **the cell to the right (i, j+1)**. Use this formula: **dp[i][j] = dp[i+1][j] + dp[i][j+1].**\\n    - **Continue filling** in the DP table row by row and column by column until you reach the top-left corner (dp[0][0]).\\n\\n**Step 3: Return the Result**\\n\\n- Return the value stored in the top-left corner of the DP table (dp[0][0]), which represents the number of unique paths from the top-left corner to the bottom-right corner.\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n---\\n\\n\\n# **Top-Down Dynamic Programming:**\\n\\n**Step 1: Initialize the Memoization Table**\\n\\n- **Create a memoization table** (an auxiliary 2D array) of size m x n to store computed results. Initialize all entries to -1 to indicate that no results have been computed yet.\\n\\n**Step 2: Recursive Function**\\n- **Implement a recursive function**, say **uniquePathsRecursive(x, y, m, n, memo)**, which calculates the number of unique paths to reach cell (x, y) from the top-left corner.\\n- **In this function:**\\n    - **Check if (x, y) is the destination cell** (m - 1, n - 1). If yes, return 1 since there is one way to reach the destination.\\n    - **Check if the result for (x, y) is already computed** in the memoization table (memo[x][y] != -1). **If yes, return the stored result.**    \\n\\n    - **Otherwise, calculate the number of unique paths** by recursively moving right and down (if valid) and adding the results. **Use the following logic:**\\n            \\u27A1**If (x, y) can move right** (i.e., x < m - 1), calculate rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo).\\n            \\u27A1 **If (x, y) can move down** (i.e., y < n - 1), calculate downPaths = uniquePathsRecursive(x, y + 1, m, n, memo).\\n            \\u27A1 **The total unique paths to (x, y) are rightPaths + downPaths.**\\n            \\u27A1** Store the result** in the memoization table (memo[x][y]) and return it. \\n\\n**Step 3: Invoke the Recursive Function**\\n\\n- Call the recursive function with the initial arguments (0, 0, m, n, memo) to find the number of unique paths.\\n\\n**Step 4: Return the Result**\\n\\n- The result obtained from the recursive function call represents the number of unique paths from the top-left corner to the bottom-right corner.\\n # Complexity\\n\\n---\\n\\n\\n**Bottom-Up Dynamic Programming:**\\n**Time Complexity (TC):** The bottom-up approach fills in the DP table iteratively, visiting each cell once. There are m rows and n columns in the grid, so the TC is **O(m * n)**.\\n**Space Complexity (SC):** The space complexity is determined by the DP table, which is of size m x n. Therefore, **the SC is O(m * n)** to store the DP table.\\n\\n---\\n\\n\\n**Top-Down Dynamic Programming (with Memoization):**\\n**Time Complexity (TC):** O(m * n).\\n**Space Complexity (SC):** O(m + n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n---\\n\\n\\n\\n# \\uD83D\\uDE0A\\uD83D\\uDE0ASMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n---\\n\\n\\n# Bottom up Approach Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        // Initialize the rightmost column and bottom row to 1 because there is only one way to reach each cell in those rows/columns.\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[m-1][j] = 1;\\n        }\\n        \\n        // Fill in the dp table bottom-up\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n\\n```\\n```python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Create a 2D DP table filled with zeros\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the rightmost column and bottom row to 1\\n        for i in range(m):\\n            dp[i][n-1] = 1\\n        for j in range(n):\\n            dp[m-1][j] = 1\\n        \\n        # Fill in the DP table bottom-up\\n        for i in range(m - 2, -1, -1):\\n            for j in range(n - 2, -1, -1):\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        \\n        # Return the result stored in the top-left corner\\n        return dp[0][0]\\n\\n```\\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        // Create a 2D DP array filled with zeros\\n        int[][] dp = new int[m][n];\\n        \\n        // Initialize the rightmost column and bottom row to 1\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[m-1][j] = 1;\\n        }\\n        \\n        // Fill in the DP array bottom-up\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        // Return the result stored in the top-left corner\\n        return dp[0][0];\\n    }\\n}\\n\\n```\\n```Javascript []\\nvar uniquePaths = function(m, n) {\\n    // Create a 2D DP array filled with zeros\\n    let dp = new Array(m).fill().map(() => new Array(n).fill(0));\\n    \\n    // Initialize the rightmost column and bottom row to 1\\n    for (let i = 0; i < m; i++) {\\n        dp[i][n-1] = 1;\\n    }\\n    for (let j = 0; j < n; j++) {\\n        dp[m-1][j] = 1;\\n    }\\n    \\n    // Fill in the DP array bottom-up\\n    for (let i = m - 2; i >= 0; i--) {\\n        for (let j = n - 2; j >= 0; j--) {\\n            dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n        }\\n    }\\n    \\n    // Return the result stored in the top-left corner\\n    return dp[0][0];\\n};\\n\\n```\\n# Top-Down Approach Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        // Create a memoization table to store computed results\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        \\n        // Call the recursive function to compute unique paths\\n        return uniquePathsRecursive(0, 0, m, n, memo);\\n    }\\n    \\n    int uniquePathsRecursive(int x, int y, int m, int n, vector<vector<int>>& memo) {\\n        // If we reach the destination (bottom-right corner), return 1\\n        if (x == m - 1 && y == n - 1) {\\n            return 1;\\n        }\\n        \\n        // If we have already computed the result for this cell, return it from the memo table\\n        if (memo[x][y] != -1) {\\n            return memo[x][y];\\n        }\\n        \\n        // Calculate the number of unique paths by moving right and down\\n        int rightPaths = 0;\\n        int downPaths = 0;\\n        \\n        // Check if it\\'s valid to move right\\n        if (x < m - 1) {\\n            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n        }\\n        \\n        // Check if it\\'s valid to move down\\n        if (y < n - 1) {\\n            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n        }\\n        \\n        // Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths;\\n        return memo[x][y];\\n    }\\n};\\n\\n```\\n```python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Create a memoization table to store computed results\\n        memo = [[-1 for _ in range(n)] for _ in range(m)]\\n        \\n        # Call the recursive function to compute unique paths\\n        return self.uniquePathsRecursive(0, 0, m, n, memo)\\n    \\n    def uniquePathsRecursive(self, x: int, y: int, m: int, n: int, memo: List[List[int]]) -> int:\\n        # If we reach the destination (bottom-right corner), return 1\\n        if x == m - 1 and y == n - 1:\\n            return 1\\n        \\n        # If we have already computed the result for this cell, return it from the memo table\\n        if memo[x][y] != -1:\\n            return memo[x][y]\\n        \\n        # Calculate the number of unique paths by moving right and down\\n        rightPaths = 0\\n        downPaths = 0\\n        \\n        # Check if it\\'s valid to move right\\n        if x < m - 1:\\n            rightPaths = self.uniquePathsRecursive(x + 1, y, m, n, memo)\\n        \\n        # Check if it\\'s valid to move down\\n        if y < n - 1:\\n            downPaths = self.uniquePathsRecursive(x, y + 1, m, n, memo)\\n        \\n        # Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths\\n        return memo[x][y]\\n\\n```\\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        // Create a memoization table to store computed results\\n        int[][] memo = new int[m][n];\\n        \\n        // Initialize the memoization table with -1 to indicate uncomputed results\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        \\n        // Call the recursive function to compute unique paths\\n        return uniquePathsRecursive(0, 0, m, n, memo);\\n    }\\n    \\n    public int uniquePathsRecursive(int x, int y, int m, int n, int[][] memo) {\\n        // If we reach the destination (bottom-right corner), return 1\\n        if (x == m - 1 && y == n - 1) {\\n            return 1;\\n        }\\n        \\n        // If we have already computed the result for this cell, return it from the memo table\\n        if (memo[x][y] != -1) {\\n            return memo[x][y];\\n        }\\n        \\n        // Calculate the number of unique paths by moving right and down\\n        int rightPaths = 0;\\n        int downPaths = 0;\\n        \\n        // Check if it\\'s valid to move right\\n        if (x < m - 1) {\\n            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n        }\\n        \\n        // Check if it\\'s valid to move down\\n        if (y < n - 1) {\\n            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n        }\\n        \\n        // Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths;\\n        return memo[x][y];\\n    }\\n}\\n\\n```\\n```Javascript []\\nvar uniquePaths = function(m, n) {\\n    // Create a memoization table to store computed results\\n    let memo = new Array(m).fill(null).map(() => new Array(n).fill(-1));\\n    \\n    // Call the recursive function to compute unique paths\\n    return uniquePathsRecursive(0, 0, m, n, memo);\\n};\\n\\nvar uniquePathsRecursive = function(x, y, m, n, memo) {\\n    // If we reach the destination (bottom-right corner), return 1\\n    if (x === m - 1 && y === n - 1) {\\n        return 1;\\n    }\\n    \\n    // If we have already computed the result for this cell, return it from the memo table\\n    if (memo[x][y] !== -1) {\\n        return memo[x][y];\\n    }\\n    \\n    // Calculate the number of unique paths by moving right and down\\n    let rightPaths = 0;\\n    let downPaths = 0;\\n    \\n    // Check if it\\'s valid to move right\\n    if (x < m - 1) {\\n        rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n    }\\n    \\n    // Check if it\\'s valid to move down\\n    if (y < n - 1) {\\n        downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n    }\\n    \\n    // Store the result in the memo table and return it\\n    memo[x][y] = rightPaths + downPaths;\\n    return memo[x][y];\\n};\\n\\n```\\n# \\uD83D\\uDE0A\\uD83D\\uDE0ASMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A![UPVOTE.png](https://assets.leetcode.com/users/images/0c91ddd3-d9da-49c8-8add-2898aa10de7a_1693712670.8764517.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        \\n        // Initialize the rightmost column and bottom row to 1 because there is only one way to reach each cell in those rows/columns.\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[m-1][j] = 1;\\n        }\\n        \\n        // Fill in the dp table bottom-up\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n\\n```\n```python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Create a 2D DP table filled with zeros\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the rightmost column and bottom row to 1\\n        for i in range(m):\\n            dp[i][n-1] = 1\\n        for j in range(n):\\n            dp[m-1][j] = 1\\n        \\n        # Fill in the DP table bottom-up\\n        for i in range(m - 2, -1, -1):\\n            for j in range(n - 2, -1, -1):\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        \\n        # Return the result stored in the top-left corner\\n        return dp[0][0]\\n\\n```\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        // Create a 2D DP array filled with zeros\\n        int[][] dp = new int[m][n];\\n        \\n        // Initialize the rightmost column and bottom row to 1\\n        for (int i = 0; i < m; i++) {\\n            dp[i][n-1] = 1;\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dp[m-1][j] = 1;\\n        }\\n        \\n        // Fill in the DP array bottom-up\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = n - 2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        // Return the result stored in the top-left corner\\n        return dp[0][0];\\n    }\\n}\\n\\n```\n```Javascript []\\nvar uniquePaths = function(m, n) {\\n    // Create a 2D DP array filled with zeros\\n    let dp = new Array(m).fill().map(() => new Array(n).fill(0));\\n    \\n    // Initialize the rightmost column and bottom row to 1\\n    for (let i = 0; i < m; i++) {\\n        dp[i][n-1] = 1;\\n    }\\n    for (let j = 0; j < n; j++) {\\n        dp[m-1][j] = 1;\\n    }\\n    \\n    // Fill in the DP array bottom-up\\n    for (let i = m - 2; i >= 0; i--) {\\n        for (let j = n - 2; j >= 0; j--) {\\n            dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n        }\\n    }\\n    \\n    // Return the result stored in the top-left corner\\n    return dp[0][0];\\n};\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        // Create a memoization table to store computed results\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        \\n        // Call the recursive function to compute unique paths\\n        return uniquePathsRecursive(0, 0, m, n, memo);\\n    }\\n    \\n    int uniquePathsRecursive(int x, int y, int m, int n, vector<vector<int>>& memo) {\\n        // If we reach the destination (bottom-right corner), return 1\\n        if (x == m - 1 && y == n - 1) {\\n            return 1;\\n        }\\n        \\n        // If we have already computed the result for this cell, return it from the memo table\\n        if (memo[x][y] != -1) {\\n            return memo[x][y];\\n        }\\n        \\n        // Calculate the number of unique paths by moving right and down\\n        int rightPaths = 0;\\n        int downPaths = 0;\\n        \\n        // Check if it\\'s valid to move right\\n        if (x < m - 1) {\\n            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n        }\\n        \\n        // Check if it\\'s valid to move down\\n        if (y < n - 1) {\\n            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n        }\\n        \\n        // Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths;\\n        return memo[x][y];\\n    }\\n};\\n\\n```\n```python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Create a memoization table to store computed results\\n        memo = [[-1 for _ in range(n)] for _ in range(m)]\\n        \\n        # Call the recursive function to compute unique paths\\n        return self.uniquePathsRecursive(0, 0, m, n, memo)\\n    \\n    def uniquePathsRecursive(self, x: int, y: int, m: int, n: int, memo: List[List[int]]) -> int:\\n        # If we reach the destination (bottom-right corner), return 1\\n        if x == m - 1 and y == n - 1:\\n            return 1\\n        \\n        # If we have already computed the result for this cell, return it from the memo table\\n        if memo[x][y] != -1:\\n            return memo[x][y]\\n        \\n        # Calculate the number of unique paths by moving right and down\\n        rightPaths = 0\\n        downPaths = 0\\n        \\n        # Check if it\\'s valid to move right\\n        if x < m - 1:\\n            rightPaths = self.uniquePathsRecursive(x + 1, y, m, n, memo)\\n        \\n        # Check if it\\'s valid to move down\\n        if y < n - 1:\\n            downPaths = self.uniquePathsRecursive(x, y + 1, m, n, memo)\\n        \\n        # Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths\\n        return memo[x][y]\\n\\n```\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        // Create a memoization table to store computed results\\n        int[][] memo = new int[m][n];\\n        \\n        // Initialize the memoization table with -1 to indicate uncomputed results\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        \\n        // Call the recursive function to compute unique paths\\n        return uniquePathsRecursive(0, 0, m, n, memo);\\n    }\\n    \\n    public int uniquePathsRecursive(int x, int y, int m, int n, int[][] memo) {\\n        // If we reach the destination (bottom-right corner), return 1\\n        if (x == m - 1 && y == n - 1) {\\n            return 1;\\n        }\\n        \\n        // If we have already computed the result for this cell, return it from the memo table\\n        if (memo[x][y] != -1) {\\n            return memo[x][y];\\n        }\\n        \\n        // Calculate the number of unique paths by moving right and down\\n        int rightPaths = 0;\\n        int downPaths = 0;\\n        \\n        // Check if it\\'s valid to move right\\n        if (x < m - 1) {\\n            rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n        }\\n        \\n        // Check if it\\'s valid to move down\\n        if (y < n - 1) {\\n            downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n        }\\n        \\n        // Store the result in the memo table and return it\\n        memo[x][y] = rightPaths + downPaths;\\n        return memo[x][y];\\n    }\\n}\\n\\n```\n```Javascript []\\nvar uniquePaths = function(m, n) {\\n    // Create a memoization table to store computed results\\n    let memo = new Array(m).fill(null).map(() => new Array(n).fill(-1));\\n    \\n    // Call the recursive function to compute unique paths\\n    return uniquePathsRecursive(0, 0, m, n, memo);\\n};\\n\\nvar uniquePathsRecursive = function(x, y, m, n, memo) {\\n    // If we reach the destination (bottom-right corner), return 1\\n    if (x === m - 1 && y === n - 1) {\\n        return 1;\\n    }\\n    \\n    // If we have already computed the result for this cell, return it from the memo table\\n    if (memo[x][y] !== -1) {\\n        return memo[x][y];\\n    }\\n    \\n    // Calculate the number of unique paths by moving right and down\\n    let rightPaths = 0;\\n    let downPaths = 0;\\n    \\n    // Check if it\\'s valid to move right\\n    if (x < m - 1) {\\n        rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo);\\n    }\\n    \\n    // Check if it\\'s valid to move down\\n    if (y < n - 1) {\\n        downPaths = uniquePathsRecursive(x, y + 1, m, n, memo);\\n    }\\n    \\n    // Store the result in the memo table and return it\\n    memo[x][y] = rightPaths + downPaths;\\n    return memo[x][y];\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711190,
                "title": "python-2-solutions-dp-and-oneliner-math-explained",
                "content": "### 1. Dynamic programming solution\\nOne way to solve this problem is to use **dynamic programming**: define by `dp[i][j]` number of ways to reach point `(i,j)`. How can we reach it, there are two options:\\n1. We can reach it from above `(i, j-1)`.\\n2. We can reach it from the left: `(i-1, j)`.\\n\\nThat is all! We just evaluate `dp[i][j] = dp[i-1][j] + dp[i][j-1]`\\n**Complexity**: time comlexity is `O(mn)`, space complexity is `O(mn)`, which can be improved to `O(min(m,n))`.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1] * n for _ in range(m)]\\n        for i,j in product(range(1,m),range(1,n)):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]            \\n        return dp[-1][-1]\\n```\\n\\n### 2. Math solution\\n\\nNote, that we need to make overall `n + m - 2` steps, and exactly `m - 1` of them need to be right moves and `n - 1` down steps. By definition this is numbef of combinations to choose `n - 1` elements from `n + m - 2`.\\n\\n**Complexity**: time complexity is `O(m+n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        return factorial(m+n-2)//factorial(m-1)//factorial(n-1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        dp = [[1] * n for _ in range(m)]\\n        for i,j in product(range(1,m),range(1,n)):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]            \\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m, n):\\n        return factorial(m+n-2)//factorial(m-1)//factorial(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23230,
                "title": "java-dp-with-o-n-space",
                "content": "We only need to store the previous row/column to perform the calculation for the next one. So an 1-d array would suffice. You could also choose to iterate through m or n depending on which direction you choose to go (by row or by column). Note that the first element of the array will always be 1.\\n\\n    public class Solution {\\n        public int uniquePaths(int m, int n) {\\n            int[] arr = new int[m];\\n            for (int i = 0; i < m; i++) {\\n                arr[i] = 1;\\n            }\\n            for (int i = 1; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    arr[j] = arr[j] + arr[j-1];\\n                }\\n            }\\n            return arr[m-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int uniquePaths(int m, int n) {\\n            int[] arr = new int[m];\\n            for (int i = 0; i < m; i++) {\\n                arr[i] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2362096,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\nGiven are only two valid moves :\\n* Move right\\n* Move down\\n*Hence,* it is clear number of paths from ```cell (i,j)``` = sum of paths from ```cell( i+1,j) and cell(i,j+1)``` \\n\\nIt becomes a DP problem.\\nBut implementing **DP** directly will lead to **TLE**\\nSo memoization is useful -> Storing a result so that we donot need to calculate it again.\\n\\n```dp[i][j] = d[i+1][j] + dp[i][j+1]```\\n\\n**BASE CASES**\\n* If we are in last row, ```i == m-1```, we only have the choice to move **RIGHT**, Hence number of moves will be **1**.\\n* If we are in last column, ```j == n-1```, we only have the choice to move **DOWN**, Hence number of moves will be **1**.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>> &dp, int& m, int& n) {\\n        if(i == m-1 || j == n-1) return 1;\\n        if(dp[i][j] != 0)return dp[i][j];\\n        \\n        dp[i][j] = solve(i+1, j, dp, m, n) + solve(i, j+1, dp, m, n);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m , vector<int>(n , 0));\\n        return solve(0, 0, dp, m, n);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/df8b4e17-aa90-43e4-aba4-112caf0795a7_1659315381.4456522.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```cell (i,j)```\n```cell( i+1,j) and cell(i,j+1)```\n```dp[i][j] = d[i+1][j] + dp[i][j+1]```\n```i == m-1```\n```j == n-1```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>> &dp, int& m, int& n) {\\n        if(i == m-1 || j == n-1) return 1;\\n        if(dp[i][j] != 0)return dp[i][j];\\n        \\n        dp[i][j] = solve(i+1, j, dp, m, n) + solve(i, j+1, dp, m, n);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m , vector<int>(n , 0));\\n        return solve(0, 0, dp, m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363008,
                "title": "python-detailed-explanation-easy-understand-dp-math",
                "content": "**Appreciate if you could upvote this solution**\\n\\n**Method 1: `DP`**\\n\\nImagine that we store the grid in a 2D matrix\\nIf we want to go to dp[i][j], we can only either come from the left side or the top side.\\n![image](https://assets.leetcode.com/users/images/df065f88-f410-4313-b187-0ef8e434faed_1659331435.2545106.png)\\nThus, the total combinations for reaching `dp[i][j]`\\n= `dp[i-1][j] (*from the left*) + dp[i][j-1] (*from the top*)` **for i != 0 and j != 0**\\n\\nFor initializing the `dp` matrix, we need to set 1 to the first row and first column because there is only one way to reach `dp[0][j]` and `dp[i][0]`\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Initialize the first row and column to 1\\n        # Since the combination for \\n        # dp[i][0] = dp[i-1][0]\\n        # dp[0][j] = dp[0][j-1]\\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n\\n        # df_table = [[1]*n] + [[1] + [0]*(n-1) ] * (m-1)\\n\\t\\t# Since dp[i][j] only depends on the calculated cells before,\\n\\t\\t# we can simply initialize the value of all cells to 1.\\n        dp = [[1]*n] * m\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\\n\\n        return dp[-1][-1]\\n```\\n\\n<br/>\\n\\n**Advanced solution**:\\nSince some of the paths are just reversed, we can ignore the calculated for those reversed paths to optimize the execution time.\\n\\n```\\nclass Solution:\\n    dp = dict()\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if m > n:\\n            r = m\\n            c = n\\n        else:\\n            r = n\\n            c = m\\n            \\n        if r == 1 or c == 1:\\n            return 1\\n\\n        if (r, c) not in self.dp:\\n            self.dp[(r, c)] = self.uniquePaths(r - 1, c) + self.uniquePaths(r, c - 1)\\n\\n        return self.dp[(r,c)]\\n```\\nTime complexity: `O(n * m)`\\nSpace complexity:  `O(n)`\\n<br/>\\n<br/>\\n \\n**Method 2: `math`**\\n\\nFor a grid with `m` rows and `n` columns, there are `m + n - 2` steps to the destination.\\nFor example, if `m = 3` and `n = 7`\\n\\n![image](https://assets.leetcode.com/users/images/11c9d780-ba87-418a-8d2a-b4cc479c56e0_1659333082.6938484.png)\\ne.g. the `-2`  in this path means ignoring the starting cell and the overlapped corner.\\n\\nIn these  `m + n - 2` steps, we can have `n - 1` times to choose to turn right *(or `m - 1` times to choose to turn down)*.\\nThus, the total combinations is  `(m+n-2) C (n-1)` / `C(m+n-2, n-1)`\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(n + m - 2, n - 1)\\n```\\n\\n**Time complexity**: `O(n * m)`\\n**Space complexity**:  `O(1)`\\n<br/>\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Initialize the first row and column to 1\\n        # Since the combination for \\n        # dp[i][0] = dp[i-1][0]\\n        # dp[0][j] = dp[0][j-1]\\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n\\n        # df_table = [[1]*n] + [[1] + [0]*(n-1) ] * (m-1)\\n\\t\\t# Since dp[i][j] only depends on the calculated cells before,\\n\\t\\t# we can simply initialize the value of all cells to 1.\\n        dp = [[1]*n] * m\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\\n\\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    dp = dict()\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if m > n:\\n            r = m\\n            c = n\\n        else:\\n            r = n\\n            c = m\\n            \\n        if r == 1 or c == 1:\\n            return 1\\n\\n        if (r, c) not in self.dp:\\n            self.dp[(r, c)] = self.uniquePaths(r - 1, c) + self.uniquePaths(r, c - 1)\\n\\n        return self.dp[(r,c)]\\n```\n```\\nimport math\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(n + m - 2, n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23003,
                "title": "1-line-math-solution-python",
                "content": "    class Solution(object):\\n        def uniquePaths(self, m, n):\\n            \"\"\"\\n            :type m: int\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            return math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def uniquePaths(self, m, n):\\n            \"\"\"\\n            :type m: int\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            return math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1)",
                "codeTag": "Java"
            },
            {
                "id": 22988,
                "title": "simple-c-version-using-math",
                "content": "    class Solution {\\n    public:\\n        int uniquePaths(int m, int n) {\\n            if(m <=0 || n <= 0) return 0;\\n            long long res = 1;\\n            for(int i = n; i < m+n-1 ; i++){\\n                res = res * i / (i- n + 1);\\n            }\\n            return (int)res;\\n        }\\n    };\\n\\nThe total step number should be m+n-2. This means that we have to move down for m-1 steps and move right n-1 steps to reach the definition. Then different choice number would be:\\n\\n\\n----------\\nUniqueStepNum = choose (m-1) from (m+n-2) = choose (n-1) from (m+n-2)\\n\\n----------\\n = (m+n-2)! / [(m-1)! * (n-1)!] \\n\\n----------\\n = ( (m+n-2) / (m-1) ) * ( (m+n-3) / (m-2) ) * ... * (n / 1)",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int uniquePaths(int m, int n) {\\n            if(m <=0 || n <= 0) return 0;\\n            long long res = 1;\\n            for(int i = n; i < m+n-1 ; i++){\\n                res = res * i / (i- n + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 474165,
                "title": "python-js-java-go-c-by-o-mn-dp-with-explanation",
                "content": "3 sol. based on dynamic programming, math analysis, and recursion.\\n\\n\\n[My tutorial with DP problem solving framework to unique paths [English]](https://medium.com/@cutesciuridae/dive-into-dp-take-unique-path-for-example-28c817ba4fe8?source=your_stories_page-------------------------------------)\\n\\n[My tutorial with DP problem solving framework to unique paths [Chinese]](https://medium.com/@cutesciuridae/dynamic-programming-%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-%E4%BB%A5unique-path%E7%82%BA%E4%BE%8B-2387bfab5722?source=your_stories_page-------------------------------------)\\n\\n[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://youtu.be/ZdGN8JZ23cU)\\n\\n[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0 + DP\\u601D\\u8003\\u6846\\u67B6](https://vocus.cc/article/65102de8fd89780001c2bfd9)\\n\\n---\\n\\nDiagram:\\n\\n![image](https://assets.leetcode.com/users/images/2cf56e11-729e-426b-be98-2ef81469d933_1613721428.3846037.png)\\n\\n\\n---\\n\\nmethod_#1: Dynamic Programming\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        rows, cols = m, n\\n        \\n        path_dp = [ [ 1 for j in range(cols)] for i in range(rows) ]\\n        \\n        \\n        # Dynamic Programming relation:\\n        \\n        # Base case:\\n        # DP(0, j) = 1 , only reachable from one step left\\n        # DP(i, 0) = 1 , only reachable from one step up\\n        \\n        # General case:\\n        # DP(i,j) = number of path reach to (i, j)\\n        #         = number of path reach to one step left + number of path reach to one step up\\n        #         = number of path reach to (i, j-1) + number of path to (i-1, j)\\n        #         = DP(i, j-1) + DP(i-1, j)\\n        \\n        \\n        \\n        for i in range(1, rows):\\n            for j in range(1, cols):\\n                \\n                path_dp[i][j] = path_dp[i][j-1] + path_dp[i-1][j]\\n        \\n        \\n        # Destination coordination = (rows-1, cols-1)\\n        return path_dp[rows-1][cols-1]\\n```\\n\\n---\\nC++\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n\\t\\n        vector< vector<int> > path(m, vector<int>(n, 1) );\\n        \\n        for(int y = 1 ; y < m ; y++){\\n            for(int x = 1 ; x < n ; x++){\\n                \\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y][x-1] + path[y-1][x];\\n            }\\n        }\\n        return path[m-1][n-1];\\n    }\\n};\\n```\\n\\t\\n</details>\\n\\n\\n---\\n\\nJava:\\n\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        \\n        int [][]path = new int[m][n];\\n        \\n        // Base case:\\n        \\n        // left-most column\\n        for(int y = 0 ; y < m ; y++){\\n            path[y][0] = 1;\\n        }\\n        \\n        // top-most row\\n        for(int x = 0 ; x < n ; x++){\\n            path[0][x] = 1;\\n        }\\n        \\n        // General cases\\n        for(int y = 1 ; y < m ; y++){\\n            for(int x = 1 ; x < n ; x++){\\n                \\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y][x-1] + path[y-1][x];\\n\\n            }\\n        }\\n        return path[m-1][n-1];        \\n    }\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nGo\\n\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nfunc uniquePaths(m int, n int) int {\\n    \\n    // Create 2D array with size m x n\\n    path := make( [][]int, m )\\n    rows := make( []int, m * n)\\n    for y := 0 ; y < m ; y++{\\n        path[y] = rows[ y*n : (y+1)*n]\\n    }\\n    \\n    for y := 0 ; y < m ; y++{\\n        for x := 0 ; x < n ; x++{\\n            \\n            if (y == 0) || (x == 0){\\n                path[y][x] = 1\\n            }else{\\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y-1][x] + path[y][x-1]\\n            }\\n            \\n        }\\n    }\\n    \\n    return path[m-1][n-1]\\n}\\n```\\n\\t\\n</details>\\n\\n---\\n\\nJavascript\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nvar uniquePaths = function(m, n) {\\n    let perRow = Array(n).fill(1);\\n    \\n    // pathCount is 2D array of size m * n\\n    let pathCount = Array.from( Array(m).fill( perRow ) );\\n    \\n    for(let y = 1 ; y < m ; y++){\\n        for(let x = 1 ; x < n ; x++){\\n            \\n            // path count = number of path reach to one step left + number of path reach to one step up\\n            pathCount[y][x] = pathCount[y][x-1] + pathCount[y-1][x] \\n        }\\n    }\\n    \\n    return pathCount[m-1][n-1]\\n\\n};\\n```\\n\\t\\n</details>\\n\\n\\n---------------------------------------\\n\\nmethod_#2: Math analysis\\n\\n```\\nfrom math import factorial\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        rows, cols = m, n\\n        \\n        # from start to destination, we need (m-1) \\u2193 moves and (n-1) \\u2192 moves\\n        # Thus, the number of unique paths is the number of permutations of (m-1) \\u2193 and (n-1) \\u2192\\n        #\\n        # Number of unique paths = ( m-1 + n-1 ) ! / (m-1)! * (n-1)!\\n        \\n        \\n        return factorial( m+n-2 ) // ( factorial( m-1 ) * factorial( n-1 ) )    \\n```\\n\\n---\\n\\nJavascript:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nvar uniquePaths = function(m, n) {\\n    \\n    \\n    // from start to destination, we need (m-1) \\u2193 moves and (n-1) \\u2192 moves\\n    // Thus, the number of unique paths is the number of permutations of (m-1) \\u2193 and (n-1) \\u2192\\n    //\\n    // Number of unique paths = ( m-1 + n-1 ) ! / (m-1)! * (n-1)!\\n    \\n    let pathCount = factorial( m-1 + n-1 ) / ( factorial( m-1 )*factorial( n-1 ) );\\n    \\n    return pathCount\\n\\n};\\n\\n\\nvar factorial = function( k ){\\n    \\n    if( k == 0 || k == 1 ){\\n        return 1;\\n    }else{\\n        return k * factorial(k-1);\\n    }\\n    \\n};\\n```\\n\\t\\n</details>\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nunsigned long int combination( int n, int k )\\n{\\n    if (k > n){     return 0;} \\n    if (k * 2 > n){ k = n-k; } \\n    if (k == 0){    return 1;} \\n\\n    unsigned long int result = n;\\n    for( int i = 2; i <= k; ++i ) {\\n        result *= (n-i+1);\\n        result /= i;\\n    }\\n    return result;\\n}\\n\\nclass Solution {\\npublic:\\n    unsigned int uniquePaths(int m, int n) {\\n        return combination( m-1+n-1, m-1);        \\n    }\\n};\\n```\\n\\t\\n</details>\\n\\n\\n---\\n\\nmethod_#3 Recursion + Memoization\\n\\n```\\n\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        # -----------------------------------\\n        \\n        # key: (m, n) size of grid\\n        # value: total path count from source to destinaion\\n        memo = {}\\n        \\n        def path_count(m, n):\\n            \\n            if (m, n) in memo:\\n                \\n                # look-up in memo\\n                return memo[(m, n)]\\n            \\n            if m == 0 or n == 0:\\n                \\n                # base case\\n                memo[(m, n)] = 0\\n                return 0\\n            \\n            elif m == 1 and n == 1:\\n                \\n                # base case\\n                memo[(m, n)] = 1\\n                return 1\\n\\n            # general case\\n            memo[(m, n)] = path_count(m-1, n) + path_count(m, n-1)\\n            return memo[(m, n)]\\n    \\n        # -----------------------------------\\n        return path_count(m, n)\\n    \\n    \\n\\n\\n```\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        \\n        tuple<int, int> curMatrixSize = tuple<int, int>{m, n};\\n        \\n        if( pathCount.count( curMatrixSize ) ){\\n            return pathCount[ curMatrixSize ];\\n        }\\n        \\n        if( m == 0 || n == 0 ){\\n            // base case\\n            pathCount[ curMatrixSize ] = 0;    \\n            return 0;\\n            \\n        }else if( m == 1 && n == 1){\\n            \\n            // base case\\n            pathCount[ curMatrixSize ] = 1;    \\n            return 1;\\n        }\\n        \\n        // general cases:\\n        pathCount[ curMatrixSize ] = uniquePaths(m-1, n) + uniquePaths(m, n-1);\\n        return pathCount[ curMatrixSize ];\\n        \\n\\n    }\\n\\nprivate:\\n    \\n    // key: tuple of (matrix height, matrix width)\\n    // value: path count of matrix from start to destination\\n    map< tuple<int, int>, int> pathCount;\\n\\n};\\n\\n```\\n\\t\\n</details>\\n\\n---\\n\\nJavascript:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nvar makeKey = function(m, n){\\n    return String(m) + \",\" + String(n);\\n}\\n\\nvar uniquePaths = function(m, n) {\\n    \\n    // key: tuple of (matrix height, matrix width)\\n    // value: path count of matrix from start to destination\\n    pathCount = { };\\n    \\n    var dp = function(m, n){\\n        \\n        let matrixSize = makeKey(m, n);\\n        \\n        if( matrixSize in pathCount ){\\n            return pathCount[matrixSize];\\n        }\\n        \\n        if( m == 0 && n == 0 ){\\n            // base case\\n            pathCount[matrixSize] = 0;\\n            return 0;\\n        }\\n        else if( m == 1 || n == 1){\\n            // base case\\n            pathCount[matrixSize] = 1;\\n            return 1;\\n            \\n        }else{\\n            // general case\\n            pathCount[matrixSize] = dp(m-1, n) + dp(m, n-1);\\n            return pathCount[matrixSize];\\n        }\\n        \\n    }\\n    \\n    \\n    return dp(m, n);\\n\\n};\\n\\n\\n```\\n\\t\\n</details>\\n\\n---\\n\\nRelated Leetcode challenge:\\n\\n[Leetcode #62 Unique Paths](https://leetcode.com/problems/unique-paths)\\n\\n[Leetcode #63 Unique Paths II](https://leetcode.com/problems/unique-paths-ii)\\n\\n[Leetcode #980 Unique Paths III](https://leetcode.com/problems/unique-paths-iii)\\n\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        rows, cols = m, n\\n        \\n        path_dp = [ [ 1 for j in range(cols)] for i in range(rows) ]\\n        \\n        \\n        # Dynamic Programming relation:\\n        \\n        # Base case:\\n        # DP(0, j) = 1 , only reachable from one step left\\n        # DP(i, 0) = 1 , only reachable from one step up\\n        \\n        # General case:\\n        # DP(i,j) = number of path reach to (i, j)\\n        #         = number of path reach to one step left + number of path reach to one step up\\n        #         = number of path reach to (i, j-1) + number of path to (i-1, j)\\n        #         = DP(i, j-1) + DP(i-1, j)\\n        \\n        \\n        \\n        for i in range(1, rows):\\n            for j in range(1, cols):\\n                \\n                path_dp[i][j] = path_dp[i][j-1] + path_dp[i-1][j]\\n        \\n        \\n        # Destination coordination = (rows-1, cols-1)\\n        return path_dp[rows-1][cols-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n\\t\\n        vector< vector<int> > path(m, vector<int>(n, 1) );\\n        \\n        for(int y = 1 ; y < m ; y++){\\n            for(int x = 1 ; x < n ; x++){\\n                \\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y][x-1] + path[y-1][x];\\n            }\\n        }\\n        return path[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        \\n        int [][]path = new int[m][n];\\n        \\n        // Base case:\\n        \\n        // left-most column\\n        for(int y = 0 ; y < m ; y++){\\n            path[y][0] = 1;\\n        }\\n        \\n        // top-most row\\n        for(int x = 0 ; x < n ; x++){\\n            path[0][x] = 1;\\n        }\\n        \\n        // General cases\\n        for(int y = 1 ; y < m ; y++){\\n            for(int x = 1 ; x < n ; x++){\\n                \\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y][x-1] + path[y-1][x];\\n\\n            }\\n        }\\n        return path[m-1][n-1];        \\n    }\\n}\\n```\n```\\nfunc uniquePaths(m int, n int) int {\\n    \\n    // Create 2D array with size m x n\\n    path := make( [][]int, m )\\n    rows := make( []int, m * n)\\n    for y := 0 ; y < m ; y++{\\n        path[y] = rows[ y*n : (y+1)*n]\\n    }\\n    \\n    for y := 0 ; y < m ; y++{\\n        for x := 0 ; x < n ; x++{\\n            \\n            if (y == 0) || (x == 0){\\n                path[y][x] = 1\\n            }else{\\n                // just follow the DP recurrence formula\\n                path[y][x] = path[y-1][x] + path[y][x-1]\\n            }\\n            \\n        }\\n    }\\n    \\n    return path[m-1][n-1]\\n}\\n```\n```\\nvar uniquePaths = function(m, n) {\\n    let perRow = Array(n).fill(1);\\n    \\n    // pathCount is 2D array of size m * n\\n    let pathCount = Array.from( Array(m).fill( perRow ) );\\n    \\n    for(let y = 1 ; y < m ; y++){\\n        for(let x = 1 ; x < n ; x++){\\n            \\n            // path count = number of path reach to one step left + number of path reach to one step up\\n            pathCount[y][x] = pathCount[y][x-1] + pathCount[y-1][x] \\n        }\\n    }\\n    \\n    return pathCount[m-1][n-1]\\n\\n};\\n```\n```\\nfrom math import factorial\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        rows, cols = m, n\\n        \\n        # from start to destination, we need (m-1) \\u2193 moves and (n-1) \\u2192 moves\\n        # Thus, the number of unique paths is the number of permutations of (m-1) \\u2193 and (n-1) \\u2192\\n        #\\n        # Number of unique paths = ( m-1 + n-1 ) ! / (m-1)! * (n-1)!\\n        \\n        \\n        return factorial( m+n-2 ) // ( factorial( m-1 ) * factorial( n-1 ) )    \\n```\n```\\nvar uniquePaths = function(m, n) {\\n    \\n    \\n    // from start to destination, we need (m-1) \\u2193 moves and (n-1) \\u2192 moves\\n    // Thus, the number of unique paths is the number of permutations of (m-1) \\u2193 and (n-1) \\u2192\\n    //\\n    // Number of unique paths = ( m-1 + n-1 ) ! / (m-1)! * (n-1)!\\n    \\n    let pathCount = factorial( m-1 + n-1 ) / ( factorial( m-1 )*factorial( n-1 ) );\\n    \\n    return pathCount\\n\\n};\\n\\n\\nvar factorial = function( k ){\\n    \\n    if( k == 0 || k == 1 ){\\n        return 1;\\n    }else{\\n        return k * factorial(k-1);\\n    }\\n    \\n};\\n```\n```\\nunsigned long int combination( int n, int k )\\n{\\n    if (k > n){     return 0;} \\n    if (k * 2 > n){ k = n-k; } \\n    if (k == 0){    return 1;} \\n\\n    unsigned long int result = n;\\n    for( int i = 2; i <= k; ++i ) {\\n        result *= (n-i+1);\\n        result /= i;\\n    }\\n    return result;\\n}\\n\\nclass Solution {\\npublic:\\n    unsigned int uniquePaths(int m, int n) {\\n        return combination( m-1+n-1, m-1);        \\n    }\\n};\\n```\n```\\n\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        # -----------------------------------\\n        \\n        # key: (m, n) size of grid\\n        # value: total path count from source to destinaion\\n        memo = {}\\n        \\n        def path_count(m, n):\\n            \\n            if (m, n) in memo:\\n                \\n                # look-up in memo\\n                return memo[(m, n)]\\n            \\n            if m == 0 or n == 0:\\n                \\n                # base case\\n                memo[(m, n)] = 0\\n                return 0\\n            \\n            elif m == 1 and n == 1:\\n                \\n                # base case\\n                memo[(m, n)] = 1\\n                return 1\\n\\n            # general case\\n            memo[(m, n)] = path_count(m-1, n) + path_count(m, n-1)\\n            return memo[(m, n)]\\n    \\n        # -----------------------------------\\n        return path_count(m, n)\\n    \\n    \\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        \\n        tuple<int, int> curMatrixSize = tuple<int, int>{m, n};\\n        \\n        if( pathCount.count( curMatrixSize ) ){\\n            return pathCount[ curMatrixSize ];\\n        }\\n        \\n        if( m == 0 || n == 0 ){\\n            // base case\\n            pathCount[ curMatrixSize ] = 0;    \\n            return 0;\\n            \\n        }else if( m == 1 && n == 1){\\n            \\n            // base case\\n            pathCount[ curMatrixSize ] = 1;    \\n            return 1;\\n        }\\n        \\n        // general cases:\\n        pathCount[ curMatrixSize ] = uniquePaths(m-1, n) + uniquePaths(m, n-1);\\n        return pathCount[ curMatrixSize ];\\n        \\n\\n    }\\n\\nprivate:\\n    \\n    // key: tuple of (matrix height, matrix width)\\n    // value: path count of matrix from start to destination\\n    map< tuple<int, int>, int> pathCount;\\n\\n};\\n\\n```\n```\\nvar makeKey = function(m, n){\\n    return String(m) + \",\" + String(n);\\n}\\n\\nvar uniquePaths = function(m, n) {\\n    \\n    // key: tuple of (matrix height, matrix width)\\n    // value: path count of matrix from start to destination\\n    pathCount = { };\\n    \\n    var dp = function(m, n){\\n        \\n        let matrixSize = makeKey(m, n);\\n        \\n        if( matrixSize in pathCount ){\\n            return pathCount[matrixSize];\\n        }\\n        \\n        if( m == 0 && n == 0 ){\\n            // base case\\n            pathCount[matrixSize] = 0;\\n            return 0;\\n        }\\n        else if( m == 1 || n == 1){\\n            // base case\\n            pathCount[matrixSize] = 1;\\n            return 1;\\n            \\n        }else{\\n            // general case\\n            pathCount[matrixSize] = dp(m-1, n) + dp(m, n-1);\\n            return pathCount[matrixSize];\\n        }\\n        \\n    }\\n    \\n    \\n    return dp(m, n);\\n\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23090,
                "title": "java-solution-0ms-4lines",
                "content": "If you mark the south move as '1' and the east move as '0'. This problem shall be equal to :\\nGiven (m+n-2) bits. you can fill in '1' for (m-1) times and '0' for (n-1) times, what is the number of different numbers?\\n the result is clear that the formula shall be C(m-1)(m+n-2), where m-1 is the superscript behind C and m+n-2 is the subscript behind C.\\nTo avoid overflow, I write the program in this manner.\\n\\npublic class Solution {\\n\\n    public int uniquePaths(int m, int n) {\\n\\n         long result = 1;\\n         for(int i=0;i<Math.min(m-1,n-1);i++)\\n             result = result*(m+n-2-i)/(i+1); \\n         return (int)result;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int uniquePaths(int m, int n) {\\n\\n         long result = 1;\\n         for(int i=0;i<Math.min(m-1,n-1);i++)\\n             result = result*(m+n-2-i)/(i+1); \\n         return (int)result;\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1635338,
                "title": "clean-recursive-dp-solution-javascript",
                "content": "Essentially we have 2 base cases where we know that:\\n* a 1x1 grid only has 1 path possible\\n* if we theoretically get a grid where m or n is 0, then the grid is invalid and there are 0 possible paths.\\n\\nWith memoization, we can pass down a hash that keeps track of values we have already calculated. If we have already previously saved the value, then we can simply add another base case where it simply returns the value saved in our memoization hash.\\n\\nIf we imagine uniquePaths as a tree of paths, we can either move down or right. Each decision effectively shrinks the grid size by either 1 row when we go down or 1 column when we go right. When drawn out, we can clearly see duplicate nodes that would return the same values, so we can simply save the first solution and refer back to it whenever we encounter it again.\\nTime: O(m * n)\\nSpace: O(m + n)\\n\\n![image](https://assets.leetcode.com/users/images/b0245695-e526-4247-8098-e2cc55efba8e_1639893241.4448733.png)\\n![image](https://assets.leetcode.com/users/images/064dbc78-fe2d-4817-9024-aa36fa826d39_1639892319.575502.png)\\n\\n```\\n const uniquePaths = function(m, n, memo = {}) {\\n     const key = m + \\',\\' + n;\\n     if (key in memo) return memo[key];\\n     if (m === 1 || n === 1) return 1\\n     if (m === 0 || n === 0) return 0;\\n     \\n     memo[key] = uniquePaths(m-1, n, memo) + uniquePaths(m, n-1, memo);\\n     return memo[key];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n const uniquePaths = function(m, n, memo = {}) {\\n     const key = m + \\',\\' + n;\\n     if (key in memo) return memo[key];\\n     if (m === 1 || n === 1) return 1\\n     if (m === 0 || n === 0) return 0;\\n     \\n     memo[key] = uniquePaths(m-1, n, memo) + uniquePaths(m, n-1, memo);\\n     return memo[key];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184248,
                "title": "8-lines-java-dp-solution-0ms-beats-100-explained-with-graph",
                "content": "The idea is to use a 2D array to keep track of the total possible ways to enter specific block.\nSince we can only go \"DOWN\" and \"RIGHT\", therefore each block could be entered from both \"ABOVE\" and \"LEFT\", therefore adding up their total ways would give the total ways for current block. The idea is illustrated as following:\n![image](https://assets.leetcode.com/users/yfgu0618/image_1540157891.png)\n\nIn order to save the hassles in the future, it's easier that we initialize the array to something like following:\n![image](https://assets.leetcode.com/users/yfgu0618/image_1540158218.png)\nwhich is why `dp[1][0]=1`\n\nFollowing is the code\n```java\n  public static int uniquePaths(int m, int n) {\n    int[][] dp = new int[n + 1][m + 1];\n    dp[1][0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= m; j++) {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n    return dp[n][m];\n  }\n```",
                "solutionTags": [],
                "code": "```java\n  public static int uniquePaths(int m, int n) {\n    int[][] dp = new int[n + 1][m + 1];\n    dp[1][0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= m; j++) {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n    return dp[n][m];\n  }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171708,
                "title": "100-faster-time-98-faster-space-easy-understanding",
                "content": "![image](https://assets.leetcode.com/users/images/9a4cc031-73e9-46e3-86b1-61e63ec9d7c6_1619115060.195593.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 1;\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 1;\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511059,
                "title": "javascript-from-naive-recursive-to-dp-bottom-up",
                "content": "(this is my reasoning. It might not be the most optimal. But arrived at this before looking at the solution)\\n\\nProblem can be decomposed into the following sub-problems:\\n * can I go right?\\n * can I go down?\\n\\nand the following base cases to get a response to those questions:\\n\\n* have I gone outside bounds?\\n\\t* return 0. This is not a valid path. \\n\\n* have I reached destination?\\n\\t* return 1. This is a valid path.\\n\\nThen I can add up the numbe of valid paths (see code below)\\n \\n* Here\\'s my progression:\\n  *  Brute force recursive\\n  *  Optimize by memoizing\\n  *  Turn around and make it dp bottom up tabular\\n  *  Further optimize space\\n\\n* Brute force recursive\\n```javascript\\nconst uniquePaths = (m, n) => {\\n    return helper(m, n, 1, 1);\\n};\\n\\nconst helper = (m, n, row, col) => {\\n    if(row === m && col === n) return 1;\\n    if(row > m || col > n) return 0;\\n    \\n    const pathsRight = helper(m, n, row, col + 1);\\n    const pathsDown = helper(m, n, row + 1, col);\\n    \\n    return pathsRight + pathsDown;\\n};\\n```\\n\\n\\n* Memoized\\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const memo = new Array(m + 1).fill(0);\\n    for(let i = 0; i < memo.length; i++) {\\n        memo[i] = new Array(n + 1).fill(-1);\\n    }\\n    return helper(m, n, 1, 1, memo);\\n};\\n\\nconst helper = (m, n, row, col, memo) => {\\n    if(row === m && col === n) return 1;\\n    if(row > m || col > n) return 0;\\n    \\n    if(memo[row][col] === -1) {\\n    \\n        const pathsRight = helper(m, n, row, col + 1, memo);\\n        const pathsDown = helper(m, n, row + 1, col, memo);\\n\\n        memo[row][col] = pathsRight + pathsDown;\\n    }\\n    \\n    return memo[row][col];\\n};\\n```\\n\\n* DP Bottom up tabular\\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const dp = new Array(m + 1).fill(0);\\n    for(let i = 0; i < dp.length; i++) {\\n        dp[i] = new Array(n + 1).fill(1);\\n    }\\n    \\n    dp[m][n] = 1;\\n    for(let row = m - 1; row > 0; row--){\\n        for(let col = n - 1; col > 0; col--){\\n            dp[row][col] = dp[row + 1][col] + dp[row][col + 1];\\n        }\\n    }\\n    \\n    return dp[1][1];\\n};\\n```\\n\\n* DP space optimized (there might be even further space optimization!!)\\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const dp = new Array(n + 1).fill(1);\\n    \\n    for(let row = m - 1; row > 0; row--){\\n        for(let col = n - 1; col > 0; col--){\\n            dp[col] = dp[col] + dp[col + 1];\\n        }\\n    }\\n    return dp[1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```javascript\\nconst uniquePaths = (m, n) => {\\n    return helper(m, n, 1, 1);\\n};\\n\\nconst helper = (m, n, row, col) => {\\n    if(row === m && col === n) return 1;\\n    if(row > m || col > n) return 0;\\n    \\n    const pathsRight = helper(m, n, row, col + 1);\\n    const pathsDown = helper(m, n, row + 1, col);\\n    \\n    return pathsRight + pathsDown;\\n};\\n```\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const memo = new Array(m + 1).fill(0);\\n    for(let i = 0; i < memo.length; i++) {\\n        memo[i] = new Array(n + 1).fill(-1);\\n    }\\n    return helper(m, n, 1, 1, memo);\\n};\\n\\nconst helper = (m, n, row, col, memo) => {\\n    if(row === m && col === n) return 1;\\n    if(row > m || col > n) return 0;\\n    \\n    if(memo[row][col] === -1) {\\n    \\n        const pathsRight = helper(m, n, row, col + 1, memo);\\n        const pathsDown = helper(m, n, row + 1, col, memo);\\n\\n        memo[row][col] = pathsRight + pathsDown;\\n    }\\n    \\n    return memo[row][col];\\n};\\n```\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const dp = new Array(m + 1).fill(0);\\n    for(let i = 0; i < dp.length; i++) {\\n        dp[i] = new Array(n + 1).fill(1);\\n    }\\n    \\n    dp[m][n] = 1;\\n    for(let row = m - 1; row > 0; row--){\\n        for(let col = n - 1; col > 0; col--){\\n            dp[row][col] = dp[row + 1][col] + dp[row][col + 1];\\n        }\\n    }\\n    \\n    return dp[1][1];\\n};\\n```\n```javascript\\nconst uniquePaths = (m, n) => {\\n    const dp = new Array(n + 1).fill(1);\\n    \\n    for(let row = m - 1; row > 0; row--){\\n        for(let col = n - 1; col > 0; col--){\\n            dp[col] = dp[col] + dp[col + 1];\\n        }\\n    }\\n    return dp[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23122,
                "title": "sharing-my-0ms-java-solution-with-detailed-exploration",
                "content": "public class UniquePaths {\\n\\n\\t public int uniquePathsSample(int m, int n) {\\n\\t\\tint[] dp = new int[m];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = 1; j < m; j++)\\n\\t\\t\\t\\tdp[j] = dp[j - 1] + dp[j];\\n\\t\\treturn dp[m - 1];\\n\\t}\\n\\n}\\n\\nFirst, image you have a m*n matrix, and you start from the left-top corner, to the right-bottom corner. And at the beginning, the matrix[0][0] would be 1, means you only have one way to reach the position where you are. And then if you want to move to the end of the first row, which is matrix[0][n-1], you only have one way to be there, too, you just need to move along the first row, to the rightmost position. Thus, you may set all values in the first row to 1.\\n\\nAnd then you move down, if you want to reach the bottom of the leftmost column. Similarly, you only have one way to be there, too, thus you can also set all values in the leftmost column to be 1.\\n\\nLet's go further, if you want to reach the right end of second row, how many different paths you can choose? Let's say, if you want to get matrix[1][1], you can either move right firstly, then move down, or you can move down firstly, then move right. So you will have two paths to reach the position(1,1), then matrix[1][1] will equal 2. So how can we get this number in general?\\n\\nObviously, we could know matrix[i][j] = matrix[i-1][j] + matrix[i][j-1], because if we can get the position (i-1,j) or (i, j-1), then we only have one way to reach the destination -- move down or move right -- thus we use this formula matrix[i][j] = matrix[i-1][j] + matrix[i][j-1] to fill up all of the values in the matrix.\\n\\nFurther more, do we really need o(m*n) space to help us finishing this task? Not really, through filling the matrix, we may see the filling task could be fulfilled layer by layer. Another saying, we could use only 1-dimension array to present each row of the matrix. And we fill the array again and again till n times (0,1,2...n-1). And finally we will get the result we want.",
                "solutionTags": [],
                "code": "public class UniquePaths {\\n\\n\\t public int uniquePathsSample(int m, int n) {\\n\\t\\tint[] dp = new int[m];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = 1; j < m; j++)\\n\\t\\t\\t\\tdp[j] = dp[j - 1] + dp[j];\\n\\t\\treturn dp[m - 1];\\n\\t}\\n\\n}\\n\\nFirst, image you have a m*n matrix, and you start from the left-top corner, to the right-bottom corner. And at the beginning, the matrix[0][0] would be 1, means you only have one way to reach the position where you are. And then if you want to move to the end of the first row, which is matrix[0][n-1], you only have one way to be there, too, you just need to move along the first row, to the rightmost position. Thus, you may set all values in the first row to 1.\\n\\nAnd then you move down, if you want to reach the bottom of the leftmost column. Similarly, you only have one way to be there, too, thus you can also set all values in the leftmost column to be 1.\\n\\nLet's go further, if you want to reach the right end of second row, how many different paths you can choose? Let's say, if you want to get matrix[1][1], you can either move right firstly, then move down, or you can move down firstly, then move right. So you will have two paths to reach the position(1,1), then matrix[1][1] will equal 2. So how can we get this number in general?\\n\\nObviously, we could know matrix[i][j] = matrix[i-1][j] + matrix[i][j-1], because if we can get the position (i-1,j) or (i, j-1), then we only have one way to reach the destination -- move down or move right -- thus we use this formula matrix[i][j] = matrix[i-1][j] + matrix[i][j-1] to fill up all of the values in the matrix.\\n\\nFurther more, do we really need o(m*n) space to help us finishing this task? Not really, through filling the matrix, we may see the filling task could be fulfilled layer by layer. Another saying, we could use only 1-dimension array to present each row of the matrix. And we fill the array again and again till n times (0,1,2...n-1). And finally we will get the result we want.",
                "codeTag": "Java"
            },
            {
                "id": 1582017,
                "title": "python-simple-one-liner-math-solution-with-explanation",
                "content": "### Explanation\\n\\nFor any given ```M x N``` grid, each unique path (no matter which one it is) requires you to move right from the starting point ```N - 1``` times and move down from the starting point ```M - 1``` times. Hence, regardless of the order you choose to move right or down, you need to make a total of ```(M - 1) + (N - 1) = M + N - 2``` moves.\\n\\nThen, out of the ```M + N - 2``` moves, we need to select ```M - 1``` moves to move right and the remaining ```N - 1``` moves to move down. This essentially is why this problem boils down to combinatorics, because we need to calculate how many different ways we can select ```M - 1``` moves from ```M + N - 2``` moves (or equivalently, ```N - 1``` moves from ```M + N - 2``` moves).\\n\\nFor more information I suggest reading [this Stack Exchange post](https://math.stackexchange.com/questions/2486807/number-of-unique-paths-in-m-times-n-matrix-combination-or-permutation). There are tons of other resources that explain this problem in greater detail too.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m+n-2, m-1)  # or math.comb(m+n-2, n-1)\\n```\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/7e02c6e5-c597-43d0-9171-887a45d10f25_1634915058.3338945.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```M x N```\n```N - 1```\n```M - 1```\n```(M - 1) + (N - 1) = M + N - 2```\n```M + N - 2```\n```M - 1```\n```N - 1```\n```M - 1```\n```M + N - 2```\n```N - 1```\n```M + N - 2```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m+n-2, m-1)  # or math.comb(m+n-2, n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362027,
                "title": "3-approaches-dp-recursion-math",
                "content": "[Leetcode](https://leetcode.com/) [62. Unique Paths](https://leetcode.com/problems/unique-paths).\\n\\nHere shows **3** Approaches to slove this problem: Dynamic Programming, Recursion, Math.\\n\\n\\n# Dynamic Programming\\n\\nThe equation is: $f(i, j) = f(i\\u22121, j) + f(i, j\\u22121)$.\\n\\n```java\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            dp[0][i] = 1;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            dp[i][0] = 1;\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.max(dp[i][j - 1] + 1, dp[i][j - 1] + dp[i - 1][j]);\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(mn)$\\n- **Space Complexity**: $O(mn)$\\n\\n# Recursion\\n\\nThe DFS is top-down dynamic programming with **memoization**. If we do ordinary DFS without proper memoization, it will have a TLE error.\\n\\n```java\\n    public int uniquePaths(int m, int n) {\\n        return dfs(new HashMap<Pair, Integer>(), 0, 0, m, n);\\n    }\\n\\n    private static int dfs(Map<Pair, Integer> cache, int r, int c, int rows, int cols) {\\n        Pair p = new Pair(r, c);\\n\\n        if (cache.containsKey(p)) {\\n            return cache.get(p);\\n        }\\n\\n        if (r == rows - 1 || c == cols - 1) {\\n            return 1;\\n        }\\n        \\n        cache.put(p, dfs(cache, r + 1, c, rows, cols) + dfs(cache, r, c + 1, rows, cols));\\n        return cache.get(p);\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(mn)$\\n- **Space Complexity**: $O(mn)$\\n\\n# Combination Math\\n\\nIn the process from the top left to the bottom right, we need to move $m+n-2$ steps, of which there are $m-1$ moves down and $n-1$ times to the right. \\n\\nTherefore, the total number of paths is equal to the number of options for selecting $m-1$ downward moves from $m+n-2$ moves, that is, the number of combinations:\\n\\n$$\\n{\\\\Large C}_{m+n-2}^{m-1} = \\\\binom{m+n-2}{m-1} = \\\\frac{(m+n-2)(m+n-3)\\\\cdots n}{(m-1)!} = \\\\frac{(m+n-2)!}{(m-1)!(n-1)!}\\n$$\\n\\nWe can use $\\\\frac{(m+n-2)(m+n-3)\\\\cdots n}{(m-1)!}$ to calcuate the number.\\n\\u200B\\n```java\\n    public static int uniquePaths_math(int m, int n) {\\n        long ans = 1;\\n        \\n        for (int x = n, y = 1; y < m; ++x, ++y) {\\n            ans = ans * x / y;\\n        }\\n\\n        return (int) ans;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(m)$\\n- **Space Complexity**: $O(1)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```java\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            dp[0][i] = 1;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            dp[i][0] = 1;\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.max(dp[i][j - 1] + 1, dp[i][j - 1] + dp[i - 1][j]);\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n```\n```java\\n    public int uniquePaths(int m, int n) {\\n        return dfs(new HashMap<Pair, Integer>(), 0, 0, m, n);\\n    }\\n\\n    private static int dfs(Map<Pair, Integer> cache, int r, int c, int rows, int cols) {\\n        Pair p = new Pair(r, c);\\n\\n        if (cache.containsKey(p)) {\\n            return cache.get(p);\\n        }\\n\\n        if (r == rows - 1 || c == cols - 1) {\\n            return 1;\\n        }\\n        \\n        cache.put(p, dfs(cache, r + 1, c, rows, cols) + dfs(cache, r, c + 1, rows, cols));\\n        return cache.get(p);\\n    }\\n```\n```java\\n    public static int uniquePaths_math(int m, int n) {\\n        long ans = 1;\\n        \\n        for (int x = n, y = 1; y < m; ++x, ++y) {\\n            ans = ans * x / y;\\n        }\\n\\n        return (int) ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513886,
                "title": "java-tc-o-m-n-sc-o-min-m-n-space-optimized-dynamic-programming-solution",
                "content": "**Space optimized Dynamic Programming solution**\\n\\n```java\\n/**\\n * Space optimized Dynamic Programming solution\\n *\\n * dp[i][j] = Number of ways to reach this cell [i][j].\\n * dp[i][j] = dp[i][j-1] + dp[i-1][j].\\n *\\n * This can be solved by using one array representing the row.\\n *\\n * Let M = number of rows and N = number of columns. Thus the row size will be\\n * N. Try to minimize N by swapping M and N if M < N;\\n *\\n * Time Complexity: O(M * N).\\n *\\n * Space Complexity = O(min(M, N)). Only one row is used for dp.\\n */\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if (m <= 0 || n <= 0) {\\n            return 0;\\n        }\\n        if (m == 1 || n == 1) {\\n            return 1;\\n        }\\n        if (m < n) {\\n            uniquePaths(n, m);\\n        }\\n\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n```\\n\\n---\\n**Math Solution using Combinatorics**\\n\\n```java\\n/**\\n * Find the total permutations of the directions to be travelled. For example\\n * D,D,D,D,R,R,R,R -> Find permutations of this list\\n *\\n * This is a combinatorial problem and can be solved without DP. For mxn grid,\\n * robot has to move exactly m-1 steps down and n-1 steps right and these can be\\n * done in any order.\\n *\\n * For the eg., given in question, 3x7 matrix, robot needs to take 2+6 = 8 steps\\n * with 2 down and 6 right in any order. That is nothing but a permutation\\n * problem. Denote down as \\'D\\' and right as \\'R\\', following is one of the path :-\\n *\\n * D R R R D R R R\\n *\\n * We have to tell the total number of permutations of the above given word. So,\\n * decrease both m & n by 1 and apply following formula:-\\n *\\n * Total permutations = (m+n)! / (m! * n!)\\n *\\n * Time Complexity: O(min(M,N)). Assuming Multiplication and Division takes\\n * O(1).\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if (m <= 0 || n <= 0) {\\n            return 0;\\n        }\\n        if (m == 1 || n == 1) {\\n            return 1;\\n        }\\n        if (m < n) {\\n            uniquePaths(n, m);\\n        }\\n\\n        m--;\\n        n--;\\n        long paths = 1;\\n        for (int i = 1; i <= n; i++) {\\n            paths *= (m + i);\\n            paths /= i;\\n        }\\n\\n        return (int) paths;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/discuss/1513891/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/discuss/1513899/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/discuss/1513906/Java-or-TC:-O(3(R*C))-or-SC:-O(R*C)-or-DFS-solution-with-Backtracking)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Matrix",
                    "Combinatorics"
                ],
                "code": "```java\\n/**\\n * Space optimized Dynamic Programming solution\\n *\\n * dp[i][j] = Number of ways to reach this cell [i][j].\\n * dp[i][j] = dp[i][j-1] + dp[i-1][j].\\n *\\n * This can be solved by using one array representing the row.\\n *\\n * Let M = number of rows and N = number of columns. Thus the row size will be\\n * N. Try to minimize N by swapping M and N if M < N;\\n *\\n * Time Complexity: O(M * N).\\n *\\n * Space Complexity = O(min(M, N)). Only one row is used for dp.\\n */\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if (m <= 0 || n <= 0) {\\n            return 0;\\n        }\\n        if (m == 1 || n == 1) {\\n            return 1;\\n        }\\n        if (m < n) {\\n            uniquePaths(n, m);\\n        }\\n\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n```\n```java\\n/**\\n * Find the total permutations of the directions to be travelled. For example\\n * D,D,D,D,R,R,R,R -> Find permutations of this list\\n *\\n * This is a combinatorial problem and can be solved without DP. For mxn grid,\\n * robot has to move exactly m-1 steps down and n-1 steps right and these can be\\n * done in any order.\\n *\\n * For the eg., given in question, 3x7 matrix, robot needs to take 2+6 = 8 steps\\n * with 2 down and 6 right in any order. That is nothing but a permutation\\n * problem. Denote down as \\'D\\' and right as \\'R\\', following is one of the path :-\\n *\\n * D R R R D R R R\\n *\\n * We have to tell the total number of permutations of the above given word. So,\\n * decrease both m & n by 1 and apply following formula:-\\n *\\n * Total permutations = (m+n)! / (m! * n!)\\n *\\n * Time Complexity: O(min(M,N)). Assuming Multiplication and Division takes\\n * O(1).\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if (m <= 0 || n <= 0) {\\n            return 0;\\n        }\\n        if (m == 1 || n == 1) {\\n            return 1;\\n        }\\n        if (m < n) {\\n            uniquePaths(n, m);\\n        }\\n\\n        m--;\\n        n--;\\n        long paths = 1;\\n        for (int i = 1; i <= n; i++) {\\n            paths *= (m + i);\\n            paths /= i;\\n        }\\n\\n        return (int) paths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996056,
                "title": "dp-easy-to-understand-solution-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExplore all options i.e down + right\\n\\n`for detailed explanation you can refer to my youtube channel` \\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `uniquePaths` function initializes a 2D array `dp` of size 101x101 to store intermediate results. It also sets all values in `dp` to -1 as an indicator that they need to be computed.\\n\\n2. The `solve` function is a recursive helper function that calculates the number of unique paths from a given position `(i, j)` to the bottom-right corner `(m-1, n-1)`.\\n\\n3. In the `solve` function, it first checks if we have reached either the last row (`i == m-1`) or the last column (`j == n-1`). If either of these conditions is met, there is only one way to reach the destination, so it returns 1.\\n\\n4. If the value of `dp[i][j]` is not -1, it means we have already computed the number of unique paths from this position, so it returns the stored value.\\n\\n5. If none of the above conditions are met, it calculates the number of unique paths recursively by summing the paths from moving down (`solve(m, n, i+1, j)`) and moving right (`solve(m, n, i, j+1)`). It then stores this value in `dp[i][j]` to avoid redundant calculations and returns it.\\n\\n6. Finally, in the `uniquePaths` function, it calls the `solve` function with initial arguments `(0, 0)` to start the recursive calculation from the top-left corner and returns the result.\\n\\n\\n# Complexity\\n- Time complexity:$$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int m,int n,int i,int j){\\n        if(i==m-1||j==n-1){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=solve(m,n,i+1,j)+solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\\n```java []\\npublic class Solution {\\n    int[][] dp;\\n\\n    public int uniquePaths(int m, int n) {\\n        dp = new int[m][n];\\n\\n        // Initialize dp grid with -1 values\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        return solve(m, n, 0, 0);\\n    }\\n\\n    private int solve(int m, int n, int i, int j) {\\n        if (i == m - 1 || j == n - 1) {\\n            return 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        return dp[i][j] = solve(m, n, i + 1, j) + solve(m, n, i, j + 1);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[-1] * n for _ in range(m)]\\n\\n        def solve(i, j):\\n            if i == m - 1 or j == n - 1:\\n                return 1\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            dp[i][j] = solve(i + 1, j) + solve(i, j + 1)\\n            return dp[i][j]\\n\\n        return solve(0, 0)\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int m,int n,int i,int j){\\n        if(i==m-1||j==n-1){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=solve(m,n,i+1,j)+solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\n```java []\\npublic class Solution {\\n    int[][] dp;\\n\\n    public int uniquePaths(int m, int n) {\\n        dp = new int[m][n];\\n\\n        // Initialize dp grid with -1 values\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        return solve(m, n, 0, 0);\\n    }\\n\\n    private int solve(int m, int n, int i, int j) {\\n        if (i == m - 1 || j == n - 1) {\\n            return 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        return dp[i][j] = solve(m, n, i + 1, j) + solve(m, n, i, j + 1);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[-1] * n for _ in range(m)]\\n\\n        def solve(i, j):\\n            if i == m - 1 or j == n - 1:\\n                return 1\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            dp[i][j] = solve(i + 1, j) + solve(i, j + 1)\\n            return dp[i][j]\\n\\n        return solve(0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582266,
                "title": "0-ms-c-easy-to-understand-with-explanation-tabulation-memoization-dp",
                "content": "**Thanks in advance for reading.**\\nPls upvote if this helps and feel free to suggest changes.\\n.\\n.\\nWe have to find the total number of unique paths.\\n\\n# Basic Idea\\nLet we are currently at (i,j) i.e. i-th row and j-th column, Then we can either move right or down.\\nLet the number of unique paths from (i,j+1) i.e. right cell to destination be x \\nand number of unique paths from (i+1,j) i.e. bottom cell to destination be y.\\n\\nThen, number of unique paths from (i,j) i.e. current cell to destination will be x+y.\\n\\n**Note**\\nif right cell (i,j+1) doesn\\'t exist, then treat x as 0.\\nif bottom cell (i+1,j) doesn\\'t exist, then we treat y as 0.\\n\\nSo we can easily do it with plain recursion, but\\n# Point to observe\\nconsider the cell (5,6) , recursion function will be called for this cell more than once. for example, this cell acts as bottom cell for (4,6). So whenever function call for (4,6) is made, recursive call for (5,6) too.\\nHowever answer will always be the same for same input. Same happens when function call for (5,5) is made since (5,6) acts as right cell for it.\\n\\nSo inorder to avoid computing the same thing again and again. We store the result of compuatation in a array (concept of dynamic prograaming). So if a function call is made for some input for which the computation is already done. We just return the value that we stored after getting the result when the computation was performed.\\n\\nThe above said logic can be implemented in the following two ways.\\n\\n**1) Memoization(top-down) code follows**\\ni.e. using recursive implementation\\n```\\nclass Solution\\n{\\n  public:\\n  int uniquePaths(int m, int n)\\n  {\\n    vector<vector<int>> dp(m+1,vector<int>(n+1,-1)) ;\\n    int x = 1 , y =1 ; // we start from (1,1)\\n      dp[m][n] = 1 ; // no. of unique paths from destination to itself is 1\\n    \\n      return solve(x,y,m,n,dp) ;\\n  }\\n  \\n  int solve(int x, int y, int m, int n, vector<vector<int>>& dp)\\n  {\\n    if(x<1 || x>m || y<1 || y>n) // if the current cell doesn\\'t exist return 0\\n        return 0 ;\\n      \\n      if(dp[x][y] != -1) // if answer for this cell is already calculated, return the stored value\\n         return dp[x][y] ;\\n     \\n    dp[x][y] = solve(x,y+1,m,n,dp) + solve(x+1,y,m,n,dp) ; // sum of paths from right cell and bottom cell\\n    \\n      return dp[x][y] ;\\n  }\\n} ;\\n\\n```\\n\\nTime Complexity : O(m*n)\\nSpace Complexity : O(m*n)\\n\\n.\\n.\\n.\\n\\n**2) Tabulation(bottom-up) code follows**\\ni.e using iterative implementation\\n```\\n\\nclass Solution \\n{\\npublic:\\n    int uniquePaths(int m, int n)\\n    {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,1)) ;\\n        \\n        for (int i = 2; i <= m; i++) \\n        {\\n            for (int j = 2; j <= n; j++) \\n            {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n\\n```\\n\\nTime Complexity : O(m*n)\\nSpace Complexity : O(m*n)\\n\\nupvote if this is helpful",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n  public:\\n  int uniquePaths(int m, int n)\\n  {\\n    vector<vector<int>> dp(m+1,vector<int>(n+1,-1)) ;\\n    int x = 1 , y =1 ; // we start from (1,1)\\n      dp[m][n] = 1 ; // no. of unique paths from destination to itself is 1\\n    \\n      return solve(x,y,m,n,dp) ;\\n  }\\n  \\n  int solve(int x, int y, int m, int n, vector<vector<int>>& dp)\\n  {\\n    if(x<1 || x>m || y<1 || y>n) // if the current cell doesn\\'t exist return 0\\n        return 0 ;\\n      \\n      if(dp[x][y] != -1) // if answer for this cell is already calculated, return the stored value\\n         return dp[x][y] ;\\n     \\n    dp[x][y] = solve(x,y+1,m,n,dp) + solve(x+1,y,m,n,dp) ; // sum of paths from right cell and bottom cell\\n    \\n      return dp[x][y] ;\\n  }\\n} ;\\n\\n```\n```\\n\\nclass Solution \\n{\\npublic:\\n    int uniquePaths(int m, int n)\\n    {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,1)) ;\\n        \\n        for (int i = 2; i <= m; i++) \\n        {\\n            for (int j = 2; j <= n; j++) \\n            {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994595,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nThe main idea to solve the unique paths question is to use dynamic programming to calculate the number of unique paths from the top-left corner of a grid to the bottom-right corner. \\n\\nThis approach efficiently solves the problem by breaking it down into smaller subproblems and avoiding redundant calculations. It\\'s a classic example of dynamic programming used for finding solutions to grid-related problems.\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 253 videos as of September 3rd, 2023.\\n\\nhttps://youtu.be/6NorAYw7NMU\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\n### \\u2B50\\uFE0F Don\\'t forget to subscribe to my channel!\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be differnt a bit.\\n\\n1. **Initialization of the AboveRow list**\\n   - Main Point: Initialize the aboveRow list with `n` elements, all set to 1.\\n   - Detailed Explanation: This list represents the number of unique paths for each column in the top row of the grid. It\\'s initialized with 1 because there\\'s only one way to reach each cell in the top row, which is by moving horizontally.\\n\\n2. **Iteration through Rows**\\n   - Main Point: Loop `m - 1` times, where `m` is the number of rows in the grid.\\n   - Detailed Explanation: This loop iterates over each row below the top row. The `-1` is used because the top row was already initialized, and there\\'s no need to recompute it.\\n\\n3. **Creating a New Row**\\n   - Main Point: Inside the loop, create a new list called currentRow with `n` elements, all set to 1.\\n   - Detailed Explanation: For each row below the top row, we create a new list to store the number of unique paths for each column in that row. All values are initialized to 1 because there are no previous paths to consider yet.\\n\\n4. **Nested Loop for Columns**\\n   - Main Point: Iterate over each column in the currentRow from index 1 to `n - 1`.\\n   - Detailed Explanation: This nested loop starts from index 1 because the cell at index 0 already has one unique path, and we want to calculate the number of unique paths for the remaining cells in the current row.\\n\\n5. **Updating Cell Values**\\n   - Main Point: In the nested loop, update the currentRow list at index `i` by adding the value at index `i-1` of the currentRow and the value at index `i` of the aboveRow.\\n   - Detailed Explanation: This step implements the dynamic programming logic. The number of unique paths to reach a cell in the current row is the sum of the number of paths to reach the cell immediately to the left (in the same row) and the number of paths to reach the cell above it (from the aboveRow).\\n\\n6. **Updating aboveRow**\\n   - Main Point: After the nested loop completes, update the aboveRow to be equal to the currentRow.\\n   - Detailed Explanation: We update the aboveRow to be the same as the currentRow because it becomes the reference for the next row calculation.\\n\\n7. **Returning the Result**\\n   - Main Point: Once the outer loop finishes, return the last element of the aboveRow list, which represents the number of unique paths to reach the bottom-right cell of the grid.\\n   - Detailed Explanation: The final result is stored in the last element of the aboveRow list because it represents the number of unique paths to reach the last column in the last row, which is the destination cell.\\n\\nThis algorithm efficiently calculates the number of unique paths to traverse an `m x n` grid from the top-left corner to the bottom-right corner using dynamic programming.\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n\\n- Space complexity: O(n)\\nn is the number of columns in the grid\\n\\n```python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n\\n        aboveRow = [1] * n\\n\\n        for _ in range(m - 1):\\n            currentRow = [1] * n\\n            for i in range(1, n):\\n                currentRow[i] = currentRow[i-1] + aboveRow[i]\\n            aboveRow = currentRow\\n        \\n        return aboveRow[-1]\\n```\\n```javascript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    let aboveRow = Array(n).fill(1);\\n\\n    for (let row = 1; row < m; row++) {\\n        let currentRow = Array(n).fill(1);\\n        for (let col = 1; col < n; col++) {\\n            currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n        }\\n        aboveRow = currentRow;\\n    }\\n\\n    return aboveRow[n - 1];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[] aboveRow = new int[n];\\n        Arrays.fill(aboveRow, 1);\\n\\n        for (int row = 1; row < m; row++) {\\n            int[] currentRow = new int[n];\\n            Arrays.fill(currentRow, 1);\\n            for (int col = 1; col < n; col++) {\\n                currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n            }\\n            aboveRow = currentRow;\\n        }\\n\\n        return aboveRow[n - 1];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        std::vector<int> aboveRow(n, 1);\\n\\n        for (int row = 1; row < m; row++) {\\n            std::vector<int> currentRow(n, 1);\\n            for (int col = 1; col < n; col++) {\\n                currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n            }\\n            aboveRow = currentRow;\\n        }\\n\\n        return aboveRow[n - 1];        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n\\n        aboveRow = [1] * n\\n\\n        for _ in range(m - 1):\\n            currentRow = [1] * n\\n            for i in range(1, n):\\n                currentRow[i] = currentRow[i-1] + aboveRow[i]\\n            aboveRow = currentRow\\n        \\n        return aboveRow[-1]\\n```\n```javascript []\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    let aboveRow = Array(n).fill(1);\\n\\n    for (let row = 1; row < m; row++) {\\n        let currentRow = Array(n).fill(1);\\n        for (let col = 1; col < n; col++) {\\n            currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n        }\\n        aboveRow = currentRow;\\n    }\\n\\n    return aboveRow[n - 1];    \\n};\\n```\n```java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[] aboveRow = new int[n];\\n        Arrays.fill(aboveRow, 1);\\n\\n        for (int row = 1; row < m; row++) {\\n            int[] currentRow = new int[n];\\n            Arrays.fill(currentRow, 1);\\n            for (int col = 1; col < n; col++) {\\n                currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n            }\\n            aboveRow = currentRow;\\n        }\\n\\n        return aboveRow[n - 1];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        std::vector<int> aboveRow(n, 1);\\n\\n        for (int row = 1; row < m; row++) {\\n            std::vector<int> currentRow(n, 1);\\n            for (int col = 1; col < n; col++) {\\n                currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n            }\\n            aboveRow = currentRow;\\n        }\\n\\n        return aboveRow[n - 1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362451,
                "title": "c-easy-math-combinatorics-o-1-spaces",
                "content": "#### **Upvote if you like it**\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int k=m+n-2;\\n      long  ans=1;\\n        for(int i=1;i<=n-1;++i){\\n            \\n            \\n           ans=ans*(k-(n-1)+i)/i;\\n        }\\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int k=m+n-2;\\n      long  ans=1;\\n        for(int i=1;i<=n-1;++i){\\n            \\n            \\n           ans=ans*(k-(n-1)+i)/i;\\n        }\\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116646,
                "title": "very-simple-javascript-solution-in-100th-percentile-56ms",
                "content": "Given that the pure math solution using factorials can be numerically unstable, I opted for the DP approach that uses O(n) space for a single row vector that I update iteratively.\n\nFor context, here's an example for how to fill out a 3x6 grid in the more traditional DP regime:\n```\n0 | 1  | 1  | 1  | 1  | 1\n1 | 2  | 3  | 4  | 5  | 6\n1 | 3  | 6  | 10 | 15 | 21\n```\nNotice that for every i and j, matrix[i][j] is the total number of ways of getting to (i, j). The first row and first column of this matrix are trivial cases because we can only move down and to the right, so they will always be vectors of 1s with matrix[0][0] = 0 as a degenerate base case.\n```\n0 | 1  | 1  | 1  | 1  | 1\n1 | 0  | 0  | 0  | 0  | 0\n1 | 0  | 0  | 0  | 0  | 0\n```\nFrom the initialization above, we can work row by row, assigning matrix[i][j] = matrix[i][j-1] + matrix[i-1][j], getting a grid that looks like the first one above. The solution is the bottom-right value of this matrix.\n\nThe insight with my implementation is that we don't need to allocate the full mxn matrix. One row will suffice. Initialize the first row the same way you did before and simply mutate the values of that first row with the new values of the second row. You can iterate this process until you have calcluated the final row of the matrix. This works because we will only ever need row k to calculate the values of row k+1;\n\n```javascript\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    let currentRow = new Array(n);\n    // Assigning a 1 to matrix[0][0] is simply a shortcut that skips some later computation\n    // as matrix[i][0] will never change in this iterative process\n    for (let i = 0; i < n; i++) {\n        currentRow[i] = 1;\n    }\n    for (let row = 1; row < m; row++) {\n        for (let i = 1; i < n; i++) {\n            currentRow[i] += currentRow[i - 1];\n        }\n    }\n    return currentRow[n - 1];\n};\n```",
                "solutionTags": [],
                "code": "```\n0 | 1  | 1  | 1  | 1  | 1\n1 | 2  | 3  | 4  | 5  | 6\n1 | 3  | 6  | 10 | 15 | 21\n```\n```\n0 | 1  | 1  | 1  | 1  | 1\n1 | 0  | 0  | 0  | 0  | 0\n1 | 0  | 0  | 0  | 0  | 0\n```\n```javascript\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    let currentRow = new Array(n);\n    // Assigning a 1 to matrix[0][0] is simply a shortcut that skips some later computation\n    // as matrix[i][0] will never change in this iterative process\n    for (let i = 0; i < n; i++) {\n        currentRow[i] = 1;\n    }\n    for (let row = 1; row < m; row++) {\n        for (let i = 1; i < n; i++) {\n            currentRow[i] += currentRow[i - 1];\n        }\n    }\n    return currentRow[n - 1];\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362303,
                "title": "java-easy-solution-using-dp-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution \\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int dp[][]=new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int dp[][]=new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774807,
                "title": "fastest-100-faster-and-simplest-java-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\n       public int uniquePaths(int m, int n) {//in this question m is considered as columns and n as rows(usually we take first element written as rows but it is reversed here )\\n        int[][] matrix = new int[n][m]; // create a matrix in which value of every element represents the total possible ways to reach there.\\n       \\n        for (int i = 0; i < m; i++) {\\n            matrix[0][i] = 1;//as there is only one way to reach every element having index (0,i).i.e->(0,1)->(0,2)->(0,3)->--so on till (0,m) and it is by moving right from (0,0)\\n\\n        }\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 1;// as there is only one way to reach every index (i,0) by going down(1,0) and down(2,0) and down(3,0)...\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]; //for every other element number of ways to reach there is sum of number of ways to reach its top and number of ways to reach to its left(since we can move only right and down)\\n            }\\n        }\\n        return matrix[n - 1][m - 1];  //finally return the number of ways to reach last element.\\n    }\\n}\\n//PLEASE UPVOTE IF IT WAS HELPFUL!! \\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n       public int uniquePaths(int m, int n) {//in this question m is considered as columns and n as rows(usually we take first element written as rows but it is reversed here )\\n        int[][] matrix = new int[n][m]; // create a matrix in which value of every element represents the total possible ways to reach there.\\n       \\n        for (int i = 0; i < m; i++) {\\n            matrix[0][i] = 1;//as there is only one way to reach every element having index (0,i).i.e->(0,1)->(0,2)->(0,3)->--so on till (0,m) and it is by moving right from (0,0)\\n\\n        }\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 1;// as there is only one way to reach every index (i,0) by going down(1,0) and down(2,0) and down(3,0)...\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]; //for every other element number of ways to reach there is sum of number of ways to reach its top and number of ways to reach to its left(since we can move only right and down)\\n            }\\n        }\\n        return matrix[n - 1][m - 1];  //finally return the number of ways to reach last element.\\n    }\\n}\\n//PLEASE UPVOTE IF IT WAS HELPFUL!! \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581956,
                "title": "c-simple-and-short-dp-solution-brief-explanation-0ms-faster-than-100",
                "content": "**Idea:**\\nTo each cell `grid[i][j]` we have to ways: either coming from the top - `grid[i-1][j]` or coming from the left - `grid[i][j-1]`.\\ndp[i][j] holds the number of paths to get to grid[i][j].\\nSo we just add the sum of the two ways - `dp[i-1][j] + dp[i][j-1]`.\\n\\nBase cases are 1, there is one way to get to the cells on first row and col.\\n\\n**Time Complexity:** O(mn)\\n**Space Complexity:** O(mn)\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691177,
                "title": "4-approaches-learn-for-interview-beats-100",
                "content": "Recursive solution (The very first step you should come up with)\\n\\n```\\nclass Solution {\\n    int solve(int[][] grid, int x, int y){\\n        if(x>=grid.length || y >=grid[0].length) return 0;\\n        if(x == grid.length-1 && y == grid[0].length-1) return 1;\\n        return solve(grid,x+1,y) + solve(grid,x,y+1); \\n    }\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        return solve(grid,0,0);\\n    }\\n}\\n```\\n\\nMethod 1 : Top Down DP ( Recursion + memoization)\\n```\\nclass Solution {\\n    int[][] memo;\\n    \\n    int solve(int[][] grid, int x, int y){\\n        if(x>=grid.length || y >=grid[0].length) return 0;\\n        if(memo[x][y] != -1) return memo[x][y];\\n        if(x == grid.length-1 && y == grid[0].length-1) return 1;\\n        return memo[x][y] = solve(grid,x+1,y) + solve(grid,x,y+1); \\n    }\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        memo = new int[m][n];\\n        for(int[]rows:memo) Arrays.fill(rows,-1);\\n        return solve(grid,0,0);\\n    }\\n}\\n```\\n\\nMethod 2 : Bottom up DP ( Building solution from (Destination) RIGHT-MOST BOTTOM corner)\\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        int[][]dp = new int[m+1][n+1];\\n        for(int x=m;x>=0;x--){\\n            for(int y=n;y>=0;y--){\\n                if(x == m || y == n) dp[x][y] = 0;\\n                else if(x == m-1 && y == n-1) dp[x][y] = 1;\\n                else dp[x][y] =  dp[x+1][y] + dp[x][y+1]; \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\\n\\nMethod 3 : Bottom-up ( Building solution from (source) LEFT-MOST TOP corner)\\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        int[][]dp = new int[m][n];\\n  \\n        for(int x=0;x<m;x++){\\n            for(int y=0;y<n;y++){\\n                if(x == 0 || y == 0) dp[x][y] = 1;\\n                else dp[x][y] =  dp[x-1][y] + dp[x][y-1]; \\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int[][] grid, int x, int y){\\n        if(x>=grid.length || y >=grid[0].length) return 0;\\n        if(x == grid.length-1 && y == grid[0].length-1) return 1;\\n        return solve(grid,x+1,y) + solve(grid,x,y+1); \\n    }\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        return solve(grid,0,0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[][] memo;\\n    \\n    int solve(int[][] grid, int x, int y){\\n        if(x>=grid.length || y >=grid[0].length) return 0;\\n        if(memo[x][y] != -1) return memo[x][y];\\n        if(x == grid.length-1 && y == grid[0].length-1) return 1;\\n        return memo[x][y] = solve(grid,x+1,y) + solve(grid,x,y+1); \\n    }\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        memo = new int[m][n];\\n        for(int[]rows:memo) Arrays.fill(rows,-1);\\n        return solve(grid,0,0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        int[][]dp = new int[m+1][n+1];\\n        for(int x=m;x>=0;x--){\\n            for(int y=n;y>=0;y--){\\n                if(x == m || y == n) dp[x][y] = 0;\\n                else if(x == m-1 && y == n-1) dp[x][y] = 1;\\n                else dp[x][y] =  dp[x+1][y] + dp[x][y+1]; \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        int[][]dp = new int[m][n];\\n  \\n        for(int x=0;x<m;x++){\\n            for(int y=0;y<n;y++){\\n                if(x == 0 || y == 0) dp[x][y] = 1;\\n                else dp[x][y] =  dp[x-1][y] + dp[x][y-1]; \\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362191,
                "title": "python3-1-line-combinatorics-w-explanation-t-m-88-79",
                "content": "Some points to consider:\\n\\n*  Because the robot may only move to the right or down, the count of paths to any cell in row 0 or column 0 is exactly 1. For all other cells, the count of paths is equal to the the count of the cell to the left plus the count of the cell above.\\n\\n![image](https://assets.leetcode.com/users/images/4a75d47a-c14c-4efb-9913-33ac40c1017f_1659319303.142981.png)\\n\\n*  In the figure above, m = 3 and n = 5, and the answer to the problem is 15. One could iterate the relation above by row and column as shown  and determine the answer.\\n\\n![image](https://assets.leetcode.com/users/images/2379d57d-21e3-47ad-8e2f-9cbed8c7ee2a_1659318546.287716.png)\\n\\n\\n* However, the arrangement of integers on the grid are familiar-- Pascal\\'s Triangle. For Pascal\\'s Triangle, rows and columns are 0-indexed. The answer is at the intersection of left-column 2 (which is 3-1) and right-column 4 (which is 5-1. The row is 4+2 = 6 (which is 5+3 -2). From combinatorics, integer in the 6th row in column 2 is 6!/(2!4!) = 15\\n\\n```\\nclass Solution: \\n        def uniquePaths(self, m: int, n: int) -> int:\\n            return factorial(m+n-2)//factorial(m-1)//factorial(n-1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "Some points to consider:\\n\\n*  Because the robot may only move to the right or down, the count of paths to any cell in row 0 or column 0 is exactly 1. For all other cells, the count of paths is equal to the the count of the cell to the left plus the count of the cell above.\\n\\n![image](https://assets.leetcode.com/users/images/4a75d47a-c14c-4efb-9913-33ac40c1017f_1659319303.142981.png)\\n\\n*  In the figure above, m = 3 and n = 5, and the answer to the problem is 15. One could iterate the relation above by row and column as shown  and determine the answer.\\n\\n![image](https://assets.leetcode.com/users/images/2379d57d-21e3-47ad-8e2f-9cbed8c7ee2a_1659318546.287716.png)\\n\\n\\n* However, the arrangement of integers on the grid are familiar-- Pascal\\'s Triangle. For Pascal\\'s Triangle, rows and columns are 0-indexed. The answer is at the intersection of left-column 2 (which is 3-1) and right-column 4 (which is 5-1. The row is 4+2 = 6 (which is 5+3 -2). From combinatorics, integer in the 6th row in column 2 is 6!/(2!4!) = 15\\n\\n```\\nclass Solution: \\n        def uniquePaths(self, m: int, n: int) -> int:\\n            return factorial(m+n-2)//factorial(m-1)//factorial(n-1)",
                "codeTag": "Java"
            },
            {
                "id": 1912575,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-min-n-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows, and m is the number of columns.\\n    //   - space: O(min(n, m)), where n is the number of rows, and m is the number of columns.\\n    \\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)\\n        \\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if i == 0 || j == 0 {\\n                    matrix[i][j] = 1\\n                } else {\\n                    matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]\\n                }\\n            }\\n        }\\n        \\n        return matrix[n - 1][m - 1]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows, and m is the number of columns.\\n    //   - space: O(min(n, m)), where n is the number of rows, and m is the number of columns.\\n    \\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)\\n        \\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if i == 0 || j == 0 {\\n                    matrix[i][j] = 1\\n                } else {\\n                    matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]\\n                }\\n            }\\n        }\\n        \\n        return matrix[n - 1][m - 1]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241181,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\n- The robot can only move either down or right. Hence any cell in the first row can only be reached from the cell left to it. Similarly, any cell in the first column can only be reached from the cell above it.\\n- For any other cell in the grid, we can reach it either from the cell to left of it or the cell above it.\\n---\\n- Thus, we have the following state equations: suppose the number of paths to arrive at a point `(i, j)` is denoted as `path[i][j]`, then we can find that \\n `path[i][j] = path[i - 1][j] + path[i][j - 1]`.\\n- The boundary conditions of the above equation occur at the leftmost-column and the topmost-row . These conditions can be handled by initialization. So we initialize first-row and first column with `1`. i,e. `path[0][j] = 1` and `path[i][0] = 1` for all valid `i`, `j`.\\n---\\n- Initially, we fill the first row and first column with `1` and then we fill the complete table.\\nFor example- when `n = 4` and `m = 6`, table will look like this:\\n\\n| 1 | 1 | 1 | 1 | 1 | 1 |\\n| -- | -- | -- | -- | -- | -- |\\n| **1** | 2 | 3 | 4 | 5 | 6 | \\n| **1** | 3 | 6 | 10 | 15 | 21 |\\n| **1** | 4 | 10 | 20 | 35 | **56** |\\n\\nTime complexity: `O(n * m)`\\nSpace Complexity: `O(n * m)`\\n\\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int[][] path = new int[n][m];\\n        \\n        for(int i = 0; i < n; i++) path[i][0] = 1;\\n        for(int j = 0; j < m; j++) path[0][j] = 1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 1; j < m; j++)\\n            {\\n                path[i][j] = path[i - 1][j] + path[i][j - 1];\\t\\t// current cell = top cell + left cell\\n            }\\n        }\\n        return path[n - 1][m - 1];\\n    }\\n}\\n```\\n**OR**\\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int[][] path = new int[n][m];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i == 0 || j == 0)\\n                    path[i][j] = 1;\\n                else\\n                    path[i][j] = path[i - 1][j] + path[i][j - 1];\\t// current cell = top cell + left cell\\n            }\\n        }\\n        return path[n - 1][m - 1];\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n- The `Solution1` runs in `O(n * m)` time and costs `O(n * m)` space. Each time when we update `path[i][j]`, we only need `path[i - 1][j]` (at the same column) and `path[i][j - 1]` (at the left column). \\n- So as per this observation, it is enough to maintain two columns the current column and the left column, instead of maintaining the full `n * m` matrix. This will reduce the space complexity to `O(m)`, where `m` is the column size.\\n\\nTime complexity: `O(n * m)`\\nSpace Complexity: `O(m)`\\n\\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n\\t{\\n        int[] pre = new int[m];\\n        int[] cur = new int[m];\\n\\n        for(int i = 0; i < m; i++)\\n\\t\\t{\\n            pre[i] = 1;\\n            cur[i] = 1;            \\n        }\\n\\n        for(int i = 1; i < n; i++)\\n\\t\\t{\\n            for(int j = 1; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur[j] = cur[j - 1] + pre[j];\\t\\t\\t\\t\\t\\t// current cell = top cell + left cell\\n\\t\\t\\t}\\n            pre = cur;\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\\n\\n**Solution 3:**\\n\\n- Further inspecting the `Solution2`, we can see that that keeping two columns or arrays is used to recover pre[i] from the left column, which is just cur[i] before its update. So there is even no need to use two arrays and one is just enough. This will further reduce the required space from `2 * m` to `m`\\n\\nTime complexity: `O(n * m)`\\nSpace Complexity: `O(m)`\\n\\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n\\t{\\n        int[] cur = new int[m];\\n        Arrays.fill(cur, 1);\\n\\n        for(int i = 1; i < n; i++)\\n\\t\\t{\\n            for(int j = 1; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur[j] += cur[j - 1];\\t\\t\\t\\t\\t\\t// current cell = top cell + left cell  \\tcur[j] = cur[j] + cur[j - 1]\\n\\t\\t\\t}\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int[][] path = new int[n][m];\\n        \\n        for(int i = 0; i < n; i++) path[i][0] = 1;\\n        for(int j = 0; j < m; j++) path[0][j] = 1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 1; j < m; j++)\\n            {\\n                path[i][j] = path[i - 1][j] + path[i][j - 1];\\t\\t// current cell = top cell + left cell\\n            }\\n        }\\n        return path[n - 1][m - 1];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n    {\\n        int[][] path = new int[n][m];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i == 0 || j == 0)\\n                    path[i][j] = 1;\\n                else\\n                    path[i][j] = path[i - 1][j] + path[i][j - 1];\\t// current cell = top cell + left cell\\n            }\\n        }\\n        return path[n - 1][m - 1];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n\\t{\\n        int[] pre = new int[m];\\n        int[] cur = new int[m];\\n\\n        for(int i = 0; i < m; i++)\\n\\t\\t{\\n            pre[i] = 1;\\n            cur[i] = 1;            \\n        }\\n\\n        for(int i = 1; i < n; i++)\\n\\t\\t{\\n            for(int j = 1; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur[j] = cur[j - 1] + pre[j];\\t\\t\\t\\t\\t\\t// current cell = top cell + left cell\\n\\t\\t\\t}\\n            pre = cur;\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int uniquePaths(int m, int n)\\n\\t{\\n        int[] cur = new int[m];\\n        Arrays.fill(cur, 1);\\n\\n        for(int i = 1; i < n; i++)\\n\\t\\t{\\n            for(int j = 1; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur[j] += cur[j - 1];\\t\\t\\t\\t\\t\\t// current cell = top cell + left cell  \\tcur[j] = cur[j] + cur[j - 1]\\n\\t\\t\\t}\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23240,
                "title": "dynamic-programming-in-o-m-n-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        int uniquePaths(int m, int n) {\\n            int P[101][101];\\n            P[1][1]=1;\\n            for (int i=2; i<=n; i++)\\n            {\\n                P[1][i]=1;\\n            }\\n            for (int i=2; i<=m; i++)\\n            {\\n                P[i][1]=1;\\n            }\\n            for (int i=2; i<=m; i++)\\n            {\\n                for (int j=2; j<=n; j++)\\n                {\\n                    P[i][j]=P[i-1][j]+P[i][j-1];\\n                }\\n            }\\n            return P[m][n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int uniquePaths(int m, int n) {\\n            int P[101][101];\\n            P[1][1]=1;\\n            for (int i=2; i<=n; i++)\\n            {\\n                P[1][i]=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1484498,
                "title": "3-solutions-c-brute-better-best-recursion-dp-combinatorics",
                "content": "**Recursion Based Solution:(Brute Solution)**\\nExplanation with code:\\n```\\nclass Solution {\\npublic:\\n    int solve(int x,int y,int m,int n)\\n    {\\n        if(x==m-1 and y==n-1)// we reached at target so return 1 (consider 0 based indexing)\\n        {\\n            return 1;\\n        }\\n        \\n        if(x>=m || y>=n)//we are not able to reach to the target so return 0;\\n        {\\n            return 0;\\n        }\\n        \\n        return solve(x+1,y,m,n)+solve(x,y+1,m,n);//at last we return total of x+1 step and y+1 step\\n    }\\n    int uniquePaths(int m, int n) {\\n        int x=0,y=0;\\n        return solve(x,y,m,n);\\n    }\\n};\\n```\\nGives **TLE** :(\\n\\nLet\\'s try to solve by DP :)\\n\\n\\n\\n**DP based solution(Better solution):**\\nSince the robot can only move right and down, when it arrives at a point, it either arrives from left or above. If we use dp[i][j] for the number of unique paths to arrive at the point (i, j), then the state equation is dp[i][j] = dp[i][j - 1] + dp[i - 1][j]. Moreover, we have the base cases dp[0][j] = dp[i][0] = 1 for all valid i and j respectively.\\n\\nExplanation with code:\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> matrix(m,vector<int>(n,1));//0 based \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0||j==0)//Base case\\n                {\\n                    matrix[i][j]=1;\\n                }\\n                else matrix[i][j] = matrix[i-1][j] + matrix[i][j-1];//get the ans from (i-1,j) and (i,j-1) state\\n            }\\n        }\\n        \\n        return matrix[m-1][n-1];//return the ans\\n    }\\n};\\n```\\n\\n**Best Solution:**\\nFor mxn grid, robot has to move exactly m-1 steps down and n-1 steps right and these can be done in any order.\\nTherefore total ways are : m-1 + n-1 = m+n-2\\nIf you placed or choose the m-1 steps from total ways then n-1 automatically found // either can be calculated..\\n\\nso the final ans is m+n-2 choose m-1.i.e.**( (m+n-2 )C (m-1))**\\n\\nCode with explanation:\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int total_ways = m+n-2;//skip current row and col\\n        int r = m-1;//if i placed m-1 then definitely n-1 automatically arranged\\n        \\n        double ans=1;//take double because we have to divide something in the following iterations\\n        for(int i=1;i<=r;i++)\\n        {\\n            ans = ans *(total_ways-r+i)/i; // it will compute total ways choose m-1 \\n        }\\n        \\n        return (int)ans;\\n        \\n    }\\n};\\n```\\n\\n**Enjoy Coding :)** and Like the post if u liked....\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int x,int y,int m,int n)\\n    {\\n        if(x==m-1 and y==n-1)// we reached at target so return 1 (consider 0 based indexing)\\n        {\\n            return 1;\\n        }\\n        \\n        if(x>=m || y>=n)//we are not able to reach to the target so return 0;\\n        {\\n            return 0;\\n        }\\n        \\n        return solve(x+1,y,m,n)+solve(x,y+1,m,n);//at last we return total of x+1 step and y+1 step\\n    }\\n    int uniquePaths(int m, int n) {\\n        int x=0,y=0;\\n        return solve(x,y,m,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> matrix(m,vector<int>(n,1));//0 based \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0||j==0)//Base case\\n                {\\n                    matrix[i][j]=1;\\n                }\\n                else matrix[i][j] = matrix[i-1][j] + matrix[i][j-1];//get the ans from (i-1,j) and (i,j-1) state\\n            }\\n        }\\n        \\n        return matrix[m-1][n-1];//return the ans\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int total_ways = m+n-2;//skip current row and col\\n        int r = m-1;//if i placed m-1 then definitely n-1 automatically arranged\\n        \\n        double ans=1;//take double because we have to divide something in the following iterations\\n        for(int i=1;i<=r;i++)\\n        {\\n            ans = ans *(total_ways-r+i)/i; // it will compute total ways choose m-1 \\n        }\\n        \\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934807,
                "title": "recursion-memo-dp-two-js-solutions",
                "content": "```\\n/*\\n[Recursion & Memo]\\nThe number of possible paths from grid[row][col] to the bottom-right \\n= the number of possible paths from grid[row][col+1] + the number of possible paths from grid[row+1][col]\\n\\n1. We will use DFS to traverse every possible path starting at (0,0). The function dfs() will be called\\nrecursively until the bottom-right (where row = height-1, col = width-1) is reached. \\n- Once the bottom-right is reached, 1 is returned because it means there is a path.\\n- If invalid row or col index is given, 0 will be returned. \\n- If given row and col have already been visited, the result will be returned from this memoization table.\\n- If given row and col are valid, not bottom-right, unvisited position, we will call dfs one to the right and one to the bottom, add these results, record it to our memoization table and return it.\\n\\nWe will use a m x n 2-d array for a memoization table.\\n*/\\nvar uniquePaths = function(m, n) {\\n    let memo = new Array(m).fill(0).map(() => new Array(n));\\n    return dfs(0, 0, m, n, memo);\\n    // T.C: O(M * N), M = # of rows, N = # of columns\\n    // S.C: O(M * N)\\n};\\n\\n// Returns the number of possible paths from given (row,col) to the bottom-right\\nfunction dfs(row, col, height, width, memo) {\\n    // invalid index\\n    if (row < 0 || row >= height || col < 0 || col >= width) {\\n        return 0;\\n    }\\n    // the right-bottom is reached\\n    if (row === height-1 && col === width-1) {\\n        return 1;\\n    }\\n    if (memo[row][col] !== undefined) {\\n        return memo[row][col];\\n    }\\n    let res = dfs(row, col+1, height, width, memo) + dfs(row+1, col, height, width, memo);\\n    memo[row][col] = res;\\n    return res;\\n}\\n```\\n\\n```\\n/*\\n[DP]\\nThe number of paths from (row,col) to the bottom-right \\n= the number of paths from (row, col+1) + the number of paths from (row+1, col).\\n\\nHence, we will create a m x n dp table; dp[row][col] is the number of paths from given row and column to the bottom-right.\\nWe know that every entry in row=m-1 and every entry in col=n-1 will have a value of 1 because we can only move right or down. So, all these will be our base cases.\\n\\nSo we will traverse the grid backwards and fill our dp table.\\n\\nThe answer will be dp[0][0] since we want to figure out the number of paths from (0,0) to the bottom-right.\\n*/\\nvar uniquePaths = function(m, n) {\\n    let dp = new Array(m).fill(0).map(() => new Array(n));\\n    for (let row = m-1; row >= 0; row--) {\\n        for (let col = n-1; col >= 0; col--) {\\n            if (row === m-1 || col === n-1) {\\n                dp[row][col] = 1;\\n            } else {\\n                dp[row][col] = dp[row][col+1] + dp[row+1][col];\\n            }\\n        }\\n    }\\n    return dp[0][0];\\n    // T.C: O(M*N)\\n    // S.C: O(M*N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n[Recursion & Memo]\\nThe number of possible paths from grid[row][col] to the bottom-right \\n= the number of possible paths from grid[row][col+1] + the number of possible paths from grid[row+1][col]\\n\\n1. We will use DFS to traverse every possible path starting at (0,0). The function dfs() will be called\\nrecursively until the bottom-right (where row = height-1, col = width-1) is reached. \\n- Once the bottom-right is reached, 1 is returned because it means there is a path.\\n- If invalid row or col index is given, 0 will be returned. \\n- If given row and col have already been visited, the result will be returned from this memoization table.\\n- If given row and col are valid, not bottom-right, unvisited position, we will call dfs one to the right and one to the bottom, add these results, record it to our memoization table and return it.\\n\\nWe will use a m x n 2-d array for a memoization table.\\n*/\\nvar uniquePaths = function(m, n) {\\n    let memo = new Array(m).fill(0).map(() => new Array(n));\\n    return dfs(0, 0, m, n, memo);\\n    // T.C: O(M * N), M = # of rows, N = # of columns\\n    // S.C: O(M * N)\\n};\\n\\n// Returns the number of possible paths from given (row,col) to the bottom-right\\nfunction dfs(row, col, height, width, memo) {\\n    // invalid index\\n    if (row < 0 || row >= height || col < 0 || col >= width) {\\n        return 0;\\n    }\\n    // the right-bottom is reached\\n    if (row === height-1 && col === width-1) {\\n        return 1;\\n    }\\n    if (memo[row][col] !== undefined) {\\n        return memo[row][col];\\n    }\\n    let res = dfs(row, col+1, height, width, memo) + dfs(row+1, col, height, width, memo);\\n    memo[row][col] = res;\\n    return res;\\n}\\n```\n```\\n/*\\n[DP]\\nThe number of paths from (row,col) to the bottom-right \\n= the number of paths from (row, col+1) + the number of paths from (row+1, col).\\n\\nHence, we will create a m x n dp table; dp[row][col] is the number of paths from given row and column to the bottom-right.\\nWe know that every entry in row=m-1 and every entry in col=n-1 will have a value of 1 because we can only move right or down. So, all these will be our base cases.\\n\\nSo we will traverse the grid backwards and fill our dp table.\\n\\nThe answer will be dp[0][0] since we want to figure out the number of paths from (0,0) to the bottom-right.\\n*/\\nvar uniquePaths = function(m, n) {\\n    let dp = new Array(m).fill(0).map(() => new Array(n));\\n    for (let row = m-1; row >= 0; row--) {\\n        for (let col = n-1; col >= 0; col--) {\\n            if (row === m-1 || col === n-1) {\\n                dp[row][col] = 1;\\n            } else {\\n                dp[row][col] = dp[row][col+1] + dp[row+1][col];\\n            }\\n        }\\n    }\\n    return dp[0][0];\\n    // T.C: O(M*N)\\n    // S.C: O(M*N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994633,
                "title": "c-dp-combinatorics",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**DP Approach :**\\n* We can reach [i, j] from [i-1, j] or [i, j-1]\\n* count of unique paths to [i,j] = count of unique paths to [i-1,j] + count of unique paths to [i,j-1]  \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i=0, j=0;j<n;j++) dp[i][j]=1;\\n        for(int j=0, i=0;i<m;i++) dp[i][j]=1;\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++) dp[i][j]=dp[i-1][j] + dp[i][j-1];\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n**Combinatorics Approach:**\\n\\n* Considering [i,j+1] movement H sticks and [i+1,j] as V sticks, so H = m-1 and V = n-1\\n* Count of unique paths = number of ways we can make arrangments with these sticks\\n\\n![image](https://assets.leetcode.com/users/images/352ef86f-d8a2-4ca5-8f3c-02e13feb3a86_1693706929.8266468.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ncr(int n, int r){\\n        long long int ans=1;\\n        for(int i=0;i<r;i++){\\n            ans *= (n-i);\\n            ans /= (i+1);\\n        }\\n        return (int) ans;\\n    }\\n    \\n    int uniquePaths(int m, int n) {     \\n        return ncr(m+n-2,min(n-1,m-1));\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i=0, j=0;j<n;j++) dp[i][j]=1;\\n        for(int j=0, i=0;i<m;i++) dp[i][j]=1;\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++) dp[i][j]=dp[i-1][j] + dp[i][j-1];\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int ncr(int n, int r){\\n        long long int ans=1;\\n        for(int i=0;i<r;i++){\\n            ans *= (n-i);\\n            ans /= (i+1);\\n        }\\n        return (int) ans;\\n    }\\n    \\n    int uniquePaths(int m, int n) {     \\n        return ncr(m+n-2,min(n-1,m-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640546,
                "title": "easiest-c-solution-using-memoization-0-ms-beats-100-of-the-solutions",
                "content": "1. Let\\'s first consider the possible base cases. \\nWhat happens if we move **out** of the grid ? There is no possible solution in such case.\\n2. If we reach the final cell, then we have a possible answer.\\n3. We can either move **down** or **right** in this problem, hence consider either of them.\\n4. Since, this is a **counting** problem and we need to count the **total ways**, we add the respective down and right results to the answer.\\n5. Memoize using the 2D DP array of size n x m filled with -1.\\n\\n```\\nint solve(int i, int j, int &n, int &m, vector<vector<int>>&dp)\\n    {\\n        if (i < 0 or j < 0 or i >= n or j >= m)\\n            return 0;\\n        \\n        if (i == n - 1 and j == m - 1)\\n            return 1;\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int down = solve(i + 1, j, n, m, dp);\\n        int right = solve(i, j + 1, n, m, dp);\\n        \\n        return dp[i][j] = down + right;\\n    }\\n    \\n    int uniquePaths(int n, int m) {\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        return solve(0, 0, n, m, dp);\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9fc26cf5-daa2-4f8c-8e8b-25b88d621814_1686815441.0917704.png)",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nint solve(int i, int j, int &n, int &m, vector<vector<int>>&dp)\\n    {\\n        if (i < 0 or j < 0 or i >= n or j >= m)\\n            return 0;\\n        \\n        if (i == n - 1 and j == m - 1)\\n            return 1;\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int down = solve(i + 1, j, n, m, dp);\\n        int right = solve(i, j + 1, n, m, dp);\\n        \\n        return dp[i][j] = down + right;\\n    }\\n    \\n    int uniquePaths(int n, int m) {\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        return solve(0, 0, n, m, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2274218,
                "title": "c-0-ms-with-images-explanation",
                "content": "Hello there!\\n\\nHere I present the **combinatorial solution** because personally I think it is easier to think mathematically than to solve using DP (Dynamic Programming).\\n\\nFor those who are not familiar with the notion of combination, check this out: https://artofproblemsolving.com/wiki/index.php?title=Combination\\n\\n\\nIt is a really famous combinatorial problem for math competitions. The notion of N choose R is written in this form: $${n\\\\choose r}$$ \\n\\nOther people use these notations, which I do not use frequently:\\n$C(n,r)$\\n$_n C_r$\\n$C_n^r$\\nSo what does this mean, $N$ choose $R$? It basically means that you are putting $N$ indistinguishable (identical) balls into $R$ distinguishable (different) boxes. The formula for this would be:\\n$${n\\\\choose r} = \\\\frac{n!}{r!(n-r)!}$$\\nBecause you can put the balls in any way, you have $n!$ possibilities. But because there are repeats (the boxes are different), we should divide by $r!(n-r)!$ and you get this formula.\\n************************************************************************************************************************************\\nLet\\'s get in our problem. \\n\\nHere is the diagram provided:\\n![image](https://assets.leetcode.com/users/images/7b2d2c8b-ec9e-411b-aae7-524ec0dd07a7_1657661820.7252288.png)\\nFirst, I let you choose any path you want. How many steps must the bot go to reach the star?\\n![image](https://assets.leetcode.com/users/images/bef35c8f-85f0-482d-9dfa-0dcae9924c60_1657661383.641953.png)\\nClearly, you see that it requires $8$ steps to arrive there. But the bot walks two steps down and six steps right. It could have chosen to walk right first, then walk down to reach the star. So all the possible ways to walk to the end would be all the choices of where to place his downward steps in the grid! The bot could have chosen to walk like this:\\n![image](https://assets.leetcode.com/users/images/ae3636dd-fc2e-4481-b1c1-5fda55cea885_1657662070.0830517.png)\\nOr like this:\\n![image](https://assets.leetcode.com/users/images/05d62218-8a0f-482d-8d58-9d0677754a54_1657662094.6793065.png)\\nYou can see that he decides when to go down. When you get all the possibilities of where to go down, it is the final answer.\\n\\nYou should see that all the possibilities is simply the number of ways to choose 2 down steps from 8 walkings. You could also have thought of the number of ways to choose 6 right steps from 8 walkings. They yield to the same answer. You know why? It is because of the formula:\\n${8 \\\\choose 2}=\\\\frac{8!}{2!(8-2)!}=\\\\frac{8!}{2!6!}$\\n$${8 \\\\choose 6}=\\\\frac{8!}{6!(8-6)!}=\\\\frac{8!}{2!6!}$$\\n$${8 \\\\choose 2}={8\\\\choose 6}$$\\nSo the 1-1 correspondance would be that the number of ways to walk the grid would be the number of ways to choose $R$ down/right steps from $N$ steps.\\n******************************************************************************\\nBut wait, how do we translate this into code language? How do we define the number of steps and the number of down steps?\\n\\nLet\\'s work on our example. We have $m = 3$ and $n = 7$. We said earlier that we have 8 steps to walk. We get that by calculating $(m - 1) + (n - 1) = m + n - 2 = 3 + 7 - 2 = 8$.\\n\\nNext, how do we get the number of down/right steps? We either have $m - 1 = 2$ or $n - 1 = 6$. \\n\\nFinally, how do we implement our combinatorial formula? For those using Python, it is easier because $factorial$ which does all the work. (By the way, $n$ $factorial$ means $n!$)\\n\\nFor $C++$ (which is what I use), we need to create $for$ loops to compute it. Recall the formula:\\n$${n\\\\choose r} = \\\\frac{n!}{r!(n-r)!}$$\\nThis technically equals:\\n$${n\\\\choose r} = \\\\frac{n!}{r!(n-r)!}=\\\\frac{1\\\\times2\\\\times3\\\\times...\\\\times n}{(1\\\\times2\\\\times...\\\\times r)(1\\\\times2\\\\times...\\\\times n - r)}=\\\\frac{(n-r+1)(n-r+2)...n}{1\\\\times2\\\\times...\\\\times r}$$\\nSo we only need to loop-multiply from $m$ (or $n$) to $m + n - 2$ and then loop-divide from $1$ to ($m$ (or $n$) - 1).\\nDo not forget that we need the smallest divider and the biggest multiplier. You can choose between $smallest$ divider and $biggest$ multiplier OR $biggest$ divider and $smallest$ multiplier. They yield the same result.\\n\\nFor those who do not understand what I meant, look at the example: if $m = 3$ and $n = 7$, we would have either $7 \\\\times 8 / 1 \\\\times 2$ or $3 \\\\times 4 \\\\times 5 \\\\times 6 \\\\times 7 \\\\times 8 / 1 \\\\times 2 \\\\times 3 \\\\times 4 \\\\times 5 \\\\times 6$. In the second expression, the $3$, $4$, $5$ and $6$\\'s all cancel to yield the first expression. So it overcomplicates everything for nothing. I prefer using the smallest divider and the biggest multiplier for this problem.\\n\\nNow it\\'s time for what everyone wants to see: the solution code. It gave me $0\\\\text{ ms}$ runtime (yey!). Please note that I used ```double``` for the answer because the answers can be REALLY large. Even ```long long``` does not satisfy the problem.\\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        double ans = 1;\\n        // Implementing {m + n - 2 choose m (or n) - 1}\\n        for (int i = max(m, n); i <= m + n - 2; i++) ans *= i;\\n        for (int j = 1; j <= min(m, n) - 1; j++) ans /= j;\\n        return ans;\\n    }\\n};\\n```\\n**PLEASE UPVOTE IF YOU FIND IT HELPFUL!!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```double```\n```long long```\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        double ans = 1;\\n        // Implementing {m + n - 2 choose m (or n) - 1}\\n        for (int i = max(m, n); i <= m + n - 2; i++) ans *= i;\\n        for (int j = 1; j <= min(m, n) - 1; j++) ans /= j;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22965,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The **ART** of dynamic programming:](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n---\\n\\n**Top-Down:**\\n\\nThe number of ways to each cell `i`,`j` is the number of ways to reach the cell below (ie. `i + 1`,`j`) plus the number of ways to reach the cell to the right (ie. `i`,`j + 1`).  Thus the recurrence relation is:\\n\\n* `go(i, j)` = `go(i + 1, j) + go(i, j + 1)`\\n\\nThe base case occurs when we reach the bottom-right cell `M - 1`, `N - 1`, ie. we return `1` to count each unique each path.\\n\\n**Bottom-Up:**\\n\\nThe number of ways to each cell `i`,`j` is the sum of the number of ways to reach the cell above (ie. `i - 1`,`j`) and the number of ways to reach cell to-the-left (ie. `i`,`j - 1`).  Thus the recurrence relation is:\\n\\n* `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`\\n\\nThe base case occurs where we start at `0`,`0`, ie. there exists `1` way to reach the beginning: `dp[0][0] = 1`.\\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1\\n            var D = go(i + 1, j)\\n            var R = go(i, j + 1)\\n            return D + R\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var D = go(i + 1, j)\\n                var R = go(i, j + 1)\\n                m[k] = D + R\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var dp = Array(M) { IntArray(N) { 0 } }\\n        for (i in 0 until M) dp[i][0] = 1\\n        for (j in 0 until N) dp[0][j] = 1\\n        for (i in 1 until M) {\\n            for (j in 1 until N) {\\n                var U = dp[i - 1][j]\\n                var L = dp[i][j - 1]\\n                dp[i][j] = U + L\\n            }\\n        }\\n        return dp[M - 1][N - 1]\\n    }\\n}\\n```\\n\\n4. Bottom-up memory optimiziation 2N (previous and current rows of DP matrix)\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var pre = IntArray(N) { 1 }\\n        for (i in 1 until M) {\\n            var cur = pre.copyOf()\\n            for (j in 1 until N)\\n                cur[j] += cur[j - 1]\\n            pre = cur.also{ cur = pre }\\n        }\\n        return pre[N - 1]\\n    }\\n}\\n```\\n\\n5. Bottom-up memory optimiziation N (current row of DP matrix)\\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var cur = IntArray(N) { 1 }\\n        for (i in 1 until M)\\n            for (j in 1 until N)\\n                cur[j] += cur[j - 1]\\n        return cur[N - 1]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet uniquePaths = (M, N) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return 0;\\n        if (i == M - 1 && j == N - 1)\\n            return 1;\\n        let D = go(i + 1, j),\\n            R = go(i, j + 1);\\n        return D + R;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet uniquePaths = (M, N, m = new Map()) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return 0;\\n        if (i == M - 1 && j == N - 1)\\n            return 1;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let D = go(i + 1, j),\\n                R = go(i, j + 1);\\n            m.set(k, D + R);\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet uniquePaths = (M, N) => {\\n    let dp = [...Array(M)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < M; dp[i++][0] = 1);\\n    for (let j = 0; j < N; dp[0][j++] = 1);\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 1; j < N; ++j) {\\n            let U = dp[i - 1][j],\\n                L = dp[i][j - 1];\\n            dp[i][j] = U + L;\\n        }\\n    }\\n    return dp[M - 1][N - 1];\\n};\\n```\\n\\n4. Bottom-up memory optimiziation 2N (previous and current rows of DP matrix)\\n```\\nlet uniquePaths = (M, N) => {\\n    let pre = Array(N).fill(1);\\n    for (let i = 1; i < M; ++i) {\\n        let cur = [...pre];\\n        for (let j = 1; j < N; ++j)\\n            cur[j] += cur[j - 1];\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[N - 1];\\n};\\n```\\n\\n5. Bottom-up memory optimiziation N (current row of DP matrix)\\n```\\nlet uniquePaths = (M, N) => {\\n    let cur = Array(N).fill(1);\\n    for (let i = 1; i < M; ++i)\\n        for (let j = 1; j < N; ++j)\\n            cur[j] += cur[j - 1];\\n    return cur[N - 1];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return 0\\n            if i == M - 1 and j == N - 1:\\n                return 1\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            return D + R\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return 0\\n            if i == M - 1 and j == N - 1:\\n                return 1\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            return D + R\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        dp = [[0] * N for _ in range(M)]\\n        for i in range(M): dp[i][0] = 1\\n        for j in range(N): dp[0][j] = 1\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                U = dp[i - 1][j]\\n                L = dp[i][j - 1]\\n                dp[i][j] = U + L\\n        return dp[M - 1][N - 1]\\n```\\n\\n4. Bottom-up memory optimiziation 2N (previous and current rows of DP matrix)\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        pre = [1] * N\\n        for i in range(1, M):\\n            cur = pre.copy()\\n            for j in range(1, N):\\n                cur[j] += cur[j - 1]\\n            pre, cur = cur, pre\\n        return pre[N - 1]\\n```\\n\\n5. Bottom-up memory optimiziation N (current row of DP matrix)\\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        cur = [1] * N\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                cur[j] += cur[j - 1]\\n        return cur[N - 1]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int uniquePaths(int M, int N) {\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1;\\n            auto D = go(i + 1, j),\\n                 R = go(i, j + 1);\\n            return D + R;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int uniquePaths(int M, int N) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, Map m = {}) {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto D = go(i + 1, j),\\n                     R = go(i, j + 1);\\n                m[k] = D + R;\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int uniquePaths(int M, int N) {\\n        VVI dp(M, VI(N));\\n        for (auto i{ 0 }; i < M; dp[i++][0] = 1);\\n        for (auto j{ 0 }; j < N; dp[0][j++] = 1);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                auto U = dp[i - 1][j],\\n                     L = dp[i][j - 1];\\n                dp[i][j] = U + L;\\n            }\\n        }\\n        return dp[M - 1][N - 1];\\n    }\\n};\\n```\\n\\n4. Bottom-up memory optimiziation 2N (previous and current rows of DP matrix)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int uniquePaths(int M, int N) {\\n        VI pre(N, 1);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            auto cur{ pre };\\n            for (auto j{ 1 }; j < N; ++j)\\n                cur[j] += cur[j - 1];\\n            swap(pre, cur);\\n        }\\n        return pre[N - 1];\\n    }\\n};\\n```\\n\\n5. Bottom-up memory optimiziation N (current row of DP matrix)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int uniquePaths(int M, int N) {\\n        VI cur(N, 1);\\n        for (auto i{ 1 }; i < M; ++i)\\n            for (auto j{ 1 }; j < N; ++j)\\n                cur[j] += cur[j - 1];\\n        return cur[N - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1\\n            var D = go(i + 1, j)\\n            var R = go(i, j + 1)\\n            return D + R\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var D = go(i + 1, j)\\n                var R = go(i, j + 1)\\n                m[k] = D + R\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var dp = Array(M) { IntArray(N) { 0 } }\\n        for (i in 0 until M) dp[i][0] = 1\\n        for (j in 0 until N) dp[0][j] = 1\\n        for (i in 1 until M) {\\n            for (j in 1 until N) {\\n                var U = dp[i - 1][j]\\n                var L = dp[i][j - 1]\\n                dp[i][j] = U + L\\n            }\\n        }\\n        return dp[M - 1][N - 1]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var pre = IntArray(N) { 1 }\\n        for (i in 1 until M) {\\n            var cur = pre.copyOf()\\n            for (j in 1 until N)\\n                cur[j] += cur[j - 1]\\n            pre = cur.also{ cur = pre }\\n        }\\n        return pre[N - 1]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun uniquePaths(M: Int, N: Int): Int {\\n        var cur = IntArray(N) { 1 }\\n        for (i in 1 until M)\\n            for (j in 1 until N)\\n                cur[j] += cur[j - 1]\\n        return cur[N - 1]\\n    }\\n}\\n```\n```\\nlet uniquePaths = (M, N) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return 0;\\n        if (i == M - 1 && j == N - 1)\\n            return 1;\\n        let D = go(i + 1, j),\\n            R = go(i, j + 1);\\n        return D + R;\\n    };\\n    return go();\\n};\\n```\n```\\nlet uniquePaths = (M, N, m = new Map()) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return 0;\\n        if (i == M - 1 && j == N - 1)\\n            return 1;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let D = go(i + 1, j),\\n                R = go(i, j + 1);\\n            m.set(k, D + R);\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet uniquePaths = (M, N) => {\\n    let dp = [...Array(M)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < M; dp[i++][0] = 1);\\n    for (let j = 0; j < N; dp[0][j++] = 1);\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 1; j < N; ++j) {\\n            let U = dp[i - 1][j],\\n                L = dp[i][j - 1];\\n            dp[i][j] = U + L;\\n        }\\n    }\\n    return dp[M - 1][N - 1];\\n};\\n```\n```\\nlet uniquePaths = (M, N) => {\\n    let pre = Array(N).fill(1);\\n    for (let i = 1; i < M; ++i) {\\n        let cur = [...pre];\\n        for (let j = 1; j < N; ++j)\\n            cur[j] += cur[j - 1];\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[N - 1];\\n};\\n```\n```\\nlet uniquePaths = (M, N) => {\\n    let cur = Array(N).fill(1);\\n    for (let i = 1; i < M; ++i)\\n        for (let j = 1; j < N; ++j)\\n            cur[j] += cur[j - 1];\\n    return cur[N - 1];\\n};\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return 0\\n            if i == M - 1 and j == N - 1:\\n                return 1\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            return D + R\\n        return go()\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return 0\\n            if i == M - 1 and j == N - 1:\\n                return 1\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            return D + R\\n        return go()\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        dp = [[0] * N for _ in range(M)]\\n        for i in range(M): dp[i][0] = 1\\n        for j in range(N): dp[0][j] = 1\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                U = dp[i - 1][j]\\n                L = dp[i][j - 1]\\n                dp[i][j] = U + L\\n        return dp[M - 1][N - 1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        pre = [1] * N\\n        for i in range(1, M):\\n            cur = pre.copy()\\n            for j in range(1, N):\\n                cur[j] += cur[j - 1]\\n            pre, cur = cur, pre\\n        return pre[N - 1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, M: int, N: int) -> int:\\n        cur = [1] * N\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                cur[j] += cur[j - 1]\\n        return cur[N - 1]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int uniquePaths(int M, int N) {\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1;\\n            auto D = go(i + 1, j),\\n                 R = go(i, j + 1);\\n            return D + R;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int uniquePaths(int M, int N) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, Map m = {}) {\\n            if (i == M || j == N)\\n                return 0;\\n            if (i == M - 1 && j == N - 1)\\n                return 1;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto D = go(i + 1, j),\\n                     R = go(i, j + 1);\\n                m[k] = D + R;\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int uniquePaths(int M, int N) {\\n        VVI dp(M, VI(N));\\n        for (auto i{ 0 }; i < M; dp[i++][0] = 1);\\n        for (auto j{ 0 }; j < N; dp[0][j++] = 1);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                auto U = dp[i - 1][j],\\n                     L = dp[i][j - 1];\\n                dp[i][j] = U + L;\\n            }\\n        }\\n        return dp[M - 1][N - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int uniquePaths(int M, int N) {\\n        VI pre(N, 1);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            auto cur{ pre };\\n            for (auto j{ 1 }; j < N; ++j)\\n                cur[j] += cur[j - 1];\\n            swap(pre, cur);\\n        }\\n        return pre[N - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int uniquePaths(int M, int N) {\\n        VI cur(N, 1);\\n        for (auto i{ 1 }; i < M; ++i)\\n            for (auto j{ 1 }; j < N; ++j)\\n                cur[j] += cur[j - 1];\\n        return cur[N - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23129,
                "title": "0ms-java-10-line-code",
                "content": "    public int uniquePaths(int m, int n) {\\n        int smaller = m>n ? n-1 : m-1;\\n        int totalsteps = m+n-2;\\n        long result = 1;\\n        for (int counter = 1; counter<=smaller; counter++){\\n            result *= totalsteps--;\\n            result /= counter;\\n        }\\n        return (int)result;\\n    }\\nBasically it is math: select m (or n) from [(m-1)+(n-1)]",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int uniquePaths(int m, int n) {\\n        int smaller = m>n ? n-1 : m-1;\\n        int totalsteps = m+n-2;\\n        long result = 1;\\n        for (int counter = 1; counter<=smaller; counter++){\\n            result *= totalsteps--;\\n            result /= counter;\\n        }\\n        return (int)result;\\n    }\\nBasically it is math: select m (or n) from [(m-1)+(n-1)]",
                "codeTag": "Unknown"
            },
            {
                "id": 3995933,
                "title": "c-100-tc-basic-math-optimised",
                "content": "### \\uD83D\\uDD25 Donn Forget to Upvote if you liked the Approach \\uD83D\\uDD25\\n\\n\\n# Intuition\\nIntution to the problem is we just have to reach at the bottom corner for that we only have to moves possible either to our right or to a step down from the current location. So basically our total no. of ways is going to be total no. of arrangements of \\'R\\' movement and \\'D\\' movement.\\n\\n# Approach\\nLet\\'s Say `m=5` and `n=3` so to reach at bottom right we\\'ll have to move right 4 times and down 2 times. therefore we have `R,R,R,R,D,D` movements with us.\\nNow we have to find the total no. of ways of reaching at bottom right corner for that we have 4 R\\'s and 2 D\\'s. We just have to apply the arrangements formula which will be `6!/(4!*2!)`.\\n\\n# Complexity\\n- Time complexity:\\n    O(N-max(R,N-R)).\\n    N= Rows+ Cols- 2.\\n    R= Rows-1.\\n    N-R= Cols-1.\\n\\n- Space complexity:\\n    O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int cal(int n, int r)\\n    {\\n        long long p=1, k=1;\\n        if (n-r<r)\\n            r=n-r;\\n        if(r!=0) {\\n            while(r) {\\n                p*=n;\\n                k*=r;\\n                long long m=__gcd(p,k);\\n                p/=m;\\n                k/=m;\\n                n--;\\n                r--;\\n            }\\n        }\\n        else\\n            p=1;\\n        return p;\\n    }\\n    int uniquePaths(int m, int n) {\\n        return cal(m+n-2,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int cal(int n, int r)\\n    {\\n        long long p=1, k=1;\\n        if (n-r<r)\\n            r=n-r;\\n        if(r!=0) {\\n            while(r) {\\n                p*=n;\\n                k*=r;\\n                long long m=__gcd(p,k);\\n                p/=m;\\n                k/=m;\\n                n--;\\n                r--;\\n            }\\n        }\\n        else\\n            p=1;\\n        return p;\\n    }\\n    int uniquePaths(int m, int n) {\\n        return cal(m+n-2,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572377,
                "title": "unique-paths-4-approaches-recursion-memoization-tabulation-space-optimization",
                "content": "# **Recursive Approach**\\n\\nTime Complexity : 2^(n*m)\\nSpace Complexity: O((m-1)+(n-1))\\nThis will give a **TLE**\\n\\n```\\nint find(int i,int j,vector<vector<int>>& dp){\\n        if( i == 0 &&  j == 0 ) return 1;\\n        if ( i<0 || j<0) return 0;\\n        int up = find( i-1 , j );\\n        int left = find( i , j-1 );\\n        return up+left;\\n    }\\n    int uniquePaths(int m, int n) {\\n        return find ( m-1 ,n-1 );\\n    }\\n```\\n\\t\\n# \\tMemoization Approach\\nTime Complexity : O(n*m)\\nSpace Complexity: O((m-1)+(n-1))+O(n*m)\\n\\n```\\nint find(int i,int j,vector<vector<int>>& dp){\\n        if(i==0 && j==0)\\n            return 1;\\n        if(i<0 || j<0)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int up = find(i-1,j,dp);\\n        int left = find(i,j-1,dp);\\n        return dp[i][j] = up+left;\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return find(m-1,n-1,dp);\\n    }\\n```\\n\\t\\n# \\tTabulation Method\\n\\nTime Complexity : O(n*m)\\nSpace Complexity: O(n*m)\\n\\n```\\nint uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    int dp [m] [n];   \\n\\tfor (int i=0; i<m; i++){\\n        for (int j=0 ;j<n ;j++){\\n            if ( i==0 || j==0 ) dp[i][j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=dp [i-1] [j];\\n                int u=0;\\n                if(j>0) u=dp [i] [j-1];                       \\n                dp [i] [j] =l+u;\\n                }\\n            }\\n        }\\n        return dp [ m-1 ] [ n-1 ] ;\\n}\\n```\\n\\n# Space Optimization\\n\\n```\\nint uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    vector<int> prev(n,0);\\n    for(int i=0;i<m;i++){\\n        vector<int>curr(n,0);\\n        for(int j=0;j<n;j++){\\n            if(i==0||j==0) curr[j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=prev[j];\\n                int u=0;\\n                if(j>0) u=curr[j-1];                       \\n                curr[j]=l+u;\\n                }\\n            }\\n        prev=curr;\\n        }\\n        return prev[n-1];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint find(int i,int j,vector<vector<int>>& dp){\\n        if( i == 0 &&  j == 0 ) return 1;\\n        if ( i<0 || j<0) return 0;\\n        int up = find( i-1 , j );\\n        int left = find( i , j-1 );\\n        return up+left;\\n    }\\n    int uniquePaths(int m, int n) {\\n        return find ( m-1 ,n-1 );\\n    }\\n```\n```\\nint find(int i,int j,vector<vector<int>>& dp){\\n        if(i==0 && j==0)\\n            return 1;\\n        if(i<0 || j<0)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int up = find(i-1,j,dp);\\n        int left = find(i,j-1,dp);\\n        return dp[i][j] = up+left;\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return find(m-1,n-1,dp);\\n    }\\n```\n```\\nint uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    int dp [m] [n];   \\n\\tfor (int i=0; i<m; i++){\\n        for (int j=0 ;j<n ;j++){\\n            if ( i==0 || j==0 ) dp[i][j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=dp [i-1] [j];\\n                int u=0;\\n                if(j>0) u=dp [i] [j-1];                       \\n                dp [i] [j] =l+u;\\n                }\\n            }\\n        }\\n        return dp [ m-1 ] [ n-1 ] ;\\n}\\n```\n```\\nint uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    vector<int> prev(n,0);\\n    for(int i=0;i<m;i++){\\n        vector<int>curr(n,0);\\n        for(int j=0;j<n;j++){\\n            if(i==0||j==0) curr[j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=prev[j];\\n                int u=0;\\n                if(j>0) u=curr[j-1];                       \\n                curr[j]=l+u;\\n                }\\n            }\\n        prev=curr;\\n        }\\n        return prev[n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127822,
                "title": "5-approaches-o-m-time-o-1-space-c",
                "content": "Implementation\\n\\n**1st Approach\\nRecursive Approach\\nWill give TLE\\nTime Complexity : O(2!)\\nSpace Complexity : O(2!)**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, int left, int up){\\n        if(left == -1 || up == -1) return 0;\\n        if(left == 0 && up == 0) return 1;\\n        \\n        int leftSide = solve(m, n, left-1, up);\\n        int upSide = solve(m, n, left, up-1);\\n        \\n        return leftSide + upSide;\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m, n, m-1, n-1);\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nMemoization Approach\\nime Complexity : O(M * N)\\nSpace Complexity : O((M * N) + (M * N)) => O(M * N), bcz of recursion stack trace**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, int left, int up, vector<vector<int>> &memo){\\n        if(left == -1 || up == -1) return 0;\\n        if(left == 0 && up == 0) return 1;\\n        \\n        if(memo[left][up] != -1) return memo[left][up];\\n        \\n        int leftSide = solve(m, n, left-1, up, memo);\\n        int upSide = solve(m, n, left, up-1, memo);\\n        \\n        return memo[left][up] = leftSide + upSide;\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> memo(m, vector<int> (n, -1));\\n        return solve(m, n, m-1, n-1, memo);\\n    }\\n};\\n```\\n\\n\\n\\n**3rd Approach\\nDP Approach\\nTime Complexity : O(M * N)\\nSpace Complexity : O(M * N)**\\n\\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = 1;\\n                }\\n                else{                    \\n                    int leftSide = 0;\\n                    if(i-1 >= 0){\\n                        leftSide = dp[i-1][j];\\n                    }\\n                    \\n                    int upSide = 0;\\n                    if(j-1 >= 0){\\n                        upSide = dp[i][j-1];\\n                    }                        \\n                    \\n                    dp[i][j] = leftSide + upSide;\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n\\n**4th Approach\\nSpace Optimization in DP Approach\\nTime Complexity : O(M*N)\\nSpace Complexity : O(N)**\\n\\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> prev(n, 0);\\n        \\n        for(int i = 0; i < m; i++){\\n            \\n            vector<int> cur(n, 0);\\n            \\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    cur[j] = 1;\\n                }\\n                else{                    \\n                    int leftSide = 0;\\n                    if(i-1 >= 0){\\n                        leftSide = prev[j];\\n                    }\\n                    \\n                    int upSide = 0;\\n                    if(j-1 >= 0){\\n                        upSide = cur[j-1];\\n                    }                        \\n                    \\n                    cur[j] = leftSide + upSide;\\n                }\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[n-1];\\n    }\\n};\\n```\\n\\n\\n\\n**5th Approach\\nLinear Solution\\nTime Complexity : O(M)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        int formulaValue = m + n - 2;\\n        int run = m-1;\\n        \\n        // NcR formula\\n        \\n        double sum = 1;\\n        for(int i = 1; i <= run; i++){\\n            sum = sum * (formulaValue - run + i) / i;\\n        }\\n        \\n        return (int)sum;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, int left, int up){\\n        if(left == -1 || up == -1) return 0;\\n        if(left == 0 && up == 0) return 1;\\n        \\n        int leftSide = solve(m, n, left-1, up);\\n        int upSide = solve(m, n, left, up-1);\\n        \\n        return leftSide + upSide;\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m, n, m-1, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, int left, int up, vector<vector<int>> &memo){\\n        if(left == -1 || up == -1) return 0;\\n        if(left == 0 && up == 0) return 1;\\n        \\n        if(memo[left][up] != -1) return memo[left][up];\\n        \\n        int leftSide = solve(m, n, left-1, up, memo);\\n        int upSide = solve(m, n, left, up-1, memo);\\n        \\n        return memo[left][up] = leftSide + upSide;\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> memo(m, vector<int> (n, -1));\\n        return solve(m, n, m-1, n-1, memo);\\n    }\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = 1;\\n                }\\n                else{                    \\n                    int leftSide = 0;\\n                    if(i-1 >= 0){\\n                        leftSide = dp[i-1][j];\\n                    }\\n                    \\n                    int upSide = 0;\\n                    if(j-1 >= 0){\\n                        upSide = dp[i][j-1];\\n                    }                        \\n                    \\n                    dp[i][j] = leftSide + upSide;\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> prev(n, 0);\\n        \\n        for(int i = 0; i < m; i++){\\n            \\n            vector<int> cur(n, 0);\\n            \\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    cur[j] = 1;\\n                }\\n                else{                    \\n                    int leftSide = 0;\\n                    if(i-1 >= 0){\\n                        leftSide = prev[j];\\n                    }\\n                    \\n                    int upSide = 0;\\n                    if(j-1 >= 0){\\n                        upSide = cur[j-1];\\n                    }                        \\n                    \\n                    cur[j] = leftSide + upSide;\\n                }\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        int formulaValue = m + n - 2;\\n        int run = m-1;\\n        \\n        // NcR formula\\n        \\n        double sum = 1;\\n        for(int i = 1; i <= run; i++){\\n            sum = sum * (formulaValue - run + i) / i;\\n        }\\n        \\n        return (int)sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23204,
                "title": "44ms-python-dp-solution",
                "content": "    def uniquePaths(self, m, n):\\n            table = [[0 for x in range(n)] for x in range(m)]\\n            for i in range(m):\\n                table[i][0] = 1\\n            for i in range(n):\\n                table[0][i] = 1\\n            for i in range(1,m):\\n                for j in range(1,n):\\n                    table[i][j] = table[i-1][j] + table[i][j-1]\\n            return table[m-1][n-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def uniquePaths(self, m, n):\\n            table = [[0 for x in range(n)] for x in range(m)]\\n            for i in range(m):\\n                table[i][0] = 1\\n            for i in range(n):\\n                table[0][i] = 1\\n            for i in range(1,m):\\n                for j in range(1,n):\\n                    table[i][j] = table[i-1][j] + table[i][j-1]\\n            return table[m-1][n-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23239,
                "title": "one-line-in-python",
                "content": "It's true that this can be solved with dynamic programming. But you can see that every path has exactly m - 1 horizontal moves and n - 1 vertical moves. So, to get a particular path, you need to choose where to put your m - 1 horizontal moves (or your n - 1 vertical moves) amongst the m + n - 2 total moves. That gives (m+n-2 choose m-1) paths (or (m+n-2 choose n-1), which is the same).\\n\\n    class Solution:\\n        # @return an integer\\n        def uniquePaths(self, m, n):\\n            return math.factorial(m + n - 2) / (math.factorial(m - 1) * math.factorial(n - 1))",
                "solutionTags": [],
                "code": "It's true that this can be solved with dynamic programming. But you can see that every path has exactly m - 1 horizontal moves and n - 1 vertical moves. So, to get a particular path, you need to choose where to put your m - 1 horizontal moves (or your n - 1 vertical moves) amongst the m + n - 2 total moves. That gives (m+n-2 choose m-1) paths (or (m+n-2 choose n-1), which is the same).\\n\\n    class Solution:\\n        # @return an integer\\n        def uniquePaths(self, m, n):\\n            return math.factorial(m + n - 2) / (math.factorial(m - 1) * math.factorial(n - 1))",
                "codeTag": "Java"
            },
            {
                "id": 3346352,
                "title": "dp-o-mn-time-o-mn-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe approach used in the code is dynamic programming. We create a m x n grid and calculate the number of unique paths from the top-left corner to each cell in the grid.\\n\\nWe initialize the first row and first column of the grid to 1, because there is only one way to reach any cell in the first row or first column - by moving only right or down respectively.\\n\\nFor all other cells, we can reach that cell from either the cell above it or the cell to its left. So the number of unique paths to that cell is the sum of the number of unique paths to the cell above it and the cell to its left.\\n\\nWe fill up the entire grid in this manner and return the number of unique paths to the bottom-right corner, which is the last cell in the grid.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize a 2D grid of size m x n with all elements set to 0.\\n2. For each cell in the first row or first column, set its value to 1, since there is only one unique path to reach any cell in the first row or first column.\\n3. For each cell (i, j) in the grid where i > 0 and j > 0, set its value to the sum of the value of the cell above it (i-1, j) and the value of the cell to its left (i, j-1).\\n4. Once the entire grid has been filled, return the value of the bottom-right cell (m-1, n-1), which represents the total number of unique paths from the top-left corner to the bottom-right corner of the grid.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n//using dynamic programming - O(mn) time and O(mn) space\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>grid(m, vector<int>(n));\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (row == 0 || col == 0) {\\n                    grid[row][col] = 1;\\n                }\\n                else {\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n```C++ []\\n//using recursion - O(2^(m+n)) time and O(m+n) space\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (m == 1 || n == 1)\\n            return 1;\\n        return uniquePaths(m-1, n) + uniquePaths(m, n-1);\\n    }\\n};\\n```\\n```Java []\\n//using dynamic programming - O(mn) time and O(mn) space\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] grid = new int[m][n];\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (row == 0 || col == 0) {\\n                    grid[row][col] = 1;\\n                }\\n                else {\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        grid = [[0] * n for _ in range(m)]\\n        for row in range(m):\\n            for col in range(n):\\n                if row == 0 or col == 0:\\n                    grid[row][col] = 1\\n                else:\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1]\\n        return grid[m-1][n-1]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(mn)** - DP\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(mn)** - DP\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\n//using dynamic programming - O(mn) time and O(mn) space\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>grid(m, vector<int>(n));\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (row == 0 || col == 0) {\\n                    grid[row][col] = 1;\\n                }\\n                else {\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\n```C++ []\\n//using recursion - O(2^(m+n)) time and O(m+n) space\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (m == 1 || n == 1)\\n            return 1;\\n        return uniquePaths(m-1, n) + uniquePaths(m, n-1);\\n    }\\n};\\n```\n```Java []\\n//using dynamic programming - O(mn) time and O(mn) space\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] grid = new int[m][n];\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (row == 0 || col == 0) {\\n                    grid[row][col] = 1;\\n                }\\n                else {\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        grid = [[0] * n for _ in range(m)]\\n        for row in range(m):\\n            for col in range(n):\\n                if row == 0 or col == 0:\\n                    grid[row][col] = 1\\n                else:\\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1]\\n        return grid[m-1][n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362716,
                "title": "convert-recursion-dp-easy-cpp-comments",
                "content": "UPVOTE IF HELPFUL\\n\\n**recursion**\\n```\\nclass Solution {\\npublic:\\n    int help(int i,int j,int m,int n)\\n    {\\n        if(i>=m || j>=n )return 0;   //if i>=m means outside so simple return 0;\\n        if(i==(m-1) && j==(n-1))return 1;    // if i==m-1 && j==n-1 means we reach the exact location or at the end so return 1;\\n       return  help(i+1,j,m,n)+help(i,j+1,m,n);   // move right abd down so i+1 mean down and j+1 move right.\\n    }\\n\\t\\n    int uniquePaths(int m, int n) {\\n        return help(0,0,m,n); //function call\\n        \\n    }\\n};\\n\\n```\\n\\n**DP**\\n\\n```\\nclass Solution {\\npublic:\\n    int help(int i,int j,int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(i>=m || j>=n )return 0;\\n        if(i==(m-1) && j==(n-1))return 1;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n       return dp[i][j]= help(i+1,j,m,n,dp)+help(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return help(0,0,m,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(int i,int j,int m,int n)\\n    {\\n        if(i>=m || j>=n )return 0;   //if i>=m means outside so simple return 0;\\n        if(i==(m-1) && j==(n-1))return 1;    // if i==m-1 && j==n-1 means we reach the exact location or at the end so return 1;\\n       return  help(i+1,j,m,n)+help(i,j+1,m,n);   // move right abd down so i+1 mean down and j+1 move right.\\n    }\\n\\t\\n    int uniquePaths(int m, int n) {\\n        return help(0,0,m,n); //function call\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int help(int i,int j,int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(i>=m || j>=n )return 0;\\n        if(i==(m-1) && j==(n-1))return 1;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n       return dp[i][j]= help(i+1,j,m,n,dp)+help(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return help(0,0,m,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855525,
                "title": "python-math-solution-3-lines",
                "content": "This problem can be used in a more Computer Science lens or a Mathematics lens. As a CS and Math double major I wanted to go with the math solution as it\\'s a lot easier to explain and code. This is a question about possile unique paths, which can be solved using DP or just basic combinatorics. In combinatorics, if you want to find the number of possible unique paths, in no particular order, without repitition, we use n choose k (nCk). Instead of hard coding the factorial and choose functions, we can simply use the math module which has the comb() method for nCk. By letting k be the smaller of the two dimensions, it improves the time.\\n\\nIt should be noted that in my explanation above, n isn\\'t the same n given in the problem, hence why I am using n to be a for nCk since the given *n* is one of the demensions of our board.\\n```\\nclass Solution:    \\n    def uniquePaths(self, m: int, n: int) -> int:\\n        a = (n - 1) + (m - 1)\\n        k = min(n, m) - 1\\n               \\n        return int(comb(a, k))\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:    \\n    def uniquePaths(self, m: int, n: int) -> int:\\n        a = (n - 1) + (m - 1)\\n        k = min(n, m) - 1\\n               \\n        return int(comb(a, k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411539,
                "title": "dp-solution-with-o-n-and-o-m-n-space-complexity",
                "content": "```python\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # DP Solution\\n        if m == 1 or n == 1:\\n            return 1\\n        \\n        \\'\\'\\'\\n        # O(m*n) Space Complexity \\n        dp = [[1] * n for i in range(m)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]      \\n        return dp[m-1][n-1]\\n        \\'\\'\\'\\n        \\n        # O(n) Space Complexity \\n        dp = [1] * n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[j] += dp[j-1]\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # DP Solution\\n        if m == 1 or n == 1:\\n            return 1\\n        \\n        \\'\\'\\'\\n        # O(m*n) Space Complexity \\n        dp = [[1] * n for i in range(m)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]      \\n        return dp[m-1][n-1]\\n        \\'\\'\\'\\n        \\n        # O(n) Space Complexity \\n        dp = [1] * n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[j] += dp[j-1]\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23147,
                "title": "c-dp-o-n-2-time-o-n-space",
                "content": "The state transition equation is: `memo[i][j] = memo[i][j-1] + memo[i-1][j]`\\n                \\nFor example: A 3x4 grid, you need to reach bottom-right corner from top-left corner. \\n               \\nWe use memo[3][4] to save number of paths.\\n\\n    x x x x\\n    x x x x \\n    x x x x \\n\\nNumber of paths of first row is 1 1 1 1, because you can only go down and left, you only have one way to go to destination in row 0. So I init the row 0 with 1. \\n\\nAnd the second row, we only have one way to go to grid[1][0], is start->down->down.so memo[1][0] = 1. \\n\\nAnd for memo[1][1], you can go from grid[1][0] and grid[0][1], so memo[1][1] = memo[1][0]+memo[0][1], and the others are the similar. \\n\\nso the number of paths of 3x4 grid is: \\n\\n    1 1 1  1 \\n    1 2 3  4 \\n    1 3 6 10, and return memo[2][3].\\n\\nAnd take a closer look at the question, you can just use O(n) space, because when you calculate m[i][j], you need to add up m[i][j-1] and m[i-1][j]. \\n\\nIn my solution, m[i][j-1] is m[i-1],has been calculated just before m[i]j, and m[i-1][j] is old m[i] saved in m[i]. \\n\\nYou add up old m[i] and new m[i-1], the answer saves in m[i]. \\n\\nMy English is not so good, I hope this can answer you question.   \\n\\n       int uniquePaths(int m, int n) {\\n            int *memo = new int[n];\\n            for(int i = 0; i < n; i++)\\n                memo[i] = 1;\\n            for(int i = 1 ; i < m; i++)\\n                for(int j = 1; j < n; j++)\\n                    memo[j] += memo[j-1];\\n            return memo[n-1];\\n        }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The state transition equation is: `memo[i][j] = memo[i][j-1] + memo[i-1][j]`\\n                \\nFor example: A 3x4 grid, you need to reach bottom-right corner from top-left corner. \\n               \\nWe use memo[3][4] to save number of paths.\\n\\n    x x x x\\n    x x x x \\n    x x x x \\n\\nNumber of paths of first row is 1 1 1 1, because you can only go down and left, you only have one way to go to destination in row 0. So I init the row 0 with 1. \\n\\nAnd the second row, we only have one way to go to grid[1][0], is start->down->down.so memo[1][0] = 1. \\n\\nAnd for memo[1][1], you can go from grid[1][0] and grid[0][1], so memo[1][1] = memo[1][0]+memo[0][1], and the others are the similar. \\n\\nso the number of paths of 3x4 grid is: \\n\\n    1 1 1  1 \\n    1 2 3  4 \\n    1 3 6 10, and return memo[2][3].\\n\\nAnd take a closer look at the question, you can just use O(n) space, because when you calculate m[i][j], you need to add up m[i][j-1] and m[i-1][j]. \\n\\nIn my solution, m[i][j-1] is m[i-1],has been calculated just before m[i]j, and m[i-1][j] is old m[i] saved in m[i]. \\n\\nYou add up old m[i] and new m[i-1], the answer saves in m[i]. \\n\\nMy English is not so good, I hope this can answer you question.   \\n\\n       int uniquePaths(int m, int n) {\\n            int *memo = new int[n];\\n            for(int i = 0; i < n; i++)\\n                memo[i] = 1;\\n            for(int i = 1 ; i < m; i++)\\n                for(int j = 1; j < n; j++)\\n                    memo[j] += memo[j-1];\\n            return memo[n-1];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 23214,
                "title": "trickily-solve-the-problem-with-math-code-is-simple",
                "content": "This problem can be trickily solved with math, the principle is simple:\\n      In total the robot should walk m + n - 2 steps, m - 1 steps to right and n - 1 steps to bottom, so all what we should do is to select which m - 1 steps to be right, therefore the problem is actually a combination problem, then we just need to calculate  (n + m - 2)! / ((m - 1)!  * (n - 1)!), here is the code:\\n\\n    class Solution {\\n    public:\\n    long long fab(int x, int y) {\\n        long long ret = 1;\\n        for (int i = x; i >= y && i > 0; --i) {\\n            ret *=i;\\n        }\\n        return ret;\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        if (0 == m || 0 == n) {\\n            return 0;\\n        }\\n\\n        int max = std::max(m, n) - 1;\\n        int min = std::min(m, n) - 1;\\n\\n        int ret = int(fab(max + min, max + 1) / fab(min, 1));\\n\\n        return ret;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    long long fab(int x, int y) {\\n        long long ret = 1;\\n        for (int i = x; i >= y && i > 0; --i) {\\n            ret *=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3461624,
                "title": "c-and-c-the-fastest-solution-ever-explained",
                "content": "# Intuition:\\nThis formula is based on the fact that the robot must take exactly m-1 steps to the right and n-1 steps down to reach the bottom-right corner, for a total of m+n-2 steps. Therefore, the problem can be reduced to counting the number of ways to arrange m-1 right steps and n-1 down steps in a sequence of length m+n-2, which is equivalent to choosing (m-1) positions out of (m+n-2) to place the right steps, or equivalently (n-1) positions out of (m+n-2) to place the down steps.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![photo_2023-04-27_23-33-18.jpg](https://assets.leetcode.com/users/images/cfa6708a-a601-46f4-abdc-13985ae04393_1682620652.8100438.jpeg)\\n\\n```C++ []\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n, 1);\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n\\n```C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        long result = 1;\\n        for (int i = 1; i < m; i++) {\\n            result *= n + i - 1;\\n            result /= i;\\n        }\\n        return (int)result;\\n    }\\n}\\n```\\n# JavaScript\\n```\\nvar uniquePaths = function(m, n) {\\n     let result = 1;\\n        for (let i = 1; i < m; i++) {\\n            result *= n + i - 1;\\n            result /= i;\\n        }\\n        return result;\\n};\\n```\\n\\n![photo_2023-04-27_23-33-24.jpg](https://assets.leetcode.com/users/images/0304e462-6b47-4b47-87a8-8e05711c61ec_1682620656.2920358.jpeg)\\n![Vote.png](https://assets.leetcode.com/users/images/3bf051dc-1393-4cb0-a60f-91341aa2cb2a_1682620641.9265544.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Combinatorics"
                ],
                "code": "```C++ []\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n, 1);\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int UniquePaths(int m, int n) {\\n        long result = 1;\\n        for (int i = 1; i < m; i++) {\\n            result *= n + i - 1;\\n            result /= i;\\n        }\\n        return (int)result;\\n    }\\n}\\n```\n```\\nvar uniquePaths = function(m, n) {\\n     let result = 1;\\n        for (let i = 1; i < m; i++) {\\n            result *= n + i - 1;\\n            result /= i;\\n        }\\n        return result;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2974621,
                "title": "c-easy-to-understand-recursion-memoization-tabulation-space-optimization",
                "content": "**1. Recursion** \\n\\n```\\n    int solveRec(int row,int col,int m,int n){\\n        if(row>=m || col>=n) return 0;\\n        if(row==m-1 && col==n-1){\\n            return 1;\\n        }\\n        else{\\n            int right=solveRec(row+1,col,m,n);\\n            int down=solveRec(row,col+1,m,n);\\n            return right+down;\\n        }\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveRec(0,0,m,n);\\n    }\\n```\\n\\n**2. Memoization**\\n\\n```\\nint solveMem(int row,int col,int m,int n,vector<vector<int>>&dp){\\n        if(row>=m || col>=n) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        if(row==m-1 && col==n-1){\\n            return 1;\\n        }\\n        else{\\n            int right=solveMem(row+1,col,m,n,dp);\\n            int down=solveMem(row,col+1,m,n,dp);\\n            int ans=right+down;\\n            return dp[row][col]=ans;\\n        }\\n    }\\n\\tint uniquePaths(int m, int n) {\\n         vector<vector<int>>dp(m,vector<int>(n,-1));\\n         return solveMem(0,0,m,n,dp);\\n    }\\n```\\n\\n**3. Tabulation** \\n\\n```\\n int solveTab(int m,int n){\\n        vector<vector<int>>dp(m,vector<int>(n,1));\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveTab(m,n);\\n    }\\n\\n```\\n**4. Space Optimization**\\n\\n```\\nint solveSpaceOpt(int m,int n){\\n        vector<int> next(n,1);\\n        vector<int> curr(n,1);\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                curr[j]=next[j]+curr[j-1];\\n            }\\n            next=curr;\\n        }\\n        return next[n-1];\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveSpaceOpt(m,n);\\n    }\\n\\t\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\n    int solveRec(int row,int col,int m,int n){\\n        if(row>=m || col>=n) return 0;\\n        if(row==m-1 && col==n-1){\\n            return 1;\\n        }\\n        else{\\n            int right=solveRec(row+1,col,m,n);\\n            int down=solveRec(row,col+1,m,n);\\n            return right+down;\\n        }\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveRec(0,0,m,n);\\n    }\\n```\n```\\nint solveMem(int row,int col,int m,int n,vector<vector<int>>&dp){\\n        if(row>=m || col>=n) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        if(row==m-1 && col==n-1){\\n            return 1;\\n        }\\n        else{\\n            int right=solveMem(row+1,col,m,n,dp);\\n            int down=solveMem(row,col+1,m,n,dp);\\n            int ans=right+down;\\n            return dp[row][col]=ans;\\n        }\\n    }\\n\\tint uniquePaths(int m, int n) {\\n         vector<vector<int>>dp(m,vector<int>(n,-1));\\n         return solveMem(0,0,m,n,dp);\\n    }\\n```\n```\\n int solveTab(int m,int n){\\n        vector<vector<int>>dp(m,vector<int>(n,1));\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveTab(m,n);\\n    }\\n\\n```\n```\\nint solveSpaceOpt(int m,int n){\\n        vector<int> next(n,1);\\n        vector<int> curr(n,1);\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                curr[j]=next[j]+curr[j-1];\\n            }\\n            next=curr;\\n        }\\n        return next[n-1];\\n    }\\n\\tint uniquePaths(int m, int n) {\\n        return solveSpaceOpt(m,n);\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23154,
                "title": "6-lines-java-0ms-solution",
                "content": "    public int uniquePaths(int m, int n) {\\n        int[] dp = new int[m];\\n        dp[0] = 1;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < m; j++)\\n                dp[j] = dp[j-1] + dp[j];\\n        return dp[m-1];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int uniquePaths(int m, int n) {\\n        int[] dp = new int[m];\\n        dp[0] = 1;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < m; j++)\\n                dp[j] = dp[j-1] + dp[j];\\n        return dp[m-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23170,
                "title": "python-solution-using-dp-40ms",
                "content": "    class Solution(object):\\n        def uniquePaths(self, m, n):\\n            \"\"\"\\n            :type m: int\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            if m == 1 or n == 1:\\n                return 1\\n            \\n            #have a list of lists to represent the grid, initilized with 0's\\n            diffPaths = [[0]*n]*m\\n            \\n            #fill row 0 and column 0 with all 1's, only one way to get to all those squares\\n            for col in range(n):\\n                diffPaths[0][col] = 1\\n            \\n            for row in range(m):\\n                diffPaths[row][0] = 1\\n            \\n            #starting at grid[1][1], go through each gridspace and enter in the amount of unique paths to that square\\n            #unique paths for a certain square are found by adding the amount of unique paths from each of the squares to its top and its left\\n            for row in range(1, m):\\n                for col in range(1, n):\\n                    diffPaths[row][col] = diffPaths[row-1][col] + diffPaths[row][col-1]\\n            \\n            #bottom rightmost square will now contain the total amount of unique paths to there\\n            return diffPaths[m-1][n-1]",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def uniquePaths(self, m, n):\\n            \"\"\"\\n            :type m: int\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            if m == 1 or n == 1:\\n                return 1\\n            \\n            #have a list of lists to represent the grid, initilized with 0's\\n            diffPaths = [[0]*n]*m\\n            \\n            #fill row 0 and column 0 with all 1's, only one way to get to all those squares\\n            for col in range(n):\\n                diffPaths[0][col] = 1\\n            \\n            for row in range(m):\\n                diffPaths[row][0] = 1\\n            \\n            #starting at grid[1][1], go through each gridspace and enter in the amount of unique paths to that square\\n            #unique paths for a certain square are found by adding the amount of unique paths from each of the squares to its top and its left\\n            for row in range(1, m):\\n                for col in range(1, n):\\n                    diffPaths[row][col] = diffPaths[row-1][col] + diffPaths[row][col-1]\\n            \\n            #bottom rightmost square will now contain the total amount of unique paths to there\\n            return diffPaths[m-1][n-1]",
                "codeTag": "Java"
            },
            {
                "id": 23200,
                "title": "python-recursive-solution-with-cache",
                "content": "    class Solution:\\n        # @param {integer} m\\n        # @param {integer} n\\n        # @return {integer}\\n        def uniquePaths(self, m, n):\\n            cache = {}\\n            return self.findPath(m, n, cache)\\n    \\n        def findPath(self, m, n, cache):\\n            if (m, n) in cache:\\n                return cache[(m, n)]\\n            elif m == 1 or n == 1:\\n                return 1\\n    \\n            cache[(m, n)] = self.findPath(m - 1, n, cache) + self.findPath(m, n - 1, cache)\\n    \\n            return cache[(m, n)]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 23139,
                "title": "solve-unique-paths-with-linear-algorithm",
                "content": "1. The formula : C(n + m - 2, n - 1)  \\n    Overflow is the problem. Would you do it with this formula? Thanks.\\n\\n2. Using DP  Time Complexity is O(m * n)  Space Complexity is O(min(m, n))\\n\\n        class Solution {\\n        public:\\n            int uniquePaths(int m, int n) {\\n                // IMPORTANT: Please reset any member data you declared, as\\n                // the same Solution instance will be reused for each test case.\\n                if((m <= 0) || (n <= 0)) return 0;\\n                if((1 == m) || (1 == n)) return 1;\\n                int map[n + 1];\\n                memset(map, 0, sizeof(map));\\n                for(int i = 1; i <= n; i ++) map[i] = 1;\\n                for(int i = 2; i <= m; i ++) {\\n                    for(int j = 2; j <= n; j ++) {\\n                        map[j] += map[j - 1];\\n                    }\\n                }\\n                return map[n];\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int uniquePaths(int m, int n) {\\n                // IMPORTANT: Please reset any member data you declared, as\\n                // the same Solution instance will be reused for each test case.\\n                if((m <= 0) || (n <= 0)) return 0;\\n                if((1 == m) || (1 == n)) return 1;\\n                int map[n + 1];\\n                memset(map, 0, sizeof(map));\\n                for(int i = 1; i <= n; i ++) map[i] = 1;\\n                for(int i = 2; i <= m; i ++) {\\n                    for(int j = 2; j <= n; j ++) {\\n                        map[j] += map[j - 1];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3995244,
                "title": "c-dp-iterative",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        swap(n,m);\\n        vector<vector<int>>dp(n,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/dacfbe5e-516f-4457-9ceb-54582996237d_1693716740.5145779.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        swap(n,m);\\n        vector<vector<int>>dp(n,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365888,
                "title": "python-simple-python-solution-using-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n\\n# Approach 1 Using Recursion : -\\n\\n# Runtime: 49 ms, faster than 52.07% of Python3 online submissions for Unique Paths.\\n# Memory Usage: 14.1 MB, less than 14.98% of Python3 online submissions for Unique Paths.\\n\\tclass Solution:\\n\\t\\tdef uniquePaths(self, m: int, n: int) -> int:\\n\\n\\t\\t\\tresult = {}\\n\\n\\t\\t\\tdef All_Path(row, col):\\n\\n\\t\\t\\t\\tif row == 0 or col == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\telif (row , col ) not in result:\\n\\n\\t\\t\\t\\t\\tresult[(row , col)] = All_Path(row - 1, col) + All_Path(row, col - 1)\\n\\n\\t\\t\\t\\treturn result[(row , col )]\\n\\n\\t\\t\\treturn All_Path(m - 1, n - 1)\\n\\n# Approach 2 Using Dynamic Programming : -\\n# Runtime: 36 ms, faster than 71.76% of Python3 online submissions for Unique Paths.\\n# Memory Usage: 13.8 MB, less than 72.18% of Python3 online submissions for Unique Paths.\\n\\n\\tclass Solution:\\n\\t\\tdef uniquePaths(self, m: int, n: int) -> int:\\n\\n\\t\\t\\tdp = [[1 for _ in range(n)] for _ in range(m)]\\n\\n\\t\\t\\tfor i in range(1, m):\\n\\t\\t\\t\\tfor j in range(1, n):\\n\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n\\n\\t\\t\\treturn dp[m-1][n-1]\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution:\\n\\t\\tdef uniquePaths(self, m: int, n: int) -> int:\\n\\n\\t\\t\\tresult = {}",
                "codeTag": "Java"
            },
            {
                "id": 1328799,
                "title": "c-brute-to-optimal-3-approaches",
                "content": "**1. RECURSION**\\n```\\nclass Solution {\\npublic:\\n    \\n    int paths(int m, int n, int i, int j){\\n        if((i>=m) || (j>=n)){ return 0; }\\n        if((i==m-1 && j==n-1)) return 1;\\n        else return (paths(m, n, i+1, j) + paths(m, n, i, j+1));\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        return paths(m, n, 0, 0);\\n    }\\n};\\n```\\n\\n**2. DYNAMIC PROGRAMMING**\\n```\\nclass Solution {\\npublic:\\n    \\n    int paths(int m, int n, int i, int j, vector<vector<int>> &dp){\\n        if((i>=m) || (j>=n)){ return 0; }\\n        if((i==m-1 && j==n-1)) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        else return  dp[i][j] = (paths(m, n, i+1, j, dp) + paths(m, n, i, j+1, dp));\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m+1, vector<int>(n+1, -1));\\n        return paths(m, n, 0, 0, dp);\\n    }\\n};\\n```\\n\\n**3. COMBINATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N = n+m-2;\\n        int r = m-1;\\n        double res = 1;\\n        \\n        for(int i=1; i<=r; i++){\\n            res = res * ( N - r + i) / i;\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int paths(int m, int n, int i, int j){\\n        if((i>=m) || (j>=n)){ return 0; }\\n        if((i==m-1 && j==n-1)) return 1;\\n        else return (paths(m, n, i+1, j) + paths(m, n, i, j+1));\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        return paths(m, n, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int paths(int m, int n, int i, int j, vector<vector<int>> &dp){\\n        if((i>=m) || (j>=n)){ return 0; }\\n        if((i==m-1 && j==n-1)) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        else return  dp[i][j] = (paths(m, n, i+1, j, dp) + paths(m, n, i, j+1, dp));\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m+1, vector<int>(n+1, -1));\\n        return paths(m, n, 0, 0, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N = n+m-2;\\n        int r = m-1;\\n        double res = 1;\\n        \\n        for(int i=1; i<=r; i++){\\n            res = res * ( N - r + i) / i;\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301553,
                "title": "python-2d-intuitive-dp-solution-96-36",
                "content": "```\\ndef uniquePaths(self, m: int, n: int) -> int:\\n\\ttriangle = [[1] * n] # figure 1\\n\\tfor i in range(1, m):\\n\\t\\trow = list()\\n\\t\\trow.append(1) # figure 2\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\trow.append(row[j-1] + triangle[i-1][j]) # figure 3\\n\\t\\ttriangle.append(row)\\n\\treturn triangle[m-1][n-1]```\\n```\\nOther posts talk about Pascal\\'s triangle and binomial coefficients, but they don\\'t exactly explain what makes the solution work.\\n\\nIn this solution, we construct a 2D array, ```triangle```, where ```triangle[row][col]]``` retrieves the number of unique steps to go to ```row, col``` with only 2 types of moves: right and down.\\n\\nWe build this 2D array by starting with our top row, an array filled with ones. Trivially, we can move to any spot in this array from the top-left corner with one move.\\n\\n![image](https://assets.leetcode.com/users/images/8c89c661-6a70-4a81-afe9-13817f5d00f8_1624831359.9246347.png)\\n\\nTo expand on the 2D array, we create new arrays to serve as additional rows below, with the first value as 0 because we can move down in one move (i.e. ```triangle[row][0] = 1```, or as shown in the code, ```row.append(1)```).\\n\\n![image](https://assets.leetcode.com/users/images/e1db0708-b47d-46b2-a691-f96566298ede_1624831580.4956439.png)\\n\\nThe final logical step that builds the remainder of the solution is for each tile ```row, col``` to be equal to the sum of the unique moves in the squares above and to the left. In the code, this represents itself as ```row.append(row[j-1] + triangle[i-1][j])```. This is dynamic programming because it builds on the previous solutions ```row[j-1] and triangle[i-1][j]```.\\n\\nThe image below shows a visualization of how the code finds the solution to the first example test case.\\n![image](https://assets.leetcode.com/users/images/ba04201d-8c41-4f5c-b338-194839ea16f4_1624832023.493262.png)\\n\\nIs this the most efficient solution? No, it uses ```O(m * n)``` space and time, but it\\'s very straight-forward and it serves as a good way to visualize this problem and other DP-type problems.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef uniquePaths(self, m: int, n: int) -> int:\\n\\ttriangle = [[1] * n] # figure 1\\n\\tfor i in range(1, m):\\n\\t\\trow = list()\\n\\t\\trow.append(1) # figure 2\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\trow.append(row[j-1] + triangle[i-1][j]) # figure 3\\n\\t\\ttriangle.append(row)\\n\\treturn triangle[m-1][n-1]```\n```\\nOther posts talk about Pascal\\'s triangle and binomial coefficients, but they don\\'t exactly explain what makes the solution work.\\n\\nIn this solution, we construct a 2D array, ```\n```, where ```\n``` retrieves the number of unique steps to go to ```\n``` with only 2 types of moves: right and down.\\n\\nWe build this 2D array by starting with our top row, an array filled with ones. Trivially, we can move to any spot in this array from the top-left corner with one move.\\n\\n![image](https://assets.leetcode.com/users/images/8c89c661-6a70-4a81-afe9-13817f5d00f8_1624831359.9246347.png)\\n\\nTo expand on the 2D array, we create new arrays to serve as additional rows below, with the first value as 0 because we can move down in one move (i.e. ```\n```, or as shown in the code, ```\n```).\\n\\n![image](https://assets.leetcode.com/users/images/e1db0708-b47d-46b2-a691-f96566298ede_1624831580.4956439.png)\\n\\nThe final logical step that builds the remainder of the solution is for each tile ```\n``` to be equal to the sum of the unique moves in the squares above and to the left. In the code, this represents itself as ```\n```. This is dynamic programming because it builds on the previous solutions ```\n```.\\n\\nThe image below shows a visualization of how the code finds the solution to the first example test case.\\n![image](https://assets.leetcode.com/users/images/ba04201d-8c41-4f5c-b338-194839ea16f4_1624832023.493262.png)\\n\\nIs this the most efficient solution? No, it uses ```",
                "codeTag": "Python3"
            },
            {
                "id": 323514,
                "title": "two-python-solutions-with-explanation",
                "content": "Observe that for a `m` by `n` grid, robot will always make `(m-1)` moves to the right, and `(n-1)` moves down for a total of `(m+n-2)` moves. The number of possible paths the robot can take is then the binomial coefficient `B(m+n-2,m-1) = factorial(m+n-2)/(factorial(m-1)*factorial(n-1))`\\n\\n**Solution 1 **(definition of binomial coefficient):\\n```\\nfrom math import factorial as fact\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return fact(m+n-2)/(fact(m-1)*fact(n-1))\\n```\\n\\n**Solution 2 ** (Dynamic Programming)\\nThe recurrance relation between the number of moves at grid `(i,j)` and previous grids is `dp[i-1][j] + dp[i][j-1]` and a dp matrix is created to memoize the moves at each `(i,j)`.\\n\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1]*m for _ in range(n)]\\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom math import factorial as fact\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return fact(m+n-2)/(fact(m-1)*fact(n-1))\\n```\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1]*m for _ in range(n)]\\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 267270,
                "title": "dp-javascript-solution",
                "content": "Use a Javascript syntactic suger to initialize list.\\nI don\\'t know if this initialization is efficient or not.\\n\\n``` javascript\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    const res = [];\\n    for (let i = 0; i < n; i++) res.push([...new Array(m).fill(1)]); // initialize list\\n    for (let i = 1; i < n; i++) {\\n        for (let j = 1; j < m; j++) {\\n            res[i][j] = res[i-1][j] + res[i][j-1];\\n        }\\n    }\\n    return res[n-1][m-1];\\n};\\n```",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    const res = [];\\n    for (let i = 0; i < n; i++) res.push([...new Array(m).fill(1)]); // initialize list\\n    for (let i = 1; i < n; i++) {\\n        for (let j = 1; j < m; j++) {\\n            res[i][j] = res[i-1][j] + res[i][j-1];\\n        }\\n    }\\n    return res[n-1][m-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996246,
                "title": "python-bottom-up-dynamic-programming",
                "content": "# Python | Bottom-Up Dynamic Programming \\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = dp[r-1][c] + dp[r][c-1]\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = dp[r-1][c] + dp[r][c-1]\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324014,
                "title": "java-solution-dynamic-programming-beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first intuition after seeing the problem was to use DFS to search all the possible paths and count them.\\nThis is the recursive bruteforce approach.\\nLater I realized that many repetitive subproblems are calculated and it was way beyond the limited time complexity.\\nSo I have applied Dynamic Programming to solve this.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLets consider an 2d `grid` of length `m x n` where each cell represents total number of unique paths that are possible.\\n\\nBy the problem description we can conclude that the unique paths from a particular cell will be the sum of unique paths of its `right` and `down` cells.\\nFor ex :-\\n```\\ngrid[r][c] = grid[r+1][c] + grid[r][c+1]\\n```\\n**So, we can use bottom-up approach of Dynamic Programming to solve this problem.**\\n\\nNow,\\nInitially the last target position `grid[m-1][n-1]` has value `1` as one path.\\nNow we traverse through the last `cell` until `grid[0][0]` and calculate paths of each cell.\\nIn the end, total paths from starting position `0,0` will be `dp[0][0]`.\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we traverse through the 2d array of `m x n`.\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we created an 2d array of `m x n`.\\n# Code\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        grid[m-1][n-1] = 1;\\n        for(int r = m-1; r >= 0; r--){\\n            for(int c = n-1; c >= 0; c--){\\n                if(r+1 < m){\\n                    grid[r][c] += grid[r+1][c];\\n                }\\n                if(c+1 < n){\\n                    grid[r][c] += grid[r][c+1];\\n                }\\n            }\\n        }\\n        return grid[0][0];\\n    }\\n}\\n```\\n*Hope You Understand the Approach !!*\\n\\n**Please Do Upvote :)**\\n\\n*Thank You !!*",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\ngrid[r][c] = grid[r+1][c] + grid[r][c+1]\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int grid[][] = new int[m][n];\\n        grid[m-1][n-1] = 1;\\n        for(int r = m-1; r >= 0; r--){\\n            for(int c = n-1; c >= 0; c--){\\n                if(r+1 < m){\\n                    grid[r][c] += grid[r+1][c];\\n                }\\n                if(c+1 < n){\\n                    grid[r][c] += grid[r][c+1];\\n                }\\n            }\\n        }\\n        return grid[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361997,
                "title": "daily-leetcoding-challenge-august-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 2:** Math (Python3 only)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1180400,
                "title": "c-simplest-5-line-dynamic-programming-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896149,
                "title": "javascript-dp-solution",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    // big idea: the number of ways to reach a cell c[i][j]\\n    // is equal to the number of ways to reach the cell above c[i-1][j]\\n    // plus the number of ways to make the cell left c[i][j-i], because you\\n    // can only reach c[i][j] via either of those two cells\\n\\t\\n    if(m === 0 || n === 0) return 0;\\n    if(m === 1 || n === 1) return 1;\\n    \\n    // initialise DP with base cases\\n    const dp = Array(m ).fill(\\n        Array(n).fill(1)\\n    );\\n    \\n    for(let i = 1; i < m; i++) {\\n        for(let j = 1; j < n; j++) {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        }\\n    }\\n    \\n    // return value for bottom right\\n    return dp[m-1][n-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function(m, n) {\\n    // big idea: the number of ways to reach a cell c[i][j]\\n    // is equal to the number of ways to reach the cell above c[i-1][j]\\n    // plus the number of ways to make the cell left c[i][j-i], because you\\n    // can only reach c[i][j] via either of those two cells\\n\\t\\n    if(m === 0 || n === 0) return 0;\\n    if(m === 1 || n === 1) return 1;\\n    \\n    // initialise DP with base cases\\n    const dp = Array(m ).fill(\\n        Array(n).fill(1)\\n    );\\n    \\n    for(let i = 1; i < m; i++) {\\n        for(let j = 1; j < n; j++) {\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        }\\n    }\\n    \\n    // return value for bottom right\\n    return dp[m-1][n-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871688,
                "title": "detail-explanation-using-combination-0-ms-and-100-faster",
                "content": "\\n\\n  ## Combination Program : Explanation has been given at end ##\\n   \\n    private int countUniquePathWithNCR ( int m, int n ) {      \\n    int N = m+n-2;       \\n    int r = m-1;        \\n    double ans = 1;   //Initialize it with 1 as we need to multiply the obtained result while\\n\\t//calculation    \\n\\t//Logic of loop. To understand it, take an specific example of 10c3.\\n\\t//Numerator will be 10*9*8*!7\\n\\t//Denominator !3 * !7\\n\\t//After solving you will have numeraor =10*9*8\\n\\t//and denominator =!3=3*2*1\\n\\t//Now, adjust them in a loop. the first factor in the numerator will be 8 and it can be calculated as follows 10-3+1 [Where N=10, r=3 and i=1]\\n\\t//Denominator = 1 [where i=1 ]\\n\\t//If the loop start with i=1 and goes to i=3, we will start getting the result as follows\\n\\t// 8/1, 9/2, 10/3\\n\\t//ans=ans*(N-r+i)/i  ; will give the final result.\\n\\t\\n    for ( int j=1; j<=r;  j++) {\\n        ans =  ans * ( N-r+j ) / j ;            \\n    }\\n    return ( int ) ans;  \\n}\\n\\n## Explanation ##\\n     The Recursive solution was taking more time in its execution, whereas Recursive with \\n\\t DP was a good way to solve it. But, it can also be solved by using permutation \\n\\t and combination approach.\\n\\n     If you start oberving the solution of the problem with a small matrix of size 2*3, you\\n\\t could notice that the no. of cells you visit in each unique path remains fixed . \\n\\t In case of 2*3 matrix ,the possible paths are as follows. \\n\\n    RRD, RDR, DRR \\n\\t\\n\\t**Remark**: Each R and D have different co-ordinates. Don\\'t get confused with similar \\n\\ttwo Rs. they are infact with differnt co-ordinates.\\n\\t\\n    We also notice here that we need 2 R-movements [steps] and 1- down \\n\\tmovement [step] in each path.\\n\\t\\n    Now, try to find out a relationship between total step-counts and the given matrix size.\\n\\t\\n\\tYou could notice that (m-1) + ( n-1) which is (3-1)+(2-1)  i.e.   3. Which is the no. of \\n\\ttotal step-counts.\\n\\t\\n\\tSecond thing that you can notice is the no. of right and down movements [steps] in \\n\\teach unique path which also remains constant. i.e.  Two R-movement [step] and one \\n\\tD-movement [step] are available in each path.\\n\\t\\n\\tNow, again try to find out a relationship between the no. of R-movement [step] \\n\\tand the no. of D-movement [step] with the given matrix size.\\n\\t\\n\\tYou could notice that if \"m\" denotes the right movement [step] direction, then \\n\\tthe total no. of right movement [step] is m-1 which is 3-1 i.e. 2. Which are R and  R.\\n\\t\\n\\tYou could also notice that if \"n\" denotes the down movement [step] direction, \\n\\tthen the total no. of down movement [step] is n-1 which is 2-1 i.e. 1. Which is D.\\n\\t\\n\\tSo, finally you have reached at a conclusion that there is a relationship between \\n\\tour two observations and matrix size\\n\\t\\n\\tFirst one is total steps counts = 3 [ (m-1)+(n-1) ]\\n\\t\\n\\tTotal Right movement count in each path = 2 [m-1]\\n\\tTotal Down movement count in each path = 1 [n-1]\\n\\t\\n    Now, we can think of having 3 places  to fill with 2 items[2 R] and one place with \\n\\tone item[1 D].\\n\\t\\n\\t# # #  [ \\'# \\' dentoees 3 places ]\\t\\n\\t3C2 * 1C1 \\n\\t\\n\\tOR\\n\\t\\n\\t Now, we can think of having 3 places  to fill with 1 item[1 D] and the rest two places with \\n\\ttwo items [2 R].\\n\\t\\n\\t# # #  [ \\'# \\' dentoees 3 places ]\\t\\t\\n\\t3C1 * 2C2\\n\\t\\t\\n\\tYou can approach either way to calculate the total possible combination which results \\n\\tas 3.  One more thing that you can notice here is that both 1C1 and 2C2 will give you 1 as\\n\\ta result. So, we can discard it and we can directly use either 3C2 or 3C1 .\\n\\t\\n\\tNow, translate the final result in NcR formula.\\n\\tLet N= (m-1) + (n-1)=m+n-2\\n\\tLet r= m-1 or n-1\\n\\tCalculate NcR in the program and it will be the total no. of nique paths.\\t\\n   \\n   \\n",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "\\n\\n  ## Combination Program : Explanation has been given at end ##\\n   \\n    private int countUniquePathWithNCR ( int m, int n ) {      \\n    int N = m+n-2;       \\n    int r = m-1;        \\n    double ans = 1;   //Initialize it with 1 as we need to multiply the obtained result while\\n\\t//calculation    \\n\\t//Logic of loop. To understand it, take an specific example of 10c3.\\n\\t//Numerator will be 10*9*8*!7\\n\\t//Denominator !3 * !7\\n\\t//After solving you will have numeraor =10*9*8\\n\\t//and denominator =!3=3*2*1\\n\\t//Now, adjust them in a loop. the first factor in the numerator will be 8 and it can be calculated as follows 10-3+1 [Where N=10, r=3 and i=1]\\n\\t//Denominator = 1 [where i=1 ]\\n\\t//If the loop start with i=1 and goes to i=3, we will start getting the result as follows\\n\\t// 8/1, 9/2, 10/3\\n\\t//ans=ans*(N-r+i)/i  ; will give the final result.\\n\\t\\n    for ( int j=1; j<=r;  j++) {\\n        ans =  ans * ( N-r+j ) / j ;            \\n    }\\n    return ( int ) ans;  \\n}\\n\\n## Explanation ##\\n     The Recursive solution was taking more time in its execution, whereas Recursive with \\n\\t DP was a good way to solve it. But, it can also be solved by using permutation \\n\\t and combination approach.\\n\\n     If you start oberving the solution of the problem with a small matrix of size 2*3, you\\n\\t could notice that the no. of cells you visit in each unique path remains fixed . \\n\\t In case of 2*3 matrix ,the possible paths are as follows. \\n\\n    RRD, RDR, DRR \\n\\t\\n\\t**Remark**: Each R and D have different co-ordinates. Don\\'t get confused with similar \\n\\ttwo Rs. they are infact with differnt co-ordinates.\\n\\t\\n    We also notice here that we need 2 R-movements [steps] and 1- down \\n\\tmovement [step] in each path.\\n\\t\\n    Now, try to find out a relationship between total step-counts and the given matrix size.\\n\\t\\n\\tYou could notice that (m-1) + ( n-1) which is (3-1)+(2-1)  i.e.   3. Which is the no. of \\n\\ttotal step-counts.\\n\\t\\n\\tSecond thing that you can notice is the no. of right and down movements [steps] in \\n\\teach unique path which also remains constant. i.e.  Two R-movement [step] and one \\n\\tD-movement [step] are available in each path.\\n\\t\\n\\tNow, again try to find out a relationship between the no. of R-movement [step] \\n\\tand the no. of D-movement [step] with the given matrix size.\\n\\t\\n\\tYou could notice that if \"m\" denotes the right movement [step] direction, then \\n\\tthe total no. of right movement [step] is m-1 which is 3-1 i.e. 2. Which are R and  R.\\n\\t\\n\\tYou could also notice that if \"n\" denotes the down movement [step] direction, \\n\\tthen the total no. of down movement [step] is n-1 which is 2-1 i.e. 1. Which is D.\\n\\t\\n\\tSo, finally you have reached at a conclusion that there is a relationship between \\n\\tour two observations and matrix size\\n\\t\\n\\tFirst one is total steps counts = 3 [ (m-1)+(n-1) ]\\n\\t\\n\\tTotal Right movement count in each path = 2 [m-1]\\n\\tTotal Down movement count in each path = 1 [n-1]\\n\\t\\n    Now, we can think of having 3 places  to fill with 2 items[2 R] and one place with \\n\\tone item[1 D].\\n\\t\\n\\t# # #  [ \\'# \\' dentoees 3 places ]\\t\\n\\t3C2 * 1C1 \\n\\t\\n\\tOR\\n\\t\\n\\t Now, we can think of having 3 places  to fill with 1 item[1 D] and the rest two places with \\n\\ttwo items [2 R].\\n\\t\\n\\t# # #  [ \\'# \\' dentoees 3 places ]\\t\\t\\n\\t3C1 * 2C2\\n\\t\\t\\n\\tYou can approach either way to calculate the total possible combination which results \\n\\tas 3.  One more thing that you can notice here is that both 1C1 and 2C2 will give you 1 as\\n\\ta result. So, we can discard it and we can directly use either 3C2 or 3C1 .\\n\\t\\n\\tNow, translate the final result in NcR formula.\\n\\tLet N= (m-1) + (n-1)=m+n-2\\n\\tLet r= m-1 or n-1\\n\\tCalculate NcR in the program and it will be the total no. of nique paths.\\t\\n   \\n   \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 23180,
                "title": "with-explanation-simplest-method-based-on-a-little-bit-math-knowledge-no-dp-or-any-programming-trick-needed",
                "content": "When the grid is m*n, Robot on top left need to move right m-1 times and down n-1 times to get to Finish Spot in total, since it doesn't know to go left or up. Nothing more, nothing less.  \\n\\nSo the problem now is \"how many possible combination of m-1 right moves and n-1 down moves\", obviously it is C(m+n-2, m-1), aka  \\\\frac{(m+n-2)!}{(m-1)!(n-1)!}, which is shown by the code below.\\n\\n    class Solution:\\n        def c(self,n,k):\\n            r = 1\\n            for i in range(n,n-k,-1):\\n                r *= i\\n            for i in range(1,k+1):\\n                r /= i\\n            return r\\n            \\n        def uniquePaths(self, m, n):\\n            return self.c(m+n-2,m-1)",
                "solutionTags": [],
                "code": "When the grid is m*n, Robot on top left need to move right m-1 times and down n-1 times to get to Finish Spot in total, since it doesn't know to go left or up. Nothing more, nothing less.  \\n\\nSo the problem now is \"how many possible combination of m-1 right moves and n-1 down moves\", obviously it is C(m+n-2, m-1), aka  \\\\frac{(m+n-2)!}{(m-1)!(n-1)!}, which is shown by the code below.\\n\\n    class Solution:\\n        def c(self,n,k):\\n            r = 1\\n            for i in range(n,n-k,-1):\\n                r *= i\\n            for i in range(1,k+1):\\n                r /= i\\n            return r\\n            \\n        def uniquePaths(self, m, n):\\n            return self.c(m+n-2,m-1)",
                "codeTag": "Java"
            },
            {
                "id": 3994790,
                "title": "putta-easy-solution-c-beats-100-recursive-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int paths(int i,int j,int m,int n,vector< vector<int>>& dp){\\n        if (i >= m || j>= n){\\n            return 0;\\n        }\\n        if (i == m-1 && j == n-1)\\n            return 1;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = paths(i+1,j,m,n,dp)+paths(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector< vector<int>> dp(m,vector<int>(n,-1));\\n        return paths(0,0,m,n,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paths(int i,int j,int m,int n,vector< vector<int>>& dp){\\n        if (i >= m || j>= n){\\n            return 0;\\n        }\\n        if (i == m-1 && j == n-1)\\n            return 1;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = paths(i+1,j,m,n,dp)+paths(i,j+1,m,n,dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector< vector<int>> dp(m,vector<int>(n,-1));\\n        return paths(0,0,m,n,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994527,
                "title": "c-python-math-pascal-triangle-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe codes calculate the number of unique paths in a grid from the top-left corner to the bottom-right corner. To do this, it uses the concept of combinations to determine the total number of ways to choose a certain number of downward steps (represented by \\'V\\') and rightward steps (represented by \\'>\\').\\n\\n[Please turn on English subtitles if necessary]\\n[https://youtu.be/sgRvG0rhWGI?si=N7nEiMEw70QCsnLx](https://youtu.be/sgRvG0rhWGI?si=N7nEiMEw70QCsnLx)\\n\\n\\nIn the grid, there are exactly (m + n - 2) steps to move in total. Out of these steps, (m - 1) are downward steps and (n - 1) are rightward steps. This can be converted into a combination problem where we need to find the combination number for permutations of (m - 1) downward steps and (n - 1) rightward steps.\\n\\nIn Python, the combination number can be directly calculated using the formula \\n$$C(N, K) = \\\\frac{(N)(N-1)\\\\cdots (N-K+1)}{K!},$$ \\nwhere $N=m + n - 2$ represents the total number of steps and $K=\\\\min(n-1, m-1)$ the mininum for the numbers for downward steps and rightward steps. This formula simplifies the computation.\\n\\nHowever, in C++, the direct computation of the combination number may exceed the limits of even the signed long long data type. Therefore, the code employs an iterative approach inspired by Pascal\\'s Triangle, which is a form of dynamic programming. By iteratively calculating the combinations, it avoids the need for large integer computations and efficiently determines the number of unique paths.\\n\\nBy understanding this concept and leveraging dynamic programming techniques, the code effectively solves the problem of finding the number of unique paths in the grid.\\n\\nSo use the idea in Leetcode 118. Pascal\\'s Triangle, which is in fact the iterative way for dynamic programming, then done!\\n[https://youtu.be/paoJGMYEEhA](https://youtu.be/paoJGMYEEhA)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Python 1 line just comb(m+n-2, m-1)\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:        \\n        return comb(m+n-2, m-1)\\n```\\n# Python Code\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if n == 1: \\n            return 1\\n        N = n + m - 2\\n        K = min(n - 1, m - 1)\\n        C=1\\n        for i in range(N,N-K, -1):\\n            C*=i\\n        for i in range(1, K+1):\\n            C//=i       \\n        return C\\n```\\n# C++ solution uses recursion from Pascal\\'s Triangle with Memoziation\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> C;\\n    long long comb(int i, int j){\\n        if (C[i][j]!=-1) return C[i][j];\\n        if (j==0 || j==i ) return C[i][j]=1LL;\\n        return C[i][j]=comb(i-1, j)+comb(i-1, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        C.assign(N+1, vector(K+1, -1LL));\\n        return comb(N, K);\\n    }\\n};\\n```\\n# DP solution using recursion dp(i,j)=dp(i-1, j)+dp(i, j-1) beats also 100% can compare with comb(i+j, j)=dp[i][j] in Pascal\\'s triangle\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    long long f(int i, int j){\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        if (i==0 || j==0 ) return dp[i][j]=1LL;\\n        return dp[i][j]=f(i-1, j)+f(i, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        dp.assign(m+1, vector(n+1, -1LL));\\n        return f(m-1, n-1);\\n    }\\n};\\n```\\n# C++ code using Pascal\\'s triangle beats 100%\\nBoth of SC & iterations are optimized\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        vector<int> prev, C_N;\\n        prev.assign(K + 1, 1); // C(0,0)=1\\n        for (int i = 1; i <= K; i++) {\\n            C_N.assign(i + 1, 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C_N[j] = C_N[i - j] = prev[j] + prev[j - 1];\\n            }\\n            prev = C_N;\\n        }\\n        for (int i = K + 1; i <= N - K; i++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = 1; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        for (int i = N - K + 1, j0 = 1; i <= N; i++, j0++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = j0; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        return C_N[K];\\n    }\\n};\\n\\n```\\n# C++ code using C(N, K)=C(N-1, K-1)*N/K which is also applied for solving hard problem [2842. Count K-Subsequences of a String With Maximum Beauty](https://leetcode.com/problems/count-k-subsequences-of-a-string-with-maximum-beauty/solutions/3995805/c-math-beats-100/)\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        unsigned long long C=1LL;\\n        for (unsigned i=1; i<=K; i++) \\n            C=C*(N-K+i)/i;            \\n        return C;\\n    }\\n};\\n\\n\\n```\\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:        \\n        return comb(m+n-2, m-1)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if n == 1: \\n            return 1\\n        N = n + m - 2\\n        K = min(n - 1, m - 1)\\n        C=1\\n        for i in range(N,N-K, -1):\\n            C*=i\\n        for i in range(1, K+1):\\n            C//=i       \\n        return C\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> C;\\n    long long comb(int i, int j){\\n        if (C[i][j]!=-1) return C[i][j];\\n        if (j==0 || j==i ) return C[i][j]=1LL;\\n        return C[i][j]=comb(i-1, j)+comb(i-1, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        C.assign(N+1, vector(K+1, -1LL));\\n        return comb(N, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    long long f(int i, int j){\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        if (i==0 || j==0 ) return dp[i][j]=1LL;\\n        return dp[i][j]=f(i-1, j)+f(i, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        dp.assign(m+1, vector(n+1, -1LL));\\n        return f(m-1, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        vector<int> prev, C_N;\\n        prev.assign(K + 1, 1); // C(0,0)=1\\n        for (int i = 1; i <= K; i++) {\\n            C_N.assign(i + 1, 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C_N[j] = C_N[i - j] = prev[j] + prev[j - 1];\\n            }\\n            prev = C_N;\\n        }\\n        for (int i = K + 1; i <= N - K; i++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = 1; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        for (int i = N - K + 1, j0 = 1; i <= N; i++, j0++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = j0; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        return C_N[K];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        unsigned long long C=1LL;\\n        for (unsigned i=1; i<=K; i++) \\n            C=C*(N-K+i)/i;            \\n        return C;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999834,
                "title": "python-3-solutions-video-solution",
                "content": "I have explained this [here](https://youtu.be/Q6rwr41Hml8).\\n\\nIf you found this useful, please upvote, like the video & subscribe to the channel.\\n\\nCheers.\\n\\n# Time Compexity\\n\\n![image](https://assets.leetcode.com/users/images/1796bdb8-5c47-421b-9c85-f11c2eb7ca27_1672861197.1021965.png)\\n\\n\\n# Maths - Combinations\\nThis is the same as chosing **m-1** down moves from **m+n-2** total moves.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        return math.comb(m+n-2, m-1)\\n```\\n\\n# Memoization (Top-Down)\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n                \\n        @cache\\n        def dfs(i,j):\\n            if i==m-1 or j==n-1:\\n                return 1\\n            return dfs(i+1, j) + dfs(i, j+1)\\n        return dfs(0, 0)\\n```\\n\\n# Dynamic Programming (Bottom-Up)\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        lower = [1] * n\\n        \\n        for i in reversed(range(m-1)):\\n            upper = [0] * n\\n            upper[n-1] = 1\\n            for j in reversed(range(n-1)):\\n                upper[j] = upper[j+1] + lower[j]\\n            lower = upper\\n            \\n        return lower[0]\\t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        return math.comb(m+n-2, m-1)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n                \\n        @cache\\n        def dfs(i,j):\\n            if i==m-1 or j==n-1:\\n                return 1\\n            return dfs(i+1, j) + dfs(i, j+1)\\n        return dfs(0, 0)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        lower = [1] * n\\n        \\n        for i in reversed(range(m-1)):\\n            upper = [0] * n\\n            upper[n-1] = 1\\n            for j in reversed(range(n-1)):\\n                upper[j] = upper[j+1] + lower[j]\\n            lower = upper\\n            \\n        return lower[0]\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362169,
                "title": "quick-math-approach-python-c-go-o-min-m-n-time",
                "content": "To get from the top left corner to the bottom right corner, the robot has to move, in some order, `m - 1` squares down and `n - 1` squares to the right. There is a **one-to-one correspondence** with the set of all possible paths and the set of *instructions* to follow these paths.\\n\\n>An easy way to give instructions is to tell the robot at ***each step*** if they need to move down or to the right, so the problem is equivalent to figuring out in how many ways we can **rearrange** the letters of the word `DDDDD...DDDRRRR...RR` that has exactly `m - 1` `D`s and `n - 1` `R`s. This can be done in exactly\\n>```\\n>\\tbinom((m - 1) + (n - 1), n - 1)\\n>```\\n>different ways, where\\n>```\\n>\\tbinom(n, k) = n! / (k! * (n - k)!)\\n>```\\n>counts the number of ways to choose `k` objects from a group of `n` in no particular order, since we need to **choose** which `n - 1` of the `(m - 1) + (n - 1)` spots in the word will be taken by `R`s, and the remaining will be taken by `D`s.\\n\\n&#8718;\\n\\n### ****Python3** Code**\\n\\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n\\t\\n\\t\\t# recursive definition of binom(n, k)\\n        def binom(n, k) -> int:\\n            if k == 0:\\n                return 1\\n            return (n - k + 1) * binom(n, k - 1) // k\\n        \\n        return binom(m + n - 2, min(m - 1, n - 1))\\n```\\n\\n### ****C++** Code**\\n```\\nclass Solution {\\n    long int binom(int n, int k){\\n        if (k == 0){\\n            return 1;\\n        }\\n        return (long int) floor((n - k + 1) * binom(n, k - 1) / k);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        return binom(m + n - 2, min(m - 1, n - 1));\\n    }\\n};\\n```\\n\\n### ****Go** code**\\n```\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n\\nfunc binom(n int, k int) int {\\n    if k == 0 {\\n        return 1\\n    }\\n    return (n - k + 1) * binom(n, k - 1) / k\\n}\\n\\nfunc uniquePaths(m int, n int) int {\\n    return binom(m + n - 2, min(m - 1, n - 1))\\n}\\n```\\n* **Note** `binom(n, k) == binom(n, n - k)` for all `0 <= k <= n`. The recursive definition we have above performs faster if we pick the smallest of `k` and `n - k`, so that is why we call `binom(m + n - 2, min(m - 1, n - 1))`.",
                "solutionTags": [
                    "Python",
                    "C",
                    "Go",
                    "Math"
                ],
                "code": "```\\n>\\tbinom((m - 1) + (n - 1), n - 1)\\n>```\n```\\n>\\tbinom(n, k) = n! / (k! * (n - k)!)\\n>```\n```python\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n\\t\\n\\t\\t# recursive definition of binom(n, k)\\n        def binom(n, k) -> int:\\n            if k == 0:\\n                return 1\\n            return (n - k + 1) * binom(n, k - 1) // k\\n        \\n        return binom(m + n - 2, min(m - 1, n - 1))\\n```\n```\\nclass Solution {\\n    long int binom(int n, int k){\\n        if (k == 0){\\n            return 1;\\n        }\\n        return (long int) floor((n - k + 1) * binom(n, k - 1) / k);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        return binom(m + n - 2, min(m - 1, n - 1));\\n    }\\n};\\n```\n```\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n\\nfunc binom(n int, k int) int {\\n    if k == 0 {\\n        return 1\\n    }\\n    return (n - k + 1) * binom(n, k - 1) / k\\n}\\n\\nfunc uniquePaths(m int, n int) int {\\n    return binom(m + n - 2, min(m - 1, n - 1))\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255608,
                "title": "c-simple-tc-o-n-m-using-calculate-ncr",
                "content": "int uniquePaths(int m, int n) {\\n      long path=1;\\n       \\n         \\n    for (int i = n; i < (m + n - 1); i++) {\\n        path *= i;\\n        path /= (i - n + 1);\\n    }\\n",
                "solutionTags": [],
                "code": "int uniquePaths(int m, int n) {\\n      long path=1;\\n       \\n         \\n    for (int i = n; i < (m + n - 1); i++) {\\n        path *= i;\\n        path /= (i - n + 1);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1674332,
                "title": "solution-swift-unique-paths-test-cases",
                "content": "```swift\\nclass Solution {\\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\\n        guard m > 0 else { return 0 }\\n        var dp = [Int](repeating: 1, count: n)\\n        for _ in 1..<m {\\n            for c in 1..<n {\\n                dp[c] += dp[c - 1]\\n            }\\n        }\\n        return dp.last ?? 0\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 4 tests, with 0 failures (0 unexpected) in 0.014 (0.016) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.uniquePaths(3, 7)\\n        XCTAssertEqual(value, 28)\\n    }\\n    \\n    /// From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n    /// 1. Right -> Down -> Down\\n    /// 2. Down -> Down -> Right\\n    /// 3. Down -> Right -> Down\\n    func test1() {\\n        let value = solution.uniquePaths(3, 2)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test2() {\\n        let value = solution.uniquePaths(7, 3)\\n        XCTAssertEqual(value, 28)\\n    }\\n    \\n    func test3() {\\n        let value = solution.uniquePaths(3, 3)\\n        XCTAssertEqual(value, 6)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\\n        guard m > 0 else { return 0 }\\n        var dp = [Int](repeating: 1, count: n)\\n        for _ in 1..<m {\\n            for c in 1..<n {\\n                dp[c] += dp[c - 1]\\n            }\\n        }\\n        return dp.last ?? 0\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.uniquePaths(3, 7)\\n        XCTAssertEqual(value, 28)\\n    }\\n    \\n    /// From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n    /// 1. Right -> Down -> Down\\n    /// 2. Down -> Down -> Right\\n    /// 3. Down -> Right -> Down\\n    func test1() {\\n        let value = solution.uniquePaths(3, 2)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test2() {\\n        let value = solution.uniquePaths(7, 3)\\n        XCTAssertEqual(value, 28)\\n    }\\n    \\n    func test3() {\\n        let value = solution.uniquePaths(3, 3)\\n        XCTAssertEqual(value, 6)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223719,
                "title": "faster-than-100-using-basic-maths-in-c",
                "content": "So basically to reach the destination we have to move m-1 downs and n-1 rights, this means now our new task would be like there are m-1 objects of one kind and n-1 objects of another kind and we have to count the total number of arrangements possible.\\nUsing permutation and combinations\\nanswer = (m+n-2)! / ((m-1)! * (n-1)!)\\nThat\\'s it. Hit like if you like my approach :-)\\nAnd here is the simple code\\n```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n) {\\n        if(m <=0 || n <= 0) \\n            return 0;\\n        \\n        long long res = 1;\\n        for(int i = n; i < m+n-1 ; i++){\\n            res = res * i / (i- n + 1);\\n        }\\n        \\n        return (int)res;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n) {\\n        if(m <=0 || n <= 0) \\n            return 0;\\n        \\n        long long res = 1;\\n        for(int i = n; i < m+n-1 ; i++){\\n            res = res * i / (i- n + 1);\\n        }\\n        \\n        return (int)res;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124869,
                "title": "c-bruteforce-top-down-bottom-up-time-o-2-n-o-m-n-space-o-m-n",
                "content": "**Bruteforce**\\nTime Complexity: O (2^(m+n))\\nSpace Complexity: O(m + n) //I thinkk\\n```\\n    int uniquePaths(int m, int n) {\\n        int res=0;\\n        res+=dfs (m, n, 0, 0);\\n    return res;\\n    }\\n    \\n    int dfs (int m, int n, int i, int j) {\\n        if (i<0 || j<0 || i>=m || j>=n) return 0;\\n        if (i==m-1 && j==n-1) return 1;\\n        \\n        return dfs (m, n, i+1, j) + dfs (m, n, i, j+1);\\n    }\\n```\\n\\n**Memoisation (Top-down)**\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\\n    int uniquePaths(int m, int n) {\\n        vector <vector<int>> dp(m+1, vector<int> (n+1,-1));\\n        return dfs (m, n, dp, 0, 0);\\n    }\\n    \\n    int dfs (int m, int n, vector <vector<int>> &dp, int i, int j) {\\n        if (i>m || j>n) return 0;\\n        if (i==m-1 && j==n-1) return 1;\\n        else if (dp[i][j]!=-1) return dp[i][j];        \\n        else return dp[i][j]=dfs (m, n, dp, i+1, j) + dfs (m, n, dp, i, j+1);\\n    }\\n```\\n\\n**Tabular (Bottom-up)**\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\\n    int uniquePaths(int m, int n) {\\n        vector <vector<int>> dp(m, vector<int> (n,1));\\n        for (int i=1; i<m; i++) \\n            for (int j=1; j<n; j++) \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        \\n        return dp[m-1][n-1];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int uniquePaths(int m, int n) {\\n        int res=0;\\n        res+=dfs (m, n, 0, 0);\\n    return res;\\n    }\\n    \\n    int dfs (int m, int n, int i, int j) {\\n        if (i<0 || j<0 || i>=m || j>=n) return 0;\\n        if (i==m-1 && j==n-1) return 1;\\n        \\n        return dfs (m, n, i+1, j) + dfs (m, n, i, j+1);\\n    }\\n```\n```\\n    int uniquePaths(int m, int n) {\\n        vector <vector<int>> dp(m+1, vector<int> (n+1,-1));\\n        return dfs (m, n, dp, 0, 0);\\n    }\\n    \\n    int dfs (int m, int n, vector <vector<int>> &dp, int i, int j) {\\n        if (i>m || j>n) return 0;\\n        if (i==m-1 && j==n-1) return 1;\\n        else if (dp[i][j]!=-1) return dp[i][j];        \\n        else return dp[i][j]=dfs (m, n, dp, i+1, j) + dfs (m, n, dp, i, j+1);\\n    }\\n```\n```\\n    int uniquePaths(int m, int n) {\\n        vector <vector<int>> dp(m, vector<int> (n,1));\\n        for (int i=1; i<m; i++) \\n            for (int j=1; j<n; j++) \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        \\n        return dp[m-1][n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000238,
                "title": "only-1-line-of-c-with-clear-explanation-beats-100",
                "content": "First thing\\'s first, here\\'s the 1 line code ..\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return round(exp(lgamma(m+n-1) - (lgamma(m) + lgamma(n))));\\n    }\\n};\\n```\\n\\nThis is **not at all a DP problem**. It\\'s a simple **math combiantional problem**.\\n\\nWhat is lgamma ?\\n=> It\\'s a math formula which calculates natural logarithm of the absolute value of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of x. [Refer here for usage.](http://www.cplusplus.com/reference/cmath/lgamma/)\\n\\nWhy are we using lgamma ?\\n=> Because it helps us to calculate factorial. Given `\\u0413(n)` is gamma function of n, \\n\\t\\t**`\\u0413(n) = (n-1)!; for positive integers`**\\nAnd so, **`lgamma(n) = log(\\u0413(n))`**\\n\\nTo avoid re-writing what other great articles have already mentioned, all we need is to compute\\n`(n + m -2) ! / (n-1)! (m-1)!`\\n\\nLet\\'s take \\n```\\n=> y = (n + m - 2) ! /  (n-1)! (m-1)!\\n=> log y = log[(n + m - 2) ! / (n-1)! (m-1)!] .. (taking log both sides)\\n=> log y = log[(n + m - 2)!] - log[(n-1)! (m-1)!]\\n=> log y = log[(n + m - 2)!] - [log((n-1)!) + log((m-1)!)]\\n=> log y = lgamma(n + m - 1) - (lgamma(n) + lgamma(m))\\n=> y = e ^ [lgamma(n + m - 1) - (lgamma(n) + lgamma(m))]\\n```\\nAnd then we round off for precisions.\\n\\nI hope someone found this helpful and interesting :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return round(exp(lgamma(m+n-1) - (lgamma(m) + lgamma(n))));\\n    }\\n};\\n```\n```\\n=> y = (n + m - 2) ! /  (n-1)! (m-1)!\\n=> log y = log[(n + m - 2) ! / (n-1)! (m-1)!] .. (taking log both sides)\\n=> log y = log[(n + m - 2)!] - log[(n-1)! (m-1)!]\\n=> log y = log[(n + m - 2)!] - [log((n-1)!) + log((m-1)!)]\\n=> log y = lgamma(n + m - 1) - (lgamma(n) + lgamma(m))\\n=> y = e ^ [lgamma(n + m - 1) - (lgamma(n) + lgamma(m))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711370,
                "title": "c-optimized-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if(n==1||m==1)\\n            return 1;\\n        vector<vector<int>> dp(2,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i%2][j] = dp[(i-1)%2][j] + dp[i%2][j-1];\\n            }\\n        }\\n        return dp[(n-1)%2][m-1];\\n    }\\n};\\n```\\nIf you have any doubts,feel free to ask in comment section",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if(n==1||m==1)\\n            return 1;\\n        vector<vector<int>> dp(2,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i%2][j] = dp[(i-1)%2][j] + dp[i%2][j-1];\\n            }\\n        }\\n        return dp[(n-1)%2][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588648,
                "title": "c-100-both-in-memory-and-time-dp",
                "content": "**If understood please upvote\\nIf want help please comment**\\n```\\nint uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++)\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        }\\n        return dp[m-1][n-1];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++)\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        }\\n        return dp[m-1][n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405310,
                "title": "c-solution-with-explanation-dp",
                "content": "```\\npublic int UniquePaths(int m, int n)\\n        {\\n            // Matrix to store the value of possible ways to reach each cell\\n            int[][] dp = new int[m][];\\n\\n            // C# thing, as we cannot define int[][] dp = new int[m][n]; \\n            for (int i = 0; i < m; i++)\\n            {\\n                dp[i] = new int[n];\\n            }\\n\\n            //Base Conditions \\n            // all first column of every row as 1\\n            for(int i = 0; i < dp.Length; i++)\\n                dp[i][0] = 1;\\n            // all first row of every column as 1\\n            for(int i = 0; i< dp[0].Length; i++)\\n                  dp[0][i] = 1;\\n\\n            for (int i = 1; i < m; i++)\\n            {\\n                for (int j = 1; j < n; j++)\\n                {\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];   \\n                }\\n            }\\n\\n            return dp[m - 1][n - 1];\\n\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int UniquePaths(int m, int n)\\n        {\\n            // Matrix to store the value of possible ways to reach each cell\\n            int[][] dp = new int[m][];\\n\\n            // C# thing, as we cannot define int[][] dp = new int[m][n]; \\n            for (int i = 0; i < m; i++)\\n            {\\n                dp[i] = new int[n];\\n            }\\n\\n            //Base Conditions \\n            // all first column of every row as 1\\n            for(int i = 0; i < dp.Length; i++)\\n                dp[i][0] = 1;\\n            // all first row of every column as 1\\n            for(int i = 0; i< dp[0].Length; i++)\\n                  dp[0][i] = 1;\\n\\n            for (int i = 1; i < m; i++)\\n            {\\n                for (int j = 1; j < n; j++)\\n                {\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];   \\n                }\\n            }\\n\\n            return dp[m - 1][n - 1];\\n\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374561,
                "title": "100-5-solutions-step-by-step-optimisation-dp-thought-process",
                "content": "Presenting a approach driven code, so that it help you to learn how to approach this kind of problems.\\n\\n**Backtracking**\\n----------\\n\\n```\\n\\n/**\\n * We can solve this problem through backtracking.\\n * Backtracking\\n * 1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n * 2. Our constraints: a) We can not move outside of boundary b\\n * 3. Our choices: a) we can move either Down (i+1,j) or right (i, j+1) from any cell\\n * <p>\\n * Complexity:\\n * To reach a cell there are two way and we try all the source cell to reach this cell.\\n * Complexity: O((m*n)^2) /O (m*n)\\n * <p>\\n * TLE\\n */\\nclass UniquePathsIBacktracking {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        final boolean maze[][] = new boolean[m][n];\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(maze, m, n, sx, sy, dx, dy);\\n\\n\\n    }\\n\\n    private int uniquePaths(boolean[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n        if (sx == dx && sy == dy)\\n            return 1;\\n\\n        int path = 0;\\n        if (isSafe(sx, sy, m, n, maze)) {\\n            maze[sx][sy] = true;\\n\\n            path = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n            maze[sx][sy] = false;\\n        }\\n        return path;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, boolean[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy])\\n            return false;\\n        return true;\\n    }\\n\\n\\n}\\n```\\n\\n**Cache: DP Top Down**\\n\\n```\\n\\n/**\\n * In above backtracking, we visit same cell[i][j] and try to reach destination[m-1][n-1].\\n * This happen again n again for different source cell [sx][sy] for this cell [i][j].\\n * <p>\\n * Since there are overlapping sub-problems, we can cache them; Hence DP\\n * <p>\\n * dp[i][j] = dp[i+1][j] + dp[i][j+1] ; [i,j] is in range of [m,n]\\n * *        = 0 [i,j] is Not in range of [m,n]\\n * base case:\\n * i==dx, j==dy => dp[i][j] = 1\\n * <p>\\n * dp[sx][sy] is output\\n * <p>\\n * <p>\\n * <p>\\n * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 33.2 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPTopDown {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        final int maze[][] = new int[m][n];\\n        for (int i = 0; i < m; i++)\\n            Arrays.fill(maze[i], -1);\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(maze, m, n, sx, sy, dx, dy);\\n\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        if (isSafe(sx, sy, m, n)) {\\n\\n            if (sx == dx && sy == dy)\\n                return maze[sx][sy] = 1;\\n\\n            if (maze[sx][sy] != -1)\\n                return maze[sx][sy];\\n\\n\\n            return maze[sx][sy] = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n        }\\n        return 0;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0)\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\\n\\n\\n**Cache: DP Bottom up**\\n\\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * * O(m*n) / O (m*n)\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 33.2 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPBottomUp {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n\\n        final int dp[][] = new int[m + 1][n + 1];\\n\\n        for (int i = 0; i <= m; i++) {\\n\\n            for (int j = 0; j <= n; j++) {\\n\\n                if (i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n\\n                /**\\n                 * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n                 * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n                 */\\n                else if (i == 1 || j == 1)\\n                    dp[i][j] = 1;\\n\\n                else {\\n                    //would reach this cell by coming down from up dp[i - 1][j] or by coming right from left dp[i][j - 1]\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n\\n            }\\n        }\\n        return dp[m][n];\\n\\n\\n    }\\n\\n\\n}\\n```\\n\\n\\n**Cache: DP Bottom up Space optimize**\\n\\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * We can see we are using only two rows at a time. We can optimize the space\\n * dp[i-1][j] => dp[j] old\\n * dp[i][j-1] => dp[j-1] old\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 32.9 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPBottomUpSpaceOptimize {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n\\n        final int dp[] = new int[n + 1];\\n\\n        for (int i = 0; i <= m; i++) {\\n\\n            for (int j = 0; j <= n; j++) {\\n\\n                if (i == 0 || j == 0)\\n                    dp[j] = 0;\\n\\n                /**\\n                 * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n                 * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n                 */\\n                else if (i == 1 || j == 1)\\n                    dp[j] = 1;\\n\\n                else {\\n                    //would reach this cell by coming down from up dp[i - 1][j] or by coming right from left dp[i][j - 1]\\n                    dp[j] = dp[j] + dp[j - 1];\\n                }\\n\\n            }\\n        }\\n        return dp[n];\\n\\n\\n    }\\n\\n\\n    public int uniquePathsReverse(int m, int n) {\\n        int[] res = new int[m + 1]; // for this problem we can reduce the m*n matrix to an array\\n\\n        Arrays.fill(res, 1);\\n\\n        for (int nIdx = n - 1; nIdx >= 1; nIdx--) {\\n            for (int mIdx = m - 1; mIdx >= 1; mIdx--) {\\n                res[mIdx] = res[mIdx] + res[mIdx + 1];\\n            }\\n        }\\n\\n        return res[1];\\n    }\\n\\n}\\n\\n```\\n\\n**Another approach: Binomial Coefficient**\\n\\n```\\n/**\\n * https://www.geeksforgeeks.org/binomial-coefficient-dp-9/\\n * Basically imagine that you have a binary array where:\\n * 1- move right\\n * 0- move down\\n * <p>\\n * You need m-1 moves right and n-1 moves down\\n * <p>\\n * That means that you need to calculate the number of\\n * binary arrays of length: (m-1 + n-1) = m+n-2 with m-1 ones (1) and n-1 zeros (0). This you can calculate from the\\n * binomial coefficient { (m+n-2) C (m-1) }  // or { (m+n-2) C (n-1) }\\n */\\nclass UniquePathsIBinomialCoefficient {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        return binomialCoefficient(m + n - 2, m - 1);\\n\\n    }\\n\\n    //C(n, k) = C(n-1, k-1) + C(n-1, k)\\n    //   C(n, 0) = C(n, n) = 1\\n    private int binomialCoefficient(int n, int k) {\\n\\n        int c[] = new int[k + 1];\\n\\n        c[0] = 1;\\n\\n        for (int i = 1; i <= n; i++)\\n            for (int j = Math.min(k, i); j >= 1; j--)\\n                c[j] = c[j] + c[j - 1];\\n\\n        return c[k];\\n    }\\n\\n}\\n```\\nUnique Path II : https://leetcode.com/problems/unique-paths-ii/discuss/374664/Simple-or-Easy-to-understand-or-Though-Processor-Explanation-or-4-Solutions-or-UniquePath-I-extension",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\n\\n/**\\n * We can solve this problem through backtracking.\\n * Backtracking\\n * 1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n * 2. Our constraints: a) We can not move outside of boundary b\\n * 3. Our choices: a) we can move either Down (i+1,j) or right (i, j+1) from any cell\\n * <p>\\n * Complexity:\\n * To reach a cell there are two way and we try all the source cell to reach this cell.\\n * Complexity: O((m*n)^2) /O (m*n)\\n * <p>\\n * TLE\\n */\\nclass UniquePathsIBacktracking {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        final boolean maze[][] = new boolean[m][n];\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(maze, m, n, sx, sy, dx, dy);\\n\\n\\n    }\\n\\n    private int uniquePaths(boolean[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n        if (sx == dx && sy == dy)\\n            return 1;\\n\\n        int path = 0;\\n        if (isSafe(sx, sy, m, n, maze)) {\\n            maze[sx][sy] = true;\\n\\n            path = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n            maze[sx][sy] = false;\\n        }\\n        return path;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, boolean[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy])\\n            return false;\\n        return true;\\n    }\\n\\n\\n}\\n```\n```\\n\\n/**\\n * In above backtracking, we visit same cell[i][j] and try to reach destination[m-1][n-1].\\n * This happen again n again for different source cell [sx][sy] for this cell [i][j].\\n * <p>\\n * Since there are overlapping sub-problems, we can cache them; Hence DP\\n * <p>\\n * dp[i][j] = dp[i+1][j] + dp[i][j+1] ; [i,j] is in range of [m,n]\\n * *        = 0 [i,j] is Not in range of [m,n]\\n * base case:\\n * i==dx, j==dy => dp[i][j] = 1\\n * <p>\\n * dp[sx][sy] is output\\n * <p>\\n * <p>\\n * <p>\\n * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 33.2 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPTopDown {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        final int maze[][] = new int[m][n];\\n        for (int i = 0; i < m; i++)\\n            Arrays.fill(maze[i], -1);\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(maze, m, n, sx, sy, dx, dy);\\n\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        if (isSafe(sx, sy, m, n)) {\\n\\n            if (sx == dx && sy == dy)\\n                return maze[sx][sy] = 1;\\n\\n            if (maze[sx][sy] != -1)\\n                return maze[sx][sy];\\n\\n\\n            return maze[sx][sy] = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n        }\\n        return 0;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0)\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * * O(m*n) / O (m*n)\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 33.2 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPBottomUp {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n\\n        final int dp[][] = new int[m + 1][n + 1];\\n\\n        for (int i = 0; i <= m; i++) {\\n\\n            for (int j = 0; j <= n; j++) {\\n\\n                if (i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n\\n                /**\\n                 * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n                 * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n                 */\\n                else if (i == 1 || j == 1)\\n                    dp[i][j] = 1;\\n\\n                else {\\n                    //would reach this cell by coming down from up dp[i - 1][j] or by coming right from left dp[i][j - 1]\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n\\n            }\\n        }\\n        return dp[m][n];\\n\\n\\n    }\\n\\n\\n}\\n```\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * We can see we are using only two rows at a time. We can optimize the space\\n * dp[i-1][j] => dp[j] old\\n * dp[i][j-1] => dp[j-1] old\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.\\n * Memory Usage: 32.9 MB, less than 5.10% of Java online submissions for Unique Paths.\\n */\\nclass UniquePathsIDPBottomUpSpaceOptimize {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n\\n\\n        final int dp[] = new int[n + 1];\\n\\n        for (int i = 0; i <= m; i++) {\\n\\n            for (int j = 0; j <= n; j++) {\\n\\n                if (i == 0 || j == 0)\\n                    dp[j] = 0;\\n\\n                /**\\n                 * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n                 * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n                 */\\n                else if (i == 1 || j == 1)\\n                    dp[j] = 1;\\n\\n                else {\\n                    //would reach this cell by coming down from up dp[i - 1][j] or by coming right from left dp[i][j - 1]\\n                    dp[j] = dp[j] + dp[j - 1];\\n                }\\n\\n            }\\n        }\\n        return dp[n];\\n\\n\\n    }\\n\\n\\n    public int uniquePathsReverse(int m, int n) {\\n        int[] res = new int[m + 1]; // for this problem we can reduce the m*n matrix to an array\\n\\n        Arrays.fill(res, 1);\\n\\n        for (int nIdx = n - 1; nIdx >= 1; nIdx--) {\\n            for (int mIdx = m - 1; mIdx >= 1; mIdx--) {\\n                res[mIdx] = res[mIdx] + res[mIdx + 1];\\n            }\\n        }\\n\\n        return res[1];\\n    }\\n\\n}\\n\\n```\n```\\n/**\\n * https://www.geeksforgeeks.org/binomial-coefficient-dp-9/\\n * Basically imagine that you have a binary array where:\\n * 1- move right\\n * 0- move down\\n * <p>\\n * You need m-1 moves right and n-1 moves down\\n * <p>\\n * That means that you need to calculate the number of\\n * binary arrays of length: (m-1 + n-1) = m+n-2 with m-1 ones (1) and n-1 zeros (0). This you can calculate from the\\n * binomial coefficient { (m+n-2) C (m-1) }  // or { (m+n-2) C (n-1) }\\n */\\nclass UniquePathsIBinomialCoefficient {\\n\\n\\n    public int uniquePaths(int m, int n) {\\n\\n        if (m == 0 || n == 0)\\n            return 0;\\n        /**\\n         * m==1 ; if only horizontal strip is there; source (0,0) destination (0,n-1) and we can move right only\\n         * n==1 ; if only vertical strip is there; source (0,0) destination (m-1,0) and we can move down only\\n         */\\n        if (m == 1 || n == 1)\\n            return 1;\\n\\n\\n        return binomialCoefficient(m + n - 2, m - 1);\\n\\n    }\\n\\n    //C(n, k) = C(n-1, k-1) + C(n-1, k)\\n    //   C(n, 0) = C(n, n) = 1\\n    private int binomialCoefficient(int n, int k) {\\n\\n        int c[] = new int[k + 1];\\n\\n        c[0] = 1;\\n\\n        for (int i = 1; i <= n; i++)\\n            for (int j = Math.min(k, i); j >= 1; j--)\\n                c[j] = c[j] + c[j - 1];\\n\\n        return c[k];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197557,
                "title": "java-and-python-backtrack-and-dp-solutions-with-descriptions",
                "content": "Methods:\\n1) Using backtrack, we can literally traverse through all the possible paths. It sounds bruteforce and yeah it is brute force with asymptotic time being ```O(2^(m+n))```, because always gotta move m times bottom and n times right. But it works, just takes long time and it TLE on leetcode, it spits out same answer as the latter DP method given enough time.. I\\'ve included the code. Backtrack works by searching through all the possible state space tree, illustrated below.\\n![image](https://assets.leetcode.com/users/tedcoder/image_1543101243.png)\\n2) We can use dynamic programming to optimize this problem from method 1). If we think about what backtracking algorithm is doing, it is traversing through the same paths multiple times, so subproblems overlap and we can use DP.\\n\\t1) Subproblems: Smaller grid size of (i,j), there are O(m*n) subproblems\\n\\t2) Guess: # of paths just before the final move.\\n\\t3) Recurrence: Suppose ```DP[i,j]``` is the num paths for sub matrix of i x j where i <= m and j <= n. Then the recurrence relationship is given by ```DP[i,j] = DP[i-1,j] + DP[i,j-1]```. This is derived from illustrations such as below:\\n![image](https://assets.leetcode.com/users/tedcoder/image_1543101488.png)\\nWe simply add up paths just before the ending. The ending move is finished just above or to the left in this question, indicated by red diamonds.\\n\\t4) Using the recurrence, we can construct a bottom-up algorithm with base case ```DP[i,0] = 1 and DP[0,j] = 1```, which correspond to just thin singular paths. ```Time/subproblem = O(1)```, so ```total time is O(m*n) * O(1) = O(m*n)``` with ```space complexity of O(m*n)```.\\n\\t5) Solves original problem ? Yes, because ```DP[m-1,n-1]``` will give you the answer.\\n3) We can further optimize the DP solution by realizing that we dont need O(m*n) space, we just need like two rows of DP data at a time, since we are propagating diagonally (top left to bot right direction). So if we want, we can reduce space to O(n).\\n\\nHere are my code:\\nJava (backtrack, TLE solution):\\n```\\nclass Solution {\\n    private int paths = 0;\\n    public int uniquePaths(int m, int n) {\\n        backtrack(m,n,0,0);\\n        return paths;\\n    }\\n    \\n    public void backtrack(int m, int n, int i, int j){\\n        if(i >= m) return;\\n        if(j >= n) return;\\n        if(i == m-1 && j== n-1){\\n            paths++;\\n            return;\\n        }\\n        \\n        backtrack(m,n,i+1,j);\\n        backtrack(m,n,i,j+1);\\n    }\\n}\\n```\\n\\nPython (DP solution):\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        #construct a DP matrix\\n        DP = [0]*(m)\\n        for i in range(0,m):\\n            DP[i] = [0]*(n)\\n        # set base cases\\n        DP[0][0] = 1\\n        for i in range(1,m):\\n            DP[i][0] = 1\\n        for j in range(1,n):\\n            DP[0][j] = 1\\n        \\n        #bottom up approach\\n        for i in range(1, m):\\n            for j in range(1,n):\\n                DP[i][j] = DP[i-1][j] + DP[i][j-1]\\n                \\n        return DP[m-1][n-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```O(2^(m+n))```\n```DP[i,j]```\n```DP[i,j] = DP[i-1,j] + DP[i,j-1]```\n```DP[i,0] = 1 and DP[0,j] = 1```\n```Time/subproblem = O(1)```\n```total time is O(m*n) * O(1) = O(m*n)```\n```space complexity of O(m*n)```\n```DP[m-1,n-1]```\n```\\nclass Solution {\\n    private int paths = 0;\\n    public int uniquePaths(int m, int n) {\\n        backtrack(m,n,0,0);\\n        return paths;\\n    }\\n    \\n    public void backtrack(int m, int n, int i, int j){\\n        if(i >= m) return;\\n        if(j >= n) return;\\n        if(i == m-1 && j== n-1){\\n            paths++;\\n            return;\\n        }\\n        \\n        backtrack(m,n,i+1,j);\\n        backtrack(m,n,i,j+1);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        #construct a DP matrix\\n        DP = [0]*(m)\\n        for i in range(0,m):\\n            DP[i] = [0]*(n)\\n        # set base cases\\n        DP[0][0] = 1\\n        for i in range(1,m):\\n            DP[i][0] = 1\\n        for j in range(1,n):\\n            DP[0][j] = 1\\n        \\n        #bottom up approach\\n        for i in range(1, m):\\n            for j in range(1,n):\\n                DP[i][j] = DP[i-1][j] + DP[i][j-1]\\n                \\n        return DP[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130628,
                "title": "java-solution-beats-87-but-will-explanation-and-the-approach-to-this-problem",
                "content": "First thing first -- you should first try to solve it recursively. The reason is that the recursion clearly demonstrates what the problem is. The approach should be to come up with a recursive equation and then use that to solve it first. The optimization using DP should come later. \\nSo, to solve using recursion, the question is: how many ways one could reach to the last cell (with the finish)? It is the sum of number of ways you could reach to the cell above, and the cell to the left. Putting it into an equation, here it is :\\n`T(m)(n) = T(m-1)(n) + T(m)(n-1).`\\n\\nSo the recursive solution will be:\\n\\n```\\n    public int uniquePaths_rec(int m, int n) {\\n        if (m <=0 || n<=0) {\\n           return 0;\\n        } else if (m == 1 && n ==1) {\\n            return 1;\\n        }\\n        return uniquePaths(m-1,n) + uniquePaths(m,n-1);\\n    }\\n```\\nThe first condition takes care of index going out of scope and when you reach to the first cell, it completes one path. Rest is merely recursive call.\\n\\nHowever, the time complexity of this approach tends to be exponential since it will calculate every path again and again. The better way is to use Dynamic Programming keeping the same recursion in our mind. We could simulate it with a 2-D array that uses n * m size and our size lies at the arr [n-1 ][m-1] index. Also, remember that for all values of m, arr[0][m] will be 1 since there is only 1 way to go on the right side. Likewise, for all values of n, arr[n][0] will be 1 since there is only 1 way to go down. With that in the mind, here is the code:\\n\\n```\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[n][m];\\n        Arrays.fill(dp[0],1);\\n        for (int i = 0;i<n;i++) {\\n            dp[i][0] = 1;\\n        }\\n        \\n        for (int i=1;i<n ; i++) {\\n            for (int j=1;j<m;j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }  \\n        \\n        return dp[n-1][m-1];        \\n    }\\n```\\n\\nSome examples of run:\\n\\n```\\nYour input\\nm=3,n=3\\n\\nInitialized DP array\\n[1, 1, 1]\\n[1, 0, 0]\\n[1, 0, 0]\\n\\nFinal DP array\\n[1, 1, 1]\\n[1, 2, 3]\\n[1, 3, 6]\\n\\nYour input\\nm=7,n=3\\n\\nInitialized DP array\\n[1, 1, 1, 1, 1, 1, 1]\\n[1, 0, 0, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0, 0, 0]\\n\\nFinal DP array\\n[1, 1, 1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5, 6, 7]\\n[1, 3, 6, 10, 15, 21, 28]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int uniquePaths_rec(int m, int n) {\\n        if (m <=0 || n<=0) {\\n           return 0;\\n        } else if (m == 1 && n ==1) {\\n            return 1;\\n        }\\n        return uniquePaths(m-1,n) + uniquePaths(m,n-1);\\n    }\\n```\n```\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[n][m];\\n        Arrays.fill(dp[0],1);\\n        for (int i = 0;i<n;i++) {\\n            dp[i][0] = 1;\\n        }\\n        \\n        for (int i=1;i<n ; i++) {\\n            for (int j=1;j<m;j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }  \\n        \\n        return dp[n-1][m-1];        \\n    }\\n```\n```\\nYour input\\nm=3,n=3\\n\\nInitialized DP array\\n[1, 1, 1]\\n[1, 0, 0]\\n[1, 0, 0]\\n\\nFinal DP array\\n[1, 1, 1]\\n[1, 2, 3]\\n[1, 3, 6]\\n\\nYour input\\nm=7,n=3\\n\\nInitialized DP array\\n[1, 1, 1, 1, 1, 1, 1]\\n[1, 0, 0, 0, 0, 0, 0]\\n[1, 0, 0, 0, 0, 0, 0]\\n\\nFinal DP array\\n[1, 1, 1, 1, 1, 1, 1]\\n[1, 2, 3, 4, 5, 6, 7]\\n[1, 3, 6, 10, 15, 21, 28]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996228,
                "title": "c-0ms-fastest-easy-to-understand",
                "content": "# C++ | 0ms | Fastest | Easy to Understand\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555153,
                "title": "easy-to-understand-o-m-n-c",
                "content": "# Intuition\\nThe count of distinct routes to navigate to a given cell will be equivalent to the summation of the paths leading to the cell immediately to the left of the current cell and the paths leading to the cell directly above the current cell. \\n\\n# Approach\\nThe number of unique paths when traversing only along a row or column is 1.\\n\\nA matrix of size m*n is initialized with all elements assigned the value 1. Each row and column is sequentially traversed, commencing from index 1. The count of unique paths at any given point is determined by summing the values of dp[i-1][j] and dp[i][j-1], denoting the number of paths leading to the cell directly to the left and above the current cell, respectively. Finally, the value in the last cell, representing the target position, is returned.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n)\\n    {\\n        vector<vector<int> > dp(m,vector<int> (n,1));\\n\\n        for(int i = 1;i<m;i++)\\n        {\\n            for(int j = 1;j<n;j++)\\n            {  \\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n)\\n    {\\n        vector<vector<int> > dp(m,vector<int> (n,1));\\n\\n        for(int i = 1;i<m;i++)\\n        {\\n            for(int j = 1;j<n;j++)\\n            {  \\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386573,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        swap(n,m);\\n        int t=0;\\n        vector<vector<int>>dp(n,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        swap(n,m);\\n        int t=0;\\n        vector<vector<int>>dp(n,vector<int>(m,1));\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233752,
                "title": "fastest-solution-using-combinations-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter observing similarities of pattern in each example we can conclude that we are taking  m + n - 2 number of steps every time.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can conclude by our observation that total number of steps in  each observation is m + 1 or n - 1 so calculate combinations (m + n - 2)C (n - 1) or (m + n - 2)C(m - 1) steps. We can linearly iterate over the given matrix and can compute the value of above derived relation.\\n\\nFor more clarity : https://www.youtube.com/watch?v=t_f0nwwdg5o&list=PLgUwDviBIf0p4ozDR_kJJkONnb1wdx2Ma&index=4 \\nWatch strivers placement series lecture number 3\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m - 1) or O(n - 1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int uniquePaths(int m, int n) {\\n        int k = n + m - 2;\\n        int r = m - 1;\\n        double res = 1;\\n        for(int i = 1; i <= r; i++){\\n            res = res * (k - r + i) / i;\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int uniquePaths(int m, int n) {\\n        int k = n + m - 2;\\n        int r = m - 1;\\n        double res = 1;\\n        for(int i = 1; i <= r; i++){\\n            res = res * (k - r + i) / i;\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745303,
                "title": "100-faster-solution-2d-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n         vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        \\n        dp[0][0]=0;\\n        dp[0][1]=1;\\n        \\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];   \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n         vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        \\n        dp[0][0]=0;\\n        dp[0][1]=1;\\n        \\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345223,
                "title": "very-easy-0-ms-100-fully-explained-c-java-python-js-c-python3",
                "content": "# **C++ Solution (DP Approach):**\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        // create a 2D array to store results of sub-problems...\\n        int paths[m][n];\\n        // To reach any cell in first column is 1...\\n        for (int i = 0; i < m; i++)\\n            paths[i][0] = 1;\\n        // To reach any cell in first row is 1...\\n        for (int j = 0; j < n; j++)\\n            paths[0][j] = 1;\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++)\\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\\n        }\\n        return paths[m - 1][n - 1];   // Return the result...\\n    }\\n};\\n```\\n\\n# **Java Solution (DP Approach):**\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if(m==0 || n==0) return 0;\\n        if(m==1 || n==1) return 1;\\n        int way[][] = new int [m][n];\\n\\t    for(int i = 0; i<m; i++){\\n\\t\\t    for(int j = 0; j<n; j++){\\n\\t\\t\\t    if(i==0 || j==0)\\n                    way[i][j] = 1;\\n\\t\\t\\t    else\\n                    way[i][j] = way[i-1][j] + way[i][j-1];\\n\\t\\t    }\\n\\t    }\\n\\t    return way[m-1][n-1];\\n    }\\n}\\n```\\n\\n# **Python Solution (DP Approach):**\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = [[1] * n for _ in range(m)]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1]\\n        return paths[-1][-1]\\n```\\n        \\n# **JavaScript Solution (Combinatorics approach):**\\n```\\nvar uniquePaths = function(m, n) {\\n    let way = 1;\\n    for(let i = n; i < m + n - 1; i++){\\n        way *= i;\\n        way /= (i - n + 1);\\n    }\\n    return way;\\n};\\n```\\n\\n# **C Language (DP Approach):**\\n```\\nint uniquePaths(int m, int n){\\n    // create a 2D array to store results of sub-problems...\\n    int paths[m][n];\\n    // To reach any cell in first column is 1...\\n    for (int i = 0; i < m; i++)\\n        paths[i][0] = 1;\\n    // To reach any cell in first row is 1...\\n    for (int j = 0; j < n; j++)\\n        paths[0][j] = 1;\\n    for (int i = 1; i < m; i++) {\\n        for (int j = 1; j < n; j++)\\n            paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\\n    }\\n    return paths[m - 1][n - 1];   // Return the result...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        total = m + n -2\\n        any = min(m, n) - 1\\n        paths = 1\\n        for i in range(any):\\n            paths = paths * total / (i+1)\\n            total -= 1\\n        return int(paths)\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        // create a 2D array to store results of sub-problems...\\n        int paths[m][n];\\n        // To reach any cell in first column is 1...\\n        for (int i = 0; i < m; i++)\\n            paths[i][0] = 1;\\n        // To reach any cell in first row is 1...\\n        for (int j = 0; j < n; j++)\\n            paths[0][j] = 1;\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++)\\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\\n        }\\n        return paths[m - 1][n - 1];   // Return the result...\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        if(m==0 || n==0) return 0;\\n        if(m==1 || n==1) return 1;\\n        int way[][] = new int [m][n];\\n\\t    for(int i = 0; i<m; i++){\\n\\t\\t    for(int j = 0; j<n; j++){\\n\\t\\t\\t    if(i==0 || j==0)\\n                    way[i][j] = 1;\\n\\t\\t\\t    else\\n                    way[i][j] = way[i-1][j] + way[i][j-1];\\n\\t\\t    }\\n\\t    }\\n\\t    return way[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = [[1] * n for _ in range(m)]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1]\\n        return paths[-1][-1]\\n```\n```\\nvar uniquePaths = function(m, n) {\\n    let way = 1;\\n    for(let i = n; i < m + n - 1; i++){\\n        way *= i;\\n        way /= (i - n + 1);\\n    }\\n    return way;\\n};\\n```\n```\\nint uniquePaths(int m, int n){\\n    // create a 2D array to store results of sub-problems...\\n    int paths[m][n];\\n    // To reach any cell in first column is 1...\\n    for (int i = 0; i < m; i++)\\n        paths[i][0] = 1;\\n    // To reach any cell in first row is 1...\\n    for (int j = 0; j < n; j++)\\n        paths[0][j] = 1;\\n    for (int i = 1; i < m; i++) {\\n        for (int j = 1; j < n; j++)\\n            paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\\n    }\\n    return paths[m - 1][n - 1];   // Return the result...\\n}\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        total = m + n -2\\n        any = min(m, n) - 1\\n        paths = 1\\n        for i in range(any):\\n            paths = paths * total / (i+1)\\n            total -= 1\\n        return int(paths)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330657,
                "title": "python-1line-answer-ultra-simple-answer-faster-than-95",
                "content": "The Code and logic is given below\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m-1+n-1,n-1)\\n```\\n\\nThink robot has to go from (0,0) to (m,n) ... which means it has to move (m-1) times down \\nand (n-1) time right\\nSo,\\ntotal move = (m-1)+(n-1)\\ndown move = (m-1) \\nright move = (n-1)\\n\\nNow the question narrow down to arrange (m-1) D ( D means down)  and (n-1) R (R means right)\\nso answer is => (m-1)C(n-1)\\n\\nExample if (0,0) to (3,2)\\nthen i know i need to arrange 2 D and 1 L\\nSo possible arrangements are:-\\nDDL\\nDLD\\nLDD\\ntotal 3 arrangement\\nSo answer is 3C2 multiple by 1C1 (posssible way of chossing 2 position for D out of 3 and chossing 1 position of L out of 1 position\\n\\nor 3C1 multiple by 2C2 (posssible way of chossing 1 position for L out of 3 and chossing 2 position of D out of 2 position)\\n\\n\\nPlease Vote Up if you find it usefull.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return math.comb(m-1+n-1,n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195092,
                "title": "no-dp-100-faster-by-maths-4-line-code-o-n-time-complexity-o-1-auxiliary-space-explained",
                "content": "![image](https://assets.leetcode.com/users/images/4e7e809d-b461-4ac8-bf9d-67c22478e4fc_1656157107.7047405.jpeg)\\n\\nGeneral formula :- m-1+i/i\\nThink this like you have 5 cards(Here m+n) and you have to choose 2 cards(Here m or n) ,so total combinations are 5C2.\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        double res = 1;\\n        \\n        for (int i = 1; i <= n-1; i++) {\\n            res = res * (m-1+i) / i;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\\nTime Complexity: O(n)\\nAuxiliary Space: O(1)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        double res = 1;\\n        \\n        for (int i = 1; i <= n-1; i++) {\\n            res = res * (m-1+i) / i;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318140,
                "title": "c-tle-recursive-ac-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int path(int m, int n, int a, int b)\\n    {\\n        if (a < 0 || a > m || b < 0 || b > n) {\\n            return 0;\\n        }    \\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        }\\n        return path(m, n, a+1, b) + path(m, n, a, b+1);\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        int totalPaths = path(m, n, 0, 0);\\n        return totalPaths;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int path(int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a < 0 || a > m || b < 0 || b > n) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            dp[a][b] = 1;\\n        }\\n        else {\\n            dp[a][b] = path(m, n, a+1, b, dp) + path(m, n, a, b+1, dp);\\n        } \\n        return dp[a][b];\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int totalPaths = path(m, n, 0, 0, dp);\\n        return totalPaths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int path(int m, int n, int a, int b)\\n    {\\n        if (a < 0 || a > m || b < 0 || b > n) {\\n            return 0;\\n        }    \\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        }\\n        return path(m, n, a+1, b) + path(m, n, a, b+1);\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        int totalPaths = path(m, n, 0, 0);\\n        return totalPaths;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int path(int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a < 0 || a > m || b < 0 || b > n) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            dp[a][b] = 1;\\n        }\\n        else {\\n            dp[a][b] = path(m, n, a+1, b, dp) + path(m, n, a, b+1, dp);\\n        } \\n        return dp[a][b];\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int totalPaths = path(m, n, 0, 0, dp);\\n        return totalPaths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804052,
                "title": "python-easy-simple-dp-solution-time-o-m-n",
                "content": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[1] * n for i in range(m)]        # DP Matrix of size m*n intialized to 1\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\\n\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[1] * n for i in range(m)]        # DP Matrix of size m*n intialized to 1\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\\n\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395453,
                "title": "kotlin-solution-beats-100-mem-runtime",
                "content": "Here it\\'s\\n\\n```\\nclass Solution {\\n    \\n    fun uniquePaths(m: Int, n: Int): Int {\\n        \\n        var line = IntArray(n){1}\\n\\n        for(i in 1 until m){\\n            for(j in 1 until n){\\n                line[j] += line[j-1]\\n            }\\n        }\\n\\n        return line[n-1]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    fun uniquePaths(m: Int, n: Int): Int {\\n        \\n        var line = IntArray(n){1}\\n\\n        for(i in 1 until m){\\n            for(j in 1 until n){\\n                line[j] += line[j-1]\\n            }\\n        }\\n\\n        return line[n-1]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23159,
                "title": "java-different-solutions-math-dp-o-m-n-o-n-space",
                "content": "    import static java.lang.Math.toIntExact;\\n    public class Solution {\\n    // math \\n    public int uniquePaths1(int m, int n) {\\n        m--; n--;\\n        long ret=1;\\n        for (int i=1; i<=Math.min(m, n); i++) {\\n            ret = ret * (m+n+1-i)/i; //take care here \\n        }\\n        return toIntExact(ret);\\n    }   \\n    \\n    // O(n*m) space, dp\\n    public int uniquePaths2(int m, int n) {\\n        int dp[][] = new int[m][n];\\n        for (int i=0; i<m; i++)\\n            dp[i][0] = 1;\\n        for (int j=0; j<n; j++)\\n            dp[0][j] = 1;\\n        for (int i=1; i<m; i++) \\n            for (int j=1; j<n; j++) \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        return dp[m-1][n-1];\\n    }\\n    \\n    // O(n) space, dp\\n    public int uniquePaths(int m, int n) {\\n        int []dp = new int[n];\\n        for (int j=0; j<n; j++)\\n            dp[j] = 1;\\n        for (int i=1; i<m; i++) \\n            for (int j=1; j<n; j++)\\n                dp[j] += dp[j-1];\\n         return dp[n-1];       \\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    // math \\n    public int uniquePaths1(int m, int n) {\\n        m--; n--;\\n        long ret=1;\\n        for (int i=1; i<=Math.min(m, n); i++) {\\n            ret = ret * (m+n+1-i)/i; //take care here \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3995388,
                "title": "4-different-approaches-dp",
                "content": "# 1. Recursive Approach-------->Top to Down\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        def solve(ind1,ind2):\\n            if ind1==0 and ind2==0:\\n                return 1\\n            if ind1<0  or ind2<0:\\n                return 0\\n            return solve(ind1-1,ind2)+solve(ind1,ind2-1)\\n        return solve(m-1,n-1)\\n ```\\n # 2. Memorization Approach\\n ```\\n class Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp=[[-1]*(n+1) for i in range(m)]\\n        def solve(ind1,ind2):\\n            if ind1==0 and ind2==0:\\n                return 1\\n            if ind1<0 or ind2<0:\\n                return 0\\n            if dp[ind1][ind2]!=-1:\\n                return dp[ind1][ind2]\\n            left=solve(ind1,ind2-1)\\n            up=solve(ind1-1,ind2)\\n            dp[ind1][ind2]=up+left\\n            return left+up\\n        return solve(m-1,n-1)\\n```\\n# 3. Tabulation------>Bottom to Up Approach\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp=[[0]*(n+1) for i in range(m+1)]\\n        for ind1 in range(1,m+1):\\n            for ind2 in range(1,n+1):\\n                if ind1==ind2==1:\\n                    dp[ind1][ind2]=1\\n                else:\\n                    left=up=0\\n                    if ind2-1>=0:\\n                        left=dp[ind1][ind2-1]\\n                    if ind1-1>=0:\\n                        up=dp[ind1-1][ind2]\\n                    dp[ind1][ind2]=up+left\\n        return dp[-1][-1]\\n```\\n# 4. Space Optimization\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        prev=[0]*(n+1)\\n        for ind1 in range(1,m+1):\\n            cur=[0]*(n+1)\\n            for ind2 in range(1,n+1):\\n                if ind1==ind2==1:\\n                    cur[ind2]=1\\n                else:\\n                    left=up=0\\n                    if ind2-1>=0:\\n                        left=cur[ind2-1]\\n                    if ind1-1>=0:\\n                        up=prev[ind2]\\n                    cur[ind2]=up+left\\n            prev=cur\\n        return cur[-1]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        def solve(ind1,ind2):\\n            if ind1==0 and ind2==0:\\n                return 1\\n            if ind1<0  or ind2<0:\\n                return 0\\n            return solve(ind1-1,ind2)+solve(ind1,ind2-1)\\n        return solve(m-1,n-1)\\n ```\n```\\n class Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp=[[-1]*(n+1) for i in range(m)]\\n        def solve(ind1,ind2):\\n            if ind1==0 and ind2==0:\\n                return 1\\n            if ind1<0 or ind2<0:\\n                return 0\\n            if dp[ind1][ind2]!=-1:\\n                return dp[ind1][ind2]\\n            left=solve(ind1,ind2-1)\\n            up=solve(ind1-1,ind2)\\n            dp[ind1][ind2]=up+left\\n            return left+up\\n        return solve(m-1,n-1)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp=[[0]*(n+1) for i in range(m+1)]\\n        for ind1 in range(1,m+1):\\n            for ind2 in range(1,n+1):\\n                if ind1==ind2==1:\\n                    dp[ind1][ind2]=1\\n                else:\\n                    left=up=0\\n                    if ind2-1>=0:\\n                        left=dp[ind1][ind2-1]\\n                    if ind1-1>=0:\\n                        up=dp[ind1-1][ind2]\\n                    dp[ind1][ind2]=up+left\\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        prev=[0]*(n+1)\\n        for ind1 in range(1,m+1):\\n            cur=[0]*(n+1)\\n            for ind2 in range(1,n+1):\\n                if ind1==ind2==1:\\n                    cur[ind2]=1\\n                else:\\n                    left=up=0\\n                    if ind2-1>=0:\\n                        left=cur[ind2-1]\\n                    if ind1-1>=0:\\n                        up=prev[ind2]\\n                    cur[ind2]=up+left\\n            prev=cur\\n        return cur[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897175,
                "title": "beats-100-user-solution",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND COMMENT FOR ANY SUPPORT**\\n# SPACE OPTIMIZED SOLUTION\\n# Approach\\nInitialize two vectors, prevRow and currRow, both of size n. The initial values for these vectors are all set to 1. This is because there\\'s only one way to reach any cell in the first row or column.\\n\\nIterate through the rows from the second row (index 1) to the last row (index m - 1):\\n\\na. In each iteration of the outer loop, iterate through the columns from the second column (index 1) to the last column (index n - 1).\\n\\nb. For each cell, update the value in currRow[j] using the dynamic programming formula: currRow[j] = currRow[j - 1] + prevRow[j]. This calculates the number of unique paths to the current cell based on the values from the left cell (currRow[j - 1]) and the cell above (prevRow[j]).\\n\\nAfter updating all cells in currRow, swap the contents of currRow and prevRow. This is done so that in the next iteration, prevRow holds the values of the previous row, and you can update currRow with the new values.\\n\\nAfter completing the loop, the value at prevRow[n - 1] represents the number of unique paths to the last cell of the grid (bottom-right corner). Return this value as the final result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> prevRow(n, 1);\\n        vector<int> currRow(n, 1);\\n        \\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                currRow[j] = currRow[j - 1] + prevRow[j];\\n            }\\n            swap(currRow, prevRow); \\n        }\\n        return prevRow[n - 1];\\n    }\\n};\\n\\n```\\n# MEMOIZATION\\n# Approach\\nThe function path is a recursive function that calculates the number of unique paths from a given cell (i, j) to the destination cell (m-1, n-1) in the grid.\\n\\nThe base cases are handled first:\\n\\nIf the current cell (i, j) is the destination cell (m-1, n-1), there is only one way to reach the destination, so the function returns 1.\\nIf i is greater than or equal to m or j is greater than or equal to n, it means the current cell is out of bounds, so the function returns 0.\\nThe memoization check is done by looking at the value of dp[i][j]. If it\\'s not equal to -1, it means the result for this cell has already been computed, so the function directly returns dp[i][j].\\n\\nIf the result for the current cell (i, j) is not available in the dp array, the function calculates the number of unique paths by recursively calculating the number of paths moving down (i+1, j) and moving right (i, j+1). These values are stored in the down and right variables, respectively.\\n\\nThe result for the current cell (i, j) is then calculated as the sum of the paths moving down and moving right: dp[i][j] = down + right.\\n\\nFinally, the result dp[i][j] is returned.\\n\\nThe uniquePaths function initializes the dp array with -1 values. Then, it calls the path function with the starting cell (0, 0) and the dp array.\\n\\nThe path function calculates and returns the total number of unique paths from the starting cell to the destination cell.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint path(int m, int n, int i ,int j,vector<vector<int>>&dp)\\n{\\n    if(i==m-1 && j==n-1)return 1;\\n    if(i>=m || j>=n)return 0;\\n    if(dp[i][j]!=-1)\\n    return dp[i][j];\\n\\n    int down=path(m,n,i+1,j,dp);\\n    int right=path(m,n,i,j+1,dp);\\n    dp[i][j]=down+right;\\n    return dp[i][j];\\n\\n}\\n    int uniquePaths(int m, int n){\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return path(m,n,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> prevRow(n, 1);\\n        vector<int> currRow(n, 1);\\n        \\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                currRow[j] = currRow[j - 1] + prevRow[j];\\n            }\\n            swap(currRow, prevRow); \\n        }\\n        return prevRow[n - 1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\nint path(int m, int n, int i ,int j,vector<vector<int>>&dp)\\n{\\n    if(i==m-1 && j==n-1)return 1;\\n    if(i>=m || j>=n)return 0;\\n    if(dp[i][j]!=-1)\\n    return dp[i][j];\\n\\n    int down=path(m,n,i+1,j,dp);\\n    int right=path(m,n,i,j+1,dp);\\n    dp[i][j]=down+right;\\n    return dp[i][j];\\n\\n}\\n    int uniquePaths(int m, int n){\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return path(m,n,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735932,
                "title": "simple-math-easy-to-understand",
                "content": "# Simple Math\\n```\\n    int combination(int n,int r){\\n        double ans=1,N=n;\\n        for(double i=1;i<=r;i++){\\n            ans*=(N-(i-1));\\n            ans/=i;\\n        }\\n        return ans;\\n    }\\n    int uniquePaths(int m, int n) {\\n        //Combinatrial solution \\n\\n        /*  \\n        Total_right_step_to_take = n-1    \\n        Total_down_step_to_take = m-1\\n        Total step = n-1+m-1 = m+n-2\\n        We want to choose m-1 down path from this total paths which is (m+n-2)C(m-1)\\n        which will also be equal to (m+n-2)C(n-1)\\n        Answer = (m+n-2)C(m-1) or (m+n-2)C(n-1)\\n        */\\n\\n        return combination(m+n-2,min(n-1,m-1));\\n    }\\n```\\n\\n# DP\\n```\\n    int dp[105][105];\\n    int uniquePaths(int n, int m) {\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<n;i++) dp[i][0]=1; \\n        for(int i=0;i<m;i++) dp[0][i]=1; \\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                //Think in reverse direction,\\n                //we can go from current cell to up or left,\\n                //So we only add dp[i-1][j] && dp[i][j-1] to current dp[i][j].\\n                dp[i][j]=(i-1>=0?dp[i-1][j]:0)+(j-1>=0?dp[i][j-1]:0);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int combination(int n,int r){\\n        double ans=1,N=n;\\n        for(double i=1;i<=r;i++){\\n            ans*=(N-(i-1));\\n            ans/=i;\\n        }\\n        return ans;\\n    }\\n    int uniquePaths(int m, int n) {\\n        //Combinatrial solution \\n\\n        /*  \\n        Total_right_step_to_take = n-1    \\n        Total_down_step_to_take = m-1\\n        Total step = n-1+m-1 = m+n-2\\n        We want to choose m-1 down path from this total paths which is (m+n-2)C(m-1)\\n        which will also be equal to (m+n-2)C(n-1)\\n        Answer = (m+n-2)C(m-1) or (m+n-2)C(n-1)\\n        */\\n\\n        return combination(m+n-2,min(n-1,m-1));\\n    }\\n```\n```\\n    int dp[105][105];\\n    int uniquePaths(int n, int m) {\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<n;i++) dp[i][0]=1; \\n        for(int i=0;i<m;i++) dp[0][i]=1; \\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                //Think in reverse direction,\\n                //we can go from current cell to up or left,\\n                //So we only add dp[i-1][j] && dp[i][j-1] to current dp[i][j].\\n                dp[i][j]=(i-1>=0?dp[i-1][j]:0)+(j-1>=0?dp[i][j-1]:0);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602735,
                "title": "python-c-solutions-use-math-pascal-triangle-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe codes calculate the number of unique paths in a grid from the top-left corner to the bottom-right corner. To do this, it uses the concept of combinations to determine the total number of ways to choose a certain number of downward steps (represented by \\'V\\') and rightward steps (represented by \\'>\\').\\n\\nIn the grid, there are exactly (m + n - 2) steps to move in total. Out of these steps, (m - 1) are downward steps and (n - 1) are rightward steps. This can be converted into a combination problem where we need to find the combination number for permutations of (m - 1) downward steps and (n - 1) rightward steps.\\n\\nIn Python, the combination number can be directly calculated using the formula \\n$$C(N, K) = \\\\frac{(N)(N-1)\\\\cdots (N-K+1)}{K!},$$ \\nwhere $N=m + n - 2$ represents the total number of steps and $K=\\\\min(n-1, m-1)$ the mininum for the numbers for downward steps and rightward steps. This formula simplifies the computation.\\n\\nHowever, in C++, the direct computation of the combination number may exceed the limits of even the signed long long data type. Therefore, the code employs an iterative approach inspired by Pascal\\'s Triangle, which is a form of dynamic programming. By iteratively calculating the combinations, it avoids the need for large integer computations and efficiently determines the number of unique paths.\\n\\nBy understanding this concept and leveraging dynamic programming techniques, the code effectively solves the problem of finding the number of unique paths in the grid.\\n\\nSo use the idea in Leetcode 118. Pascal\\'s Triangle, which is in fact the iterative way for dynamic programming, then done!\\n[https://youtu.be/paoJGMYEEhA](https://youtu.be/paoJGMYEEhA)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Python Code\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if n == 1: \\n            return 1\\n        N = n + m - 2\\n        K = min(n - 1, m - 1)\\n        C=1\\n        for i in range(N,N-K, -1):\\n            C*=i\\n        for i in range(1, K+1):\\n            C//=i       \\n        return C\\n```\\n# C++ solution uses recursion with Memoziation\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> C;\\n    long long comb(int i, int j){\\n        if (C[i][j]!=-1) return C[i][j];\\n        if (j==0 || j==i ) return C[i][j]=1LL;\\n        return C[i][j]=comb(i-1, j)+comb(i-1, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        C.assign(N+1, vector(K+1, -1LL));\\n        return comb(N, K);\\n    }\\n};\\n```\\n# C++ code using Pascal\\'s triangle beats 100%\\nBoth of SC & iterations are optimized\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        vector<int> prev, C_N;\\n        prev.assign(K + 1, 1); // C(0,0)=1\\n        for (int i = 1; i <= K; i++) {\\n            C_N.assign(i + 1, 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C_N[j] = C_N[i - j] = prev[j] + prev[j - 1];\\n            }\\n            prev = C_N;\\n        }\\n        for (int i = K + 1; i <= N - K; i++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = 1; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        for (int i = N - K + 1, j0 = 1; i <= N; i++, j0++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = j0; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        return C_N[K];\\n    }\\n};\\n\\n```\\n# C++ code using C(N, K)=C(N-1, K-1)*N/K\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        unsigned long long C=1LL;\\n        for (unsigned i=1; i<=K; i++) \\n            C=C*(N-K+i)/i;            \\n        return C;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if n == 1: \\n            return 1\\n        N = n + m - 2\\n        K = min(n - 1, m - 1)\\n        C=1\\n        for i in range(N,N-K, -1):\\n            C*=i\\n        for i in range(1, K+1):\\n            C//=i       \\n        return C\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> C;\\n    long long comb(int i, int j){\\n        if (C[i][j]!=-1) return C[i][j];\\n        if (j==0 || j==i ) return C[i][j]=1LL;\\n        return C[i][j]=comb(i-1, j)+comb(i-1, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        C.assign(N+1, vector(K+1, -1LL));\\n        return comb(N, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        vector<int> prev, C_N;\\n        prev.assign(K + 1, 1); // C(0,0)=1\\n        for (int i = 1; i <= K; i++) {\\n            C_N.assign(i + 1, 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C_N[j] = C_N[i - j] = prev[j] + prev[j - 1];\\n            }\\n            prev = C_N;\\n        }\\n        for (int i = K + 1; i <= N - K; i++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = 1; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        for (int i = N - K + 1, j0 = 1; i <= N; i++, j0++) {\\n            C_N.assign(K + 1, 1);\\n            for (int j = j0; j <= K; j++)\\n                C_N[j] = prev[j - 1] + prev[j];\\n            prev = C_N;\\n        }\\n        return C_N[K];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        if (n == 1) return 1;\\n        int N = n + m - 2, K = min(n - 1, m - 1);\\n        unsigned long long C=1LL;\\n        for (unsigned i=1; i<=K; i++) \\n            C=C*(N-K+i)/i;            \\n        return C;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593119,
                "title": "c-easy-to-understand-0ms-o-m-n-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider a cell A. The number of paths from A will be the sum of paths from the cell below it and the cell to the right of it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is a top-down DP approach.\\nWe are adding the number of paths of the right and below cells and doing it recurrsively. Along this we are storing the calculated paths in the DP array to use them in repetitive recurrsive calls.\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(m*n) (memory used by DP array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int rec(int m, int n,int a, int b, vector<vector<int>> &v)\\n    {\\n        if(v[m][n]!=-1)return v[m][n];\\n        //cheking if the value is previously stored in DP array\\n\\n        if(m==a || n==b)return 1;\\n        //base case\\n        //if the recurrsion reached the bottom or right edge then only one path is present to the final box\\n\\n        v[m][n] = rec(m+1,n,a,b, v)+rec(m, n+1,a,b,v);\\n        //adding and storing the number of paths of right and bottom cell\\n\\n        return v[m][n];\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(m, vector<int>(n, -1));\\n        return rec(0,0,m-1,n-1, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int rec(int m, int n,int a, int b, vector<vector<int>> &v)\\n    {\\n        if(v[m][n]!=-1)return v[m][n];\\n        //cheking if the value is previously stored in DP array\\n\\n        if(m==a || n==b)return 1;\\n        //base case\\n        //if the recurrsion reached the bottom or right edge then only one path is present to the final box\\n\\n        v[m][n] = rec(m+1,n,a,b, v)+rec(m, n+1,a,b,v);\\n        //adding and storing the number of paths of right and bottom cell\\n\\n        return v[m][n];\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(m, vector<int>(n, -1));\\n        return rec(0,0,m-1,n-1, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372964,
                "title": "easy-clear-solution-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        memo=[[0 for _ in range(n+1)] for _ in range(m+1)]\\n        def db(x,y):\\n            if x==m and y==n:\\n                return 1\\n            elif x==m:\\n                if memo[x][y+1]==0:\\n                    memo[x][y+1]=db(x,y+1)\\n                return memo[x][y+1]\\n            elif y==n:\\n                if memo[x+1][y]==0:\\n                    memo[x+1][y]=db(x+1,y)\\n                return memo[x+1][y]\\n            else:\\n                if memo[x][y+1]==0:\\n                    memo[x][y+1]=db(x,y+1)\\n                if memo[x+1][y]==0:\\n                    memo[x+1][y]=db(x+1,y)\\n                return memo[x][y+1]+memo[x+1][y]\\n        return db(1,1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        memo=[[0 for _ in range(n+1)] for _ in range(m+1)]\\n        def db(x,y):\\n            if x==m and y==n:\\n                return 1\\n            elif x==m:\\n                if memo[x][y+1]==0:\\n                    memo[x][y+1]=db(x,y+1)\\n                return memo[x][y+1]\\n            elif y==n:\\n                if memo[x+1][y]==0:\\n                    memo[x+1][y]=db(x+1,y)\\n                return memo[x+1][y]\\n            else:\\n                if memo[x][y+1]==0:\\n                    memo[x][y+1]=db(x,y+1)\\n                if memo[x+1][y]==0:\\n                    memo[x+1][y]=db(x+1,y)\\n                return memo[x][y+1]+memo[x+1][y]\\n        return db(1,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161220,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101]{};\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [ [1]*n for i in range(m)]\\n\\n        for y in range(1,m):\\n            for x in range(1,n):\\n                dp[y][x] = dp[y-1][x] + dp[y][x-1]\\n\\n        return dp[m-1][n-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] arr = new int[m][n];\\n        int total = traverse(0, 0, m, n, arr);\\n        return total;\\n    }\\n\\n    private int traverse(int i, int j, int m, int n, int[][] arr) {\\n        if (i == m  || j == n) {\\n            return 0;\\n        }\\n\\n        if (i == m - 1 && j == n - 1) {\\n            return 1;\\n        }\\n\\n        int bottom = i+1 < m && arr[i+1][j] != 0 ? arr[i+1][j]:traverse(i+1, j, m, n, arr);\\n        int right = j+1 < n && arr[i][j+1] != 0 ? arr[i][j]:traverse(i, j + 1, m, n, arr);\\n\\n        arr[i][j] = bottom + right;\\n        return arr[i][j];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101]{};\\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [ [1]*n for i in range(m)]\\n\\n        for y in range(1,m):\\n            for x in range(1,n):\\n                dp[y][x] = dp[y-1][x] + dp[y][x-1]\\n\\n        return dp[m-1][n-1]\\n```\n```Java []\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] arr = new int[m][n];\\n        int total = traverse(0, 0, m, n, arr);\\n        return total;\\n    }\\n\\n    private int traverse(int i, int j, int m, int n, int[][] arr) {\\n        if (i == m  || j == n) {\\n            return 0;\\n        }\\n\\n        if (i == m - 1 && j == n - 1) {\\n            return 1;\\n        }\\n\\n        int bottom = i+1 < m && arr[i+1][j] != 0 ? arr[i+1][j]:traverse(i+1, j, m, n, arr);\\n        int right = j+1 < n && arr[i][j+1] != 0 ? arr[i][j]:traverse(i, j + 1, m, n, arr);\\n\\n        arr[i][j] = bottom + right;\\n        return arr[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158157,
                "title": "java-2-solutions-with-clear-explanation-brute-force-dp",
                "content": "# Intuition\\nThe Unique Paths problem is a classic dynamic programming problem where you need to find the number of unique paths from the top-left corner of a grid to a bottom-right corner, while only allow to move right or down.\\n\\n# Approach\\nThe first approach that came into my mind was backtracking. Starting from the top-left corner of the grid (represented by `row` and `column`), we recursively explore all the possible paths to the bottom-right corner of the grid. However, this solution is quite inefficient.\\n\\n# Code\\n#### **1) Brute force solution (Recursive) [TLE] \\u274C**\\n\\nAt every cell, we make 2 decisions: go right / go left.\\n\\nif `row` is equal to `m-1` and `column` is equal to `n-1`, it means we have reached the bottom-right corner, and we can increment the `count` of unique paths by 1.\\n\\nif `row` is greater than or equal to `m` or `column` is greater than or equal to `n`, it means we have stepped outside the grid, and we return from the function.\\n\\nFinally we return the variable `count`.\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePaths(int m, int n) {\\n        backtracking(0, 0, m, n);\\n        return count;\\n    }\\n\\n    public void backtracking(int row, int column, int m, int n)\\n    {\\n        if(row == m - 1 && column == n - 1) \\n        {\\n            count++;\\n            return;\\n        }\\n        if(row >= m || column >= n) return;\\n        backtracking(row, column + 1, m,n);\\n        backtracking(row + 1, column, m, n);\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(2^m * 2^n)$$ where `m` and `n` are the dimensions of the grid. For each cells, the robot tries every possible path to go and this lead to an exponential number of possible paths to solve.\\n\\n- Space complexity: $$O(m*n)$$ in the worst case, the maximum number of function calls that can be made is `m * n`, one for each cell of the grid. \\n\\n#### **2) Dynamic programming solutions**\\n\\n##### Iterative - Tabulation - Bottom Up \\u2705\\n\\nStep 1 - Create a 2D-array with the same dimension as the grid. This `dp` array will store the number of unique paths to each cell in the grid. You can initialize the whole top row and side-left column to 1 because there is always one path and to reach any cell in the top row and the side-left column.\\n\\nYour array might looks like this:\\n[1\\t1\\t1\\t1]\\n[1\\t0\\t0\\t0]\\n[1\\t0\\t0\\t0]\\n[1\\t0\\t0\\t0]\\n\\nStep 2 - Fill the `dp` array: Now traverse through the `dp` array, you can skip any cell that has a value of 1. The value of each cell holds the number of unique paths to reach that cell. To find this value, you can add the value of the cell above it and the cell to its left. \\n\\n[1\\t1\\t1\\t1   ]\\n[1\\t2\\t3\\t4  ] \\n[1\\t3\\t9\\t13 ]\\n[1\\t4\\t13\\t26]\\n\\nStep 3 - Return the value of the last cell. After traversing through the array, the last cell will hold the number of unique paths to get to it. You can return `dp[m-1][n-1]` to get the solution. \\n\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int [][] grid = new int [m][n];\\n        for(int k = 0; k < m; k++) grid[k][0] = 1;\\n        for(int k = 0; k < n; k++) grid[0][k] = 1;\\n\\n        for(int k = 0; k < m; k++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[k][j] == 1) continue;\\n                else\\n                {\\n                    grid[k][j] = grid[k-1][j] + grid[k] [j-1]; \\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(m*n)$$ where m and n are the dimensions of the grid\\n\\n- Space complexity: $$O(m*n)$$ as you need to store the values of all cells in the `dp` array.\\n\\n# Application\\n\\n###### The Jump Game problem have several real-life applications, including the following: \\n\\n1. Robotics: find the number of unique paths it can take to reach its destionation in a grid-like enviroment (warehouses).\\n2. Game development: this algorithm can be used to find the number of unique paths that a player can take to reach a certain point.\\n3. Image processing: measure the  distance between two objects by counting the number of unique paths between two points in an image\\n4. Network Design: find the number of unique paths between two nodes in a network, for example, two find the number of different routes between 2 cities.\\n5. Supplychain management: unique paths that a product can take from the warehouse to the customer\\n6. Map navigation: find different routes between 2 cities.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePaths(int m, int n) {\\n        backtracking(0, 0, m, n);\\n        return count;\\n    }\\n\\n    public void backtracking(int row, int column, int m, int n)\\n    {\\n        if(row == m - 1 && column == n - 1) \\n        {\\n            count++;\\n            return;\\n        }\\n        if(row >= m || column >= n) return;\\n        backtracking(row, column + 1, m,n);\\n        backtracking(row + 1, column, m, n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int [][] grid = new int [m][n];\\n        for(int k = 0; k < m; k++) grid[k][0] = 1;\\n        for(int k = 0; k < n; k++) grid[0][k] = 1;\\n\\n        for(int k = 0; k < m; k++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[k][j] == 1) continue;\\n                else\\n                {\\n                    grid[k][j] = grid[k-1][j] + grid[k] [j-1]; \\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078158,
                "title": "100-runtime-recursion-memoization-tabulation-optimisation",
                "content": "## Intuition\\nThe question is a simple problem of recursion/backtracking that can be optimised through Dynamic Programming using memoization and tabulation, to reduce the time complexity exponentially.\\n> To put things into perspective, it takes about 0.0000006 seconds to finish 60 computations, but more than 360 YEARS for 2^60 computations, on most platforms.\\n\\nWe are given a matrix of M rows and N columns, where we have to reach the bottom-right corner (i.e the block with index [m-1][n-1]) from the top-left (i.e. the block with index [0][0]), moving only to the right or down from any given block.\\n\\nOur first intuition would be to start from the first block and explore all possibilities on each iterations till we reach the destination, then repeat for every other possible combination along the way. Let\\'s see how we do that while not aging beyond our generation.\\n\\n# Approach 1: Recursion/Backtracking [TLE]\\n<!-- Describe your approach to solving the problem. -->\\n1) The first approach that comes to mind is Recursion, starting from the base case, reaching the destination through a valid path then backtracking to find all possible solutions. \\nDoing so is a correct approach but not an optimised one, since we would be performing a huge amount of redundant computations while traversing all possibilities in the recursion tree.\\n## Complexity\\n- Time complexity:<code>**O(2<sup>m + n</sup>)**</code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code>**O(m*n) + O(m+n)**</code>, for the dp array and the implicit recursive stack respectively.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int find(int& m, int& n, int i, int j){\\n        if(i==m || j==n) return 0;  // Out of bounds\\n        if(i==m-1 && j==n-1) return 1;\\n        return find(m, n, i+1, j) + find(m, n, i, j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return find(m, n, 0, 0);\\n    }\\n};\\n```\\n<br>\\n\\n# Approach 2: Memoization - Top down\\nNow that we\\'ve got a glamorous TLE error, let\\'s try to optimise it by maintaining a `M*N` dp matrix that saves all computations for future reference. Every time we come across a cell whole value has already been found, we return that value without having to go down that road again.\\n> You\\'ll see, its much better! \\n\\n## Complexity\\n- Time complexity:<code>**O(m * n)**</code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code>**O(m*n) + O(m+n)**</code>, for the dp array and the implicit recursive stack respectively.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& dp, int& m, int& n, int i, int j){\\n        if(i==m || j==n) return 0;  // Out of bounds\\n        if(i==m-1 && j==n-1) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        dp[i][j] = find(dp, m, n, i+1, j) + find(dp, m, n, i, j+1);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return find(dp, m, n, 0, 0);\\n    }\\n};\\n```\\n<br>\\n\\n# Approach 3: Tabulation - Bottom up\\nOkay so we\\'ve solved it but the space complexity still bugs a bit, doesn\\'t it? I get why we need the `M*N` space for the array, but the additional space needs to leave. What if we come up with an iterative solution instead (it\\'s basically the same thing, just in a loop, and better), which works from the *bottom-up*... that ought to work?\\n> PS, it does.\\n\\n## Complexity\\n- Time complexity:<code>**O(m * n)**</code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code>**O(m*n)**</code>, for the dp array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        if(m==1 && n==1) return 1;\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=0;\\n                dp[i][j] += dp[i+1][j];\\n                dp[i][j] += dp[i][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\nNow we **could** stop with the madness, but we do notice that we\\'re not really using all of `M*N` space; instead, on every iteration, we\\'re just concerned with the current row, and the one succeeding it. So why not just do that? Let\\'s reduce the array to have 2 rows which we alternate through on every iteration and update the values in those cells instead of storing values in new ones. \\n> Why? Reduces the space complexity even more, which would be good when you\\'ve got longer testcases.\\n\\n## Complexity\\n- Time complexity:<code>**O(m * n)**</code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code>**O(2*n)**</code>, for the optimised dp array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(2, vector<int>(n, 1));\\n        int f=(m-2)&1;\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[f][j] = dp[!f][j] + dp[f][j+1];\\n            }\\n            f=!f;\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\nOr still better yet, we can use a single vector as well. We are only accessing same column from previous row which can be given by dp[j] and previous column of current row which can be given by dp[j-1]. So the above code can be further simplfied to a space complexity of <code>**O(n)**</code>, thanks to [@zayne-siew](https://leetcode.com/zayne-siew/).",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int& m, int& n, int i, int j){\\n        if(i==m || j==n) return 0;  // Out of bounds\\n        if(i==m-1 && j==n-1) return 1;\\n        return find(m, n, i+1, j) + find(m, n, i, j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return find(m, n, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& dp, int& m, int& n, int i, int j){\\n        if(i==m || j==n) return 0;  // Out of bounds\\n        if(i==m-1 && j==n-1) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        dp[i][j] = find(dp, m, n, i+1, j) + find(dp, m, n, i, j+1);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return find(dp, m, n, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 1));\\n        if(m==1 && n==1) return 1;\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=0;\\n                dp[i][j] += dp[i+1][j];\\n                dp[i][j] += dp[i][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(2, vector<int>(n, 1));\\n        int f=(m-2)&1;\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[f][j] = dp[!f][j] + dp[f][j+1];\\n            }\\n            f=!f;\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974532,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nl, ml, dp[105][105];\\n\\n    bool valid(int x, int y) {\\n        if(x < nl and y < ml) return true;\\n        else return false;\\n    }\\n\\n    int solve(int i, int j) {\\n        if(!valid(i, j)) return 0;\\n        if(i >= nl-1 and j >= ml-1) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = solve(i+1, j) + solve(i, j+1);\\n        return dp[i][j] = ans;\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        nl = m, ml = n;\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nl, ml, dp[105][105];\\n\\n    bool valid(int x, int y) {\\n        if(x < nl and y < ml) return true;\\n        else return false;\\n    }\\n\\n    int solve(int i, int j) {\\n        if(!valid(i, j)) return 0;\\n        if(i >= nl-1 and j >= ml-1) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = solve(i+1, j) + solve(i, j+1);\\n        return dp[i][j] = ans;\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n        nl = m, ml = n;\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815421,
                "title": "java-runtime-0ms-faster-than-100-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return helper(m, n, new int[m + 1][n + 1]);\\n    }\\n\\n    private int helper(int m, int n, int[][] arr) {\\n        if (m < 1 || n < 1) return 0;\\n        if (m == 1 && n == 1) return 1;\\n\\n        if (arr[m][n] != 0) return arr[m][n];\\n        arr[m][n] = helper(m - 1, n, arr) + helper(m, n - 1, arr);\\n\\n        return arr[m][n];\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a64975ed-3362-45cd-b513-c550863466b2_1668474983.0550408.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return helper(m, n, new int[m + 1][n + 1]);\\n    }\\n\\n    private int helper(int m, int n, int[][] arr) {\\n        if (m < 1 || n < 1) return 0;\\n        if (m == 1 && n == 1) return 1;\\n\\n        if (arr[m][n] != 0) return arr[m][n];\\n        arr[m][n] = helper(m - 1, n, arr) + helper(m, n - 1, arr);\\n\\n        return arr[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760831,
                "title": "recursion-memo-dp-clean-javascript-explain",
                "content": "Since we can only move to the right or down, the number of paths from any point is equal to the sum of the paths from the right cell and bottom cell. And there are zero possible paths outside the map.\\n\\n![image](https://assets.leetcode.com/users/images/66ab31aa-c2f7-4d60-b01d-cca55d67e47b_1667153620.739161.png)\\n\\nSo we can use recursion and memoization to prevent re-calculations.\\n``` javascript\\nfunction uniquePaths(m, n) {\\n    // generate map\\n    const cache = Array.from({length: m}, e => Array(n));\\n    cache[m-1][n-1] = 1;\\n    \\n    function cellCalc(x, y) {\\n        // if not in chache then calc\\n        if (!cache[x][y]) {\\n            cache[x][y] = \\n                // if out of map then + 0\\n                (x < m - 1 ? cellCalc(x + 1, y) : 0) + \\n                (y < n - 1 ? cellCalc(x, y + 1) : 0);\\n        }\\n        return cache[x][y];\\n    }\\n    \\n    return cellCalc(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` javascript\\nfunction uniquePaths(m, n) {\\n    // generate map\\n    const cache = Array.from({length: m}, e => Array(n));\\n    cache[m-1][n-1] = 1;\\n    \\n    function cellCalc(x, y) {\\n        // if not in chache then calc\\n        if (!cache[x][y]) {\\n            cache[x][y] = \\n                // if out of map then + 0\\n                (x < m - 1 ? cellCalc(x + 1, y) : 0) + \\n                (y < n - 1 ? cellCalc(x, y + 1) : 0);\\n        }\\n        return cache[x][y];\\n    }\\n    \\n    return cellCalc(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740482,
                "title": "python-one-liner",
                "content": "We can consider this as a permutation/combination problem. If the matrix has `m` rows and `n` columns, any path we take will include `m-1` down steps and `n-1` right steps. The problem of finding number of unique paths is essentially number of ways to arrange these steps we take. Since all the down steps are identical and similarly all the right steps are identical it doesn matter the internal ordering of all the down steps (similarly true for the right steps). Essentialy we want to find number of unique ways to arrange `m-1` identical objects and `n-1` identical objects with each other, which becomes `(m-1+n-1)!/((m-1)!*(n-1)!)`.\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return math.factorial(m+n-2) / (math.factorial(m-1) * math.factorial(n-1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return math.factorial(m+n-2) / (math.factorial(m-1) * math.factorial(n-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693671,
                "title": "c-easy-fast-and-shortest-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<vector<int>> &dp)\\n    {\\n        if(i==0 or j==0) return 1;\\n        return dp[i-1][j] + dp[i][j-1];\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int> (m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        dp[i][j] = solve(i,j,dp);\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<vector<int>> &dp)\\n    {\\n        if(i==0 or j==0) return 1;\\n        return dp[i-1][j] + dp[i][j-1];\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(n, vector<int> (m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        dp[i][j] = solve(i,j,dp);\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445553,
                "title": "dp-all-techniques-memoization-and-tabulation-and-tabulation-with-space-optimization",
                "content": "Memoization:\\n```\\nint f (int row, int col, vector<vector<int>> &dp) {\\n        if (row == 0 || col == 0 ) return 1;\\n        if (dp[row][col] != 1) return dp[row][col];\\n        return dp[row][col] = f(row-1, col,dp) + f(row, col-1,dp);\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m, vector<int> (n,1));\\n        return f(m-1, n-1,dp);\\n    }\\n```\\nTime Complexity: O(NxM)\\nSpace Complexity: O(NxM) + O(N+M)\\n(O(NxM) for dp grid and  O(N+M) for extra stack space)\\nThe extra stack space can be reduced by using Tabulation Method.\\n\\nTabulation:\\n```\\nint uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m, vector<int> (n,1));\\n        \\n        for (int j=1;j<n;j++) {\\n            for (int i=1;i<m;i++) {\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n            \\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n```\\nTime Complexity: O (NxM)\\nSpace Complexity: O (NxM)\\n\\nNow, the space used by the dp grid can also be optimized. We observe that we only need the values from dp grid from last column and current column. So, instead of the whole dp grid we can just store the values from last column and current column in two vectors.\\n\\nTabulation with Space Optimization: \\n```\\nint uniquePaths(int m, int n) {\\n        vector<int> last (m,1);\\n        \\n        for (int j=1;j<n;j++) {\\n            vector<int> curr (m,1);\\n            for (int i=1;i<m;i++) {\\n                curr[i] = last[i] + curr[i-1];\\n            }\\n            last = curr;\\n        }\\n        \\n        return last[m-1];\\n    }\\n```\\nTime Complexity: O(MxN)\\nSpace Complexity: O(M)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint f (int row, int col, vector<vector<int>> &dp) {\\n        if (row == 0 || col == 0 ) return 1;\\n        if (dp[row][col] != 1) return dp[row][col];\\n        return dp[row][col] = f(row-1, col,dp) + f(row, col-1,dp);\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m, vector<int> (n,1));\\n        return f(m-1, n-1,dp);\\n    }\\n```\n```\\nint uniquePaths(int m, int n) {\\n        vector<vector<int>> dp (m, vector<int> (n,1));\\n        \\n        for (int j=1;j<n;j++) {\\n            for (int i=1;i<m;i++) {\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n            }\\n            \\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n```\n```\\nint uniquePaths(int m, int n) {\\n        vector<int> last (m,1);\\n        \\n        for (int j=1;j<n;j++) {\\n            vector<int> curr (m,1);\\n            for (int i=1;i<m;i++) {\\n                curr[i] = last[i] + curr[i-1];\\n            }\\n            last = curr;\\n        }\\n        \\n        return last[m-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363681,
                "title": "java-easy-dp-solution-o-n-m",
                "content": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int [][]matrix = new int[m][n];\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                if (i==0 || j==0)matrix[i][j]=1;\\n                else matrix[i][j]=matrix[i-1][j]+matrix[i][j-1];\\n            }\\n        }\\n        return matrix[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int [][]matrix = new int[m][n];\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                if (i==0 || j==0)matrix[i][j]=1;\\n                else matrix[i][j]=matrix[i-1][j]+matrix[i][j-1];\\n            }\\n        }\\n        return matrix[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363489,
                "title": "java-4-liner-solution-without-dp",
                "content": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n      long ans = 1;\\n      \\nfor(int i = m + n - 2, j = 1; i >= Math.max(m, n); i --, j ++)\\nans = (ans * i) / j;\\n      \\nreturn (int)ans;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n      long ans = 1;\\n      \\nfor(int i = m + n - 2, j = 1; i >= Math.max(m, n); i --, j ++)\\nans = (ans * i) / j;\\n      \\nreturn (int)ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362994,
                "title": "dp-top-down-bottom-up-space-reduction-explained",
                "content": "If you found this helpful, please upvote <3\\n\\n<hr />\\n\\nThis is a dynamic programming problem, how do we identify?\\n\\nAt any position in the grid `r, c` (row, column) we can ask how many paths we have to reach the end of the grid.\\n\\nThis is a `subproblem statement`, which is independent of the previous problems.\\n\\nAlso there is an `optimal substructure`, possible **unique paths**.\\n\\n# Transition\\nWe stand at the starting cell 0,0.\\n\\nWe have 2 choices: go right or go down.\\n\\nWhenever we reach the end, `row == m-1 and col == n-1` we found a path to the end, we return 1.\\n\\n# Top down\\nUse memoization to lookup answers to already solved subproblems.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def dp_memo(r, c):\\n\\t\\t\\t# base case - reached the end\\n            if r == m-1 and c == n-1:\\n                return 1\\n            \\n            ans = 0\\n            for nr, nc in [(r+1, c), (r, c+1)]:\\n\\t\\t\\t\\t# if inbound\\n                if 0 <= nr < m and 0 <= nc < n:\\n                    ans += dp_memo(nr, nc)\\n            return ans\\n            \\n        return dp_memo(0, 0)\\n```\\n\\n# Bottom up\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # base case, bottom row and most right column\\n        for i in range(n):\\n            dp[-1][i] = 1\\n        \\n        for j in range(m):\\n            dp[j][-1] = 1\\n            \\n        # transition\\n        for r in range(m-2, -1, -1):\\n            for c in range(n-2, -1, -1):\\n                for nr, nc in [(r+1, c), (r, c+1)]:\\n                    dp[r][c] += dp[nr][nc]\\n        \\n        return dp[0][0]\\n```\\n\\n# Space reduction\\nWe can see that our dp transition is only based on the previous row, or the previous column.\\n\\nWe can reduce the `m*n` dp array into a 1D array.\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # base case, bottom row and most right column\\n        prev_row = [1] * n\\n            \\n        # transition\\n        for r in range(m-2, -1, -1):\\n            cur_row = [0] * n\\n            # base case, last column is 1\\n            cur_row[-1] = 1\\n            \\n            for c in range(n-2, -1, -1):\\n                cur_row[c] += prev_row[c] + cur_row[c+1]\\n        \\n            prev_row = cur_row\\n            \\n        return prev_row[0]\\n```\\n\\n\\n<hr />\\n\\nHave a fantastic day",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def dp_memo(r, c):\\n\\t\\t\\t# base case - reached the end\\n            if r == m-1 and c == n-1:\\n                return 1\\n            \\n            ans = 0\\n            for nr, nc in [(r+1, c), (r, c+1)]:\\n\\t\\t\\t\\t# if inbound\\n                if 0 <= nr < m and 0 <= nc < n:\\n                    ans += dp_memo(nr, nc)\\n            return ans\\n            \\n        return dp_memo(0, 0)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # base case, bottom row and most right column\\n        for i in range(n):\\n            dp[-1][i] = 1\\n        \\n        for j in range(m):\\n            dp[j][-1] = 1\\n            \\n        # transition\\n        for r in range(m-2, -1, -1):\\n            for c in range(n-2, -1, -1):\\n                for nr, nc in [(r+1, c), (r, c+1)]:\\n                    dp[r][c] += dp[nr][nc]\\n        \\n        return dp[0][0]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # base case, bottom row and most right column\\n        prev_row = [1] * n\\n            \\n        # transition\\n        for r in range(m-2, -1, -1):\\n            cur_row = [0] * n\\n            # base case, last column is 1\\n            cur_row[-1] = 1\\n            \\n            for c in range(n-2, -1, -1):\\n                cur_row[c] += prev_row[c] + cur_row[c+1]\\n        \\n            prev_row = cur_row\\n            \\n        return prev_row[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362815,
                "title": "easy-solution-using-combinatorics",
                "content": "This is a combinatorial problem and can be solved without DP. For mxn grid, robot has to move exactly m-1 steps down and n-1 steps right and these can be done in any order.\\n\\nFor the eg., given in question, 3x7 matrix, robot needs to take 2+6 = 8 steps with 2 down and 6 right in any order. That is nothing but a permutation problem. Denote down as \\'D\\' and right as \\'R\\', following is one of the path :-\\n\\nD R R R D R R R\\n\\nWe have to tell the total number of permutations of the above given word. So, decrease both m & n by 1 and apply following formula:-\\n\\nTotal permutations = (m+n)! / (m! * n!)\\n\\nFollowing is my code doing the same :-\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N=m+n-2;\\n        int R=min(m-1,n-1);\\n        \\n        double ans=1;\\n        \\n        for(int i=1;i<=R;++i)\\n            ans = ans*(N--)/i;\\n        \\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int N=m+n-2;\\n        int R=min(m-1,n-1);\\n        \\n        double ans=1;\\n        \\n        for(int i=1;i<=R;++i)\\n            ans = ans*(N--)/i;\\n        \\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298605,
                "title": "python-4-approaches-entire-dp",
                "content": "**Recursion -> TLE\\nTime Complexity: O(2^M*N)\\nSpace Complexity: O(Path Length)\\nwhere, Path Length = (M+1)+(N+1)**\\n\\n```\\ndef f(i,j):\\n    \\n    if(i == 0 and j == 0):\\n        return 1\\n    \\n    if(i < 0 or j < 0):\\n        return 0\\n    \\n    up = f(i-1,j)\\n    left = f(i,j-1)\\n    \\n    return up+left\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        return f(m-1,n-1)\\n```\\n\\n**Memoization**\\n**Time Complexity: O(M*N)**\\n**Space Complexity: O((N-1)+(M-1)) + O(M*N)**\\n\\n```\\ndef f(i,j,dp):\\n    \\n    if(i == 0 and j == 0):\\n        return 1\\n    \\n    if(i < 0 or j < 0):\\n        return 0\\n    \\n    if(dp[i][j] != -1):\\n        return dp[i][j]\\n    \\n    up = f(i-1,j,dp)\\n    left = f(i,j-1,dp)\\n    \\n    dp[i][j] = up + left\\n    \\n    return dp[i][j]\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        dp = [[-1] * n for x in range(m)]\\n        \\n        return f(m-1,n-1,dp)\\n```\\n\\n**Tabulation**\\n**Time Complexity: O(M*N)**\\n**Space Complexity: O(M*N)**\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        dp = [[-1] * n for x in range(m)]\\n        \\n        for i in range(0,m):\\n            for j in range(0,n):\\n                \\n                if(i==0 and j==0):\\n                    dp[i][j] =1\\n                    \\n                else:\\n                    up,left = 0,0\\n                    if(i>0):\\n                        \\n                        up = dp[i-1][j]\\n                    if(j>0):\\n                        \\n                        left = dp[i][j-1]\\n                        \\n                    dp[i][j] = up+left\\n                    \\n        return dp[m-1][n-1]\\n```\\n\\n**Tabulation with SPACE OPTIMIZED**\\n**Time Complexity: O(M*N)**\\n**Space Complexity: O(N)**\\n\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        prev = [0] * n\\n        for i in range(0,m):\\n            curr = [0] * n\\n            for j in range(0,n):\\n                \\n                if(i==0 and j==0):\\n                    curr[j] = 1\\n                    \\n                else:\\n                    up,left = 0,0\\n                    \\n                    if(i>0):\\n                        up = prev[j]\\n                    if(j>0):\\n                        \\n                        left = curr[j-1]\\n                    curr[j] = up+left\\n                    \\n            prev = [x for x in curr]        \\n                    \\n        return prev[n-1]\\n```\\n\\n**Please upvote if you find it useful !!!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef f(i,j):\\n    \\n    if(i == 0 and j == 0):\\n        return 1\\n    \\n    if(i < 0 or j < 0):\\n        return 0\\n    \\n    up = f(i-1,j)\\n    left = f(i,j-1)\\n    \\n    return up+left\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        return f(m-1,n-1)\\n```\n```\\ndef f(i,j,dp):\\n    \\n    if(i == 0 and j == 0):\\n        return 1\\n    \\n    if(i < 0 or j < 0):\\n        return 0\\n    \\n    if(dp[i][j] != -1):\\n        return dp[i][j]\\n    \\n    up = f(i-1,j,dp)\\n    left = f(i,j-1,dp)\\n    \\n    dp[i][j] = up + left\\n    \\n    return dp[i][j]\\n\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        dp = [[-1] * n for x in range(m)]\\n        \\n        return f(m-1,n-1,dp)\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        dp = [[-1] * n for x in range(m)]\\n        \\n        for i in range(0,m):\\n            for j in range(0,n):\\n                \\n                if(i==0 and j==0):\\n                    dp[i][j] =1\\n                    \\n                else:\\n                    up,left = 0,0\\n                    if(i>0):\\n                        \\n                        up = dp[i-1][j]\\n                    if(j>0):\\n                        \\n                        left = dp[i][j-1]\\n                        \\n                    dp[i][j] = up+left\\n                    \\n        return dp[m-1][n-1]\\n```\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        \\n        prev = [0] * n\\n        for i in range(0,m):\\n            curr = [0] * n\\n            for j in range(0,n):\\n                \\n                if(i==0 and j==0):\\n                    curr[j] = 1\\n                    \\n                else:\\n                    up,left = 0,0\\n                    \\n                    if(i>0):\\n                        up = prev[j]\\n                    if(j>0):\\n                        \\n                        left = curr[j-1]\\n                    curr[j] = up+left\\n                    \\n            prev = [x for x in curr]        \\n                    \\n        return prev[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252966,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n// Brute-Force Solution :: Using Recursion :: Time : O(2^(max(m,n))) :: Aux_Space : O(2^(max(m,n))) [Stack Space]\\n\\nclass Solution {\\npublic:\\n\\n    int countPaths(int i,int j,int m,int n){\\n\\n        if(i == (n-1) && j == (m-1))\\n            return 1;\\n\\n        if(i >= n || j>=m)\\n            return 0;\\n        else\\n            return countPaths(i+1,j,m,n) + countPaths(i,j+1,m,n);\\n\\n\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n\\n        int i=0,j=0;\\n\\n        return countPaths(i,j,m,n);\\n\\n    }\\n};\\n\\n// Better Solution :: Using Dynamic Programming :: Time : O(M*N) :: Aux_Space : O(M*N)\\n\\nclass Solution {\\npublic:\\n\\n    int countPaths(int i,int j,int m,int n, vector<vector<int>> &dp){\\n\\n        if(i >= n || j>=m)\\n            return 0;\\n\\n        if(i == (n-1) && j == (m-1))\\n            return 1;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        return dp[i][j] = countPaths(i+1,j,m,n,dp) + countPaths(i,j+1,m,n,dp);\\n    }\\n\\n    int uniquePaths(int m, int n) {\\n\\n        int i=0,j=0;\\n\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n\\n        return countPaths(i,j,m,n,dp);\\n\\n    }\\n};\\n\\n// Efficient Solution :: Using Combinations :: Time : O(M-1) || O(N-1) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n\\n        int N = m+n-2;\\n\\n        int r = m-1;\\n        double res = 1;\\n\\n        for(int i=1;i<=r;i++){\\n            res = res * (N-r+i)/i;\\n        }\\n        return (int)res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countPaths(int i,int j,int m,int n){\\n\\n        if(i == (n-1) && j == (m-1))\\n            return 1;\\n\\n        if(i >= n || j>=m)\\n            return 0;\\n        else\\n            return countPaths(i+1,j,m,n) + countPaths(i,j+1,m,n);\\n\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2225531,
                "title": "recursive-memo-hashmap-2d-dp-tabulation",
                "content": "RECURSION\\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n       return solve(m-1,n-1);\\n    }\\n    private int solve(int si, int sj){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        int op1 = solve(si-1, sj);\\n        int op2 = solve(si, sj-1);\\n        return op1+op2;\\n    }\\n}\\n```\\nMEMO => HASHMAP\\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        return solve(m-1,n-1, map);\\n    }\\n    private int solve(int si, int sj, HashMap<String, Integer> map){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        String key = si+\"$\"+sj;\\n        if(map.containsKey(key)) return map.get(key);\\n        int op1 = solve(si-1, sj, map);\\n        int op2 = solve(si, sj-1, map);\\n        map.put(key, op1+op2);\\n        return op1+op2;\\n    }\\n}\\n```\\nMEMO => 2D DP ARRAY\\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        return solve(m-1,n-1, dp);\\n    }\\n    private int solve(int si, int sj, int[][] dp){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        if(dp[si][sj] != 0) return dp[si][sj];\\n        int op1 = solve(si-1, sj, dp);\\n        int op2 = solve(si, sj-1, dp);\\n        dp[si][sj] = op1 + op2;\\n        return op1+op2;\\n    }\\n}\\n```\\nTABULATION\\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 || j==0) dp[i][j] = 1;\\n                else{\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n       return solve(m-1,n-1);\\n    }\\n    private int solve(int si, int sj){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        int op1 = solve(si-1, sj);\\n        int op2 = solve(si, sj-1);\\n        return op1+op2;\\n    }\\n}\\n```\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        return solve(m-1,n-1, map);\\n    }\\n    private int solve(int si, int sj, HashMap<String, Integer> map){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        String key = si+\"$\"+sj;\\n        if(map.containsKey(key)) return map.get(key);\\n        int op1 = solve(si-1, sj, map);\\n        int op2 = solve(si, sj-1, map);\\n        map.put(key, op1+op2);\\n        return op1+op2;\\n    }\\n}\\n```\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        return solve(m-1,n-1, dp);\\n    }\\n    private int solve(int si, int sj, int[][] dp){\\n        if(si == 0 && sj == 0) return 1;\\n        if(si < 0 || sj < 0) return 0;\\n        if(dp[si][sj] != 0) return dp[si][sj];\\n        int op1 = solve(si-1, sj, dp);\\n        int op2 = solve(si, sj-1, dp);\\n        dp[si][sj] = op1 + op2;\\n        return op1+op2;\\n    }\\n}\\n```\n```\\nclass Solution {   \\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 || j==0) dp[i][j] = 1;\\n                else{\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212649,
                "title": "simple-c-clean-code-dp-and-recursion-memorization-easy-understanding",
                "content": "**We will try to build dp grid of given m*n size and try to fill it accordingly.**\\n**We can see in question that we can either move down or right only.\\nSo to reach any cell of first row or first column we only one way to reach there.\\nNow for other cells say cell[1][1]  we can reach there in cell[0][1]+cell[1][0] ways.\\nso at last the value at cell[m-1][n-1] will be our ans.\\nFor clear understanding take a look at image below.**\\n![image](https://assets.leetcode.com/users/images/2586eea7-5f90-480f-b94b-351830c404eb_1656486252.4715111.png)\\nhere if we are at any cell in first row or column we can reach there in one way only.\\nand we have updated dp matrix according to approch explained above.\\n\\n**DP CODE**\\n```\\nclass Solution {\\npublic:\\n\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int>(n,1));\\n        {\\n            for(int  i = 1;i < m;i++)\\n            {\\n                for(int j = 1;j < n;j++)\\n                {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n                }\\n            }\\n            return dp[m-1][n-1];\\n        }\\n    }\\n};\\n```\\n\\n\\n**Recursion + Memoization**\\n```\\nclass Solution {\\npublic:\\n    \\n    int giveMePathCount(int row, int col,int m, int  n, vector<vector<int>> &dp)\\n    {\\n        if(row >= m  || col >= n){\\n            return 0;\\n        }\\n        if(row == m - 1 && col == n - 1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(dp[row][col] != -1)return dp[row][col];\\n        \\n        return dp[row][col] = giveMePathCount(row + 1, col, m, n, dp) + giveMePathCount(row, col + 1, m, n, dp);\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return giveMePathCount(0, 0, m, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int>(n,1));\\n        {\\n            for(int  i = 1;i < m;i++)\\n            {\\n                for(int j = 1;j < n;j++)\\n                {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n                }\\n            }\\n            return dp[m-1][n-1];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int giveMePathCount(int row, int col,int m, int  n, vector<vector<int>> &dp)\\n    {\\n        if(row >= m  || col >= n){\\n            return 0;\\n        }\\n        if(row == m - 1 && col == n - 1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(dp[row][col] != -1)return dp[row][col];\\n        \\n        return dp[row][col] = giveMePathCount(row + 1, col, m, n, dp) + giveMePathCount(row, col + 1, m, n, dp);\\n    }\\n    \\n    int uniquePaths(int m, int n) \\n    {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return giveMePathCount(0, 0, m, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126442,
                "title": "faster-than-100-c-java-both",
                "content": "*Brut-Forces ( It\\'s give TLE )*\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j){\\n        if(i==0 and j==0)   return 1;\\n        if(i<0 or j<0)    return 0;\\n        return f(i-1, j) + f(i, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return f(m-1, n-1);\\n    }\\n};\\n//*If you find helpful please upvote\\n```\\n\\n*Steps to memoize a recursive solution: O(N*M)*\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>> &dp){\\n        if(i==0 and j==0)   return 1;\\n        if(i<0 or j<0)    return 0;\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n        \\n        return dp[i][j] = f(i-1, j, dp) + f(i, j-1, dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return f(m-1, n-1, dp);\\n    }\\n\\t//*If you find helpful please upvote\\n};\\n```\\n\\n*Steps to convert Recursive Solution to Tabulation one.*\\n```\\nint uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==0 and j==0) dp[i][j]=1;\\n                else{\\n                    int up=0, down=0;\\n                    if(i>0) up = dp[i-1][j];\\n                    if(j>0) down = dp[i][j-1];\\n                    dp[i][j]= up + down;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n\\t\\t//*If you find helpful please upvote\\n    }\\n```\\n\\n*Space Optimization*\\n```\\nint countWays(int m, int n){\\n    vector<int> prev(n,0);\\n    for(int i=0; i<m; i++){\\n        vector<int> temp(n,0);\\n        for(int j=0; j<n; j++){\\n            if(i==0 && j==0){\\n                temp[j]=1;\\n                continue;\\n            }\\n            \\n            int up=0;\\n            int left =0;\\n            \\n            if(i>0)\\n                up = prev[j];\\n            if(j>0)\\n                left = temp[j-1];\\n                \\n            temp[j] = up + left;\\n        }\\n        prev = temp;\\n    }\\n    \\n    return prev[n-1];\\n    //*If you find helpful please upvote\\n}\\n```\\n\\nJava Code\\n```\\nstatic int countWaysUtil(int i, int j, int[][] dp) {\\n  if(i==0 && j == 0)\\n    return 1;\\n  if(i<0 || j<0)\\n    return 0;\\n  if(dp[i][j]!=-1) return dp[i][j];\\n    \\n  int up = countWaysUtil(i-1,j,dp);\\n  int left = countWaysUtil(i,j-1,dp);\\n  \\n  return dp[i][j] = up+left;\\n  \\n}\\n\\nstatic int countWays(int m, int n){\\n    int dp[][]=new int[m][n];\\n    for (int[] row : dp)\\n        Arrays.fill(row, -1);\\n    return countWaysUtil(m-1,n-1,dp);\\n    \\n\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j){\\n        if(i==0 and j==0)   return 1;\\n        if(i<0 or j<0)    return 0;\\n        return f(i-1, j) + f(i, j-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return f(m-1, n-1);\\n    }\\n};\\n//*If you find helpful please upvote\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>> &dp){\\n        if(i==0 and j==0)   return 1;\\n        if(i<0 or j<0)    return 0;\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n        \\n        return dp[i][j] = f(i-1, j, dp) + f(i, j-1, dp);\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return f(m-1, n-1, dp);\\n    }\\n\\t//*If you find helpful please upvote\\n};\\n```\n```\\nint uniquePaths(int m, int n) {\\n        int dp[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==0 and j==0) dp[i][j]=1;\\n                else{\\n                    int up=0, down=0;\\n                    if(i>0) up = dp[i-1][j];\\n                    if(j>0) down = dp[i][j-1];\\n                    dp[i][j]= up + down;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n\\t\\t//*If you find helpful please upvote\\n    }\\n```\n```\\nint countWays(int m, int n){\\n    vector<int> prev(n,0);\\n    for(int i=0; i<m; i++){\\n        vector<int> temp(n,0);\\n        for(int j=0; j<n; j++){\\n            if(i==0 && j==0){\\n                temp[j]=1;\\n                continue;\\n            }\\n            \\n            int up=0;\\n            int left =0;\\n            \\n            if(i>0)\\n                up = prev[j];\\n            if(j>0)\\n                left = temp[j-1];\\n                \\n            temp[j] = up + left;\\n        }\\n        prev = temp;\\n    }\\n    \\n    return prev[n-1];\\n    //*If you find helpful please upvote\\n}\\n```\n```\\nstatic int countWaysUtil(int i, int j, int[][] dp) {\\n  if(i==0 && j == 0)\\n    return 1;\\n  if(i<0 || j<0)\\n    return 0;\\n  if(dp[i][j]!=-1) return dp[i][j];\\n    \\n  int up = countWaysUtil(i-1,j,dp);\\n  int left = countWaysUtil(i,j-1,dp);\\n  \\n  return dp[i][j] = up+left;\\n  \\n}\\n\\nstatic int countWays(int m, int n){\\n    int dp[][]=new int[m][n];\\n    for (int[] row : dp)\\n        Arrays.fill(row, -1);\\n    return countWaysUtil(m-1,n-1,dp);\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466475,
                "title": "recursion-memoization-tabulation-c",
                "content": "**Plain Recursion**\\n```\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n\\t/* base condition */\\n    if (m == 1 or n == 1)\\n        return 1;\\n\\t\\n\\t/* recursive call*/\\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\\n}\\n\\n// Driver code\\nint main()\\n{\\n\\t// Given numbers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```\\n\\n**Memoization**\\n\\n```\\n// Global memo array\\nint memo[100][100];\\n\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n    /* base condition */\\n    if (m == 1 or n == 1)\\n        return 1;\\n\\n    /* check in memo array */\\n    if (memo[m][n])\\n        return memo[m][n];\\n\\n    /* recursive call*/\\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // initialize memo arry\\n    memset(memo, 0, sizeof(memo));\\n\\n    // Given numbers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```\\n\\n**Tabulation**\\n\\n```\\n// Global dp array\\nint dp[100][100];\\n\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n    /* initialize first row and first column */\\n    for (int i = 0; i < m; i++)\\n        for (int j = 0; j < n; j++)\\n            if (i == 0 or j == 0)\\n                dp[i][j] = 1;\\n\\n    /* logic: */\\n    for (int i = 1; i < m; i++)\\n        for (int j = 1; j < n; j++)\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n\\n    /* result */\\n    return dp[m - 1][n - 1];\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // Given numers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n\\t/* base condition */\\n    if (m == 1 or n == 1)\\n        return 1;\\n\\t\\n\\t/* recursive call*/\\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\\n}\\n\\n// Driver code\\nint main()\\n{\\n\\t// Given numbers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```\n```\\n// Global memo array\\nint memo[100][100];\\n\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n    /* base condition */\\n    if (m == 1 or n == 1)\\n        return 1;\\n\\n    /* check in memo array */\\n    if (memo[m][n])\\n        return memo[m][n];\\n\\n    /* recursive call*/\\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // initialize memo arry\\n    memset(memo, 0, sizeof(memo));\\n\\n    // Given numbers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```\n```\\n// Global dp array\\nint dp[100][100];\\n\\n// Given function\\nint uniquePaths(int m, int n)\\n{\\n    /* initialize first row and first column */\\n    for (int i = 0; i < m; i++)\\n        for (int j = 0; j < n; j++)\\n            if (i == 0 or j == 0)\\n                dp[i][j] = 1;\\n\\n    /* logic: */\\n    for (int i = 1; i < m; i++)\\n        for (int j = 1; j < n; j++)\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n\\n    /* result */\\n    return dp[m - 1][n - 1];\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // Given numers\\n    int m = 13, n = 11;\\n    cout << uniquePaths(m, n);  // 646646\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1454615,
                "title": "from-recursive-to-dp-intuition-and-explanation",
                "content": "First, i will write down the most basic approach that might come to mind - checking all the combinations at first. At every point, we need to decide whether we go down or left, so let `i` be the x co-ordinate and `j` be the y co-ordinate. \\nSince we can move only right i.e `i` can increase or we can move down i.e. `j` can increase. \\nSo, at every point in the grid, we just have 2 choices - either to go `i+1` or to go `j+1`.\\n\\nRemember how I used the word \"or\". Since, we need to count the number of ways so the word \"or\" means `+` in numerical computations. \\nWhen do we stop? when either `i`reaches to last column or `j` reaches to last row. Hence, we have a base condition too and a logic.\\nThe recursive code:\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int m, int n, int i, int j){\\n        if(i>=n || j>=m) return 0;\\n        if(i==n-1 && j==m-1) return 1;\\n        return solve(m,n,i+1,j) + solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\\n\\nThis will ofcourse give TLE. So, to convert to dp, a good rule of thumb would be `look before you leap` i.e. check if you have the ans in table, if yes, then return and if not, then go ahead compute a new answer and save it before returning.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int m, int n, int i, int j){\\n        if(i>=n || j>=m) return 0;\\n        if(i==n-1 && j==m-1) return 1;\\n//         look before you leap\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        // save and return\\n        return dp[i][j]=solve(m,n,i+1,j) + solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int m, int n, int i, int j){\\n        if(i>=n || j>=m) return 0;\\n        if(i==n-1 && j==m-1) return 1;\\n        return solve(m,n,i+1,j) + solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return solve(m,n,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int m, int n, int i, int j){\\n        if(i>=n || j>=m) return 0;\\n        if(i==n-1 && j==m-1) return 1;\\n//         look before you leap\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        // save and return\\n        return dp[i][j]=solve(m,n,i+1,j) + solve(m,n,i,j+1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(m,n,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112519,
                "title": "c-dp-100-faster-unique-paths",
                "content": "```int uniquePaths(int m, int n) {\\n        int dp[n][m];\\n        for(int  i = 0 ; i < m ; i++){\\n            dp[n-1][i] = 1;\\n        }\\n        for(int  i = 0 ; i < n ; i++){\\n            dp[i][m-1] = 1;\\n        }\\n        for(int  i = n-2 ; i>=0 ; i--){\\n            for(int  j = m-2 ; j>=0 ; j--){\\n                /*Total number of ways to reach (i,j) grid equal to\\n                Total no of ways to reach (i+1,j)+(i,j+1) grid*/\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```int uniquePaths(int m, int n) {\\n        int dp[n][m];\\n        for(int  i = 0 ; i < m ; i++){\\n            dp[n-1][i] = 1;\\n        }\\n        for(int  i = 0 ; i < n ; i++){\\n            dp[i][m-1] = 1;\\n        }\\n        for(int  i = n-2 ; i>=0 ; i--){\\n            for(int  j = m-2 ; j>=0 ; j--){\\n                /*Total number of ways to reach (i,j) grid equal to\\n                Total no of ways to reach (i+1,j)+(i,j+1) grid*/\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 983132,
                "title": "java-solution",
                "content": "java\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=1;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                \\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i=0;i<n;i++)\\n            dp[0][i]=1;\\n        for(int i=0;i<m;i++)\\n            dp[i][0]=1;\\n        \\n        for(int i=1;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                \\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711761,
                "title": "java-runtime-o-m-n-space-o-1-combinatorics-solution",
                "content": "This solution uses the combinatorics theorems to quickly calculate the number of unique paths. \\n\\nIn this problem, you\\'re limited to choosing a *right* move, or a *down* move - both of which take you in the right direction. There will be (n-1) *right moves* and (m-1) *down moves* in any path from start to finish. Let a *right move* be represented by the character `X` and a *down move* be represented by the character `O`. \\n\\n*Let m=3, n=4*.  The problem becomes *\"how many unique permutations of the String `\\'OOXXX\\'` exist?\"*\\n\\nThis is a well-studied and well-known problem in combinatorics and you may have studied this if you\\'ve taken a combinatorics class before. Here\\'s the theorem used to solve this problem. \\n![image](https://assets.leetcode.com/users/images/ffbeecd8-9f61-41c1-bbb3-f517c11d2c87_1593443864.6758277.png)\\n\\nNow for my code, there are cleaner ways to implement, and faster ways to implement, but this code is concise and clear. It is not difficult to follow what\\'s going on once you know the theorem being used.\\n```java\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        //numerator = total moves! = ((m-1) + (n - 1))! = (m+n-2)! (as a BigInteger because factorials get out of hand quickly)\\n\\t\\t//BigInteger String constructor is easy to use. So we\\'ll convert the number to a String and pass to BigInteger constructor, which is sent to factorial function\\n        BigInteger numerator = bigFact(new BigInteger(String.valueOf(m + n - 2)));\\n\\t\\t\\n\\t\\t//we only have 2 classes of indistinguishable objects (down moves and right moves)\\n\\t\\t//denom1 is the first factorial of the denominator\\n        BigInteger denom1 = bigFact(new BigInteger(String.valueOf(m-1)));\\n\\t\\t\\n\\t\\t//denom2 is the second factorial of the denominator\\n        BigInteger denom2 = bigFact(new BigInteger(String.valueOf(n-1)));\\n\\t\\t\\n\\t\\t//denom is both denominator terms multiplied together\\n        BigInteger denom = denom1.multiply(denom2);\\n\\t\\t\\n\\t\\t//result is the numerator divided by the denominator (obviously)\\n        BigInteger result = numerator.divide(denom);\\n        return result.intValueExact();\\n    }\\n    \\n\\t//BigInteger Factorial function\\n    public static BigInteger bigFact(BigInteger number){\\n        BigInteger result = BigInteger.ONE;\\n        while(number.compareTo(BigInteger.ONE) > 0){\\n            result = result.multiply(number);\\n            number = number.subtract(BigInteger.ONE);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        //numerator = total moves! = ((m-1) + (n - 1))! = (m+n-2)! (as a BigInteger because factorials get out of hand quickly)\\n\\t\\t//BigInteger String constructor is easy to use. So we\\'ll convert the number to a String and pass to BigInteger constructor, which is sent to factorial function\\n        BigInteger numerator = bigFact(new BigInteger(String.valueOf(m + n - 2)));\\n\\t\\t\\n\\t\\t//we only have 2 classes of indistinguishable objects (down moves and right moves)\\n\\t\\t//denom1 is the first factorial of the denominator\\n        BigInteger denom1 = bigFact(new BigInteger(String.valueOf(m-1)));\\n\\t\\t\\n\\t\\t//denom2 is the second factorial of the denominator\\n        BigInteger denom2 = bigFact(new BigInteger(String.valueOf(n-1)));\\n\\t\\t\\n\\t\\t//denom is both denominator terms multiplied together\\n        BigInteger denom = denom1.multiply(denom2);\\n\\t\\t\\n\\t\\t//result is the numerator divided by the denominator (obviously)\\n        BigInteger result = numerator.divide(denom);\\n        return result.intValueExact();\\n    }\\n    \\n\\t//BigInteger Factorial function\\n    public static BigInteger bigFact(BigInteger number){\\n        BigInteger result = BigInteger.ONE;\\n        while(number.compareTo(BigInteger.ONE) > 0){\\n            result = result.multiply(number);\\n            number = number.subtract(BigInteger.ONE);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362375,
                "title": "3-solutions-in-go-best-beats-100-time-space-dp",
                "content": "The **basic recursive approach** (time limit exceeded):\\n```\\nfunc uniquePathsRecurs(m int, n int) int {\\n    var explore func(i, j int) int\\n    explore = func(i, j int) int {\\n        if i == m && j == n {\\n            return 1\\n        }\\n        \\n        var iPaths, jPaths int\\n        if i < m {\\n            iPaths = explore(i+1, j) // move right\\n        }\\n        if j < n {\\n            jPaths = explore(i, j+1) // move down\\n        }\\n        return iPaths+jPaths\\n    }\\n    return explore(1, 1)\\n}\\n```\\n\\nThen, with **memoization**:\\n```\\nfunc uniquePathsMemo(m int, n int) int {\\n    paths := make([][]int, n)\\n    for i := 0; i < len(paths); i++ {\\n        paths[i] = make([]int, m)\\n    }\\n    paths[n-1][m-1] = 1\\n    \\n    var explore func(i, j int) int\\n    explore = func(i, j int) int {\\n        if paths[j][i] != 0 {\\n            return paths[j][i]\\n        }\\n        \\n        var iPaths, jPaths int\\n        if i < m-1 {\\n            iPaths = explore(i+1, j) // move right\\n        }\\n        if j < n-1 {\\n            jPaths = explore(i, j+1) // move down\\n        }\\n        paths[j][i] = iPaths+jPaths\\n        return iPaths+jPaths\\n    }\\n    return explore(0, 0)\\n}\\n```\\n\\nThen, with **Dynamic Programming** (bottom up processing):\\nTime: `O(m*n)`\\nSpace: `O(m*n)`\\n```\\nfunc uniquePathsDP(m int, n int) int {\\n   paths := make([][]int, n)\\n    for i := 0; i < len(paths); i++ {\\n        paths[i] = make([]int, m)\\n    }\\n    for i := 0; i < m; i++ {\\n        paths[0][i] = 1\\n    }\\n    for j := 1; j < n; j++ {\\n        paths[j][0] = 1\\n    }\\n    \\n    for i := 1; i < m; i++ {\\n        for j := 1; j < n; j++ {\\n            paths[j][i] = paths[j][i-1] + paths[j-1][i]\\n        }\\n    }\\n    \\n    return paths[n-1][m-1]\\n}\\n```\\n\\nAnd a **bonus**, moving `O(m*n)` space of the above to `O(n)`. This is based on the intuition that we only need to look at the current and previous rows when computing each cell.\\nTime: `O(m*n)`\\nSpace: `O(n)`\\n```\\nfunc uniquePaths(m int, n int) int {\\n    cur := make([]int, m)\\n    prev := make([]int, m)\\n    for i := 0; i < m; i++ {\\n        cur[i] = 1\\n        prev[i] = 1\\n    }\\n    \\n    for j := 1; j < n; j++ {\\n        for i := 1; i < m; i++ {\\n            cur[i] = cur[i-1] + prev[i]            \\n        }\\n        cur, prev = prev, cur\\n    }\\n    return prev[m-1]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc uniquePathsRecurs(m int, n int) int {\\n    var explore func(i, j int) int\\n    explore = func(i, j int) int {\\n        if i == m && j == n {\\n            return 1\\n        }\\n        \\n        var iPaths, jPaths int\\n        if i < m {\\n            iPaths = explore(i+1, j) // move right\\n        }\\n        if j < n {\\n            jPaths = explore(i, j+1) // move down\\n        }\\n        return iPaths+jPaths\\n    }\\n    return explore(1, 1)\\n}\\n```\n```\\nfunc uniquePathsMemo(m int, n int) int {\\n    paths := make([][]int, n)\\n    for i := 0; i < len(paths); i++ {\\n        paths[i] = make([]int, m)\\n    }\\n    paths[n-1][m-1] = 1\\n    \\n    var explore func(i, j int) int\\n    explore = func(i, j int) int {\\n        if paths[j][i] != 0 {\\n            return paths[j][i]\\n        }\\n        \\n        var iPaths, jPaths int\\n        if i < m-1 {\\n            iPaths = explore(i+1, j) // move right\\n        }\\n        if j < n-1 {\\n            jPaths = explore(i, j+1) // move down\\n        }\\n        paths[j][i] = iPaths+jPaths\\n        return iPaths+jPaths\\n    }\\n    return explore(0, 0)\\n}\\n```\n```\\nfunc uniquePathsDP(m int, n int) int {\\n   paths := make([][]int, n)\\n    for i := 0; i < len(paths); i++ {\\n        paths[i] = make([]int, m)\\n    }\\n    for i := 0; i < m; i++ {\\n        paths[0][i] = 1\\n    }\\n    for j := 1; j < n; j++ {\\n        paths[j][0] = 1\\n    }\\n    \\n    for i := 1; i < m; i++ {\\n        for j := 1; j < n; j++ {\\n            paths[j][i] = paths[j][i-1] + paths[j-1][i]\\n        }\\n    }\\n    \\n    return paths[n-1][m-1]\\n}\\n```\n```\\nfunc uniquePaths(m int, n int) int {\\n    cur := make([]int, m)\\n    prev := make([]int, m)\\n    for i := 0; i < m; i++ {\\n        cur[i] = 1\\n        prev[i] = 1\\n    }\\n    \\n    for j := 1; j < n; j++ {\\n        for i := 1; i < m; i++ {\\n            cur[i] = cur[i-1] + prev[i]            \\n        }\\n        cur, prev = prev, cur\\n    }\\n    return prev[m-1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329894,
                "title": "c-top-down-memoized-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int paths(int i, int j, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        if (i == m - 1 || j == n - 1)\\n            return 1;\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        dp[i][j] = paths(i + 1, j, m, n, dp) + paths(i, j + 1, m, n, dp);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n       vector<vector<int>> dp(m, vector<int>(n, -1));\\n       return paths(0, 0, m, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int paths(int i, int j, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        if (i == m - 1 || j == n - 1)\\n            return 1;\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        dp[i][j] = paths(i + 1, j, m, n, dp) + paths(i, j + 1, m, n, dp);\\n        return dp[i][j];\\n    }\\n    int uniquePaths(int m, int n) {\\n       vector<vector<int>> dp(m, vector<int>(n, -1));\\n       return paths(0, 0, m, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326002,
                "title": "go-100",
                "content": "```\\nfunc uniquePaths(m int, n int) int {\\n    \\n    result := make([][]int, m)\\n    for i:=0; i<m; i++{\\n        result[i] = make([]int,n)\\n    }\\n    \\n    for i:=0; i<m;i++{\\n        result[i][0] = 1\\n    }\\n    \\n    for j:=1; j<n; j++{\\n        result[0][j] = 1\\n    }\\n    \\n    \\n    for i:=1;i<m; i++{\\n        for j:=1; j<n; j++{\\n            result[i][j] = result[i-1][j] + result[i][j-1]\\n        }\\n    }\\n    return result[m-1][n-1]\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc uniquePaths(m int, n int) int {\\n    \\n    result := make([][]int, m)\\n    for i:=0; i<m; i++{\\n        result[i] = make([]int,n)\\n    }\\n    \\n    for i:=0; i<m;i++{\\n        result[i][0] = 1\\n    }\\n    \\n    for j:=1; j<n; j++{\\n        result[0][j] = 1\\n    }\\n    \\n    \\n    for i:=1;i<m; i++{\\n        for j:=1; j<n; j++{\\n            result[i][j] = result[i-1][j] + result[i][j-1]\\n        }\\n    }\\n    return result[m-1][n-1]\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298244,
                "title": "python-simple-1-line-solution-based-on-permutation",
                "content": "We can handle this poblem by using permutations. suppose we have 7x3 grid. So, we have to move right 6 times and down 2 times. Now, the problem is reduced to how we can arrange 6 right moves and 2 down move. This will be (6+2)! / (6! * 2!) = 8! / (6! * 2!) = 28.\\nso the formula we get is (m-1 + n-1)! / ((m-1)! * (n-1)!)\\n```\\nimport math\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return int(math.factorial(m+n-2)/(math.factorial(m-1)*math.factorial(n-1)))\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        return int(math.factorial(m+n-2)/(math.factorial(m-1)*math.factorial(n-1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257504,
                "title": "python-concise-dp-solution-with-accumulate-4-lines",
                "content": "Firstly, we can maintain a 2d matrix to store the ans.\\n\\u9996\\u5148\\u6211\\u4EEC\\u53EF\\u4EE5\\u7528\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u6570\\u7EC4\\u6765\\u4FDD\\u5B58\\u6BCF\\u4E2A\\u5355\\u5143\\u683C\\u7684\\u8D70\\u6CD5\\u3002\\n```python\\ndef uniquePaths(self, m: int, n: int) -> int:\\n    g = [[0] * m for _ in range(n)]\\n    for i in range(n):\\n        for j in range(m):\\n            if i==0 or j==0:\\n                g[i][j] = 1\\n            else:\\n                g[i][j] = g[i-1][j] + g[i][j-1]\\n        \\n    return g[-1][-1]\\n```\\nbut, 2d-matrix is unnecessary. We only need the last row to caculate current row.\\n\\u4E8C\\u7EF4\\u6570\\u7EC4\\u662F\\u6CA1\\u6709\\u5FC5\\u8981\\u7684\\uFF0C\\u5B9E\\u9645\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u6839\\u636E\\u4E0A\\u4E00\\u884C\\u6765\\u8BA1\\u7B97\\u5F53\\u524D\\u884C\\u3002\\ni.e.  m = 7, n = 3\\nthe matix is \\n```\\n[1,  1,  1,   1,   1,   1,   1]\\n[1,  2,  3,   4,   5,   6,   7]\\n[1,  3,  6,  10,  15,  21,  28]\\n```\\nThat is what the `accumulate` does.\\n`accumulate`\\u505A\\u7684\\u4E8B\\u60C5\\u5C31\\u662F\\u628A\\u5DE6\\u8FB9\\u7684\\u503C\\u548C\\u5F53\\u524D\\u503C\\u7D2F\\u8BA1\\u3002\\n```python\\ndef uniquePaths(self, m: int, n: int) -> int:\\n    row = [1] * m\\n    for _ in range(n-1):\\n        row = itertools.accumulate(row)\\n    return list(row)[-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef uniquePaths(self, m: int, n: int) -> int:\\n    g = [[0] * m for _ in range(n)]\\n    for i in range(n):\\n        for j in range(m):\\n            if i==0 or j==0:\\n                g[i][j] = 1\\n            else:\\n                g[i][j] = g[i-1][j] + g[i][j-1]\\n        \\n    return g[-1][-1]\\n```\n```\\n[1,  1,  1,   1,   1,   1,   1]\\n[1,  2,  3,   4,   5,   6,   7]\\n[1,  3,  6,  10,  15,  21,  28]\\n```\n```python\\ndef uniquePaths(self, m: int, n: int) -> int:\\n    row = [1] * m\\n    for _ in range(n-1):\\n        row = itertools.accumulate(row)\\n    return list(row)[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 162333,
                "title": "python-solution",
                "content": "Dynamic programming: O(mn) time O(mn) space\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        table = [[0]*n for _ in range(m)]\\n        for i in range(n):\\n            table[0][i] = 1\\n        for j in range(m):\\n            table[j][0] = 1\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                table[i][j] = table[i-1][j] + table[i][j-1]\\n        return table[m-1][n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        table = [[0]*n for _ in range(m)]\\n        for i in range(n):\\n            table[0][i] = 1\\n        for j in range(m):\\n            table[j][0] = 1\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                table[i][j] = table[i-1][j] + table[i][j-1]\\n        return table[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23040,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Unique Paths** https://leetcode.com/problems/unique-paths/\\n\\n**Dynamic Programming using Memoization**\\n* path[i,j] = Number of paths from [i,j] to destination\\n* path[m-1,n-1] = 1\\n* return path[0,0]\\n```\\nclass Solution(object):\\n    def helper(self, i, j, m, n, paths):\\n        if 0<=i<m and 0<=j<n:\\n            if paths[i][j] != -1:\\n                return paths[i][j]\\n            paths[i][j] = self.helper(i, j+1, m, n, paths) + self.helper(i+1, j, m, n, paths)\\n            return paths[i][j]\\n        return 0\\n    \\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        paths = [[-1]*n for _ in range(m)]\\n        paths[m-1][n-1] = 1\\n        return self.helper(0, 0, m, n, paths)\\n```\\n\\n**Dynamic Programming without Recursion**\\n* path[i,j] = Number of paths from [0,0] to [i,j].\\n* path[0,j] = 1 and path[i,0] = 1\\n* path[i,j] = path[i,j-1] + path[i-1,j]\\n* return path[m-1, n-1]\\n* We can start from row 1 and column 1 after initializing the path matrix to 1.\\n* Time and Space complexity: O(MN)\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        paths = [[1]*n for _ in range(m)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                paths[i][j] = paths[i-1][j] + paths[i][j-1]\\n        return paths[-1][-1]\\n```\\n\\n**Dynamic Programming without Recursion * Optimization**\\n* Optimization: Instead of 2D matrix, a single array can do the job and reduce space complexity to O(N)\\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        dp = [1]*n\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[j] = dp[j-1] + dp[j]\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, i, j, m, n, paths):\\n        if 0<=i<m and 0<=j<n:\\n            if paths[i][j] != -1:\\n                return paths[i][j]\\n            paths[i][j] = self.helper(i, j+1, m, n, paths) + self.helper(i+1, j, m, n, paths)\\n            return paths[i][j]\\n        return 0\\n    \\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        paths = [[-1]*n for _ in range(m)]\\n        paths[m-1][n-1] = 1\\n        return self.helper(0, 0, m, n, paths)\\n```\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        paths = [[1]*n for _ in range(m)]\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                paths[i][j] = paths[i-1][j] + paths[i][j-1]\\n        return paths[-1][-1]\\n```\n```\\nclass Solution(object):\\n    def uniquePaths(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0 or n == 0:\\n            return 0\\n        dp = [1]*n\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[j] = dp[j-1] + dp[j]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23106,
                "title": "similar-to-pascal-triangle-o-1-space-and-o-min-m-n-solution-with-image-explanation",
                "content": "![enter image description here][1]\\n\\n\\n  [1]: http://uiinventory.netne.net/LC_62.png\\n\\n    import java.math.BigInteger;\\n    \\n    public class Solution {\\n        \\n        private int comb(int n, int k) {\\n            long r = 1;\\n            for(int d = 1; d <= k; ++d) r = r * n-- / d;\\n            return (int)r;\\n        }\\n        \\n        public int uniquePaths(int m, int n) {\\n            return comb(m + n - 2, Math.min(n - 1, m - 1));\\n        }\\n    }",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n        \\n        private int comb(int n, int k) {\\n            long r = 1;\\n            for(int d = 1; d <= k; ++d) r = r * n-- / d;\\n            return (int)r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3997007,
                "title": "clean-and-understandable-java-sol-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Tabulation\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m X n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m X n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int uniquePaths(int m, int n) {\\n     int[][] dp = new int[m][n];\\n     for(int i=0; i<m ;i++){\\n      for(int j=0; j<n; j++){\\n          \\n          //base condition\\n          if(i==0 && j==0){\\n              dp[i][j]=1;\\n              continue;\\n          }\\n          \\n          int up=0;\\n          int left = 0;\\n          \\n          if(i>0) \\n            up = dp[i-1][j];\\n          if(j>0)\\n            left = dp[i][j-1];\\n            \\n          dp[i][j] = up+left;\\n      }\\n  }\\n  \\n  return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int uniquePaths(int m, int n) {\\n     int[][] dp = new int[m][n];\\n     for(int i=0; i<m ;i++){\\n      for(int j=0; j<n; j++){\\n          \\n          //base condition\\n          if(i==0 && j==0){\\n              dp[i][j]=1;\\n              continue;\\n          }\\n          \\n          int up=0;\\n          int left = 0;\\n          \\n          if(i>0) \\n            up = dp[i-1][j];\\n          if(j>0)\\n            left = dp[i][j-1];\\n            \\n          dp[i][j] = up+left;\\n      }\\n  }\\n  \\n  return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995616,
                "title": "easiest-python-solution-for-beginners-using-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The problem can be approached as a dynamic programming problem.\\n- We can calculate the number of unique paths for each cell in the grid          by summing the paths coming from the cell above it and the cell to its left.\\n        \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Define a helper function `check(i, j)` to check if a cell is within the grid.\\n- Use memoization with the `@lru_cache` decorator to optimize the recursive approach.\\n- Implement a recursive function `helper(i, j)` to calculate the number of unique paths.\\n- Start from the top-left corner (0, 0) and recursively explore all possible paths.\\n- Memoize the results to avoid redundant calculations.\\n        \\n# Complexity\\n- Time complexity:$$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Helper function to check if a cell is within the grid\\n        def check(i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n:\\n                return False\\n            return True\\n        \\n        # Recursive function with memoization\\n        @lru_cache(maxsize=None)\\n        def helper(i, j):\\n            if not check(i, j):\\n                return 0\\n            else:\\n                if j == n - 1 and i == m - 1:\\n                    return 1\\n                else:\\n                    # Move right (i, j+1) and move down (i+1, j)\\n                    return helper(i + 1, j) + helper(i, j + 1)\\n\\n        # Start from the top-left corner\\n        return helper(0, 0)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        # Helper function to check if a cell is within the grid\\n        def check(i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n:\\n                return False\\n            return True\\n        \\n        # Recursive function with memoization\\n        @lru_cache(maxsize=None)\\n        def helper(i, j):\\n            if not check(i, j):\\n                return 0\\n            else:\\n                if j == n - 1 and i == m - 1:\\n                    return 1\\n                else:\\n                    # Move right (i, j+1) and move down (i+1, j)\\n                    return helper(i + 1, j) + helper(i, j + 1)\\n\\n        # Start from the top-left corner\\n        return helper(0, 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730915,
                "title": "4-different-codes-recursion-memoisation-tabulation-space-optimisation",
                "content": "# Intuition\\nSince we can only move right or down, If we only have one row or one column then only one way is possible. Now this can be used as the base case and i can work my way up from the goal\\n\\n# Recursive Approach\\n**Will give TLE**\\nStart from the goal coordinates and either go left or move up, till you either reach the first row or first column and we already know only one way is possible to get there so return from there.\\nAt any given coordinate our answer will be the sum of the moves required to reach the coordinate just above it and just to its left.\\n# Complexity\\n- Time complexity: O(2**N)\\n\\n- Space complexity: Please help with the space complexity if possible\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        if (m < 0 || n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || m == 0) {\\n            return 1;\\n        }\\n        return solve(m-1, n) + solve(m, n-1);\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```\\n# Memoisation\\nAs evident from the recursive solution two variables are changing i.e. the row coordinate and the column coordinate.\\nThis makes it a problem of 2D dp.\\nMemoisation required 3 main steps :\\n1. Create a vector of appropriate dimensions\\n2. Store the answer in the vector\\n3. Check if answer to current subproblem is already present and return it.\\n# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N*N)\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, vector<vector<int>>& dp) {\\n        if (m < 0 || n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || m == 0) {\\n            return 1;\\n        }\\n        <!-- check if answer already present -->\\n        if (dp[m][n] != 0) {\\n            return dp[m][n];\\n        }\\n        <!-- store calculated answer -->\\n        dp[m][n] = solve(m-1, n, dp) + solve(m, n-1, dp);\\n        return dp[m][n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        <!-- make vector where each coordinate represents ways to reach it-->\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        return solve(m-1, n-1, dp);\\n    }\\n};\\n```\\n# Tabulation\\nInstead of using recursive calls use for loop to traverse the matrix and fill values. Use the base case properly i.e. the value in the first column and row should be 1.\\n# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N*N)\\n# Code \\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,1));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```\\n# Space optimisation\\nOn careful observation we can see that only two 1D vectors are required to store the answer as current answer depends on the answer of the previous row and previous column(but same row). In the previous row everywhere you see dp[i] swap it with CurrRow and everywhere you see dp[i-1] swap with previous row. At the end of the iteration swap with previous and current row vectors to prepare for the next iteration \\n# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        // vector<vector<int>> dp(m+1, vector<int>(n+1,1));\\n        vector<int> prevRow(n+1,1);\\n        for (int i = 1; i <= m; i++) {\\n            vector<int> currRow(n+1);\\n            currRow[0] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                currRow[j] = prevRow[j] + currRow[j-1];\\n            }\\n            prevRow = currRow;\\n        }\\n        return prevRow[n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        if (m < 0 || n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || m == 0) {\\n            return 1;\\n        }\\n        return solve(m-1, n) + solve(m, n-1);\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n, vector<vector<int>>& dp) {\\n        if (m < 0 || n < 0) {\\n            return 0;\\n        }\\n        if (n == 0 || m == 0) {\\n            return 1;\\n        }\\n        <!-- check if answer already present -->\\n        if (dp[m][n] != 0) {\\n            return dp[m][n];\\n        }\\n        <!-- store calculated answer -->\\n        dp[m][n] = solve(m-1, n, dp) + solve(m, n-1, dp);\\n        return dp[m][n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        <!-- make vector where each coordinate represents ways to reach it-->\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        return solve(m-1, n-1, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        vector<vector<int>> dp(m+1, vector<int>(n+1,1));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int m, int n) {\\n        // vector<vector<int>> dp(m+1, vector<int>(n+1,1));\\n        vector<int> prevRow(n+1,1);\\n        for (int i = 1; i <= m; i++) {\\n            vector<int> currRow(n+1);\\n            currRow[0] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                currRow[j] = prevRow[j] + currRow[j-1];\\n            }\\n            prevRow = currRow;\\n        }\\n        return prevRow[n];\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        return solve(m-1, n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680395,
                "title": "c-solution-dp-100-beat-with-3-approach",
                "content": "\\n\\n# Approach\\nIf the recusrion code is correct but the time limit is exceeded due to an overlapping problem, we can use the top down and bottom up approaches in the DP question. First, try the top down approach, and then try the bottom up approach.\\n\\n    any DP questions to be answered follow this flow. \\n\\n# recusrive soltution (time limit exceeded)\\n```\\n class Solution {\\n public:\\n     int uniquePaths(int m, int n) {\\n         vector<int>dp()\\n         return helper(m, n);\\n     }\\n\\n private:\\n     int helper(int m, int n) {\\n         if (m == 1 && n == 1)\\n             return 1;\\n         if (m < 1 || n < 1)\\n             return 0;\\n\\n         int count = 0;\\n         count += helper(m - 1, n);\\n         count += helper(m, n - 1);\\n\\n         return count;\\n     }\\n };\\n\\n\\n```\\n# top-down approach \\n```\\nclass Solution {\\n public:\\n     int uniquePaths(int m, int n) {\\n         vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n         return helper(m, n, dp);\\n     }\\n\\n private:\\n     int helper(int m, int n, vector<vector<int>>& dp) {\\n         if (m == 1 && n == 1) return 1;\\n         if (m < 1 || n < 1) return 0;\\n         if (dp[m][n] != -1) return dp[m][n];\\n\\n         int count = 0;\\n         count += helper(m - 1, n, dp);\\n         count += helper(m, n - 1, dp);\\n\\n         return dp[m][n] = count;\\n     }\\n };\\n```\\n# bottom-up approach \\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) continue;\\n                int count = 0;\\n                if (j - 1 >= 0) count += dp[i][j - 1];\\n                if (i - 1 >= 0) count += dp[i - 1][j];\\n                dp[i][j] = count;\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n public:\\n     int uniquePaths(int m, int n) {\\n         vector<int>dp()\\n         return helper(m, n);\\n     }\\n\\n private:\\n     int helper(int m, int n) {\\n         if (m == 1 && n == 1)\\n             return 1;\\n         if (m < 1 || n < 1)\\n             return 0;\\n\\n         int count = 0;\\n         count += helper(m - 1, n);\\n         count += helper(m, n - 1);\\n\\n         return count;\\n     }\\n };\\n\\n\\n```\n```\\nclass Solution {\\n public:\\n     int uniquePaths(int m, int n) {\\n         vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n         return helper(m, n, dp);\\n     }\\n\\n private:\\n     int helper(int m, int n, vector<vector<int>>& dp) {\\n         if (m == 1 && n == 1) return 1;\\n         if (m < 1 || n < 1) return 0;\\n         if (dp[m][n] != -1) return dp[m][n];\\n\\n         int count = 0;\\n         count += helper(m - 1, n, dp);\\n         count += helper(m, n - 1, dp);\\n\\n         return dp[m][n] = count;\\n     }\\n };\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) continue;\\n                int count = 0;\\n                if (j - 1 >= 0) count += dp[i][j - 1];\\n                if (i - 1 >= 0) count += dp[i - 1][j];\\n                dp[i][j] = count;\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569630,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 2041560,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1771537,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1572401,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1569205,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1574527,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1565160,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1575649,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1567179,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1566319,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1569630,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 2041560,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1771537,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1572401,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1569205,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1574527,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1565160,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1575649,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1567179,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1566319,
                "content": [
                    {
                        "username": "wyc1997",
                        "content": "A pure mathematics solution for people who are interested.\\nThis can be seen as a counting problem in discrete math.\\nIf we can only travel down or right, then every path from the starting point to the ending point is of fixed length m+n. \\n\\nIn this m+n steps we need to make m rightward steps and n downward steps. The difference between each path is at each point whether you choose to go down or right. Therefore, out of m+n steps to take, we have to choose m steps to go right, and the others go down. There are C(m+n, m) number of ways to do this, where C stands for the mathematics combination. \\n\\n(Official definition for C(m+n,m): the number of subsets of length m of a set that has m+n elements)"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@anwendeng](/anwendeng) Yes, this is the correct solution in terms of the variables given in the problem input.  And, by symmetry, C(n+m-2,n-1) must also be the answer.  I used C(n+m-2, min(n,m)-1) in my C solution."
                    },
                    {
                        "username": "Lorins",
                        "content": "from math import factorial\nreturn int(factorial(m + n - 2)/factorial(m - 1)/factorial(n - 1))"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "firezdog",
                        "content": "Could it also be C(m+n,n)?\n\nChatGPT says yes:\n\n\"Yes, the statement is true.\n\nThe expression C(m + n, n) represents the number of ways to choose n items from a set of (m + n) items, while C(m + n, m) represents the number of ways to choose m items from the same set of (m + n) items.\n\nUsing the formula for combinations, C(n, r) = n! / (r!(n - r)!), we can express C(m + n, n) and C(m + n, m) as follows:\n\nC(m + n, n) = (m + n)! / (n!(m + n - n)!) = (m + n)! / (n!m!)\nC(m + n, m) = (m + n)! / (m!(m + n - m)!) = (m + n)! / (m!n!)\n\nBy comparing the two expressions, we can see that C(m + n, n) and C(m + n, m) have the same numerator, (m + n)!, and the denominators differ only in the order of the factors, n!m! for C(m + n, n) and m!n! for C(m + n, m).\n\nSince the order of multiplication does not affect the value of a fraction, we can conclude that C(m + n, n) = C(m + n, m).\""
                    },
                    {
                        "username": "trashw1n",
                        "content": "if we have a square grid (m==n) then the answer is the nth catalan number."
                    },
                    {
                        "username": "anikaith_kapoor",
                        "content": "we have m columns but our moves are m-1 and n rows and moves are n-1. so total moves possible are C(m+n-2,n-1)"
                    },
                    {
                        "username": "zomborid",
                        "content": "The answer is helpful, but a bit confusing, since m and n are the grid parameters, not how many steps are needed.\\nlet r = m-1 // right steps\\nlet d = n-1 // down steps\\nThe answer is as suggested the mathematical combination C(r+d,r)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is very similar to Pascal triangle! DP is a suggestion.\nIf python is used. 1 line is enough!\n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "best hint ever \\uD83E\\uDEE1"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "This deserve more upvotes! \\n"
                    },
                    {
                        "username": "Luckyberry",
                        "content": "wow! you have a great problem solving skill and pattern recognition thanks for sharing your thoughts\\n"
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "that is an amazing perspective "
                    },
                    {
                        "username": "psquared",
                        "content": "The analogy to Pascal\\'s triangle is amazing; such a clear explanation and creative analogy for a newbie like myself!"
                    },
                    {
                        "username": "suhbell",
                        "content": "Explanation of a mathematical approach: \\n\\nIn the first test case m=3 and n=7. Based on these dimensions the robot can move 2 spaces down and 6 spaces to the right. These moves can be made in any order but there must always be 2 moves down and 6 moves to the right to get to the destination. Generalizing this, there will always be `(m-1)` moves down and `(n-1)` moves right so there will always be `(m-1)+(n-1)` total moves. \\n\\nWe want to find all combinations of the `(m-1)` moves down and `(n-1)` moves to the right. The combination formula is as follows:  \\n`N!/(r!(N-r)!` \\nwhere N is the total number of options and r is the number of choices you have to make. As we saw above, the total number of choices is `(m-1)+(n-1)` which can be simplified to `m+n-2`. So we can substitute `m+n-2` for `N` in the combination formula:\\n`(m+n-2)!/(r!(m+n-2-r)!` \\nWe can then select either the total number of possible moves to the right OR down for r in the combination formula. First, let\\'s try `m-1` for `r`:\\n`(m+n-2)!/((m-1)!(m+n-2-(m-1))!` \\n`(m+n-2)!/((m-1)!(m+n-2-m+1))!` \\n`(m+n-2)!/((m-1)!(n-1))!` \\nTo show that wither m-1 or n-1 for r would produce the same answer, let\\'s use n-1 for r:\\n`(m+n-2)!/((n-1)!(m+n-2-(n-1))!` \\n`(m+n-2)!/((n-1)!(m+n-2-n+1))!` \\n`(m+n-2)!/((n-1)!(m-1))!` \\nSince `(m+n-2)!/((n-1)!(m-1))!`  is equal to `(m+n-2)!/((m-1)!(n-1))!` , then choosing wither m-1 or n-1 for r in the combination formula is valid. \\n"
                    },
                    {
                        "username": "GD18",
                        "content": "great explanation\\n"
                    },
                    {
                        "username": "dejunchen",
                        "content": "why output of 1X1 is 1?not 0?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "because there is just one way to reach bottom right corner, by standing still"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "There is one way, stand still.\\nNo of moves = 0\\nNo of ways = 1\\n\\nThe question is not about finding the number of moves it is about finding the no of ways to reach the goal. Hope that helps."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Well there\\'s only 1 way to go from (0, 0) to (0, 0). If you think about the recursion, if you keep taking recur(x-1, y) and recur(x, y-1) and eventually end up at (0, 0), you\\'d have to return 0 in this base case or else you\\'re going to get 0 for your final output. If this is counterintuitive, you can use (0, 1) and (1, 0) as your base case of 1 to visualize it. Although, this wouldn\\'t work for (m, n) = (0, 0) as you\\'d still need to define the n# of ways to get there."
                    },
                    {
                        "username": "LJXLJXLJX",
                        "content": "It should be 0 , because the robot is at the destination on the beginning..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "yoonl",
                        "content": "So, robot in (m x n) grid needs to take total (m-1) down move and (n-1) right move. For an example, (3 x 7) grid, robot needs 2 down moves, 6 right moves, one of which is DDRRRRRR. Now this is about math combination problem picking up 2 D (or 6 R) from 8 spots, 8C2 (the number of way picking 2 from 8) then fill all others with R, 8x7 / 2x1 = 28."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/unique-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Math (Python3 only)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/unique-paths/solutions/3104226/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "abhaykumar05",
                        "content": "During google screening round, I gave same solution as given in solution \"Approach 1: Dynamic Programming\". I was rejected, HR said i solved in complicated way with high memory requirement. \\nThe interviewer also asked \"Unique Paths II\" as second question, i solved it again using matrix, which uses m*n space.\\n \\n"
                    },
                    {
                        "username": "Balerii",
                        "content": "[@gauravsahni25](/gauravsahni25) You just have to be a bit smarter with the math sollution not to overflow the int maximum. "
                    },
                    {
                        "username": "nikhiljn",
                        "content": "[@cecilia5](/cecilia5) Could you elaborate on that?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@gauravsahni25](/gauravsahni25) The binonmial coefficient is a fraction, you can keep canceling the numerator to avoid overflow."
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "That is unfortunate. Because the factorial solution does not scale well. By that I mean the factorial overflows the int\\'s maximum value as soon as \\n(Height + Width - 2) != 18. i.e. your grid does not have to be that big. \\nThe only scalable solution is DP.\\nSorry mate!\\n\\nThe math answer is smart looking wrong answer :/ "
                    },
                    {
                        "username": "Moore",
                        "content": "I dont think int is enough for the result of uniquepaths(m = 100 and n = 100)"
                    },
                    {
                        "username": "shlykovich",
                        "content": "`\\nAn m \\xD7 n (read as m by n) order matrix is a set of numbers arranged in m rows and n columns.\\n`  https://en.wikipedia.org/wiki/Matrix_representation\\n\\nIn this problem 7x3 grid has 3 rows in 7 columns. Order is switched."
                    }
                ]
            },
            {
                "id": 1576421,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1760609,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 2041941,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1917677,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1572008,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 2069326,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 2041658,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1926934,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1711267,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1576019,
                "content": [
                    {
                        "username": "mkbari5",
                        "content": "![image](https://assets.leetcode.com/users/images/10b1134d-5697-4789-92ca-2ab39090da32_1645349752.5808718.png)\\n"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "The answer is 1 because there is only one way to reach the destination which is just staying there. The answer will be 0 if and only if there is no way to reach destination."
                    },
                    {
                        "username": "lakshyakumartiwari",
                        "content": "// 100% beat solution using combination\\n/** we can also solve it by creating sieve of array but it is less efficient as of space complexity while is doing competitive programming it is preffered to pre compute factorial and power using fermit theorem (numbe^mod-2) for handling division modulo\\n**/\\nclass Solution {\\npublic:\\n   int uniquePaths(int m, int n) {\\n\\t\\tint N = n+m-2,R = min(n-1,m-1);\\n\\t\\tdouble result = 1;\\n\\t\\tfor(int i = 0; i < min(n-1,m-1); i++)\\n\\t\\t\\t\\tresult = result * N-- / R--;\\n\\t\\treturn round(result);\\n   }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you know that there is a Solutions section here? :)"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Any Dp with grid Question Exists:\\n\\n<a href=\"https://imgur.com/naclXcE\"><img src=\"https://i.imgur.com/naclXcE.jpg\" title=\"source: imgur.com\" width=\"350px\"/></a>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are axactly m+n-2 steps to move, (m-1) V(down) and (n-1) >(right). \nThis is converted to the problem finding combination number for\n(m-1) V and (n-1)>. \nSo according to combination number, the number of ways is\nC(n+m-2, m-1). Use Pascal's triangle equation, then done!"
                    },
                    {
                        "username": "psionl0",
                        "content": "By my calculation, using Pascal's triangle to calculate ``combin(n,r)`` has an ``O(n * k)`` run time and a space penalty of ``O(k)`` where ``k = min(r, n-r)``. Using multiplication we can get the time complexity down to ``O(k)``."
                    },
                    {
                        "username": "aneeshakella17",
                        "content": "Hello, \\nI was wondering why BFS doesn\\'t work here?"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@slnarasim92](/slnarasim92) If there are too many paths to report without taking MOD 1e9+7 remainders, then there are too many to count one by one in a search.  "
                    },
                    {
                        "username": "slnarasim92",
                        "content": "getting time limit exceeded for backtracking based approach as well"
                    },
                    {
                        "username": "pranjal_28",
                        "content": "This questions gave me nostalgia and all JEE aspirants will relate to it....we used to do this question in Permutations and Combinations in class 12th during our JEE preperation"
                    },
                    {
                        "username": "psionl0",
                        "content": "If I remember correctly, ``63. Unique Paths II`` was a daily problem on August 12, 2023 (a Saturday). This one is definitely not your usual type of Sunday problem."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "why can\\'t they just make row n and col m.\\nI got 2 typos and I spend my 20 mins finding why its showing runtime error.\\n\\n"
                    },
                    {
                        "username": "Joald",
                        "content": "We need to make m - 1 steps right and n - 1 steps down.\\nWe are asked for how many ways we can do that - that is, in how many different ways we can produce a sequence of that many of each step.\\nFor m = 4, n = 3, one such sequence is > \\\\\\\\/ > > \\\\\\\\/\\nSince we always have to make the same amount of steps (m + n - 2), we can treat steps as \"slots\", and one kind of arrow as \"chosen\" and the other as \"not chosen\". This means that all we need to calculate is how many ways we can choose a certain amount of arrows out of the pool of m + n - 2 arrows. \\nThe rest is left as an exercise for the reader."
                    },
                    {
                        "username": "purple329",
                        "content": "For the last test case, I got an wrong answer.\\n\\ninput:\\n1\\n1\\nOutput:\\n0\\nExpected:\\n1"
                    },
                    {
                        "username": "Joald",
                        "content": "There is exactly one path from each square to itself - the empty path."
                    }
                ]
            },
            {
                "id": 1574458,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1573974,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1573799,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1573453,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1572654,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1572497,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1571986,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1572600,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 1571146,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 2053141,
                "content": [
                    {
                        "username": "ml4",
                        "content": "answer: (m+n-2)! / [(m-1)! * (n-1)!]"
                    },
                    {
                        "username": "vashishthaakshay18",
                        "content": "This question can be solved by two method one through dp and another through maths \\nMaths approach ->\\n1. In path we need to fix no. of down moves and fix no. of right moves so we can say that in a string of length (m-1) + (n-1) we need to find total different string possible so so we can easily see ans is (n!)/(m1!)(m2!)..... ans so \\n2. we just need to compute (n+m-2)!/(n-1)!*(m-1)!\\n\\nDp approach we can easily see that we just need find the no of possible ways to reach (i,j) index so that will be equal to dp[i][k] which is equal to the sum of its upper row or left column value i.e. dp[i][j] = dp[i-1][j] + dp[i][j-1]"
                    },
                    {
                        "username": "kavyakumar",
                        "content": "Input: m = 3, n = 2\\nOutput: 3\\nExplanation:\\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\\n1. Right -> Right -> Down\\n2. Right -> Down -> Right\\n3. Down -> Right -> Right\\n\\nOne more path is also available\\ndown->right->up->right->down"
                    },
                    {
                        "username": "nikhilchinnala",
                        "content": "Yes it is possible. However, according to problem statement, we can move either down or right. So, in the problem context 4th path is not available."
                    },
                    {
                        "username": "anshulmaheshwari5404834",
                        "content": "\\ttotal steps to be taken = m-1 (right)+n-1(down);\\n\\tto select m-1 right steps from m+n-2 total steps then n-1 down steps from remaining n-1 down steps \\n\\t\\ttherefore ans should be **m+n-2 C m-1******\\n"
                    },
                    {
                        "username": "seaskies",
                        "content": "The note says m and n will be at most 100, then how does the platform deal with the answer bigger than 2^31-1 as the follow picture?\\nCan anyone help me out, with great appreciation!\\n![image](https://assets.leetcode.com/users/seaskies/image_1556768250.png)\\n"
                    },
                    {
                        "username": "demmr",
                        "content": "The return type of the function is int and it will fail for values of m and n going more than 40 lets say. I took dp matrix to be long type and then it is able to accomodate the values as m and n can go upto 100. But the code is accepted when I\\'m just taking dp matrix to be int type.\\n\\nIn running the test cases, I can see that Integer overflow is happening for m,n >40, but the testcases get pass. \\n\\nCan someone please let me know if I want to get it accepted for int return type for m,n = 100, then how can we proceed and is it possible using dp matrix?"
                    },
                    {
                        "username": "kruglikov",
                        "content": "This problem is essentially asking  N+M - 2 choose N-1. It\\'s a simple math problem as long as you figure out how to avoid overflowing the int type (asuume n = N+M-2 and k = min(N, M) - 1 just perform n!/max(n-k, k)! as a single step so in the the 100,2 test case it redeuces to 100 instead of calculating 100!/99! which will overflow the int type."
                    },
                    {
                        "username": "sykKo",
                        "content": "\\u7B54\\u6848\\u662F (m + n - 2)! / ((m - 1)! * (n - 1)!)\\n\\u6211\\u77E5\\u9053\\u8FD9\\u9898\\u5E94\\u8BE5\\u7528dynamic programming\\u505A\\uFF0C\\u4F46\\u662F\\u4E8B\\u5B9E\\u4E0A\\u8FD9\\u9053\\u9898\\u6211\\u4EEC\\u5728\\u5B66\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u65F6\\u5019\\u5176\\u5B9E\\u5E94\\u8BE5\\u90FD\\u505A\\u5230\\u8FC7\\uFF0C\\u5F53\\u65F6\\u53EF\\u6CA1\\u6CD5\\u7F16\\u7A0B\\u505A\\uFF0C\\u66F4\\u4F55\\u51B5\\u9898\\u76EE\\u91CC\\u7684m\\u548Cn\\u90FD\\u4E0D\\u4E00\\u5B9A\\u662F\\u5177\\u4F53\\u6570\\u5B57\\u3002\\n\\u590D\\u4E60\\u4E86\\u4E00\\u4E0B\\u4EE5\\u540E\\uFF08\\u662F\\u7684\\uFF0C\\u6211TM\\u73B0\\u5728\\u5DF2\\u7ECF\\u4E0D\\u4F1A\\u505A\\u8FD9\\u9053\\u9898\\u4E86\\uFF09\\uFF0C\\u89E3\\u7B54\\u8FC7\\u7A0B\\u5982\\u4E0B\\uFF1A\\n\\u9996\\u5148\\uFF0C\\u5C06\\u9898\\u76EE\\u8F6C\\u53D8\\u4E3A\\u628A(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u63D2\\u5165\\u5230(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u91CC\\u3002\\n\\u800C\\u8FD9\\u53C8\\u53EF\\u4EE5\\u8F6C\\u53D8\\u4E3A\\u6C42(m-1)\\u4E2A\\u201C\\u53F3\\u201D\\u548C(n-1)\\u4E2A\\u201C\\u4E0B\\u201D\\u603B\\u5171\\u6709\\u591A\\u5C11\\u79CD\\u4E0D\\u540C\\u7684\\u6392\\u5217\\u65B9\\u6CD5\\uFF0C\\u90A3\\u7B54\\u6848\\u5C31\\u662F(m + n - 2)! / ((m - 1)! * (n - 1)!)\\u4E86\\u3002\\n\\nEnglish translation:\\nanswer is (m + n - 2)! / ((m - 1)! * (n - 1)!)\\nI know this problem is supposed to be solved with dynamic programming, but the truth is that we Chinese have all probably met this question when learning permutations and combinations in school. We could program then, let alone m and n might even not be actual numbers.\\nAfter reviewing a bit (yeah, I cannot solve this on my own now, years after graduating), I\\'ve solved this problem with following steps:\\n1. The problem actually equals to insert m - 1 \"right\"s into n - 1 \"downs\"\\n2. and that equals to find out in how many ways m - 1 \"1\"s and n - 1 \"0\"s can form a string\\n3. the answer here it is."
                    },
                    {
                        "username": "quantic",
                        "content": "If you try with 60 60 the Accepted solution will return -234078496 so i thing the answer should be returned MOD some prime number or the limits (m,n<= 100 ) changed."
                    },
                    {
                        "username": "cuckfcp",
                        "content": "Fibonacci style easy DP problem"
                    }
                ]
            },
            {
                "id": 2048390,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2043136,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2043047,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2043036,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2043006,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042827,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042687,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042530,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042504,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042478,
                "content": [
                    {
                        "username": "1234567812345678",
                        "content": "Well, combinatorial solution is the most immediate one. However, this will require us to use long long type because of the integer overflow. Integer overflow is quite annoying especially when we are solving the computational problem like this. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "You can solve it in O(n) space with bottom-up dp."
                    },
                    {
                        "username": "shresthaaa",
                        "content": "What is wrong in this\\nclass Solution {\\npublic:\\n    int fun(int m, int n , vector<vector<int>> &v ,int r,int d )\\n    {\\n        if(r>= n || d >= m)\\n        return 0;\\n\\n       else if(v[r][d])\\n        return v[r][d]; \\n\\n        else\\n        v[r][d] = fun( m, n , v , r++, d ) + fun( m, n, v , r, d++ );\\n\\n        return v[r][d];\\n\\n    }\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        int r = 0, d =0 ;\\n        return fun(m, n, v , r, d );\\n        \\n    }\\n};"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "dfs , island count , with only 2 dir?"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Whoa whoa whoa... No Backtracking??? WHYYYY  ;_;"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Why doesn\\'t this work?\\n\\n`import java.lang.*;\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return (factorial(Math.max(m,n))/factorial(Math.min(m,n)))/ factorial(Math.abs(m - n));\\n    }\\n    public int factorial(int m) {\\n        int prod = 1;\\n        for(int i = 1; i <= m; i++) {\\n            prod *= i;\\n        }\\n        return prod;\\n    }\\n}`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that there is Dynamic Programming mentioned among the related topics. This problem has nothing to do with the Dynamic Programming whatsoever, just picking an appropriate number from Pascal triangle via $$O(min(m, n))$$ multiplications and divisions."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "[@sergei99](/sergei99) Thats a good point. I guess the problem should include a note at the bottom specifying the improved time complexity as a goal once the O(mn) solution is found, like in lots of other problems."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@PierreLessard](/PierreLessard) Well, Unique Paths II is definitely a kind of such harder problem, and DP is appropriate there. But subproblems don't have to demand the same algorithms as their main problems to solve them. Somebody was complaining here that Google said them goodbye at an interview because they used DP where it was not the most efficient way."
                    },
                    {
                        "username": "PierreLessard",
                        "content": "Its labeled dynamic programing because its a subproblem of harder unique path dynamic programming problems. If you open with the pascal triangle solution youll still need to know the dp solution since its required to solve those more complicated problems that interviewers often lead with afterwards. Also, including this as dp is good considering it is a pretty intuitive starter dp problem with how hard dp problems are to first learn."
                    },
                    {
                        "username": "lentehora",
                        "content": "Would you guys say that this is one of the easiest use cases of dynamic programming? "
                    },
                    {
                        "username": "aviralj02",
                        "content": "I\\'m so happy to solve this in first go as usually dp problems make me busy for sometime \\uD83D\\uDE00"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "For the test case : \\n`m =\\n19`\\n`n =\\n13`\\n\\nOutput:\\n`86493225`\\n\\nWhen I run it properly executes with not much time, but gives TLE when submitted. I used the Recursive approach. Any help/suggestion on this?"
                    }
                ]
            },
            {
                "id": 2042468,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042464,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042365,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042144,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042087,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042085,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042035,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2042034,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2041953,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2041804,
                "content": [
                    {
                        "username": "kiart-tantasi",
                        "content": "It is a good dp but I do not like that only dp or limited solutions would pass the time limit.\\n\\nI like solving these questions in some other ways. (even they are slower)"
                    },
                    {
                        "username": "layyy",
                        "content": "directly calculating the factorials will give overflow, so apply some math to the answer"
                    },
                    {
                        "username": "nikalinov",
                        "content": "Now I am become Leetcode, the destroyer of weekends"
                    },
                    {
                        "username": "GD18",
                        "content": "standard dfs, dont overthink"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "This [question](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/) is asked a lot of times in interviews!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[I\\'ve explained  with images too here](https://leetcode.com/problems/unique-paths/solutions/3709798/dp-solution-beats-100/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Is this the first weekend without a Hard?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "Would a recursive solution be accepted in an interview? My solution beats 50% on time (2ms) and 69% on memory but I see most people talking about other approaches and I wouldn't actually know how to solve it any other way...\n\nhttps://leetcode.com/problems/unique-paths/solutions/3995427/pure-c-recursive-solution/"
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it depends on which firm is interviewing you but recursion + memoization is a perfectly acceptable way to solve dp problems. With practice, you can convert from recursion directly into a bottom up solution if you want to avoid recursion.\\nThis is the technique I used to solve ``63. Unique Paths II``. The commented out section was the original recursive approach.\\nhttps://leetcode.com/submissions/detail/1039268411/"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "already done, just pressed submit"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Well explained solutions and code is in JAVA**\\nhttps://leetcode.com/problems/unique-paths/solutions/2363431/using-maths-0ms-java-solution/\\nhttps://leetcode.com/problems/unique-paths/solutions/2675825/2-easy-explained-java-solution/"
                    }
                ]
            },
            {
                "id": 2041779,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041775,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041684,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041677,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041669,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041666,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2041593,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2017853,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 2010589,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 1983522,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "If you wish to use the combinations formula instead of a dp matrix then a recursive formula that can be used is\n```\ncombin(r, r) = 1\ncombin(n, r) = combin(n-1, r) * n / (n - r)\n```\nNote that you will need to use a ``long long`` integer for your intermediate products otherwise they will overflow."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*after an annoying contest, I would say, this question good*"
                    },
                    {
                        "username": "jaggz01",
                        "content": "The combinations formula is = Combination (m,n) = m!/(n! * (m-n)!). Use this formula to generate the answer."
                    },
                    {
                        "username": "psionl0",
                        "content": "That formula will never work if m=100 or n=100. Use iteration or recursion to get the combinations."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This might be the most familiar dp problem to me now."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you have practised some dp, imo this should be marked as Easy"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "And Here I complete my 101 days of POTD streak."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "DP is easier than Math :("
                    },
                    {
                        "username": "rajat_171",
                        "content": "No DP is like : cooking the whole dish by yourself.\\nWith DP is like : Just order that dish."
                    },
                    {
                        "username": "jukov",
                        "content": "Looks like all solutions lay on pascal triangle"
                    },
                    {
                        "username": "gauravsahni25",
                        "content": "The math solution of (m+n-2)! / (m-1)! * (n-1)! does not scale well.\\nThe int will overflow as little as m+n-2 = 18\\n\\nOf couse you can calc factorial in long and then cast the result into int. \\nTry uniquePath(10, 10) in your programming language with ints"
                    }
                ]
            },
            {
                "id": 1979658,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1971750,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1954069,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1945891,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1940881,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1925582,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1911579,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1905332,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1902501,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1870221,
                "content": [
                    {
                        "username": "ahmad_masood",
                        "content": "Hint:\\n\"Total steps to get to the goal how many can you have to pick them to be right\".. If you know combination and permutation concepts then it will be simple using the above statement. Let\\'s suppose i have 7 rows and 3 columns. how many time do i have to move right so to reach my goal? use combination to solve this statement and then implement in the code\\n"
                    },
                    {
                        "username": "zzz6519003",
                        "content": "what if we omit \"The robot can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alwaysaditi](/alwaysaditi) Not if the question asked for (all) <i>minimum</i> paths. A \"visited\" matrix should  take care of previously visited cells. ``980. Unique Paths III`` is similar in nature to this."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Then there could be some paths of infinite length and there would be infinite such paths!"
                    },
                    {
                        "username": "YungIrving",
                        "content": "Can some look at my code. Trying a dfs + memo approach and I just can\\'t visualize how it bubbles up so my answer is wrong. Thanks!\\n\\n    `def uniquePaths(self, m: int, n: int) -> int:\\n        dirs = [(1, 0), (0, 1)]\\n        memo = defaultdict(int)\\n        memo[(m - 1, n - 1)] = 1\\n\\n        def dfs(r, c):\\n            if (r, c) in memo:\\n                return memo[(r, c)]\\n            else:\\n                for i, j in dirs:\\n                    x = r + i\\n                    y = c + j\\n\\n                    if self.valid(m, n, x, y):\\n                        memo[(r, c)] += dfs(x, y)\\n                        return memo[(r, c)]\\n\\n        \\n        dfs(0, 0)\\n        return memo[(0, 0)]\\n\\n    def valid(self, m, n, r, c) -> bool:\\n        return r in range(m) and c in range(n)\\n`"
                    },
                    {
                        "username": "startupveteran",
                        "content": "During live interview, are we permitted to skip DP and head straight to math-based solutions (combinations/permutations)?\n\n----------------SPOILER BELOW------------------:\n.\n.\n.\n.\n..\n.\n.\n.\n.\n.\n..\n.\n.\n.\n.\n..\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n\n        vertical_moves = m-1\n        horizontal_moves = n-1\n        \n        total_moves = vertical_moves + horizontal_moves\n        \n        top = 1\n        bottom = 1\n        for each in range(vertical_moves):\n            top *= total_moves\n            total_moves -= 1\n            bottom *= (1+each)\n        return int(top/bottom)\n"
                    },
                    {
                        "username": "Shivainspace",
                        "content": "i get the output for my code when i put in my compiler. but here am getting a type error, pls help."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = 1;\\n                    continue;\\n                }\\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];\\n\\nthis code works but the code below doesn\\'t what is that I am missing??\\n\\ndp[0][0] = 1;\\n        for(int i  = 0 ; i <= m ; i ++){\\n            for(int j = 0 ; j <= n ; j++){\\n                \\n                int down = 0;\\n                int right = 0;\\n                if(i-1>=0) down = dp[i-1][j];\\n                if(j-1>=0) right = dp[i][j-1];\\n                dp[i][j] = down+right;\\n            }\\n        }\\n        return dp[m][n];"
                    },
                    {
                        "username": "Tiwari100rv",
                        "content": "In the for loop there will be i<m , j<n. Less than or equal to(<=) is wrong there. Also return value will be dp[m-1][n-1]. Your current code is providing answer for m+1, n+1."
                    },
                    {
                        "username": "ashishlawaniyaa",
                        "content": "fun fact:- robot is not smiling :)"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "why i am getting tle on using dfs"
                    },
                    {
                        "username": "amirdon",
                        "content": "I don\\'t understand why the base-case is `m == 1 || n == 1`. Shouldn\\'t it be `m == 1 && n == 1`?\\n"
                    },
                    {
                        "username": "raginibhayana99",
                        "content": "\"class Solution {\\n    vector<vector<int>>dp;\\n    \\n    int solve(int m, int n){\\n        if(m==0 and n==0) return 1;\\n        if(m<0 or n <0) return 0;\\n\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\n        return dp[m][n] = uniquePaths(m-1, n)+ uniquePaths(m, n-1);\\n    }\\n    \\npublic:\\n    int uniquePaths(int m, int n) {\\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\\n        return solve(m-1, n-1);\\n        return 0;\\n    }\\n}; \"i am getting this error: terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  cannot create std::vector larger than max_size(). Please help. Thank you so much in advance. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If only one of `m` or `n` is `0` then the `return` statement calls `uniquePaths()` with a negative argument, and when `uniquePaths()` creates a `std::vector` this `-1` gets implicitly converted to a large integer because the parameter of `std::vector` is `std::size_t`, an unsigned integer type.\nAlso, are you sure that `solve()` should call `uniquePaths()` and not `solve()`?"
                    }
                ]
            },
            {
                "id": 1856298,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1849563,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1848748,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1845088,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1844958,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1841877,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1832847,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1822880,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1820592,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1806039,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "What is this Bruhh \n```class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int N = n+m-2;\n        int r = m-1;\n        int ans = 1;\n        for(int i=1;i<=r;i++){\n            ans = ans*(N-r+i)/i;\n        }\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "singhapoorv7",
                        "content": "return 1 if (i==1 or j==1) else self.uniquePaths(i,j-1)+self.uniquePaths(i-1,j)"
                    },
                    {
                        "username": "Hello_There_",
                        "content": "Backtracking approach to check all the paths. But TLE\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        count=0\\n        def back(i,j):\\n            nonlocal count\\n            if i>=m or j>=n:\\n                return \\n            if i==m-1 and j==n-1:\\n                count+=1\\n                return count\\n            back(i,j+1)\\n            back(i+1,j)\\n            return count\\n        back(0,0)\\n        return count"
                    },
                    {
                        "username": "suchitnegi",
                        "content": "can anyone explain me what is the problem with this approach?\\n\\n\\nclass Solution {\\nunordered_set<vector<pair<int,int>>>  st;\\npublic:\\n    \\n    void help(vector<pair<int,int>> &vec,int i,int j,unordered_set<vector<pair<int,int>>> &st,int m,int n)\\n    {\\n        if(i>=m || j>=n)\\n        return;\\n        \\n        if(i==(m-1) && j == (n-1))\\n        {\\n            st.insert(vec);\\n            return;\\n        }\\n\\n        vec.push_back(make_pair(i,j));\\n        help(vec,i+1,j,st,m,n);\\n        vec.pop_back();\\n        help(vec,i,j+1,st,m,n);\\n\\n        // return;\\n       \\n\\n\\n    }\\n    \\n    int uniquePaths(int m, int n) {\\n       \\n        vector<pair<int,int>> vec;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n\\n        help(vec,i,j,st,m,n);\\n\\n\\n        int ans = st.size();\\n        return ans;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Should have been marked EASY"
                    },
                    {
                        "username": "harkeshbirman",
                        "content": " no of path required to move from (0,0) to (0,0) is 1"
                    },
                    {
                        "username": "c8763yee",
                        "content": "i don\\'t get it, why my O(1) space solution using more memory than dp solution"
                    },
                    {
                        "username": "pritha28",
                        "content": "What is the time complexity if we traverse all possible paths using dfs approach ?\n`\n     public int dfs(int m, int n, int row_idx, int col_idx){\n         if(row_idx >= m || col_idx >= n) return 0;\n         if(row_idx == m-1 && col_idx == n-1) return 1;\n         return dfs(m, n, row_idx+1, col_idx) + dfs(m, n, row_idx, col_idx+1);\n     }\n`"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "this is a back-tracking problem, right?"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "It should be. If solving it with back tracking and recursions didn\\'t hit TLE."
                    },
                    {
                        "username": "EserCengiz",
                        "content": "uniquePaths = (m+n-2)! / ((m-1)! * (n-1)!)"
                    }
                ]
            },
            {
                "id": 1803957,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1800932,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1799419,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1786634,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1784104,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1774478,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1774153,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770247,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1765176,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757440,
                "content": [
                    {
                        "username": "bikramleeemboo",
                        "content": "Can please suggest me how to decrease runtime for this following code. thanks in advance.\\n\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        return recursive(m, n, 0, 0);\\n    }\\n\\n    private int recursive(int m, int n, int x, int y) {\\n        if(x == m -1 && y == n -1) {\\n            return 1;\\n        }\\n        if(x == m || y == n) return 0;\\n        return recursive(m, n, x + 1, y) + recursive(m, n, x, y + 1);\\n    }\\n}"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "Here, I use tablization in which finding out the unique paths  by making the rows and columns in the dp matrix or the same as the table given i.e,. m,n...Now implement  dp[i][j] = dp[i-1][j] + dp[i][j-1]; by this we get the unique paths "
                    },
                    {
                        "username": "amaan7",
                        "content": "Why i am getting TLE ?? can someone explain !!\\n\\n`class Solution {\\n    public int countPaths(int m ,int n, int i ,int j){\\n        if(i>=m || j >=n){\\n            return 0;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return 1;\\n        }\\n        int downPaths = countPaths(m,n,i+1,j);\\n        int RightPaths = countPaths(m,n,i,j+1);\\n        return downPaths+RightPaths;\\n    }\\n    public int uniquePaths(int m, int n) {\\n        int ans = countPaths(m,n,0,0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First of all, please make sure the code which you are sending is enough for readability, we are programmers, not bloggers."
                    },
                    {
                        "username": "Code2Buzz",
                        "content": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(m,1));\n        for(int i=m-2;i>=0;i--){\n            for(int j=n-2;j>=0;j--){\n                dp[i][j]=dp[i+1][j]+dp[i][j+1];\n            }\n        }\n        return dp[0][0];\n    }\n};\n\nWhat is wrong in above code it's getting AddressSanitizer error ?."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the definition of `dp`. It creates a `std::vector<std::vector<int>>` with dimensions `m x m`.  \\nBut what if `n` is greater than `m`?"
                    },
                    {
                        "username": "user4956si",
                        "content": "I\\'ll try to explain as simply as possible.\\nLet\\'s say, you only have a 1x1 grid. In this case, it doesn\\'t make sense to get to the end so let\\'s assume the number of ways to get to the end would be 1.\\n\\nNow, if you have 2x1 grid, no of of ways of getting to end would be 1. similarly for 3x1 grid, answer would be 1. So, for mx1 grid, total number of ways to get to the end would be 1.\\n\\nSimilarly, total number of ways to get to the end of 1xn grid would also be 1.\\n\\nNow, calculating the number of ways to get to the end is simple. If you are at (m-1,n-2) position number of ways is 1. If you are at (m-2,n-1) number of ways is 1. And mind you, to reach (m-1,n-1) you must first either enter (m-1,n-2) or (m-2,n-1). \\n\\nSo total no of ways of reaching (m-1,n-1) = no of ways of reaching(m-2,n-1) + no of ways of reaching (m-1,n-2).\\n\\nNow we can solve this using dynamic programming technique."
                    },
                    {
                        "username": "ivsvinay2003",
                        "content": "class Solution {\\npublic:\\n    long long int solve(int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(m<0 || n<0){\\n            return 0;\\n        }\\n        if(m==0 && n!=0){\\n            return 1;\\n        }\\n        if(m!=0 && n==0){\\n            return 1;\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        return dp[m][n]=1+solve(m-1,n,dp)+solve(m,n-1,dp);\\n    }\\n    long long int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        long long ans=solve(m-1,n-1,dp);\\n        return (ans+1)/2;\\n    }\\nmay I know what\\'s the problem for this solution?\\n61/63 cases passed!!\\nremaining 2 are left"
                    },
                    {
                        "username": "roundup414",
                        "content": "// Why this code giving TLE \n\n\nclass Solution {\npublic:\n  int solve(int m,int n,vector<vector<int>> dp)\n    {\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        if(dp[m][n]!=-1) return dp[m][n];\n        int  sum=solve(m,n-1,dp)+solve(m-1,n,dp);\n        return dp[m][n]=sum;\n    }\n   int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(m-1,n-1,dp);\n    }\n};\n\n\n\n\n\n\n\n// Why this code doesn't \n\nclass Solution {\npublic:\n\n   int countWaysUtil(int i, int j, vector<vector<int> > &dp) {\n  if(i==0 && j == 0)\n    return 1;\n  if(i<0 || j<0)\n    return 0;\n  if(dp[i][j]!=-1) return dp[i][j];\n    \n  int up = countWaysUtil(i-1,j,dp);\n  int left = countWaysUtil(i,j-1,dp);\n  \n  return dp[i][j] = up+left;\n  \n}\n\nint uniquePaths(int m, int n){\n    vector<vector<int> > dp(m,vector<int>(n,-1));\n    return countWaysUtil(m-1,n-1,dp);\n    \n}\n};\n\n"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Biggest hint:\\n1. Draw the number of possible ways to reach the finish on a grid.\\n2. Look for the pattern\\n3. Put that pattern into code\\n4. Question how one is able to come to these conclusions during coding interviews"
                    },
                    {
                        "username": "sed4ted",
                        "content": "So for this problem i decided to use tgamma from cmath to implement combinatorics formula, but i think i ran into a problem of precition.\\nwhen i use standart tgamma i get some of the answers 1 short, when i use tgammal i get other testcases wrong is this rounding problem for different compilers or smth?"
                    },
                    {
                        "username": "prats02",
                        "content": "how do i optimize this or y isnt this giving me ans\\nclass Solution {\\npublic:\\n    int fact(int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n    int uniquePaths(int m, int n) {\\n        return fact((n+m)-2)/(fact(n-1)*fact(m-1));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1749093,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1745861,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1736187,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1729809,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1725507,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1724014,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1721253,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1707511,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1697031,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            },
            {
                "id": 1649073,
                "content": [
                    {
                        "username": "Exclusion12",
                        "content": "The output would be 1 if m = 1 and n = 1. This is because there is only one way for the robot to reach the bottom-right corner in this case, which is to stay at the starting position (i.e., grid[0][0]). XD"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int uniquePaths(int m, int n) {\\n        // Bottom up approach\\n        if(m == 1 and n == 1) { //m==0 and n==0\\n            return 1; // agar grid sirf ek box ka hain.\\n        }\\n\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(i == 1 and j == 1) {\\n                    dp[i][j] = 1;\\n                }else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n]; // dp[m-1][n-1]\\n\\n    }\\n};"
                    },
                    {
                        "username": "Black_Beard",
                        "content": "It was an easy question but is there any possibility of constant time solution??"
                    },
                    {
                        "username": "singhsarthak691",
                        "content": "Hey friends,can you help me I don\\'t know why I got TLE in this code.\\n//In this code I approch to the botom up solution \\nclass Solution {\\n    \\n    private:\\n    int solve(int i,int j,vector<vector<int>>dp){\\n        if(i==0 && j==0){\\n            return 1;\\n        }\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n      \\n        return dp[i][j]= solve(i-1,j,dp)+solve(i,j-1,dp);;\\n    }\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        return ans=solve(m-1,n-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "pkl27",
                        "content": "Need help with my code. Why does this not work?\\n\\n\\'\\'\\'\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        paths = 0\\n\\n        def getpaths(m, n, paths):\\n            if (n - 1) >= 1:\\n                return getpaths(m, n - 1, paths)\\n            if (m - 1) >= 1:\\n                return getpaths(m - 1, n, paths)\\n            if (m, n) == (1, 1):\\n                paths += 1\\n        \\n        getpaths(m, n, paths)\\n        return paths\\n\\'\\'\\'\\'"
                    },
                    {
                        "username": "aknopov",
                        "content": "Not proficient in Python, but I think the condition `if (m, n) == (1, 1)` should be replaced by ` if m==1 or n == 1`"
                    },
                    {
                        "username": "aknopov",
                        "content": "uniquePaths(m, n) = uniquePaths(m-1, n) + uniquePaths(m, n - 1)\\nuniquePaths(1, n) = uniquePaths(m, 1) = 1"
                    },
                    {
                        "username": "hemanthtondur789",
                        "content": "class Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        int a[m][n];\\n        a[0][0]=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if (j==0) a[i][j]=1;\\n               else if (i==0) a[i][j]=1;\\n               else {\\n                   a[i][j]=a[i-1][j]+a[i][j-1];\\n               }\\n            }\\n        }\\n    return a[m-1][n-1];\\n    }\\n};"
                    },
                    {
                        "username": "julabgamun",
                        "content": "class Solution {\\npublic:\\n    long double calculateFactorial(int a){\\n        long double prod = 1;\\n        for(long double i=1;i<=a;i++){\\n            prod = prod*i;\\n        }\\n        return prod;\\n    }\\n    int uniquePaths(int m, int n) {\\n        long double num = calculateFactorial(m-1+n-1);\\n        long double denom = calculateFactorial(m-1) * calculateFactorial(n-1);\\n        int val = num/denom;\\n        return val;\\n    }\\n};\\n\\nFew of the test cases are failing, any idea why? \\n\\nOne such example is m = 36, n = 7, OP: 4496388, mine is 4496387"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "Can this be solved without dynamic programming???\\n"
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Is there a reason why recursion is outperforming iterative implementations for this problem?"
                    }
                ]
            }
        ]
    }
]