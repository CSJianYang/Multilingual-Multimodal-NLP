[
    {
        "title": "Smallest K-Length Subsequence With Occurrences of a Letter",
        "question_content": "You are given a string s, an integer k, a letter letter, and an integer repetition.\nReturn the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. The test cases are generated so that the letter appears in s at least repetition times.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nA string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\n&nbsp;\nExample 1:\n\nInput: s = \"leet\", k = 3, letter = \"e\", repetition = 1\nOutput: \"eet\"\nExplanation: There are four subsequences of length 3 that have the letter 'e' appear at least 1 time:\n- \"lee\" (from \"leet\")\n- \"let\" (from \"leet\")\n- \"let\" (from \"leet\")\n- \"eet\" (from \"leet\")\nThe lexicographically smallest subsequence among them is \"eet\".\n\nExample 2:\n\nInput: s = \"leetcode\", k = 4, letter = \"e\", repetition = 2\nOutput: \"ecde\"\nExplanation: \"ecde\" is the lexicographically smallest subsequence of length 4 that has the letter \"e\" appear at least 2 times.\n\nExample 3:\n\nInput: s = \"bb\", k = 2, letter = \"b\", repetition = 2\nOutput: \"bb\"\nExplanation: \"bb\" is the only subsequence of length 2 that has the letter \"b\" appear at least 2 times.\n\n&nbsp;\nConstraints:\n\n\t1 <= repetition <= k <= s.length <= 5 * 104\n\ts consists of lowercase English letters.\n\tletter is a lowercase English letter, and appears in s at least repetition times.",
        "solutions": [
            {
                "id": 1500174,
                "title": "python-java-o-n-greedy-solution-using-a-stack",
                "content": "This question reminds me of `316-Remove Duplicate Letters`, so I am going with a similar approach here.\\n\\nI maintain a stack containing the built prefix of the output. Starting from left to right of the string `s`, for any character that can improve the lexicographical order, we will pop a character from the stack only if:\\n    1. There are enough characters left to construct a `k`-size string.\\n    2. If the character to be popped is the same as `letter`, then there should also be at least `r` character `letter` left.\\n\\nWhen adding new element to `stack`, we just need to check if the stack is already full (has size of `k`), and if the character is not the same as `letter`, then also check if we are leaving enough space for the matching characters.\\n\\nPython solution:\\n```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, r: int) -> str:\\n        n_letters = len([c for c in s if c == letter])\\n        stack = []\\n        \\n        for i, c in enumerate(s):\\n            while stack and stack[-1] > c and (len(s) - i + len(stack) > k) and (stack[-1] != letter or n_letters > r):\\n                d = stack.pop()\\n                if d == letter:\\n                    r += 1\\n                \\n            if len(stack) < k:\\n                if c == letter:\\n                    stack.append(c)\\n                    r -= 1\\n                elif k - len(stack) > r:\\n                    stack.append(c)\\n            \\n            if c == letter:\\n                n_letters -= 1\\n            \\n        return \\'\\'.join(stack)\\n```\\nJava solution:\\n```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        int n_letters = 0;\\n        for (int i = 0; i < s.length(); i++)\\n            if (s.charAt(i) == letter)\\n                n_letters ++;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            while (!stack.isEmpty() && stack.peek() > c && (s.length() - i + stack.size() > k) && (stack.peek() != letter || n_letters > r)) {\\n                if (stack.pop() == letter) r ++;\\n            }\\n            \\n            if (stack.size() < k) {\\n                if (c == letter) {\\n                    stack.push(c);\\n                    r --;\\n                } else if (k - stack.size() > r) {\\n                    stack.push(c);\\n                }\\n            }\\n            \\n            if (c == letter) n_letters --;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(stack.size());\\n        for(Character c : stack) sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, r: int) -> str:\\n        n_letters = len([c for c in s if c == letter])\\n        stack = []\\n        \\n        for i, c in enumerate(s):\\n            while stack and stack[-1] > c and (len(s) - i + len(stack) > k) and (stack[-1] != letter or n_letters > r):\\n                d = stack.pop()\\n                if d == letter:\\n                    r += 1\\n                \\n            if len(stack) < k:\\n                if c == letter:\\n                    stack.append(c)\\n                    r -= 1\\n                elif k - len(stack) > r:\\n                    stack.append(c)\\n            \\n            if c == letter:\\n                n_letters -= 1\\n            \\n        return \\'\\'.join(stack)\\n```\n```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        int n_letters = 0;\\n        for (int i = 0; i < s.length(); i++)\\n            if (s.charAt(i) == letter)\\n                n_letters ++;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            while (!stack.isEmpty() && stack.peek() > c && (s.length() - i + stack.size() > k) && (stack.peek() != letter || n_letters > r)) {\\n                if (stack.pop() == letter) r ++;\\n            }\\n            \\n            if (stack.size() < k) {\\n                if (c == letter) {\\n                    stack.push(c);\\n                    r --;\\n                } else if (k - stack.size() > r) {\\n                    stack.push(c);\\n                }\\n            }\\n            \\n            if (c == letter) n_letters --;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(stack.size());\\n        for(Character c : stack) sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502211,
                "title": "monostack-sort-of",
                "content": "I wrongfully followed a DP route, which was foolish - I should have realized it sooner from looking at the constraints. I then got a \"monostack\" idea, but I struggled a bit to implement it.\\n\\nWe build our non-decreasing stack:\\n- While the previous character is larger, we remove it. \\n\\t- We can remove up to `n - k` characters. And we just copy the remaining characters.\\n- If that larger character is `letter`, we remove it only if we have `extra`.\\n\\nNote that our \"monostack\" can have more chars that we need. So we pick `k` characters from monostack, from smaller to larger. We ensure that we also pick a `rep` number of `letter`, and we do it by only picking `k - rep` of other characters.\\n\\n**C++**\\n```cpp\\nstring smallestSubsequence(string s, int k, char letter, int rep) {\\n    int extra = count(begin(s), end(s), letter) - rep, remove = s.size() - k;\\n    string mono, res;\\n    for (auto ch : s) {\\n        while (!mono.empty() && mono.back() > ch && remove) {\\n            if (mono.back() == letter && extra == 0)\\n                break;\\n            extra -= mono.back() == letter;\\n            --remove;\\n            mono.pop_back();\\n        }\\n        mono += ch;\\n    }\\n    for (int i = 0; res.size() < k; ++i) {\\n        if (mono[i] != letter && res.size() + max(0, rep) >= k)\\n            continue;\\n        res += mono[i];\\n        rep -= mono[i] == letter;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring smallestSubsequence(string s, int k, char letter, int rep) {\\n    int extra = count(begin(s), end(s), letter) - rep, remove = s.size() - k;\\n    string mono, res;\\n    for (auto ch : s) {\\n        while (!mono.empty() && mono.back() > ch && remove) {\\n            if (mono.back() == letter && extra == 0)\\n                break;\\n            extra -= mono.back() == letter;\\n            --remove;\\n            mono.pop_back();\\n        }\\n        mono += ch;\\n    }\\n    for (int i = 0; res.size() < k; ++i) {\\n        if (mono[i] != letter && res.size() + max(0, rep) >= k)\\n            continue;\\n        res += mono[i];\\n        rep -= mono[i] == letter;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500760,
                "title": "python-9-lines-greedy-solution-explained",
                "content": "As mentioned in some other posts, this problem is more difficult version of problem **0316 Remove Duplicate Letters**. The idea is try to construct our answer in greedy way, each time deciding if we can improve our answer, which we keep in stack or not. To do it efficiently we need array `suff`, which for example for `s = leetcode` and `letter = e` will be equal to \\n`[3, 3, 2, 1, 1, 1, 1, 1]`: it means, that for index `0` we have `3` more letters starting from this index which is equal to `e`, for index `5` we have `1` more letters starting from this index which is equal to `e`.\\n\\n1. I added dummy symbol `!` to stack to make sure it is never empty.\\n2. `r` will mean how many elements `l` we still need to put in our stack.\\n\\nNow, we traverse our string `s` and we want to decide if we can remove some elements from the end of stack:\\n\\n1. We need `stack[-1] > c` condition: that is if we want to add new element `c` we want our answer to decrease.\\n2. `len(stack) + n - i > k + 1`, it means that we still have enough letter ahead to be able to reach `k` elements in our answer.\\n3. `stack[-1] != l or r < suff[i]` condition: first one means that last element of stack is not letter `l`: if we remove it from stack, number of letters `l` in stack will not change, so we can safely do it. Or if `r < suff[i]` means, that last element in stack is `l`, but if we remove it we still have enough letters `l` ahead.\\n4. If we decide to pop element, we update `r`.\\n\\nNow, when we add elements to stack? We need two conditions:\\n1. `len(stack) < k + 1` (+1 here because we use dummy `!`), because obviously answer can not be longer than `k + 1`.\\n2. `len(stack) < k + 1 - r + (c == l)` - this is another crucuial condition you should not miss: it means that you still have enough spaces in you stack to fill it with letters `l`. If we do not use it, we can have something like `[a a a]` in stack with letter `l = \"b\"` and we just do not have enough space in our stack to put letters `l`.\\n3. If we decide to add element, we update `r`.\\n\\n#### Complexity\\nIt is `O(n)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def smallestSubsequence(self, s, k, l, r):\\n        n, stack = len(s), [\"!\"]\\n        suff = list(accumulate([c == l for c in s][::-1]))[::-1]\\n        \\n        for i, c in enumerate(s): \\n            while stack[-1] > c and len(stack) + n - i > k + 1 and (stack[-1] != l or r < suff[i]):\\n                r += stack.pop() == l\\n            if len(stack) < min(k, k - r + (c==l)) + 1:\\n                stack += [c]\\n                r -= (c == l)\\n        \\n        return \"\".join(stack[1:])\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestSubsequence(self, s, k, l, r):\\n        n, stack = len(s), [\"!\"]\\n        suff = list(accumulate([c == l for c in s][::-1]))[::-1]\\n        \\n        for i, c in enumerate(s): \\n            while stack[-1] > c and len(stack) + n - i > k + 1 and (stack[-1] != l or r < suff[i]):\\n                r += stack.pop() == l\\n            if len(stack) < min(k, k - r + (c==l)) + 1:\\n                stack += [c]\\n                r -= (c == l)\\n        \\n        return \"\".join(stack[1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500156,
                "title": "c-simple-o-n",
                "content": "**Thought Process**\\n* Need lexicographically smallest subsequence of length k.\\n* In simpler terms, for every character of the answer string we have to put the smallest possible character.\\n* Which gives us a hint, that we can build answer character by character. \\n\\n**Algorithm**\\n* Say we are adding jth character to the answer string, 1 <= j <=k, let\\'s say we need x occurences of *letter*, that is we have taken *repitition - x* occurences already in answer[1 .. j-1].\\n\\t* We iterate over all 26 possible chars\\n\\t\\t* For each char, we check its first position in input string, say it is i.\\n\\t\\t* We check following conditions:\\n\\t\\t\\t* The count of *letter* in remaining suffix of input string ( = s[i ... n-1] ) >= *x*.\\n\\t\\t\\t* Length of remaininig suffix + answer string length >= k =>. n-i+j-1 >= k.\\n\\t\\t\\t\\t* Need this condition to ensure that the answer subsequence will have length k.\\n\\t\\t\\t* Requirement + current length is not exceeding the K => x+j+1 <= k\\n\\t\\t\\t\\t* Need this condition to ensure we have *repitition* number of character *letter* in answer subsequence.\\n\\t\\t* If current char obeys above condition we add it to the answer string.\\n\\t\\t\\t* Also if current char == *letter*\\n\\t\\t\\t\\t* We decrease requirement by 1, i.e. x--\\n\\n\\n\\n**TC & SC**\\nO(26 * n)\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n        int n = s.length();\\n        \\n        //cnt[i] store the count of letter in suffix [i, n-1]\\n        vector<int> cnt(n); \\n        cnt[n-1] = (s[n-1]==letter);\\n        for(int i=n-2; i>=0; --i) cnt[i] = cnt[i+1] + (s[i]==letter);\\n        \\n        \\n        //for each character, store its indexe(s\\n        \\n        vector<deque<int>> ind(26);\\n        for(int i=0; i<n; ++i) ind[s[i]-\\'a\\'].push_back(i);\\n        \\n        \\n        int x = rep, lastInd=-1;\\n        string ans = \"\";\\n        for(int j=0; j<k; ++j){\\n            for(int ch=0; ch<26; ++ch){\\n                auto &dq = ind[ch];\\n                \\n                //remove invalid indexes\\n                while(dq.size() && dq.front() <= lastInd) dq.pop_front();\\n                if(!dq.size()) continue;\\n                \\n                //check if current index satisfies the conditions \\n                auto index = dq.front();\\n                if(ans.length() + n-index >= k && cnt[index] >= x && (x-(ch+\\'a\\'==letter)+j+1 <= k)){\\n                    ans += ch+\\'a\\';\\n                    if(ch+\\'a\\'==letter) x--;   \\n                    lastInd = index;  \\n                    dq.pop_front();\\n                    break;\\n                }\\n\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n\\n\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n        int n = s.length();\\n        \\n        //cnt[i] store the count of letter in suffix [i, n-1]\\n        vector<int> cnt(n); \\n        cnt[n-1] = (s[n-1]==letter);\\n        for(int i=n-2; i>=0; --i) cnt[i] = cnt[i+1] + (s[i]==letter);\\n        \\n        \\n        //for each character, store its indexe(s\\n        \\n        vector<deque<int>> ind(26);\\n        for(int i=0; i<n; ++i) ind[s[i]-\\'a\\'].push_back(i);\\n        \\n        \\n        int x = rep, lastInd=-1;\\n        string ans = \"\";\\n        for(int j=0; j<k; ++j){\\n            for(int ch=0; ch<26; ++ch){\\n                auto &dq = ind[ch];\\n                \\n                //remove invalid indexes\\n                while(dq.size() && dq.front() <= lastInd) dq.pop_front();\\n                if(!dq.size()) continue;\\n                \\n                //check if current index satisfies the conditions \\n                auto index = dq.front();\\n                if(ans.length() + n-index >= k && cnt[index] >= x && (x-(ch+\\'a\\'==letter)+j+1 <= k)){\\n                    ans += ch+\\'a\\';\\n                    if(ch+\\'a\\'==letter) x--;   \\n                    lastInd = index;  \\n                    dq.pop_front();\\n                    break;\\n                }\\n\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784636,
                "title": "python-beats-88-o-n-well-explained-monotonic-stack",
                "content": "**Thinking Process:**\\nfirst we need to analyse the constraints:\\nwe should find the smallest sbsq with **k length** and this sbsq must have a **letter** repeated **repetition** time(s).\\n\\nwe may think of using monotonic stack where we append each letter, **BUT** before pushing a letter to a stack we need to check if the last pushed one is **greater** than it, if it is, we keep poping till we found a letter **less than it lexicographically** and then we append the letter we are pointing on.\\n\\n**Example:**\\n\\t\"acdbp\" ---> stack : [a]\\n\\t\"cdbp\"  ----> stack : [a, c]  | \"a\"  is less than \"c\" that\\'s why we did not pop \"a\"\\n\\t\"dbp\"  -----> stack : [a, c, d]   same logic for \"d\"\\n\\t\"bp\"   ------> stack : [a, b]   | because \"b\" is less than \"d\" and \"c\" we popped them\\n\\t\"p\"     ------> stack: [a, b, p] \\n\\nThat was a simple example that shows how our stack will work, but there are some difficulties that we gonna face, we will treat them one by one to understand well.\\n\\n**FIRST DIFFICULTY:**\\n\\nif i have **letter** = \"e\",   **repetition** = 2, and i have **s **= \"eeaabe\":\\ni will end up with a stack of [a, a, b, e] with **letter** = \"e\" repeated one time, this wrong because i did not fulfill the constraints that say the **letter** should occur **repetition** time(s)\\n\\nSo How can we fix that ?\\nFirst we need to keep track of how many **letter** that i still have on my string **s** and how many **letter** i have appended to my stack :\\n\\nso when we append a **letter** into the stack i will decrement the **repetition** variable, because it represents how many **letter** i still have to add to fulfill the criteria, and before trying to pop any letter from my stack i need to check if the number of occurances of my **letter** (let\\'s call it **left**) is greater strictly than **repetition**:\\n\\n**example:**\\n\\n**letter** = \"e\",   **repetition** = 2, **s** = \"eeaabe\", **left** = 3 (as we said **left** will represent number of occurences of **letter** in our **s**).\\n\\nstack = []\\n---> [e]  ,    repetition = 1, left = 2\\n---> [e, e],  repetition = 0, left = 1\\n---> [e, a]  repetition = 1 \\n\\n(at this point we checked if the stack[-1] == **letter** (yes, it is) then we checked if **left** > **repetition** (yes, it is) , then we popped the second \"e\" and we incremented **repetition** by one, because we lose an occurance of **letter** and the stack became = [e]? then we checked again if stack[-1] > s[i] (yes it is), if stack[-1] == **letter** (yes it is) if  the **left** > **repetition**  ( 1 > 1, no it is not so we will not pop the \"e\" from the stack, we will only append the \"a\" without poping the \"e\")\\n\\n---> [e, a, a, b, e] (with the same logic we can make sure that our stack will have at least **letter repetition** time(s))\\n\\nso the first issue was solved, we move on to the second.\\n\\n**SECOND DIFFICULTY**\\n\\nHow can we make sure that our stack will have **k length** and contain **letter repetition** time(s) ?\\n\\nn = len(s)\\nfirst thing to do is before poping from the stack we have to make sure that length of the stack plus the length not iterated yet of **s** is greater than **k**, because if we just kept popping we may endup with a stack of length less than k,\\n\\nsecond thing is the second criteria of popping from the stack which is, if the current letter s[i] == **letter** and k - (the length of stack) < repetition, it\\'s like making space for the **repetition letter** that i must  add them later to the stack.\\n \\n **example that the second criteria of poping solves**\\n\\n**s** = \"aaaaee\", **k** = 4, **letter** = \"e\", **repetition** = 1\\n at the end we will return the stack[:k] wich is equal to [a, a, a, a] it does not contain **letter repetition** time(s), but with the criteria that we added it will check if the s[i] == **letter** and if k - length(stack) < repetition wich will be verified at iteration number 5 (i = 5).\\n\\n**I think i covered all the main points let\\'s jump to code to make it more clear**\\n\\n```\\nleft = s.count(letter)\\nn = len(s)\\nstack = list()\\n        \\nfor i in range(n):\\n\\tc = s[i]\\n\\n\\twhile stack and stack[-1] > c and n - i + len(stack) > k or (c == letter and k - len(stack) < repetition):\\n\\t\\tlast = stack[-1]\\n\\t\\t# if the last char in the stack == letter and the number of letter left in s\\n\\t\\t#is less or equal to repetition that means if i popped the letter i can\\'t\\n\\t\\t#end up with sbsq with repetition letter, that\\'s why we break from the loop\\n\\t\\tif letter == last and left <= repetition:   \\n\\t\\t\\tbreak       \\n\\t\\t\\n\\t\\t#if it is not we just pop from the stack\\n\\t\\tstack.pop()\\n\\t\\t\\n\\t\\t#if the popped char == letter we increase number of repetition (bcs it represent\\n\\t\\t#the number of letter i still need to add to the stack)\\n\\t\\tif last == letter: repetition += 1\\n\\t\\n\\t#with the same logic if the current char equal to letter -->\\n\\t# dec repetition and decrement the number of occurances of letter i still have\\n\\t#in my string s\\n\\tif c == letter:\\n\\t\\trepetition -= 1\\n\\t\\tleft -= 1\\n            \\n\\tstack.append(c)\\n        \\nreturn \"\".join(stack[: k])\\n\\n```\\n\\nTime : O(N)\\n**Please upvote if you found that HELPFUL**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nleft = s.count(letter)\\nn = len(s)\\nstack = list()\\n        \\nfor i in range(n):\\n\\tc = s[i]\\n\\n\\twhile stack and stack[-1] > c and n - i + len(stack) > k or (c == letter and k - len(stack) < repetition):\\n\\t\\tlast = stack[-1]\\n\\t\\t# if the last char in the stack == letter and the number of letter left in s\\n\\t\\t#is less or equal to repetition that means if i popped the letter i can\\'t\\n\\t\\t#end up with sbsq with repetition letter, that\\'s why we break from the loop\\n\\t\\tif letter == last and left <= repetition:   \\n\\t\\t\\tbreak       \\n\\t\\t\\n\\t\\t#if it is not we just pop from the stack\\n\\t\\tstack.pop()\\n\\t\\t\\n\\t\\t#if the popped char == letter we increase number of repetition (bcs it represent\\n\\t\\t#the number of letter i still need to add to the stack)\\n\\t\\tif last == letter: repetition += 1\\n\\t\\n\\t#with the same logic if the current char equal to letter -->\\n\\t# dec repetition and decrement the number of occurances of letter i still have\\n\\t#in my string s\\n\\tif c == letter:\\n\\t\\trepetition -= 1\\n\\t\\tleft -= 1\\n            \\n\\tstack.append(c)\\n        \\nreturn \"\".join(stack[: k])\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500365,
                "title": "concise-c-o-n-stack-solution",
                "content": "This is the C++ version of sguaaa\\'s solution to help anyone that\\'s more familiar with C++.\\nAll credit for the original idea and implementation goes to him, original post here:\\nhttps://leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/discuss/1500174/PythonJava-O(N)-greedy-solution-using-a-stack\\n\\n```\\nstring smallestSubsequence(string s, int k, char target, int reps) {\\n    int N = s.length(), remain = count(s.begin(), s.end(), target);\\n    string stack;\\n\\n    for (int i = 0; i < N; i++) {\\n        while (!stack.empty() && stack.back() > s[i] && (N - i + stack.length() > k) && (stack.back() != target || remain > reps)) {\\n            if (stack.back() == target)\\n                reps++;\\n            stack.pop_back();\\n        }\\n\\n        if (stack.length() < k) {\\n            if (s[i] == target || k - (int)stack.length() > reps) {\\n                stack += s[i];\\n                if (s[i] == target)\\n                    reps--;\\n            }\\n        }\\n\\n        if (s[i] == target)\\n            remain--;\\n    }\\n    return stack;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nstring smallestSubsequence(string s, int k, char target, int reps) {\\n    int N = s.length(), remain = count(s.begin(), s.end(), target);\\n    string stack;\\n\\n    for (int i = 0; i < N; i++) {\\n        while (!stack.empty() && stack.back() > s[i] && (N - i + stack.length() > k) && (stack.back() != target || remain > reps)) {\\n            if (stack.back() == target)\\n                reps++;\\n            stack.pop_back();\\n        }\\n\\n        if (stack.length() < k) {\\n            if (s[i] == target || k - (int)stack.length() > reps) {\\n                stack += s[i];\\n                if (s[i] == target)\\n                    reps--;\\n            }\\n        }\\n\\n        if (s[i] == target)\\n            remain--;\\n    }\\n    return stack;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505481,
                "title": "java-monotonic-stack-solution",
                "content": "The idea is keep a monotonously increasing stack, but make sure follow these constrains. \\n1. There are have enough space left for `repetition - count`letters. (`count` is the number of `letter` inside the stack)\\n2. There are have enough letters left to compose `k` letters.\\n3. There are at least `repetition` letters left.\\n\\n```java\\nclass Solution {\\n  public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n    Deque<Character> stack = new ArrayDeque<>();\\n    int count = 0; // count how many `letter` in the stack\\n    int left = s.length();\\n    int letterCount = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      if (s.charAt(i) == letter) letterCount++;\\n    }\\n\\n    for (int i = 0; i < s.length(); i++) {\\n      char c = s.charAt(i); \\n      //                                              Make sure ther are still have enough space left for `repetition` letters\\n      while (!stack.isEmpty() && (c < stack.peek() || k - stack.size() < repetition - count)) {\\n        // Make sure there are still have enough letters left to compose `k` letters.\\n        if (left + stack.size() <= k) break;\\n        // Make sure there are at least `repetition` letters left\\n        if (stack.peek() == letter && letterCount <= repetition) break;\\n\\n        if (stack.pop() == letter) {\\n          count--;\\n          letterCount--;\\n        }\\n      }\\n      stack.push(c);\\n      if (c == letter) count++;\\n\\t  left--;\\n    }\\n\\n    while (stack.size() > k) stack.pop();\\n\\n    StringBuilder builder = new StringBuilder();\\n    while (!stack.isEmpty()) {\\n      builder.append(stack.pop());\\n    }\\n    return builder.reverse().toString();\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n    Deque<Character> stack = new ArrayDeque<>();\\n    int count = 0; // count how many `letter` in the stack\\n    int left = s.length();\\n    int letterCount = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      if (s.charAt(i) == letter) letterCount++;\\n    }\\n\\n    for (int i = 0; i < s.length(); i++) {\\n      char c = s.charAt(i); \\n      //                                              Make sure ther are still have enough space left for `repetition` letters\\n      while (!stack.isEmpty() && (c < stack.peek() || k - stack.size() < repetition - count)) {\\n        // Make sure there are still have enough letters left to compose `k` letters.\\n        if (left + stack.size() <= k) break;\\n        // Make sure there are at least `repetition` letters left\\n        if (stack.peek() == letter && letterCount <= repetition) break;\\n\\n        if (stack.pop() == letter) {\\n          count--;\\n          letterCount--;\\n        }\\n      }\\n      stack.push(c);\\n      if (c == letter) count++;\\n\\t  left--;\\n    }\\n\\n    while (stack.size() > k) stack.pop();\\n\\n    StringBuilder builder = new StringBuilder();\\n    while (!stack.isEmpty()) {\\n      builder.append(stack.pop());\\n    }\\n    return builder.reverse().toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020290,
                "title": "c-monotonic-stack-beats-96-explained",
                "content": "It is similar with LeetCode 316, but with more complex constraints on output string size (*k*)and repetition of a letter (*c*).\\n\\nWhen push into Monotonic stack, the constraints to meet:\\n1. Output string size *k*.\\n2. The number of non-target (non-*c*) letter in output string.\\n\\nWhen pop out of Monotonic stack, the constraints to meet:\\n1. The rest of string *s* and the existing letters in stack can make a string of size *k*.\\n2. The number of target letter *c* in the rest of string and in the stack can make a *repetition* required. \\n\\nIt is pretty hard to make those constraints in code correctly within a short time.\\n\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int cnt = 0;                //total # of \\'letter\\' in the rest of s\\n        for (int i=0; i<s.size(); i++) \\n            if (s[i]==letter) cnt++;\\n        \\n        string stack;\\n        int n=s.size(),  cnt_st=0;  //cnt_st, the count of letter in stack st.\\n        for (int i=0; i<n; i++) {\\n            char c= s[i];\\n            while(!stack.empty() && stack.back()>c &&\\n                  n-i+stack.size()>k &&        // constraint on k\\n                  (cnt_st+cnt > repetition || stack.back()!=letter) ) //constraint on repetition \\n            {\\n                auto x=stack.back();\\n                stack.pop_back(); \\n                if (x==letter) cnt_st--;\\n            }\\n\\n            if ( stack.size()<k && (letter==c || stack.size()-cnt_st < k- repetition)) {\\n                stack.push_back(c); \\n                if (c==letter) cnt_st++;\\n            }\\n            if (c==letter) cnt--;\\n        }\\n\\n        return stack;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int cnt = 0;                //total # of \\'letter\\' in the rest of s\\n        for (int i=0; i<s.size(); i++) \\n            if (s[i]==letter) cnt++;\\n        \\n        string stack;\\n        int n=s.size(),  cnt_st=0;  //cnt_st, the count of letter in stack st.\\n        for (int i=0; i<n; i++) {\\n            char c= s[i];\\n            while(!stack.empty() && stack.back()>c &&\\n                  n-i+stack.size()>k &&        // constraint on k\\n                  (cnt_st+cnt > repetition || stack.back()!=letter) ) //constraint on repetition \\n            {\\n                auto x=stack.back();\\n                stack.pop_back(); \\n                if (x==letter) cnt_st--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2642354,
                "title": "c-easy-to-understand-step-by-step",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n        int n = s.length();\\n        vector<int> cnt(n); \\n        cnt[n-1] = (s[n-1]==letter);\\n        for(int i=n-2; i>=0; --i) cnt[i] = cnt[i+1] + (s[i]==letter);\\n        vector<deque<int>> ind(26);\\n        for(int i=0; i<n; ++i) ind[s[i]-\\'a\\'].push_back(i);\\n        \\n        \\n        int x = rep, lastInd=-1;\\n        string ans = \"\";\\n        for(int j=0; j<k; ++j){\\n            for(int ch=0; ch<26; ++ch){\\n                auto &dq = ind[ch];\\n                while(dq.size() && dq.front() <= lastInd) dq.pop_front();\\n                if(!dq.size()) \\n                continue;\\n                auto index = dq.front();\\n                if(ans.length() + n-index >= k && cnt[index] >= x && (x-(ch+\\'a\\'==letter)+j+1 <= k)){\\n                    ans += ch+\\'a\\';\\n                    if(ch+\\'a\\'==letter) x--;   \\n                    lastInd = index;  \\n                    dq.pop_front();\\n                    break;\\n                }\\n\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n        int n = s.length();\\n        vector<int> cnt(n); \\n        cnt[n-1] = (s[n-1]==letter);\\n        for(int i=n-2; i>=0; --i) cnt[i] = cnt[i+1] + (s[i]==letter);\\n        vector<deque<int>> ind(26);\\n        for(int i=0; i<n; ++i) ind[s[i]-\\'a\\'].push_back(i);\\n        \\n        \\n        int x = rep, lastInd=-1;\\n        string ans = \"\";\\n        for(int j=0; j<k; ++j){\\n            for(int ch=0; ch<26; ++ch){\\n                auto &dq = ind[ch];\\n                while(dq.size() && dq.front() <= lastInd) dq.pop_front();\\n                if(!dq.size()) \\n                continue;\\n                auto index = dq.front();\\n                if(ans.length() + n-index >= k && cnt[index] >= x && (x-(ch+\\'a\\'==letter)+j+1 <= k)){\\n                    ans += ch+\\'a\\';\\n                    if(ch+\\'a\\'==letter) x--;   \\n                    lastInd = index;  \\n                    dq.pop_front();\\n                    break;\\n                }\\n\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502134,
                "title": "python3-o-n-using-stack-with-explanation",
                "content": "First, we need to count how many time `letter` occurs in the whole string.\\nNext, we enumerate and keep track of how many times `letter` occurred (and how many are remaining) and greedily add the current character with some condition. \\n\\nIf we need to remove the top element of the stack, we need to have these three conditions satisfied:\\n1) current stack top is greater than the `current character`\\n2) if we remove the top of stack and add the `current character`, we can still have k total characters\\n3) if we remove the top of stack and add the `current character`, we can still have repetition of `letter`  character.\\n\\nNext, we may add the the `current character` based on these condition:\\n1) if the current character is `letter`, we check how many times `letter` occcurs later; if it is not enough for the length constraint, we need to add it. Otherwise, we can always add the `letter` later.\\n2) if the `current character` is not the `letter`, we can try to greedily add this character keeping space for the `letter` repetition number of times. If better alternatives come, we can always pop this. Thus we need to keep track how many time the character `letter` was added in the stack too using variable `occ`.  \\n\\n```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        counts,total = 0, 0\\n        n = len(s)\\n        for ch in s:\\n            if ch==letter:\\n                total +=1\\n        stack = []\\n        occ = 0\\n        for idx,ch in enumerate(s):\\n            if ch==letter:\\n                counts +=1\\n            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): \\n                occ -= stack.pop()==letter\\n            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):\\n                stack.append(ch)\\n            elif ch==letter and len(stack)+(total-counts)<k:\\n                stack.append(ch)\\n                occ +=1\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        counts,total = 0, 0\\n        n = len(s)\\n        for ch in s:\\n            if ch==letter:\\n                total +=1\\n        stack = []\\n        occ = 0\\n        for idx,ch in enumerate(s):\\n            if ch==letter:\\n                counts +=1\\n            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): \\n                occ -= stack.pop()==letter\\n            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):\\n                stack.append(ch)\\n            elif ch==letter and len(stack)+(total-counts)<k:\\n                stack.append(ch)\\n                occ +=1\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500297,
                "title": "why-o-n-26-solution-is-giving-tle",
                "content": "Hi community,\\n\\ni wrote O(26n) or O(26k) solution that is giving TLE to me - but when i test that case on custom test cases. it runs finely in 50-60ms.\\n\\nWhy?\\n\\nHere is the solution\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string &s, int len, char letter, int repetition) {\\n        int n = s.size();\\n        vector<int> pos[26];\\n        vector<vector<int>> pref(26,vector<int>(n+2,0));\\n        for(int i=n-1;i>=0;i--) pos[s[i]-\\'a\\'].push_back(i);\\n        \\n        for(int i=0;i<n;i++){\\n            pref[s[i]-\\'a\\'][i]++;\\n            for(int ch=0;ch<26;ch++){\\n                if(i==0) continue;\\n                pref[ch][i]+=pref[ch][i-1];\\n            }\\n        }\\n\\n        string ans = \"\";\\n        int lst = -1;\\n        for(int k=1;k<=len;k++){        \\n            for(int ch=0;ch<26;ch++){\\n                while(!pos[ch].empty()){\\n                    if(pos[ch].back()>lst) break;\\n                    pos[ch].pop_back();\\n                }\\n                if(pos[ch].size()==0) continue;\\n                int idx = pos[ch].back();\\n                ////check\\n\\n                int cnt = pref[letter-\\'a\\'][n-1]-pref[letter-\\'a\\'][idx];\\n                bool c1 = cnt>=repetition-(ch==letter-\\'a\\'?1:0);\\n                bool c2 = (n-1-idx)>=(len-k);\\n                bool c3 = (len-k)>=repetition-(ch==letter-\\'a\\'?1:0);\\n                \\n                if(c1 and c2 and c3){\\n                    ans.push_back((char)(ch+\\'a\\'));\\n                    if(ans.back()==letter) repetition--;\\n                    lst = idx;\\n                    break;\\n                }        \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string &s, int len, char letter, int repetition) {\\n        int n = s.size();\\n        vector<int> pos[26];\\n        vector<vector<int>> pref(26,vector<int>(n+2,0));\\n        for(int i=n-1;i>=0;i--) pos[s[i]-\\'a\\'].push_back(i);\\n        \\n        for(int i=0;i<n;i++){\\n            pref[s[i]-\\'a\\'][i]++;\\n            for(int ch=0;ch<26;ch++){\\n                if(i==0) continue;\\n                pref[ch][i]+=pref[ch][i-1];\\n            }\\n        }\\n\\n        string ans = \"\";\\n        int lst = -1;\\n        for(int k=1;k<=len;k++){        \\n            for(int ch=0;ch<26;ch++){\\n                while(!pos[ch].empty()){\\n                    if(pos[ch].back()>lst) break;\\n                    pos[ch].pop_back();\\n                }\\n                if(pos[ch].size()==0) continue;\\n                int idx = pos[ch].back();\\n                ////check\\n\\n                int cnt = pref[letter-\\'a\\'][n-1]-pref[letter-\\'a\\'][idx];\\n                bool c1 = cnt>=repetition-(ch==letter-\\'a\\'?1:0);\\n                bool c2 = (n-1-idx)>=(len-k);\\n                bool c3 = (len-k)>=repetition-(ch==letter-\\'a\\'?1:0);\\n                \\n                if(c1 and c2 and c3){\\n                    ans.push_back((char)(ch+\\'a\\'));\\n                    if(ans.back()==letter) repetition--;\\n                    lst = idx;\\n                    break;\\n                }        \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514381,
                "title": "c-easy-to-understand-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n\\n        int n = s.size();\\n        vector<int> suf(n, 0);\\n        suf[n-1] = s[n-1] == letter; \\n        for(int i = n-2; i >= 0; i--){\\n            suf[i] = suf[i+1] + (s[i] == letter);\\n        }\\n        \\n        stack<char> st;\\n        int currLetter = 0;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // cout << \"-----\" << endl;\\n            // cout << i << \" - \" << s[i] <<  \" : \" << suf[i] << endl;\\n\\n            //no of elements left nums.size() - i - 1 after putting current element\\n            //after poping, element in stack is st.size() - 1\\n            //so number of element if poping is ( st.size() - 1 ) + ( 1 ) + ( nums.size() - i - 1 )\\n            while((st.size() + s.size() - i - 1 >= k) and st.size() > 0 and st.top() > s[i]){\\n                //now if top is letter then ((currLetter - 1) + suf[i]) >= repeations\\n                //else (currLetter + suf[i]) >= repeations\\n                if(st.top() == letter){\\n                    if((currLetter - 1 + suf[i]) >= repetition){\\n                        // cout << \"Popping \" << st.top() << \" : \" << (currLetter - 1 + suf[i]) << endl;\\n                        st.pop();\\n                        currLetter--;\\n                    }else{\\n                        break;\\n                    }\\n                }else if((currLetter + suf[i]) >= repetition){\\n                    // cout << \"Popping2 \" << st.top() << \" : \" << (currLetter + suf[i]) << endl;\\n                    st.pop();\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            if(st.size() < k){\\n                if(s[i] == letter){\\n                    currLetter++;\\n                    st.push(s[i]);\\n                }else{\\n                    //Check if there are enough space left for letter repeations\\n                    //space left if pushing ith  k - st.size() - 1\\n                    //space required for letter repeations - currLetter\\n                    if((repetition - currLetter) <= 0){\\n                        st.push(s[i]);\\n                    }else if((repetition - currLetter) <= (k - st.size() - 1)){\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        string ans;\\n        while(st.size() > 0){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n\\n        int n = s.size();\\n        vector<int> suf(n, 0);\\n        suf[n-1] = s[n-1] == letter; \\n        for(int i = n-2; i >= 0; i--){\\n            suf[i] = suf[i+1] + (s[i] == letter);\\n        }\\n        \\n        stack<char> st;\\n        int currLetter = 0;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // cout << \"-----\" << endl;\\n            // cout << i << \" - \" << s[i] <<  \" : \" << suf[i] << endl;\\n\\n            //no of elements left nums.size() - i - 1 after putting current element\\n            //after poping, element in stack is st.size() - 1\\n            //so number of element if poping is ( st.size() - 1 ) + ( 1 ) + ( nums.size() - i - 1 )\\n            while((st.size() + s.size() - i - 1 >= k) and st.size() > 0 and st.top() > s[i]){\\n                //now if top is letter then ((currLetter - 1) + suf[i]) >= repeations\\n                //else (currLetter + suf[i]) >= repeations\\n                if(st.top() == letter){\\n                    if((currLetter - 1 + suf[i]) >= repetition){\\n                        // cout << \"Popping \" << st.top() << \" : \" << (currLetter - 1 + suf[i]) << endl;\\n                        st.pop();\\n                        currLetter--;\\n                    }else{\\n                        break;\\n                    }\\n                }else if((currLetter + suf[i]) >= repetition){\\n                    // cout << \"Popping2 \" << st.top() << \" : \" << (currLetter + suf[i]) << endl;\\n                    st.pop();\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            if(st.size() < k){\\n                if(s[i] == letter){\\n                    currLetter++;\\n                    st.push(s[i]);\\n                }else{\\n                    //Check if there are enough space left for letter repeations\\n                    //space left if pushing ith  k - st.size() - 1\\n                    //space required for letter repeations - currLetter\\n                    if((repetition - currLetter) <= 0){\\n                        st.push(s[i]);\\n                    }else if((repetition - currLetter) <= (k - st.size() - 1)){\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        string ans;\\n        while(st.size() > 0){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3348070,
                "title": "javascript-js-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n\\n * @param {string} s\\n * @param {number} k\\n * @param {character} letter\\n * @param {number} repetition\\n * @return {string}\\n */\\nvar smallestSubsequence=function(s, k, letter, rep) {\\n    let extra = s.split(\\'\\').filter(ch => ch == letter).length - rep;\\n    let remove = s.length - k,mono = \"\",ans = \"\";\\n    for (let ch of s) {\\n        while (mono.length > 0 && mono.slice(-1) > ch && remove) {\\n            if (mono.slice(-1) == letter && extra == 0) break;\\n            extra -= mono.slice(-1) == letter;\\n            remove--;\\n            mono = mono.substring(0, mono.length - 1);\\n        }\\n        mono+=ch;\\n    }\\n    for (var i = 0; ans.length < k; i++) {\\n        if (mono[i] != letter && ans.length + Math.max(0, rep) >= k) continue;\\n        ans += mono[i];\\n        rep -= (mono[i] == letter ? 1 : 0);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n\\n * @param {string} s\\n * @param {number} k\\n * @param {character} letter\\n * @param {number} repetition\\n * @return {string}\\n */\\nvar smallestSubsequence=function(s, k, letter, rep) {\\n    let extra = s.split(\\'\\').filter(ch => ch == letter).length - rep;\\n    let remove = s.length - k,mono = \"\",ans = \"\";\\n    for (let ch of s) {\\n        while (mono.length > 0 && mono.slice(-1) > ch && remove) {\\n            if (mono.slice(-1) == letter && extra == 0) break;\\n            extra -= mono.slice(-1) == letter;\\n            remove--;\\n            mono = mono.substring(0, mono.length - 1);\\n        }\\n        mono+=ch;\\n    }\\n    for (var i = 0; ans.length < k; i++) {\\n        if (mono[i] != letter && ans.length + Math.max(0, rep) >= k) continue;\\n        ans += mono[i];\\n        rep -= (mono[i] == letter ? 1 : 0);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264805,
                "title": "python-simple-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestSubsequence(self, s, k, letter, repetition):\\n        n, count, stack = len(s), sum(x == letter for x in s), []\\n\\n        for i,j in enumerate(s):\\n            while stack and stack[-1] > j and len(stack) + n - i > k and (stack[-1] != letter or repetition < count):\\n                if stack.pop() == letter: repetition += 1\\n\\n            if len(stack) < k and (j == letter or len(stack) + repetition < k):\\n                stack.append(j)\\n                if j == letter: repetition -= 1\\n\\n            if j == letter: count -= 1\\n\\n        return \"\".join(stack)\\n\\n        \\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubsequence(self, s, k, letter, repetition):\\n        n, count, stack = len(s), sum(x == letter for x in s), []\\n\\n        for i,j in enumerate(s):\\n            while stack and stack[-1] > j and len(stack) + n - i > k and (stack[-1] != letter or repetition < count):\\n                if stack.pop() == letter: repetition += 1\\n\\n            if len(stack) < k and (j == letter or len(stack) + repetition < k):\\n                stack.append(j)\\n                if j == letter: repetition -= 1\\n\\n            if j == letter: count -= 1\\n\\n        return \"\".join(stack)\\n\\n        \\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947832,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char required, int repetition) {\\n        int sCnt = s.size();\\n        \\n        // Find out how many tar are there in the string\\n        int rCnt = 0; // required characters in the right side\\n        for (char &c : s) {\\n            rCnt += (c == required);\\n        }\\n        \\n        string mono;\\n        int lCnt = 0; // required characters in stack\\n        for (char &c : s) {\\n            while (!mono.empty() && c < mono.back()) {\\n                if (mono.back() == required && lCnt + rCnt == repetition) { // cannot pop the required character\\n                    break;\\n                }\\n                if (mono.size() + sCnt == k) { // no more letters we can pop\\n                    break;\\n                }\\n                lCnt -= (mono.back() == required);\\n                mono.pop_back();\\n            }\\n            \\n            // push to stack if less than k characters in stack\\n            // otherwise, we will have to check if it is required for us to push the character\\n            if (mono.size() < k) {\\n                mono += c;\\n                lCnt += (c == required);\\n            } else {\\n                // the only case we are forced to push c into stack is when\\n                // this is the only remaining required character\\n                if (c == required && lCnt + rCnt == repetition) {\\n                    for (int i = mono.size() - 1; i >= 0; i--) {\\n                        if (mono[i] != required) {\\n                            mono[i] = c;\\n                            lCnt++;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            rCnt -= (c == required);\\n            sCnt--;\\n        }\\n        \\n        return mono.substr(0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char required, int repetition) {\\n        int sCnt = s.size();\\n        \\n        // Find out how many tar are there in the string\\n        int rCnt = 0; // required characters in the right side\\n        for (char &c : s) {\\n            rCnt += (c == required);\\n        }\\n        \\n        string mono;\\n        int lCnt = 0; // required characters in stack\\n        for (char &c : s) {\\n            while (!mono.empty() && c < mono.back()) {\\n                if (mono.back() == required && lCnt + rCnt == repetition) { // cannot pop the required character\\n                    break;\\n                }\\n                if (mono.size() + sCnt == k) { // no more letters we can pop\\n                    break;\\n                }\\n                lCnt -= (mono.back() == required);\\n                mono.pop_back();\\n            }\\n            \\n            // push to stack if less than k characters in stack\\n            // otherwise, we will have to check if it is required for us to push the character\\n            if (mono.size() < k) {\\n                mono += c;\\n                lCnt += (c == required);\\n            } else {\\n                // the only case we are forced to push c into stack is when\\n                // this is the only remaining required character\\n                if (c == required && lCnt + rCnt == repetition) {\\n                    for (int i = mono.size() - 1; i >= 0; i--) {\\n                        if (mono[i] != required) {\\n                            mono[i] = c;\\n                            lCnt++;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            rCnt -= (c == required);\\n            sCnt--;\\n        }\\n        \\n        return mono.substr(0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861319,
                "title": "c-solution-faster-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int count=0, inStack=0;\\n        int n=s.size();\\n        for(int i=0; i<n; i++) \\n            if(s[i]==letter)\\n                count++;\\n        string res=\"\";\\n        int i=0;\\n        while(i<n) {\\n            if(res.empty())\\n                res.push_back(s[i]);\\n            else {\\n            while(!res.empty() && res.back()>s[i] && n-i+res.size()>k) {\\n                if(res.back()==letter && count+inStack-1>=repetition) {\\n                        res.pop_back();\\n                        inStack--;\\n                }\\n                else if(res.back()==letter)\\n                    break;\\n                else\\n                res.pop_back();\\n            }\\n            if(s[i]==letter) {\\n                inStack++;\\n                count--;\\n            }\\n            res.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        string ret=\"\";\\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(res[i]==letter && repetition>0 && k>0)\\n            {\\n                repetition--;\\n                ret+=res[i];\\n                k--;\\n            }\\n            else if(k-repetition>0)\\n            {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tret+=res[i];   \\n            }\\n        }\\n     return ret;\\n    }\\n};\\n/*\\nif(find helpful) {\\ndo upvote(); // thanks\\n}\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int count=0, inStack=0;\\n        int n=s.size();\\n        for(int i=0; i<n; i++) \\n            if(s[i]==letter)\\n                count++;\\n        string res=\"\";\\n        int i=0;\\n        while(i<n) {\\n            if(res.empty())\\n                res.push_back(s[i]);\\n            else {\\n            while(!res.empty() && res.back()>s[i] && n-i+res.size()>k) {\\n                if(res.back()==letter && count+inStack-1>=repetition) {\\n                        res.pop_back();\\n                        inStack--;\\n                }\\n                else if(res.back()==letter)\\n                    break;\\n                else\\n                res.pop_back();\\n            }\\n            if(s[i]==letter) {\\n                inStack++;\\n                count--;\\n            }\\n            res.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        string ret=\"\";\\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(res[i]==letter && repetition>0 && k>0)\\n            {\\n                repetition--;\\n                ret+=res[i];\\n                k--;\\n            }\\n            else if(k-repetition>0)\\n            {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tret+=res[i];   \\n            }\\n        }\\n     return ret;\\n    }\\n};\\n/*\\nif(find helpful) {\\ndo upvote(); // thanks\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860026,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        s = list(s)\\n        stack = []\\n        countAll = s.count(letter)\\n        count = 0\\n        for ind, i in enumerate(s):\\n            while stack and stack[-1] > i:\\n                if stack[-1] == letter and i != letter:\\n                    if countAll+count-1 < repetition:\\n                        break\\n                if len(stack)+len(s)-ind-1 < k:\\n                    break\\n                if stack[-1] == letter:\\n                    count-=1\\n                stack.pop()\\n            stack.append(i)\\n            if i == letter:\\n                count+=1\\n                countAll-=1\\n        temp = 0\\n        while len(stack)+temp > k:\\n            if stack[-1] == letter and count <= repetition:\\n                temp+=1\\n            if stack[-1] == letter:\\n                count-=1\\n            stack.pop()\\n        return \"\".join(stack)+temp*letter\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        s = list(s)\\n        stack = []\\n        countAll = s.count(letter)\\n        count = 0\\n        for ind, i in enumerate(s):\\n            while stack and stack[-1] > i:\\n                if stack[-1] == letter and i != letter:\\n                    if countAll+count-1 < repetition:\\n                        break\\n                if len(stack)+len(s)-ind-1 < k:\\n                    break\\n                if stack[-1] == letter:\\n                    count-=1\\n                stack.pop()\\n            stack.append(i)\\n            if i == letter:\\n                count+=1\\n                countAll-=1\\n        temp = 0\\n        while len(stack)+temp > k:\\n            if stack[-1] == letter and count <= repetition:\\n                temp+=1\\n            if stack[-1] == letter:\\n                count-=1\\n            stack.pop()\\n        return \"\".join(stack)+temp*letter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860006,
                "title": "two-step-o-n-solution-c-clean-code",
                "content": "We can split this question to two simper one:\\n1 Find the smallest string with at least repetition letter and at least k length\\nThis can be done by a monotonic stack, but we need be careful with the two at least count condition.\\n2 Take a k length subsequence as the answer. \\nTo make it smallest, we can remove the letter from the ending, or add letter from the beginning. Here I take the k - repitition char which are not the given repitition letter.\\nSince the two step are O(N), the time and space complexity are O(N).\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring smallestSubsequence(string s, int k, char letter, int repetition) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\t// smallest string with at least repetition letter and k length\\n\\t\\t\\tstring smallest_str;\\n\\t\\t\\tint remain_letter = 0;\\n\\t\\t\\tfor(auto ch : s){\\n\\t\\t\\t\\tif(ch == letter) remain_letter++;\\n\\t\\t\\t}\\n\\t\\t\\tint reamain_char = n;\\n\\t\\t\\tint has_letter = 0;\\n\\t\\t\\tfor(auto ch : s){\\n\\t\\t\\t\\twhile(!smallest_str.empty() && ch < smallest_str.back() && smallest_str.size() + reamain_char > k){\\n\\t\\t\\t\\t\\tif(smallest_str.back() != letter)smallest_str.pop_back();\\n\\t\\t\\t\\t\\telse if(has_letter + remain_letter > repetition){\\n\\t\\t\\t\\t\\t\\t\\tsmallest_str.pop_back();\\n\\t\\t\\t\\t\\t\\t\\thas_letter--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsmallest_str.push_back(ch);\\n\\t\\t\\t\\treamain_char--;\\n\\t\\t\\t\\tif(ch == letter) {\\n\\t\\t\\t\\t\\thas_letter++;\\n\\t\\t\\t\\t\\tremain_letter--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// now we have a smallest string but may longer than k\\n\\t\\t\\tstring res;\\n\\t\\t\\tint non_letter_max = k - repetition;\\n\\t\\t\\tint non_letter_cnt = 0;\\n\\t\\t\\tfor(auto ch : smallest_str){\\n\\t\\t\\t\\tif(ch != letter && non_letter_cnt < non_letter_max){\\n\\t\\t\\t\\t\\tres.push_back(ch);\\n\\t\\t\\t\\t\\tnon_letter_cnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ch == letter && res.size() < k) res.push_back(ch);\\n\\t\\t\\t\\tif(res.size() == k) break;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring smallestSubsequence(string s, int k, char letter, int repetition) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\t// smallest string with at least repetition letter and k length\\n\\t\\t\\tstring smallest_str;\\n\\t\\t\\tint remain_letter = 0;\\n\\t\\t\\tfor(auto ch : s){\\n\\t\\t\\t\\tif(ch == letter) remain_letter++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1714332,
                "title": "java-solution-with-monotonic-stack",
                "content": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int rem = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==letter)\\n            {\\n                rem++;\\n            }\\n        }\\n        \\n        Stack<Integer> stack  = new Stack<>();\\n        int cnt = 0;\\n        int len = s.length();\\n        int taken = 0;\\n        for(int i = 0; i < len; i++)\\n        {\\n            char c  = s.charAt(i);\\n            while(!stack.isEmpty() && c < s.charAt(stack.peek()))\\n            {\\n                char top = s.charAt(stack.peek());\\n                if((len - i + taken - 1 >= k) \\n                       && (top != letter \\n                           || (top==letter && rem + cnt - 1 >= repetition)))\\n                {\\n                    taken--;\\n                    stack.pop();\\n                    cnt -= (top==letter ? 1 : 0);\\n                }\\n                else \\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if(taken < k && (c==letter\\n               || (c!=letter && k - taken > repetition - cnt)))\\n            {\\n                stack.push(i);\\n                taken++;\\n                cnt += (c==letter ? 1 : 0);\\n            }\\n            \\n            rem -= (c==letter ? 1 : 0);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.isEmpty())\\n        {\\n            sb.append(s.charAt(stack.pop()));\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int rem = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==letter)\\n            {\\n                rem++;\\n            }\\n        }\\n        \\n        Stack<Integer> stack  = new Stack<>();\\n        int cnt = 0;\\n        int len = s.length();\\n        int taken = 0;\\n        for(int i = 0; i < len; i++)\\n        {\\n            char c  = s.charAt(i);\\n            while(!stack.isEmpty() && c < s.charAt(stack.peek()))\\n            {\\n                char top = s.charAt(stack.peek());\\n                if((len - i + taken - 1 >= k) \\n                       && (top != letter \\n                           || (top==letter && rem + cnt - 1 >= repetition)))\\n                {\\n                    taken--;\\n                    stack.pop();\\n                    cnt -= (top==letter ? 1 : 0);\\n                }\\n                else \\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if(taken < k && (c==letter\\n               || (c!=letter && k - taken > repetition - cnt)))\\n            {\\n                stack.push(i);\\n                taken++;\\n                cnt += (c==letter ? 1 : 0);\\n            }\\n            \\n            rem -= (c==letter ? 1 : 0);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.isEmpty())\\n        {\\n            sb.append(s.charAt(stack.pop()));\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661581,
                "title": "template-for-monostack-problems",
                "content": "Problems like Maximum Rectangle, Smallest K-Length Subsequence With Occurrences of a Letter and Remove Duplicate Letters can also employ such a template. Firstly we determines how many elements need to be popped from the stack to keep the invariant, then we push a new element to the stack.\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        string ans;\\n        int count = 0;\\n        for (auto c : s) {\\n            if (c == letter)\\n                ++count;\\n        }\\n        int used = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            const auto c = s[i];            \\n\\t\\t\\t// Check if it\\'s safe and necessary to pop elements from the stack\\n\\t\\t\\t// 1. If we have enough characters remaining in the string\\n\\t\\t\\t// 2. If c != letter, does it produce a smaller valid subsequence with the remaining elements?\\n\\t\\t\\t// 3. If c == letter, do we need to pop from the stack so the final subsequence length is k?\\n            while (!ans.empty() && ans.size() - 1 + s.size() - i >= k && \\n                   ((ans.back() != letter && c < ans.back()) ||\\n                    (ans.back() == letter && c < ans.back() && used + count - 1 >= repetition) ||\\n                    (c == letter && used + k - ans.size() < repetition))) {\\n                if (ans.back() == letter)\\n                    --used;\\n                ans.pop_back();\\n            }\\n\\t\\t\\t// Need to push the new one\\n            if (ans.size() < k) {                \\n                if (c == letter) {\\n                    ++used;                    \\n                }\\n                ans.push_back(c);\\n            }\\n\\t\\t\\t// Update how many characters are still available\\n            if (c == letter)\\n                --count;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        string ans;\\n        int count = 0;\\n        for (auto c : s) {\\n            if (c == letter)\\n                ++count;\\n        }\\n        int used = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            const auto c = s[i];            \\n\\t\\t\\t// Check if it\\'s safe and necessary to pop elements from the stack\\n\\t\\t\\t// 1. If we have enough characters remaining in the string\\n\\t\\t\\t// 2. If c != letter, does it produce a smaller valid subsequence with the remaining elements?\\n\\t\\t\\t// 3. If c == letter, do we need to pop from the stack so the final subsequence length is k?\\n            while (!ans.empty() && ans.size() - 1 + s.size() - i >= k && \\n                   ((ans.back() != letter && c < ans.back()) ||\\n                    (ans.back() == letter && c < ans.back() && used + count - 1 >= repetition) ||\\n                    (c == letter && used + k - ans.size() < repetition))) {\\n                if (ans.back() == letter)\\n                    --used;\\n                ans.pop_back();\\n            }\\n\\t\\t\\t// Need to push the new one\\n            if (ans.size() < k) {                \\n                if (c == letter) {\\n                    ++used;                    \\n                }\\n                ans.push_back(c);\\n            }\\n\\t\\t\\t// Update how many characters are still available\\n            if (c == letter)\\n                --count;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519681,
                "title": "c-solution-with-clear-comments-on-4-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        vector<int> st;\\n        \\n        // num of letters we still can use\\n        int num_letter_left = 0;\\n        for(const auto& c : s) {\\n            if (c == letter) num_letter_left++;\\n        }\\n        \\n        // num of letters we already have in the result\\n        int num_letter_in = 0;\\n        int len = s.size();\\n        for(int i = 0; i < len; i++) {\\n            char cur = s[i];\\n            \\n            while(!st.empty()) {\\n                int prev_idx = st.back();\\n                char prev_char = s[prev_idx];\\n                \\n                // if deletion of prev_char would lead to insufficient characters in the result\\n                // we cannot delete any more\\n                if (st.size()-1+(len-i) < k) {\\n                    break;\\n                }\\n                \\n                \\n                if (prev_char == letter && cur != letter) {\\n                    // need to ensure we still have enough `letter` to use\\n                    if ((num_letter_in-1 + num_letter_left) >= repetition && prev_char > cur) {\\n                        num_letter_in--;\\n                        st.pop_back();\\n                    } else {\\n                        break;\\n                    }\\n                } else if (prev_char != letter && cur == letter) {\\n                    // if we don\\'t have enough space for `letter`, we need to pop `prev_char`\\n                    if (prev_char > cur || (k-st.size()) < (repetition-num_letter_in) ) {\\n                        st.pop_back();\\n                    } else {\\n                        break;\\n                    }\\n                } else if (prev_char == letter && cur == letter) {\\n                    // the same, no need to do anything\\n                    break;\\n                } else {\\n                    if (prev_char > cur) {\\n                        st.pop_back();\\n                    } else {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (st.size() < k) {\\n                st.push_back(i);\\n                if (cur == letter) {\\n                    num_letter_in++;\\n                }\\n            }\\n            if (cur == letter) {\\n                num_letter_left--;\\n            }\\n        }\\n        \\n        string res;\\n        for(const auto& idx : st) {\\n            res.push_back(s[idx]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        vector<int> st;\\n        \\n        // num of letters we still can use\\n        int num_letter_left = 0;\\n        for(const auto& c : s) {\\n            if (c == letter) num_letter_left++;\\n        }\\n        \\n        // num of letters we already have in the result\\n        int num_letter_in = 0;\\n        int len = s.size();\\n        for(int i = 0; i < len; i++) {\\n            char cur = s[i];\\n            \\n            while(!st.empty()) {\\n                int prev_idx = st.back();\\n                char prev_char = s[prev_idx];\\n                \\n                // if deletion of prev_char would lead to insufficient characters in the result\\n                // we cannot delete any more\\n                if (st.size()-1+(len-i) < k) {\\n                    break;\\n                }\\n                \\n                \\n                if (prev_char == letter && cur != letter) {\\n                    // need to ensure we still have enough `letter` to use\\n                    if ((num_letter_in-1 + num_letter_left) >= repetition && prev_char > cur) {\\n                        num_letter_in--;\\n                        st.pop_back();\\n                    } else {\\n                        break;\\n                    }\\n                } else if (prev_char != letter && cur == letter) {\\n                    // if we don\\'t have enough space for `letter`, we need to pop `prev_char`\\n                    if (prev_char > cur || (k-st.size()) < (repetition-num_letter_in) ) {\\n                        st.pop_back();\\n                    } else {\\n                        break;\\n                    }\\n                } else if (prev_char == letter && cur == letter) {\\n                    // the same, no need to do anything\\n                    break;\\n                } else {\\n                    if (prev_char > cur) {\\n                        st.pop_back();\\n                    } else {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (st.size() < k) {\\n                st.push_back(i);\\n                if (cur == letter) {\\n                    num_letter_in++;\\n                }\\n            }\\n            if (cur == letter) {\\n                num_letter_left--;\\n            }\\n        }\\n        \\n        string res;\\n        for(const auto& idx : st) {\\n            res.push_back(s[idx]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502017,
                "title": "c-2030-smallest-k-length-subsequence-with-occurrences-of-a-letter",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int rest = count(s.begin(), s.end(), letter); \\n        string ans; \\n        for (int i = 0, n = s.size(); i < n; ++i) {\\n            while (ans.size() && ans.back() > s[i] && ans.size() + n - i > k && (ans.back() != letter || repetition < rest)) {\\n                if (ans.back() == letter) repetition += 1; \\n                ans.pop_back(); \\n            }\\n            if (ans.size() < k && (s[i] == letter || ans.size() + repetition < k)) {\\n                ans.push_back(s[i]); \\n                if (s[i] == letter) repetition -= 1; \\n            }\\n            if (s[i] == letter) --rest; \\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int rest = count(s.begin(), s.end(), letter); \\n        string ans; \\n        for (int i = 0, n = s.size(); i < n; ++i) {\\n            while (ans.size() && ans.back() > s[i] && ans.size() + n - i > k && (ans.back() != letter || repetition < rest)) {\\n                if (ans.back() == letter) repetition += 1; \\n                ans.pop_back(); \\n            }\\n            if (ans.size() < k && (s[i] == letter || ans.size() + repetition < k)) {\\n                ans.push_back(s[i]); \\n                if (s[i] == letter) repetition -= 1; \\n            }\\n            if (s[i] == letter) --rest; \\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501284,
                "title": "during-the-contest-i-received-tle-and-now-i-got-ac-with-the-same-submission",
                "content": "Submission Ids with the same code: \\n564866027 = TLE during the contest\\n565089397 = AC this morning\\n\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n = s.size();\\n        \\n        vector<vector<int> > pos(26);\\n        for(int i=0;i<n;i++) pos[s[i] - \\'a\\'].push_back(i);\\n         \\n        vector<int> cnt(n + 1);\\n        for(int i=n-1;i>=0;i--) {\\n            cnt[i] = (s[i] == letter);\\n            cnt[i] += cnt[i + 1];\\n        }\\n        int last = 0;\\n        string output = \"\";\\n        for(int len=0;len<k;len++) {\\n            char best = \\'-\\';\\n            if (k - len == repetition)\\n                best = letter;\\n            else {\\n                for(int c=0;c<26;c++) {\\n                    if (pos[c].empty()) continue;\\n\\n                    auto it = lower_bound(pos[c].begin(), pos[c].end(), last);\\n                    if (it == pos[c].end()) continue;\\n                    if (cnt[ *it ] < repetition) continue;\\n                    if (k - len > (n - *it) ) continue;\\n\\n                    best = c + \\'a\\';\\n                    last = *it + 1;\\n                    break;\\n                }\\n            }\\n            \\n            if (best == letter) repetition--;\\n            output.push_back(best);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n = s.size();\\n        \\n        vector<vector<int> > pos(26);\\n        for(int i=0;i<n;i++) pos[s[i] - \\'a\\'].push_back(i);\\n         \\n        vector<int> cnt(n + 1);\\n        for(int i=n-1;i>=0;i--) {\\n            cnt[i] = (s[i] == letter);\\n            cnt[i] += cnt[i + 1];\\n        }\\n        int last = 0;\\n        string output = \"\";\\n        for(int len=0;len<k;len++) {\\n            char best = \\'-\\';\\n            if (k - len == repetition)\\n                best = letter;\\n            else {\\n                for(int c=0;c<26;c++) {\\n                    if (pos[c].empty()) continue;\\n\\n                    auto it = lower_bound(pos[c].begin(), pos[c].end(), last);\\n                    if (it == pos[c].end()) continue;\\n                    if (cnt[ *it ] < repetition) continue;\\n                    if (k - len > (n - *it) ) continue;\\n\\n                    best = c + \\'a\\';\\n                    last = *it + 1;\\n                    break;\\n                }\\n            }\\n            \\n            if (best == letter) repetition--;\\n            output.push_back(best);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500564,
                "title": "javascript-mock-stack-996ms",
                "content": "```\\nconst smallestSubsequence = (s, k, letter, repetition) => {\\n    let n = s.length, st = \\'\\', rest = 0, letterCnt = 0;\\n    let visit = Array(n + 1).fill(0);\\n    for (const c of s) {\\n        if (c == letter) rest++;\\n    }\\n    for (let i = 0; i < n; i++) {\\n        while (1) {\\n            if (st.length == 0) break;\\n            if (st.length + (n - i) <= k) break;\\n            if (st[st.length - 1] <= s[i]) break;\\n            if (st[st.length - 1] == letter && letterCnt - 1 + rest < repetition) break;\\n            if (st[st.length - 1] == letter) letterCnt--;\\n            st = st.slice(0, st.length - 1);\\n        }\\n        st += s[i];\\n        if (s[i] == letter) {\\n            letterCnt++;\\n            rest--;\\n        }\\n    }\\n    let pos = letterCnt - repetition;\\n    letterCnt = st.length - k;\\n    for (let i = st.length - 1; ~i; i--) {\\n        if (letterCnt > 0 && pos > 0 && st[i] == letter) {\\n            visit[i] = 1;\\n            letterCnt--;\\n            pos--;\\n        }\\n        if (letterCnt > 0 && st[i] != letter) {\\n            visit[i] = 1;\\n            letterCnt--;\\n        }\\n    }\\n    let res = \\'\\';\\n    for (let i = 0; i < st.length; i++) {\\n        if (!visit[i]) res += st[i];\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nconst smallestSubsequence = (s, k, letter, repetition) => {\\n    let n = s.length, st = \\'\\', rest = 0, letterCnt = 0;\\n    let visit = Array(n + 1).fill(0);\\n    for (const c of s) {\\n        if (c == letter) rest++;\\n    }\\n    for (let i = 0; i < n; i++) {\\n        while (1) {\\n            if (st.length == 0) break;\\n            if (st.length + (n - i) <= k) break;\\n            if (st[st.length - 1] <= s[i]) break;\\n            if (st[st.length - 1] == letter && letterCnt - 1 + rest < repetition) break;\\n            if (st[st.length - 1] == letter) letterCnt--;\\n            st = st.slice(0, st.length - 1);\\n        }\\n        st += s[i];\\n        if (s[i] == letter) {\\n            letterCnt++;\\n            rest--;\\n        }\\n    }\\n    let pos = letterCnt - repetition;\\n    letterCnt = st.length - k;\\n    for (let i = st.length - 1; ~i; i--) {\\n        if (letterCnt > 0 && pos > 0 && st[i] == letter) {\\n            visit[i] = 1;\\n            letterCnt--;\\n            pos--;\\n        }\\n        if (letterCnt > 0 && st[i] != letter) {\\n            visit[i] = 1;\\n            letterCnt--;\\n        }\\n    }\\n    let res = \\'\\';\\n    for (let i = 0; i < st.length; i++) {\\n        if (!visit[i]) res += st[i];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500418,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char l, int r) {\\n        string res(k, l); \\n        if(k == r) return res;\\n        \\n        int n = 0;\\n        for(char& c : s) if(c == l) n++;\\n        \\n        stack<char> st;\\n        for(int i = 0; i < s.size(); i++){\\n            while(!st.empty() && st.top() > s[i] && (s.size() - i + st.size() > k) && (st.top() != l || n > r)){\\n                if(st.top() == l) r++;\\n                st.pop();\\n            }\\n            if(st.size() < k){\\n                if(s[i] == l){\\n                    st.push(s[i]);\\n                    r--;\\n                }\\n                else if(k > st.size() + r) st.push(s[i]);\\n            }\\n            if(s[i] == l) n--;\\n        }\\n        \\n        while(!st.empty()){\\n            res[--k] = st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char l, int r) {\\n        string res(k, l); \\n        if(k == r) return res;\\n        \\n        int n = 0;\\n        for(char& c : s) if(c == l) n++;\\n        \\n        stack<char> st;\\n        for(int i = 0; i < s.size(); i++){\\n            while(!st.empty() && st.top() > s[i] && (s.size() - i + st.size() > k) && (st.top() != l || n > r)){\\n                if(st.top() == l) r++;\\n                st.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1500153,
                "title": "python-3-tle-but-c-ac",
                "content": "Python 3 TLE but C++ AC, so I had to convert my program from Python to C++. Maybe my solution is not the optimal?\\n\\nPython 3:\\n```py\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        s.split()\\n        from collections import Counter\\n        next_char = []\\n        count_char = [None] * len(s)\\n        for i in range(26):\\n            c = chr(ord(\\'a\\') + i)\\n            n = [None] * len(s)\\n            next_char.append(n)\\n            index = None\\n            count = 0\\n            for j in range(len(s) - 1, -1, -1):\\n                if s[j] == c:\\n                    index = j\\n                    count += 1\\n                n[j] = index\\n                if c == letter:\\n                    count_char[j] = count\\n        ans = []\\n        cur = 0\\n        rem_rep = repetition\\n        for i in range(k):\\n            rem_k = k - i\\n            found = None\\n            for j in range(26):\\n                jc = chr(ord(\\'a\\') + j)\\n                n = next_char[j][cur]\\n                if n is not None and count_char[n] >= rem_rep and len(s) - n >= rem_k:\\n                    if jc != letter and rem_rep >= rem_k:\\n                        continue\\n                    found = j, jc, n\\n                    break\\n            else:\\n                assert 0\\n            assert found\\n            ans.append(jc)\\n            cur = n + 1\\n            if jc == letter:\\n                rem_rep -= 1\\n        return \\'\\'.join(ans)\\n```\\n\\nC++:\\n```cpp\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        const int S = s.size();\\n        int next_char[26][S];\\n        int count_char[S];\\n        for (int i = 0; i < 26; i++) {\\n            char c = \\'a\\' + i;\\n            int index = -1;\\n            int count = 0;\\n            for (int j = S - 1; j >= 0; j--) {\\n                if (s[j] == c) {\\n                    index = j;\\n                    count += 1;\\n                }\\n                next_char[i][j] = index;\\n                if (c == letter) {\\n                    count_char[j] = count;\\n                }\\n            }\\n        }\\n        char ans[k + 1];\\n        ans[k] = 0;\\n        int cur = 0;\\n        int rem_rep = repetition;\\n        for (int i = 0; i < k; i++) {\\n            int rem_k = k - i;\\n            for (int j = 0; j < 26; j++) {\\n                char jc = \\'a\\' + j;\\n                int n = next_char[j][cur];\\n                if (n != -1 && count_char[n] >= rem_rep && s.size() - n >= rem_k) {\\n                    if (jc != letter && rem_rep >= rem_k) {\\n                        continue;\\n                    }\\n                    ans[i] = jc;\\n                    cur = n + 1;\\n                    if (jc == letter) {\\n                        rem_rep--;\\n                    }\\n                    goto _break;\\n                }\\n            }\\n            _break:;\\n        }\\n        return string(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        s.split()\\n        from collections import Counter\\n        next_char = []\\n        count_char = [None] * len(s)\\n        for i in range(26):\\n            c = chr(ord(\\'a\\') + i)\\n            n = [None] * len(s)\\n            next_char.append(n)\\n            index = None\\n            count = 0\\n            for j in range(len(s) - 1, -1, -1):\\n                if s[j] == c:\\n                    index = j\\n                    count += 1\\n                n[j] = index\\n                if c == letter:\\n                    count_char[j] = count\\n        ans = []\\n        cur = 0\\n        rem_rep = repetition\\n        for i in range(k):\\n            rem_k = k - i\\n            found = None\\n            for j in range(26):\\n                jc = chr(ord(\\'a\\') + j)\\n                n = next_char[j][cur]\\n                if n is not None and count_char[n] >= rem_rep and len(s) - n >= rem_k:\\n                    if jc != letter and rem_rep >= rem_k:\\n                        continue\\n                    found = j, jc, n\\n                    break\\n            else:\\n                assert 0\\n            assert found\\n            ans.append(jc)\\n            cur = n + 1\\n            if jc == letter:\\n                rem_rep -= 1\\n        return \\'\\'.join(ans)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        const int S = s.size();\\n        int next_char[26][S];\\n        int count_char[S];\\n        for (int i = 0; i < 26; i++) {\\n            char c = \\'a\\' + i;\\n            int index = -1;\\n            int count = 0;\\n            for (int j = S - 1; j >= 0; j--) {\\n                if (s[j] == c) {\\n                    index = j;\\n                    count += 1;\\n                }\\n                next_char[i][j] = index;\\n                if (c == letter) {\\n                    count_char[j] = count;\\n                }\\n            }\\n        }\\n        char ans[k + 1];\\n        ans[k] = 0;\\n        int cur = 0;\\n        int rem_rep = repetition;\\n        for (int i = 0; i < k; i++) {\\n            int rem_k = k - i;\\n            for (int j = 0; j < 26; j++) {\\n                char jc = \\'a\\' + j;\\n                int n = next_char[j][cur];\\n                if (n != -1 && count_char[n] >= rem_rep && s.size() - n >= rem_k) {\\n                    if (jc != letter && rem_rep >= rem_k) {\\n                        continue;\\n                    }\\n                    ans[i] = jc;\\n                    cur = n + 1;\\n                    if (jc == letter) {\\n                        rem_rep--;\\n                    }\\n                    goto _break;\\n                }\\n            }\\n            _break:;\\n        }\\n        return string(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060029,
                "title": "o-n-solution-using-monotonic-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func smallestSubsequence(_ s: String, _ k: Int, _ letter: Character, _ repetition: Int) -> String {\\n        var maxOcc = 0\\n        for ch in s {\\n            if ch == letter {\\n                maxOcc += 1\\n            }\\n        }\\n\\n        var count = 0\\n        var left = s.count\\n        var stack = [Character]()\\n\\n        for ch in s {\\n            while stack.count > 0 && (stack.last! > ch || k - stack.count < repetition - count) {\\n                if left + stack.count <= k { break }\\n\\n                if stack.last == letter && maxOcc <= repetition { break }\\n\\n                if stack.last == letter {\\n                    maxOcc -= 1\\n                    count -= 1\\n                }\\n                \\n                _ = stack.popLast()\\n            }\\n\\n            if ch == letter {\\n                count += 1\\n            }\\n\\n            stack.append(ch)\\n            left -= 1\\n        }\\n\\n        while(stack.count > k) {\\n            _ = stack.popLast()\\n        }\\n\\n        return String(stack)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func smallestSubsequence(_ s: String, _ k: Int, _ letter: Character, _ repetition: Int) -> String {\\n        var maxOcc = 0\\n        for ch in s {\\n            if ch == letter {\\n                maxOcc += 1\\n            }\\n        }\\n\\n        var count = 0\\n        var left = s.count\\n        var stack = [Character]()\\n\\n        for ch in s {\\n            while stack.count > 0 && (stack.last! > ch || k - stack.count < repetition - count) {\\n                if left + stack.count <= k { break }\\n\\n                if stack.last == letter && maxOcc <= repetition { break }\\n\\n                if stack.last == letter {\\n                    maxOcc -= 1\\n                    count -= 1\\n                }\\n                \\n                _ = stack.popLast()\\n            }\\n\\n            if ch == letter {\\n                count += 1\\n            }\\n\\n            stack.append(ch)\\n            left -= 1\\n        }\\n\\n        while(stack.count > k) {\\n            _ = stack.popLast()\\n        }\\n\\n        return String(stack)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880181,
                "title": "monotonic-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on the increasing monotonic stack, keep the smallest letter in the stack.\\nFor this problem, require the specified letters for repetition times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstack pop:\\nwhen current stack last letter is smaller than current letter and the stack size combined with leftover letters that have not been visited is still enough to compose a string of length k,and:\\n1 if current letter is the specified letter, we can pop the element in the stack\\n2 if current letter is not the specified letter, but the leftover string still have enough specified letters \\n\\nthis element could be poped.\\n\\nstack push:\\nwhen current letter is the specified letter, push it\\nwhen current letter is not the specified letter, just make sure there are enough spaces for pushing the specified letter.\\n\\nwhenever the specified letter is visited, reduce the leftover letter that could be available for pushing to the stack. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(K)\\n# Code\\n```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        m, n = Counter(s), len(s)\\n        stack = []\\n        cnt = m[letter]\\n        for i, c in enumerate(s):\\n            while stack and stack[-1] > c and len(stack) + n - i - 1 >= k and (stack[-1] !=letter or cnt > repetition):\\n                top_c = stack[-1]\\n                if top_c == letter:\\n                    repetition += 1\\n                stack.pop()\\n            \\n            if len(stack) < k:\\n                if c == letter:\\n                    stack.append(c)\\n                    repetition -= 1\\n                elif k - len(stack) > repetition:\\n                    stack.append(c)\\n            if c== letter:\\n                cnt = cnt - 1\\n        return \"\".join(stack)\\n\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        m, n = Counter(s), len(s)\\n        stack = []\\n        cnt = m[letter]\\n        for i, c in enumerate(s):\\n            while stack and stack[-1] > c and len(stack) + n - i - 1 >= k and (stack[-1] !=letter or cnt > repetition):\\n                top_c = stack[-1]\\n                if top_c == letter:\\n                    repetition += 1\\n                stack.pop()\\n            \\n            if len(stack) < k:\\n                if c == letter:\\n                    stack.append(c)\\n                    repetition -= 1\\n                elif k - len(stack) > repetition:\\n                    stack.append(c)\\n            if c== letter:\\n                cnt = cnt - 1\\n        return \"\".join(stack)\\n\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753756,
                "title": "greedily-pick-earliest-smallest-letter-if-possible",
                "content": "```\\nimport bisect\\n\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        n = len(s)\\n        s = [ord(c) - ord(\\'a\\') for c in s]\\n        letter = ord(letter) - ord(\\'a\\')\\n        pos = [[] for _ in range(26)]\\n        for i in range(n):\\n            pos[s[i]].append(i)\\n        prev = -1\\n        rem = repetition\\n        res = [\"\"] * k\\n        for i in range(k):\\n            for c in range(26):\\n                p = bisect.bisect_right(pos[c], prev)\\n                if p == len(pos[c]):\\n                    continue\\n                j = pos[c][p]\\n                if k - i > n - j:\\n                    continue\\n                newrem = rem - int(c == letter)\\n                available = bisect.bisect_right(pos[letter], n - 1) - bisect.bisect_left(pos[letter], j + 1)\\n                if k - i - 1 < newrem:\\n                    continue\\n                if available >= newrem:\\n                    res[i] = chr(ord(\\'a\\') + c)\\n                    rem = newrem\\n                    prev = j\\n                    break\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        n = len(s)\\n        s = [ord(c) - ord(\\'a\\') for c in s]\\n        letter = ord(letter) - ord(\\'a\\')\\n        pos = [[] for _ in range(26)]\\n        for i in range(n):\\n            pos[s[i]].append(i)\\n        prev = -1\\n        rem = repetition\\n        res = [\"\"] * k\\n        for i in range(k):\\n            for c in range(26):\\n                p = bisect.bisect_right(pos[c], prev)\\n                if p == len(pos[c]):\\n                    continue\\n                j = pos[c][p]\\n                if k - i > n - j:\\n                    continue\\n                newrem = rem - int(c == letter)\\n                available = bisect.bisect_right(pos[letter], n - 1) - bisect.bisect_left(pos[letter], j + 1)\\n                if k - i - 1 < newrem:\\n                    continue\\n                if available >= newrem:\\n                    res[i] = chr(ord(\\'a\\') + c)\\n                    rem = newrem\\n                    prev = j\\n                    break\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684533,
                "title": "python-stack-solution-explained",
                "content": "We want a \"k\" length subsequence that has at least \"repetition\" number of \"letter\" characters. \\n\\nAnd that subsequence needs to be lexicographically smallest. \\n\\nThis problem can be solved efficiently using a Stack because otherwise, you won\\'t be able to write a solution that gets accepted due to the constraints.\\n\\nSo, as we traverse the input string, we will keep pushing the characters in the stack. Now in this process, we may or may not pop from the stack. We will pop only if we see that popping will make the ongoing subsequence lexicographically smallest as well as will ensure that we get at least \"repetition\" number of \"letter\" characters.\\n\\nNow the question is, what are situations we may encounter?\\n\\nFor that, we have to analyze a few examples. \\n\\n\\tSuppose, we have  s = \"laeet\", k = 3, letter = \"e\", repetition = 1\\n\\t\\n\\tIt means, generate a lexicographically smallest subsequence of length 3\\n\\twith the letter \"e\" occuring at least once.\\n\\t\\n\\tSo, if we start putting characters in stack from left to right.\\n\\t\\n\\tInitially, stack is empty. So we simply put \"l\" in stack\\n\\t\\n\\tstack = [\"l\"]\\n\\t\\n\\tNext, we have \"a\". Here, what do we see? \\n\\t\\n\\tWe see that top of stack has \"l\". And the current character is \"a\".\\n\\t\\n\\tAnd since \"a\" is smaller than \"l\", instead of \"l\", we should put \"a\"\\n\\tto get a lexicographically smaller subsequence than current ongoing subsequence.\\n\\t\\nBut then again, we need to think. What can be the consequences of removing \"l\"? \\n\\t\\n\\tWhat if we had the input string as \"lae\" and k = 3?\\n\\t\\nIn that case, it would not be ideal to remove any character at all since we want a subsequence of length 3\\nand the length of string is also 3\\n\\nSo, when we pop, we also need to make sure that we have enough characters with us to get a \"k\" length subsequence even if we pop the top of stack. Only if that is True, we can pop.\\n\\nAnd that\\'s the reason why in the code, you will see that when the top of stack is greater than current character, then we pop only if a certain condition is true -\\n\\n\\t\\tif (k - len(stack)) < (n - i): stack.pop()\\n\\t\\t\\nWhat does this mean? \\n\\n\\tk -> Length of subsequence we have to generate\\n\\tlen(stack) -> Length of stack at this point\\n\\tk - len(stack) -> Characters the subsequence requires so that its length is \"k\"\\n\\t(n - i) -> Characters we still have to traverse\\n\\t\\nSo we are saying, only pop the top of stack if the number of characters that subsequence is requiring, is less than number of characters that we still have to traverse.\\n\\nAnd that\\'s just one case. \\n\\nWhat can be some other case? \\n\\nAnother case can be if  the top of stack has a greater character than current character but also, the top of stack is \"letter\" itself.\\n\\n\\tFor example, s = \"eatxyzw\", k = 2, letter = \"e\" and repetition = \"1\"\\n\\t\\n\\tHere, when we put first character in stack, stack = [\"e\"]\\n\\t\\n\\tBut then, when we have \"a\", then we see that \"e\" is greater than \"a\"\\n\\t\\n\\tSo, ideally, we should remove \"e\" so that we get a lexicographically smaller subsequence \\n\\t\\nBut, the issue is, \"e\" is also the \"letter\" and so we cannot remove it just like that. \\n\\nHere, the condition (k - len(stack)) < (n - i) is also True but still we see that removing \"e\" will be a wrong step.\\n\\nSo this means, whenever we have a character on top of stack that is not only greater than current character but is also the \"letter\" itself, then we have to think of an additional condition on the basis of which we can remove or not remove.\\n\\nHere, why we cannot remove \"e\"? Because we know that there is only one \"e\" in this whole input string and also, we want \"e\" to appear at least once in the final subsequence. So that\\'s why we cannot pop it. But, if we had \"eaetxyz\" then we would\\'ve removed it because we have an extra \"e\" on the right of \"a\" so we know that even if we remove the first \"e\", we still have an \"e\" on the right.\\n\\n\\tAnd that\\'s why we have pre computed the number of \"letter\" characters \\n\\ton the right of each character in input string.\\n\\t\\nThis will help us in this specific case when the top of stack is a letter and is also greater than the current character.\\nSo, now, the condition to pop() in this case is -> \\n\\n\\tif countOnRight[i] > repetition and (k - len(stack)) < (n - i): \\n\\t\\trepetition += 1\\n\\t\\tstack.pop()\\n\\t\\t\\nNote that as we pop, we are also incrementing the \"repetition\" because we know that we now have one extra \"e\" to find and put in the subsequence.\\n\\nSimilarly, when we will push a \"letter\" into the stack, we will decrement the \"repetition\" because we now have one less \"e\" to find.\\n\\nFinally, there will also be a case where the top of stack has a smaller character than current character but we still have to pop.\\n\\nFor example, s = \"aee\", letter = \"e\", k = 2 and repetition = \"2\"\\n\\n\\tInitially, stack will have \"a\" => [\"a\"]\\n\\t\\n\\tThen, when we are at \"e\", we see that top of stack has a smaller character\\n\\tSo it means, right now our subsequence is the smallest that it can be.\\n\\t\\n\\tBut, still, if you see, we cannot keep \"a\" in the final subsequence. Why?\\n\\t\\n\\tbecause, since length of stack is \"1\", it means, we have already put one character in our subsequence.\\n\\t\\n\\tSo, the number of characters left to put are k - len(stack) -> 2 - 1 => 1\\n\\t\\n\\tBut, we still have repetition = 2\\n\\t\\nThis means, we have space of only 1 character in our subsequence but we still have to put 2 \"e\" characters. That cannot be possible. So, to make space for two \"e\" characters, one element needs to be popped from top of stack. And that\\'s why we pop \"a\" here.\\n\\nHence, the condition will be -> \\n\\n\\t\\tif k - len(stack) < repetition:  stack.pop()\\n\\t\\t\\t\\t \\n\\nAnd that\\'s the whole idea of this solution.\\n\\t\\t\\n\\n```\\ndef smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        # Length of the string\\n        n = len(s)\\n        \\n        # Count of \"letter\" characters on right of each character\\n        countOnRight = [0] * n\\n        countSoFar = 0\\n        \\n        for i in range(n - 1, -1, -1):\\n            # Update the count of \"letter\" characters on right of current character\\n            countOnRight[i] = countSoFar\\n            if s[i] == letter: countSoFar += 1\\n                \\n        # Stack that we will use to generate the smallest subsequence\\n        stack = []\\n        \\n        # Loop over the string\\n        for i in range(n):\\n            \\n            # If the stack is not empty then what are the situations we will face?\\n            while stack:\\n                \\n                # 1. The character on top of stack might be greater than the current character\\n                if s[stack[-1]] > s[i]:\\n                    # Here also, we have two situations\\n                    \\n                    # 1.1 The character on top of stack is \"letter\"\\n                    if s[stack[-1]] == letter:\\n                        # In this case, if we pop the top of stack\\n                        # It would mean repetition will increase by \"1\"\\n                        # So,we need to be sure that we have enough \"letter\" characters on the right of s[i]\\n                        \\n                        # If we have enough \"letter\" characters on right of current index\\n                        # Then we can pop the top of stack\\n                        \\n                        # And since the character that we are popping is same as \"letter\"\\n                        # Then repetitions will increase by \"1\" because we now have\\n                        # \"1\" extra \"letter\" to put in our subsequence\\n                        \\n                        # Another condition to keep in mind is that we should only remove from stack\\n                        # If we know that we have enough characters left to traverse to make sure\\n                        # We can get a \"k\" length subsequence\\n                        # We don\\'t want to get a stack with less than \"k\" characters in it at the end\\n                        if countOnRight[i] > repetition and (k - len(stack)) < (n - i): \\n                            repetition += 1\\n                            stack.pop()\\n                            \\n                        # Otherwise, we cannot pop so the top of stack will remain in stack\\n                        # And so we come out of the loop\\n                        else: break\\n\\n\\n                    # 1.2 The character on top of stack is not \"letter\"\\n                    # In this case, we can safely pop the top of stack\\n                    else:                         \\n                        if (k - len(stack)) < (n - i): stack.pop()\\n                        else: break\\n                        \\n                # 2. The character on top of stack might be smaller or equal than the current character\\n                elif s[stack[-1]] <= s[i]:\\n                    \\n                    \\n                    # 2.1 The only time we should pop from stack in this case\\n                    # is when current character is \"letter\"\\n                    # Even then, there should be a certain condition\\n                    if s[i] == letter:\\n                        \\n                        # Length of stack represents the length of subsequence\\n                        # So, at any point, if we want to know how many characters are left to put in subsequence to return\\n                        # We can say -> k - len(stack)\\n                        # So, at this point, if k - len(stack) is less than repetitions\\n                        # It means, we need to pop from stack\\n                        \\n                        \\n                        # If the character that we are popping is same as \"letter\"\\n                        # Then repetitions will increase by \"1\" because we now have\\n                        # \"1\" extra \"letter\" to put in our subsequence\\n                        if k - len(stack) < repetition: \\n                            if stack[-1] == letter: repetition += 1\\n                            stack.pop()\\n                        else: \\n                            break\\n                        \\n                    # Otherwise, no need to pop from the stack\\n                    else: break\\n            \\n            # Push the current character\\'s index in the stack\\n            # Also, if the character that we push is same as \"letter\", that means we need one less repetition\\n            if s[i] == letter: repetition -= 1\\n                \\n            stack.append(i)\\n    \\n        # We need only the first \"k\" characters of stack\\n        # So update it accordingly\\n        stack = [s[i] for i in stack[:k]]\\n        \\n        # Finally, just return the string\\n        return \"\".join(stack)\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        # Length of the string\\n        n = len(s)\\n        \\n        # Count of \"letter\" characters on right of each character\\n        countOnRight = [0] * n\\n        countSoFar = 0\\n        \\n        for i in range(n - 1, -1, -1):\\n            # Update the count of \"letter\" characters on right of current character\\n            countOnRight[i] = countSoFar\\n            if s[i] == letter: countSoFar += 1\\n                \\n        # Stack that we will use to generate the smallest subsequence\\n        stack = []\\n        \\n        # Loop over the string\\n        for i in range(n):\\n            \\n            # If the stack is not empty then what are the situations we will face?\\n            while stack:\\n                \\n                # 1. The character on top of stack might be greater than the current character\\n                if s[stack[-1]] > s[i]:\\n                    # Here also, we have two situations\\n                    \\n                    # 1.1 The character on top of stack is \"letter\"\\n                    if s[stack[-1]] == letter:\\n                        # In this case, if we pop the top of stack\\n                        # It would mean repetition will increase by \"1\"\\n                        # So,we need to be sure that we have enough \"letter\" characters on the right of s[i]\\n                        \\n                        # If we have enough \"letter\" characters on right of current index\\n                        # Then we can pop the top of stack\\n                        \\n                        # And since the character that we are popping is same as \"letter\"\\n                        # Then repetitions will increase by \"1\" because we now have\\n                        # \"1\" extra \"letter\" to put in our subsequence\\n                        \\n                        # Another condition to keep in mind is that we should only remove from stack\\n                        # If we know that we have enough characters left to traverse to make sure\\n                        # We can get a \"k\" length subsequence\\n                        # We don\\'t want to get a stack with less than \"k\" characters in it at the end\\n                        if countOnRight[i] > repetition and (k - len(stack)) < (n - i): \\n                            repetition += 1\\n                            stack.pop()\\n                            \\n                        # Otherwise, we cannot pop so the top of stack will remain in stack\\n                        # And so we come out of the loop\\n                        else: break\\n\\n\\n                    # 1.2 The character on top of stack is not \"letter\"\\n                    # In this case, we can safely pop the top of stack\\n                    else:                         \\n                        if (k - len(stack)) < (n - i): stack.pop()\\n                        else: break\\n                        \\n                # 2. The character on top of stack might be smaller or equal than the current character\\n                elif s[stack[-1]] <= s[i]:\\n                    \\n                    \\n                    # 2.1 The only time we should pop from stack in this case\\n                    # is when current character is \"letter\"\\n                    # Even then, there should be a certain condition\\n                    if s[i] == letter:\\n                        \\n                        # Length of stack represents the length of subsequence\\n                        # So, at any point, if we want to know how many characters are left to put in subsequence to return\\n                        # We can say -> k - len(stack)\\n                        # So, at this point, if k - len(stack) is less than repetitions\\n                        # It means, we need to pop from stack\\n                        \\n                        \\n                        # If the character that we are popping is same as \"letter\"\\n                        # Then repetitions will increase by \"1\" because we now have\\n                        # \"1\" extra \"letter\" to put in our subsequence\\n                        if k - len(stack) < repetition: \\n                            if stack[-1] == letter: repetition += 1\\n                            stack.pop()\\n                        else: \\n                            break\\n                        \\n                    # Otherwise, no need to pop from the stack\\n                    else: break\\n            \\n            # Push the current character\\'s index in the stack\\n            # Also, if the character that we push is same as \"letter\", that means we need one less repetition\\n            if s[i] == letter: repetition -= 1\\n                \\n            stack.append(i)\\n    \\n        # We need only the first \"k\" characters of stack\\n        # So update it accordingly\\n        stack = [s[i] for i in stack[:k]]\\n        \\n        # Finally, just return the string\\n        return \"\".join(stack)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3644784,
                "title": "c-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n        int n=s.length();\\n        stack<char>st;\\n        vector<int>suf(n);\\n        suf[n-1]=(s[n-1]==letter ? 1:0);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==letter)\\n                suf[i]=suf[i+1]+1;\\n            else\\n                suf[i]=suf[i+1];\\n        }\\n        \\n        int curr_let=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && st.top()>s[i])\\n            {\\n            // If we are removing stack top which is letter make sure we have enough occurences of it later.\\n                if(st.top()==letter && (curr_let-1+suf[i])<rep)\\n                    break;\\n                // Make sure we still have enough chars to fill length k.\\n                if((st.size()-1+n-i)<k)\\n                    break;\\n                // Update letter count seen till now.\\n                if(st.top()==letter)\\n                    curr_let--;\\n                st.pop();\\n            }\\n            \\n            // Number of chars still need to be filled.\\n            int v1=k-st.size();\\n            // Number of letter still need to be filled.\\n            int v2=rep-curr_let;\\n            // Check if we can still fill a non-letter character , otherwise skip current character.\\n            if((s[i]!=letter) && v1<=v2)\\n            {\\n                continue;\\n            }\\n            // Add element only if size is not greater than k, update letter count.\\n            if(st.size()<k)\\n            {\\n                st.push(s[i]);\\n                if(s[i]==letter)\\n                    curr_let++;\\n            }\\n        }\\n        \\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n        int n=s.length();\\n        stack<char>st;\\n        vector<int>suf(n);\\n        suf[n-1]=(s[n-1]==letter ? 1:0);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==letter)\\n                suf[i]=suf[i+1]+1;\\n            else\\n                suf[i]=suf[i+1];\\n        }\\n        \\n        int curr_let=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && st.top()>s[i])\\n            {\\n            // If we are removing stack top which is letter make sure we have enough occurences of it later.\\n                if(st.top()==letter && (curr_let-1+suf[i])<rep)\\n                    break;\\n                // Make sure we still have enough chars to fill length k.\\n                if((st.size()-1+n-i)<k)\\n                    break;\\n                // Update letter count seen till now.\\n                if(st.top()==letter)\\n                    curr_let--;\\n                st.pop();\\n            }\\n            \\n            // Number of chars still need to be filled.\\n            int v1=k-st.size();\\n            // Number of letter still need to be filled.\\n            int v2=rep-curr_let;\\n            // Check if we can still fill a non-letter character , otherwise skip current character.\\n            if((s[i]!=letter) && v1<=v2)\\n            {\\n                continue;\\n            }\\n            // Add element only if size is not greater than k, update letter count.\\n            if(st.size()<k)\\n            {\\n                st.push(s[i]);\\n                if(s[i]==letter)\\n                    curr_let++;\\n            }\\n        }\\n        \\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570976,
                "title": "easy-to-understand-code-with-reference-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem is similar to leetcode 316 -> https://leetcode.com/problems/remove-duplicate-letters/\\nTry to solve that problem with stack and you will see the similar logic can be applied here.\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity will be O(n) as in the main computation of stack the maximum number of times we reach at the same index of the string is 2.\\n\\n- Space complexity:\\nSpace complexity will O(n) for the occurAfter and O(k) for the stack. Overall complexity will be O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n\\n        int n = s.length();\\n        vector<int> occurAfter(n+1,0);\\n\\n        for(int i =n-1;i>=0;i--) {\\n\\n            occurAfter[i] = occurAfter[i+1];\\n            if(s[i] == letter) {\\n                occurAfter[i]++;\\n            }\\n        }\\n\\n        stack<int> st;\\n        \\n        for(int i =0;i<n;i++) {\\n\\n            int remainingChars = n-i; // including current one\\n            \\n            while(!st.empty() && st.top() > s[i] && remainingChars > k) {\\n\\n                // to check if we have enough letter available for make string of size k\\n                if(st.top() == letter) {\\n                    if(occurAfter[i] <= rep) {\\n                        break;\\n                    }\\n                }\\n\\n                if(st.top() == letter) {\\n                    rep++;\\n                }\\n\\n                k++;\\n                st.pop();\\n            }\\n\\n            // we shouldn\\'t add the character if we don\\'t have enough space for repetitive letter\\n            if(k == rep  && s[i] != letter) {\\n                continue;\\n            }\\n\\n            // don\\'t add character if it won\\'t be part of k-length string\\n            if(k == 0) {\\n                continue;\\n            }\\n\\n            // add the character\\n            st.push(s[i]);\\n            k--;\\n            if(s[i] == letter) {\\n                rep--;\\n            }\\n        }\\n\\n        string res = \"\";\\n\\n        while(!st.empty()) {\\n            res += st.top();\\n            st.pop();\\n        }\\n\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n\\n        int n = s.length();\\n        vector<int> occurAfter(n+1,0);\\n\\n        for(int i =n-1;i>=0;i--) {\\n\\n            occurAfter[i] = occurAfter[i+1];\\n            if(s[i] == letter) {\\n                occurAfter[i]++;\\n            }\\n        }\\n\\n        stack<int> st;\\n        \\n        for(int i =0;i<n;i++) {\\n\\n            int remainingChars = n-i; // including current one\\n            \\n            while(!st.empty() && st.top() > s[i] && remainingChars > k) {\\n\\n                // to check if we have enough letter available for make string of size k\\n                if(st.top() == letter) {\\n                    if(occurAfter[i] <= rep) {\\n                        break;\\n                    }\\n                }\\n\\n                if(st.top() == letter) {\\n                    rep++;\\n                }\\n\\n                k++;\\n                st.pop();\\n            }\\n\\n            // we shouldn\\'t add the character if we don\\'t have enough space for repetitive letter\\n            if(k == rep  && s[i] != letter) {\\n                continue;\\n            }\\n\\n            // don\\'t add character if it won\\'t be part of k-length string\\n            if(k == 0) {\\n                continue;\\n            }\\n\\n            // add the character\\n            st.push(s[i]);\\n            k--;\\n            if(s[i] == letter) {\\n                rep--;\\n            }\\n        }\\n\\n        string res = \"\";\\n\\n        while(!st.empty()) {\\n            res += st.top();\\n            st.pop();\\n        }\\n\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491080,
                "title": "c-monotonic-stack",
                "content": "```\\npublic class Solution {\\n    public string SmallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n=s.Length;\\n        int c=0;\\n       \\n        for(int i=0;i<n;i++)\\n            c= s[i]==letter ? c+1: c;\\n        char[] res = new char[k];\\n        int idx=-1;\\n        int r=repetition;\\n        for(int i=0;i<n;i++){\\n            int rem=n-i;\\n            \\n            while(idx>=0 && res[idx] >s[i]  && (rem+idx+1>k) && (res[idx] != letter || c>r))\\n                if(res[idx--]==letter)\\n                    r++;\\n\\n            if(idx <k-1){\\n                if(s[i]==letter ){\\n                    r--;\\n                    res[++idx]=s[i];\\n                }else if((idx+1) <(k-r))\\n                    res[++idx]=s[i];\\n            }\\n            \\n            if(s[i]==letter )\\n                    c--;\\n        }\\n        \\n        String answer=new String(res);\\n            \\n        return answer;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string SmallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n=s.Length;\\n        int c=0;\\n       \\n        for(int i=0;i<n;i++)\\n            c= s[i]==letter ? c+1: c;\\n        char[] res = new char[k];\\n        int idx=-1;\\n        int r=repetition;\\n        for(int i=0;i<n;i++){\\n            int rem=n-i;\\n            \\n            while(idx>=0 && res[idx] >s[i]  && (rem+idx+1>k) && (res[idx] != letter || c>r))\\n                if(res[idx--]==letter)\\n                    r++;\\n\\n            if(idx <k-1){\\n                if(s[i]==letter ){\\n                    r--;\\n                    res[++idx]=s[i];\\n                }else if((idx+1) <(k-r))\\n                    res[++idx]=s[i];\\n            }\\n            \\n            if(s[i]==letter )\\n                    c--;\\n        }\\n        \\n        String answer=new String(res);\\n            \\n        return answer;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314638,
                "title": "o-n-use-provided-rules-to-build-smallest-string-with-stack",
                "content": "During my first attempt at this question, I made a mistake of thinking about the stack push/pop rules during implementation (instead of being clear about them beforehand) which led to bugs and messy code. It is extremely important to be clear on the rules (note down the rules somewhere before you start coding) that need to be strictly followed when adding or removing from stack. Once you are clear with the rules the implementation is relatively straight-forward.\\n\\nRules are:\\n1. Add non repeating letter only if the number of positions available (k - current size of stack) are greater than the positions required to repeat letter\\n2. Check before adding character that the size of string is less than k\\n3. Before removing any letter check that there are enough letters remaining to make a string of size k\\n4. Before a repeating letter is removed keep track of how many times it is repeated so far in the string and if there are more repeating letters available to the right that we can use if we are under the repetition count\\n\\n```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        Deque<Character> stack = new ArrayDeque<Character>();\\n        int letterCount = 0;\\n        int letterInStack = 0;\\n        char[] c = s.toCharArray();\\n        for (int i = 0; i < c.length; i++) {\\n            if (c[i] == letter) {\\n                letterCount++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < c.length; i++) {\\n            if (c[i] == letter) {\\n                letterCount--;\\n            }\\n            \\n            while (!stack.isEmpty() && c[i] < stack.peekFirst()) {\\n                boolean shouldReplaceLastLetter = true;\\n                if (c[i] != letter) {\\n                    if (stack.peekFirst() == letter) {\\n                        // Before replacing a repeating letter with a different non-repeating letter,\\n                        // check that we will have sufficient repeating letters available to the right\\n                        shouldReplaceLastLetter = letterCount >= repetition - (letterInStack - 1) ? true : false;\\n                    }\\n                }\\n                \\n                // Before replacing a non repeating letter with a repeating letter or\\n                // replacing a non repeating letter with another non repeating letter or\\n                // replacing a repeating letter with a non-repeating letter\\n                // check that the no. of chars remaining will be sufficient to make a string of size k\\n                if (shouldReplaceLastLetter) {\\n                    int lettersNeeded = k - stack.size();\\n                    int lettersAvailable = c.length - i - 1;\\n                    shouldReplaceLastLetter = lettersAvailable >= lettersNeeded ? true : false;\\n                }\\n                                \\n                if (shouldReplaceLastLetter) {\\n                    if (stack.peekFirst() == letter) {\\n                        letterInStack--;\\n                    }\\n                    stack.removeFirst();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            if (stack.size() < k) {\\n                if (c[i] == letter) {\\n                    letterInStack++;\\n                    stack.addFirst(c[i]);\\n                } else if (k - stack.size() > repetition - letterInStack) {\\n                    // Check if there are enough spots available to repeat \"letter\" in the future before adding a non-repeating letter to the string\\n                    stack.addFirst(c[i]);\\n                }\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            sb.append(stack.removeFirst());\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        Deque<Character> stack = new ArrayDeque<Character>();\\n        int letterCount = 0;\\n        int letterInStack = 0;\\n        char[] c = s.toCharArray();\\n        for (int i = 0; i < c.length; i++) {\\n            if (c[i] == letter) {\\n                letterCount++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < c.length; i++) {\\n            if (c[i] == letter) {\\n                letterCount--;\\n            }\\n            \\n            while (!stack.isEmpty() && c[i] < stack.peekFirst()) {\\n                boolean shouldReplaceLastLetter = true;\\n                if (c[i] != letter) {\\n                    if (stack.peekFirst() == letter) {\\n                        // Before replacing a repeating letter with a different non-repeating letter,\\n                        // check that we will have sufficient repeating letters available to the right\\n                        shouldReplaceLastLetter = letterCount >= repetition - (letterInStack - 1) ? true : false;\\n                    }\\n                }\\n                \\n                // Before replacing a non repeating letter with a repeating letter or\\n                // replacing a non repeating letter with another non repeating letter or\\n                // replacing a repeating letter with a non-repeating letter\\n                // check that the no. of chars remaining will be sufficient to make a string of size k\\n                if (shouldReplaceLastLetter) {\\n                    int lettersNeeded = k - stack.size();\\n                    int lettersAvailable = c.length - i - 1;\\n                    shouldReplaceLastLetter = lettersAvailable >= lettersNeeded ? true : false;\\n                }\\n                                \\n                if (shouldReplaceLastLetter) {\\n                    if (stack.peekFirst() == letter) {\\n                        letterInStack--;\\n                    }\\n                    stack.removeFirst();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            if (stack.size() < k) {\\n                if (c[i] == letter) {\\n                    letterInStack++;\\n                    stack.addFirst(c[i]);\\n                } else if (k - stack.size() > repetition - letterInStack) {\\n                    // Check if there are enough spots available to repeat \"letter\" in the future before adding a non-repeating letter to the string\\n                    stack.addFirst(c[i]);\\n                }\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            sb.append(stack.removeFirst());\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246454,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn smallest_subsequence(s: String, k: i32, letter: char, repetition: i32) -> String {\\n        let letter = letter as i32;\\n        let s = s.as_bytes().iter().map(|&c| c as i32).collect::<Vec<i32>>();\\n        let mut repetition = repetition;\\n        let mut extra = s.iter().filter(|&&c| c == letter).count() as i32 - repetition;\\n        let mut remove = s.len() as i32 - k;\\n        let mut mono = Vec::new();\\n        for &ch in s.iter() {\\n            while !mono.is_empty() && mono[mono.len() - 1] > ch && remove > 0 {\\n                let mono_back = mono[mono.len() - 1];\\n                if mono_back == letter && extra == 0 {\\n                    break;\\n                }\\n                extra -= i32::from(mono_back == letter);\\n                remove -= 1;\\n                mono.pop();\\n            }\\n            mono.push(ch);\\n        }\\n        let mut res = Vec::new();\\n        let mut i = 0;\\n        while res.len() < k as usize {\\n            if mono[i] != letter && res.len() + 0.max(repetition) as usize >= k as usize {\\n                i += 1;\\n                continue;\\n            }\\n            res.push(mono[i] as u8);\\n            repetition -= i32::from(mono[i] == letter);\\n            i += 1;\\n        }\\n        String::from_utf8(res).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn smallest_subsequence(s: String, k: i32, letter: char, repetition: i32) -> String {\\n        let letter = letter as i32;\\n        let s = s.as_bytes().iter().map(|&c| c as i32).collect::<Vec<i32>>();\\n        let mut repetition = repetition;\\n        let mut extra = s.iter().filter(|&&c| c == letter).count() as i32 - repetition;\\n        let mut remove = s.len() as i32 - k;\\n        let mut mono = Vec::new();\\n        for &ch in s.iter() {\\n            while !mono.is_empty() && mono[mono.len() - 1] > ch && remove > 0 {\\n                let mono_back = mono[mono.len() - 1];\\n                if mono_back == letter && extra == 0 {\\n                    break;\\n                }\\n                extra -= i32::from(mono_back == letter);\\n                remove -= 1;\\n                mono.pop();\\n            }\\n            mono.push(ch);\\n        }\\n        let mut res = Vec::new();\\n        let mut i = 0;\\n        while res.len() < k as usize {\\n            if mono[i] != letter && res.len() + 0.max(repetition) as usize >= k as usize {\\n                i += 1;\\n                continue;\\n            }\\n            res.push(mono[i] as u8);\\n            repetition -= i32::from(mono[i] == letter);\\n            i += 1;\\n        }\\n        String::from_utf8(res).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3196006,
                "title": "monotonic-stack-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int letterCount = 0;\\n\\n        for (char ch : s.toCharArray()) {\\n\\n            if (ch == letter) {\\n                letterCount++;\\n            }\\n        }\\n        Deque<Character> monoStack = new LinkedList<>();\\n        int repeatCanBeDeleted = letterCount - repetition;\\n        int charCanBeDeleted = s.length() - k;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            while (!monoStack.isEmpty() && ch < monoStack.peek() && charCanBeDeleted > 0) {\\n\\n                if (monoStack.peek() == letter && repeatCanBeDeleted <= 0) {\\n                    break;\\n                }\\n\\n                if (monoStack.peek() == letter && repeatCanBeDeleted > 0) {\\n                    repeatCanBeDeleted--;\\n                }\\n                charCanBeDeleted--;\\n                monoStack.pop();\\n            }\\n            monoStack.push(ch);\\n        } \\n        StringBuilder holder = new StringBuilder();\\n\\n        while (!monoStack.isEmpty()) {\\n            char ch = monoStack.poll();\\n\\n            if (ch == letter) {\\n\\n                if (charCanBeDeleted > 0) {\\n                    \\n                    if (repeatCanBeDeleted > 0) {\\n                        repeatCanBeDeleted--;\\n                        charCanBeDeleted--;\\n                    } else {\\n                        holder.insert(0, ch);    \\n                    }\\n                } else {\\n                    holder.insert(0, ch);\\n                }\\n            } else {\\n\\n                if (charCanBeDeleted > 0) {\\n                    charCanBeDeleted--;\\n                } else {\\n                    holder.insert(0, ch);\\n                }\\n            }\\n        }\\n        return holder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int letterCount = 0;\\n\\n        for (char ch : s.toCharArray()) {\\n\\n            if (ch == letter) {\\n                letterCount++;\\n            }\\n        }\\n        Deque<Character> monoStack = new LinkedList<>();\\n        int repeatCanBeDeleted = letterCount - repetition;\\n        int charCanBeDeleted = s.length() - k;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            while (!monoStack.isEmpty() && ch < monoStack.peek() && charCanBeDeleted > 0) {\\n\\n                if (monoStack.peek() == letter && repeatCanBeDeleted <= 0) {\\n                    break;\\n                }\\n\\n                if (monoStack.peek() == letter && repeatCanBeDeleted > 0) {\\n                    repeatCanBeDeleted--;\\n                }\\n                charCanBeDeleted--;\\n                monoStack.pop();\\n            }\\n            monoStack.push(ch);\\n        } \\n        StringBuilder holder = new StringBuilder();\\n\\n        while (!monoStack.isEmpty()) {\\n            char ch = monoStack.poll();\\n\\n            if (ch == letter) {\\n\\n                if (charCanBeDeleted > 0) {\\n                    \\n                    if (repeatCanBeDeleted > 0) {\\n                        repeatCanBeDeleted--;\\n                        charCanBeDeleted--;\\n                    } else {\\n                        holder.insert(0, ch);    \\n                    }\\n                } else {\\n                    holder.insert(0, ch);\\n                }\\n            } else {\\n\\n                if (charCanBeDeleted > 0) {\\n                    charCanBeDeleted--;\\n                } else {\\n                    holder.insert(0, ch);\\n                }\\n            }\\n        }\\n        return holder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027315,
                "title": "stack-solution-explained-python",
                "content": "First question you need ask yourself is,\\n**How to find the smallest subsequence of s of length k?**\\nYou can do this using DP, but more efficient and easier way is non decreasing stack.\\n\\nYou follow the same procedure in this problem, but\\nif `stack.top() == letter`, remove it if there are enough letters remaining\\notherwise you can\\'t afford to remove letter.\\n\\n**Time: O(n)\\nSpace:O(n)**\\n```\\ndef smallestSubsequence(self, s, k, letter, repetition):\\n    n = len(s)\\n\\n    letter_count = s.count(letter)\\n    stack = []\\n    for i in range(n):\\n        while stack and s[i] < stack[-1] and len(stack) + n - i > k:\\n            if stack[-1] == letter and letter_count == repetition:\\n                break\\n            repetition += (stack[-1] == letter)\\n            stack.pop()\\n        repetition -= (s[i] == letter)\\n        letter_count -= (s[i] == letter)\\n        stack.append(s[i])\\n    \\n    diff = len(stack) - k\\n    i = len(stack) - 1\\n    while diff:\\n        if stack[i] != letter or repetition < 0:\\n            repetition += (stack[i] == letter)\\n            stack[i] = \"\"\\n            diff -= 1\\n        i -= 1\\n    \\n    return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\ndef smallestSubsequence(self, s, k, letter, repetition):\\n    n = len(s)\\n\\n    letter_count = s.count(letter)\\n    stack = []\\n    for i in range(n):\\n        while stack and s[i] < stack[-1] and len(stack) + n - i > k:\\n            if stack[-1] == letter and letter_count == repetition:\\n                break\\n            repetition += (stack[-1] == letter)\\n            stack.pop()\\n        repetition -= (s[i] == letter)\\n        letter_count -= (s[i] == letter)\\n        stack.append(s[i])\\n    \\n    diff = len(stack) - k\\n    i = len(stack) - 1\\n    while diff:\\n        if stack[i] != letter or repetition < 0:\\n            repetition += (stack[i] == letter)\\n            stack[i] = \"\"\\n            diff -= 1\\n        i -= 1\\n    \\n    return \"\".join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2952950,
                "title": "monotonic-stack-greedy-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        // we can solve this problem using\\n        // monotonic stack and greedy strategy\\n        int n = s.size();\\n\\n        // the number of characters that we can remove\\n        int totalChances = n - k;\\n\\n        // frequence of the letter\\n        int letterCount = 0;\\n\\n        for(char& c : s) {\\n            if(c == letter) letterCount++;\\n        }\\n\\n        // the number of \"letter\" character that we can remove\\n        int letterChances = letterCount - repetition;\\n\\n        // monotonic stack\\n        deque<char> mono;\\n\\n        for(char& c : s) {\\n            while(not mono.empty() and mono.back()>c and totalChances) {\\n                if(mono.back() == letter) {\\n                    if(letterChances) {\\n                        mono.pop_back();\\n                        letterChances--;\\n                        totalChances--;\\n                    }\\n                    else break;\\n                }\\n                else {\\n                    mono.pop_back();\\n                    totalChances--;\\n                }\\n            }\\n\\n            mono.push_back(c);\\n        }\\n\\n        // count of \"letter\" character that we pop from the stack\\n        int remLetterCount = 0;\\n\\n        int size = mono.size();\\n\\n        // while the size of the result is greater than k\\n        while(size > k) {\\n            if(mono.back() == letter) {\\n                if(letterChances) {\\n                    letterChances--;\\n                    size--;\\n                }\\n                else {\\n                    remLetterCount++;\\n                }\\n            }\\n            else size--;\\n\\n            mono.pop_back();\\n        }\\n\\n        // add back the removed \"letter\" characters\\n        for(int i=0; i<remLetterCount; i++) {\\n            mono.push_back(letter);\\n        }\\n\\n        string result(mono.begin(), mono.end());\\n\\n        return result;\\n    }\\n};\\n```\\n-------\\n## Similar Problems\\n* [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/description/)\\n* [321. Create Maximum Number](https://leetcode.com/problems/create-maximum-number/description/)\\n\\n> **The above problems all follow `Lexicographic Subsequence of Length K` pattern.**\\n\\n#### **Consider upvoting if you found my solution useful!**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        // we can solve this problem using\\n        // monotonic stack and greedy strategy\\n        int n = s.size();\\n\\n        // the number of characters that we can remove\\n        int totalChances = n - k;\\n\\n        // frequence of the letter\\n        int letterCount = 0;\\n\\n        for(char& c : s) {\\n            if(c == letter) letterCount++;\\n        }\\n\\n        // the number of \"letter\" character that we can remove\\n        int letterChances = letterCount - repetition;\\n\\n        // monotonic stack\\n        deque<char> mono;\\n\\n        for(char& c : s) {\\n            while(not mono.empty() and mono.back()>c and totalChances) {\\n                if(mono.back() == letter) {\\n                    if(letterChances) {\\n                        mono.pop_back();\\n                        letterChances--;\\n                        totalChances--;\\n                    }\\n                    else break;\\n                }\\n                else {\\n                    mono.pop_back();\\n                    totalChances--;\\n                }\\n            }\\n\\n            mono.push_back(c);\\n        }\\n\\n        // count of \"letter\" character that we pop from the stack\\n        int remLetterCount = 0;\\n\\n        int size = mono.size();\\n\\n        // while the size of the result is greater than k\\n        while(size > k) {\\n            if(mono.back() == letter) {\\n                if(letterChances) {\\n                    letterChances--;\\n                    size--;\\n                }\\n                else {\\n                    remLetterCount++;\\n                }\\n            }\\n            else size--;\\n\\n            mono.pop_back();\\n        }\\n\\n        // add back the removed \"letter\" characters\\n        for(int i=0; i<remLetterCount; i++) {\\n            mono.push_back(letter);\\n        }\\n\\n        string result(mono.begin(), mono.end());\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942819,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @param {character} letter\\n * @param {number} repetition\\n * @return {string}\\n */\\n\\n\\nconst smallestSubsequence = (s, k, letter, repetition) => {\\n    let n = s.length, st = \\'\\', rest = 0, letterCnt = 0;\\n    let visit = Array(n + 1).fill(0);\\n    for (const c of s) {\\n        if (c == letter) rest++;\\n    }\\n    for (let i = 0; i < n; i++) {\\n        while (1) {\\n            if (st.length == 0) break;\\n            if (st.length + (n - i) <= k) break;\\n            if (st[st.length - 1] <= s[i]) break;\\n            if (st[st.length - 1] == letter && letterCnt - 1 + rest < repetition) break;\\n            if (st[st.length - 1] == letter) letterCnt--;\\n            st = st.slice(0, st.length - 1);\\n        }\\n        st += s[i];\\n        if (s[i] == letter) {\\n            letterCnt++;\\n            rest--;\\n        }\\n    }\\n    let pos = letterCnt - repetition;\\n    letterCnt = st.length - k;\\n    for (let i = st.length - 1; ~i; i--) {\\n        if (letterCnt > 0 && pos > 0 && st[i] == letter) {\\n            visit[i] = 1;\\n            letterCnt--;\\n            pos--;\\n        }\\n        if (letterCnt > 0 && st[i] != letter) {\\n            visit[i] = 1;\\n            letterCnt--;\\n        }\\n    }\\n    let res = \\'\\';\\n    for (let i = 0; i < st.length; i++) {\\n        if (!visit[i]) res += st[i];\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @param {character} letter\\n * @param {number} repetition\\n * @return {string}\\n */\\n\\n\\nconst smallestSubsequence = (s, k, letter, repetition) => {\\n    let n = s.length, st = \\'\\', rest = 0, letterCnt = 0;\\n    let visit = Array(n + 1).fill(0);\\n    for (const c of s) {\\n        if (c == letter) rest++;\\n    }\\n    for (let i = 0; i < n; i++) {\\n        while (1) {\\n            if (st.length == 0) break;\\n            if (st.length + (n - i) <= k) break;\\n            if (st[st.length - 1] <= s[i]) break;\\n            if (st[st.length - 1] == letter && letterCnt - 1 + rest < repetition) break;\\n            if (st[st.length - 1] == letter) letterCnt--;\\n            st = st.slice(0, st.length - 1);\\n        }\\n        st += s[i];\\n        if (s[i] == letter) {\\n            letterCnt++;\\n            rest--;\\n        }\\n    }\\n    let pos = letterCnt - repetition;\\n    letterCnt = st.length - k;\\n    for (let i = st.length - 1; ~i; i--) {\\n        if (letterCnt > 0 && pos > 0 && st[i] == letter) {\\n            visit[i] = 1;\\n            letterCnt--;\\n            pos--;\\n        }\\n        if (letterCnt > 0 && st[i] != letter) {\\n            visit[i] = 1;\\n            letterCnt--;\\n        }\\n    }\\n    let res = \\'\\';\\n    for (let i = 0; i < st.length; i++) {\\n        if (!visit[i]) res += st[i];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908175,
                "title": "python-heap-based-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(N * log(N))$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        suffix_count = [0 for _ in range(len(s) + 1)]\\n\\n        for i in range(len(s) - 1, -1, -1):\\n            suffix_count[i] = suffix_count[i + 1] + int(s[i] == letter)\\n    \\n        heap = []\\n        result = []\\n        in_result = right = left = 0\\n        \\n        while len(result) < k:\\n            while heap and heap[0][1] < left:\\n                ch = heappop(heap)\\n            \\n            while right < len(s) and len(s) - right >= k - len(result) and suffix_count[right] >= repetition - in_result:\\n                heappush(heap, (s[right], right))\\n                right += 1\\n\\n            ch, idx = heappop(heap)\\n            \\n            in_result += int(ch == letter)\\n            if ch == letter or k - len(result) > repetition - in_result:\\n                result.append(ch)\\n            left = idx + 1\\n        \\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        suffix_count = [0 for _ in range(len(s) + 1)]\\n\\n        for i in range(len(s) - 1, -1, -1):\\n            suffix_count[i] = suffix_count[i + 1] + int(s[i] == letter)\\n    \\n        heap = []\\n        result = []\\n        in_result = right = left = 0\\n        \\n        while len(result) < k:\\n            while heap and heap[0][1] < left:\\n                ch = heappop(heap)\\n            \\n            while right < len(s) and len(s) - right >= k - len(result) and suffix_count[right] >= repetition - in_result:\\n                heappush(heap, (s[right], right))\\n                right += 1\\n\\n            ch, idx = heappop(heap)\\n            \\n            in_result += int(ch == letter)\\n            if ch == letter or k - len(result) > repetition - in_result:\\n                result.append(ch)\\n            left = idx + 1\\n        \\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886280,
                "title": "easy-to-understand-o-n-solution",
                "content": "```\\nstring smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n = s.size();\\n        int numLetters = 0;\\n        for (auto &c : s)\\n            numLetters += (c == letter);\\n        int extraLetters = numLetters - repetition; // total number of letters which are extra\\n        int canRemove = n-k; // total characters unwanted can be removed\\n        \\n        string monoStack;\\n        for (auto &c : s) {\\n            // keep the monotonic string unless we \\n            // we don\\'t have any more letters to purge\\n            while (canRemove && !monoStack.empty() && monoStack.back() > c) {\\n                // we won\\'t pop out the letter even if it disturb the monotonic \\n                // order as repetition number of letters are needed.\\n                if (monoStack.back() == letter && extraLetters == 0)\\n                    break;\\n                extraLetters -= (monoStack.back() == letter);\\n                monoStack.pop_back();\\n                canRemove--;\\n            }\\n            monoStack.push_back(c);\\n        }\\n        \\n        // so monotonic stack is sorted string on non letters and compulsory repetion letters in the end.\\n        // pick up all minimumm required non letter characters from monotoic stack and \\n        string res;\\n        int letterCount = repetition; // number of letters needed compulsory\\n        int remLetters = k - repetition; // rest all letters\\n        // pick above 2 letters from monotonic constructed list from above\\n        for (int i = 0; (letterCount || nonLetters) ; i++) {\\n            if ((monoStack[i] == letter) && letterCount) {\\n                res += monoStack[i];\\n                letterCount--;\\n            } else if (remLetters) {\\n                res += monoStack[i];\\n                remLetters--;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nstring smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n = s.size();\\n        int numLetters = 0;\\n        for (auto &c : s)\\n            numLetters += (c == letter);\\n        int extraLetters = numLetters - repetition; // total number of letters which are extra\\n        int canRemove = n-k; // total characters unwanted can be removed\\n        \\n        string monoStack;\\n        for (auto &c : s) {\\n            // keep the monotonic string unless we \\n            // we don\\'t have any more letters to purge\\n            while (canRemove && !monoStack.empty() && monoStack.back() > c) {\\n                // we won\\'t pop out the letter even if it disturb the monotonic \\n                // order as repetition number of letters are needed.\\n                if (monoStack.back() == letter && extraLetters == 0)\\n                    break;\\n                extraLetters -= (monoStack.back() == letter);\\n                monoStack.pop_back();\\n                canRemove--;\\n            }\\n            monoStack.push_back(c);\\n        }\\n        \\n        // so monotonic stack is sorted string on non letters and compulsory repetion letters in the end.\\n        // pick up all minimumm required non letter characters from monotoic stack and \\n        string res;\\n        int letterCount = repetition; // number of letters needed compulsory\\n        int remLetters = k - repetition; // rest all letters\\n        // pick above 2 letters from monotonic constructed list from above\\n        for (int i = 0; (letterCount || nonLetters) ; i++) {\\n            if ((monoStack[i] == letter) && letterCount) {\\n                res += monoStack[i];\\n                letterCount--;\\n            } else if (remLetters) {\\n                res += monoStack[i];\\n                remLetters--;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804902,
                "title": "simple-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n        \\n        if(k==rep)\\n        {\\n            string q=\"\";\\n            for(int i=0;i<rep;i++)\\n            {\\n                q+=letter;\\n            }\\n            return q;\\n        }\\n        \\n        int n=s.length();\\n        vector<int> mad(n,0);\\n        int c=0;\\n        for(int i=(n-1);i>=0;i--)\\n        {\\n            mad[i]=c;\\n            if(s[i]==letter)\\n                c++;\\n        }\\n        \\n        stack<char> sad;\\n        c=0;\\n        int d=k-rep,e=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!sad.empty())\\n            {\\n                if(s[i]<sad.top())\\n                {\\n                    while(!sad.empty() && s[i]<sad.top())\\n                    {\\n                        if(sad.top()==letter)\\n                        {\\n                            int p=sad.size()-1;\\n                            if(mad[i]>=(rep-(c-1)) && (n-i)>=(k-p) )\\n                            {\\n                                sad.pop();\\n                                c--;\\n                            }\\n                            else{\\n                                break;\\n                            }\\n                        }\\n                        else{\\n                            int p=sad.size()-1;\\n                            if((n-i)>=(k-p))\\n                            {\\n                                sad.pop();\\n                                e--;\\n                            }\\n                            else{\\n                                break;\\n                            }\\n                        }\\n                        \\n                    }\\n                    \\n                    if(sad.size()<k)\\n                    {\\n                        if(s[i]!=letter)\\n                        {\\n                            if(e<d)\\n                            {\\n                                sad.push(s[i]);\\n                                e++;\\n                            }\\n                        }\\n                        else{\\n                            sad.push(s[i]);\\n                            c++;\\n                        }\\n                    }\\n                    \\n                }\\n                else {\\n                    if(sad.size()<k)\\n                    {\\n                        if(s[i]==letter)\\n                        {\\n                            sad.push(s[i]);\\n                            c++;\\n                        }\\n                        else{\\n                            if(e<d)\\n                            {\\n                                sad.push(s[i]);\\n                                e++;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n               \\n                if(s[i]==letter)\\n                {\\n                    sad.push(s[i]);\\n                    c++;\\n                }\\n                else{\\n                    if(e<d)\\n                    {\\n                        sad.push(s[i]);\\n                        e++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!sad.empty())\\n        {\\n            ans+=sad.top();\\n            sad.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int rep) {\\n        \\n        if(k==rep)\\n        {\\n            string q=\"\";\\n            for(int i=0;i<rep;i++)\\n            {\\n                q+=letter;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2782596,
                "title": "monotonous-stack-with-clear-explanation-similar-to-316",
                "content": "Before you do this problem, try attempting #316 https://leetcode.com/problems/remove-duplicate-letters/\\n\\nWe use the same approach with some extra constraints as provided in the question. \\n\\n\\n\\n```\\npublic String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        Stack<Character> stack = new Stack<>();\\n        int index = 0;\\n        int remainingCountOfE = 0;\\n        int repetitionTemp = repetition;\\n\\n        // Maintain Count of the target letter\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter) {\\n                remainingCountOfE++;\\n            }\\n        }\\n        \\n        while (index < s.length()) {\\n            while (!stack.isEmpty() && stack.peek() > s.charAt(index)) {\\n                // First constraint to maintain result string of size K.\\n                // Since we have a constraint on string size k. We cannot pop out all the elements from the stack.\\n                // We need to verify if (number of remaining elements in stack) + (remaining characters in the string) > k \\n                if (stack.size() + s.length() - index <= k) {\\n                    break;\\n                }\\n                if (stack.peek() == letter) {\\n                    // Second constraint to repetition on target letter.\\n                    // We can only remove the current stack top (e) only if we are sure that we still have enough e\\'s \\n                    // in the later part of string which can help us in forming the resultant string\\n                    if (remainingCountOfE <= repetition) {\\n                        break;\\n                    }\\n                    repetition++;\\n                }\\n                stack.pop();\\n            }\\n            // We pop all the elements and push the current character in the index\\n            if (s.charAt(index) == letter) {\\n                remainingCountOfE--;\\n                repetition--;\\n            }\\n            stack.push(s.charAt(index));\\n            index++;\\n        }\\n        return buildResultString(stack, letter, k, repetitionTemp);\\n    }\\n\\n    public String buildResultString(Stack<Character> stack, Character letter, int k, int repetitionTemp) {\\n        // At this point our Mono Stack will have elements in increasing order except for the target character.\\n        // We may only k characters from the Stack but not all.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int stackLength = stack.size();\\n        int numberOfE = 0;\\n        \\n        \\n        while (!stack.isEmpty()) {\\n            char ch = stack.pop();\\n            // We greedily push the character to result string if it is target character.\\n            // If the stack length is greater than K, we wont push the top char in stack as we greedily\\n            // assume that the character in the below part of the stack is less than the current element\\n            // This assumption is true as this is a mono stack in increasing order except for target character\\n            if (ch == letter && numberOfE < repetitionTemp) {\\n                numberOfE++;\\n                sb.append(ch);\\n            } else if (stackLength <= k - numberOfE) {\\n                sb.append(ch);\\n            }\\n            stackLength--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        Stack<Character> stack = new Stack<>();\\n        int index = 0;\\n        int remainingCountOfE = 0;\\n        int repetitionTemp = repetition;\\n\\n        // Maintain Count of the target letter\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter) {\\n                remainingCountOfE++;\\n            }\\n        }\\n        \\n        while (index < s.length()) {\\n            while (!stack.isEmpty() && stack.peek() > s.charAt(index)) {\\n                // First constraint to maintain result string of size K.\\n                // Since we have a constraint on string size k. We cannot pop out all the elements from the stack.\\n                // We need to verify if (number of remaining elements in stack) + (remaining characters in the string) > k \\n                if (stack.size() + s.length() - index <= k) {\\n                    break;\\n                }\\n                if (stack.peek() == letter) {\\n                    // Second constraint to repetition on target letter.\\n                    // We can only remove the current stack top (e) only if we are sure that we still have enough e\\'s \\n                    // in the later part of string which can help us in forming the resultant string\\n                    if (remainingCountOfE <= repetition) {\\n                        break;\\n                    }\\n                    repetition++;\\n                }\\n                stack.pop();\\n            }\\n            // We pop all the elements and push the current character in the index\\n            if (s.charAt(index) == letter) {\\n                remainingCountOfE--;\\n                repetition--;\\n            }\\n            stack.push(s.charAt(index));\\n            index++;\\n        }\\n        return buildResultString(stack, letter, k, repetitionTemp);\\n    }\\n\\n    public String buildResultString(Stack<Character> stack, Character letter, int k, int repetitionTemp) {\\n        // At this point our Mono Stack will have elements in increasing order except for the target character.\\n        // We may only k characters from the Stack but not all.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int stackLength = stack.size();\\n        int numberOfE = 0;\\n        \\n        \\n        while (!stack.isEmpty()) {\\n            char ch = stack.pop();\\n            // We greedily push the character to result string if it is target character.\\n            // If the stack length is greater than K, we wont push the top char in stack as we greedily\\n            // assume that the character in the below part of the stack is less than the current element\\n            // This assumption is true as this is a mono stack in increasing order except for target character\\n            if (ch == letter && numberOfE < repetitionTemp) {\\n                numberOfE++;\\n                sb.append(ch);\\n            } else if (stackLength <= k - numberOfE) {\\n                sb.append(ch);\\n            }\\n            stackLength--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735895,
                "title": "easy-c-solution-with-explanation-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n         int cnt = count(s.begin(),s.end(),letter) , n = s.size();\\n         string stk , ans;\\n         for(int i=0; i<s.size(); i++) {\\n             // can we remove a big char , check enough elements are left in the array to make length atleast equal to k , also check cnt > repetition\\n             while(!stk.empty() && cnt>repetition && stk.back() > s[i] && stk.size() + (n - i) > k) {\\n                 if(letter == stk.back()) cnt--;\\n                 stk.pop_back();\\n             }\\n             // remove big char if they aren\\'t \\'letter\\' when repetition is still satisfied!\\n             while(!stk.empty() && stk.back()!=letter && stk.back() > s[i] && stk.size() + (n - i) > k && cnt == repetition) stk.pop_back();\\n             stk.push_back(s[i]);\\n         }\\n        for(int i=0; ans.size()<k; i++) {\\n\\t\\t     // don\\'t pick any  unnecessary char if required repetition & exact size are not satisfied!\\n             if(stk[i]!=letter && ans.size() + max(0,repetition) >=k) continue; \\n             ans+=stk[i];\\n             repetition-=letter==stk[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n         int cnt = count(s.begin(),s.end(),letter) , n = s.size();\\n         string stk , ans;\\n         for(int i=0; i<s.size(); i++) {\\n             // can we remove a big char , check enough elements are left in the array to make length atleast equal to k , also check cnt > repetition\\n             while(!stk.empty() && cnt>repetition && stk.back() > s[i] && stk.size() + (n - i) > k) {\\n                 if(letter == stk.back()) cnt--;\\n                 stk.pop_back();\\n             }\\n             // remove big char if they aren\\'t \\'letter\\' when repetition is still satisfied!\\n             while(!stk.empty() && stk.back()!=letter && stk.back() > s[i] && stk.size() + (n - i) > k && cnt == repetition) stk.pop_back();\\n             stk.push_back(s[i]);\\n         }\\n        for(int i=0; ans.size()<k; i++) {\\n\\t\\t     // don\\'t pick any  unnecessary char if required repetition & exact size are not satisfied!\\n             if(stk[i]!=letter && ans.size() + max(0,repetition) >=k) continue; \\n             ans+=stk[i];\\n             repetition-=letter==stk[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690965,
                "title": "java-o-n-greedy-solution-with-a-sorted-queue",
                "content": "We don\\'t need DP for this problem because we can greedily pick the smallest letter that satisfies the two problem constraints (k and repetitions). Once the letter is picked, we update the constraints and look for the next smallest letter in the set of valid letters. Naively, with a linear scan on the remaining letters we can find the k substring  in O(k * n) time. To optimize, we can exploit a sorted queue to reuse the computation from previous rounds, thus each letter is processed a constant number of times.\\n```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        int limit = initLimit(s, letter, r);\\n        StringBuilder sb = new StringBuilder(k);\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; k > r; --k) { // k > r ensures that r spots are reserved for the letter\\n            // iterate until problem constraints violated\\n            for (; s.length() - i >= k && i <= limit; ++i) { \\n                char curr = s.charAt(i);\\n                // maintain sorted queue\\n                while (!queue.isEmpty() && s.charAt(queue.peekLast()) > curr) {\\n                    queue.removeLast();\\n                }\\n                queue.addLast(i);\\n            }\\n            // greedily pick minimum among the valid options\\n            char min = s.charAt(queue.pollFirst());\\n            sb.append(min);\\n            if (min == letter) { // when the letter happens to be picked, relax constraints\\n                limit = nextLetter(s, limit);\\n                r = Integer.max(0, r - 1);\\n            }\\n        }\\n        // pick the remaining r letters to satisfy the constraint\\n        for (; k > 0; --k) {\\n            sb.append(letter);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int initLimit(String s, int letter, int r) {\\n        int limit = s.length();\\n        for (int c = 0; c < r;) {\\n            if (s.charAt(--limit) == letter) {\\n                ++c;\\n            }\\n        }\\n        return limit;\\n    }\\n    \\n    private int nextLetter(String s, int limit) {\\n        if (limit >= s.length()) {\\n            return limit;\\n        }\\n        char c = s.charAt(limit);\\n        while (++limit < s.length() && s.charAt(limit) != c)\\n            ;\\n        return limit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        int limit = initLimit(s, letter, r);\\n        StringBuilder sb = new StringBuilder(k);\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; k > r; --k) { // k > r ensures that r spots are reserved for the letter\\n            // iterate until problem constraints violated\\n            for (; s.length() - i >= k && i <= limit; ++i) { \\n                char curr = s.charAt(i);\\n                // maintain sorted queue\\n                while (!queue.isEmpty() && s.charAt(queue.peekLast()) > curr) {\\n                    queue.removeLast();\\n                }\\n                queue.addLast(i);\\n            }\\n            // greedily pick minimum among the valid options\\n            char min = s.charAt(queue.pollFirst());\\n            sb.append(min);\\n            if (min == letter) { // when the letter happens to be picked, relax constraints\\n                limit = nextLetter(s, limit);\\n                r = Integer.max(0, r - 1);\\n            }\\n        }\\n        // pick the remaining r letters to satisfy the constraint\\n        for (; k > 0; --k) {\\n            sb.append(letter);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int initLimit(String s, int letter, int r) {\\n        int limit = s.length();\\n        for (int c = 0; c < r;) {\\n            if (s.charAt(--limit) == letter) {\\n                ++c;\\n            }\\n        }\\n        return limit;\\n    }\\n    \\n    private int nextLetter(String s, int limit) {\\n        if (limit >= s.length()) {\\n            return limit;\\n        }\\n        char c = s.charAt(limit);\\n        while (++limit < s.length() && s.charAt(limit) != c)\\n            ;\\n        return limit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593027,
                "title": "using-stringbuilder-as-stack",
                "content": "You already know how to solve using stack. It is faster if you use stringbuilder with help of a tracking index to use it as stack\\n```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int sl= s.length();\\n        int letter_left=0;\\n        int letter_taken=0;\\n        for(int idx=0;idx<sl;idx++){\\n            if(s.charAt(idx)==letter) letter_left++;\\n        }\\n        //Stack<Character> st = new Stack<>();\\n        StringBuilder sb=new StringBuilder(\"z\".repeat(k));\\n        int sbidx=-1;\\n        for(int idx=0;idx<sl;idx++){\\n            char c=s.charAt(idx);\\n            while(sbidx>=0 && sb.charAt(sbidx)>c && (sl-idx+sbidx+1>k)){\\n                if(sb.charAt(sbidx)==letter){\\n                    if(letter_left+letter_taken<=repetition) break;\\n                    letter_taken--;\\n                }\\n                sbidx--;\\n            }\\n            if(sbidx+1<k){\\n                if(c==letter){\\n                    sb.setCharAt(++sbidx,c);\\n                    letter_taken++;\\n                }\\n                else if(k-(sbidx+1)>repetition-letter_taken) {\\n                    //System.out.println(k);\\n                    sb.setCharAt(++sbidx,c);\\n                }\\n            }\\n            if(c==letter) letter_left--;\\n            //System.out.println(\"IDX = \"+idx+\" char = \"+c+\" letter_left = \"+letter_left+\" Taken = \"+letter_taken );\\n            //System.out.println(sb.toString().substring(0,sbidx+1));\\n            //System.out.println(sbidx);\\n            \\n            //System.out.println(\"------------\");\\n            \\n        }\\n    \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int sl= s.length();\\n        int letter_left=0;\\n        int letter_taken=0;\\n        for(int idx=0;idx<sl;idx++){\\n            if(s.charAt(idx)==letter) letter_left++;\\n        }\\n        //Stack<Character> st = new Stack<>();\\n        StringBuilder sb=new StringBuilder(\"z\".repeat(k));\\n        int sbidx=-1;\\n        for(int idx=0;idx<sl;idx++){\\n            char c=s.charAt(idx);\\n            while(sbidx>=0 && sb.charAt(sbidx)>c && (sl-idx+sbidx+1>k)){\\n                if(sb.charAt(sbidx)==letter){\\n                    if(letter_left+letter_taken<=repetition) break;\\n                    letter_taken--;\\n                }\\n                sbidx--;\\n            }\\n            if(sbidx+1<k){\\n                if(c==letter){\\n                    sb.setCharAt(++sbidx,c);\\n                    letter_taken++;\\n                }\\n                else if(k-(sbidx+1)>repetition-letter_taken) {\\n                    //System.out.println(k);\\n                    sb.setCharAt(++sbidx,c);\\n                }\\n            }\\n            if(c==letter) letter_left--;\\n            //System.out.println(\"IDX = \"+idx+\" char = \"+c+\" letter_left = \"+letter_left+\" Taken = \"+letter_taken );\\n            //System.out.println(sb.toString().substring(0,sbidx+1));\\n            //System.out.println(sbidx);\\n            \\n            //System.out.println(\"------------\");\\n            \\n        }\\n    \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516727,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        stack<char> ans;\\n        int n= s.size();\\n        int c=0;\\n        vector<int> cnt(n,0);\\n        if(s[n-1]==letter) cnt[n-1]=1;\\n        for(int i=n-2; i>=0; i--){\\n            if(s[i]==letter) cnt[i]= cnt[i+1]+1;\\n            else cnt[i]= cnt[i+1];\\n        }\\n        for(int i=0; i<n; i++){\\n            while(!ans.empty() && ans.top()>s[i] && (ans.size()+n-1-i)>=k){\\n                    if(ans.top()==letter){\\n                        if(c-1+cnt[i]>=repetition){\\n                            ans.pop();\\n                            c--;\\n                        }\\n                        else break;\\n                    }\\n                    else\\n                    ans.pop();\\n                }\\n            if(s[i]==letter) c++;\\n            ans.push(s[i]);\\n        }\\n        \\n        string x;\\n        while(!ans.empty()){\\n            x.push_back(ans.top());\\n            ans.pop();\\n        }\\n        reverse(x.begin(),x.end());\\n        string res=\"\";\\n        for(int i=0;i<x.size();i++){\\n            if(x[i]==letter and repetition>0 and k>0){\\n                repetition--;\\n                k--;\\n                res.push_back(x[i]);\\n            } else if(k-repetition>0){\\n                k--;\\n                res.push_back(x[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        stack<char> ans;\\n        int n= s.size();\\n        int c=0;\\n        vector<int> cnt(n,0);\\n        if(s[n-1]==letter) cnt[n-1]=1;\\n        for(int i=n-2; i>=0; i--){\\n            if(s[i]==letter) cnt[i]= cnt[i+1]+1;\\n            else cnt[i]= cnt[i+1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2473932,
                "title": "o-k-26-logn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        string ans=\"\";\\n        int n =s.size();\\n        int pos=0;\\n        set<int>v[26];\\n        \\n        for(int i=0;i<n;i++){\\n            int val=s[i]-\\'a\\';\\n            v[val].insert(i);\\n        }\\n        \\n        int count[n];\\n        memset(count,0,sizeof(count));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==letter)\\n                count[i]++;\\n            if(i+1<n)\\n                count[i]+=count[i+1];\\n        }\\n        \\n        \\n        for(int i=0;i<k;i++){\\n           // char c=\\'*\\';\\n            for(char a=\\'a\\';a<=\\'z\\';a++){\\n                int id=-1;\\n                bool ok=false;\\n                int val=a-\\'a\\';\\n                auto it=v[val].lower_bound(pos);\\n                \\n                 if(it==v[val].end())\\n                    continue;\\n                \\n                id=*it;\\n                \\n               \\n                int cnt = count[id];\\n                \\n                // if(i==1 && a==\\'c\\')\\n                //     cout<<cnt<<endl;\\n                if(cnt<repetition)\\n                    continue;\\n                \\n              //   id=pos;\\n                \\n                if(k-i>n-id)\\n                    continue;\\n                \\n                if(k-i==repetition && a!=letter)\\n                    continue;\\n                \\n              //  k--;\\n                v[val].erase(pos);\\n                ans+=a;\\n                if(a==letter)\\n                    repetition--;\\n                pos=id+1;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        string ans=\"\";\\n        int n =s.size();\\n        int pos=0;\\n        set<int>v[26];\\n        \\n        for(int i=0;i<n;i++){\\n            int val=s[i]-\\'a\\';\\n            v[val].insert(i);\\n        }\\n        \\n        int count[n];\\n        memset(count,0,sizeof(count));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==letter)\\n                count[i]++;\\n            if(i+1<n)\\n                count[i]+=count[i+1];\\n        }\\n        \\n        \\n        for(int i=0;i<k;i++){\\n           // char c=\\'*\\';\\n            for(char a=\\'a\\';a<=\\'z\\';a++){\\n                int id=-1;\\n                bool ok=false;\\n                int val=a-\\'a\\';\\n                auto it=v[val].lower_bound(pos);\\n                \\n                 if(it==v[val].end())\\n                    continue;\\n                \\n                id=*it;\\n                \\n               \\n                int cnt = count[id];\\n                \\n                // if(i==1 && a==\\'c\\')\\n                //     cout<<cnt<<endl;\\n                if(cnt<repetition)\\n                    continue;\\n                \\n              //   id=pos;\\n                \\n                if(k-i>n-id)\\n                    continue;\\n                \\n                if(k-i==repetition && a!=letter)\\n                    continue;\\n                \\n              //  k--;\\n                v[val].erase(pos);\\n                ans+=a;\\n                if(a==letter)\\n                    repetition--;\\n                pos=id+1;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2442854,
                "title": "dynamic-programming-approach-bottom-up-tle-mle",
                "content": "The structure of the problem sounded like a DP problem to me but after writing the code etc I don\\'t think we have any overlapping sub problems and also readin the other solutions there are much much faster ones. \\n\\nThis one is at least O(n^2) but more like O(n*number of permutations that is possible up to k) \\n\\nSolution works for 15 test cases,\\n```\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        \\n        if len(s) == 1:\\n            return s[0]\\n                \\n        prev_sequences = [\"\", s[0]]\\n        current_sequences = []\\n        \\n        for i in range(1, len(s)):\\n            # not take\\n            not_take = copy.copy(prev_sequences)\\n            # take\\n            take = []\\n            for subsequence in prev_sequences:\\n                subsequence += s[i]\\n                if len(subsequence) <= k:\\n                    take.append(subsequence)\\n\\n            current_sequences = take + not_take\\n            prev_sequences = current_sequences\\n        \\n        return sorted([x for x in current_sequences if x.count(letter) >= repetition and len(x) == k])[0]\\n```\\n\\nWould love some feedback on this approach if it would ever be possible to make it work in a reasonable manner?\\n\\nJust thought I\\'d post my solution for potential discussion and feedback and an example what not to do, or something that could lead you down an incorrect path (while still passing some simpler test-cases).",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        \\n        if len(s) == 1:\\n            return s[0]\\n                \\n        prev_sequences = [\"\", s[0]]\\n        current_sequences = []\\n        \\n        for i in range(1, len(s)):\\n            # not take\\n            not_take = copy.copy(prev_sequences)\\n            # take\\n            take = []\\n            for subsequence in prev_sequences:\\n                subsequence += s[i]\\n                if len(subsequence) <= k:\\n                    take.append(subsequence)\\n\\n            current_sequences = take + not_take\\n            prev_sequences = current_sequences\\n        \\n        return sorted([x for x in current_sequences if x.count(letter) >= repetition and len(x) == k])[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2421239,
                "title": "c-code-for-beginners-stack-well-commented-code-in-detail",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        stack<char> st;\\n        int n=s.size();\\n        \\n        int numberofLettersleft=0;\\n        for(auto e: s){\\n            if(e==letter){\\n                numberofLettersleft++;  // counting the freq of given letter on the right of i, including i. \\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!st.empty() && (s[i]<st.top()) && (st.size()-1+n-i)>=k && repetition+(st.top()==letter ? 1 : 0)<=numberofLettersleft){\\n\\t\\t\\t\\n                /* if we come inside this loop, we will pop a element from stack for sure, right?... \\n\\t\\t\\t\\tok, so now let\\'s see the remaining number of characters from i till end, that is, n-i, \\n\\t\\t\\t\\tnow stack.size()-1, -1 because we just popped the element, stack.size()-1+n-i should be\\n\\t\\t\\t\\tgreater than k, because otherwise there is no way we can make k character stack, \\n\\t\\t\\t\\tif we pop this element now. OK! Fine, so lets see what\\'s this \\n\\t\\t\\t\\t\"repetition+(st.top()==letter ? 1 : 0)<=numberofLettersleft\" is all about. \\n\\t\\t\\t\\tThis repetition variable can be seen as the demand of the unique letter, right!!?\\n\\t\\t\\t\\tOK! But, how many times, yep, repetition amount of times. OK, so lets say if we\\n\\t\\t\\t\\tpop the top of the stack, now there are two cases, the top of the stack can be the\\n\\t\\t\\t\\tunique letter or can be odinary letter,right??..If it is that unique letter, then the \\n\\t\\t\\t\\trepetition we reduced, will again increase, why?? because now we need to search \\n\\t\\t\\t\\t1 more of this letter again as we removed it now. So, if we are gonna pop this letter,\\n\\t\\t\\t\\tand this letter happens to be that special letter, we add 1 with repetition and check if\\n\\t\\t\\t\\tthe unique letters left on the right are greater to meet this demand or not, if it is,\\n\\t\\t\\t\\tthen we can safely pop since we are assured as there are enough repetition of unique\\n\\t\\t\\t\\tletters on the right side of i(including i). And if this top is not a special character, the\\n\\t\\t\\t\\tdemand of unique letters or the repetition will stay the same, hence added 0. */ \\n\\t\\t\\t\\t\\n                if(st.top()==letter){\\n                    repetition++;  // if unique letter, increase repetition since we are removing a unique letter from stack\\n                }\\n                st.pop();\\n            }\\n            if((st.empty() || st.size()<k) && st.size()+1+repetition+(s[i]==letter ? -1 : 0)<=k){\\n\\t\\t\\t\\n                /* well, the first half of if is self explainatory, the second half means if we are adding\\n\\t\\t\\t\\tsomething to stack, then the new stack size will be stack.size()+1, isn\\'t it?.. OK, so \\n\\t\\t\\t\\tnow what we will check is if adding this letter(unique or ordinary) is useful or not.\\n\\t\\t\\t\\tnow stack.size()+1 will be added with repetition?? WHY?? Because we wanna see,\\n\\t\\t\\t\\tif adding this element will pose a threat to the accomodation of the neccesaary \\n\\t\\t\\t\\trepetiton of unique letters, right? Now, we check if the letter is a unique or not. \\n\\t\\t\\t\\tIf it is unique, then we add -1 to repetition, since it means, repetition will decrease\\n\\t\\t\\t\\tnow, as we are gonna add it to stack, and if it is not a unique letter, just add 0 \\n\\t\\t\\t\\tsince no change in repetition. Now this sum should be less than K. WHY? \\n\\t\\t\\t\\tBecause, if greater than K it means, adding this character in stack will result in \\n\\t\\t\\t\\tstack size greater than K when our stack will try to accomodate the repetitions \\n\\t\\t\\t\\tof unique letters, so it is neccessary that it should be less than k */\\n                st.push(s[i]);\\n\\t\\t\\t\\t\\n                if(s[i]==letter){ // since we are pushing a unique element in stack, decrease repetition\\n                    repetition--;\\n                }\\n            }\\n            if(s[i]==letter){  // if this is unique character, decrease freq of unique letters \\n                numberofLettersleft--;\\n            }\\n        }\\n        string res=\"\";\\n        while(!st.empty()){\\n            res+=st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        stack<char> st;\\n        int n=s.size();\\n        \\n        int numberofLettersleft=0;\\n        for(auto e: s){\\n            if(e==letter){\\n                numberofLettersleft++;  // counting the freq of given letter on the right of i, including i. \\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!st.empty() && (s[i]<st.top()) && (st.size()-1+n-i)>=k && repetition+(st.top()==letter ? 1 : 0)<=numberofLettersleft){\\n\\t\\t\\t\\n                /* if we come inside this loop, we will pop a element from stack for sure, right?... \\n\\t\\t\\t\\tok, so now let\\'s see the remaining number of characters from i till end, that is, n-i, \\n\\t\\t\\t\\tnow stack.size()-1, -1 because we just popped the element, stack.size()-1+n-i should be\\n\\t\\t\\t\\tgreater than k, because otherwise there is no way we can make k character stack, \\n\\t\\t\\t\\tif we pop this element now. OK! Fine, so lets see what\\'s this \\n\\t\\t\\t\\t\"repetition+(st.top()==letter ? 1 : 0)<=numberofLettersleft\" is all about. \\n\\t\\t\\t\\tThis repetition variable can be seen as the demand of the unique letter, right!!?\\n\\t\\t\\t\\tOK! But, how many times, yep, repetition amount of times. OK, so lets say if we\\n\\t\\t\\t\\tpop the top of the stack, now there are two cases, the top of the stack can be the\\n\\t\\t\\t\\tunique letter or can be odinary letter,right??..If it is that unique letter, then the \\n\\t\\t\\t\\trepetition we reduced, will again increase, why?? because now we need to search \\n\\t\\t\\t\\t1 more of this letter again as we removed it now. So, if we are gonna pop this letter,\\n\\t\\t\\t\\tand this letter happens to be that special letter, we add 1 with repetition and check if\\n\\t\\t\\t\\tthe unique letters left on the right are greater to meet this demand or not, if it is,\\n\\t\\t\\t\\tthen we can safely pop since we are assured as there are enough repetition of unique\\n\\t\\t\\t\\tletters on the right side of i(including i). And if this top is not a special character, the\\n\\t\\t\\t\\tdemand of unique letters or the repetition will stay the same, hence added 0. */ \\n\\t\\t\\t\\t\\n                if(st.top()==letter){\\n                    repetition++;  // if unique letter, increase repetition since we are removing a unique letter from stack\\n                }\\n                st.pop();\\n            }\\n            if((st.empty() || st.size()<k) && st.size()+1+repetition+(s[i]==letter ? -1 : 0)<=k){\\n\\t\\t\\t\\n                /* well, the first half of if is self explainatory, the second half means if we are adding\\n\\t\\t\\t\\tsomething to stack, then the new stack size will be stack.size()+1, isn\\'t it?.. OK, so \\n\\t\\t\\t\\tnow what we will check is if adding this letter(unique or ordinary) is useful or not.\\n\\t\\t\\t\\tnow stack.size()+1 will be added with repetition?? WHY?? Because we wanna see,\\n\\t\\t\\t\\tif adding this element will pose a threat to the accomodation of the neccesaary \\n\\t\\t\\t\\trepetiton of unique letters, right? Now, we check if the letter is a unique or not. \\n\\t\\t\\t\\tIf it is unique, then we add -1 to repetition, since it means, repetition will decrease\\n\\t\\t\\t\\tnow, as we are gonna add it to stack, and if it is not a unique letter, just add 0 \\n\\t\\t\\t\\tsince no change in repetition. Now this sum should be less than K. WHY? \\n\\t\\t\\t\\tBecause, if greater than K it means, adding this character in stack will result in \\n\\t\\t\\t\\tstack size greater than K when our stack will try to accomodate the repetitions \\n\\t\\t\\t\\tof unique letters, so it is neccessary that it should be less than k */\\n                st.push(s[i]);\\n\\t\\t\\t\\t\\n                if(s[i]==letter){ // since we are pushing a unique element in stack, decrease repetition\\n                    repetition--;\\n                }\\n            }\\n            if(s[i]==letter){  // if this is unique character, decrease freq of unique letters \\n                numberofLettersleft--;\\n            }\\n        }\\n        string res=\"\";\\n        while(!st.empty()){\\n            res+=st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342836,
                "title": "greedy-stack-easy-to-understand",
                "content": "Starting from an empty string `result`, we traverse the original string from left to right, with each letter `a` we would try to add `a` to the `result`. \\n\\nObservations:\\n> **_As long as the last character of `result` is greater than `a`, poping the last char then appending `a` would lead to a smaller `result`._**\\n\\t\\nWe can easily implement this approach by using a stack. But there\\'s still some flaws of this thinking. What if after we has trucated the last char, the remaing characters  is not enough to create a string  of length `k` regardless of number of `letter`, and what if there\\'s no way to have enough `k` `letter` by using the remaining chars ? Hence, we only poping the last char of `result` if both following conditions are fullfill:\\n1. `len(result) - 1 + number_of_remaining_chars >= k` \\n\\n2. `the remaining_letter_in_result + the remaining_letter_in_s  >= repetition`\\n\\nAfter we has gone through all char of `s`, we would end up a string `result` of length `k`.\\nIf result does not contain at least `repetition` `letter`, then just traverse backward the `result`, if the char is differ form `letter` change it to `letter` until `result` has `repetition` `letter`\\'s. \\n<details>\\n<summary>Proof</summary>\\nLet `b` denotes the number of `lettter`\\'s in `result`.\\nThe above algorithm ensure that `result`  is the smallest possible one, there\\'s always at least `repetiton - x`  `letter`\\'s of the remaining character of \\'s\\' at the time \\'result\\' is formed. So these `repetition-x` letters\\' must be at the very end of `result`, so they must replace the chars which is differ from `letter` in the right most of `result`.\\n</details>\\n<br>\\n\\n```python\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        from collections import Counter \\n        a = Counter(s)\\n        p = []\\n        b = 0\\n        for j,i in enumerate(s):\\n            while p and i < p[-1] and b - (p[-1] == letter) + a[letter] >= repetition and len(p) - 1 + len(s) - j >= k :\\n                b -= p.pop() == letter\\n            if len(p) < k:\\n                p.append(i)\\n                b += i == letter\\n            a[i] -= 1\\n       \\n        for i in range(len(p)-1, -1, -1):\\n            if b >= repetition:\\n                break\\n            if p[i] != letter:\\n                p[i] = letter\\n                b += 1\\n        return \"\".join(p)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        from collections import Counter \\n        a = Counter(s)\\n        p = []\\n        b = 0\\n        for j,i in enumerate(s):\\n            while p and i < p[-1] and b - (p[-1] == letter) + a[letter] >= repetition and len(p) - 1 + len(s) - j >= k :\\n                b -= p.pop() == letter\\n            if len(p) < k:\\n                p.append(i)\\n                b += i == letter\\n            a[i] -= 1\\n       \\n        for i in range(len(p)-1, -1, -1):\\n            if b >= repetition:\\n                break\\n            if p[i] != letter:\\n                p[i] = letter\\n                b += 1\\n        return \"\".join(p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152967,
                "title": "c-solution-using-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int available=0;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter){\\n                available++;\\n            }\\n        }\\n        int seen=0;\\n        for(int i=0;i<s.size();i++){\\n            while(res.size() and res.back()>s[i] and res.size()+s.size()-i>k){\\n                if(res.back()==letter){\\n                    if(available+seen-1>=repetition){\\n                        res.pop_back();\\n                        seen--;\\n                    } else {\\n                        break;\\n                    }\\n                } else {\\n                    res.pop_back();\\n                }\\n            }\\n            if(s[i]==letter){\\n                seen++;\\n                available--;\\n            }\\n            res.push_back(s[i]);\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]==letter and repetition>0 and k>0){\\n                repetition--;\\n                k--;\\n                ans.push_back(res[i]);\\n            } else if(k-repetition>0){\\n                k--;\\n                ans.push_back(res[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int available=0;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter){\\n                available++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2124585,
                "title": "python-go-greedy-w-conditional-monostack-o-n",
                "content": "*Python* solution w/ suffix sum\\n\\n```python\\ndef smallestSubsequence(self, s, k, letter, demand):\\n    A, supply = [], list(itertools.accumulate([ch == letter for ch in s][::-1]))[::-1]\\n\\t\\n    for i, ch in enumerate(s):\\n        while A and A[-1] > ch and len(s) - i + len(A) > k and (A[-1] != letter or supply[i] > demand):\\n            demand += A.pop() == letter\\n\\t\\t\\t\\n        if len(A) < k and (ch == letter or k - len(A) > demand):\\n            demand -= ch == letter\\n            A.append(ch)\\n\\t\\t\\t\\n    return \"\".join(A)\\n```\\n\\n*Go* solution in 36ms beat 100% :)\\n\\n```go\\ntype stack []byte\\n\\nfunc (s *stack) pop() byte {\\n\\tvar (\\n\\t\\ti = len(*s) - 1\\n\\t\\tx = (*s)[i]\\n\\t)\\n\\t*s = (*s)[:i]\\n\\treturn x\\n}\\nfunc (s stack) top() byte    { return s[len(s)-1] }\\nfunc (s *stack) push(x byte) { *s = append(*s, x) }\\nfunc (s stack) empty() bool  { return len(s) == 0 }\\n\\nfunc smallestSubsequence(s string, k int, letter byte, demand int) string {\\n\\tvar (\\n\\t\\tA      stack\\n\\t\\tsupply = strings.Count(s, string(letter))\\n\\t)\\n\\n\\tfor i, c := range s {\\n\\t\\tch := byte(c)\\n\\t\\tfor !A.empty() && A.top() > ch && len(s)-i+len(A) > k {\\n\\t\\t\\tif A.top() != letter {\\n\\t\\t\\t\\tA.pop()\\n\\t\\t\\t} else if supply > demand {\\n\\t\\t\\t\\tA.pop()\\n\\t\\t\\t\\tdemand++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(A) < k {\\n\\t\\t\\tif ch == letter {\\n\\t\\t\\t\\tA.push(ch)\\n\\t\\t\\t\\tdemand--\\n\\t\\t\\t} else if k-len(A) > demand {\\n\\t\\t\\t\\tA.push(ch)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ch == letter {\\n\\t\\t\\tsupply--\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(A)\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef smallestSubsequence(self, s, k, letter, demand):\\n    A, supply = [], list(itertools.accumulate([ch == letter for ch in s][::-1]))[::-1]\\n\\t\\n    for i, ch in enumerate(s):\\n        while A and A[-1] > ch and len(s) - i + len(A) > k and (A[-1] != letter or supply[i] > demand):\\n            demand += A.pop() == letter\\n\\t\\t\\t\\n        if len(A) < k and (ch == letter or k - len(A) > demand):\\n            demand -= ch == letter\\n            A.append(ch)\\n\\t\\t\\t\\n    return \"\".join(A)\\n```\n```go\\ntype stack []byte\\n\\nfunc (s *stack) pop() byte {\\n\\tvar (\\n\\t\\ti = len(*s) - 1\\n\\t\\tx = (*s)[i]\\n\\t)\\n\\t*s = (*s)[:i]\\n\\treturn x\\n}\\nfunc (s stack) top() byte    { return s[len(s)-1] }\\nfunc (s *stack) push(x byte) { *s = append(*s, x) }\\nfunc (s stack) empty() bool  { return len(s) == 0 }\\n\\nfunc smallestSubsequence(s string, k int, letter byte, demand int) string {\\n\\tvar (\\n\\t\\tA      stack\\n\\t\\tsupply = strings.Count(s, string(letter))\\n\\t)\\n\\n\\tfor i, c := range s {\\n\\t\\tch := byte(c)\\n\\t\\tfor !A.empty() && A.top() > ch && len(s)-i+len(A) > k {\\n\\t\\t\\tif A.top() != letter {\\n\\t\\t\\t\\tA.pop()\\n\\t\\t\\t} else if supply > demand {\\n\\t\\t\\t\\tA.pop()\\n\\t\\t\\t\\tdemand++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(A) < k {\\n\\t\\t\\tif ch == letter {\\n\\t\\t\\t\\tA.push(ch)\\n\\t\\t\\t\\tdemand--\\n\\t\\t\\t} else if k-len(A) > demand {\\n\\t\\t\\t\\tA.push(ch)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ch == letter {\\n\\t\\t\\tsupply--\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(A)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2091467,
                "title": "java-faster-than-96-10-less-than-94-16",
                "content": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        \\n        int remL = 0;\\n        for (char c : s.toCharArray()) if (c == letter) remL++;\\n        int rem = s.length()-k;\\n        \\n        char[] chars = s.toCharArray();\\n        int top = -1;\\n        for (int i = 0; i < chars.length; i++) {\\n            char c = chars[i];\\n            boolean isLetter = c == letter;\\n            \\n            if (isLetter) {\\n                int l = k-repetition;\\n                while (top >= 0 && rem > 0 && (top >= l || chars[top] > c)) {\\n                    if (top >= l) {\\n                        rem -= (top-l+1);\\n                        top = l-1;\\n                    } else {\\n                        top--;\\n                        rem--;\\n                    }\\n                }\\n                repetition--;\\n                remL--;\\n            } else {\\n                while (top >= 0 && chars[top] > c && rem > 0 && (chars[top] == letter && repetition < remL || chars[top] != letter)) {\\n                    if (chars[top] == letter) {\\n                        if (repetition < remL) {\\n                            repetition++;\\n                            rem--;\\n                            top--;\\n                        } else break;\\n                    } else {\\n                        if (rem > 0) {\\n                            rem--;\\n                            top--;\\n                        } else break;\\n                    }\\n                }\\n            }\\n            \\n            chars[++top] = c;\\n        }\\n        return new String(chars, 0, k);\\n    }\\n}\\n```\\n\\n1. Keep a monotonic stack with ascending order\\n2. Consider limitation: max length k\\n\\t* Variable \"rem\" to represent how many letter could be replaced\\n3. Consider limitation: letter repetition\\n\\t* Variable \"remL\" represents remaing Letters\\n\\t* Variable \"repetition\" represents how many Letters are required in stack\\n4. Condition 1: the incoming char is \"letter\"\\n\\t* Must make sure letter will be in the stack if repetition is still not zero.\\n\\t* Replace char to keep asending order if possible\\n5. Condition 2: the incoming char is not \"letter\"\\n\\t* If the top char is letter, confirm remaing letters are enough to put in the stack\\n\\t* Replace char to keep asending order if possible",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        \\n        int remL = 0;\\n        for (char c : s.toCharArray()) if (c == letter) remL++;\\n        int rem = s.length()-k;\\n        \\n        char[] chars = s.toCharArray();\\n        int top = -1;\\n        for (int i = 0; i < chars.length; i++) {\\n            char c = chars[i];\\n            boolean isLetter = c == letter;\\n            \\n            if (isLetter) {\\n                int l = k-repetition;\\n                while (top >= 0 && rem > 0 && (top >= l || chars[top] > c)) {\\n                    if (top >= l) {\\n                        rem -= (top-l+1);\\n                        top = l-1;\\n                    } else {\\n                        top--;\\n                        rem--;\\n                    }\\n                }\\n                repetition--;\\n                remL--;\\n            } else {\\n                while (top >= 0 && chars[top] > c && rem > 0 && (chars[top] == letter && repetition < remL || chars[top] != letter)) {\\n                    if (chars[top] == letter) {\\n                        if (repetition < remL) {\\n                            repetition++;\\n                            rem--;\\n                            top--;\\n                        } else break;\\n                    } else {\\n                        if (rem > 0) {\\n                            rem--;\\n                            top--;\\n                        } else break;\\n                    }\\n                }\\n            }\\n            \\n            chars[++top] = c;\\n        }\\n        return new String(chars, 0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978674,
                "title": "python-stack-track-used-letter-and-remain-letter-o-n",
                "content": "We can use a mono-stack to get the lexicographically smallest sub sequence with length k, \\n```\\n    def smallestSubsequenceWithLengthK(self, s: str, k: int) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            while stack and len(stack) + len(s)-i-1 >= k and stack[-1] > s[i] :\\n                stack.pop()\\n            stack.append(s[i])\\n        return \\'\\'.join(stack[:k])\\n```\\nHowever there is a additional constraint that a particular letter repeat at least several time.\\nHere we used two more variable to track the count of the letter in the stack and remain in the string.\\nThere are two points to take care:\\n1. During each pop operation, if the remaining letter count is not enough to form the substring -> break\\n2. During each append operation, if the count of other letter is too much -> do not append other letter\\n\\n```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        #letter count remain in the string\\n        remain_cnt = s.count(letter)\\n        #letter count in the stack\\n        in_stack_cnt = 0\\n        stack = []\\n        for i in range(len(s)):\\n            while stack and len(stack) + len(s)-i-1 >= k and stack[-1] > s[i] :\\n                #if the remain_cnt is just enough, we can not pop letter from the stack\\n                if stack[-1] == letter and in_stack_cnt + remain_cnt == repetition:\\n                    break\\n                if stack[-1] == letter:\\n                    in_stack_cnt-=1\\n                stack.pop()\\n            #the count of other letters in the stack can not exceed k-repetition\\n            if s[i] == letter or len(stack)-in_stack_cnt < k-repetition:\\n                stack.append(s[i])\\n            if s[i] == letter:\\n                in_stack_cnt += 1\\n                remain_cnt -= 1\\n        return \\'\\'.join(stack[:k])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n    def smallestSubsequenceWithLengthK(self, s: str, k: int) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            while stack and len(stack) + len(s)-i-1 >= k and stack[-1] > s[i] :\\n                stack.pop()\\n            stack.append(s[i])\\n        return \\'\\'.join(stack[:k])\\n```\n```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        #letter count remain in the string\\n        remain_cnt = s.count(letter)\\n        #letter count in the stack\\n        in_stack_cnt = 0\\n        stack = []\\n        for i in range(len(s)):\\n            while stack and len(stack) + len(s)-i-1 >= k and stack[-1] > s[i] :\\n                #if the remain_cnt is just enough, we can not pop letter from the stack\\n                if stack[-1] == letter and in_stack_cnt + remain_cnt == repetition:\\n                    break\\n                if stack[-1] == letter:\\n                    in_stack_cnt-=1\\n                stack.pop()\\n            #the count of other letters in the stack can not exceed k-repetition\\n            if s[i] == letter or len(stack)-in_stack_cnt < k-repetition:\\n                stack.append(s[i])\\n            if s[i] == letter:\\n                in_stack_cnt += 1\\n                remain_cnt -= 1\\n        return \\'\\'.join(stack[:k])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925307,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n = s.size();\\n        vector<int> suff(n);\\n        if (s.back() == letter) suff[n - 1] = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (s[i] == letter) suff[i] = suff[i + 1] + 1;\\n            else suff[i] = suff[i + 1];\\n        }\\n        string st;\\n        int lCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty()) {\\n                if (st.back() > s[i]) {\\n                    if (st.back() == letter) {\\n                        if (lCount - 1 + suff[i] >= repetition && (int) st.size() - 1 + n - i >= k) {\\n                            st.pop_back();\\n                            --lCount;\\n                        }\\n                        else break;\\n                    }\\n                    else if (lCount + suff[i] >= repetition && (int) st.size() - 1 + n - i >= k) {\\n                        st.pop_back();\\n                    }\\n                    else {\\n                        break;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            st.push_back(s[i]);\\n            if (s[i] == letter) ++lCount;\\n        }\\n        int len = (int) st.size();\\n        vector<bool> rm(len);\\n        for (int i = (int) st.size() - 1; i >= 0; i--) {\\n            if (st[i] != letter && len > k) {\\n                rm[i] = true;\\n                --len;\\n            }\\n            else if (st[i] == letter && len > k && lCount > repetition) {\\n                rm[i] = true;\\n                --len;\\n                --lCount;\\n            }\\n        }\\n        string sol;\\n        for (int i = 0; i < (int) st.size(); i++) {\\n            if (!rm[i]) {\\n                sol.push_back(st[i]);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n = s.size();\\n        vector<int> suff(n);\\n        if (s.back() == letter) suff[n - 1] = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (s[i] == letter) suff[i] = suff[i + 1] + 1;\\n            else suff[i] = suff[i + 1];\\n        }\\n        string st;\\n        int lCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty()) {\\n                if (st.back() > s[i]) {\\n                    if (st.back() == letter) {\\n                        if (lCount - 1 + suff[i] >= repetition && (int) st.size() - 1 + n - i >= k) {\\n                            st.pop_back();\\n                            --lCount;\\n                        }\\n                        else break;\\n                    }\\n                    else if (lCount + suff[i] >= repetition && (int) st.size() - 1 + n - i >= k) {\\n                        st.pop_back();\\n                    }\\n                    else {\\n                        break;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            st.push_back(s[i]);\\n            if (s[i] == letter) ++lCount;\\n        }\\n        int len = (int) st.size();\\n        vector<bool> rm(len);\\n        for (int i = (int) st.size() - 1; i >= 0; i--) {\\n            if (st[i] != letter && len > k) {\\n                rm[i] = true;\\n                --len;\\n            }\\n            else if (st[i] == letter && len > k && lCount > repetition) {\\n                rm[i] = true;\\n                --len;\\n                --lCount;\\n            }\\n        }\\n        string sol;\\n        for (int i = 0; i < (int) st.size(); i++) {\\n            if (!rm[i]) {\\n                sol.push_back(st[i]);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918484,
                "title": "python-self-explainable-ish-this-problem-is-the-plus-version-of-1673-most-competitive",
                "content": "So, we can solve it in a similar way. The base structure is offered by the solution of [1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/1917771/Python6-line-succinct-solution-based-on-monotonic-stack-strategy-for-your-quick-comprehension). And you can add the conditions for the corner cases. \\n\\n\\'u\\' is the sum of the specific letters in current sequence and \\'p\\' is the left number of this letter and ready for use.\\n\\n\\'k-len(S)>=repetition-u\\' means the unfilled positions of the solution sequence has to be bigger or equal than the left repeat times of that specific letter.\\n```\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        p =sum([e == letter for e in s]) #p:left\\n        u=0\\n        S,n=[],len(s)\\n        for i,e in enumerate(s):\\n            while S and S[-1]>e and len(S)+n-i>k and u+p >=repetition:\\n                if u+p > repetition:\\n                    u -= (letter == S.pop())\\n                else:\\n                    if S[-1]!= letter:\\n                        S.pop()\\n                    else: break\\n            p-=(e==letter)\\n            if k-len(S)>=repetition-u and len(S)<k:\\n                S.append(e)\\n                u+=(e==letter)\\n            if k-len(S)<repetition -u:\\n                S.pop()\\n        return \\'\\'.join(S)\\n```",
                "solutionTags": [],
                "code": "```\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        p =sum([e == letter for e in s]) #p:left\\n        u=0\\n        S,n=[],len(s)\\n        for i,e in enumerate(s):\\n            while S and S[-1]>e and len(S)+n-i>k and u+p >=repetition:\\n                if u+p > repetition:\\n                    u -= (letter == S.pop())\\n                else:\\n                    if S[-1]!= letter:\\n                        S.pop()\\n                    else: break\\n            p-=(e==letter)\\n            if k-len(S)>=repetition-u and len(S)<k:\\n                S.append(e)\\n                u+=(e==letter)\\n            if k-len(S)<repetition -u:\\n                S.pop()\\n        return \\'\\'.join(S)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1903567,
                "title": "typescript-stack-explained-faster-than-100",
                "content": "**Runtime**: 208 ms, faster than 100.00% of TypeScript\\n**Memory** Usage: 61.3 MB, less than 100.00% of TypeScript\\n\\n**Phase 1.**\\n\\nIterate the given string first. Put values on the stack, pop if conditions are met. Here we keep track of several values:\\n1. How many targetted letters (`letter`) the initial string has - aka `letterRemains`,\\n2. How many targetted letters we have already taken - aka `letterIn`,\\n3. How many targetted letters are on the stack - aka `letterRemains + letterIn`\\n4. How many letters we have left on the string.\\n\\nNow, loop through the given string. Watch out for the following, they **all** gotta be `true` to proceed.\\n\\n1. Do we have anything on the stack? `stack.length`\\n2. If we were to remove this value from the stack, would we still have enough letters in the given string to meet the `k` (answer length) requirement? `stack.length + s.length - i - 1` Just checking yet, thus, the `-1`, do not remove the value but see if we possibly can.\\n3. Is the last letter on the stack lexicographically larger than the current one? `stack[stack.length - 1] > curr ` , e.g. _**n** is larger than **f**_\\n4. If the last value on the stack is not a targetted letter `stack[stack.length - 1] !== letter` **OR** if it **IS** a targetted letter **BUT** we have enough targetted letters left in the string to remove the one on the stack `letterRemains + letterIn - 1 >= repetition`. Here, again, the `-1` - do not remove the letter, just check that we can.\\n\\nWhen all this is true - we can safely pop the letter off the stack. Keep in mind to decrease `letterIn` if the letter was a targetted letter.\\n\\nKeep doing this while all is true.\\n\\nFinish the current interation by pushing the current letter to the stack, if it\\'s targetted update the `letterIn` and `letterRemains`\\n\\nIterate the given string.\\n\\n**Phase 2**\\n\\nWe might have gotten too many letters on the stack. But if not (`stack.length === k`) quit here and return the joined stack.\\n\\nWe might end up in phase 2 when faced the following example: `aaabbcccccdd` where all letters come in order - it\\'s just too many of them if the answer length should be small.\\n\\nThus, loop the stack, which is larger than `k` (target answer length).\\n\\n- If it\\'s a targetted letter AND we need more of those (mind `repetition`) - keep the letter for the answer and decrease repetition\\n- If it\\'s not AND we still need any letters (`looseLetters = k - repetition`) - keep the letter for the answer and decrease looseLetters\\n\\nReturn what we got.\\n\\n**Clean code:** (scroll down for commented examples)\\n\\n```\\nfunction smallestSubsequence(s: string, k: number, letter: string, repetition: number): string {\\n    let letterRemains = s.split(\"\").filter(item => item === letter).length\\n    let letterIn = 0\\n    \\n    let stack = []\\n    for (let i = 0; i < s.length; i++) {\\n        const curr = s.charAt(i)\\n        while (stack.length \\n               && stack[stack.length - 1] > curr \\n               && stack.length + s.length - i - 1 >= k\\n               && (stack[stack.length - 1] !== letter \\n                || stack[stack.length - 1] === letter \\n                   && letterRemains + letterIn - 1 >= repetition)) {\\n            if (stack[stack.length - 1] === letter) letterIn--\\n            stack.pop()    \\n        }\\n        \\n        stack.push(curr)\\n        if (curr === letter) { \\n            letterIn++\\n            letterRemains--\\n        }\\n    }\\n\\n    if (stack.length === k) return stack.join(\"\")\\n    \\n    let looseLetters = k - repetition\\n    let answer = \\'\\'\\n    \\n    for (let i = 0; i < stack.length; i++) {\\n        if (repetition && stack[i] === letter) {\\n            answer += stack[i]\\n            repetition--\\n        }\\n        else if (looseLetters) {\\n            answer += stack[i]\\n            looseLetters--\\n        }\\n    }\\n\\n    return answer\\n};\\n```\\n\\n**Commented examples:**\\n\\n```\\nfunction smallestSubsequence(s: string, k: number, letter: string, repetition: number): string {\\n    let letterRemains = s.split(\"\").filter(item => item === letter).length\\n    let letterIn = 0\\n    \\n    let stack = []\\n    for (let i = 0; i < s.length; i++) {\\n        const curr = s.charAt(i)\\n        while (stack.length \\n               && stack[stack.length - 1] > curr \\n\\t\\t\\t   // with something like  \"mmmxmxymmm\" \\n\\t\\t\\t   // we would end up with a letter less than the target (8) because \"m\"s after \"xy\" pop them off\\n\\t\\t\\t   // there\\'s not enough \"m\"s => keep one other letter, here it\\'s + \"x\" which we do not pop\\n               && stack.length + s.length - i - 1 >= k\\n               && (stack[stack.length - 1] !== letter \\n                || stack[stack.length - 1] === letter \\n                   && letterRemains + letterIn - 1 >= repetition)) {\\n            if (stack[stack.length - 1] === letter) letterIn--\\n            stack.pop()    \\n        }\\n        \\n        stack.push(curr)\\n        if (curr === letter) { \\n            letterIn++\\n            letterRemains--\\n        }\\n    }\\n\\n    if (stack.length === k) return stack.join(\"\")\\n    \\n    let looseLetters = k - repetition\\n    let answer = \\'\\'\\n    \\n\\t// \"aaabbbcccddd\"\\n\\t// k = 3\\n\\t// letter = \"b\"\\n\\t// repetition = 2\\n\\t// okay by the letter order but not okay by length because we end up with the whole thing\\n\\t// if we just slice we loose targetted letters\\n    for (let i = 0; i < stack.length; i++) {\\n        if (repetition && stack[i] === letter) {\\n            answer += stack[i]\\n            repetition--\\n        }\\n        else if (looseLetters) {\\n            answer += stack[i]\\n            looseLetters--\\n        }\\n    }\\n\\n    return answer\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction smallestSubsequence(s: string, k: number, letter: string, repetition: number): string {\\n    let letterRemains = s.split(\"\").filter(item => item === letter).length\\n    let letterIn = 0\\n    \\n    let stack = []\\n    for (let i = 0; i < s.length; i++) {\\n        const curr = s.charAt(i)\\n        while (stack.length \\n               && stack[stack.length - 1] > curr \\n               && stack.length + s.length - i - 1 >= k\\n               && (stack[stack.length - 1] !== letter \\n                || stack[stack.length - 1] === letter \\n                   && letterRemains + letterIn - 1 >= repetition)) {\\n            if (stack[stack.length - 1] === letter) letterIn--\\n            stack.pop()    \\n        }\\n        \\n        stack.push(curr)\\n        if (curr === letter) { \\n            letterIn++\\n            letterRemains--\\n        }\\n    }\\n\\n    if (stack.length === k) return stack.join(\"\")\\n    \\n    let looseLetters = k - repetition\\n    let answer = \\'\\'\\n    \\n    for (let i = 0; i < stack.length; i++) {\\n        if (repetition && stack[i] === letter) {\\n            answer += stack[i]\\n            repetition--\\n        }\\n        else if (looseLetters) {\\n            answer += stack[i]\\n            looseLetters--\\n        }\\n    }\\n\\n    return answer\\n};\\n```\n```\\nfunction smallestSubsequence(s: string, k: number, letter: string, repetition: number): string {\\n    let letterRemains = s.split(\"\").filter(item => item === letter).length\\n    let letterIn = 0\\n    \\n    let stack = []\\n    for (let i = 0; i < s.length; i++) {\\n        const curr = s.charAt(i)\\n        while (stack.length \\n               && stack[stack.length - 1] > curr \\n\\t\\t\\t   // with something like  \"mmmxmxymmm\" \\n\\t\\t\\t   // we would end up with a letter less than the target (8) because \"m\"s after \"xy\" pop them off\\n\\t\\t\\t   // there\\'s not enough \"m\"s => keep one other letter, here it\\'s + \"x\" which we do not pop\\n               && stack.length + s.length - i - 1 >= k\\n               && (stack[stack.length - 1] !== letter \\n                || stack[stack.length - 1] === letter \\n                   && letterRemains + letterIn - 1 >= repetition)) {\\n            if (stack[stack.length - 1] === letter) letterIn--\\n            stack.pop()    \\n        }\\n        \\n        stack.push(curr)\\n        if (curr === letter) { \\n            letterIn++\\n            letterRemains--\\n        }\\n    }\\n\\n    if (stack.length === k) return stack.join(\"\")\\n    \\n    let looseLetters = k - repetition\\n    let answer = \\'\\'\\n    \\n\\t// \"aaabbbcccddd\"\\n\\t// k = 3\\n\\t// letter = \"b\"\\n\\t// repetition = 2\\n\\t// okay by the letter order but not okay by length because we end up with the whole thing\\n\\t// if we just slice we loose targetted letters\\n    for (let i = 0; i < stack.length; i++) {\\n        if (repetition && stack[i] === letter) {\\n            answer += stack[i]\\n            repetition--\\n        }\\n        else if (looseLetters) {\\n            answer += stack[i]\\n            looseLetters--\\n        }\\n    }\\n\\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1859721,
                "title": "c-simple-solution-using-stack-greedy-o-n-time-complexity",
                "content": "**Approach**  - Stack.\\n**Why stack** - Looking at the given constraints an algorithm of time complexity of O(n) or O(nlogn) would be appropriate . So we can traverse the given string. Now if we think lexicologically smallest ,we try to keep the lower letters(letters appearing earlier in alphabets) at the begining while maintaining their occurance order in the string . Means to change the previous letter(if its greater than current letter *s[i]*) we need to delete it and replace it with the current letter s[i] , which in turn makes stack the best option as it can support pop() method with O(1) complexity. \\n**The Basic understanding -** To finally have (the frequency of letter in stack) equal to repetition and length of final string equal to k.\\n**Solution -**\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int in_stack = 0,totallet=0; //in_stack = total freq of letter in stack totallet = frequency of letter in given string \"s\".\\n\\t\\t//declaring stack of char.\\n        stack<char>st;\\n\\t\\t//calculating frequency of letter in given string \"s\"\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == letter)totallet++;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.empty()) // base condition to avoid pop in empty stack.\\n            {\\n                st.push(s[i]);\\n            }\\n            else{\\n\\t\\t\\t\\t/*Three conditions in the below while loop -\\n\\t\\t\\t\\t1)!st.empty() -avoid pop in empty stack,\\n\\t\\t\\t\\t2)if previous letter is lexicologically greater than current\\n\\t\\t\\t\\t3)if forming a string of length \"k\" is still possible after performing the pop operation.\\n\\t\\t\\t\\t*/  \\n                while(!st.empty() && st.top()>s[i] && (st.size()+s.size()-i) > k)\\n                {\\n                    if(st.top() == letter && (in_stack + totallet - 1 >=repetition))\\n                    {\\n                        st.pop();\\n                        in_stack--; // if letter is poped from stack reduce the instack count.\\n                        \\n                    }\\n                    else if(st.top() == letter)\\n                    {\\n                        break;\\n                    }\\n                    else st.pop();\\n                }\\n                if(s[i] == letter)\\n                {\\n                    in_stack++;\\n                    totallet--;\\n                }\\n                st.push(s[i]);\\n                \\n            }\\n        }\\n        string ans = \"\";\\n        while(!st.empty())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end()); //forming the string again from stack.\\n\\t\\t\\n\\t\\t/*The below code is for the condition when the stack has more characters than required length k \\n\\t\\treason - the initial string \"s\" had characters greater than \"k\" in lexicologically ascending order.\\n\\t\\t*/\\n        string ret=\"\";\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i] == letter && repetition>0 && k>0)\\n            {\\n                repetition--;\\n                ret += ans[i];\\n                k--;\\n            }\\n            else if(k-repetition>0)\\n            {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tret += ans[i];   \\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n**Time complexity** - O(n)\\n**Space complexity** - O(3*n) for stack and strings depending on test case.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int in_stack = 0,totallet=0; //in_stack = total freq of letter in stack totallet = frequency of letter in given string \"s\".\\n\\t\\t//declaring stack of char.\\n        stack<char>st;\\n\\t\\t//calculating frequency of letter in given string \"s\"\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == letter)totallet++;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.empty()) // base condition to avoid pop in empty stack.\\n            {\\n                st.push(s[i]);\\n            }\\n            else{\\n\\t\\t\\t\\t/*Three conditions in the below while loop -\\n\\t\\t\\t\\t1)!st.empty() -avoid pop in empty stack,\\n\\t\\t\\t\\t2)if previous letter is lexicologically greater than current\\n\\t\\t\\t\\t3)if forming a string of length \"k\" is still possible after performing the pop operation.\\n\\t\\t\\t\\t*/  \\n                while(!st.empty() && st.top()>s[i] && (st.size()+s.size()-i) > k)\\n                {\\n                    if(st.top() == letter && (in_stack + totallet - 1 >=repetition))\\n                    {\\n                        st.pop();\\n                        in_stack--; // if letter is poped from stack reduce the instack count.\\n                        \\n                    }\\n                    else if(st.top() == letter)\\n                    {\\n                        break;\\n                    }\\n                    else st.pop();\\n                }\\n                if(s[i] == letter)\\n                {\\n                    in_stack++;\\n                    totallet--;\\n                }\\n                st.push(s[i]);\\n                \\n            }\\n        }\\n        string ans = \"\";\\n        while(!st.empty())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end()); //forming the string again from stack.\\n\\t\\t\\n\\t\\t/*The below code is for the condition when the stack has more characters than required length k \\n\\t\\treason - the initial string \"s\" had characters greater than \"k\" in lexicologically ascending order.\\n\\t\\t*/\\n        string ret=\"\";\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i] == letter && repetition>0 && k>0)\\n            {\\n                repetition--;\\n                ret += ans[i];\\n                k--;\\n            }\\n            else if(k-repetition>0)\\n            {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tret += ans[i];   \\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840069,
                "title": "java-solution-missing-one-test-case",
                "content": "Input\\n\"adffhjfmmmmorsfff\"\\n6\\n\"f\"\\n5\\n**Output**\\n\"dfffff\"\\n**Expected**\\n\"afffff\"\\n\\nIsn\\'t output a part of result as it is an increasing subsequence for this input.\\n\\n\\n        int[] count  = new int[26];\\n        boolean[] visited  = new boolean[26];\\n        for(char c:s.toCharArray()){\\n            count[c-\\'a\\']++; \\n        }\\n        Stack<Character> stack = new Stack<>();\\n        int size = s.length(), letterCount=0;\\n        for(char c:s.toCharArray()){\\n            \\n            if(visited[c-\\'a\\'])\\n                continue;\\n            while(!stack.isEmpty() && stack.peek() > c && size+stack.size() >k){\\n                if(stack.peek()==letter && letterCount+count[letter-\\'a\\']<=repetition) \\n                    break;\\n                visited[stack.peek()-\\'a\\'] = false;\\n                if(stack.pop()==letter)\\n                \\tletterCount--;\\n                    \\n            }\\n            stack.push(c);\\n            size--; \\n            if(c!=letter)\\n            \\tvisited[c-\\'a\\'] = true;\\n            else \\n            \\tletterCount++;\\n            count[c-\\'a\\']--;\\n        }\\n        StringBuilder sb = new StringBuilder(k);\\n        for(Character c:stack){\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    \\n\\n",
                "solutionTags": [],
                "code": "Input\\n\"adffhjfmmmmorsfff\"\\n6\\n\"f\"\\n5\\n**Output**\\n\"dfffff\"\\n**Expected**\\n\"afffff\"\\n\\nIsn\\'t output a part of result as it is an increasing subsequence for this input.\\n\\n\\n        int[] count  = new int[26];\\n        boolean[] visited  = new boolean[26];\\n        for(char c:s.toCharArray()){\\n            count[c-\\'a\\']++; \\n        }\\n        Stack<Character> stack = new Stack<>();\\n        int size = s.length(), letterCount=0;\\n        for(char c:s.toCharArray()){\\n            \\n            if(visited[c-\\'a\\'])\\n                continue;\\n            while(!stack.isEmpty() && stack.peek() > c && size+stack.size() >k){\\n                if(stack.peek()==letter && letterCount+count[letter-\\'a\\']<=repetition) \\n                    break;\\n                visited[stack.peek()-\\'a\\'] = false;\\n                if(stack.pop()==letter)\\n                \\tletterCount--;\\n                    \\n            }\\n            stack.push(c);\\n            size--; \\n            if(c!=letter)\\n            \\tvisited[c-\\'a\\'] = true;\\n            else \\n            \\tletterCount++;\\n            count[c-\\'a\\']--;\\n        }\\n        StringBuilder sb = new StringBuilder(k);\\n        for(Character c:stack){\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    \\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1797908,
                "title": "c-easy-solution-o-n",
                "content": "```\\nstring smallestSubsequence(string s, int k, char letter, int repetition) {\\n\\n        int len = s.size(), remain = count(s.begin(), s.end(), letter);\\n        string stack;\\n        int repcount = 0;\\n        for (int i = 0; i < len; i++) {\\n            while (!stack.empty() && stack.back() > s[i] &&\\n                  (len - i + stack.size() > k) &&\\n                  (stack.back() != letter || repcount + remain > repetition)) {\\n                if (stack.back() == letter)\\n                    repcount--;\\n                stack.pop_back();\\n            }\\n\\n            if (stack.size() < k) {\\n                if (s[i] == letter || k-(int)stack.size()+repcount > repetition) {\\n                    stack += s[i];\\n                    if (s[i] == letter)\\n                        repcount++;\\n                }\\n            }\\n\\n            if (s[i] == letter)\\n                remain--;\\n        }\\n    \\n        return stack;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring smallestSubsequence(string s, int k, char letter, int repetition) {\\n\\n        int len = s.size(), remain = count(s.begin(), s.end(), letter);\\n        string stack;\\n        int repcount = 0;\\n        for (int i = 0; i < len; i++) {\\n            while (!stack.empty() && stack.back() > s[i] &&\\n                  (len - i + stack.size() > k) &&\\n                  (stack.back() != letter || repcount + remain > repetition)) {\\n                if (stack.back() == letter)\\n                    repcount--;\\n                stack.pop_back();\\n            }\\n\\n            if (stack.size() < k) {\\n                if (s[i] == letter || k-(int)stack.size()+repcount > repetition) {\\n                    stack += s[i];\\n                    if (s[i] == letter)\\n                        repcount++;\\n                }\\n            }\\n\\n            if (s[i] == letter)\\n                remain--;\\n        }\\n    \\n        return stack;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1791294,
                "title": "c-solution-o-n-space-and-time-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int fulfilled = 0; // fulfilled >= repetitions\\n        stack<char> st; // montonically increasing stack\\n        int n = s.length(), deletions = n-k;\\n        \\n        vector<int> letter_occurences(n);\\n        for(int i = n-1; i >= 0; i--) {\\n            if(i == n-1) {\\n                if(s[n-1] == letter) letter_occurences[n-1] = 1;\\n                else letter_occurences[n-1] = 0;\\n            } else {\\n                if(s[i] == letter) letter_occurences[i] = letter_occurences[i+1]+1;\\n                else letter_occurences[i] = letter_occurences[i+1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(st.empty() or st.top() < s[i]) {\\n                st.push(s[i]);\\n                if(s[i] == letter) fulfilled++;\\n            } else {\\n                while(!st.empty() and st.top() > s[i]) {\\n                    // consider deletions\\n                    int topchar = st.top();\\n                    if(deletions == 0) break;\\n                    if(topchar == letter and fulfilled+letter_occurences[i] <= repetition) break;\\n                    st.pop();\\n                    if(topchar == letter) fulfilled--;\\n                    deletions--;\\n                }\\n                \\n                st.push(s[i]);\\n                if(s[i] == letter) fulfilled++;\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        while(!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());        \\n        ans = ans.substr(0,k);\\n        \\n        int cnt = 0;\\n        for(char c:ans) \\n            if(c == letter) cnt++;\\n        \\n        if(cnt < repetition) {\\n            for(int i = ans.length()-1; i >= 0; i--) {\\n                if(ans[i] != letter) {\\n                    ans[i] = letter;\\n                    cnt++;\\n                }\\n                if(cnt == repetition) break;\\n            }\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int fulfilled = 0; // fulfilled >= repetitions\\n        stack<char> st; // montonically increasing stack\\n        int n = s.length(), deletions = n-k;\\n        \\n        vector<int> letter_occurences(n);\\n        for(int i = n-1; i >= 0; i--) {\\n            if(i == n-1) {\\n                if(s[n-1] == letter) letter_occurences[n-1] = 1;\\n                else letter_occurences[n-1] = 0;\\n            } else {\\n                if(s[i] == letter) letter_occurences[i] = letter_occurences[i+1]+1;\\n                else letter_occurences[i] = letter_occurences[i+1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(st.empty() or st.top() < s[i]) {\\n                st.push(s[i]);\\n                if(s[i] == letter) fulfilled++;\\n            } else {\\n                while(!st.empty() and st.top() > s[i]) {\\n                    // consider deletions\\n                    int topchar = st.top();\\n                    if(deletions == 0) break;\\n                    if(topchar == letter and fulfilled+letter_occurences[i] <= repetition) break;\\n                    st.pop();\\n                    if(topchar == letter) fulfilled--;\\n                    deletions--;\\n                }\\n                \\n                st.push(s[i]);\\n                if(s[i] == letter) fulfilled++;\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        while(!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());        \\n        ans = ans.substr(0,k);\\n        \\n        int cnt = 0;\\n        for(char c:ans) \\n            if(c == letter) cnt++;\\n        \\n        if(cnt < repetition) {\\n            for(int i = ans.length()-1; i >= 0; i--) {\\n                if(ans[i] != letter) {\\n                    ans[i] = letter;\\n                    cnt++;\\n                }\\n                if(cnt == repetition) break;\\n            }\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719960,
                "title": "dew-it-very-simple-greedy-logic-no-stack-o-n",
                "content": "**THE IDEA**\\n* We build the answer from left to right because leftward characters matter more when lexicographically sorting strings\\n* At any point during the process:\\n  * if we have `r` remaining `letter` chars to use, we cannot pick any character after the `r`th last occurrence of `letter` in `s`\\n  * if we have `x` remaining slots in the answer to fill, we cannot pick any character after the `x`th last character in `s`\\n* Which characters from `s` are available for our current position in answer is determined by whichever of the two constraints (`r` based or `x` based) from above is tighter.\\nWe simply choose the smallest available character\\n\\n**AN EXAMPLE**\\n* `leet, 3, e, 1`\\n* `ans = _ _ _`\\n* For the `0`th position:\\n  * We have 1 remaining `e` to use. This means, the char at `0` cannot come from beyond the `e` at index `2` (last `e`) of `s`\\n  * We have 3 remaining slots to fill. This mean, the char at `0` cannot come from beyong the `e` at index `1` (third last char) of `s`\\n  * The second is the tighter constraint. So we choose the smallest char upto index `1` of `s` - and that\\'s `e` from index `1`\\n* `ans = e _ _`\\n* For `1`st position:\\n  * Both constraints point at `2` being the last index we can choose from\\n  * Note: an additional constraint (trivially) is that we cannot reuse chars from before.\\n  This implicity means that the real range of indices we can choose from in this case is `(1, 2]` i.e. `[2]`\\n\\n**CODE**\\n\\n**More readable**\\n```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        char[] arr = s.toCharArray(), ans = new char[k];\\n        int c = letter - \\'a\\';\\n        int[] pointers = new int[26];\\n        List<Integer>[] indices = getIndices(arr);\\n        for(int i=0, n=arr.length; i<k-r; ++i) {\\n            int rth = (r == 0 ? n : indices[c].get(indices[c].size() - r)), x = Math.min(rth, n - (k-i));\\n            for(int j=0; j<26; ++j) if(pointers[j] < indices[j].size()) {\\n                int first = indices[j].get(pointers[j]);\\n                if(x >= first) {\\n                    ans[i] = arr[first];\\n                    if(j == c && r > 0)\\n                        --r;\\n                    for(j=0; j<26; ++j)\\n                        while(pointers[j] < indices[j].size() && indices[j].get(pointers[j]) <= first)\\n                            ++pointers[j];\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=k-r; i<k; ++i)\\n            ans[i] = letter;\\n        return String.valueOf(ans);\\n    }\\n    \\n    private List<Integer>[] getIndices(char[] arr) {\\n        List<Integer>[] indices = new List[26];\\n        for(int i=0; i<26; ++i)\\n            indices[i] = new ArrayList<>();\\n        for(int i=0; i<arr.length; ++i)\\n            indices[arr[i]-\\'a\\'].add(i);\\n        return indices;\\n    }\\n}\\n```\\n\\n**Faster**\\n```\\nclass Solution {\\n    int n;\\n    char[] arr;\\n    int[] sizes, pointers;\\n    int[][] indices;\\n    \\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        init(s);\\n        char[] ans = new char[k];\\n        int c = letter - \\'a\\';\\n        for(int i=0; i<k-r; ++i) {\\n            int rth = (r == 0 ? n : indices[c][sizes[c] - r]), x = Math.min(rth, n - (k-i));\\n            for(int j=0; j<26; ++j) if(pointers[j] < sizes[j]) {\\n                int first = indices[j][pointers[j]];\\n                if(x >= first) {\\n                    ans[i] = arr[first];\\n                    if(j == c && r > 0)\\n                        --r;\\n                    for(j=0; j<26; ++j)\\n                        while(pointers[j] < sizes[j] && indices[j][pointers[j]] <= first)\\n                            ++pointers[j];\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=k-r; i<k; ++i)\\n            ans[i] = letter;\\n        return String.valueOf(ans);\\n    }\\n    \\n    private void init(String s) {\\n        arr = s.toCharArray();\\n        n = arr.length;\\n        sizes = new int[26];\\n        pointers = new int[26];\\n        for(char c: arr)\\n            ++sizes[c-\\'a\\'];\\n        indices = new int[26][];\\n        for(int i=0; i<26; ++i) {\\n            indices[i] = new int[sizes[i]];\\n            sizes[i] = 0;\\n        }\\n        for(int i=0; i<n; ++i) {\\n            int c = arr[i] - \\'a\\';\\n            indices[c][sizes[c]++] = i;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        char[] arr = s.toCharArray(), ans = new char[k];\\n        int c = letter - \\'a\\';\\n        int[] pointers = new int[26];\\n        List<Integer>[] indices = getIndices(arr);\\n        for(int i=0, n=arr.length; i<k-r; ++i) {\\n            int rth = (r == 0 ? n : indices[c].get(indices[c].size() - r)), x = Math.min(rth, n - (k-i));\\n            for(int j=0; j<26; ++j) if(pointers[j] < indices[j].size()) {\\n                int first = indices[j].get(pointers[j]);\\n                if(x >= first) {\\n                    ans[i] = arr[first];\\n                    if(j == c && r > 0)\\n                        --r;\\n                    for(j=0; j<26; ++j)\\n                        while(pointers[j] < indices[j].size() && indices[j].get(pointers[j]) <= first)\\n                            ++pointers[j];\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=k-r; i<k; ++i)\\n            ans[i] = letter;\\n        return String.valueOf(ans);\\n    }\\n    \\n    private List<Integer>[] getIndices(char[] arr) {\\n        List<Integer>[] indices = new List[26];\\n        for(int i=0; i<26; ++i)\\n            indices[i] = new ArrayList<>();\\n        for(int i=0; i<arr.length; ++i)\\n            indices[arr[i]-\\'a\\'].add(i);\\n        return indices;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int n;\\n    char[] arr;\\n    int[] sizes, pointers;\\n    int[][] indices;\\n    \\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        init(s);\\n        char[] ans = new char[k];\\n        int c = letter - \\'a\\';\\n        for(int i=0; i<k-r; ++i) {\\n            int rth = (r == 0 ? n : indices[c][sizes[c] - r]), x = Math.min(rth, n - (k-i));\\n            for(int j=0; j<26; ++j) if(pointers[j] < sizes[j]) {\\n                int first = indices[j][pointers[j]];\\n                if(x >= first) {\\n                    ans[i] = arr[first];\\n                    if(j == c && r > 0)\\n                        --r;\\n                    for(j=0; j<26; ++j)\\n                        while(pointers[j] < sizes[j] && indices[j][pointers[j]] <= first)\\n                            ++pointers[j];\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=k-r; i<k; ++i)\\n            ans[i] = letter;\\n        return String.valueOf(ans);\\n    }\\n    \\n    private void init(String s) {\\n        arr = s.toCharArray();\\n        n = arr.length;\\n        sizes = new int[26];\\n        pointers = new int[26];\\n        for(char c: arr)\\n            ++sizes[c-\\'a\\'];\\n        indices = new int[26][];\\n        for(int i=0; i<26; ++i) {\\n            indices[i] = new int[sizes[i]];\\n            sizes[i] = 0;\\n        }\\n        for(int i=0; i<n; ++i) {\\n            int c = arr[i] - \\'a\\';\\n            indices[c][sizes[c]++] = i;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666562,
                "title": "c-solution-with-stack-o-n",
                "content": "```\\npublic class Solution \\n{\\n    public string SmallestSubsequence(string s, int k, char letter, int repetition) \\n    {\\n        int wantedRemained = s.Count(letter.Equals);\\n        Stack<char> stack = new();\\n        int numberOfWanted = 0;\\n        for (int i = 0; i < s.Length; ++i) \\n        {\\n            while (stack.Any() && stack.Peek() > s[i] && \\n                   numberOfWanted + wantedRemained - NumberOfWanted(stack.Peek()) >= repetition &&\\n                   stack.Count() + s.Length - i > k) \\n\\t\\t\\t\\t\\t   numberOfWanted -= NumberOfWanted(stack.Pop());\\n            \\n            if (s[i] == letter) --wantedRemained;\\n            \\n            if (stack.Count >= k || (s[i] != letter && repetition - numberOfWanted >= k - stack.Count())) continue;\\n\\t\\t\\t\\n            stack.Push(s[i]);\\n            if (s[i] == letter) ++numberOfWanted;\\n        }\\n        return String.Concat(stack.Reverse());\\n        \\n        int NumberOfWanted(char c) => c == letter ? 1 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string SmallestSubsequence(string s, int k, char letter, int repetition) \\n    {\\n        int wantedRemained = s.Count(letter.Equals);\\n        Stack<char> stack = new();\\n        int numberOfWanted = 0;\\n        for (int i = 0; i < s.Length; ++i) \\n        {\\n            while (stack.Any() && stack.Peek() > s[i] && \\n                   numberOfWanted + wantedRemained - NumberOfWanted(stack.Peek()) >= repetition &&\\n                   stack.Count() + s.Length - i > k) \\n\\t\\t\\t\\t\\t   numberOfWanted -= NumberOfWanted(stack.Pop());\\n            \\n            if (s[i] == letter) --wantedRemained;\\n            \\n            if (stack.Count >= k || (s[i] != letter && repetition - numberOfWanted >= k - stack.Count())) continue;\\n\\t\\t\\t\\n            stack.Push(s[i]);\\n            if (s[i] == letter) ++numberOfWanted;\\n        }\\n        return String.Concat(stack.Reverse());\\n        \\n        int NumberOfWanted(char c) => c == letter ? 1 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541770,
                "title": "java-simple-monostack-solution",
                "content": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int n = s.length();\\n        \\n        Deque<Character> stack = new LinkedList<>();\\n        int count = 0; \\n        for(int i= 0;i<n;i++) if(s.charAt(i) == letter) count++; // count the number of the letter\\n        \\n        int leftLetter = count-repetition; // all the letter we can delete\\n        int leftChar = n-k; // all the chars we have to delete\\n        \\n        for(int i= 0;i<n;i++){\\n            char c = s.charAt(i);\\n            while(!stack.isEmpty() && stack.peek()>c && leftChar>0)// when the peek char is bigger than the s[i], and we still can delete chars\\n            {\\n                if(stack.peek()== letter && leftLetter<=0) break; // if we already delete all the letter we can delelte.\\n                if(stack.peek()== letter) leftLetter--; // delete the letter and reduce the letter left for delete.\\n                leftChar--; // reduce the chars left for delete.\\n                stack.pop();\\n            }\\n            stack.push(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.isEmpty()) {\\n            char c = stack.pop();\\n            if(leftChar==0) sb.append(c); // no more chars we can delete.\\n            else if(c == letter && leftLetter==0 ) sb.append(c); // no more letters we can delete\\n            else{\\n                if(c == letter && leftLetter>0 ) leftLetter--;\\n                leftChar--;\\n            } \\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int n = s.length();\\n        \\n        Deque<Character> stack = new LinkedList<>();\\n        int count = 0; \\n        for(int i= 0;i<n;i++) if(s.charAt(i) == letter) count++; // count the number of the letter\\n        \\n        int leftLetter = count-repetition; // all the letter we can delete\\n        int leftChar = n-k; // all the chars we have to delete\\n        \\n        for(int i= 0;i<n;i++){\\n            char c = s.charAt(i);\\n            while(!stack.isEmpty() && stack.peek()>c && leftChar>0)// when the peek char is bigger than the s[i], and we still can delete chars\\n            {\\n                if(stack.peek()== letter && leftLetter<=0) break; // if we already delete all the letter we can delelte.\\n                if(stack.peek()== letter) leftLetter--; // delete the letter and reduce the letter left for delete.\\n                leftChar--; // reduce the chars left for delete.\\n                stack.pop();\\n            }\\n            stack.push(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.isEmpty()) {\\n            char c = stack.pop();\\n            if(leftChar==0) sb.append(c); // no more chars we can delete.\\n            else if(c == letter && leftLetter==0 ) sb.append(c); // no more letters we can delete\\n            else{\\n                if(c == letter && leftLetter>0 ) leftLetter--;\\n                leftChar--;\\n            } \\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518947,
                "title": "java-stack-suffix-sum",
                "content": "```\\n// i - index in string [0..n), so n-i == number of characters left to process\\n// j - index in result sequence under construction [0..k], so k-j == number of characters still to add to the result\\npublic String smallestSubsequence(String s, int k, char letter, int repetition) {\\n\\tif(k==repetition) return Character.toString(letter).repeat(k);\\n\\tchar[] ca= s.toCharArray(), ans= new char[k];\\n\\tint n= ca.length;\\n\\n\\tint[] lettersLeft= new int[n+1];  // \"suffix sum\" of \\'letter\\' count\\n\\tlettersLeft[n]= 0;\\n\\tfor(int i=n-1; i>=0; i--)\\n\\t\\tlettersLeft[i]= lettersLeft[i+1] + (ca[i]==letter?1:0);\\n\\n\\tfor(int i=0, j=0; i<n; i++){ // in order to achieve the smallest subsequence alphabetically\\n\\t\\tfor(char c= ca[i];;){    // try to contract stack as long as current char < stack top\\n\\t\\t\\tchar pc= j==0 ? 0 : ans[j-1];\\n\\t\\t\\tif(c<pc && pc==letter){ // can remove \\'letter\\' from the stack if\\n\\t\\t\\t\\t// 1. we\\'ll still have enough chars left in string to fill ans, 2. there is enough \\'letter\\' chars left ahead\\n\\t\\t\\t\\tif(n-i>=k-j+1 && lettersLeft[i]>=repetition+1){\\n\\t\\t\\t\\t\\t--j; ++repetition;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t// add the smaller char after the \\'letter\\' if we cannot afford to remove the \\'letter\\' and have space\\n\\t\\t\\t\\t\\tif(k-j>Math.max(0,repetition)) ans[j++]= c; \\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else if(c<pc && n-i>=k-j+1){ // we can remove another char if we\\'ll still have enough chars left to fill ans\\n\\t\\t\\t\\t--j;\\n\\t\\t\\t}else{ // we cannot remove previous char, so we just append (if we have space)\\n\\t\\t\\t\\tif(c==letter){ if(k-j>0) {ans[j++]= c; --repetition;} }\\n\\t\\t\\t\\telse if(k-j>Math.max(0,repetition)) ans[j++]= c;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}    \\n\\t}\\n\\treturn new String(ans);\\n}",
                "solutionTags": [],
                "code": "```\\n// i - index in string [0..n), so n-i == number of characters left to process\\n// j - index in result sequence under construction [0..k], so k-j == number of characters still to add to the result\\npublic String smallestSubsequence(String s, int k, char letter, int repetition) {\\n\\tif(k==repetition) return Character.toString(letter).repeat(k);\\n\\tchar[] ca= s.toCharArray(), ans= new char[k];\\n\\tint n= ca.length;\\n\\n\\tint[] lettersLeft= new int[n+1];  // \"suffix sum\" of \\'letter\\' count\\n\\tlettersLeft[n]= 0;\\n\\tfor(int i=n-1; i>=0; i--)\\n\\t\\tlettersLeft[i]= lettersLeft[i+1] + (ca[i]==letter?1:0);\\n\\n\\tfor(int i=0, j=0; i<n; i++){ // in order to achieve the smallest subsequence alphabetically\\n\\t\\tfor(char c= ca[i];;){    // try to contract stack as long as current char < stack top\\n\\t\\t\\tchar pc= j==0 ? 0 : ans[j-1];\\n\\t\\t\\tif(c<pc && pc==letter){ // can remove \\'letter\\' from the stack if\\n\\t\\t\\t\\t// 1. we\\'ll still have enough chars left in string to fill ans, 2. there is enough \\'letter\\' chars left ahead\\n\\t\\t\\t\\tif(n-i>=k-j+1 && lettersLeft[i]>=repetition+1){\\n\\t\\t\\t\\t\\t--j; ++repetition;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t// add the smaller char after the \\'letter\\' if we cannot afford to remove the \\'letter\\' and have space\\n\\t\\t\\t\\t\\tif(k-j>Math.max(0,repetition)) ans[j++]= c; \\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else if(c<pc && n-i>=k-j+1){ // we can remove another char if we\\'ll still have enough chars left to fill ans\\n\\t\\t\\t\\t--j;\\n\\t\\t\\t}else{ // we cannot remove previous char, so we just append (if we have space)\\n\\t\\t\\t\\tif(c==letter){ if(k-j>0) {ans[j++]= c; --repetition;} }\\n\\t\\t\\t\\telse if(k-j>Math.max(0,repetition)) ans[j++]= c;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}    \\n\\t}\\n\\treturn new String(ans);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1516093,
                "title": "python-easy-to-understand-beat-98",
                "content": "* first of all, we need to get a valid increasing sub sequence\\n* then we can remove the letter backwards. \\n\\n```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        lc = s.count(letter)\\n        n = len(s) - k\\n        st = []\\n    \\n        for c in s:\\n            while st and st[-1] > c and n > 0 :\\n                if st[-1] == letter:\\n                    if lc > repetition:\\n                        lc -= 1\\n                    else:\\n                        break\\n                st.pop()\\n                n -= 1\\n            st.append(c)\\n          \\n        if n > 0:\\n            for i in range(len(st)-1, -1, -1):\\n                if n <= 0:\\n                    break\\n                if st[i] == letter:\\n                    if lc == repetition:\\n                        # skip this\\n                        continue\\n                    else:\\n                        lc -= 1\\n                st[i] = \"\"\\n                n -= 1\\n                \\n        return \"\".join(st)\\n                \\n            \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        lc = s.count(letter)\\n        n = len(s) - k\\n        st = []\\n    \\n        for c in s:\\n            while st and st[-1] > c and n > 0 :\\n                if st[-1] == letter:\\n                    if lc > repetition:\\n                        lc -= 1\\n                    else:\\n                        break\\n                st.pop()\\n                n -= 1\\n            st.append(c)\\n          \\n        if n > 0:\\n            for i in range(len(st)-1, -1, -1):\\n                if n <= 0:\\n                    break\\n                if st[i] == letter:\\n                    if lc == repetition:\\n                        # skip this\\n                        continue\\n                    else:\\n                        lc -= 1\\n                st[i] = \"\"\\n                n -= 1\\n                \\n        return \"\".join(st)\\n                \\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515799,
                "title": "c-picking-the-best-character-to-place-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        \\n        int n = s.length();\\n        \\n        vector<int> ids[26];\\n        for(int i=0;i<n;i++)\\n            ids[s[i]-\\'a\\'].push_back(i);\\n        \\n        string ans;\\n        int pref[n];\\n        memset(pref,0,sizeof(pref));\\n        pref[0] = (s[0]==letter);\\n        for(int i=1;i<n;i++)\\n            pref[i] = pref[i-1] + (s[i]==letter);\\n        \\n        std::function<int(int,int)> cnt = [&](int left, int right){\\n            return pref[right] - (left-1>=0?pref[left-1]:0);\\n        };\\n        \\n        int i = -1; \\n        int reps = repetition;\\n        int copy_k = k;\\n        while(i<n){\\n            for(int j=0;j<26;j++){\\n                auto it = upper_bound(ids[j].begin(),ids[j].end(),i);\\n                if(it==ids[j].end())\\n                    continue;\\n                int id = ids[j][(it - ids[j].begin())];\\n                int check = (id+1<n)?(cnt(id+1,n-1)):0;\\n                int cnt_for_k = n-(id+1);\\n                bool see = ((\\'a\\'+j)==letter);\\n                if(see){\\n                    if(cnt_for_k>=(k-1) and (reps-1)<=check and (reps-1)<=k-1){\\n                        k--;\\n                        reps--;\\n                        ans+=(j+\\'a\\');\\n                        i = id;\\n                        break;\\n                    }\\n                }\\n                else{\\n                    if(cnt_for_k>=(k-1) and reps<=check and reps<=k-1){\\n                        k--;\\n                        ans+=(j+\\'a\\');\\n                        i = id;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(ans.size()==copy_k)\\n                break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        \\n        int n = s.length();\\n        \\n        vector<int> ids[26];\\n        for(int i=0;i<n;i++)\\n            ids[s[i]-\\'a\\'].push_back(i);\\n        \\n        string ans;\\n        int pref[n];\\n        memset(pref,0,sizeof(pref));\\n        pref[0] = (s[0]==letter);\\n        for(int i=1;i<n;i++)\\n            pref[i] = pref[i-1] + (s[i]==letter);\\n        \\n        std::function<int(int,int)> cnt = [&](int left, int right){\\n            return pref[right] - (left-1>=0?pref[left-1]:0);\\n        };\\n        \\n        int i = -1; \\n        int reps = repetition;\\n        int copy_k = k;\\n        while(i<n){\\n            for(int j=0;j<26;j++){\\n                auto it = upper_bound(ids[j].begin(),ids[j].end(),i);\\n                if(it==ids[j].end())\\n                    continue;\\n                int id = ids[j][(it - ids[j].begin())];\\n                int check = (id+1<n)?(cnt(id+1,n-1)):0;\\n                int cnt_for_k = n-(id+1);\\n                bool see = ((\\'a\\'+j)==letter);\\n                if(see){\\n                    if(cnt_for_k>=(k-1) and (reps-1)<=check and (reps-1)<=k-1){\\n                        k--;\\n                        reps--;\\n                        ans+=(j+\\'a\\');\\n                        i = id;\\n                        break;\\n                    }\\n                }\\n                else{\\n                    if(cnt_for_k>=(k-1) and reps<=check and reps<=k-1){\\n                        k--;\\n                        ans+=(j+\\'a\\');\\n                        i = id;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(ans.size()==copy_k)\\n                break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509199,
                "title": "easy-to-understand-code-c",
                "content": "```\\nstring smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int totalOccurencesOfLetter = 0;\\n        for(char c : s){\\n            totalOccurencesOfLetter += (c==letter);\\n        }\\n        string store=\"\";\\n         int currentOccurencesOfLetter = 0,totalOccurencesLeft = totalOccurencesOfLetter;\\n         for (int i = 0; i < s.size(); i++) {\\n              while (!store.empty() && store.back() > s[i] && (s.size() - i + store.size() > k) && (store.back() != letter ||                                                                                                   ((totalOccurencesLeft+currentOccurencesOfLetter) > repetition))){\\n                    if (store.back() == letter)\\n                        currentOccurencesOfLetter--;\\n                    store.pop_back();\\n              }\\n\\n             if (store.size() < k) {\\n                 if (s[i] == letter || k - (int)store.size() > (repetition-currentOccurencesOfLetter)) {\\n                    store += s[i];\\n                    if (s[i] == letter)\\n                        currentOccurencesOfLetter++;\\n                }\\n            }\\n\\n            if (s[i] == letter)\\n              totalOccurencesLeft--;\\n        }\\n      return store;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int totalOccurencesOfLetter = 0;\\n        for(char c : s){\\n            totalOccurencesOfLetter += (c==letter);\\n        }\\n        string store=\"\";\\n         int currentOccurencesOfLetter = 0,totalOccurencesLeft = totalOccurencesOfLetter;\\n         for (int i = 0; i < s.size(); i++) {\\n              while (!store.empty() && store.back() > s[i] && (s.size() - i + store.size() > k) && (store.back() != letter ||                                                                                                   ((totalOccurencesLeft+currentOccurencesOfLetter) > repetition))){\\n                    if (store.back() == letter)\\n                        currentOccurencesOfLetter--;\\n                    store.pop_back();\\n              }\\n\\n             if (store.size() < k) {\\n                 if (s[i] == letter || k - (int)store.size() > (repetition-currentOccurencesOfLetter)) {\\n                    store += s[i];\\n                    if (s[i] == letter)\\n                        currentOccurencesOfLetter++;\\n                }\\n            }\\n\\n            if (s[i] == letter)\\n              totalOccurencesLeft--;\\n        }\\n      return store;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505069,
                "title": "o-n-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        stack<char> st;\\n        vector<int>v(s.length(), 0);\\n        \\n        for(int i = s.length() - 1; i >= 0 ; i--) {\\n            if(s[i] == letter) {\\n                if(i < s.length() - 1){\\n                    v[i] = v[i + 1] + 1;\\n                } else {\\n                    v[i] = 1;\\n                }\\n                    \\n            } else {\\n                if(i < s.length() - 1){\\n                    v[i] = v[i + 1] ;\\n                } \\n            }\\n        }\\n        \\n        int lneeded = (int)repetition;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            while(st.size() > 0) {\\n                int x = st.top() == letter ? 1 : 0;\\n                \\n                if(s.length() - i > k - st.size() && v[i] >= lneeded + x && st.top() > s[i]) {\\n                    char temp = st.top();\\n                    st.pop();\\n                    if(temp == letter) {\\n                        lneeded ++;\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n                \\n            if(st.size() < k) {                \\n                st.push(s[i]);\\n                if(s[i] == letter){\\n                    lneeded = lneeded-1;\\n                }\\n                \\n                \\n                int t1 = lneeded, t2 = (int) (k-st.size());\\n                \\n                if( t1 > t2 ) {\\n                    st.pop();\\n                    if(s[i] == letter) {\\n                        lneeded++;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        vector<char>ans;\\n        while(st.size()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        string finans(ans.begin(), ans.end());\\n\\n        return finans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        stack<char> st;\\n        vector<int>v(s.length(), 0);\\n        \\n        for(int i = s.length() - 1; i >= 0 ; i--) {\\n            if(s[i] == letter) {\\n                if(i < s.length() - 1){\\n                    v[i] = v[i + 1] + 1;\\n                } else {\\n                    v[i] = 1;\\n                }\\n                    \\n            } else {\\n                if(i < s.length() - 1){\\n                    v[i] = v[i + 1] ;\\n                } \\n            }\\n        }\\n        \\n        int lneeded = (int)repetition;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            while(st.size() > 0) {\\n                int x = st.top() == letter ? 1 : 0;\\n                \\n                if(s.length() - i > k - st.size() && v[i] >= lneeded + x && st.top() > s[i]) {\\n                    char temp = st.top();\\n                    st.pop();\\n                    if(temp == letter) {\\n                        lneeded ++;\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n                \\n            if(st.size() < k) {                \\n                st.push(s[i]);\\n                if(s[i] == letter){\\n                    lneeded = lneeded-1;\\n                }\\n                \\n                \\n                int t1 = lneeded, t2 = (int) (k-st.size());\\n                \\n                if( t1 > t2 ) {\\n                    st.pop();\\n                    if(s[i] == letter) {\\n                        lneeded++;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        vector<char>ans;\\n        while(st.size()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        string finans(ans.begin(), ans.end());\\n\\n        return finans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502460,
                "title": "stack-solution-two-ways-to-kick-out-the-top-character-from-stack",
                "content": "Learned from the \"stack hint\" and high vote post from the discussion area.\\n```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n = s.size();\\n        vector<int> suffix(n, 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            suffix[i] = (s[i] == letter ? 1 : 0);\\n            suffix[i] += (i < n - 1 ? suffix[i + 1] : 0);\\n        }\\n        vector<char> stack;\\n        int seen = 0;\\n        for (int i = 0; i < n; ++i) {\\n            bool isNewValid = (s[i] == letter);\\n            while (!stack.empty()) {\\n                int size = stack.size();\\n                bool kick = false;\\n                bool isLastValid = (stack.back() == letter);\\n                if (isNewValid && (size >= (k - repetition) + (seen + 1))) {\\n                    kick = true;\\n                }\\n                if (s[i] < stack.back() && size + (n - 1 - i) >= k &&\\n                    (seen - (isLastValid ? 1 : 0) + suffix[i] >= repetition)) {\\n                    kick = true;\\n                }\\n                if (kick) {\\n                    seen -= (isLastValid ? 1 : 0);\\n                    stack.pop_back();\\n                } else {\\n                    break;\\n                }\\n            }\\n            if (stack.size() < k) {\\n                seen += (isNewValid ? 1 : 0);\\n                stack.emplace_back(s[i]);\\n            }\\n        }\\n        return {begin(stack), end(stack)};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestSubsequence(string s, int k, char letter, int repetition) {\\n        int n = s.size();\\n        vector<int> suffix(n, 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            suffix[i] = (s[i] == letter ? 1 : 0);\\n            suffix[i] += (i < n - 1 ? suffix[i + 1] : 0);\\n        }\\n        vector<char> stack;\\n        int seen = 0;\\n        for (int i = 0; i < n; ++i) {\\n            bool isNewValid = (s[i] == letter);\\n            while (!stack.empty()) {\\n                int size = stack.size();\\n                bool kick = false;\\n                bool isLastValid = (stack.back() == letter);\\n                if (isNewValid && (size >= (k - repetition) + (seen + 1))) {\\n                    kick = true;\\n                }\\n                if (s[i] < stack.back() && size + (n - 1 - i) >= k &&\\n                    (seen - (isLastValid ? 1 : 0) + suffix[i] >= repetition)) {\\n                    kick = true;\\n                }\\n                if (kick) {\\n                    seen -= (isLastValid ? 1 : 0);\\n                    stack.pop_back();\\n                } else {\\n                    break;\\n                }\\n            }\\n            if (stack.size() < k) {\\n                seen += (isNewValid ? 1 : 0);\\n                stack.emplace_back(s[i]);\\n            }\\n        }\\n        return {begin(stack), end(stack)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502370,
                "title": "python-o-n-greedy-simple-solution",
                "content": "```\\n\\t\\tn = len(s)\\n        letterArray = [0 for _ in range(n)]\\n        if s[n-1] == letter:\\n            letterArray[-1] = 1\\n        for i in range(n-2,-1,-1):\\n            if s[i] == letter:\\n                letterArray[i] = 1+letterArray[i+1]\\n            else:\\n                letterArray[i] = letterArray[i+1]\\n        c = collections.defaultdict(collections.deque)\\n        for idx,x in enumerate(s):\\n            c[x].append(idx)\\n        ans = \"\"\\n        last = -1\\n        for i in range(k):\\n            for t in string.ascii_lowercase:\\n                while c[t] and c[t][0] <= last:\\n                    c[t].popleft()\\n                if c[t] and n-c[t][0] >= k - i and letterArray[c[t][0]] >= repetition:\\n                    if t != letter and repetition >= k-i:\\n                        continue\\n                    ans += t\\n                    if t == letter:\\n                        repetition -= 1\\n                    last = c[t][0]\\n                    c[t].popleft()\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n\\t\\tn = len(s)\\n        letterArray = [0 for _ in range(n)]\\n        if s[n-1] == letter:\\n            letterArray[-1] = 1\\n        for i in range(n-2,-1,-1):\\n            if s[i] == letter:\\n                letterArray[i] = 1+letterArray[i+1]\\n            else:\\n                letterArray[i] = letterArray[i+1]\\n        c = collections.defaultdict(collections.deque)\\n        for idx,x in enumerate(s):\\n            c[x].append(idx)\\n        ans = \"\"\\n        last = -1\\n        for i in range(k):\\n            for t in string.ascii_lowercase:\\n                while c[t] and c[t][0] <= last:\\n                    c[t].popleft()\\n                if c[t] and n-c[t][0] >= k - i and letterArray[c[t][0]] >= repetition:\\n                    if t != letter and repetition >= k-i:\\n                        continue\\n                    ans += t\\n                    if t == letter:\\n                        repetition -= 1\\n                    last = c[t][0]\\n                    c[t].popleft()\\n                    break\\n        return ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502101,
                "title": "java-select-the-smallest-qualified-character-k-times",
                "content": "We select the smallest qualified character in s to be the next character in the output string for k times, subject to following criteria:\\n* there are sufficient needed letters remain in the input string s after the character\\n* there are sufficient open spots for these needed letters in output string\\n\\nIndexes of each character in s is pre-computed and cursors are maintained to only move forward among the indexes. curr position is s is also maintained to ensure the selection only goes forward.\\n\\n```\\n  public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n    int n = s.length();\\n    char[] ca = s.toCharArray();\\n    List<List<Integer>> indexes = new ArrayList<>();\\n    for (int i = 0; i < 26; i++) {\\n      indexes.add(new ArrayList<>());\\n    }\\n    for (int i = 0; i < n; i++) {\\n      indexes.get(ca[i] - \\'a\\').add(i);\\n    }\\n\\n    // sufcnt[i] is number of required letter in suffix [i,n)\\n    int[] sufcnt = new int[n + 1];\\n    for (int i = n - 1; i >= 0; i--) {\\n      sufcnt[i] = sufcnt[i+1] + (ca[i] == letter ? 1 : 0);\\n    }\\n\\n    // cursors[c] is the current offset in indexes.get(c) \\n    int[] cursors = new int[26];\\n    StringBuilder sb = new StringBuilder();\\n\\n    // current index in s to select character at or after\\n    int curr = 0;\\n    int needed = repetition;\\n    for (int len = 0; len < k; len++) {\\n      for (int c = 0; c < 26; c++) {\\n        List<Integer> idxes = indexes.get(c);\\n        while (cursors[c] < idxes.size() && idxes.get(cursors[c]) < curr) {\\n          cursors[c]++;\\n        }\\n        if (cursors[c] < idxes.size()) {\\n          int idx = idxes.get(cursors[c]);\\n          // Skip if there will be no sufficient characters remain if chosen\\n          if (len + n - idx < k) {\\n            continue;\\n          }\\n\\n          if (sufcnt[idx] >= needed && len + needed + (c + \\'a\\' == letter ? 0 : 1) <= k) {\\n            // We want to append the whole suffix string at idx if the total length is k.\\n            if (len + n - idx == k) {\\n              sb.append(s.substring(idx));\\n              return sb.toString();\\n            }\\n            sb.append((char)(\\'a\\' + c));\\n            cursors[c]++;\\n            if (letter == \\'a\\' + c) {\\n              needed = Math.max(0, needed - 1);\\n            }\\n            curr = idx + 1;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return sb.toString();\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n    int n = s.length();\\n    char[] ca = s.toCharArray();\\n    List<List<Integer>> indexes = new ArrayList<>();\\n    for (int i = 0; i < 26; i++) {\\n      indexes.add(new ArrayList<>());\\n    }\\n    for (int i = 0; i < n; i++) {\\n      indexes.get(ca[i] - \\'a\\').add(i);\\n    }\\n\\n    // sufcnt[i] is number of required letter in suffix [i,n)\\n    int[] sufcnt = new int[n + 1];\\n    for (int i = n - 1; i >= 0; i--) {\\n      sufcnt[i] = sufcnt[i+1] + (ca[i] == letter ? 1 : 0);\\n    }\\n\\n    // cursors[c] is the current offset in indexes.get(c) \\n    int[] cursors = new int[26];\\n    StringBuilder sb = new StringBuilder();\\n\\n    // current index in s to select character at or after\\n    int curr = 0;\\n    int needed = repetition;\\n    for (int len = 0; len < k; len++) {\\n      for (int c = 0; c < 26; c++) {\\n        List<Integer> idxes = indexes.get(c);\\n        while (cursors[c] < idxes.size() && idxes.get(cursors[c]) < curr) {\\n          cursors[c]++;\\n        }\\n        if (cursors[c] < idxes.size()) {\\n          int idx = idxes.get(cursors[c]);\\n          // Skip if there will be no sufficient characters remain if chosen\\n          if (len + n - idx < k) {\\n            continue;\\n          }\\n\\n          if (sufcnt[idx] >= needed && len + needed + (c + \\'a\\' == letter ? 0 : 1) <= k) {\\n            // We want to append the whole suffix string at idx if the total length is k.\\n            if (len + n - idx == k) {\\n              sb.append(s.substring(idx));\\n              return sb.toString();\\n            }\\n            sb.append((char)(\\'a\\' + c));\\n            cursors[c]++;\\n            if (letter == \\'a\\' + c) {\\n              needed = Math.max(0, needed - 1);\\n            }\\n            curr = idx + 1;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return sb.toString();\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500948,
                "title": "c-simple-greedy",
                "content": "```\\nstring smallestSubsequence(string s, int k, char letter, int r) {\\n\\tint len = s.size();\\n\\tvector<int> ml = vector<int>(len, 0); // more letter chars ahead\\n\\tint lcnt = 0;\\n\\tfor (int i = len - 1; i >= 0 ; --i) {\\n\\t\\tml[i] = lcnt;\\n\\t\\tif (s[i] == letter)\\n\\t\\t\\tlcnt++;\\n\\t}\\n\\n\\tstring out, valid;\\n\\tfor (int i = 0; i < len; ++i) {\\n\\t\\twhile (!out.empty() && out.back() > s[i] && len - i > k && (out.back()!=letter || ml[i] > r) || k < r) {\\n\\t\\t\\tif (out.back()==letter)\\n\\t\\t\\t\\tr++;\\n\\t\\t\\tk++;\\n\\t\\t\\tout.pop_back();\\n\\t\\t}\\n\\t\\tout.push_back(s[i]);\\n\\t\\tif (s[i]==letter)\\n\\t\\t\\tr--;\\n\\t\\tk--;\\n\\n\\t\\tif (k==0 && r<=0)\\n\\t\\t\\tvalid = out;\\n\\t}\\n\\n\\treturn valid;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring smallestSubsequence(string s, int k, char letter, int r) {\\n\\tint len = s.size();\\n\\tvector<int> ml = vector<int>(len, 0); // more letter chars ahead\\n\\tint lcnt = 0;\\n\\tfor (int i = len - 1; i >= 0 ; --i) {\\n\\t\\tml[i] = lcnt;\\n\\t\\tif (s[i] == letter)\\n\\t\\t\\tlcnt++;\\n\\t}\\n\\n\\tstring out, valid;\\n\\tfor (int i = 0; i < len; ++i) {\\n\\t\\twhile (!out.empty() && out.back() > s[i] && len - i > k && (out.back()!=letter || ml[i] > r) || k < r) {\\n\\t\\t\\tif (out.back()==letter)\\n\\t\\t\\t\\tr++;\\n\\t\\t\\tk++;\\n\\t\\t\\tout.pop_back();\\n\\t\\t}\\n\\t\\tout.push_back(s[i]);\\n\\t\\tif (s[i]==letter)\\n\\t\\t\\tr--;\\n\\t\\tk--;\\n\\n\\t\\tif (k==0 && r<=0)\\n\\t\\t\\tvalid = out;\\n\\t}\\n\\n\\treturn valid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500801,
                "title": "c-greedy-stack-solution",
                "content": "```\\nstring smallestSubsequence(string s, int k, char letter, int repetition) \\n{\\n\\tstring result;\\n\\tint n=s.length(),c=0,p=0; // c is the number of available letters, p is the number of letters already used\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tif(s[i]==letter)\\n\\t\\t\\tc++;\\n\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\twhile(!result.empty()&&s[i]<result.back())\\n\\t\\t{\\n\\t\\t\\tif(result.back()==letter)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(c>repetition-p) p--;\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\tif(k-result.length()>=n-i) break;\\n\\n\\t\\t\\tresult.pop_back();\\n\\t\\t}\\n\\t\\tif(result.length()<k)\\n\\t\\t{\\n\\t\\t\\tif(s[i]!=letter&&k-result.length()==repetition-p) continue;\\n\\t\\t\\tif(s[i]==letter) p++;\\n\\t\\t\\tresult+=s[i];            \\n\\t\\t}\\n\\t\\tif(s[i]==letter) c--;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring smallestSubsequence(string s, int k, char letter, int repetition) \\n{\\n\\tstring result;\\n\\tint n=s.length(),c=0,p=0; // c is the number of available letters, p is the number of letters already used\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tif(s[i]==letter)\\n\\t\\t\\tc++;\\n\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\twhile(!result.empty()&&s[i]<result.back())\\n\\t\\t{\\n\\t\\t\\tif(result.back()==letter)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(c>repetition-p) p--;\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\tif(k-result.length()>=n-i) break;\\n\\n\\t\\t\\tresult.pop_back();\\n\\t\\t}\\n\\t\\tif(result.length()<k)\\n\\t\\t{\\n\\t\\t\\tif(s[i]!=letter&&k-result.length()==repetition-p) continue;\\n\\t\\t\\tif(s[i]==letter) p++;\\n\\t\\t\\tresult+=s[i];            \\n\\t\\t}\\n\\t\\tif(s[i]==letter) c--;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1881561,
                "content": [
                    {
                        "username": "ktw361",
                        "content": "For me, the tricky point is not using mono-stack, but to realise the resulting string is monotonic with some additional constraints."
                    }
                ]
            }
        ]
    }
]