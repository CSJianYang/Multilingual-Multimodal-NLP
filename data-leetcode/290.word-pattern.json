[
    {
        "title": "Subsets II",
        "question_content": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n&nbsp;\nExample 1:\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10",
        "solutions": [
            {
                "id": 30168,
                "title": "c-solution-and-explanation",
                "content": "To solve this problem, it is helpful to first think how many subsets are there. If there is no duplicate element, the answer is simply 2^n, where n is the number of elements. This is because you have two choices for each element, either putting it into the subset or not. So all subsets for this no-duplicate set can be easily constructed:\\nnum of subset\\n\\n -  (1        to 2^0) empty set is the first subset\\n -  (2^0+1 to 2^1) add the first element into subset from (1)\\n -  (2^1+1 to 2^2) add the second element into subset (1 to 2^1)\\n -  (2^2+1 to 2^3) add the third element into subset (1 to 2^2)\\n - ....\\n -  (2^(n-1)+1 to 2^n) add the nth element into subset(1 to 2^(n-1))\\n\\nThen how many subsets are there if there are duplicate elements? We can treat duplicate element as a spacial element. For example, if we have duplicate elements (5, 5), instead of treating them as two elements that are duplicate, we can treat it as one special element 5, but this element has more than two choices: you can either NOT put it into the subset, or put ONE 5 into the subset, or put TWO 5s into the subset. Therefore, we are given an array (a1, a2, a3, ..., an) with each of them appearing (k1, k2, k3, ..., kn) times, the number of subset is (k1+1)*(k2+1)*...(kn+1). We can easily see how to write down all the subsets similar to the approach above.\\n\\n        class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > totalset = {{}};\\n            sort(S.begin(),S.end());\\n            for(int i=0; i<S.size();){\\n                int count = 0; // num of elements are the same\\n                while(count + i<S.size() && S[count+i]==S[i])  count++;\\n                int previousN = totalset.size();\\n                for(int k=0; k<previousN; k++){\\n                    vector<int> instance = totalset[k];\\n                    for(int j=0; j<count; j++){\\n                        instance.push_back(S[i]);\\n                        totalset.push_back(instance);\\n                    }\\n                }\\n                i += count;\\n            }\\n            return totalset;\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > totalset = {{}",
                "codeTag": "Java"
            },
            {
                "id": 30164,
                "title": "accepted-10ms-c-solution-use-backtracking-only-10-lines-easy-understand",
                "content": "**The characteristics of C++ reference is an outstanding tool for backtracking algorithm!**\\n\\nlet us use [1,2,3,4] as an example to explain my solution:\\n\\n    subsets([1,2,3,4]) = []\\n                         // push(1)\\n                         [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                         // pop(), push(2)\\n                         [2, subsets([3,4])]\\n                         // pop(), push(3)\\n                         [3, subsets([4])]\\n                         // pop(), push(4)\\n                         [4, subsets([])]\\n                         // pop()\\n\\nAccepted 10ms c++ solution use backtracking for [Subsets ][1]\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsets(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsets(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }\\n    private:\\n    \\tvoid subsets(std::vector<std::vector<int> > &res, std::vector<int> &nums, std::vector<int> &vec, int begin) {\\n    \\t\\tres.push_back(vec);\\n    \\t\\tfor (int i = begin; i != nums.size(); ++i) {\\n    \\t\\t\\tvec.push_back(nums[i]);\\n    \\t\\t\\tsubsets(res, nums, vec, i + 1);\\n    \\t\\t\\tvec.pop_back();\\n    \\t\\t}\\n    \\t}\\n    };\\n\\n\\nAccepted 10ms c++ solution use backtracking for [Subsets II][2]\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsetsWithDup(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsetsWithDup(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }\\n    private:\\n    \\tvoid subsetsWithDup(std::vector<std::vector<int> > &res, std::vector<int> &nums, std::vector<int> &vec, int begin) {\\n    \\t\\tres.push_back(vec);\\n    \\t\\tfor (int i = begin; i != nums.size(); ++i)\\n    \\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n    \\t\\t\\t\\tvec.push_back(nums[i]);\\n    \\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n    \\t\\t\\t\\tvec.pop_back();\\n    \\t\\t\\t}\\n    \\t}\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        std::vector<std::vector<int> > subsets(std::vector<int> &nums) {\\n    \\t\\tstd::sort(nums.begin(), nums.end());\\n            std::vector<std::vector<int> > res;\\n    \\t\\tstd::vector<int> vec;\\n    \\t\\tsubsets(res, nums, vec, 0);\\n    \\t\\treturn res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 169226,
                "title": "java-two-way-of-recursive-thinking",
                "content": "1) Each recursion level focuses on all the following elements. We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos) {\\n        res.add(new ArrayList<>(ls));\\n        for(int i=pos;i<nums.length;i++) {\\n            if(i>pos&&nums[i]==nums[i-1]) continue;\\n            ls.add(nums[i]);\\n            helper(res,ls,nums,i+1);     \\n            ls.remove(ls.size()-1);\\n        }\\n    }\\n}\\n```\\n2) Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0,false);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n        if(pos==nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        helper(res,ls,nums,pos+1,false);\\n        if(pos>=1&&nums[pos]==nums[pos-1]&&!choosePre) return;\\n        ls.add(nums[pos]);\\n        helper(res,ls,nums,pos+1,true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos) {\\n        res.add(new ArrayList<>(ls));\\n        for(int i=pos;i<nums.length;i++) {\\n            if(i>pos&&nums[i]==nums[i-1]) continue;\\n            ls.add(nums[i]);\\n            helper(res,ls,nums,i+1);     \\n            ls.remove(ls.size()-1);\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res,new ArrayList<>(),nums,0,false);\\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n        if(pos==nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        helper(res,ls,nums,pos+1,false);\\n        if(pos>=1&&nums[pos]==nums[pos-1]&&!choosePre) return;\\n        ls.add(nums[pos]);\\n        helper(res,ls,nums,pos+1,true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388566,
                "title": "subsets-i-ii-java-solution-with-detailed-explanation-and-comments-recursion-iteration",
                "content": "Reference: [Subsets I](https://leetcode.com/problems/subsets/) & [Subsets II](https://leetcode.com/problems/subsets-ii/) <span class=\"gray\">EPI 15.5</span>\\nDifficulty: <span class=\"orange\">Medium</span> (I think Subsets II should be hard)\\n\\n\\n\\n## Problem\\n\\n> Given a set of `distinct` integers, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n**Example:** \\n\\n```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\\n\\n**Follow up:** Check out the [Subsets II](#subsets_ii) section below.\\n\\n\\n## Analysis\\n\\nThe power set of a set `S` is the set of all subsets of `S`, including both the empty set `emptyset` and `S` itself. The power set of `{1, 2, 3}` is graphically illustrated as follows.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/mgtg8.jpg)\\n\\n\\n### Backtracking\\n\\nThe idea is that we loop over the number list. For each number, we have two choices: pick it, or not. For example, in `[1, 2, 3]`, we pick `1` and then do the same thing for the subproblem `[2, 3]`; and we don\\'t pick `1` and then do the same thing for the subproblem `[2, 3]`.\\n\\nThe size of subproblems is decreasing. When picking `2`, the subproblem becomes `[3]` instead of `[1, 3]`.\\n\\nConsider the following questions:\\n\\n- What is the base case?\\n- When do we add the list to the result?\\n\\nHere is an illustration of recursive process on `[1, 2, 3]`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gfdd3.jpg)\\n\\n\\n**Note:** Remember to add empty set manually.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\\n\\n**Time:** `O(N * 2^N)` since the recurrence is `T(N) = 2T(N - 1)` and we also spend at most `O(N)` time within a call.\\n**Space:** `O(N * 2^N)` since there are `2^N` subsets. If we only print the result, we just need `O(N)` space.\\n\\n\\n### Iteration\\n\\nThe idea is simple. We go through the elements in the `nums` list. For each element, we loop over the current `result` list we have constructed so far. For each list in the `result`, we make a copy of this list and append the current element to it (it means picking the element). It is based on the same idea in backtracking (in each step you have choices: `pick` or `not pick`).\\n\\nThe result list initially contains an empty list `[]`. We loop over each element of `nums`, e.g. `[1, 2, 3]`.\\n\\n- After the first round, we have `[[], [1]]`.\\n- After the second round, we have `[[], [1], [2], [1,2]]`.\\n- After the third round, we have `[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]`.\\n\\nFirst, let\\'s go over an incorrect version. There are two errors:\\n\\n1. We add a new element to `L`, but it changes the existed `L`. Thus, we should make a new copy of it.\\n2. While looping over `result`, we are modifying its size. In Java, the compiler would yell.\\n\\n**Incorrect version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Correct version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- The outer loop takes `O(N)` time.\\n- The inner loop takes `2, 4, 8, ..., 2^N` time respectively.\\n- In inner loop, making a new copy of `L` takes at most `O(N)` time.\\n- Total runtime `T(N) = N * (2 + 4 + 8 + ... + 2^N) ~= N * 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n### K-Size Subsets\\n\\nActually, we can use the code in [77. Combinations](https://www.junhaow.com/lc/problems/backtracking/77_combinations.html) to solve this problem.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- `C(0, N) + C(1, N) + C(2, N) + C(3, N) + ... + C(N, N) = 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n## Subsets II\\n\\nReference:\\n\\n- [[Java] Two Way of Recursive thinking](https://leetcode.com/problems/subsets-ii/discuss/169226/Java-Two-Way-of-Recursive-thinking)\\n- [Simple iterative solution](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution)\\n\\n> Given a collection of integers that might **contain duplicates**, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\\n\\n### Backtracking\\n\\nWe need to know when we **should not** add a list to the result list.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wek92.jpg)\\n\\nBy observation, a duplicate list occurs when `offset >= 1` (when `offset = 0`, duplicate cannot occur) and `nums[offset - 1] == nums[offset]` and in the previous step we did not pick `nums[offset - 1]`. The information of whether it picks or not could be passed down by a **boolean parameter** `isPicked`.\\n \\nIf the above condition is satisfied:\\n- Do not add the list to the result list.\\n- Do not do the subproblem after picking the current element.\\n- Only do the subproblem after not picking the current element.\\n\\n**Note:** Be careful where we should put the `numList.add(val)` and `numList.remove(numList.size() - 1)`.\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\\n\\nAnother version (similar): \\n\\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n### Iteration\\n\\nUsing the same idea in backtracking, we need to figure out when we should add a list to the result list. Check out three examples below (`[1,2,3]`, `[1,2,2]`, `[5,5,5]`).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/y0inx.jpg)\\n\\nBy observation, we learn that we should start from, if duplicate is detected, a specific location in the result list. In Subsets I, we always start from $0$.\\n\\nInterestingly, the specific location corresponds to the initial size of the result list in the previous round. Since we change the result list in each round, we should cache the size of the result list as `cachedSize`.\\n\\nThen we denote the starting index as `startIdx`. In each round, similar to what we\\'ve done in Subsets I, we set `startIdx` as:\\n\\n- `0` (no duplicate or `i == 0`)\\n- `cachedSize` (duplicate occurs)\\n\\nAfter setting `startIdx`, remember to do the caching job for the current size of the result list. Notice a fact that this cached size may not be used in the next round.\\n\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30137,
                "title": "simple-iterative-solution",
                "content": "If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step.\\n\\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        sort(S.begin(), S.end());\\n        vector<vector<int>> ret = {{}};\\n        int size = 0, startIndex = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n            size = ret.size();\\n            for (int j = startIndex; j < size; j++) {\\n                vector<int> temp = ret[j];\\n                temp.push_back(S[i]);\\n                ret.push_back(temp);\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step.\\n\\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        sort(S.begin(), S.end());\\n        vector<vector<int>> ret = {{}};\\n        int size = 0, startIndex = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n            size = ret.size();\\n            for (int j = startIndex; j < size; j++) {\\n                vector<int> temp = ret[j];\\n                temp.push_back(S[i]);\\n                ret.push_back(temp);\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30166,
                "title": "simple-python-solution-without-extra-space",
                "content": "    class Solution:\\n        # @param num, a list of integer\\n        # @return a list of lists of integer\\n        def subsetsWithDup(self, S):\\n            res = [[]]\\n            S.sort()\\n            for i in range(len(S)):\\n                if i == 0 or S[i] != S[i - 1]:\\n                    l = len(res)\\n                for j in range(len(res) - l, len(res)):\\n                    res.append(res[j] + [S[i]])\\n            return res\\n\\nif S[i] is same to S[i - 1], then it needn't to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param num, a list of integer\\n        # @return a list of lists of integer\\n        def subsetsWithDup(self, S):\\n            res = [[]]\\n            S.sort()\\n            for i in range(len(S)):\\n                if i == 0 or S[i] != S[i - 1]:\\n                    l = len(res)\\n                for j in range(len(res) - l, len(res)):\\n                    res.append(res[j] + [S[i]])\\n            return res\\n\\nif S[i] is same to S[i - 1], then it needn't to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1]",
                "codeTag": "Java"
            },
            {
                "id": 1380237,
                "title": "c-python-bitmasking-backtracking-iterative-solutions-with-picture-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bitmasking (with Hashing)**\\n- In a `nums` array of length `n`, there are total `2^n` possible subsets.\\n- The idea is that we use bitmasks of `n` bits to present the state of subsets, `mask` in `[0, 1, ... 2^n-1]`. If the `i`th bit in the `mask` is `1` means `nums[i]` exists in the subset presented by `mask`.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t- We need to hash the subset and add into a HashTable, let\\'s name `seen`, to check for duplicates.\\n\\n<iframe src=\"https://leetcode.com/playground/FqjVD8Dq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Backtracking version 1 (without Hashing)**\\n- We traverse the tree in PreOrder, starting with `index = 0`, for each `index`, we iterate elements from `nums[index]...nums[n-1]`.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t- If numbers are duplicates, we keep the first time, otherwise we skips. We can see it clearly through following picture.\\n\\n![image](https://assets.leetcode.com/users/images/f2fc14d2-fcf7-4d31-8844-0489a9b83281_1628047166.1461427.png)\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(index, curSubset):\\n            ans.append(curSubset[::])\\n\\n            for i in range(index, len(nums)):\\n                if i > index and nums[i] == nums[i - 1]: continue  # Skip duplicates\\n                curSubset.append(nums[i])\\n                backtrack(i + 1, curSubset)\\n                curSubset.pop()\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\\n\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Backtracking version 2 (without Hasing)**\\n- For each elements of `nums`, there are 2 options: **pick** or **don\\'t pick** that number, so there is total **2^n** possible subsets.\\n- Since the `nums` array may contain duplicate numbers, so in the `2^n` subsets, it may contain duplicate subsets. \\n\\t- We need to sort `nums` array to ensure all the generated subsets will also be sorted. This helps to identify duplicates. For example: subsets {3, 1, 3}, {1, 3, 3}, {3, 3, 1} will become {1, 3, 3}.\\n\\t-  In don\\'t pick choice, we only call it if the last element in current subset different with  `nums[i]` otherwise duplicate occurs.\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, curSubset):\\n            if i == len(nums):\\n                ans.append(curSubset[::])\\n                return\\n\\n            curSubset.append(nums[i])\\n            backtrack(i + 1, curSubset)  # Pick\\n            curSubset.pop()\\n\\n            if not curSubset or curSubset[-1] != nums[i]:\\n                backtrack(i + 1, curSubset)  # Don\\'t pick\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 4: Iterative (with Hashing)**\\n- The idea is that we start with an empty subset.\\n- For each element `num` in `nums`, we iterate all all previous subsets, create new subsets by adding each previous subsets with `num`.\\n- For example: `nums = [1, 2, 3]`\\n\\t- First at all, `ans = [[]]`\\n\\t- Step 1, with `nums[0] = 1`, `ans = [[], [1]]`\\n\\t- Step 2, with `nums[1] = 2`, `ans = [[], [1], [2], [1, 2]]`\\n\\t- Step 3, with `nums[2] = 3`, `ans = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]`\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        ans.add(tuple())\\n        \\n        for num in nums:\\n            newSubsets = set()\\n            for subset in ans:  # Iterate previous subsets from ans\\n                newSubsets.add(tuple(list(subset) + [num]))\\n            ans.update(newSubsets)  # Add new subsets to ans\\n\\t\\t\\t\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(2^N * N)`, where `N <= 10` is length of `nums` array.\\n- Space: `O(2^N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(index, curSubset):\\n            ans.append(curSubset[::])\\n\\n            for i in range(index, len(nums)):\\n                if i > index and nums[i] == nums[i - 1]: continue  # Skip duplicates\\n                curSubset.append(nums[i])\\n                backtrack(i + 1, curSubset)\\n                curSubset.pop()\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, curSubset):\\n            if i == len(nums):\\n                ans.append(curSubset[::])\\n                return\\n\\n            curSubset.append(nums[i])\\n            backtrack(i + 1, curSubset)  # Pick\\n            curSubset.pop()\\n\\n            if not curSubset or curSubset[-1] != nums[i]:\\n                backtrack(i + 1, curSubset)  # Don\\'t pick\\n\\n        nums.sort()\\n        ans = []\\n        backtrack(0, [])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        ans.add(tuple())\\n        \\n        for num in nums:\\n            newSubsets = set()\\n            for subset in ans:  # Iterate previous subsets from ans\\n                newSubsets.add(tuple(list(subset) + [num]))\\n            ans.update(newSubsets)  # Add new subsets to ans\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30305,
                "title": "simple-python-solution-dfs",
                "content": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        ret = []\\n        self.dfs(sorted(nums), [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        ret = []\\n        self.dfs(sorted(nums), [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30156,
                "title": "subset-i-ii-and-perm-i-ii-difference-explained",
                "content": "There are many good posts explaining the backtrack idea of these two topics. \\n\\nThe subset and permutation problems all have similar code. However, I did not find one that explains the difference between them. And despite the fact that they have similar code, actually they are very different.\\n\\n\\n* subset I, II\\nMy codes are similar to many others: push one element into the vector and then recursively call the function. After that pop that element out.\\n**Explanation:** The subset problem is all about **choice**, whether you want certain element inside the vector or not. For example, [1, 2, 3], starting with pos = 0. At pos = 0, you push 1 into temp, then recursively call the function. Then this reclusive call is a \"crossroad\". Inside the call (with all other calls inside), you have the \"1\" chosen and every vector you produce will begin with 1. When the call returns (ie. you pop 1 out), you are on the other road of the crossroad, which does not contain 1. These are just the first \"choice\" you are faced. And after that you face with other similar choices. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n**subset II :** Eliminate the dup with sort and then the condition: do not put this element inside, if it has same element before && the former dup has not been put into it. Because otherwise, you better off put the former dup into the vector instead of this (latter dup) one. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n* Permutation I, II\\nPermutation I is a very typical problem. \\n\\n**Note:** the pos here is different with the pos in subset. The pos in subset is more like choice in front of crossroad while the pos in permutation is the \"digit\" you are considering. In other words, you you consider the elements one by one: which one should be the first? which one should be the second? ...and so on. The **pos** is just the \"first\", \"second\"...\\n\\nWhen you consider the n**th** element, you swap the n**th** with element from n**th** to the last one, so that every element after that will have a chance to stay in the n**th** position. You recursively call, after each case.\\n\\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\npermutation II\\nI prefer to use the unordered_map to solve the dup problem. How does it solve the problem? because it treats all the dup as one element with several copies. \\n\\nFor example, [1, 1, 2], when you iterate, in the same \"level\", the 1 will only be put once. We only put the other 1 into the vector in the recursive call in next levels.\\n\\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30150,
                "title": "very-simple-and-fast-java-solution",
                "content": "    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        int i = pos;\\n        while (i < n.length) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n            i++;\\n            while (i < n.length && n[i] == n[i - 1]) {i++;}\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe Basic idea is: use \"while (i < n.length && n[i] == n[i - 1]) {i++;}\" to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: \\n\\n - each.add(n[i]); --> add first 2 (index 0)\\n - helper(res, new ArrayList<>(each), i + 1, n); --> go to recursion part, list each is <2 (index 0)>\\n - while (i < n.length && n[i] == n[i - 1]) {i++;} --> after this, i == 3, add the element as in subset I",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        int i = pos;\\n        while (i < n.length) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n            i++;\\n            while (i < n.length && n[i] == n[i - 1]) {i++;}\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe Basic idea is: use \"while (i < n.length && n[i] == n[i - 1]) {i++;}\" to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: \\n\\n - each.add(n[i]); --> add first 2 (index 0)\\n - helper(res, new ArrayList<>(each), i + 1, n); --> go to recursion part, list each is <2 (index 0)>\\n - while (i < n.length && n[i] == n[i - 1]) {i++;} --> after this, i == 3, add the element as in subset I",
                "codeTag": "Unknown"
            },
            {
                "id": 429537,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30158,
                "title": "standard-dfs-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            Arrays.sort(nums);\\n            List<List<Integer>> result= new ArrayList<>();\\n            dfs(nums,0,new ArrayList<Integer>(),result);\\n            return result;\\n        }\\n        \\n        public void dfs(int[] nums,int index,List<Integer> path,List<List<Integer>> result){\\n            result.add(path);\\n            for(int i=index;i<nums.length;i++){\\n                if(i>index&&nums[i]==nums[i-1]) continue;\\n                List<Integer> nPath= new ArrayList<>(path);\\n                nPath.add(nums[i]);\\n                dfs(nums,i+1,nPath,result);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            Arrays.sort(nums);\\n            List<List<Integer>> result= new ArrayList<>();\\n            dfs(nums,0,new ArrayList<Integer>(),result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1380366,
                "title": "java-python-recursion-visualization",
                "content": "Constraints:\\n\\n**1 <= nums.length <= 10**\\n-10 <= nums[i] <= 10\\n\\nthe input size give us a clear hint that it is a backtracking solution, if there were no duplicates then it would easy problem to backtrack, the trick is to skip the duplicates **except the first time**.\\n**backTrack( index, currentList )** \\n\\nExample -> nums = [1,2,2,3]\\n\\n![image](https://assets.leetcode.com/users/images/faa81e48-fd2d-4cea-ba2c-6daa7d187343_1628014649.6702619.gif)\\n\\n\\nPython -\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        result=[]\\n        nums.sort()#To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        def backtrack(nums,index=0,arr=[]):\\n            result.append( arr.copy() )\\n            for i in range( index, len(nums)):\\n                if i != index and nums[i] ==nums[i-1]: #skip the duplicates, except for the first time\\n                    continue\\n                arr.append(nums[i]) #include the element\\n                backtrack(nums,i+1,arr ) #explore\\n                arr.pop() #remove the element\\n            \\n        backtrack(nums)\\n        return result\\n```\\n\\t\\t\\n\\n\\nJava version -\\n\\n```\\nclass Solution {\\n    List<List<Integer>> output;\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort( nums ); //To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        output = new ArrayList();\\n        backTracking( 0, nums, new ArrayList() );\\n        return output;\\n    }\\n    \\n    public void backTracking( int index, int[] nums, List<Integer> list )\\n    {\\n        output.add( new ArrayList(list) );\\n        for( int i = index;i < nums.length; i++ )\\n        {\\n            if( i != index && nums[i] == nums[i-1] ) //skip the duplicates, except for the first time\\n                continue;\\n            list.add( nums[i]); //include\\n            backTracking(i+1,nums,list); //explore\\n            list.remove( list.size()-1);//backtrack, remove the element\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/103350e1-7c5a-4cf1-836f-0af96d3c6359_1627981167.994198.png)\\n\\nPlease **upvote** if you find it **uselful**. Thanks.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        result=[]\\n        nums.sort()#To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        def backtrack(nums,index=0,arr=[]):\\n            result.append( arr.copy() )\\n            for i in range( index, len(nums)):\\n                if i != index and nums[i] ==nums[i-1]: #skip the duplicates, except for the first time\\n                    continue\\n                arr.append(nums[i]) #include the element\\n                backtrack(nums,i+1,arr ) #explore\\n                arr.pop() #remove the element\\n            \\n        backtrack(nums)\\n        return result\\n```\n```\\nclass Solution {\\n    List<List<Integer>> output;\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort( nums ); //To handle duplicate first we sort the array ( adjacent elements will be similar )\\n        output = new ArrayList();\\n        backTracking( 0, nums, new ArrayList() );\\n        return output;\\n    }\\n    \\n    public void backTracking( int index, int[] nums, List<Integer> list )\\n    {\\n        output.add( new ArrayList(list) );\\n        for( int i = index;i < nums.length; i++ )\\n        {\\n            if( i != index && nums[i] == nums[i-1] ) //skip the duplicates, except for the first time\\n                continue;\\n            list.add( nums[i]); //include\\n            backTracking(i+1,nums,list); //explore\\n            list.remove( list.size()-1);//backtrack, remove the element\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1488442,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "Approach used- Backtracking\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;       //to store all susbets\\n        vector<int> curr;         //to store current individual subset (that we will build)\\n        sort(nums.begin(),nums.end());      //sort the array so that duplicates are adjacent \\n        helper(nums,ans,curr,0);       //we start from index 0\\n        return ans;\\n        \\n    }\\n    \\n    void helper(vector<int>& nums, vector<vector<int>>& ans, vector<int>& curr, int idx){\\n        ans.push_back(curr);       //we include current susbet into final ans\\n        for(int i=idx;i<nums.size();i++){     //check for all possibilites\\n            if(i>idx &&  nums[i]==nums[i-1]) continue;      //if duplicate then we continue\\n            curr.push_back(nums[i]);     //we include nums[i] in current subset\\n            helper(nums,ans,curr,i+1); \\n            curr.pop_back();         //to get subset without nums[i]\\n        }\\n    }  \\n};\\n```\\nHope you found this useful :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;       //to store all susbets\\n        vector<int> curr;         //to store current individual subset (that we will build)\\n        sort(nums.begin(),nums.end());      //sort the array so that duplicates are adjacent \\n        helper(nums,ans,curr,0);       //we start from index 0\\n        return ans;\\n        \\n    }\\n    \\n    void helper(vector<int>& nums, vector<vector<int>>& ans, vector<int>& curr, int idx){\\n        ans.push_back(curr);       //we include current susbet into final ans\\n        for(int i=idx;i<nums.size();i++){     //check for all possibilites\\n            if(i>idx &&  nums[i]==nums[i-1]) continue;      //if duplicate then we continue\\n            curr.push_back(nums[i]);     //we include nums[i] in current subset\\n            helper(nums,ans,curr,i+1); \\n            curr.pop_back();         //to get subset without nums[i]\\n        }\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30242,
                "title": "share-my-2ms-java-iteration-solution-very-simple-and-short",
                "content": "    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tresult.add(new ArrayList<Integer>());\\n\\t\\tint begin = 0;\\n\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\tif(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n\\t\\t\\tint size = result.size();\\n\\t\\t\\tfor(int j = begin; j < size; j++){\\n\\t\\t\\t\\tList<Integer> cur = new ArrayList<Integer>(result.get(j));\\n\\t\\t\\t\\tcur.add(nums[i]);\\n\\t\\t\\t\\tresult.add(cur);\\n\\t\\t\\t}\\n\\t\\t\\tbegin = size;\\n\\t\\t}\\n\\t\\treturn result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tresult.add(new ArrayList<Integer>());\\n\\t\\tint begin = 0;\\n\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\tif(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n\\t\\t\\tint size = result.size();\\n\\t\\t\\tfor(int j = begin; j < size; j++){\\n\\t\\t\\t\\tList<Integer> cur = new ArrayList<Integer>(result.get(j));\\n\\t\\t\\t\\tcur.add(nums[i]);\\n\\t\\t\\t\\tresult.add(cur);\\n\\t\\t\\t}\\n\\t\\t\\tbegin = size;\\n\\t\\t}\\n\\t\\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 750386,
                "title": "python3-dfs-solutions-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30145,
                "title": "accepted-java-iterative-solution",
                "content": "for explanation plz see comments in the code \\n\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        int len = num.length;\\n        if (len == 0) return ans; \\n        \\n        ans.add(new ArrayList<Integer>()); // first, need to add the subset of num[0]\\n        ans.add(new ArrayList<Integer>());\\n        ans.get(1).add(num[0]);\\n        \\n        int nprev = 1; // this is the number of lists that the previous number was added in.\\n                     // if the current number is same as the prev one, it'll be only added in the \\n                    // lists that has the prev number.\\n                    \\n        for (int i = 1; i < len ; ++i){\\n            int size = ans.size();\\n            if (num[i]!=num[i-1])   // if different\\n                nprev = size;        // this means add num[i] to all lists in ans;\\n            for (int j = size-nprev; j < size; ++j){\\n                List<Integer> l = new ArrayList<Integer>(ans.get(j));\\n                l.add(num[i]);\\n                ans.add(l);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "for explanation plz see comments in the code \\n\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        int len = num.length;\\n        if (len == 0) return ans; \\n        \\n        ans.add(new ArrayList<Integer>()); // first, need to add the subset of num[0]\\n        ans.add(new ArrayList<Integer>());\\n        ans.get(1).add(num[0]);\\n        \\n        int nprev = 1; // this is the number of lists that the previous number was added in.\\n                     // if the current number is same as the prev one, it'll be only added in the \\n                    // lists that has the prev number.\\n                    \\n        for (int i = 1; i < len ; ++i){\\n            int size = ans.size();\\n            if (num[i]!=num[i-1])   // if different\\n                nprev = size;        // this means add num[i] to all lists in ans;\\n            for (int j = size-nprev; j < size; ++j){\\n                List<Integer> l = new ArrayList<Integer>(ans.get(j));\\n                l.add(num[i]);\\n                ans.add(l);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1380191,
                "title": "c-simple-and-short-solution-without-recursion",
                "content": "**Explanation:**\\nFor each element in nums, we loop through all previous sets in res and create a new set by adding num to each one of them.\\n**Example:**\\nnum = [5, 6, 8]\\nWe start with one empty set. res = { {} }.\\nIteration 1: num = 5, res = { {}, {5} }.\\nIteration 2: num = 6, res = { {}, {5}, {6}, {5,6} }.\\nIteration 3: num = 8, res = { {}, {5}, {6}, {5,6}, {8}, {5,8}, {6,8}, {5,6,8} }.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095672,
                "title": "cpp-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>m;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>v)\\n    {\\n        if(nums.size()==0)\\n        {\\n            \\n            if(s.find(v)==s.end())\\n            {\\n            \\n                s.insert(v);\\n                m.push_back(v);\\n                \\n            }\\n            return ;\\n        }\\n        vector<int>v1=v,v2=v;\\n        v1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,v1);\\n        solve(nums,v2);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>m;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>v)\\n    {\\n        if(nums.size()==0)\\n        {\\n            \\n            if(s.find(v)==s.end())\\n            {\\n            \\n                s.insert(v);\\n                m.push_back(v);\\n                \\n            }\\n            return ;\\n        }\\n        vector<int>v1=v,v2=v;\\n        v1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,v1);\\n        solve(nums,v2);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30325,
                "title": "java-solution-using-bit-manipulation",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> lists = new ArrayList<>();\\n            int subsetNum = 1<<num.length;\\n            for(int i=0;i<subsetNum;i++){\\n                List<Integer> list = new ArrayList<>();\\n                boolean illegal=false;\\n                for(int j=0;j<num.length;j++){\\n                    if((i>>j&1)==1){\\n                        if(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n                        }else{\\n                            list.add(num[j]);\\n                        }\\n                    }\\n                }\\n                if(!illegal){\\n                   lists.add(list); \\n                }\\n                \\n            }\\n            return lists;\\n        }\\n    }\\n\\nThe idea is using every bit to represent one element in the set. The total number is 2 to num.length. Then we need to avoid duplicates. After we sort the array, the same number will be adjacent to each other. \\n\\nFor example the set is {1,1,1}. We can get subset {} and {1} first. That's great.\\nThen we need to pay attention. Suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate. \\nThat's why I write the predicate:\\nif(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n}\\n\\nHope someone can explain it better. I will go to gym now.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> lists = new ArrayList<>();\\n            int subsetNum = 1<<num.length;\\n            for(int i=0;i<subsetNum;i++){\\n                List<Integer> list = new ArrayList<>();\\n                boolean illegal=false;\\n                for(int j=0;j<num.length;j++){\\n                    if((i>>j&1)==1){\\n                        if(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\\n                            illegal=true;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 30270,
                "title": "share-my-5-lines-of-python-solution",
                "content": "From the previous question Subsets I, the iterate solution is \\n\\n    def subsets(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res]\\n        return res\\n\\nFor every number in nums, we add it to every i in res. Ex. [[]], we add [] + [1] to res. The new res is [ [], [1] ]. Then add [] + [2] and [1] + [2], the new res is [[],[1],[2],[1,2]]. \\n\\nTo void the duplicate, we check if i + [num] is already in res. So the iterate solution for Subsets II is: \\n\\n    def subsetsWithDup(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res if i + [num] not in res]\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "From the previous question Subsets I, the iterate solution is \\n\\n    def subsets(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res]\\n        return res\\n\\nFor every number in nums, we add it to every i in res. Ex. [[]], we add [] + [1] to res. The new res is [ [], [1] ]. Then add [] + [2] and [1] + [2], the new res is [[],[1],[2],[1,2]]. \\n\\nTo void the duplicate, we check if i + [num] is already in res. So the iterate solution for Subsets II is: \\n\\n    def subsetsWithDup(self, nums):\\n        res = [[]]\\n        nums.sort()\\n        for num in nums: \\n            res += [ i + [num] for i in res if i + [num] not in res]\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 688517,
                "title": "python-very-very-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        ## Similar to Leetcode : 47. Permutations II ##\\n\\n\\t\\t## TIME COMPLEXICITY : O(2^N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(2^N) ##\\n\\n        def dfs(curr, nums):                          \\n            \\n            result.append(curr[:])\\n\\n            if(len(nums) == 0):                                         \\n                return\\n            \\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:        # we dont create duplicate initial branches.\\n                    continue\\n                dfs(curr + [nums[i]], nums[i+1:])         # we are sending, nums[i+1:] for next loop\\n                \\n        result = []\\n        dfs([], sorted(nums))                             \\n        return result\\n```\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        ## Similar to Leetcode : 47. Permutations II ##\\n\\n\\t\\t## TIME COMPLEXICITY : O(2^N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(2^N) ##\\n\\n        def dfs(curr, nums):                          \\n            \\n            result.append(curr[:])\\n\\n            if(len(nums) == 0):                                         \\n                return\\n            \\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:        # we dont create duplicate initial branches.\\n                    continue\\n                dfs(curr + [nums[i]], nums[i+1:])         # we are sending, nums[i+1:] for next loop\\n                \\n        result = []\\n        dfs([], sorted(nums))                             \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362743,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        level0    []\\n        level1    [1]          [2] \\n        level2    [1,2]        [2,2]\\n        level3    [1,2,2]\\n        \"\"\"\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        level0    []\\n        level1    [1]          [2] \\n        level2    [1,2]        [2,2]\\n        level3    [1,2,2]\\n        \"\"\"\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209618,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N*2^N), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain 2^N-1 subset. so total time\\n    complexity is O(2^N*2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsetsWithDup(vector<int>& nums, vector<vector<int>> &output, vector<int> temp, int index) {\\n        if(nums.size() == index){\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(!isPresent){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        subsetsWithDup(nums, output, temp, index+1);\\n        temp.push_back(nums[index]);\\n        subsetsWithDup(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> temp;\\n        vector<vector<int>> output;\\n        subsetsWithDup(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time complexity : O(2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind){\\n        ans.push_back(ds);\\n        for(int i=ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums){\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N*2^N), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain 2^N-1 subset. so total time\\n    complexity is O(2^N*2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsetsWithDup(vector<int>& nums, vector<vector<int>> &output, vector<int> temp, int index) {\\n        if(nums.size() == index){\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(!isPresent){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        subsetsWithDup(nums, output, temp, index+1);\\n        temp.push_back(nums[index]);\\n        subsetsWithDup(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> temp;\\n        vector<vector<int>> output;\\n        subsetsWithDup(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time complexity : O(2^N).\\n\\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(2^N*N).\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind){\\n        ans.push_back(ds);\\n        for(int i=ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums){\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380314,
                "title": "python-oneliner-with-product-explained",
                "content": "It is quite classical problem and in python we can use functionality of language to make it oneliner.\\nImagine, that we have case `[1, 1, 1, 2, 2, 3]`. Then what subsets we have? We cah take:\\n1. `[], [1], [1, 1], [1, 1, 1]` when we choose how many ones we take.\\n2. `[], [2], [2, 2]` when we choose how many twos we take.\\n3. `[], [3]` when we choose how many threes we take.\\n\\nOur answer is all options when we take one element from first line, one from second and one from third and concatenate them.\\nLet us look at `[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()]` in mor details: what we have is `A = [[[], [1], [1, 1], [1, 1, 1]], [[], [2], [2, 2]], [[], [3]]]`. Now, what we need to do is to use functionality of product: we want to take elements from `A[0]`, `A[1]` and `A[2]` and for this we use trick `[chain(*i) for i in product(*A)]`, where `*` used to let product know that we want to give each element `A[0], A[1], A[2]` as parameter of product: try to do `product([[1,2,3],[4,5]])` and `product(*[[1,2,3],[4,5]])` and see the difference. The same trick is used for chain.\\n\\n#### Complexity\\nNot very tight bound for time complexity is `O(2^n*n)`, where `n` is total number of elements, space complexity as well. In fact complexity (time and space) is `O((a1+1)*...*(ak+1)*n)`, where `a1, ..., ak` are frequencies of each element.\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, nums):\\n        return [chain(*i) for i in product(*[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()])]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, nums):\\n        return [chain(*i) for i in product(*[[[k]*i for i in range(v+1)] for k, v in Counter(nums).items()])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30292,
                "title": "share-my-12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> subsets;\\n            vector<int> subset;\\n            subsetsWithDupWorker(nums, subsets, subset, 0);\\n            return subsets;\\n        }\\n    private:\\n        void subsetsWithDupWorker(const vector<int>& nums, vector<vector<int>>& subsets, vector<int>& subset, int begin) {\\n            subsets.push_back(subset);\\n            for (int i = begin; i < nums.size(); i++) {\\n                if (i != begin && nums[i] == nums[i-1]) continue;\\n                subset.push_back(nums[i]);\\n                subsetsWithDupWorker(nums, subsets, subset, i+1);\\n                subset.pop_back();\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> subsets;\\n            vector<int> subset;\\n            subsetsWithDupWorker(nums, subsets, subset, 0);\\n            return subsets;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1303284,
                "title": "general-approach-to-backtracking-problems-in-c",
                "content": "Below I present a general approach to many standard backtracking problems. A similar version exists for JAVA [here](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)) but I thought it would be a good idea to do the same for C++ as well, even though  the essence of the solutions remains the same. Most of these problems follow a single template as given below. \\n\\n```\\n//Template\\nvoid Backtrack(int start)\\n{\\n    //Base case \\n\\n// loop for all possible values\\n{\\n    //include the current element at this position if possible in the ans \\n\\t//More generally, make a choice \\n\\n    Backtrack(start+1) \\n\\n    //backtrack by removing current element \\n}\\n```\\n\\n\\n**1**.[78. Subsets](https://leetcode.com/problems/subsets/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        GenerateSubs(a,0,subset,ans);\\n        return ans;      \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n          for(int i=s;i<n;i++)\\n        {\\n            subset.push_back(a[i]); //include element at ith position\\n            GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n            subset.pop_back(); //backtrack\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\\n\\n**2**.[90. Subsets II](https://leetcode.com/problems/subsets-ii/) (Subsets with duplicates)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        sort(a.begin(),a.end()); //sort the elements so that we can keep track of duplicates\\n        GenerateSubs(a,0,subset,ans);\\n        return ans;    \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n        for(int i=s;i<n;i++)\\n        {\\n            if(i==s||a[i]!=a[i-1]) \\n            {\\n              subset.push_back(a[i]); //include element at ith position\\n              GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n              subset.pop_back(); //backtrack\\n            }\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\\n\\n**3.** [77. Combinations](https://leetcode.com/problems/combinations/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        \\n        GenerateCombs(n,1,k,ans,combination);\\n        return ans;\\n    }\\nprivate:\\n    void GenerateCombs(int n,int s,int k,vector<vector<int>> &ans,vector<int> &combination)\\n    {\\n        if(combination.size()==k) //base case\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=n;i++)\\n        {\\n            combination.push_back(i); //include i in a combination\\n            GenerateCombs(n,i+1,k,ans,combination);\\n            combination.pop_back(); //remove i, i.e. backtrack\\n        }\\n    }\\n};\\n```\\n\\n**4.** [39. Combination Sum\\n](https://leetcode.com/problems/combination-sum/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0) //base case1\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination); //base case 2\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n            combination.push_back(a[i]);\\n            combs(a,i,sum-a[i]);\\n            combination.pop_back();\\n        }\\n    }  \\n};\\n```\\n\\n**5.** [40. Combination Sum II\\n](https://leetcode.com/problems/combination-sum-ii/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0)\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n                \\n            if(i==s||a[i]!=a[i-1])\\n            {\\n             combination.push_back(a[i]);\\n             combs(a,i+1,sum-a[i]);\\n             combination.pop_back();   \\n            }\\n        }\\n    }\\n};\\n```\\n\\n**6.**  [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        Generate(0,0,s,n);\\n        return ans;\\n    }\\nprivate:\\n    vector<string>ans;\\n    void Generate(int left,int right,string &s,int n)\\n    {\\n        if(left==n&&right==n) // base case: when left and right parentheses are equal to n.\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t\\n        // case I: if left parenteses are less than n, we can add a ( to the string. \\n\\t\\t//But we might also add a ) so we backtrack by poppping it.\\n        if(left<n)\\n\\t\\t{\\n            s+=\\'(\\';\\n            Generate(left+1,right,s,n);\\n            s.pop_back(); \\n        }\\n        \\n        if(left>right) //case II: follows from I.\\n        {\\n            s+=\\')\\';\\n            Generate(left,right+1,s,n);\\n            s.pop_back();\\n        } \\n    }\\n};\\n```\\n\\n**7.** [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        n=s.size();\\n        Generate(s,0);\\n        return ans;   \\n    }\\nprivate:\\n    vector<vector<string>>ans;\\n    vector<string>Partition;\\n    int n;\\n    \\n    bool is_pal(string &s,int start,int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void Generate(string &s,int start)\\n    {\\n        if(start==n)\\n        {\\n            ans.push_back(Partition);\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++)\\n        {\\n            if(is_pal(s,start,i))\\n            {\\n                Partition.push_back(s.substr(start,i-start+1));\\n                Generate(s,i+1);\\n                Partition.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\\n\\n**8.** [46. Permutations](https://leetcode.com/problems/permutations/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        vector<vector<int>> ans;\\n        \\n        permutations(arr,0,ans);\\n        \\n        return ans;\\n    }\\n    void permutations(vector<int>&arr,int s,vector<vector<int>>&ans)\\n    {\\n        if(s==arr.size())\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i=s;i<arr.size();i++)\\n        {\\n            swap(arr[s],arr[i]);\\n            permutations(arr,s+1,ans);\\n            swap(arr[s],arr[i]);\\n        }\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n//Template\\nvoid Backtrack(int start)\\n{\\n    //Base case \\n\\n// loop for all possible values\\n{\\n    //include the current element at this position if possible in the ans \\n\\t//More generally, make a choice \\n\\n    Backtrack(start+1) \\n\\n    //backtrack by removing current element \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        GenerateSubs(a,0,subset,ans);\\n        return ans;      \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n          for(int i=s;i<n;i++)\\n        {\\n            subset.push_back(a[i]); //include element at ith position\\n            GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n            subset.pop_back(); //backtrack\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        sort(a.begin(),a.end()); //sort the elements so that we can keep track of duplicates\\n        GenerateSubs(a,0,subset,ans);\\n        return ans;    \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n        for(int i=s;i<n;i++)\\n        {\\n            if(i==s||a[i]!=a[i-1]) \\n            {\\n              subset.push_back(a[i]); //include element at ith position\\n              GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n              subset.pop_back(); //backtrack\\n            }\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        \\n        GenerateCombs(n,1,k,ans,combination);\\n        return ans;\\n    }\\nprivate:\\n    void GenerateCombs(int n,int s,int k,vector<vector<int>> &ans,vector<int> &combination)\\n    {\\n        if(combination.size()==k) //base case\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=n;i++)\\n        {\\n            combination.push_back(i); //include i in a combination\\n            GenerateCombs(n,i+1,k,ans,combination);\\n            combination.pop_back(); //remove i, i.e. backtrack\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0) //base case1\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination); //base case 2\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n            combination.push_back(a[i]);\\n            combs(a,i,sum-a[i]);\\n            combination.pop_back();\\n        }\\n    }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0)\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n                \\n            if(i==s||a[i]!=a[i-1])\\n            {\\n             combination.push_back(a[i]);\\n             combs(a,i+1,sum-a[i]);\\n             combination.pop_back();   \\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        Generate(0,0,s,n);\\n        return ans;\\n    }\\nprivate:\\n    vector<string>ans;\\n    void Generate(int left,int right,string &s,int n)\\n    {\\n        if(left==n&&right==n) // base case: when left and right parentheses are equal to n.\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t\\n        // case I: if left parenteses are less than n, we can add a ( to the string. \\n\\t\\t//But we might also add a ) so we backtrack by poppping it.\\n        if(left<n)\\n\\t\\t{\\n            s+=\\'(\\';\\n            Generate(left+1,right,s,n);\\n            s.pop_back(); \\n        }\\n        \\n        if(left>right) //case II: follows from I.\\n        {\\n            s+=\\')\\';\\n            Generate(left,right+1,s,n);\\n            s.pop_back();\\n        } \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        n=s.size();\\n        Generate(s,0);\\n        return ans;   \\n    }\\nprivate:\\n    vector<vector<string>>ans;\\n    vector<string>Partition;\\n    int n;\\n    \\n    bool is_pal(string &s,int start,int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void Generate(string &s,int start)\\n    {\\n        if(start==n)\\n        {\\n            ans.push_back(Partition);\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++)\\n        {\\n            if(is_pal(s,start,i))\\n            {\\n                Partition.push_back(s.substr(start,i-start+1));\\n                Generate(s,i+1);\\n                Partition.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        vector<vector<int>> ans;\\n        \\n        permutations(arr,0,ans);\\n        \\n        return ans;\\n    }\\n    void permutations(vector<int>&arr,int s,vector<vector<int>>&ans)\\n    {\\n        if(s==arr.size())\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i=s;i<arr.size();i++)\\n        {\\n            swap(arr[s],arr[i]);\\n            permutations(arr,s+1,ans);\\n            swap(arr[s],arr[i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250020,
                "title": "c-recursive-and-iterative",
                "content": "To skip duplicates, sort `nums`.\\n\\n**Recursive (Backtracking)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            if (j == i || nums[j] != nums[j - 1]) {\\n                sub.push_back(nums[j]);\\n                subsets(nums, j + 1, sub, subs);\\n                sub.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs = {{}};\\n        for (int i = 0, n = 0; i < nums.size(); i++) {\\n            int j = !i || nums[i] != nums[i - 1] ? 0 : n;\\n            n = subs.size();\\n            for (; j < n; j++) {\\n                subs.push_back(subs[j]);\\n                subs.back().push_back(nums[i]);\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            if (j == i || nums[j] != nums[j - 1]) {\\n                sub.push_back(nums[j]);\\n                subsets(nums, j + 1, sub, subs);\\n                sub.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subs = {{}};\\n        for (int i = 0, n = 0; i < nums.size(); i++) {\\n            int j = !i || nums[i] != nums[i - 1] ? 0 : n;\\n            n = subs.size();\\n            for (; j < n; j++) {\\n                subs.push_back(subs[j]);\\n                subs.back().push_back(nums[i]);\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30304,
                "title": "48ms-solution-with-subset-construction-method",
                "content": "One possible solution is to generate all possible subset using bit-mask, and use a set to test the existence of a subset. However, this method may generate duplicate subsets during the process, and has unsatisfiable time complexity. E.g. for input <1 1 1 1 1 1 1 1 1>, the above method will generate too many duplicate subsets.\\n\\nI use a subset construction method, whose mechanism is illustrated with an example:\\n\\ninput: <1 2 2 3 3 3> (assumed to be sorted)\\n\\ninitialization: empty set <>. ret = {<>}\\n\\nfor element 1, add it to ret, and we get: <1>. ret = {<> <1>}\\n\\nfor element 2, add it to ret, and we get: <2> <1 2>; however, notice that we have two elements of 2, hence we further need to add <2 2> to {<> <1>}, and get <2 2> <1 2 2>. ret = {<> <1> <2> <1 2> <2 2> <1 2 2>}\\n\\nfor element 3, we newly construct the following:              \\n<3> <1 3> <2 3> <1 2 3> < 2 2 3> < 1 2 2 3>             \\n<3 3> <1 3 3> <2 3 3> <1 2 3 3> <2 2 3 3> <1 2 2 3 3>             \\n<3 3 3> <1 3 3 3> < 2 3 3 3> <1 2 3 3 3> <2 2 3 3 3> <1 2 2 3 3 3>                 \\nfinally, ret = {<> <1> <2> <1 2> <2 2> <1 2 2>   \\n<3> <1 3> <2 3> <1 2 3> < 2 2 3> < 1 2 2 3>   \\n<3 3> <1 3 3> <2 3 3> <1 2 3 3> <2 2 3 3> <1 2 2 3 3>   \\n<3 3 3> <1 3 3 3> < 2 3 3 3> <1 2 3 3 3> <2 2 3 3 3> <1 2 2 3 3 3>\\n}\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > ret;\\n            ret.push_back(vector<int>());\\n            sort(S.begin(), S.end());\\n            for (int i = 0; i < S.size(); ) {\\n                int j = i;\\n                while (j < S.size() && S[j] == S[i]) j++;\\n                int size = ret.size();\\n                for (int len = 1; i + len <= j; len++) {\\n                    for (int cnt = 0; cnt < size; cnt++) {\\n                        vector<int> subset(ret[cnt]);\\n                        for (int k = 0; k < len; k++) subset.push_back(S[i]);\\n                        ret.push_back(subset);\\n                    }\\n                }\\n                i = j;\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n            vector<vector<int> > ret;\\n            ret.push_back(vector<int>());\\n            sort(S.begin(), S.end());\\n            for (int i = 0; i < S.size(); ) {\\n                int j = i;\\n                while (j < S.size() && S[j] == S[i]) j++;\\n                int size = ret.size();\\n                for (int len = 1; i + len <= j; len++) {\\n                    for (int cnt = 0; cnt < size; cnt++) {\\n                        vector<int> subset(ret[cnt]);\\n                        for (int k = 0; k < len; k++) subset.push_back(S[i]);\\n                        ret.push_back(subset);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2697523,
                "title": "c-clean-code-subset-ii-brute-force-and-optimized",
                "content": "**1. Brute Force : Generate all subsets (Subset-II)** \\n\\n**Time Complexity :** **`O(2^n*( klog(x) )).2^n`**\\n**Space Complexity :** **`O(2^n * k)`**\\n```\\nclass Solution{\\npublic:\\n    \\n    void solve(vector<int>&nums, int i, vector<int>ds, set<vector<int>>&st) \\n    {\\n        if(i == nums.size()) \\n        {\\n            sort(ds.begin(), ds.end());\\n            st.insert(ds);\\n            return;\\n        }\\n        \\n        ds.push_back(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.pop_back();\\n        solve(nums, i + 1, ds, st);\\n    }\\n    \\n    vector<vector<int>>subsetsWithDup(vector<int>& nums) \\n    {\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        vector<int>ds;\\n        \\n        solve(nums, 0, ds, st);\\n        for(auto &v : st) \\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\\n\\n**2. More Optimized - (Subset-II)**  \\n\\n**Time Complexity :** **`O(k * 2^n)`**\\n**Space Complexity :** **`O(2^n * k)`**\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int ind, vector<int>&nums, vector<int>&path, vector<vector<int>>&paths)\\n    {\\n        paths.push_back(path);\\n        \\n        for(int i=ind;i<nums.size();i++)\\n        {    \\n            if(i!=ind and nums[i] == nums[i-1]) continue; // To avoid duplicate subsets\\n            \\n            path.push_back(nums[i]);\\n            solve(i+1, nums, path, paths);\\n            path.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) \\n    {    \\n        vector<vector<int>>paths;\\n        vector<int>path;\\n        sort(nums.begin(), nums.end()); // sorting is most important --- so that order of duplicate subsets is same\\n        solve(0, nums, path, paths);    // [1,4,4] == [4,1,4] , both are same so no need to include both in answer\\n        return paths; \\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    \\n    void solve(vector<int>&nums, int i, vector<int>ds, set<vector<int>>&st) \\n    {\\n        if(i == nums.size()) \\n        {\\n            sort(ds.begin(), ds.end());\\n            st.insert(ds);\\n            return;\\n        }\\n        \\n        ds.push_back(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.pop_back();\\n        solve(nums, i + 1, ds, st);\\n    }\\n    \\n    vector<vector<int>>subsetsWithDup(vector<int>& nums) \\n    {\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        vector<int>ds;\\n        \\n        solve(nums, 0, ds, st);\\n        for(auto &v : st) \\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int ind, vector<int>&nums, vector<int>&path, vector<vector<int>>&paths)\\n    {\\n        paths.push_back(path);\\n        \\n        for(int i=ind;i<nums.size();i++)\\n        {    \\n            if(i!=ind and nums[i] == nums[i-1]) continue; // To avoid duplicate subsets\\n            \\n            path.push_back(nums[i]);\\n            solve(i+1, nums, path, paths);\\n            path.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) \\n    {    \\n        vector<vector<int>>paths;\\n        vector<int>path;\\n        sort(nums.begin(), nums.end()); // sorting is most important --- so that order of duplicate subsets is same\\n        solve(0, nums, path, paths);    // [1,4,4] == [4,1,4] , both are same so no need to include both in answer\\n        return paths; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921938,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var ans = Set<[Int]>()\\n        var comb = [Int]()\\n        \\n        subset(nums.sorted(), 0, &comb, &ans)\\n        return Array(ans)\\n    }\\n    \\n    \\n    func subset(_ nums: [Int], _ index: Int, _ comb: inout [Int], _ ans: inout Set<[Int]>) {\\n        if index >= nums.count {\\n            ans.insert(comb)\\n            \\n        } else {\\n            subset(nums, index+1, &comb, &ans)\\n            \\n            comb.append(nums[index])\\n            subset(nums, index+1, &comb, &ans)\\n            comb.removeLast()\\n        }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var ans = Set<[Int]>()\\n        var comb = [Int]()\\n        \\n        subset(nums.sorted(), 0, &comb, &ans)\\n        return Array(ans)\\n    }\\n    \\n    \\n    func subset(_ nums: [Int], _ index: Int, _ comb: inout [Int], _ ans: inout Set<[Int]>) {\\n        if index >= nums.count {\\n            ans.insert(comb)\\n            \\n        } else {\\n            subset(nums, index+1, &comb, &ans)\\n            \\n            comb.append(nums[index])\\n            subset(nums, index+1, &comb, &ans)\\n            comb.removeLast()\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549662,
                "title": "java-tc-o-n-2-n-sc-o-uniquenums-space-optimized-iterative-backtracking-solutions",
                "content": "**Space Optimized Iterative Solution. This solution takes only O(Unique Nums) for countMap**\\n\\n```java\\n/**\\n * Space Optimized Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(Unique Nums) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        result.add(new ArrayList<>());\\n\\n        for (int n : countMap.keySet()) {\\n            int size = result.size();\\n            int count = countMap.get(n);\\n\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> cur = result.get(i);\\n                for (int k = 0; k < count; k++) {\\n                    List<Integer> temp = new ArrayList<>(cur);\\n                    temp.add(n);\\n                    result.add(temp);\\n                    cur = temp;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Backtracking (Recursion). This solution take O(N + Unique Nums) space for recursion depth, temp list and countMap**\\n\\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N + Unique Nums)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution1 {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\t\\t\\n\\t\\t// Avoid sorting by using a count Map\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        subsetsWithDupHelper(countMap, new ArrayList<>(countMap.keySet()), 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsWithDupHelper(Map<Integer, Integer> countMap, List<Integer> uniqueNums,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums.get(i);\\n            int count = countMap.get(num);\\n            temp.add(num);\\n            countMap.put(num, count - 1);\\n\\n            subsetsWithDupHelper(countMap, uniqueNums, (count == 1 ? i + 1 : i), temp, result);\\n\\n            countMap.put(num, count);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Subsets questions on LeetCode:\\n- [78. Subsets](https://leetcode.com/problems/subsets/discuss/1549657/Java-or-TC:-O(N*2N)-or-SC:-O(1)-or-Constant-Space-Iterative-and-Backtracking-solutions)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Space Optimized Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(Unique Nums) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        result.add(new ArrayList<>());\\n\\n        for (int n : countMap.keySet()) {\\n            int size = result.size();\\n            int count = countMap.get(n);\\n\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> cur = result.get(i);\\n                for (int k = 0; k < count; k++) {\\n                    List<Integer> temp = new ArrayList<>(cur);\\n                    temp.add(n);\\n                    result.add(temp);\\n                    cur = temp;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N + Unique Nums)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution1 {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\t\\t\\n\\t\\t// Avoid sorting by using a count Map\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        subsetsWithDupHelper(countMap, new ArrayList<>(countMap.keySet()), 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsWithDupHelper(Map<Integer, Integer> countMap, List<Integer> uniqueNums,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums.get(i);\\n            int count = countMap.get(num);\\n            temp.add(num);\\n            countMap.put(num, count - 1);\\n\\n            subsetsWithDupHelper(countMap, uniqueNums, (count == 1 ? i + 1 : i), temp, result);\\n\\n            countMap.put(num, count);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380213,
                "title": "subset-ii-2-approaches-backtracking-iterative-c-java-python",
                "content": "**THIS PROBLEM IS VERY SIMILAR TO [THIS PROBLEM](https://leetcode.com/problems/subsets/)**\\n**NOW COMING TO THE PROBLEM AT HAND**\\n**OBSERVATION TO BE MADE:**\\n* If there are no duplicates the answer is directly `2^N`\\n\\t* This is because you have two choices for each element, either putting it into the subset or not.\\n\\n# **APPORACH I: Iterative**\\n**Algorithm:**\\nSuppose we have {1,2,3,3,3}\\nNow after each iteration our 2-d vector becomes like this-\\n```\\n1. null\\n2. null | 1\\n3. null | 1 | 2 ; 1,2\\n4. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3\\n5. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3\\n6. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3 | 3,3,3; 1,3,3,3; 2,3,3,3; 1,2,3,3,3\\n```\\nIf the number is a duplicate one, we just need to add this number to the last created subsets in the previous step.\\n\\n`In C++`\\n```\\nvector<vector<int> > subsetsWithDup(vector<int> &S) {\\n    sort(S.begin(), S.end());\\n    vector<vector<int>> ret = {{}};\\n    int size = 0, startIndex = 0;\\n    for (int i = 0; i < S.size(); i++) {\\n        startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n        size = ret.size();\\n        for (int j = startIndex; j < size; j++) {\\n            vector<int> temp = ret[j];\\n            temp.push_back(S[i]);\\n            ret.push_back(temp);\\n        }\\n    }\\n    return ret;\\n}\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        result.add(new ArrayList<Integer>());\\n        int begin = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n            int size = result.size();\\n            for(int j = begin; j < size; j++){\\n                List<Integer> cur = new ArrayList<Integer>(result.get(j));\\n                cur.add(nums[i]);\\n                result.add(cur);\\n            }\\n            begin = size;\\n        }\\n        return result;\\n    }\\n}\\n```\\n`In Python`\\n```\\n def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[ ]]\\n        nums.sort()\\n        size = 0\\n        for i in range(len(nums)):\\n            j = size if i > 0 and (nums[i] == nums[i-1]) else 0\\n            size = len(res)\\n            while j < size:\\n                temp = copy.copy(res[j])\\n                temp.append(nums[i])\\n                res.append(temp)\\n                j += 1    \\n        return res\\n```\\n**TIME COMPLEXITY: O(N)**\\n\\n# **APPROACH II: Backtracking**\\nThe characteristics of C++ reference is an outstanding tool for backtracking algorithm!\\n**Algorithm:**\\nLet us use [1,2,3,4] as an example to explain my solution:\\n```\\nsubsets([1,2,3,4]) = []\\n                     // push(1)\\n                     [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                     // pop(), push(2)\\n                     [2, subsets([3,4])]\\n                     // pop(), push(3)\\n                     [3, subsets([4])]\\n                     // pop(), push(4)\\n                     [4, subsets([])]\\n                     // pop()\\n```\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > subsetsWithDup(vector<int> &nums) {\\n\\t\\tsort(nums.begin(), nums.end());\\n        vector<std::vector<int>> res;\\n\\t\\tvector<int> vec;\\n\\t\\tsubsetsWithDup(res, nums, vec, 0);\\n\\t\\treturn res;\\n    }\\nprivate:\\n\\tvoid subsetsWithDup(vector<vector<int> > &res, vector<int> &nums, vector<int> &vec, int begin) {\\n\\t\\tres.push_back(vec);\\n\\t\\tfor (int i = begin; i != nums.size(); ++i)\\n\\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n\\t\\t\\t\\tvec.push_back(nums[i]);\\n\\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n\\t\\t\\t\\tvec.pop_back();\\n\\t\\t\\t}\\n\\t}\\n};\\n```\\n**TIME COMPLEXITY: O(2^N)**\\n",
                "solutionTags": [],
                "code": "```\\n1. null\\n2. null | 1\\n3. null | 1 | 2 ; 1,2\\n4. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3\\n5. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3\\n6. null | 1 | 2 ; 1,2 | 3; 1,3; 2,3; 1,2,3 | 3,3; 1,3,3; 2,3,3; 1,2,3,3 | 3,3,3; 1,3,3,3; 2,3,3,3; 1,2,3,3,3\\n```\n```\\nvector<vector<int> > subsetsWithDup(vector<int> &S) {\\n    sort(S.begin(), S.end());\\n    vector<vector<int>> ret = {{}};\\n    int size = 0, startIndex = 0;\\n    for (int i = 0; i < S.size(); i++) {\\n        startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;\\n        size = ret.size();\\n        for (int j = startIndex; j < size; j++) {\\n            vector<int> temp = ret[j];\\n            temp.push_back(S[i]);\\n            ret.push_back(temp);\\n        }\\n    }\\n    return ret;\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        result.add(new ArrayList<Integer>());\\n        int begin = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]) begin = 0;\\n            int size = result.size();\\n            for(int j = begin; j < size; j++){\\n                List<Integer> cur = new ArrayList<Integer>(result.get(j));\\n                cur.add(nums[i]);\\n                result.add(cur);\\n            }\\n            begin = size;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[ ]]\\n        nums.sort()\\n        size = 0\\n        for i in range(len(nums)):\\n            j = size if i > 0 and (nums[i] == nums[i-1]) else 0\\n            size = len(res)\\n            while j < size:\\n                temp = copy.copy(res[j])\\n                temp.append(nums[i])\\n                res.append(temp)\\n                j += 1    \\n        return res\\n```\n```\\nsubsets([1,2,3,4]) = []\\n                     // push(1)\\n                     [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack.\\n                     // pop(), push(2)\\n                     [2, subsets([3,4])]\\n                     // pop(), push(3)\\n                     [3, subsets([4])]\\n                     // pop(), push(4)\\n                     [4, subsets([])]\\n                     // pop()\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > subsetsWithDup(vector<int> &nums) {\\n\\t\\tsort(nums.begin(), nums.end());\\n        vector<std::vector<int>> res;\\n\\t\\tvector<int> vec;\\n\\t\\tsubsetsWithDup(res, nums, vec, 0);\\n\\t\\treturn res;\\n    }\\nprivate:\\n\\tvoid subsetsWithDup(vector<vector<int> > &res, vector<int> &nums, vector<int> &vec, int begin) {\\n\\t\\tres.push_back(vec);\\n\\t\\tfor (int i = begin; i != nums.size(); ++i)\\n\\t\\t\\tif (i == begin || nums[i] != nums[i - 1]) { \\n\\t\\t\\t\\tvec.push_back(nums[i]);\\n\\t\\t\\t\\tsubsetsWithDup(res, nums, vec, i + 1);\\n\\t\\t\\t\\tvec.pop_back();\\n\\t\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085695,
                "title": "same-code-with-tweaking-solved-2-problems-easy-to-understand",
                "content": "# CHECK THE RECURSION TREE BELOW FOR BETTER UNDERSTANDING .\\n\\n**SIMILAR QUESTION LINK WITH SOLUTION **\\nhttps://leetcode.com/problems/non-decreasing-subsequences/description/\\n\\nhttps://leetcode.com/problems/non-decreasing-subsequences/solutions/3085690/same-code-with-tweaking-solved-2-problems-easy-to-understand/\\n\\n# Intuition\\nSame code is used in solving Non decreasing Subsequence question .\\n\\n# Approach\\nWe are sorting given array. And find all subsequence it can can make ,along with the check that subset should not be repeated .\\ni.e.\\n if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void subsequence(int ind,int n,vector<int>&arr,vector<int>&ds){\\n    if(ind==n){\\n        ans.push_back(ds);\\n        return;\\n    }\\n // Since in this question we can change the order of the array elements unlike question(https://leetcode.com/problems/non-decreasing-subsequences/description/).\\n    //  Therefore we sorted the nums vector initially.\\n    //  Therefore condition , if(ds.size()==0 || nums[index] >= ds[ds.size()-1]) is not required .\\n    ds.push_back(arr[ind]);\\n    subsequence(ind+1,n,arr,ds);\\n    ds.pop_back();\\n    if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])subsequence(ind+1,n,arr,ds);\\n}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        subsequence(0,nums.size(),nums,ds);\\n        return ans;\\n    }\\n};\\n```\\n\\n## ![image.png](https://assets.leetcode.com/users/images/b241b88c-e53b-42d2-9fb5-4e111c7e7d27_1674383113.75447.png)\\n\\n\\n#UPVOTE IF YOU LIKED THE EFFORT\\nTHANK YOU\\nCODE BY :) AMAN MAURYA\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void subsequence(int ind,int n,vector<int>&arr,vector<int>&ds){\\n    if(ind==n){\\n        ans.push_back(ds);\\n        return;\\n    }\\n // Since in this question we can change the order of the array elements unlike question(https://leetcode.com/problems/non-decreasing-subsequences/description/).\\n    //  Therefore we sorted the nums vector initially.\\n    //  Therefore condition , if(ds.size()==0 || nums[index] >= ds[ds.size()-1]) is not required .\\n    ds.push_back(arr[ind]);\\n    subsequence(ind+1,n,arr,ds);\\n    ds.pop_back();\\n    if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])subsequence(ind+1,n,arr,ds);\\n}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        subsequence(0,nums.size(),nums,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953370,
                "title": "fully-explained-c-solution-with-example-time-space-complexity-analysis",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n>  \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursion & Backtracking.***\\n- Here we\\u2019ll first sort the array and for every index, we\\u2019ll try to push elements in such a way that it doesn\\u2019t contain any duplicates.\\n- In every function call, we\\u2019ll push our temp to ans vector. For the first call, it will push an empty subset.\\n- Now we will iterate from index to n-1 & try to pick & not pick an element.\\n- To avoid duplicates if we have already picked an element for the current index of temp with the same value as the index of the given array then we\\u2019ll continue.\\n- After every call we\\u2019ll pop our current element.\\n- Let\\'s explain this with an example:\\n    \\n    ```\\n    if the array is [1,2,2]\\n    \\n    help(0,num)\\n    -> ans=[[]]\\n    -> in for loop: \\n    \\t --> i=0, temp=[1], call help(1,num)\\n    \\t\\t\\t\\thelp(1,num)\\n    \\t\\t\\t\\t-> ans=[[],[1]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=1, temp=[1,2], call help(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=2, temp=[1,2,2] & call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...  \\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, temp=[1,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(1,num) & pop the last element first...\\n    \\t\\t\\t\\t\\t --> i=2, temp=[1], now it will check the condition **if(i!=index && nums[i]==nums[i-1]),** here we already used 2 and our 2nd index element, so if we take 2 again it will give us duplicates. So we\\'ll simply skip this.\\n    \\t\\t\\t\\t\\t --> i=3, temp=[], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop the last element first...\\n    \\t --> i=1, temp=[2] & call help(2,num)\\n    \\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=2, temp=[2,2], call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2],[2,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t--> i=3, temp=[2,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...\\n    \\t\\t\\t\\t\\t\\t--> i=3, temp=[2], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop last element first...\\n    \\t --> i=2, temp=[], again if condition satisfied and will skip this iteration.\\n    \\t --> i=3, temp=[], loop will terminate\\n    ```\\n    \\n- **Time complexity:** O(2^n * n).\\n- **Space complexity:** O(2^n * k).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n        \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        help(0, nums);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& nums){\\n        ans.push_back(temp);\\n        \\n        for(int i=index; i<nums.size(); i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            temp.push_back(nums[i]);\\n            help(i+1, nums);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    if the array is [1,2,2]\\n    \\n    help(0,num)\\n    -> ans=[[]]\\n    -> in for loop: \\n    \\t --> i=0, temp=[1], call help(1,num)\\n    \\t\\t\\t\\thelp(1,num)\\n    \\t\\t\\t\\t-> ans=[[],[1]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=1, temp=[1,2], call help(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=2, temp=[1,2,2] & call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...  \\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t --> i=3, temp=[1,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(1,num) & pop the last element first...\\n    \\t\\t\\t\\t\\t --> i=2, temp=[1], now it will check the condition **if(i!=index && nums[i]==nums[i-1]),** here we already used 2 and our 2nd index element, so if we take 2 again it will give us duplicates. So we\\'ll simply skip this.\\n    \\t\\t\\t\\t\\t --> i=3, temp=[], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop the last element first...\\n    \\t --> i=1, temp=[2] & call help(2,num)\\n    \\t\\t\\t\\thelp(2,num)\\n    \\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2]]\\n    \\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t --> i=2, temp=[2,2], call help(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\thelp(3,num)\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> ans=[[],[1],[1,2],[1,2,3],[2],[2,2]]\\n    \\t\\t\\t\\t\\t\\t\\t\\t-> in for loop:\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t--> i=3, temp=[2,2], loop will terminate\\n    \\t\\t\\t\\t\\t\\t\\t\\tNow it will go back to help(2,num) & pop last element first...\\n    \\t\\t\\t\\t\\t\\t--> i=3, temp=[2], loop will terminate\\n    \\t\\t\\t\\tNow it will go back to help(0,num) & pop last element first...\\n    \\t --> i=2, temp=[], again if condition satisfied and will skip this iteration.\\n    \\t --> i=3, temp=[], loop will terminate\\n    ```\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n        \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        help(0, nums);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& nums){\\n        ans.push_back(temp);\\n        \\n        for(int i=index; i<nums.size(); i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            temp.push_back(nums[i]);\\n            help(i+1, nums);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984188,
                "title": "java-simple-recursion",
                "content": "```\\n public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>>  result =new HashSet<>();\\n        solve(nums,0,new ArrayList<Integer>(),result);\\n        return new ArrayList<>(result);\\n    }\\n    \\n    public void solve(int[] arr,int pos,ArrayList<Integer> op,Set<List<Integer>> result){\\n        if(pos==(arr.length)){\\n            result.add(op);\\n            return;\\n        }\\n     \\n        ArrayList<Integer> op1=new ArrayList<>();\\n        op1.addAll(op);\\n        op1.add(arr[pos]);\\n        solve(arr,pos+1,op1,result);\\n        solve(arr,pos+1,op,result);\\n        return;\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>>  result =new HashSet<>();\\n        solve(nums,0,new ArrayList<Integer>(),result);\\n        return new ArrayList<>(result);\\n    }\\n    \\n    public void solve(int[] arr,int pos,ArrayList<Integer> op,Set<List<Integer>> result){\\n        if(pos==(arr.length)){\\n            result.add(op);\\n            return;\\n        }\\n     \\n        ArrayList<Integer> op1=new ArrayList<>();\\n        op1.addAll(op);\\n        op1.add(arr[pos]);\\n        solve(arr,pos+1,op1,result);\\n        solve(arr,pos+1,op,result);\\n        return;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 647010,
                "title": "javascript-backtrack",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    function findSubset(arr,curr){\\n        res.push([...curr])\\n        for(let i=0;i<arr.length;i++){\\n            if(i== 0 || arr[i] != arr[i-1]){\\n                curr.push(arr[i])\\n                findSubset(arr.slice(i+1),curr)\\n                curr.pop()\\n            }\\n        }\\n    }\\n    let res = []\\n    nums.sort((a,b)=>{return a-b})\\n    findSubset(nums,[])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    function findSubset(arr,curr){\\n        res.push([...curr])\\n        for(let i=0;i<arr.length;i++){\\n            if(i== 0 || arr[i] != arr[i-1]){\\n                curr.push(arr[i])\\n                findSubset(arr.slice(i+1),curr)\\n                curr.pop()\\n            }\\n        }\\n    }\\n    let res = []\\n    nums.sort((a,b)=>{return a-b})\\n    findSubset(nums,[])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30334,
                "title": "share-simple-recursive-java-solution",
                "content": "my method is simple, try to output all combination of the list and skip the same integer.\\n\\n    public class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        LinkedList<Integer> temp = new LinkedList<Integer>();\\n        Rec(num,result,temp,0);\\n        return result;\\n    }\\n    private static void Rec(int[] a,List<List<Integer>> result, LinkedList<Integer> temp, int current){\\n        result.add(new LinkedList(temp));\\n        for(int i=current;i<a.length;i++){\\n            if(i==current || a[i]!=a[i-1]){\\n                temp.add(a[i]);\\n                Rec(a,result,temp,i+1);\\n                temp.remove(temp.size()-1);\\n            }\\n        }\\n        return;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        Arrays.sort(num);\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        LinkedList<Integer> temp = new LinkedList<Integer>();\\n        Rec(num,result,temp,0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2626736,
                "title": "complete-walkthrough-with-pictures-working-explained-behind-the-approach",
                "content": "**Don\\'t have time to read at all. Read only conclusion part, guaranteed you\\'ll be able to write the code by yourself**\\n\\n```\\n/*\\n    Question is exactly similar to \\'Subset I\\' problem with slight modification\\n    --------------------------------------------------------------------------\\n        + We\\'ve to avoid duplicates.\\n        \\n    Recursion Tree Diagram Including Duplicate Subsets\\n    ===================================================\\n    \\n    NOTE:  T : Included ith indexed\\'s element, F : Excluded ith indexed\\'s element\\n    \\n                                  [1, 1, 2]                0th -> indicates making decisions for 0th indexed element\\n                           T         /   \\\\          F\\n                +------------------+      +----------------------+\\n               /                                                  \\\\\\n             {1}+--+                                                {}__   1st -> indexed\\'s decisions\\n           T/       \\\\F                                            /    \\\\ \\n           /         \\\\                                          T/      \\\\F\\n          {1, 1}       {1}+  (duplicate_subtree) --------->    {1}       {}     2nd -> indexed\\'s decisions\\n        T/    \\\\F      T/   \\\\F                                T/  \\\\    T /  \\\\F\\n        /      \\\\      /     \\\\                                /    \\\\    /    \\\\\\n     {1, 1, 2} {1, 1} {1, 2} {1}                            {1, 2} {1} {2}   {}     3rd -> elements are exhausted\\n     ^                         ^                              ^         ^     ^\\n     |                         |                              |         |     |              \\n     |                         |                              |         |     |  \\n     +-------------------------+                              +---------+     |\\n                ^                                               duplicates    ^  \\n                |                                               subsets       |         \\n                +-------------------------------------------------------------+\\n                                        required subsets\\n                                        \\n    \\n    \\n    If we look at the above recursion tree diagram, we\\'ll found that when we move the right subtree of 0th level\\n    i.e. after completing entire left subtree for 0th element. Entire Left sub-tree in this right-subtree, is computed\\n    twice which is already calculated in the left subtree of 0th level.\\n    \\n    Because when we made a decision for 1st element in the first(1st) level to include it in the empty \\n    set, at this point look the given array carefully the element at index 1 is equal to the previous index 0.\\n    \\n    Q: What would happen when made a dfs call to index 1 in the left subtree of 1st level?\\n    A: This entire DFS would give us duplicate subsets at the end, when elements are exhausted.\\n    \\n        Because when made a dfs call to the 0th index in the left subtree of 0th level, all possible\\n        subsets for the range of indices [1, 2] (inclusive) are already calculated{look at the left hand side of\\n        word \\'duplicate_subtree\\' in the recursion tree diagram}.\\n        \\n        So therefore, we can say that making dfs call to the index 1 as the left-subtree of 1st level\\n        is nothing but redundent.\\n  ======================================================================================================\\n  \\n  Conclusion [To keep in mind to avoid duplicates]\\n  ================================================\\n        When we\\'re ignoring any ith indexed element[i.e. going to the right subtree(i+1=level) of ith level]/excluding\\n        the ith element and moving to made the decisions for (i + 1) elemennt in (i + 1) level.\\n        \\n            If element_at_(i + 1)_index is equal to element at i(i.e. nums[i + 1] == nums[i]) and\\n            element at ith index is excluded then must excluded the element at (i + 1) index as well to\\n            avoid duplicates.\\n            \\n                    Because all the subsets in the range of indices [i + 1, n - 1] is already calculated\\n                    when we made a dfs[To include ith element] call to the ith index in the ith level.\\n  \\n        In simple words, basically we\\'ve to exclude the element x iff its previous adjacent\\n        element is also x and it\\'s previously execluded.\\n        \\n    \\n    Q: The biggest question is that what if two equal elements are at different[NOT adjacent] indices like i & j?\\n        where i < j and all possible subsets for the range of indices [j, n - 1] is already calculated\\n        for some dfs call(s) previously made to any index i.\\n        \\n    A: Well!! of course this case could occure but here in the question they stated that you can return the subsets\\n        in any order. Hence, to make the equal elements adjacent to each other we would sort the given \\'nums\\' array.\\n            + Sorting will only change the order of subsets in the resultant list but NOT the count.\\n            + Sorting will adjust all equal element adjacently.\\n*/\\n\\nclass Solution {\\n    \\n    //isPreviousElementExcluded : True -> Means previous element is excluded. NOT execlude[included] otherwise.\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementExcluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        \\n        //Handling the reverse case of our conclusion\\n        if(!isPreviousElementExcluded || (isPreviousElementExcluded && idx > 0 && nums[idx] != nums[idx - 1])) {\\n            runningSubset.add(nums[idx]);\\n            generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n            runningSubset.remove(runningSubset.size() - 1);\\n        }\\n        \\n        //Exclude the ith element [Calling to right-subtree]\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), false);\\n        return subsets;\\n    }\\n}\\n```\\n\\n```\\nExact same Implementation what I\\'ve Discussed in the commented section\\n```\\n\\n```\\nclass Solution {\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementIncluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        //Since this part : should always call\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n\\n        if(!isPreviousElementIncluded && nums[idx] == nums[idx - 1]) return; //Don\\'t repeat inclusion of \\'nums[idx]\\'\\n        \\n        runningSubset.add(nums[idx]);\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n        runningSubset.remove(runningSubset.size() - 1);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), true);\\n        return subsets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Question is exactly similar to \\'Subset I\\' problem with slight modification\\n    --------------------------------------------------------------------------\\n        + We\\'ve to avoid duplicates.\\n        \\n    Recursion Tree Diagram Including Duplicate Subsets\\n    ===================================================\\n    \\n    NOTE:  T : Included ith indexed\\'s element, F : Excluded ith indexed\\'s element\\n    \\n                                  [1, 1, 2]                0th -> indicates making decisions for 0th indexed element\\n                           T         /   \\\\          F\\n                +------------------+      +----------------------+\\n               /                                                  \\\\\\n             {1}+--+                                                {}__   1st -> indexed\\'s decisions\\n           T/       \\\\F                                            /    \\\\ \\n           /         \\\\                                          T/      \\\\F\\n          {1, 1}       {1}+  (duplicate_subtree) --------->    {1}       {}     2nd -> indexed\\'s decisions\\n        T/    \\\\F      T/   \\\\F                                T/  \\\\    T /  \\\\F\\n        /      \\\\      /     \\\\                                /    \\\\    /    \\\\\\n     {1, 1, 2} {1, 1} {1, 2} {1}                            {1, 2} {1} {2}   {}     3rd -> elements are exhausted\\n     ^                         ^                              ^         ^     ^\\n     |                         |                              |         |     |              \\n     |                         |                              |         |     |  \\n     +-------------------------+                              +---------+     |\\n                ^                                               duplicates    ^  \\n                |                                               subsets       |         \\n                +-------------------------------------------------------------+\\n                                        required subsets\\n                                        \\n    \\n    \\n    If we look at the above recursion tree diagram, we\\'ll found that when we move the right subtree of 0th level\\n    i.e. after completing entire left subtree for 0th element. Entire Left sub-tree in this right-subtree, is computed\\n    twice which is already calculated in the left subtree of 0th level.\\n    \\n    Because when we made a decision for 1st element in the first(1st) level to include it in the empty \\n    set, at this point look the given array carefully the element at index 1 is equal to the previous index 0.\\n    \\n    Q: What would happen when made a dfs call to index 1 in the left subtree of 1st level?\\n    A: This entire DFS would give us duplicate subsets at the end, when elements are exhausted.\\n    \\n        Because when made a dfs call to the 0th index in the left subtree of 0th level, all possible\\n        subsets for the range of indices [1, 2] (inclusive) are already calculated{look at the left hand side of\\n        word \\'duplicate_subtree\\' in the recursion tree diagram}.\\n        \\n        So therefore, we can say that making dfs call to the index 1 as the left-subtree of 1st level\\n        is nothing but redundent.\\n  ======================================================================================================\\n  \\n  Conclusion [To keep in mind to avoid duplicates]\\n  ================================================\\n        When we\\'re ignoring any ith indexed element[i.e. going to the right subtree(i+1=level) of ith level]/excluding\\n        the ith element and moving to made the decisions for (i + 1) elemennt in (i + 1) level.\\n        \\n            If element_at_(i + 1)_index is equal to element at i(i.e. nums[i + 1] == nums[i]) and\\n            element at ith index is excluded then must excluded the element at (i + 1) index as well to\\n            avoid duplicates.\\n            \\n                    Because all the subsets in the range of indices [i + 1, n - 1] is already calculated\\n                    when we made a dfs[To include ith element] call to the ith index in the ith level.\\n  \\n        In simple words, basically we\\'ve to exclude the element x iff its previous adjacent\\n        element is also x and it\\'s previously execluded.\\n        \\n    \\n    Q: The biggest question is that what if two equal elements are at different[NOT adjacent] indices like i & j?\\n        where i < j and all possible subsets for the range of indices [j, n - 1] is already calculated\\n        for some dfs call(s) previously made to any index i.\\n        \\n    A: Well!! of course this case could occure but here in the question they stated that you can return the subsets\\n        in any order. Hence, to make the equal elements adjacent to each other we would sort the given \\'nums\\' array.\\n            + Sorting will only change the order of subsets in the resultant list but NOT the count.\\n            + Sorting will adjust all equal element adjacently.\\n*/\\n\\nclass Solution {\\n    \\n    //isPreviousElementExcluded : True -> Means previous element is excluded. NOT execlude[included] otherwise.\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementExcluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        \\n        //Handling the reverse case of our conclusion\\n        if(!isPreviousElementExcluded || (isPreviousElementExcluded && idx > 0 && nums[idx] != nums[idx - 1])) {\\n            runningSubset.add(nums[idx]);\\n            generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n            runningSubset.remove(runningSubset.size() - 1);\\n        }\\n        \\n        //Exclude the ith element [Calling to right-subtree]\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), false);\\n        return subsets;\\n    }\\n}\\n```\n```\\nExact same Implementation what I\\'ve Discussed in the commented section\\n```\n```\\nclass Solution {\\n    \\n    private void generateUniqueSubsets(int[] nums, int idx, List<List<Integer>> subsets,\\n                                       List<Integer> runningSubset, boolean isPreviousElementIncluded) {\\n        if(idx == nums.length) {\\n            subsets.add(new ArrayList<>(runningSubset));\\n            return;\\n        }\\n        //Since this part : should always call\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, false);\\n\\n        if(!isPreviousElementIncluded && nums[idx] == nums[idx - 1]) return; //Don\\'t repeat inclusion of \\'nums[idx]\\'\\n        \\n        runningSubset.add(nums[idx]);\\n        generateUniqueSubsets(nums, idx + 1, subsets, runningSubset, true);\\n        runningSubset.remove(runningSubset.size() - 1);\\n    }\\n    \\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        generateUniqueSubsets(nums, 0, subsets, new ArrayList<>(), true);\\n        return subsets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044127,
                "title": "c-solution-easy-to-understand-beats-100-0ms-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void solve(vector<int>& nums , int start , vector<int>& subset){\\n        result.push_back(subset);\\n        for(int i=start ;i<nums.size();i++){\\n            if(i>start and nums[i-1] == nums[i])\\n                continue;\\n            subset.push_back(nums[i]);\\n            solve(nums , i+1 , subset);\\n            subset.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        vector<int> subset;\\n        solve(nums, 0 , subset);\\n        return result;\\n    }\\n};\\n```\\n\\n**Happy coding**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void solve(vector<int>& nums , int start , vector<int>& subset){\\n        result.push_back(subset);\\n        for(int i=start ;i<nums.size();i++){\\n            if(i>start and nums[i-1] == nums[i])\\n                continue;\\n            subset.push_back(nums[i]);\\n            solve(nums , i+1 , subset);\\n            subset.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        vector<int> subset;\\n        solve(nums, 0 , subset);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690114,
                "title": "python-backtracking-solution",
                "content": "Using sorting and comparison to prevent duplicates. \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        self.res = []\\n        self.backtrack(nums, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        self.res.append(current)\\n        if start > len(nums):\\n            return\\n        for i in range(start, len(nums)):\\n            if i > start and nums[i-1] == nums[i]:\\n                continue\\n            self.backtrack(nums, current + [nums[i]], i + 1)\\n```\\nRuntime: 32 ms, faster than 92.15% of Python3 online submissions for Subsets II.\\nMemory Usage: 13.9 MB, less than 84.06% of Python3 online submissions for Subsets II.\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        self.res = []\\n        self.backtrack(nums, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        self.res.append(current)\\n        if start > len(nums):\\n            return\\n        for i in range(start, len(nums)):\\n            if i > start and nums[i-1] == nums[i]:\\n                continue\\n            self.backtrack(nums, current + [nums[i]], i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630505,
                "title": "no-for-loop-more-intuitive",
                "content": "I noticed the for-loop is used for all the backtracing questions. It is fine. However, it\\'s more intuitive if each recursion focuses on itself - choose or not choose.\\n\\nThe non for-loop is a general solution if you don\\'t need to leap and inspect all other elements in the dataset.\\n\\nUse this question as example. Here\\'s the code:\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subset(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void subset(int[] nums, int index, List<Integer> parts, List<List<Integer>> ret) {\\n        if(index == nums.length) {\\n            ret.add(new ArrayList<>(parts));\\n            return;\\n        }\\n        parts.add(nums[index]);\\n        subset(nums, index+1, parts, ret);\\n        parts.remove(parts.size()-1);\\n        \\n        while(index+1 < nums.length && nums[index+1] == nums[index]) {\\n            ++index;\\n        }\\n        subset(nums, index+1, parts, ret);\\n    }\\n}\\n```\\n\\nUpdated on 08/16/2021: another example we can apply choose or not choose\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/1407822/No-for-loop.-More-intuitive.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subset(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void subset(int[] nums, int index, List<Integer> parts, List<List<Integer>> ret) {\\n        if(index == nums.length) {\\n            ret.add(new ArrayList<>(parts));\\n            return;\\n        }\\n        parts.add(nums[index]);\\n        subset(nums, index+1, parts, ret);\\n        parts.remove(parts.size()-1);\\n        \\n        while(index+1 < nums.length && nums[index+1] == nums[index]) {\\n            ++index;\\n        }\\n        subset(nums, index+1, parts, ret);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267930,
                "title": "python-4-line-beats-99-42",
                "content": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        result = [[]]\\n        for num in sorted(nums):\\n            result += [i+[num] for i in result if i+[num] not in result]\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        result = [[]]\\n        for num in sorted(nums):\\n            result += [i+[num] for i in result if i+[num] not in result]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229447,
                "title": "python-backtracking-general-approach-beats-100",
                "content": "```python\\ndef backtrack(nums, res, temp, start):\\n    res.append(temp)\\n    for i in range(start, len(nums)):\\n\\t\\t# Skip duplicate numbers\\n        if not (i > start and nums[i-1] == nums[i]):\\n            backtrack(nums, res, temp + [nums[i]], i+1)\\n\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        res = []\\n        backtrack(nums, res, [], 0)\\n        return res\\n```\\n\\t\\nSimilar approach can be applied to the below and other problems:\\n\\n* https://leetcode.com/problems/subsets/\\n* https://leetcode.com/problems/subsets-ii/\\n* https://leetcode.com/problems/combinations/\\n* https://leetcode.com/problems/permutations/\\n* https://leetcode.com/problems/permutations-ii/\\n* https://leetcode.com/problems/combination-sum/\\n* https://leetcode.com/problems/combination-sum-ii/\\n* https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [],
                "code": "```python\\ndef backtrack(nums, res, temp, start):\\n    res.append(temp)\\n    for i in range(start, len(nums)):\\n\\t\\t# Skip duplicate numbers\\n        if not (i > start and nums[i-1] == nums[i]):\\n            backtrack(nums, res, temp + [nums[i]], i+1)\\n\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        res = []\\n        backtrack(nums, res, [], 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30286,
                "title": "recursion-and-non-recursion-java-solution-for-your-reference",
                "content": "Two solution, recursion and non-recursion:\\n\\nRecursion solution:\\n\\n    public class Solution {\\n        Set<Integer> hash = new HashSet<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n;\\n        int[] nums;\\n        \\n        public void search(List<Integer> l, int p) {\\n            if (p == n) {\\n                int h = l.hashCode();\\n                if (!hash.contains(h)) {\\n                    hash.add(h);\\n                    res.add(new ArrayList<>(l));\\n                }\\n                return;\\n            }\\n            l.add(nums[p]);\\n            search(l, p+1);\\n            l.remove(l.size()-1);\\n            search(l, p+1);\\n        }\\n        \\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            this.n = nums.length; this.nums = nums;\\n            Arrays.sort(nums);\\n            search(new ArrayList<Integer>(), 0);\\n            return res;\\n        }\\n    }\\n\\nNon-recursion solution:\\n\\n    public class Solution {\\n        public List<List<Integer>> subsetsWithDup(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> temp = new ArrayList<>();\\n            res.add(temp);\\n            Arrays.sort(nums);\\n            int l = 0, k;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (i == 0 || nums[i] != nums[i-1])\\n                    l = res.size();\\n                k = res.size();\\n                for (int j = k-l; j < k; j++) {\\n                    temp = new ArrayList<>(res.get(j));\\n                    temp.add(nums[i]);\\n                    res.add(temp);\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        Set<Integer> hash = new HashSet<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n;\\n        int[] nums;\\n        \\n        public void search(List<Integer> l, int p) {\\n            if (p == n) {\\n                int h = l.hashCode();\\n                if (!hash.contains(h)) {\\n                    hash.add(h);\\n                    res.add(new ArrayList<>(l));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 30315,
                "title": "c-ac-regular-backtracking-solution-for-both-subsets-i-and-ii",
                "content": "    void dfs(vector<int> &S, int start, vector<int> &output, vector<vector<int>> &result) {\\n        result.push_back(output);\\n        \\n        for (int i = start; i < S.size(); i++) {\\n            output.push_back(S[i]);\\n            dfs(S, i + 1, output, result);\\n            output.pop_back();\\n            // disable following line for subset I\\n            while (i + 1 < S.size() && S[i + 1] == S[i]) i++;\\n        }\\n    }\\n    \\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        vector<vector<int>> result;\\n        vector<int> output;\\n        \\n        if (0 == S.size()) {\\n            result.push_back(output);\\n            return result;\\n        }\\n        \\n        sort(S.begin(), S.end());\\n        dfs(S, 0, output, result);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    void dfs(vector<int> &S, int start, vector<int> &output, vector<vector<int>> &result) {\\n        result.push_back(output);\\n        \\n        for (int i = start; i < S.size(); i++) {\\n            output.push_back(S[i]);\\n            dfs(S, i + 1, output, result);\\n            output.pop_back();\\n            // disable following line for subset I\\n            while (i + 1 < S.size() && S[i + 1] == S[i]) i++;\\n        }\\n    }\\n    \\n    vector<vector<int> > subsetsWithDup(vector<int> &S) {\\n        vector<vector<int>> result;\\n        vector<int> output;\\n        \\n        if (0 == S.size()) {\\n            result.push_back(output);\\n            return result;\\n        }\\n        \\n        sort(S.begin(), S.end());\\n        dfs(S, 0, output, result);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2772818,
                "title": "subsets-ii-java-solution-2-lines-added-in-subsets-i-problem",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n        public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        \\n        if(index==nums.length)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n            while(index+1<nums.length && nums[index]==nums[index+1]){\\n                index++;\\n            }\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n        public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        \\n        if(index==nums.length)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n            while(index+1<nums.length && nums[index]==nums[index+1]){\\n                index++;\\n            }\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882468,
                "title": "simple-java-solution-based-on-backtracking-with-comments-1ms",
                "content": "**Approach:**\\nThis is a classic backtracking problem is solved using the recommened template of\\n- make a choice\\n- backtrack\\n- undo your choice\\n\\n**Caveats:**\\nThe choice to sort the array introduces `O(n log n)` complexity but the worst-case complexity for generating the subsets is already `O(2^n)`.\\nThis allows us to use sorting without any impact on overall time complexity of the solution.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // sorting our array will allow us to skip repetitions easily\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] a, int idx, List<Integer> curr, List<List<Integer>> res) {\\n        // Be careful to always add a copy of the list;\\n\\t\\t// else you would essentially be changing the same list over and over again\\n\\t\\tres.add(List.copyOf(curr));\\n        if(idx == a.length) return;\\n        \\n        for(int i=idx; i<a.length; i++) {\\n            curr.add(a[i]); // make a choice (add the number at index)\\n            backtrack(a, i+1, curr,res); // backtrack (generate dependent subsets)\\n            curr.remove(curr.size()-1); // undo your choice (remove the number)\\n            \\n            // This is the tricky part; we want to skip all the repetitions of the number\\n            while(i+1 < a.length && a[i] == a[i+1]) {\\n                i += 1;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // sorting our array will allow us to skip repetitions easily\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] a, int idx, List<Integer> curr, List<List<Integer>> res) {\\n        // Be careful to always add a copy of the list;\\n\\t\\t// else you would essentially be changing the same list over and over again\\n\\t\\tres.add(List.copyOf(curr));\\n        if(idx == a.length) return;\\n        \\n        for(int i=idx; i<a.length; i++) {\\n            curr.add(a[i]); // make a choice (add the number at index)\\n            backtrack(a, i+1, curr,res); // backtrack (generate dependent subsets)\\n            curr.remove(curr.size()-1); // undo your choice (remove the number)\\n            \\n            // This is the tricky part; we want to skip all the repetitions of the number\\n            while(i+1 < a.length && a[i] == a[i+1]) {\\n                i += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171626,
                "title": "python-solution",
                "content": "Use a dictionary to keep track of the number of appearances of each number. One can then easily construct the power set of `nums` based on this dictionary.\\n\\nE.g., `nums = [1,1,2,2,2,4,4,5]`. In this case `dic = {1:2, 2:3, 4:2, 5:1}`. We intialize `res = [[]]`, and build the solution iteratively as we loop over the dictionary. We first reach `key, val = 1, 2`. The power set of `[1,1]` is `res = [[], [1], [1,1]]`. Then we reach `key, val = 2, 3`. The power set of `[1,1,2,2,2]` is obtained by appending either `0`, `1`, `2`, or `3` 2\\'s to all elements in `res`. After which we get `res = [[], [1], [1,1], [2], [1,2], [1,1,2],[2,2], [1,2,2], [1,1,2,2],[2,2,2], [1,2,2,2], [1,1,2,2,2]]`. After we loop over `dic`, `res` will be the power set of `nums`.\\n\\nTime complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return [[]]\\n        res = [[]]\\n        dic = collections.Counter(nums)\\n        for key, val in dic.items():\\n            tmp = []\\n            for lst in res:\\n                for i in range(1, val+1):\\n                    tmp.append(lst+[key]*i)\\n            res += tmp\\n        return res\\n```\\n\\nSame idea, with a backtracking algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j == i:\\n                return [[],[nums[i]]]\\n            tail = nums[j]\\n            count = 0\\n            k = j\\n            while k >= i and nums[k] == tail:\\n                count += 1\\n                k -= 1\\n            res = helper(nums, i, k)\\n            for k in range(len(res)):\\n                for l in range(1, count+1):\\n                    res.append(res[k]+[tail]*l)\\n            return res\\n            \\n        nums = sorted(nums)\\n        return helper(nums, 0, len(nums)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return [[]]\\n        res = [[]]\\n        dic = collections.Counter(nums)\\n        for key, val in dic.items():\\n            tmp = []\\n            for lst in res:\\n                for i in range(1, val+1):\\n                    tmp.append(lst+[key]*i)\\n            res += tmp\\n        return res\\n```\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j == i:\\n                return [[],[nums[i]]]\\n            tail = nums[j]\\n            count = 0\\n            k = j\\n            while k >= i and nums[k] == tail:\\n                count += 1\\n                k -= 1\\n            res = helper(nums, i, k)\\n            for k in range(len(res)):\\n                for l in range(1, count+1):\\n                    res.append(res[k]+[tail]*l)\\n            return res\\n            \\n        nums = sorted(nums)\\n        return helper(nums, 0, len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30196,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3513086,
                "title": "c-recursive-solution-100-beat-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n\\n    void subset(int index,vector<int>&nums,vector<int>&ds,vector<vector<int>>&ans){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            ds.push_back(nums[i]);\\n            subset(i+1,nums,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,ds,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\n    void subset(int index,vector<int>&nums,vector<int>&ds,vector<vector<int>>&ans){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1]) continue;\\n            ds.push_back(nums[i]);\\n            subset(i+1,nums,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,ds,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728917,
                "title": "java-easy-to-understand-same-logic-of-subsets-1",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        HashSet<List<Integer>> res = new HashSet<>(); // No need to add duplicate subsets so hashset is used\\n        backtrack(nums,res,new ArrayList<>(),0); \\n        List<List<Integer>> ans = res.stream().map(i->i).collect(Collectors.toList()); // convert hashset to list\\n        return ans;\\n    }\\n    public void backtrack(int[] nums,HashSet<List<Integer>> res,List<Integer> list,int idx){\\n        if(idx == nums.length){\\n            List<Integer> l = new ArrayList<>(list); // new list so the orignal list does no get changed\\n            Collections.sort(l); // sorting the subsets \\n            res.add(l);\\n            return;\\n        }\\n        list.add(nums[idx]);  // number gets picked\\n        backtrack(nums,res,list,idx+1);\\n        list.remove(list.size()-1); // number does not get picked\\n        backtrack(nums,res,list,idx+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        HashSet<List<Integer>> res = new HashSet<>(); // No need to add duplicate subsets so hashset is used\\n        backtrack(nums,res,new ArrayList<>(),0); \\n        List<List<Integer>> ans = res.stream().map(i->i).collect(Collectors.toList()); // convert hashset to list\\n        return ans;\\n    }\\n    public void backtrack(int[] nums,HashSet<List<Integer>> res,List<Integer> list,int idx){\\n        if(idx == nums.length){\\n            List<Integer> l = new ArrayList<>(list); // new list so the orignal list does no get changed\\n            Collections.sort(l); // sorting the subsets \\n            res.add(l);\\n            return;\\n        }\\n        list.add(nums[idx]);  // number gets picked\\n        backtrack(nums,res,list,idx+1);\\n        list.remove(list.size()-1); // number does not get picked\\n        backtrack(nums,res,list,idx+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662559,
                "title": "java-solution-and-explanation-with-time-and-space-complexity",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        \\n        //make sure to sort the array in ascending order so that we can detect the dupicates side by side\\n        Arrays.sort(nums);\\n        \\n        //create a list of list of integer anslist to return in the end\\n        //this is the array list that will contain all the unique subsets lists\\n        ArrayList<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //Now lets call the recursion\\n        findUniqueSubSets(0, nums, new ArrayList<Integer>(), ansList);\\n        //the ArrayList<Integer>() is here because we need to return List<List<Integer>> here so \\n        //our main arrayList is ansList which we\\'ve already defined\\n        //this ArrayList<Integer>() we\\'ve defined so that we can store our individual lists here\\n        //and we\\'ll add this list to main list i.e ansList\\n        \\n        return ansList;\\n    }\\n    \\n    public void findUniqueSubSets(int ind, int[] nums, ArrayList<Integer> ds, ArrayList<List<Integer>> ansList)\\n    {\\n        //initially we add an empty list to our ansList \\n        //to generate an empty list like this -> [] \\n        ansList.add(new ArrayList<Integer>(ds));\\n        \\n        //start chking from 0th to n-1th index. using for loop\\n        for(int i = ind; i< nums.length; i++)\\n        {\\n            //chk for duplicates if any just avoid them\\n            if( i != ind && nums[i] == nums[i-1]) continue;\\n            //i != ind . ind is the first index always for which we are chking \\n            //so if i is not ind then we are not visiting that element \\n            //for the first time and might be and that might be a duplicate \\n            //which we again chk using nums[i] == nums[i-1]\\n            \\n            //if we came across this if condition that only means that we are at an element \\n            //which is not a duplicate \\n            //so we have to add it to our arryalist ds\\n            ds.add(nums[i]);\\n            \\n            //again call recursion for the next index\\n            findUniqueSubSets(i+1, nums, ds, ansList);\\n            \\n            //while returning make sure to remove the element we added because \\n            //we wouldn\\'t want that to be present for the next recursion call\\n            ds.remove(ds.size() -1);\\n                \\n        }\\n    }\\n    \\n    }\\n    \\nTime Complexity: O(k * 2^n) -> O(2^n) for generating every subset + O(k) to insert every subset in another data structure. assuming average length of each subset is near about K.\\n\\nSpace Complexity: O(2^n * k) to store every subset and the Auxiliary space is O(n) if n is the depth of the recursion tree.\\n\\nI hope you find this helpful. Please do upvote in case you understood.\\nThankss!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        \\n        //make sure to sort the array in ascending order so that we can detect the dupicates side by side\\n        Arrays.sort(nums);\\n        \\n        //create a list of list of integer anslist to return in the end\\n        //this is the array list that will contain all the unique subsets lists\\n        ArrayList<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //Now lets call the recursion\\n        findUniqueSubSets(0, nums, new ArrayList<Integer>(), ansList);\\n        //the ArrayList<Integer>() is here because we need to return List<List<Integer>> here so \\n        //our main arrayList is ansList which we\\'ve already defined\\n        //this ArrayList<Integer>() we\\'ve defined so that we can store our individual lists here\\n        //and we\\'ll add this list to main list i.e ansList\\n        \\n        return ansList;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1380340,
                "title": "c-standard-backtracking-template",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void backtrack(vector<int>& nums, vector<int> temp, int idx) {\\n        result.push_back(temp);\\n        if(idx >= nums.size())\\n            return;\\n        \\n        for(int i = idx; i<nums.size(); i++) {\\n            if(i > idx && nums[i] == nums[i-1]) continue; //avoid duplicates\\n            \\n            temp.push_back(nums[i]);     //include\\n            backtrack(nums, temp, i+1);  //explore\\n            temp.pop_back();             //exclude\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        result.clear();\\n        \\n        vector<int> temp;\\n        sort(begin(nums), end(nums)); //will help avoiding duplicates\\n        backtrack(nums, temp, 0);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void backtrack(vector<int>& nums, vector<int> temp, int idx) {\\n        result.push_back(temp);\\n        if(idx >= nums.size())\\n            return;\\n        \\n        for(int i = idx; i<nums.size(); i++) {\\n            if(i > idx && nums[i] == nums[i-1]) continue; //avoid duplicates\\n            \\n            temp.push_back(nums[i]);     //include\\n            backtrack(nums, temp, i+1);  //explore\\n            temp.pop_back();             //exclude\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        result.clear();\\n        \\n        vector<int> temp;\\n        sort(begin(nums), end(nums)); //will help avoiding duplicates\\n        backtrack(nums, temp, 0);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217790,
                "title": "simple-c-solution-with-explanation-easiest-way-to-remove-duplicates-not-using-sets",
                "content": "To get all the subsets, for each element in the array, we have 2 choices \\nEither include it in subset or not.\\nJust need to improve on that approach to **remove duplicates**, which can be done easily by just making sure that if the last element in our present subset is equal to our present element, then you have to surely include present element in the subset , i.e, dont skip the present element.\\nThe subset which will form if we don\\'t include the present element will lead to duplicacy.\\nBasically :\\n```\\nif nums[posn] = subset.back() //  subset.back() = last element in our present subset\\n\\t\\tnext recursion call after including nums[posn] in the subset\\nelse \\t\\n\\t\\t1. recursion call without including present element\\n\\t\\t2. recursion call after including present element\\n\\t\\t\\n```\\n###  C++ code \\n```\\nclass Solution {\\n    // Final 2d array/vector to hold the answer\\n    vector<vector<int>> ans;\\npublic:\\n    void fun(vector<int> nums,int n,vector<int> v,int i=0)\\n    {\\n        // when posn reaches the end of the input array, insert the present vector in to ans.     \\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        /* when present element is not equal to last element in vector,\\n        then only skip the                  \\n        present element */    \\n        if(v.empty()||v.back()!=nums[i])\\n        {\\n            fun(nums,n,v,i+1);\\n        }\\n        /* add the present element to the present subset and call for the remaining array */\\n        v.push_back(nums[i]);\\n        fun(nums,n,v,i+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> v;\\n        // Sort the input array so that all duplicate elements are together.\\n        sort(nums.begin(),nums.end());\\n        \\n        fun(nums,nums.size(),v);\\n        \\n        return ans;\\n    }\\n};\\n```\\nps:- try to make the recursion tree for an example test case ( [1,2,2] ) to understand it better.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nif nums[posn] = subset.back() //  subset.back() = last element in our present subset\\n\\t\\tnext recursion call after including nums[posn] in the subset\\nelse \\t\\n\\t\\t1. recursion call without including present element\\n\\t\\t2. recursion call after including present element\\n\\t\\t\\n```\n```\\nclass Solution {\\n    // Final 2d array/vector to hold the answer\\n    vector<vector<int>> ans;\\npublic:\\n    void fun(vector<int> nums,int n,vector<int> v,int i=0)\\n    {\\n        // when posn reaches the end of the input array, insert the present vector in to ans.     \\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        /* when present element is not equal to last element in vector,\\n        then only skip the                  \\n        present element */    \\n        if(v.empty()||v.back()!=nums[i])\\n        {\\n            fun(nums,n,v,i+1);\\n        }\\n        /* add the present element to the present subset and call for the remaining array */\\n        v.push_back(nums[i]);\\n        fun(nums,n,v,i+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> v;\\n        // Sort the input array so that all duplicate elements are together.\\n        sort(nums.begin(),nums.end());\\n        \\n        fun(nums,nums.size(),v);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726404,
                "title": "java-backtracking-easy-to-understand-explanation",
                "content": "\\n```\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> resultList=new ArrayList();\\n        Arrays.sort(nums);\\n        backTrack(resultList,new ArrayList(),nums,0);\\n        return resultList;\\n    }\\n    \\n    private void backTrack(List<List<Integer>> resultList, List<Integer> currentList, int []nums, int start) {\\n\\t    resultList.add(new ArrayList(currentList));\\n        for(int i=start;i<nums.length;i++)  {\\n            if(i>start&&nums[i]==nums[i-1]) continue; // to avoid duplicates\\n            currentList.add(nums[i]);\\n            backTrack(resultList,currentList,nums,i+1);\\n            currentList.remove(currentList.size()-1);\\n        }\\n    }\\n}\\n```\\nIf you can follow the Numbers and the arrows you will get the idea \\nif you didn\\'t understand any point let me know and will try to explain it again\\n\\n![image](https://assets.leetcode.com/users/images/d81b304b-f002-4049-a57b-d0513f8f714b_1594493500.5942798.png)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> resultList=new ArrayList();\\n        Arrays.sort(nums);\\n        backTrack(resultList,new ArrayList(),nums,0);\\n        return resultList;\\n    }\\n    \\n    private void backTrack(List<List<Integer>> resultList, List<Integer> currentList, int []nums, int start) {\\n\\t    resultList.add(new ArrayList(currentList));\\n        for(int i=start;i<nums.length;i++)  {\\n            if(i>start&&nums[i]==nums[i-1]) continue; // to avoid duplicates\\n            currentList.add(nums[i]);\\n            backTrack(resultList,currentList,nums,i+1);\\n            currentList.remove(currentList.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124257,
                "title": "javascript-68-ms-98-88",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n        \\n    nums = nums.sort((a,b) => a-b);\\n    \\n    const res = [];\\n    \\n    function fn(length, start=0, arr = []) {\\n        if (arr.length === length) {\\n            res.push(arr.slice());\\n            return;\\n        }\\n        for(let i=start; i<nums.length; i++) {       \\n            if (i !== start && nums[i-1] === nums[i]) continue;\\n            arr.push(nums[i]);\\n            fn(length, i+1, arr);\\n            arr.pop();            \\n        }\\n    }\\n    \\n    for(let length=0; length<=nums.length; length++) {\\n        fn(length);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n        \\n    nums = nums.sort((a,b) => a-b);\\n    \\n    const res = [];\\n    \\n    function fn(length, start=0, arr = []) {\\n        if (arr.length === length) {\\n            res.push(arr.slice());\\n            return;\\n        }\\n        for(let i=start; i<nums.length; i++) {       \\n            if (i !== start && nums[i-1] === nums[i]) continue;\\n            arr.push(nums[i]);\\n            fn(length, i+1, arr);\\n            arr.pop();            \\n        }\\n    }\\n    \\n    for(let length=0; length<=nums.length; length++) {\\n        fn(length);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30146,
                "title": "c-subsets-and-subsets-ii-almost-same-recursive-method",
                "content": "Subset\\n```\\nclass Solution{\\npublic:\\n\\tvector<vector<int>> subsets(vector<int>& nums){\\n\\t\\tvector<vector<int>> res;\\n\\t\\tsubsets(res,nums,0,vector<int>());\\n\\t\\treturn res;\\n\\n\\t}\\n\\tvoid subsets(vector<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n\\t\\t\\tres.push_back(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t}\\n};\\n```\\nSubset 2\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        subset(res,nums,vector<int>(),0);\\n        return res;\\n    }\\n    void subset(vector<vector<int>>& res,const vector<int>& nums,vector<int> temp,int pos){\\n        if(pos>=nums.size()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        int cnt=0;\\n        while(pos+cnt<nums.size()&&nums[pos]==nums[pos+cnt]){\\n            cnt++;\\n        }\\n        subset(res,nums,temp,pos+cnt);\\n        for(int i=1;i<=cnt;++i){\\n            temp.push_back(nums[pos]);\\n            subset(res,nums,temp,pos+cnt);\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\npublic:\\n\\tvector<vector<int>> subsets(vector<int>& nums){\\n\\t\\tvector<vector<int>> res;\\n\\t\\tsubsets(res,nums,0,vector<int>());\\n\\t\\treturn res;\\n\\n\\t}\\n\\tvoid subsets(vector<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n\\t\\t\\tres.push_back(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tsubsets(res,nums,pos+1,temp);\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        subset(res,nums,vector<int>(),0);\\n        return res;\\n    }\\n    void subset(vector<vector<int>>& res,const vector<int>& nums,vector<int> temp,int pos){\\n        if(pos>=nums.size()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        int cnt=0;\\n        while(pos+cnt<nums.size()&&nums[pos]==nums[pos+cnt]){\\n            cnt++;\\n        }\\n        subset(res,nums,temp,pos+cnt);\\n        for(int i=1;i<=cnt;++i){\\n            temp.push_back(nums[pos]);\\n            subset(res,nums,temp,pos+cnt);\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30202,
                "title": "c-6ms-dp-clean-code-explanation",
                "content": "C++, 6ms: DP, Simple & Clean Code\\n**Time:** O(n*2^n)\\n**Space:** O(2^n)\\n\\n**Solution:**\\n```\\nvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\n    vector<vector<int>> r;\\n    r.push_back(vector<int>());\\n    int prev = 1; \\n    \\n    for(int i = 0; i < nums.size(); ++i){\\n        int n = r.size();\\n        int start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n        \\n        prev = 0;\\n        for(int j = start; j < n; ++j){\\n            r.push_back(r[j]);\\n            r.back().push_back(nums[i]);\\n            ++prev;\\n        }\\n    }\\n    \\n    return r;\\n}\\n```\\n\\n**Explanation:**\\n\\nI will first show you how the algorithm works with an input array containing no duplication.\\n\\nFor example, Input: `[1, 2, 3]`\\n\\nWe first add the empty set to the result.\\nThen, for each number in the input, we will concatenate the current number with all the previous results to generate a new set. \\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 3]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 3]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1,2]\\n\\n[1, 2, 3]\\n       ^\\n4th Round: [].push_back(3), [1].push_back(3), [2].push_back(3), [1, 2].push_back(3)\\nSets generated: [3], [1, 3], [2, 3], [1, 2, 3]\\n```\\nThen, ` { [ ], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] } ` is our answer.\\n\\nNow, let's take a look at an example with duplication.\\nFor example, Input: `[1, 2, 2]`\\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [].push_back(2), [1].push_back(2), [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2], [1, 2], [2, 2], [1, 2, 2]\\n```\\n\\nYou can observe that the first 2 sets generated in the 4th round are duplication of 3rd round's sets.\\nTo fix this problem, we will need to remember how many items were added to our solution which was 2.\\nThen, we can avoid using [ ], [1] which were used in the 3rd round to generate those 2 sets.\\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2, 2], [1, 2, 2]\\n```\\n\\nNow, you should be able to understand this part of the code.\\n```\\nint start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n```\\nDon't forget to sort the input array first, otherwise `nums[i] != nums[i-1]` comparison just does not make sense.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\n    vector<vector<int>> r;\\n    r.push_back(vector<int>());\\n    int prev = 1; \\n    \\n    for(int i = 0; i < nums.size(); ++i){\\n        int n = r.size();\\n        int start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n        \\n        prev = 0;\\n        for(int j = start; j < n; ++j){\\n            r.push_back(r[j]);\\n            r.back().push_back(nums[i]);\\n            ++prev;\\n        }\\n    }\\n    \\n    return r;\\n}\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 3]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 3]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1,2]\\n\\n[1, 2, 3]\\n       ^\\n4th Round: [].push_back(3), [1].push_back(3), [2].push_back(3), [1, 2].push_back(3)\\nSets generated: [3], [1, 3], [2, 3], [1, 2, 3]\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [].push_back(2), [1].push_back(2), [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2], [1, 2], [2, 2], [1, 2, 2]\\n```\n```\\nBegin\\n1st Round: []\\n\\n[1, 2, 2]\\n ^\\n2nd Round: [].push_back(1)\\nSets generated: [1]\\n\\n[1, 2, 2]\\n    ^\\n3rd Round: [].push_back(2), [1].push_back(2)\\nSets generated: [2], [1, 2]\\n\\n[1, 2, 2]\\n       ^\\n4th Round: [2].push_back(2), [1, 2].push_back(2)\\nSets generated: [2, 2], [1, 2, 2]\\n```\n```\\nint start = (i == 0 || (i > 0 && nums[i] != nums[i-1]) ? 0 : (n - prev));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742710,
                "title": "python3-simple-recursive-solution",
                "content": "# Intuition\\nThe intuition behind the code is to use a recursive approach to generate subsets. At each step, we have two choices: either include the current element in the subset or exclude it. By making these choices for each element in the array, we can generate all possible subsets.\\n\\n# Approach\\n**Sort the array nums** \\nSorting the array ensures that duplicate elements will appear next to each other, making it easier to handle them later in the code.\\n\\n**Create the recursive function subsets** \\nThis function takes two parameters: index (the current index being considered) and elements (the current subset being constructed).\\n\\n**Handle base case** \\nIf the current index reaches the length of the array (index == len(nums)), it means we have processed all elements. At this point, we check if the elements subset is already present in the res list. If not, we append it to res. This check is necessary to avoid duplicate subsets.\\n\\n**Make recursive calls**\\n**Not Pick**\\nCall subsets recursively with the next index without picking the current element (subsets(index + 1, elements)). This represents the choice of excluding the current element from the subset.\\n**Pick**\\nCall subsets recursively with the next index, including the current element (subsets(index + 1, elements + [nums[index]])). This represents the choice of picking the current element and adding it to the subset.\\n\\n**Duplicate Check**\\nThe code avoids duplicates by checking if a subset already exists in the res list before appending it. We sort the input array in the start to ensure that duplicate elements will be adjacent, simplifying the duplicate check.\\n\\nNow, we call the subsets function initially with index = 0 and an empty elements list.\\n\\nFinally, we return the final res list containing all the generated subsets.\\n\\n# Complexity\\n- Time complexity: **O(2^n)** \\n\\n- Space complexity: **O(2^n)** \\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def subsets(index, elements):\\n            # base case\\n            if index == len(nums):\\n                res.append(elements) if elements not in res else None\\n                return\\n\\n            subsets(index + 1, elements) # not pick\\n            subsets(index + 1, elements + [nums[index]]) # pick\\n\\n        subsets(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def subsets(index, elements):\\n            # base case\\n            if index == len(nums):\\n                res.append(elements) if elements not in res else None\\n                return\\n\\n            subsets(index + 1, elements) # not pick\\n            subsets(index + 1, elements + [nums[index]]) # pick\\n\\n        subsets(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596532,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n*k)$$ --> k is average length of every subset\\n\\n- Space complexity:\\n$$O(2^n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        ans.push_back(temp);\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx && nums[i] == nums[i-1])\\n                continue;\\n            temp.push_back(nums[i]);\\n            subsetHelper(i+1, nums, n, temp, ans);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        ans.push_back(temp);\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx && nums[i] == nums[i-1])\\n                continue;\\n            temp.push_back(nums[i]);\\n            subsetHelper(i+1, nums, n, temp, ans);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070879,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // vector<vector<int>>ans;\\n    void f(set<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\tres.insert(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tf(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tf(res,nums,pos+1,temp);\\n        temp.pop_back();\\n\\t}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n=nums.size();\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        f(res,nums,0,temp);\\n        vector<vector<int>>ans;\\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // vector<vector<int>>ans;\\n    void f(set<vector<int>>& res,const vector<int>& nums,int pos,vector<int> temp){\\n\\t\\tif(pos==nums.size()){\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\tres.insert(temp);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tf(res,nums,pos+1,temp);\\n\\t\\ttemp.push_back(nums[pos]);\\n\\t\\tf(res,nums,pos+1,temp);\\n        temp.pop_back();\\n\\t}\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n=nums.size();\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        f(res,nums,0,temp);\\n        vector<vector<int>>ans;\\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506092,
                "title": "java-concise-4-solutions-0-ms-100-beats",
                "content": "**1. Regular recursion**\\n```\\n// Each recursion level focuses on all the following elements.\\n// We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subsets(nums, 0, new LinkedList<>(), result);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, int start, LinkedList<Integer> set, List<List<Integer>> sets) {\\n        sets.add(new ArrayList(set));\\n        for(int i=start; i<nums.length; i++) {\\n            // If candidate[i] equals candidate[i-1], then solutions for i is subset of solution of i-1\\n            // Refer: https://leetcode.com/problems/combination-sum-ii/discuss/16861/Java-solution-using-dfs-easy-understand/977097\\n            if (i==start || (i>start && nums[i] != nums[i-1])) {\\n                set.addLast(nums[i]);\\n                // \\'i+1\\' (not \\'i\\') because can\\'t reuse same element to help avoid duplicate subsets\\n                subsets(nums, i+1, set, sets);\\n                set.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\\n**2. Optimized recursion**\\n```\\n// Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\t    // Sort to assist check for adjacent elements to avoid duplicates\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        subsetsWithDup(res, new ArrayList<>(), nums, 0, false);\\n        return res;\\n    }\\n\\n    public void subsetsWithDup(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n\\t    // Update result with new set when all elements evaluated\\n        if(pos == nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        subsetsWithDup(res, ls, nums, pos+1, false);\\n\\t\\t// If previous is same and not chosen, then we can end up in duplicate set, hence skip\\n        if(pos>=1 && nums[pos]==nums[pos-1] && !choosePre) return;\\n        ls.add(nums[pos]);\\n        subsetsWithDup(res, ls, nums, pos+1, true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```\\n3. **Using Bit mask for set generation. Using sort (with hashset) for deduplication**\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use hashset + sort to avoid duplicates\\n        Set<List<Integer>> sets = new HashSet<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                if((1 & (i>>j)) == 1) {\\n                    set.add(nums[j]);\\n                }\\n            }\\n            sets.add(set);\\n        }\\n        return new ArrayList<>(sets);\\n    }\\n}\\n```\\n4. **Using Bit mask for set generation. Using sort (without hashset) for deduplication**\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use sort + repeated element check to avoid duplicates\\n        List<List<Integer>> sets = new ArrayList<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            boolean duplicateSet = false;\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                // If jth element needs to be picked\\n                if ((1 & (i>>j)) == 1) {\\n                    // After we sort the array, the same number will be adjacent to each other.\\n                    // For example the set is {1,1,1}. We can get subset {} and {1} first. That\\'s great.\\n                    // Now, suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate.\\n                    if (j==0 || (j>0 && (nums[j] != nums[j-1] || (1 & (i>>(j-1))) == 1))) {\\n                        set.add(nums[j]);\\n                    } else {\\n                        duplicateSet = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!duplicateSet) {\\n                sets.add(set);\\n            }\\n        }\\n        return sets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Combinatorics"
                ],
                "code": "```\\n// Each recursion level focuses on all the following elements.\\n// We scan through all the following elements and decide whether to choose or not choose that element. (Every level split into N branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        subsets(nums, 0, new LinkedList<>(), result);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, int start, LinkedList<Integer> set, List<List<Integer>> sets) {\\n        sets.add(new ArrayList(set));\\n        for(int i=start; i<nums.length; i++) {\\n            // If candidate[i] equals candidate[i-1], then solutions for i is subset of solution of i-1\\n            // Refer: https://leetcode.com/problems/combination-sum-ii/discuss/16861/Java-solution-using-dfs-easy-understand/977097\\n            if (i==start || (i>start && nums[i] != nums[i-1])) {\\n                set.addLast(nums[i]);\\n                // \\'i+1\\' (not \\'i\\') because can\\'t reuse same element to help avoid duplicate subsets\\n                subsets(nums, i+1, set, sets);\\n                set.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\n```\\n// Each recursion level focuses on one element, we need to decide choose or not choose this element. (Every level split into 2 branches.)\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\t    // Sort to assist check for adjacent elements to avoid duplicates\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        subsetsWithDup(res, new ArrayList<>(), nums, 0, false);\\n        return res;\\n    }\\n\\n    public void subsetsWithDup(List<List<Integer>> res, List<Integer> ls, int[] nums, int pos, boolean choosePre) {\\n\\t    // Update result with new set when all elements evaluated\\n        if(pos == nums.length) {\\n            res.add(new ArrayList<>(ls));\\n            return;\\n        }\\n        subsetsWithDup(res, ls, nums, pos+1, false);\\n\\t\\t// If previous is same and not chosen, then we can end up in duplicate set, hence skip\\n        if(pos>=1 && nums[pos]==nums[pos-1] && !choosePre) return;\\n        ls.add(nums[pos]);\\n        subsetsWithDup(res, ls, nums, pos+1, true);\\n        ls.remove(ls.size()-1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use hashset + sort to avoid duplicates\\n        Set<List<Integer>> sets = new HashSet<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                if((1 & (i>>j)) == 1) {\\n                    set.add(nums[j]);\\n                }\\n            }\\n            sets.add(set);\\n        }\\n        return new ArrayList<>(sets);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        // Get possible sets\\n        int possibleSets = 1<<nums.length;\\n        // Use sort + repeated element check to avoid duplicates\\n        List<List<Integer>> sets = new ArrayList<>();\\n        Arrays.sort(nums);\\n        // Pick a set to fill\\n        for (int i=0; i<possibleSets; i++) {\\n            List<Integer> set = new ArrayList<>();\\n            boolean duplicateSet = false;\\n            // Fill with nums[j] if the bit corresponding to the jth index in i is set\\n            for (int j=0; j<nums.length; j++) {\\n                // If jth element needs to be picked\\n                if ((1 & (i>>j)) == 1) {\\n                    // After we sort the array, the same number will be adjacent to each other.\\n                    // For example the set is {1,1,1}. We can get subset {} and {1} first. That\\'s great.\\n                    // Now, suppose we have a subset x, which including the second 1 but not the first 1, x is a duplicate.\\n                    if (j==0 || (j>0 && (nums[j] != nums[j-1] || (1 & (i>>(j-1))) == 1))) {\\n                        set.add(nums[j]);\\n                    } else {\\n                        duplicateSet = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!duplicateSet) {\\n                sets.add(set);\\n            }\\n        }\\n        return sets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380488,
                "title": "c-easy-clean-solution-using-vector-set-and-multiset",
                "content": "**Solution:**\\n\\n1. Consider every subsequence as a collection of `bits`.\\n2. 0, 1, 10, 11, 100, 101, 110, 111, and so on.\\n3. We can observe that every `set bit(1)` indicates that we must include that particular element present in the array `nums` and every `unset bit(0)` indicates we must ignore that element.\\n4. Check for every number which particular bit is set or unset using `i & (1 << j)`. This formula helps us to know whether to include a particular element or not.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        int s = 1 << n;\\n        set<multiset<int>> ans;\\n        for(int i = 0; i < s; i++){\\n            multiset<int> temp;\\n            for(int j = 0; j < n; j++){\\n                if(i & (1 << j))\\n                    temp.insert(nums[j]);\\n            }\\n            ans.insert(temp);\\n        }\\n        vector<vector<int>> res;\\n        for(auto i: ans){\\n            multiset<int> temp = i;\\n            vector<int> set_to_vec{temp.begin(), temp.end()};\\n            res.push_back(set_to_vec);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int n = nums.size();\\n        int s = 1 << n;\\n        set<multiset<int>> ans;\\n        for(int i = 0; i < s; i++){\\n            multiset<int> temp;\\n            for(int j = 0; j < n; j++){\\n                if(i & (1 << j))\\n                    temp.insert(nums[j]);\\n            }\\n            ans.insert(temp);\\n        }\\n        vector<vector<int>> res;\\n        for(auto i: ans){\\n            multiset<int> temp = i;\\n            vector<int> set_to_vec{temp.begin(), temp.end()};\\n            res.push_back(set_to_vec);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859563,
                "title": "python-sort-bfs-approach-without-additional-space",
                "content": "Hello,\\n\\nThis solution is similar to the subset I problem solution. The explaination is below.\\n\\n\\n```python\\n\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n\\t\\t# 1. Sort nums:\\n        nums.sort()\\n        \\n\\t\\t# 2. Find all subsets:\\n        combinations = [[]]\\n        combinations_len = 1\\n        for i in range(len(nums)):\\n            \\n\\t\\t\\t# If duplicate, start from the new items appended by the previous val\\n            start = combinations_len if i and nums[i] == nums[i - 1] else 0\\n\\t\\t\\t\\n            combinations_len = len(combinations)            \\n            for c in range(start, combinations_len):\\n                combinations.append(combinations[c] + [nums[i]])\\n                \\n        return combinations\\n\\n```\\n\\n1- Intuition:\\n- Subset problem (without duplicates):\\n\\t- Let\\'s have the following input: [1,2,3] and let\\'s `combinations` be our output\\n\\t- We\\'ll start with `combinations = [[]]`\\n\\t- For each value `n` in `nums`, merge it with every existing `combination` and append it to the output list\\n\\t- For `n: 1`:  append( `[] + [1]`)  into `combinations = [[], [1]]`\\n\\t- For `n: 2`:  append( `[] + [2]`, `[1] + [2]`)  into `combinations = [[], [1], [2], [1,2]]`\\n\\t- For `n: 3`:  append( `[] + [3]`, `[1] + [3]`, `[2] + [3]`, `[1,2] + [3]` )  into `combinations = [[], [1], [2], [1,2], [1,2,3]]`\\n\\n- Subset II problem (with duplicates):\\n\\t- It\\'s the same solution as the solution above. We just need to:\\n\\t\\t- (1). Identify duplicates => Sort `nums`\\n\\t\\t- (2). We need to avoid looping on all combinations when dealing with a duplicate. \\n\\t\\t- We need to start from a specific position of the list `combinations`\\n\\t- Let\\'s have the following input: [1,2,2,3,3] and suppose that it\\'s already sorted\\n\\t- For the `1st. n: 2`:  `combinations = [[], [1], [2], [1,2]]`\\n\\t- For the `2nd. n: 2`:  \\n\\t\\t- We need to avoid the existing combinations `[] + [2]`, `[1] + [2]` \\n\\t\\t- We need to consider only `[2] + [2]` and `[1,2] + [2]`\\n\\t\\t- In other words, we need to start from the combinations appended by previous `n: 2` \\n\\t\\t- `combinations = [[], [1], [2], [1,2], [2, 2], [1,2,2]]`\\n\\t- For the `1st. n: 3`:  `combinations = [[], [1], [2], [1,2], [2, 2], [1,2,2], [3], [1,3], [2,3], [1,2,3], [2,2,3],[1,2,2,3]]`\\n\\t- For the `2nd. n:3`\\n\\t\\t- We need to start from the combinations appended by previous `n: 3`: position: 6\\n\\t\\t- We\\'ll then append: `[3] + [3], [1,3] + [3] , ...,  [1,2,2,3] + [3]`\\n\\n2- Complexity Analysis:\\n- Let\\'s `n` be the number of values in `nums`\\n- Time Complexity: `O(n * 2^n)`\\n\\t\\t- The output `combinations` doubles for every value in `nums`: `O(2^n)` combinations (including duplicates)\\n\\t\\t- Every combination is created from merging a previous combination with a value: T(merge): `O(n)`\\n- Space Complexity: `O(n * 2^n)` (same as above)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\n\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n\\t\\t# 1. Sort nums:\\n        nums.sort()\\n        \\n\\t\\t# 2. Find all subsets:\\n        combinations = [[]]\\n        combinations_len = 1\\n        for i in range(len(nums)):\\n            \\n\\t\\t\\t# If duplicate, start from the new items appended by the previous val\\n            start = combinations_len if i and nums[i] == nums[i - 1] else 0\\n\\t\\t\\t\\n            combinations_len = len(combinations)            \\n            for c in range(start, combinations_len):\\n                combinations.append(combinations[c] + [nums[i]])\\n                \\n        return combinations\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 377184,
                "title": "easy-peasy-python-comments-best-iterative-solution",
                "content": "\\t# pos dict helps to prevent duplicates\\n\\t# frm = position in res(result) from where I have to start adding the current num\\n\\t# to understand this code, first take example of [1,2,3], and then [1,2,2]\\n\\t# Basically, I add my current num to the all the lists already in the result\\n\\t# however to prevent duplicates, I note down the position of the result where I start adding my num\\n\\t# and next time when I see a duplicate I start from the position from where I added my first duplicate element instead from 0th position of the result \\n\\t\\n\\t\\n\\tdef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res, pos, nums = [[]], {}, sorted(nums)\\n        for n in nums:\\n            frm, ln = pos.get(n, 0), len(res)\\n            for ls in res[frm:]:\\n                res.append(ls + [n])\\n            pos[n] = ln\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "\\t# pos dict helps to prevent duplicates\\n\\t# frm = position in res(result) from where I have to start adding the current num\\n\\t# to understand this code, first take example of [1,2,3], and then [1,2,2]\\n\\t# Basically, I add my current num to the all the lists already in the result\\n\\t# however to prevent duplicates, I note down the position of the result where I start adding my num\\n\\t# and next time when I see a duplicate I start from the position from where I added my first duplicate element instead from 0th position of the result \\n\\t\\n\\t\\n\\tdef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res, pos, nums = [[]], {}, sorted(nums)\\n        for n in nums:\\n            frm, ln = pos.get(n, 0), len(res)\\n            for ls in res[frm:]:\\n                res.append(ls + [n])\\n            pos[n] = ln\\n            \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 30322,
                "title": "my-solution-using-bit-masks",
                "content": "Here is my solution using bit masks.\\n\\n    public class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        //Sort the input\\n        Arrays.sort(num);\\n        int numberSets = 1 << num.length;\\n        List<List<Integer>> solution = new LinkedList<>();\\n        for(int i = 0; i<numberSets; i++){\\n            List<Integer> subset = new LinkedList<Integer>();\\n            for(int j = 0; j< num.length; j++){\\n                if((i & (1 << j)) > 0){\\n                    subset.add(num[j]);\\n                }\\n            }\\n            if(!solution.contains(subset))\\n                solution.add(subset);\\n        }\\n        \\n        return solution;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] num) {\\n        //Sort the input\\n        Arrays.sort(num);\\n        int numberSets = 1 << num.length;\\n        List<List<Integer>> solution = new LinkedList<>();\\n        for(int i = 0; i<numberSets; i++){\\n            List<Integer> subset = new LinkedList<Integer>();\\n            for(int j = 0; j< num.length; j++){\\n                if((i & (1 << j)) > 0){\\n                    subset.add(num[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3683856,
                "title": "c-well-commented-backtracking-faster-than-100-c-submissions",
                "content": "# Complexity\\n- Time complexity: $$O(2^N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& ans, vector<int>& nums, vector<int>& curr, int index) {\\n        ans.push_back(curr);  // Add current subset to the answer vector\\n\\n        // Generate subsets by including elements starting from the given index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Skip duplicate elements to avoid generating duplicate subsets\\n            if (i != index && nums[i] == nums[i - 1])\\n                continue;\\n\\n            curr.push_back(nums[i]);  // Include the current element in the current subset\\n            backTrack(ans, nums, curr, i + 1);\\n            curr.pop_back();  // Remove the current element to backtrack\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;  // Vector to store the current subset\\n\\n        backTrack(ans, nums, curr, 0);\\n        return ans\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& ans, vector<int>& nums, vector<int>& curr, int index) {\\n        ans.push_back(curr);  // Add current subset to the answer vector\\n\\n        // Generate subsets by including elements starting from the given index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Skip duplicate elements to avoid generating duplicate subsets\\n            if (i != index && nums[i] == nums[i - 1])\\n                continue;\\n\\n            curr.push_back(nums[i]);  // Include the current element in the current subset\\n            backTrack(ans, nums, curr, i + 1);\\n            curr.pop_back();  // Remove the current element to backtrack\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;  // Vector to store the current subset\\n\\n        backTrack(ans, nums, curr, 0);\\n        return ans\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631632,
                "title": "100-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(i>=n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        tmp.push_back(v[i]);\\n        solve(i+1,n,v,tmp,ans); \\n        tmp.pop_back();\\n        while(i+1<n&&v[i+1]==v[i])i++;\\n        solve(i+1,n,v,tmp,ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        solve(0,n,nums,tmp,ans);\\n        // sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(i>=n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        tmp.push_back(v[i]);\\n        solve(i+1,n,v,tmp,ans); \\n        tmp.pop_back();\\n        while(i+1<n&&v[i+1]==v[i])i++;\\n        solve(i+1,n,v,tmp,ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        solve(0,n,nums,tmp,ans);\\n        // sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361683,
                "title": "easy-clear-solution-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            self.backtracking(res,i+1,subset+[nums[i]],nums)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            if i > start and nums[i] == nums[i-1]:\\n                continue\\n            self.backtracking(res,i+1,subset+[nums[i]],nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346713,
                "title": "easy-to-understand-efficient-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we need to make subsets so for each element \"Pick\" and \"Not Pick\" decision needs to be taken. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe entire approach is same as Subset I. \\n\\n- Just when we are about to not pick an element we need to not pick all the similar elements and increase the index \\'i\\'.\\n\\nAnd this job is done by the following code block -->\\n```\\nwhile(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n*O(2^n)*\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n*O(n^2)*\\n\\nMy Subset I solution link \\uD83D\\uDC47\\nhttps://leetcode.com/problems/subsets/solutions/3342538/100-beats-used-backtracking-efficient-c-code/\\nPlease upvote if you find it helpful \\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int i,vector<int>&nums,vector<int>&temp){\\n        if(i==nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[i]);\\n        help(i+1,nums,temp);\\n        \\n        temp.pop_back();\\n        while(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        help(i+1,nums,temp);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>temp;\\n        sort(nums.begin(),nums.end());\\n        help(0,nums,temp);\\n        //sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int i,vector<int>&nums,vector<int>&temp){\\n        if(i==nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[i]);\\n        help(i+1,nums,temp);\\n        \\n        temp.pop_back();\\n        while(i+1 <nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        help(i+1,nums,temp);\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>temp;\\n        sort(nums.begin(),nums.end());\\n        help(0,nums,temp);\\n        //sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217062,
                "title": "easy-c-solution-with-loop-and-backtracking-o-n-unique",
                "content": "# INTUITION \\nAs we have solved the question of finding subsets, here we will use similar approach to find the subsets for this question. make an array of all subsets and then **remove duplicates using inbuilt functions**\\n# APPROACH\\n1.  We are using here recursive technique. so firstly declare two vector ... one for answer and other as auxillary one.\\n2.  make a recursive function **solve** which will give all subsets recursively \\n3. **parameters for solve function** - answer vector, output vector, input vector and index for traversing.\\n4. HERE, we will play exclude and include game, in excluding step, just increase the index by 1.\\n5. for include, first we extract the elements from input vector and insert in the output vector ......and then make a recursive call.\\n6. when the **base case(index>= nums.size())** is reached, insert the output vector in answer vector and return.\\n\\n# COMPLEXITY\\n**TIME COMPLEXITY**-  overall is O(N)\\n**SPACE COMPLEXITY**- O(N)\\n```\\nclass Solution {\\npublic:\\n    void solve(vector <int> nums, vector<int> temp, int index, vector<vector<int>>& ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        solve(nums, temp, index+1, ans);\\n        \\n        int key = nums[index];\\n        temp.push_back(key);\\n        solve( nums, temp, index+1, ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector <int> temp;\\n        solve(nums, temp, 0, ans);\\n        sort(ans.begin(), ans.end());\\n        \\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector <int> nums, vector<int> temp, int index, vector<vector<int>>& ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        solve(nums, temp, index+1, ans);\\n        \\n        int key = nums[index];\\n        temp.push_back(key);\\n        solve( nums, temp, index+1, ans);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector <int> temp;\\n        solve(nums, temp, 0, ans);\\n        sort(ans.begin(), ans.end());\\n        \\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654821,
                "title": "c-backtracking-set-3ms",
                "content": "**Runtime:** 3 ms, faster than 73.08% of C++ online submissions for Subsets II.\\n**Memory Usage:** 7.8 MB, less than 54.76% of C++ online submissions for Subsets II.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> curr;\\n        vector<vector<int>> ret;\\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(ans, curr, nums, 0);\\n        ret.assign(ans.begin(), ans.end());\\n        return ret;\\n    }\\n    void backtrack(set<vector<int>>& ans, vector<int>& curr, vector<int>& nums, int pos) {\\n        if(pos == nums.size()) {\\n            ans.insert(curr);\\n            return;\\n        }\\n        curr.push_back(nums[pos]);\\n        backtrack(ans, curr, nums, pos + 1);\\n        curr.pop_back();\\n        backtrack(ans, curr, nums, pos + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> curr;\\n        vector<vector<int>> ret;\\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(ans, curr, nums, 0);\\n        ret.assign(ans.begin(), ans.end());\\n        return ret;\\n    }\\n    void backtrack(set<vector<int>>& ans, vector<int>& curr, vector<int>& nums, int pos) {\\n        if(pos == nums.size()) {\\n            ans.insert(curr);\\n            return;\\n        }\\n        curr.push_back(nums[pos]);\\n        backtrack(ans, curr, nums, pos + 1);\\n        curr.pop_back();\\n        backtrack(ans, curr, nums, pos + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487304,
                "title": "aditya-verma-s-approach-simple-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    \\n    void solve(vector<int>input, vector<int>output){\\n        \\n        if(input.size() == 0){\\n            \\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            \\n            return;\\n        }\\n        \\n        vector<int>op1 = output, op2 = output;\\n        \\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        \\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        vector<int>op;\\n        \\n        solve(nums, op);\\n        return ans; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    \\n    void solve(vector<int>input, vector<int>output){\\n        \\n        if(input.size() == 0){\\n            \\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433693,
                "title": "java-backtracking-easy",
                "content": "```\\nclass Solution {\\n    Set<List<Integer>> res = new HashSet<>();\\n    \\n    void solve(int [] nums,int n,int idx,List<Integer>temp)\\n    {\\n        if(idx==n)\\n        {\\n            res.add(new ArrayList(temp));\\n            return ;\\n        }\\n        solve(nums,n,idx+1,temp);\\n        temp.add(nums[idx]);\\n        solve(nums,n,idx+1,temp);\\n        temp.remove(temp.size()-1);\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        solve(nums,n,0,new ArrayList());\\n        return new ArrayList(res);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Set<List<Integer>> res = new HashSet<>();\\n    \\n    void solve(int [] nums,int n,int idx,List<Integer>temp)\\n    {\\n        if(idx==n)\\n        {\\n            res.add(new ArrayList(temp));\\n            return ;\\n        }\\n        solve(nums,n,idx+1,temp);\\n        temp.add(nums[idx]);\\n        solve(nums,n,idx+1,temp);\\n        temp.remove(temp.size()-1);\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        solve(nums,n,0,new ArrayList());\\n        return new ArrayList(res);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333174,
                "title": "c-simple-and-short-solution-no-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                if (find(res.begin(), res.end(), curr) == res.end())\\n                    res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242864,
                "title": "recursion-using-aditya-verma-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int> ip,vector<int> op)\\n    {\\n        if(ip.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n            \\n                s.insert(op);\\n                ans.push_back(op);\\n                \\n            }\\n            return ;\\n        }\\n        vector <int> op1=op;\\n        vector <int> op2=op;\\n        op2.push_back(ip[0]);\\n        ip.erase(ip.begin()+0);\\n        solve(ip,op1);\\n        solve(ip,op2);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& ip) {\\n        sort(ip.begin(),ip.end());\\n        vector <int> op;\\n        solve(ip,op);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int> ip,vector<int> op)\\n    {\\n        if(ip.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n            \\n                s.insert(op);\\n                ans.push_back(op);\\n                \\n            }\\n            return ;\\n        }\\n        vector <int> op1=op;\\n        vector <int> op2=op;\\n        op2.push_back(ip[0]);\\n        ip.erase(ip.begin()+0);\\n        solve(ip,op1);\\n        solve(ip,op2);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& ip) {\\n        sort(ip.begin(),ip.end());\\n        vector <int> op;\\n        solve(ip,op);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087030,
                "title": "python-easy-to-understand-list-solution-by-changing-start-end-indexes",
                "content": "Consider the example [1, 5, 3, 3]\\n\\n1. Sort nums to place duplicates next to each other [1, 3, 3, 5]\\n2. Start with an empty set: [[]]\\n3. Add the first number (1) to all the existing subsets to create new subsets: [[], [1]];\\n4. Add the second number (3) to all the existing subsets: [[], [1], [3], [1,3]].\\n5. The next number (3) is a duplicate. If we add it to all existing subsets we will get:\\n    [[], [1], [3], [1,3], [3], [1,3], [3,3], [1,3,3]]\\n6. To handle this instead of adding (3) to all the existing subsets, we only add it to the new subsets which were created in the previous (4th) step ([3],[1,3]):\\n    [[], [1], [3], [1,3], [3,3], [1,3,3]]\\n\\t\\n7. Finally, add the forth number (5) to all the existing subsets: [[], [1], [3], [1,3], [3,3], [1,3,3], [5], [1,5], [3,5], [1,3,5], [3,3,5], [1,3,3,5]]\\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return []\\n        \\n        subsets = []\\n        \\n        #Sorting nums so that duplicates are placed next to each other\\n        nums.sort()\\n        \\n        #Adding empty element to subsets\\n        subsets.append([])\\n        \\n        #Manipulating start, end indices\\n        startIndex, endIndex = 0, 0\\n        \\n        for i in range(len(nums)):\\n            #Initialize startIndex as 0 for every incoming number (normal unless duplicate)\\n            startIndex = 0\\n            \\n            #Checking duplicate condition\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                #Update startIndex to only consider 2nd half, subsets added in the previous step\\n                startIndex = endIndex + 1\\n                \\n            #Set endIndex till the end of subsets \\n            endIndex = len(subsets) - 1\\n            \\n            #Adding current Number to all eligible subsets\\n            for j in range(startIndex, endIndex + 1):\\n                #Selecting subset to add element to \\n                set1 = list(subsets[j])\\n                set1.append(nums[i])\\n                subsets.append(set1)\\n        \\n        return subsets\\n```\\n\\nTime Complexity: O(N * 2^N) [Number of subsets double at each step for every element N (if not duplicate)]\\nSpace Complexity: O(N * 2^N) [O(2^N) subsets taking O(N) space]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return []\\n        \\n        subsets = []\\n        \\n        #Sorting nums so that duplicates are placed next to each other\\n        nums.sort()\\n        \\n        #Adding empty element to subsets\\n        subsets.append([])\\n        \\n        #Manipulating start, end indices\\n        startIndex, endIndex = 0, 0\\n        \\n        for i in range(len(nums)):\\n            #Initialize startIndex as 0 for every incoming number (normal unless duplicate)\\n            startIndex = 0\\n            \\n            #Checking duplicate condition\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                #Update startIndex to only consider 2nd half, subsets added in the previous step\\n                startIndex = endIndex + 1\\n                \\n            #Set endIndex till the end of subsets \\n            endIndex = len(subsets) - 1\\n            \\n            #Adding current Number to all eligible subsets\\n            for j in range(startIndex, endIndex + 1):\\n                #Selecting subset to add element to \\n                set1 = list(subsets[j])\\n                set1.append(nums[i])\\n                subsets.append(set1)\\n        \\n        return subsets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852051,
                "title": "almost-same-code-as-subset-i-problem-simple-recursive-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<vector<int>>ans;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            sort(v[i].begin(),v[i].end());\\n            mp[v[i]]++;\\n        }\\n        for(auto i:mp)\\n        {\\n            ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Alternate method--**\\n```\\nclass Solution {\\npublic:\\n   void backtrack(int i,vector<int>& nums,int n,vector<int>curr,vector<vector<int>>&ans)\\n    {\\n        ans.push_back(curr);\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            if(j>i&&nums[j]==nums[j-1])continue;\\n            curr.push_back(nums[j]);\\n            backtrack(j+1,nums,n,curr,ans);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>curr;\\n        int n=nums.size();\\n        backtrack(i,nums,n,curr,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<vector<int>>ans;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            sort(v[i].begin(),v[i].end());\\n            mp[v[i]]++;\\n        }\\n        for(auto i:mp)\\n        {\\n            ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n   void backtrack(int i,vector<int>& nums,int n,vector<int>curr,vector<vector<int>>&ans)\\n    {\\n        ans.push_back(curr);\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            if(j>i&&nums[j]==nums[j-1])continue;\\n            curr.push_back(nums[j]);\\n            backtrack(j+1,nums,n,curr,ans);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>curr;\\n        int n=nums.size();\\n        backtrack(i,nums,n,curr,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773502,
                "title": "java-solution-recursion-beats-100",
                "content": "Here, I have used a recursive approach where we pick the first occurrence of every unique element in every recursive call.\\n\\nApproach:\\nBrute force: Follow a general subsequence pattern using recursion and add every subsequence to the final ArrayList. Then convert the ArrayList to a HashSet and again convert it back to an ArrayList. This process takes extra time while converting the ArrayList to a HashSet and then back to an ArrayList.\\n\\nWe can avoid these extra conversions while doing the subsequence recursion.\\n\\nOptimized approach: Initially, sort the array because we need all duplicate elements consecutively. Start the recursion and add the list to the \"ans\" (final ArrayList). Run a for loop because we need to go through every possibility of a subsequence from the current element to the end of the array.\\n\\nIf (i != ind && arr[i] == arr[i-1]), continue;\\n\\nThis condition is used to check if the current element is a duplicate or the first occurrence. If it is a duplicate, we continue the loop without adding it to the list. Otherwise, we add it to the list and make further recursive calls for other elements. Make sure to remove the last element of the list while backtracking to reconstruct the previous list.\\n\\nTime complexity: O(2^n * n)\\n- 2^n is the worst case of the number of subsequences formed. This occurs when all elements are unique.\\n- n is for adding the list to \"ans.\\n\\nSpace complexity : O(2^n * k)\\n\\n- 2^n is number of sub ArrayLists(list) in the final ArrayLists(ans)\\n- k is average size of sub ArrayList(list) \\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        subset2(0,nums,list,ans);\\n        return ans;\\n    }\\n\\n    private void subset2(int ind, int[] arr, ArrayList<Integer> list, List<List<Integer>> ans) {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=ind;i<arr.length;i++){\\n            if(i!=ind && arr[i]==arr[i-1]) continue;\\n            list.add(arr[i]);\\n            subset2(i+1,arr,list,ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        subset2(0,nums,list,ans);\\n        return ans;\\n    }\\n\\n    private void subset2(int ind, int[] arr, ArrayList<Integer> list, List<List<Integer>> ans) {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=ind;i<arr.length;i++){\\n            if(i!=ind && arr[i]==arr[i-1]) continue;\\n            list.add(arr[i]);\\n            subset2(i+1,arr,list,ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697570,
                "title": "same-approches-as-subset-i-with-brute-force-and-backtracking",
                "content": "# 1. Subset 1 Approach-->TC:[2^N*N]\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        list1 = [[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n            list1.append(list2)\\n        return list1\\n```\\n# 1. Backtracking--->TC:Log(2^N)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n        \\n```\\n# 2. Backtracking Concept:TC:[N*log(N)+log(2^N)]\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                if i!=0 and nums[i]==nums[i-1]:\\n                    continue\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(sorted(nums),ans,[])\\n        return ans\\n```\\n# 2. Same Approach as Subset I-->TC:[N^2X2^N*LogN] Heavy brute force but it works \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        list1=[[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n                list2.sort()\\n                if list2 not in list1:\\n                    list1.append(list2)\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        list1 = [[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n            list1.append(list2)\\n        return list1\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n        \\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            ans.append(temp)\\n            for i in range(len(nums)):\\n                if i!=0 and nums[i]==nums[i-1]:\\n                    continue\\n                back(nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(sorted(nums),ans,[])\\n        return ans\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        list1=[[]]\\n        n=len(nums)\\n        for i in range(1,2**n):\\n            list2=[]\\n            for j in range(n):\\n                if (i&1<<j):\\n                    list2.append(nums[j])\\n                list2.sort()\\n                if list2 not in list1:\\n                    list1.append(list2)\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696610,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>> &ans, vector<int> &nums, vector<int> &curr, int index) {\\n    ans.push_back(curr);\\n    for(int i = index; i < nums.size(); i++) {\\n        if(i != index && nums[i] == nums[i-1]) continue;\\n        curr.push_back(nums[i]);\\n        backTrack(ans, nums, curr, i+1);\\n        curr.pop_back();\\n    }\\n}\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        backTrack(ans, nums, curr, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>> &ans, vector<int> &nums, vector<int> &curr, int index) {\\n    ans.push_back(curr);\\n    for(int i = index; i < nums.size(); i++) {\\n        if(i != index && nums[i] == nums[i-1]) continue;\\n        curr.push_back(nums[i]);\\n        backTrack(ans, nums, curr, i+1);\\n        curr.pop_back();\\n    }\\n}\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        backTrack(ans, nums, curr, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677317,
                "title": "c-solution-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&ans,vector<int>&output,int index,vector<int>& nums)\\n    {\\n        //base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        //exclude\\n         solve(ans,output,index+1,nums);\\n\\n        //include\\n        output.push_back(nums[index]);\\n        solve(ans,output,index+1,nums);\\n        output.pop_back();\\n    } \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>output;\\n        int index=0;\\n        solve(ans,output,index,nums);\\n        set<vector<int>>st;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            st.insert(ans[i]);\\n        }\\n        vector<vector<int>>ans2;\\n        for(auto s:st)\\n        {\\n            ans2.push_back(s);\\n        }\\n        return ans2; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&ans,vector<int>&output,int index,vector<int>& nums)\\n    {\\n        //base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        //exclude\\n         solve(ans,output,index+1,nums);\\n\\n        //include\\n        output.push_back(nums[index]);\\n        solve(ans,output,index+1,nums);\\n        output.pop_back();\\n    } \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        vector<int>output;\\n        int index=0;\\n        solve(ans,output,index,nums);\\n        set<vector<int>>st;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            st.insert(ans[i]);\\n        }\\n        vector<vector<int>>ans2;\\n        for(auto s:st)\\n        {\\n            ans2.push_back(s);\\n        }\\n        return ans2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137672,
                "title": "c-easy-solution-recursion-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind)\\n    {\\n        ans.push_back(ds);\\n        for(int i =ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1])\\n            {\\n                continue;\\n            }\\n\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind)\\n    {\\n        ans.push_back(ds);\\n        for(int i =ind;i<nums.size();i++)\\n        {\\n            if(i>ind && nums[i] == nums[i-1])\\n            {\\n                continue;\\n            }\\n\\n            ds.push_back(nums[i]);\\n            solve(nums,ds,ans,i+1);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ds;\\n        solve(nums,ds,ans,0);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851465,
                "title": "java-simple-java-solution-without-any-for-while-loop",
                "content": "# Code\\n```\\nclass Solution {\\n    static void subsequence(int i,int[] arr, List<Integer> lst, List<List<Integer>> res){\\n        if(res.contains(lst)) return;\\n        if(i==arr.length){\\n            res.add(new ArrayList<>(lst));\\n            return;\\n        }\\n        lst.add(arr[i]);\\n        subsequence(i+1, arr, lst, res);\\n        lst.remove(lst.size()-1);\\n        subsequence(i+1, arr, lst, res);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        subsequence(0, nums, new ArrayList<>(), res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static void subsequence(int i,int[] arr, List<Integer> lst, List<List<Integer>> res){\\n        if(res.contains(lst)) return;\\n        if(i==arr.length){\\n            res.add(new ArrayList<>(lst));\\n            return;\\n        }\\n        lst.add(arr[i]);\\n        subsequence(i+1, arr, lst, res);\\n        lst.remove(lst.size()-1);\\n        subsequence(i+1, arr, lst, res);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        subsequence(0, nums, new ArrayList<>(), res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424966,
                "title": "easy-c-solution-using-backtracking-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void subset(int i,vector<int>& nums,vector<int> sub){\\n        if(i==nums.size()){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        sub.push_back(nums[i]);\\n        subset(i+1,nums,sub);\\n        sub.pop_back();\\n        while(i+1<nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        subset(i+1,nums,sub);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,{});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void subset(int i,vector<int>& nums,vector<int> sub){\\n        if(i==nums.size()){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        sub.push_back(nums[i]);\\n        subset(i+1,nums,sub);\\n        sub.pop_back();\\n        while(i+1<nums.size() && nums[i]==nums[i+1]){\\n            i++;\\n        }\\n        subset(i+1,nums,sub);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        subset(0,nums,{});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328340,
                "title": "c-solution-recursion-backtracking",
                "content": "**Code is availible in comment**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2237485,
                "title": "c-easy-solution-using-backtracking",
                "content": "class Solution {\\n    public:\\n  \\n     vector<int>v;\\n    vector<vector<int>>ans;\\n    void subset(vector<int> &arr, int N,int i){\\n        if(i==N){\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n            v.push_back(arr[i]); // take the number\\n        subset(arr,N,i+1);\\n        v.pop_back();\\n        while(i+1<N and arr[i]==arr[i+1]) i+=1; // to not include the same element as we have already taken \\n        subset(arr,N,i+1);//not take the number\\n        \\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n         int N = arr.size();\\n        sort(arr.begin(),arr.end()); // to get same value continously\\n        subset(arr,N,0);\\n        return ans;\\n    }\\n    };\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n  \\n     vector<int>v;\\n    vector<vector<int>>ans;\\n    void subset(vector<int> &arr, int N,int i){\\n        if(i==N){\\n            ans.push_back(v);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1883021,
                "title": "c-bitwise-shift-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        set<vector<int> > st;\\n        int size = nums.size();\\n        for(int i = 0; i < (1 << size); i++){\\n            vector<int> vc;\\n            for(int j = 0; j < size; j++){\\n                if(i & (1 << j)){\\n                    vc.push_back(nums[j]);\\n                }\\n            }\\n            sort(vc.begin(), vc.end());\\n            if (st.count(vc) == 0) {\\n                res.push_back(vc);\\n                st.insert(vc);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        set<vector<int> > st;\\n        int size = nums.size();\\n        for(int i = 0; i < (1 << size); i++){\\n            vector<int> vc;\\n            for(int j = 0; j < size; j++){\\n                if(i & (1 << j)){\\n                    vc.push_back(nums[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1743898,
                "title": "accepted-7ms-c-solution-basic-concept",
                "content": "The basic concept is that if a number occurs x times, then we have x+1 alternatives, i.e., include it 0 times, 1 times, 2 times, ..... or x times. For eg. x=1 ,then we have two options either leave it (0 times)  or include it (1 times).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        helper(nums,0,curr);\\n        return ans;\\n    }\\n    void helper(vector<int> &nums,int i,vector<int> curr){\\n        if(i==nums.size()){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        int j=i;\\n        while(j<nums.size()&&nums[j]==nums[i]) j++;\\n        helper(nums,j,curr);\\n        for(int x=i;x<j;x++){\\n            curr.push_back(nums[i]);\\n            helper(nums,j,curr);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        helper(nums,0,curr);\\n        return ans;\\n    }\\n    void helper(vector<int> &nums,int i,vector<int> curr){\\n        if(i==nums.size()){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        int j=i;\\n        while(j<nums.size()&&nums[j]==nums[i]) j++;\\n        helper(nums,j,curr);\\n        for(int x=i;x<j;x++){\\n            curr.push_back(nums[i]);\\n            helper(nums,j,curr);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557834,
                "title": "not-the-best-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<int>> res , vector<int> cases)\\n    {\\n        for(auto it : res)\\n        {\\n            if(it == cases)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int size = nums.size();\\n        int set = 1 << size;\\n        vector<vector<int>> res;\\n        sort(nums.begin() , nums.end());\\n        \\n        for(int index = 0 ; index < set ; index++)\\n        { \\n            vector<int> cases;\\n            for(int j = 0 ; j < size ; j++)\\n            {\\n                if(index &( 1 << j))\\n                    cases.push_back(nums[j]);\\n            }\\n            if(!exist(res,cases))\\n             res.push_back(cases);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<int>> res , vector<int> cases)\\n    {\\n        for(auto it : res)\\n        {\\n            if(it == cases)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        int size = nums.size();\\n        int set = 1 << size;\\n        vector<vector<int>> res;\\n        sort(nums.begin() , nums.end());\\n        \\n        for(int index = 0 ; index < set ; index++)\\n        { \\n            vector<int> cases;\\n            for(int j = 0 ; j < size ; j++)\\n            {\\n                if(index &( 1 << j))\\n                    cases.push_back(nums[j]);\\n            }\\n            if(!exist(res,cases))\\n             res.push_back(cases);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485015,
                "title": "c-backtracking-bit-manipulation-two-solution",
                "content": "**BACKTRACKING**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> list;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        help(nums,list,ans,0);\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        \\n        return res;\\n    }\\n    \\n    void help(vector<int> &nums,vector<int>& list, set<vector<int>>& ans,int start ){\\n        ans.insert(list);\\n       \\n        for(int i=start;i<nums.size();i++){\\n            list.push_back(nums[i]);\\n            help(nums,list,ans,i+1);\\n            list.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n**BIT MANIPULATION**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),p=1<<n;\\n        set<vector<int>> ans;\\n        \\n        for(int i=0;i<p;i++){\\n            vector<int> list;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)) list.push_back(nums[j]);\\n            }\\n            ans.insert(list);\\n        }\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        set<vector<int>> ans;\\n        vector<int> list;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        help(nums,list,ans,0);\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        \\n        return res;\\n    }\\n    \\n    void help(vector<int> &nums,vector<int>& list, set<vector<int>>& ans,int start ){\\n        ans.insert(list);\\n       \\n        for(int i=start;i<nums.size();i++){\\n            list.push_back(nums[i]);\\n            help(nums,list,ans,i+1);\\n            list.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),p=1<<n;\\n        set<vector<int>> ans;\\n        \\n        for(int i=0;i<p;i++){\\n            vector<int> list;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)) list.push_back(nums[j]);\\n            }\\n            ans.insert(list);\\n        }\\n        \\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381390,
                "title": "c-solution-recursion-aditya-verma-s-subset-video",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            if(s.find(output) == s.end()){\\n                s.insert(output);\\n                ans.push_back(output);   \\n            }\\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380224,
                "title": "python3-4-line-solution-faster-than-92-03-of-python3-online-submissions",
                "content": "Using Python, the solution can be written in 4 lines.\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ret = {()}\\n        for num in sorted(nums):\\n            ret = ret.union({s + (num,) for s in ret})\\n        return [list(elem) for elem in ret]\\n```\\nRuntime: 32 ms, faster than 92.03% of Python3 online submissions for Subsets II.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ret = {()}\\n        for num in sorted(nums):\\n            ret = ret.union({s + (num,) for s in ret})\\n        return [list(elem) for elem in ret]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359678,
                "title": "without-sorting-very-simple-backtracking-solution",
                "content": "```\\ndef btrack(inp,out,ans):\\n    if not inp:\\n        ans.append(out)\\n        return\\n    btrack(inp[1:],out+[inp[0]],ans)\\n    if inp[0] not in out:\\n        btrack(inp[1:],out,ans)\\n\\n\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        btrack(nums,[],ans)\\n        return ans\\n```\\nIdea:\\n1. In every btrack() call, we explore 2 choices for inp[0] which are: adding it to \"out\" and not adding it \"out\".\\n2. But if inp[0] already has atleast one occurence in \"out\", then *We must make only one choice i.e., adding it to out*  (This is an observation)\\n\\nPlease comment if you have any doubt and upvote if you found this solution as helpful.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef btrack(inp,out,ans):\\n    if not inp:\\n        ans.append(out)\\n        return\\n    btrack(inp[1:],out+[inp[0]],ans)\\n    if inp[0] not in out:\\n        btrack(inp[1:],out,ans)\\n\\n\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        btrack(nums,[],ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140408,
                "title": "clear-and-simple-explanation-with-intuition",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n*Note :This question is very similar to the [Subsets](https://leetcode.com/problems/subsets/) problem and I already explained that in detail [here](https://leetcode.com/problems/subsets/discuss/1140388/Clear-and-simple-explanation-with-example-:-100-faster) , so I am going to just tell the change thats going to be made for this particular question .*\\n**Concept:** Since we have to avoid the duplicates , hence we are going to use **set** data structure here. \\n\\nBut that alone wont be enough, cause the *set* can\\'t distinguish between elements if they are in different order.\\nFor instance: `[1,2,3]  !=[3,2,1]` as per the needs of our question, but the *set* can\\'t distinguish between that, so we need a way to maintain the relatibve order of elements to be same for every same combination ....\\n\\n**Thats right, the correct answer is sorting.** Sorting will maintain the oder of elements and then we can use the set to eliminate the duplicates.\\n\\nAnd thats it!!! Keeping this in mind here is the code: \\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>>subsets; // initialising set\\n    void helper(int index,vector<int>&current, vector<int>&nums)\\n    {\\n        subsets.insert(current); //inserting current array to the result\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>current;\\n        helper(0,current,nums);\\n        vector<vector<int>>ans(subsets.begin(),subsets.end()); //make vector from set\\n        return ans; //return answer\\n    }\\n};\\n```\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>>subsets; // initialising set\\n    void helper(int index,vector<int>&current, vector<int>&nums)\\n    {\\n        subsets.insert(current); //inserting current array to the result\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>current;\\n        helper(0,current,nums);\\n        vector<vector<int>>ans(subsets.begin(),subsets.end()); //make vector from set\\n        return ans; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939135,
                "title": "c-0ms-clean-concise-code-beats-100-time-12-lines",
                "content": "```\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        res.push_back(vector<int>());\\n        int end = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            int start = 0;\\n            if(i > 0 && nums[i] == nums[i - 1]) start = end;\\n            end = res.size();\\n            for(int j = start; j < end; j++){\\n                vector<int> v(res[j]);\\n                v.push_back(nums[i]);\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        res.push_back(vector<int>());\\n        int end = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            int start = 0;\\n            if(i > 0 && nums[i] == nums[i - 1]) start = end;\\n            end = res.size();\\n            for(int j = start; j < end; j++){\\n                vector<int> v(res[j]);\\n                v.push_back(nums[i]);\\n                res.push_back(v);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774097,
                "title": "python-solution-recursive-explanation",
                "content": "How Subsets II is different from Subset I codewise?\\n\\nExplanation:\\nThere are two important cases that helps us understand the solution.\\n\\nCase 1: Checking the use of sort() function.\\n```\\nInput1: [4,1, 4] \\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\\n\\nIf the nums array is not sorted the output results into:\\n```\\nWrong output: [[],[4],[4,1],[4,1,4],[4,4],[1],[1,4],[4]]\\n```\\n\\nRecursive operation explanation step-by-step:\\n```\\nIndex 0:    \\n\\tnums = [4,1, 4]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [1, 4]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [4]\\n\\t\\t\\tpath = [4,1]\\n\\t\\t\\tres= [[], [4], [4,1]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,1, 4]\\n\\t\\t\\t\\tres = [[], [4], [4,1], [4,1, 4]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,4]\\n\\t\\tres= [[], [4], [4,1], [4,1, 4], [4,4]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# here if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [4]\\n\\tpath = [1]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1]]\\t                \\n\\t\\n\\tIndex 1.1:\\n\\tnums = []\\n\\tpath = [1,4]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1], [1,4]]\\t                \\n\\t# here  nums[i] == nums [i-1] condition doesn\\'t satifies and the duplicate is generated. \\n\\t# we have two subsets with same elements [4,1] and [1,4].\\n\\n# If we sort the array and perform the operations then it helps in removing duplicates.\\n```\\n\\n\\n\\n\\n\\nCase 2: Recursive function explanation for the condition (if i > 0 and nums[i] == nums[i-1]) \\n```\\nInput: [4, 4, 1]\\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\\n\\n```\\nIndex 0:    \\n\\tnums = [4,4,1]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [4,1]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [1]\\n\\t\\t\\tpath = [4,4]\\n\\t\\t\\tres= [[], [4], [4,4]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,4,1]\\n\\t\\t\\t\\tres = [[], [4], [4,4], [4,4,1]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,1]\\n\\t\\tres= [[], [4], [4,4], [4,4,1], [4,1]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [1]\\n\\tpath = [4]    \\n\\tres =  [[], [4], [4,4], [4,4,1], [4,1], [4]]                 \\n\\t\\n# every increment we need this condition to check any duplicates.\\n\\nIndex 2:\\n\\tnums = []\\n\\tpath = [1]\\n\\tres =  [ [], [4], [4,4], [4,4,1], [4,1], [1]]\\n```\\n\\n\\n\\nBelow is the solution: \\nTotal Runtime is 32 ms.\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        print(res)\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```\\n\\n===============================================\\nPlease let me know if you have issues in understanding any part of the solution.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nInput1: [4,1, 4] \\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\n```\\nWrong output: [[],[4],[4,1],[4,1,4],[4,4],[1],[1,4],[4]]\\n```\n```\\nIndex 0:    \\n\\tnums = [4,1, 4]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [1, 4]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [4]\\n\\t\\t\\tpath = [4,1]\\n\\t\\t\\tres= [[], [4], [4,1]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,1, 4]\\n\\t\\t\\t\\tres = [[], [4], [4,1], [4,1, 4]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,4]\\n\\t\\tres= [[], [4], [4,1], [4,1, 4], [4,4]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# here if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [4]\\n\\tpath = [1]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1]]\\t                \\n\\t\\n\\tIndex 1.1:\\n\\tnums = []\\n\\tpath = [1,4]    \\n\\tres =  [[], [4], [4,1], [4,1, 4], [4,4], [1], [1,4]]\\t                \\n\\t# here  nums[i] == nums [i-1] condition doesn\\'t satifies and the duplicate is generated. \\n\\t# we have two subsets with same elements [4,1] and [1,4].\\n\\n# If we sort the array and perform the operations then it helps in removing duplicates.\\n```\n```\\nInput: [4, 4, 1]\\nExpected Output: [[],[1],[1,4],[1,4,4],[4],[4,4]]\\n```\n```\\nIndex 0:    \\n\\tnums = [4,4,1]\\n\\tpath = []\\n\\tres = [[]]\\n\\t\\n\\tIndex 0.0:\\n\\t\\tnums = [4,1]\\n\\t\\tpath = [4]\\n\\t\\tres= [[], [4]]\\n\\t\\t\\n\\t\\tIndex 0.0.0:\\n\\t\\t\\tnums = [1]\\n\\t\\t\\tpath = [4,4]\\n\\t\\t\\tres= [[], [4], [4,4]]\\n\\t\\t\\t\\n\\t\\t\\tIndex 0.0.0.0:\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tpath = [4,4,1]\\n\\t\\t\\t\\tres = [[], [4], [4,4], [4,4,1]]\\n\\t\\t\\n\\t# Now the index gets incremented\\n\\tIndex 0.1: \\n\\t\\tnums = []\\n\\t\\tpath = [4,1]\\n\\t\\tres= [[], [4], [4,4], [4,4,1], [4,1]]\\t\\n\\t\\t\\t\\n\\n# for index 1\\nIndex 1:\\n\\t# if we don\\'t check the condition nums[i] == nums [i-1], \\n\\t# then it will start adding the duplicates in the result array which we don\\'t want in our result.\\n\\tnums = [1]\\n\\tpath = [4]    \\n\\tres =  [[], [4], [4,4], [4,4,1], [4,1], [4]]                 \\n\\t\\n# every increment we need this condition to check any duplicates.\\n\\nIndex 2:\\n\\tnums = []\\n\\tpath = [1]\\n\\tres =  [ [], [4], [4,4], [4,4,1], [4,1], [1]]\\n```\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        print(res)\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501730,
                "title": "javascript-solution-easy-two-pointers",
                "content": "### The idea\\n1. Sort input `nums`\\n2. Use `prevIndex` to mark the start position of subsets to take considered of\\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    let prevIndex = 0;\\n    nums.sort((a,b)=>a-b);\\n    \\n    let res = [[]];\\n    for (let i=0;i<nums.length;i++) {    \\n        let l = res.length;\\n        for (let j=prevIndex;j<l;j++) res.push([...res[j], nums[i]]);\\n        if (nums[i+1] == nums[i]) prevIndex = l;\\n        else prevIndex = 0;\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function(nums) {\\n    let prevIndex = 0;\\n    nums.sort((a,b)=>a-b);\\n    \\n    let res = [[]];\\n    for (let i=0;i<nums.length;i++) {    \\n        let l = res.length;\\n        for (let j=prevIndex;j<l;j++) res.push([...res[j], nums[i]]);\\n        if (nums[i+1] == nums[i]) prevIndex = l;\\n        else prevIndex = 0;\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308274,
                "title": "java-1ms-simple-solution",
                "content": "```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> currentList, int index, int[] nums) {\\n    resultList.add(new ArrayList<Integer>(currentList)); // 3. add currentList to final result list\\n    for(int i = index; i < nums.length; i++) {\\n        if( i > index && nums[i] == nums[i - 1] ) // 2. duplicate removal\\n            continue;\\n        currentList.add(nums[i]);\\n        traverse(resultList, currentList, i + 1, nums);\\n        currentList.remove(currentList.size() - 1);\\n    }\\n}\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    Arrays.sort(nums); // 1. sort the array\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    traverse(resultList, new ArrayList<Integer>(), 0, nums);\\n    return resultList;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> currentList, int index, int[] nums) {\\n    resultList.add(new ArrayList<Integer>(currentList)); // 3. add currentList to final result list\\n    for(int i = index; i < nums.length; i++) {\\n        if( i > index && nums[i] == nums[i - 1] ) // 2. duplicate removal\\n            continue;\\n        currentList.add(nums[i]);\\n        traverse(resultList, currentList, i + 1, nums);\\n        currentList.remove(currentList.size() - 1);\\n    }\\n}\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    Arrays.sort(nums); // 1. sort the array\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    traverse(resultList, new ArrayList<Integer>(), 0, nums);\\n    return resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 110975,
                "title": "golang-simple-sort-backtrack-solution",
                "content": "Simply sort and if the same number appears skip it while iterating and backtracking.\\n\\n```\\nfunc subsetsWithDup(nums []int) [][]int {\\n\\tres := [][]int{[]int{}}\\n\\tvar cur []int\\n\\n\\tsort.Ints(nums)\\n\\tdoSubsetsWithDup(nums, cur, &res)\\n\\treturn res\\n}\\n\\nfunc doSubsetsWithDup(nums []int, cur []int, res *[][]int) {\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcur = append(cur, nums[i])\\n\\t\\tnewRes := make([]int, len(cur))\\n\\t\\tcopy(newRes, cur)\\n\\t\\t*res = append(*res, newRes)\\n\\n\\t\\tdoSubsetsWithDup(nums[i+1:], cur, res)\\n\\t\\tcur = cur[:len(cur)-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subsetsWithDup(nums []int) [][]int {\\n\\tres := [][]int{[]int{}}\\n\\tvar cur []int\\n\\n\\tsort.Ints(nums)\\n\\tdoSubsetsWithDup(nums, cur, &res)\\n\\treturn res\\n}\\n\\nfunc doSubsetsWithDup(nums []int, cur []int, res *[][]int) {\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcur = append(cur, nums[i])\\n\\t\\tnewRes := make([]int, len(cur))\\n\\t\\tcopy(newRes, cur)\\n\\t\\t*res = append(*res, newRes)\\n\\n\\t\\tdoSubsetsWithDup(nums[i+1:], cur, res)\\n\\t\\tcur = cur[:len(cur)-1]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30159,
                "title": "subsets-vs-subsets-ii-add-only-3-more-lines-to-subsets-solution",
                "content": "The solution of subset II could be easily derived from the answer of subset I. \\n\\nHere is my answer of subset I: \\n```\\npublic class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>(); \\n        res.add(new ArrayList<>()); \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list:resDup) {\\n                List<Integer> tmpList = new ArrayList<>(list);\\n                list.add(num);\\n                res.add(tmpList); \\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\\n\\nIn this problem, we need to change two things: \\n1. Sort the input nums, so that we won't get lists such as [1,4] and [4, 1] at the same time. \\n2. Check duplicates when adding new list to res. \\nHere is Subset II solution based on subset I solution: \\n```\\npublic class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(new ArrayList<Integer>()); \\n        Arrays.sort(nums); //important: sort nums \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list: resDup) {\\n                List<Integer> tmp = new ArrayList<>(list);\\n                tmp.add(num);\\n                if (!res.contains(tmp))  //check duplicates\\n                    res.add(tmp);\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>(); \\n        res.add(new ArrayList<>()); \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list:resDup) {\\n                List<Integer> tmpList = new ArrayList<>(list);\\n                list.add(num);\\n                res.add(tmpList); \\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(new ArrayList<Integer>()); \\n        Arrays.sort(nums); //important: sort nums \\n        \\n        for (int num: nums) {\\n            List<List<Integer>> resDup = new ArrayList<>(res);\\n            for (List<Integer> list: resDup) {\\n                List<Integer> tmp = new ArrayList<>(list);\\n                tmp.add(num);\\n                if (!res.contains(tmp))  //check duplicates\\n                    res.add(tmp);\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900796,
                "title": "retarded-way-to-solve-this-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Generate all subsets, sort each subset to handle duplicates, use custom hash as key in a map to store and filter unique subsets.\\n\\n\\n# Complexity\\n- Time complexity:2^n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Define a custom hash function for vector keys\\n    struct vectorkey { \\n        size_t operator()(const vector<int>& v) const { \\n            size_t hash = 0; \\n            for (auto x : v) { \\n                hash ^= std::hash<int>{}(x); \\n            }\\n            return hash; \\n        }\\n    };\\n\\n    // Use a map to store unique subsets and their counts\\n    unordered_map<vector<int>, int, vectorkey> map1;\\n\\n    // Function to generate subsets with handling duplicates\\n    void creator(vector<int> temp, int index, vector<int> nums) {\\n        if (temp.size() != 0) {\\n            sort(temp.begin(), temp.end()); // Sort the subset elements\\n            map1[temp]++; // Store the sorted subset in the map\\n        }\\n        for (int i = index; i < nums.size(); i++) {\\n            temp.push_back(nums[i]); // Include the current element\\n            creator(temp, i + 1, nums); // Generate subsets without current element\\n            temp.pop_back(); // Backtrack and remove the current element\\n        }\\n    }\\n\\n    // Generate unique subsets with duplicates removed\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        creator({}, 0, nums); // Start generating subsets\\n        vector<vector<int>> final; \\n        for (auto it : map1) { \\n            final.push_back(it.first); // Add each unique subset to the result\\n        }\\n        final.push_back({}); // Include an empty subset\\n        return final;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a custom hash function for vector keys\\n    struct vectorkey { \\n        size_t operator()(const vector<int>& v) const { \\n            size_t hash = 0; \\n            for (auto x : v) { \\n                hash ^= std::hash<int>{}(x); \\n            }\\n            return hash; \\n        }\\n    };\\n\\n    // Use a map to store unique subsets and their counts\\n    unordered_map<vector<int>, int, vectorkey> map1;\\n\\n    // Function to generate subsets with handling duplicates\\n    void creator(vector<int> temp, int index, vector<int> nums) {\\n        if (temp.size() != 0) {\\n            sort(temp.begin(), temp.end()); // Sort the subset elements\\n            map1[temp]++; // Store the sorted subset in the map\\n        }\\n        for (int i = index; i < nums.size(); i++) {\\n            temp.push_back(nums[i]); // Include the current element\\n            creator(temp, i + 1, nums); // Generate subsets without current element\\n            temp.pop_back(); // Backtrack and remove the current element\\n        }\\n    }\\n\\n    // Generate unique subsets with duplicates removed\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        creator({}, 0, nums); // Start generating subsets\\n        vector<vector<int>> final; \\n        for (auto it : map1) { \\n            final.push_back(it.first); // Add each unique subset to the result\\n        }\\n        final.push_back({}); // Include an empty subset\\n        return final;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759029,
                "title": "100-easy-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![download.png](https://assets.leetcode.com/users/images/bd5ee898-f275-4f33-b89f-c1c960bbe6ec_1689245864.4761305.png)\\n\\n# Code\\n// IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE \\u2B06\\uFE0F\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n         Arrays.sort(nums);\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        int start=0;\\n        int end=0;\\n        for(int i=0;i<nums.length;i++)\\n        {    start=0;\\n            // if current and previous element is same,s=e+1;\\n            if(i >0 && nums[i]==nums[i -1])\\n            {\\n                start=end+1;\\n            }\\n            end=outer.size() - 1;\\n            int n=outer.size() ;\\n            for(int j=start;j<n;j++)\\n            {\\n        List<Integer> Internal=new ArrayList<>(outer.get(j));\\n                Internal.add(nums[i]);\\n                outer.add( Internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n         Arrays.sort(nums);\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        int start=0;\\n        int end=0;\\n        for(int i=0;i<nums.length;i++)\\n        {    start=0;\\n            // if current and previous element is same,s=e+1;\\n            if(i >0 && nums[i]==nums[i -1])\\n            {\\n                start=end+1;\\n            }\\n            end=outer.size() - 1;\\n            int n=outer.size() ;\\n            for(int j=start;j<n;j++)\\n            {\\n        List<Integer> Internal=new ArrayList<>(outer.get(j));\\n                Internal.add(nums[i]);\\n                outer.add( Internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608983,
                "title": "best-recursive-approach-no-sets-94-time-beats-80-space-beats",
                "content": "# Intuition\\n**My main goal was to not using sets and i found a solution. Best solution that i saw here.**\\n# Approach\\n1. It starts by initializing the result array with an empty subset [] as the first element. This will be the starting point for building other subsets.\\n2. The nums array is sorted in non-decreasing order using the sorted() method. Sorting the array is important to handle duplicates effectively.\\n3. A loop is iterated over the indices of nums from 0 to nums.count - 1. For each index num, the following steps are performed:\\nIf num is 0 or the current number nums[num] is different from the previous number nums[num - 1], indicating a new element or a distinct occurrence of a duplicate element, the following actions are taken:\\n- A new subset subset is created with the current number nums[num].\\n- The new subset subset is appended to the result array.\\n- The findingAllSubsets function is called recursively to find all subsets considering the current subset and the remaining elements starting from num.\\n4. The findingAllSubsets function takes the nums array, the result array, the current subset, and the current index as input parameters.\\n5. Inside the findingAllSubsets function:\\n- If the current index is equal to or greater than nums.count - 1, indicating that there are no more elements remaining, the function returns.\\n- The variable nextIndex is set to the current index plus 1.\\n- A while loop is used to increment nextIndex while it is within bounds and the next number at nums[nextIndex + 1] is equal to the current number at nums[nextIndex]. This handles consecutive duplicates and ensures that all occurrences of duplicates are considered only once.\\n- The findingAllSubsets function is called recursively to find subsets starting from the updated nextIndex.\\n- A new subset is created by appending the next number in nums (at index + 1) to the current subset.\\n- The new subset is appended to the result array.\\n- The findingAllSubsets function is called recursively to find subsets starting from the current index plus 1.\\n6. Finally, the result array, containing all the subsets, is returned.\\n\\n# Complexity\\n- Time complexity O(2^N):\\nThe time complexity of this code is O(2^N), where N is the number of elements in the input array \"nums\". This is because the code generates all possible subsets, and the number of subsets grows exponentially with the input size. For each element in the input array, the code generates two subsets: one that includes the element and one that doesn\\'t. Hence, the overall time complexity is exponential.\\n\\n\\n- Space complexity O(2^N):\\nThe space complexity of this code is O(2^N), which is the same as the time complexity. This is because the code generates all possible subsets and stores them in the \"result\" array. The number of subsets is exponential, and therefore the space required to store them also grows exponentially. Additionally, there are other variables and recursive function calls that contribute to the space complexity, but their impact is relatively small compared to the subsets.\\n\\n\\n# Uncommented code\\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        for num in 0..<nums.count{\\n            if num == 0 || nums[num] != nums[num - 1]{\\n                let subset: [Int] = [nums[num]]\\n                result.append(subset)\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int){\\n        if index >= nums.count - 1{\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex]{\\n            nextIndex += 1\\n        }\\n        \\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        subset.append(nums[index + 1])\\n        result.append(subset)\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\\n\\n# Commented code\\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        // Iterate over each number in the sorted array\\n        for num in 0..<nums.count {\\n            // Check if it\\'s the first number or different from the previous number\\n            if num == 0 || nums[num] != nums[num - 1] {\\n                // Create a subset with only the current number\\n                let subset: [Int] = [nums[num]]\\n                // Add the subset to the result array\\n                result.append(subset)\\n                // Call a recursive function to find all subsets containing the current number\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int) {\\n        // Check if we have reached the last index or beyond\\n        if index >= nums.count - 1 {\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        // Find the next index that has a different number than the current one\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex] {\\n            nextIndex += 1\\n        }\\n        \\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        // Add the next number to the subset\\n        subset.append(nums[index + 1])\\n        // Add the new subset to the result array\\n        result.append(subset)\\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\\nIf you liked this solution, then do not forget to rate it please \\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        for num in 0..<nums.count{\\n            if num == 0 || nums[num] != nums[num - 1]{\\n                let subset: [Int] = [nums[num]]\\n                result.append(subset)\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int){\\n        if index >= nums.count - 1{\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex]{\\n            nextIndex += 1\\n        }\\n        \\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        subset.append(nums[index + 1])\\n        result.append(subset)\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = [[]]\\n        var nums = nums.sorted()\\n        //        var set = Set<Int>()\\n        \\n        // Iterate over each number in the sorted array\\n        for num in 0..<nums.count {\\n            // Check if it\\'s the first number or different from the previous number\\n            if num == 0 || nums[num] != nums[num - 1] {\\n                // Create a subset with only the current number\\n                let subset: [Int] = [nums[num]]\\n                // Add the subset to the result array\\n                result.append(subset)\\n                // Call a recursive function to find all subsets containing the current number\\n                findingAllSubsets(nums, &result, subset, num)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func findingAllSubsets(_ nums: [Int],_ result: inout [[Int]],_ subset: [Int],_ index: Int) {\\n        // Check if we have reached the last index or beyond\\n        if index >= nums.count - 1 {\\n            return\\n        }\\n        \\n        var nextIndex = index + 1\\n        // Find the next index that has a different number than the current one\\n        while nextIndex + 1 <= nums.count - 1 && nums[nextIndex + 1] == nums[nextIndex] {\\n            nextIndex += 1\\n        }\\n        \\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, nextIndex)\\n        var subset = subset\\n        // Add the next number to the subset\\n        subset.append(nums[index + 1])\\n        // Add the new subset to the result array\\n        result.append(subset)\\n        // Recursively call the function to find subsets starting from the next index\\n        findingAllSubsets(nums, &result, subset, index + 1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605755,
                "title": "java-easy-solution-with-comments",
                "content": "# Intuition\\n Idea: Here in this Question, the question is given that, the nums may contain duplicates so we have to skip duplicates. For skipping the duplicates, we have to sort the nums array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log n + n * 2^n)$$ \\n\\n- Space complexity:\\n$$OO(2^n + n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Approach: Using BackTracking, T.C: O(n log n + n * 2^n), S.C: O(2^n + n)\\n        //Idea: Here in the Question, the instroction is given the the nums may contain duplicates\\n        //so we have to skip duplicates\\n        //for skipping the duplicates, we have to sort the nums array\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        //sort the num array\\n        Arrays.sort(nums);\\n        backtrack(ans, nums, new ArrayList<>(), 0);\\n        return ans;\\n    }\\n    public void backtrack(List<List<Integer>> ans, int[] nums, List<Integer> temp, int idx){\\n        //don\\'t need any base case\\n        ans.add(new ArrayList<>(temp));\\n        //we have to skip duplicates\\n        for(int i=idx;i<nums.length;i++){\\n            if(i>idx && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n\\n            //add to temp arrayList\\n            temp.add(nums[i]);\\n            //call recursion\\n            backtrack(ans, nums, temp, i+1);\\n            //do empty temp list\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Approach: Using BackTracking, T.C: O(n log n + n * 2^n), S.C: O(2^n + n)\\n        //Idea: Here in the Question, the instroction is given the the nums may contain duplicates\\n        //so we have to skip duplicates\\n        //for skipping the duplicates, we have to sort the nums array\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        //sort the num array\\n        Arrays.sort(nums);\\n        backtrack(ans, nums, new ArrayList<>(), 0);\\n        return ans;\\n    }\\n    public void backtrack(List<List<Integer>> ans, int[] nums, List<Integer> temp, int idx){\\n        //don\\'t need any base case\\n        ans.add(new ArrayList<>(temp));\\n        //we have to skip duplicates\\n        for(int i=idx;i<nums.length;i++){\\n            if(i>idx && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n\\n            //add to temp arrayList\\n            temp.add(nums[i]);\\n            //call recursion\\n            backtrack(ans, nums, temp, i+1);\\n            //do empty temp list\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290882,
                "title": "java-recursion-easy-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,nums,new ArrayList<>(),ans);\\n        return ans;\\n    }\\n    public void solve(int ind,int[]nums,ArrayList<Integer>temp,List<List<Integer>>ans){\\n        ans.add(new ArrayList<>(temp));\\n        for(int i=ind;i<nums.length;i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;//for duplicate checking\\n            temp.add(nums[i]);\\n            solve(i+1,nums,temp,ans);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,nums,new ArrayList<>(),ans);\\n        return ans;\\n    }\\n    public void solve(int ind,int[]nums,ArrayList<Integer>temp,List<List<Integer>>ans){\\n        ans.add(new ArrayList<>(temp));\\n        for(int i=ind;i<nums.length;i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;//for duplicate checking\\n            temp.add(nums[i]);\\n            solve(i+1,nums,temp,ans);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162453,
                "title": "python-clean-backtracking-with-sets",
                "content": "# Intuition\\nAny time I am trying to find permutations using items from a set, I first try to determine whether I can use backtracking. It turns out this works fine in this case, since we know the input array size is 10 or less.\\n\\n# Approach\\nIn order to avoid duplicates, we should first sort the array of nums. Then we can be sure that our subsets will always occur in non-decreasing order. Here we perform backtracking, but since we are looking for all possible subsets, we don\\'t need to do any checks before adding our interim results to the output. At each step, we take our current subset and go through the remaining elements in the array and perform backtracking with the subset plus that element. We store the results in a set in order to avoid duplication.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^N * N)$$\\n\\n- Space complexity:\\n$$O(2^N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        output = set()\\n\\n        nums = sorted(nums)\\n\\n        def backtrack(subset, index):\\n            output.add(subset)\\n\\n            for i in range(index, N):\\n                backtrack(tuple(list(subset) + [nums[i]]), i + 1)\\n\\n        backtrack(tuple(), 0)\\n        return output\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        output = set()\\n\\n        nums = sorted(nums)\\n\\n        def backtrack(subset, index):\\n            output.add(subset)\\n\\n            for i in range(index, N):\\n                backtrack(tuple(list(subset) + [nums[i]]), i + 1)\\n\\n        backtrack(tuple(), 0)\\n        return output\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062151,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(vector<int>& nums, vector<int> s, int ind)\\n    {\\n       if(ind==nums.size())\\n       {\\n           ans.push_back(s);\\n           return;\\n       }\\n        s.push_back(nums[ind]);\\n        dfs(nums, s, ind+1);\\n        s.pop_back();\\n        while(ind+1<nums.size() && nums[ind]==nums[ind+1])\\n            ind++;\\n        dfs(nums, s, ind+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> s;\\n        sort(nums.begin(), nums.end());\\n        dfs(nums, s, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(vector<int>& nums, vector<int> s, int ind)\\n    {\\n       if(ind==nums.size())\\n       {\\n           ans.push_back(s);\\n           return;\\n       }\\n        s.push_back(nums[ind]);\\n        dfs(nums, s, ind+1);\\n        s.pop_back();\\n        while(ind+1<nums.size() && nums[ind]==nums[ind+1])\\n            ind++;\\n        dfs(nums, s, ind+1);\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> s;\\n        sort(nums.begin(), nums.end());\\n        dfs(nums, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847966,
                "title": "100-submission-with-0ms-time-c-solution-of-simple-recursion-and-backtracing",
                "content": "Time complexity: O(2^n)\\nspace complexity: O(N)\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> ans;\\n        void solve(vector<int> &x,int i,vector<int> &a){\\n        ans.push_back(x);  \\n    /*whenever an element is add from the vector it should be push back \\n    as we need all the possible subset which will be generated in the recursive tree\\n     as we want all the value of the recursive tree rather than the end values like in other question\\n     hence we will have the ans.push_back on the top and will work ever time the recursive call take place*/\\n        if(i==a.size()) return; \\n    // this will end all the recursion as the i is now n that mean all values are taken onces\\n        for(int j=i;j<a.size();j++){    \\n    /*we start with j=i because if we have taken a value once then in next recursion\\n     we need that our code see the next element and not the element which it had already worked\\n     hence j=i where i will be increasing by 1 so that we can iterate the whole vector*/\\n            if(i==j or a[j]!=a[j-1]){ // this is important \\n                x.push_back(a[j]); \\n    /* in subset 2 we have dublicate elements so to remove them we will have a \\'if\\' condition\\n     where we will work only when the the current element is not equal to previous element\\n     but this will also ignore the current element which will give worng answer\\n     hence to make our code to work only once and take the current element\\n    then ignore the other if they are same we use or function with i==j and arr[j]!=arr[j-1] \\n    here i==j will allow use to take the element once rather than ignore all\\n     the other condition will remove all dublicates*/\\n                solve(x,j+1,a);\\n                x.pop_back(); \\n    // this is for backtracing as after one recursion we have to make our x empty again \\n    //eg: [],[1],[1,2][1,2,2] non we will empty the x so that we can insert other value \\n                }\\n\\t\\t\\t}   \\n\\t\\t}\\n   \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); // sorting is must as our loop is checking only adjacent elements in the vector\\n        vector<int> x;\\n        solve(x,0,nums);\\n        return ans;\\n        }\\n    };\\n\\n\\n\\n\\nDO UPVOTE IF HELPED AND FEEDBACK PURELY WELLCOMED :)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> ans;\\n        void solve(vector<int> &x,int i,vector<int> &a){\\n        ans.push_back(x);  \\n    /*whenever an element is add from the vector it should be push back \\n    as we need all the possible subset which will be generated in the recursive tree\\n     as we want all the value of the recursive tree rather than the end values like in other question\\n     hence we will have the ans.push_back on the top and will work ever time the recursive call take place*/\\n        if(i==a.size()) return; \\n    // this will end all the recursion as the i is now n that mean all values are taken onces\\n        for(int j=i;j<a.size();j++){    \\n    /*we start with j=i because if we have taken a value once then in next recursion\\n     we need that our code see the next element and not the element which it had already worked\\n     hence j=i where i will be increasing by 1 so that we can iterate the whole vector*/\\n            if(i==j or a[j]!=a[j-1]){ // this is important \\n                x.push_back(a[j]); \\n    /* in subset 2 we have dublicate elements so to remove them we will have a \\'if\\' condition\\n     where we will work only when the the current element is not equal to previous element\\n     but this will also ignore the current element which will give worng answer\\n     hence to make our code to work only once and take the current element\\n    then ignore the other if they are same we use or function with i==j and arr[j]!=arr[j-1] \\n    here i==j will allow use to take the element once rather than ignore all\\n     the other condition will remove all dublicates*/\\n                solve(x,j+1,a);\\n                x.pop_back(); \\n    // this is for backtracing as after one recursion we have to make our x empty again \\n    //eg: [],[1],[1,2][1,2,2] non we will empty the x so that we can insert other value \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2768249,
                "title": "0ms-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void subset_sum(int ind,vector<int> &nums,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        ans.push_back(v);\\n        for(int i=ind;i<nums.size();i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;\\n            v.push_back(nums[i]);\\n            subset_sum(i+1,nums,v,ans);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(nums.begin(),nums.end());\\n        subset_sum(0,nums,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subset_sum(int ind,vector<int> &nums,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        ans.push_back(v);\\n        for(int i=ind;i<nums.size();i++){\\n            if(i!=ind && nums[i]==nums[i-1]) continue;\\n            v.push_back(nums[i]);\\n            subset_sum(i+1,nums,v,ans);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(nums.begin(),nums.end());\\n        subset_sum(0,nums,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713874,
                "title": "subsets-ll",
                "content": "```\\nclass Solution {\\n    public static void Met(int i,int[]nums,List<List<Integer>>a,List<Integer>ds)\\n    {\\n        //base\\n        if(i==nums.length){\\n            if(!a.contains(new ArrayList<>(ds)))\\n            {\\n            a.add(new ArrayList<>(ds));\\n                \\n            }\\n            return;\\n        }\\n        //recurance\\n        ds.add(nums[i]);\\n        Met(i+1,nums,a,ds);//take\\n        ds.remove(ds.size()-1);\\n        Met(i+1,nums,a,ds);//not take\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>a=new ArrayList<>();\\n        Met(0,nums,a,new ArrayList<>());\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public static void Met(int i,int[]nums,List<List<Integer>>a,List<Integer>ds)\\n    {\\n        //base\\n        if(i==nums.length){\\n            if(!a.contains(new ArrayList<>(ds)))\\n            {\\n            a.add(new ArrayList<>(ds));\\n                \\n            }\\n            return;\\n        }\\n        //recurance\\n        ds.add(nums[i]);\\n        Met(i+1,nums,a,ds);//take\\n        ds.remove(ds.size()-1);\\n        Met(i+1,nums,a,ds);//not take\\n    }\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>a=new ArrayList<>();\\n        Met(0,nums,a,new ArrayList<>());\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664469,
                "title": "9ms-c-space-98-beats-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &tmp,vector<vector<int>> &ans,vector<int> &num)\\n    {\\n        ans.push_back(tmp);\\n        if(i>n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(num[j]);\\n            solve(j+1,n,tmp,ans,num);\\n            while(j<n-1&&num[j]==num[j+1])j++;\\n            tmp.pop_back();\\n        }\\n    }    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        solve(0,n,tmp,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &tmp,vector<vector<int>> &ans,vector<int> &num)\\n    {\\n        ans.push_back(tmp);\\n        if(i>n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(num[j]);\\n            solve(j+1,n,tmp,ans,num);\\n            while(j<n-1&&num[j]==num[j+1])j++;\\n            tmp.pop_back();\\n        }\\n    }    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        solve(0,n,tmp,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238100,
                "title": "subsets-ii-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >v;\\n    void generate(vector<int>subset,int i,vector<int>&nums){\\n             v.push_back(subset);\\n       for(int j=i;j<nums.size();j++){\\n        if(j!=i && nums[j]==nums[j-1])\\n            continue;\\n        subset.push_back(nums[j]);\\n        generate(subset,j+1,nums);\\n        subset.pop_back();\\n       }\\n    }\\n    \\n    public:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>empty;\\n        generate(empty,0,nums);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >v;\\n    void generate(vector<int>subset,int i,vector<int>&nums){\\n             v.push_back(subset);\\n       for(int j=i;j<nums.size();j++){\\n        if(j!=i && nums[j]==nums[j-1])\\n            continue;\\n        subset.push_back(nums[j]);\\n        generate(subset,j+1,nums);\\n        subset.pop_back();\\n       }\\n    }\\n    \\n    public:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>empty;\\n        generate(empty,0,nums);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210692,
                "title": "python-set-soooooo-easyyyyyyy",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        output = [[]]\\n        nums.sort()\\n        \\n        for num in nums:\\n            output += [curr + [num] for curr in output]\\n        \\n        output = set(tuple(i) for i in output)\\n        return output",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        output = [[]]\\n        nums.sort()\\n        \\n        for num in nums:\\n            output += [curr + [num] for curr in output]\\n        \\n        output = set(tuple(i) for i in output)\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 2178266,
                "title": "my-simple-recursive-solution-using-set-for-handling-duplicates",
                "content": "\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans= new HashSet<>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        solve(nums,0,ans,list);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private static void solve(int[] nums, int i, Set<List<Integer>> ans,List<Integer> list) {\\n        if(i==nums.length){\\n            //Collections.sort(list); either sort array at starting or sort list every time\\n            ans.add(list);\\n            return;\\n        }\\n        List<Integer> list1= new ArrayList<>(list);\\n        List<Integer> list2= new ArrayList<>(list);\\n        list2.add(nums[i]);\\n        solve(nums,i+1,ans,list1);\\n        solve(nums,i+1,ans,list2);\\n        return;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans= new HashSet<>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        solve(nums,0,ans,list);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private static void solve(int[] nums, int i, Set<List<Integer>> ans,List<Integer> list) {\\n        if(i==nums.length){\\n            //Collections.sort(list); either sort array at starting or sort list every time\\n            ans.add(list);\\n            return;\\n        }\\n        List<Integer> list1= new ArrayList<>(list);\\n        List<Integer> list2= new ArrayList<>(list);\\n        list2.add(nums[i]);\\n        solve(nums,i+1,ans,list1);\\n        solve(nums,i+1,ans,list2);\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2135519,
                "title": "c-solution-simple-recursive-backtracking",
                "content": "```\\n\\n```class Solution {\\npublic:\\n   void help(int i,vector<int> &nums,vector<int> &subset,vector<vector<int>> &ans){\\n       int n = nums.size();\\n       //Base condition\\n       if(i == n){\\n           ans.push_back(subset);\\n           return;\\n       }else{\\n           //Including ith element\\n           subset.push_back(nums[i]);\\n           help(i+1,nums,subset,ans);\\n           subset.pop_back();  //Backtraking\\n           \\n           //Skip ith element\\n           while(i+1 <n && nums[i] == nums[i+1]) i++;\\n           help(i+1,nums,subset,ans);\\n       }\\n   }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        help(0,nums,subset,ans);\\n        return ans;\\n    }\\n};````````\\n\\nIf it\\'s useful please vote :-:",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\n```\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 1840236,
                "title": "easy-c-82-faster",
                "content": "```\\nclass Solution {\\n    void getsubset(vector<int>& nums,vector<int>&curr, set<vector<int>>&fin,int pos){\\n        if(pos==nums.size()){\\n            fin.insert(curr);\\n            return;}\\n        \\n        else{\\n            curr.push_back(nums[pos]);\\n            getsubset(nums,curr,fin,pos+1);\\n            curr.pop_back();\\n            getsubset(nums,curr,fin,pos+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        set<vector<int>> fin;\\n        vector<vector<int>> ans;\\n        getsubset(nums,curr,fin,0);\\n        for(auto i: fin)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void getsubset(vector<int>& nums,vector<int>&curr, set<vector<int>>&fin,int pos){\\n        if(pos==nums.size()){\\n            fin.insert(curr);\\n            return;}\\n        \\n        else{\\n            curr.push_back(nums[pos]);\\n            getsubset(nums,curr,fin,pos+1);\\n            curr.pop_back();\\n            getsubset(nums,curr,fin,pos+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> curr;\\n        set<vector<int>> fin;\\n        vector<vector<int>> ans;\\n        getsubset(nums,curr,fin,0);\\n        for(auto i: fin)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821453,
                "title": "python-iterative-solution",
                "content": "This is similar to an iterative DP. We initialize an empty list then populate that list progressively. We have a new variable `prev` that keeps track of the previous length of our result. If current number is equal to the last number, we make sure to add only to those lists that already had that number (i.e.) we don\\'t replace it, just append. This makes sure there are 0 repetitions.\\n\\n\\nSuppose we have `[1,2,2]` and `res` right now is `[[], [1], [2], [1,2]]`\\nWe have `prev = 2`. Now we have one more `2` remaining. If we start from the beginning of res and append `2` to all of them, [2] and [1,2] will be repeated. Hence we start from prev (i.e.) 2nd index from which all lists already have a `2`. \\n\\nRemember we do not **replace** an already occurred element but **append**.\\n\\n\\n```python\\nclass Solution:\\n    def subsetsWithDup(self, a: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        prev = 0\\n        a.sort()\\n\\n        for i, x in enumerate(a):\\n            temp = []\\n            if i and a[i] == a[i - 1]:\\n                for j in res[prev:]:\\n                    temp.append(j + [x])\\n            else:\\n                for j in res:\\n                    temp.append(j + [x])\\n            prev = len(res)\\n            res += temp\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def subsetsWithDup(self, a: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        prev = 0\\n        a.sort()\\n\\n        for i, x in enumerate(a):\\n            temp = []\\n            if i and a[i] == a[i - 1]:\\n                for j in res[prev:]:\\n                    temp.append(j + [x])\\n            else:\\n                for j in res:\\n                    temp.append(j + [x])\\n            prev = len(res)\\n            res += temp\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794784,
                "title": "c-100-faster-recursive-solution",
                "content": "\\tclass Solution {\\n\\t\\t  set<vector<int>> st;\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> & nums,int idx,vector<int> &temp){\\n\\t\\t\\tif(idx==nums.size()){\\n\\t\\t\\t\\tst.insert(temp);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\ttemp.push_back(nums[idx]);\\n\\t\\t\\thelper(nums,idx+1,temp);\\n\\t\\t\\ttemp.pop_back();\\n\\t\\t\\thelper(nums,idx+1,temp);\\n\\t\\t}\\n\\t\\tvector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());   //to avoid duplicates\\n\\t\\t\\t vector<vector<int>> ans;\\n\\t\\t\\t vector<int> temp;\\n\\t\\t\\t helper(nums,0,temp);\\n\\t\\t\\t for(auto &it: st)\\n\\t\\t\\t\\t\\tans.push_back(it);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t  set<vector<int>> st;\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> & nums,int idx,vector<int> &temp){\\n\\t\\t\\tif(idx==nums.size()){\\n\\t\\t\\t\\tst.insert(temp);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1722060,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 3 ms, faster than 42.29% of Java online submissions for Subsets II.\\n\\nSimilar to ```78. Subsets``` [Only have to make two changes as array contains duplicates:- 1)Sort the array. 2)Use HashSet to add the subset lists.]\\n\\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element\\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that \\nelement  will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Sort the nums array.\\n        Arrays.sort(nums);\\n        //Using HashSet to store subset lists, so that duplicate lists are not added.\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n;\\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly by 2 \\n\\t\\t\\t//until the remainder becomes 0. After that we write the remainder that has come at every step \\n\\t\\t\\t//of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the set.\\n            set.add(cl);\\n        }\\n        \\n        //Convert HashSet to ArrayList and return it.\\n        List<List<Integer>> ml = new ArrayList<>(set);\\n        \\n        return ml;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```78. Subsets```\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element\\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that \\nelement  will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        //Sort the nums array.\\n        Arrays.sort(nums);\\n        //Using HashSet to store subset lists, so that duplicate lists are not added.\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n;\\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly by 2 \\n\\t\\t\\t//until the remainder becomes 0. After that we write the remainder that has come at every step \\n\\t\\t\\t//of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the set.\\n            set.add(cl);\\n        }\\n        \\n        //Convert HashSet to ArrayList and return it.\\n        List<List<Integer>> ml = new ArrayList<>(set);\\n        \\n        return ml;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675120,
                "title": "unique-java-solution-using-hashset-to-avoid-duplicates",
                "content": "The Basic Idea is to use HashSet to remove the duplicates and procede as you solve the Subset problem, that is either choose a particular element or not choose. \\nAlso don\\'t forget to sort the array beforehand so that there is no duplicate ordering of the numbers inside the final answer!\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        helper(nums,0,ans,new ArrayList<Integer>());\\n        List<List<Integer>> newAns = new ArrayList<List<Integer>>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        for(List<Integer> curr : ans){\\n            set.add(curr);\\n        }\\n        for(List<Integer> curr : set){\\n            newAns.add(curr);\\n        }\\n        return newAns;\\n    }\\n    public void helper(int[] nums, int i, List<List<Integer>> ans, ArrayList<Integer> curr){\\n        if(i == nums.length){\\n            ans.add(new ArrayList<Integer>(curr));\\n            return;\\n        }\\n        curr.add(nums[i]);\\n        helper(nums,i+1,ans,curr);\\n        curr.remove(curr.size()-1);\\n        helper(nums,i+1,ans,curr);\\n    }\\n}\\n```\\nPlease upvote if found helpful!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        helper(nums,0,ans,new ArrayList<Integer>());\\n        List<List<Integer>> newAns = new ArrayList<List<Integer>>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        for(List<Integer> curr : ans){\\n            set.add(curr);\\n        }\\n        for(List<Integer> curr : set){\\n            newAns.add(curr);\\n        }\\n        return newAns;\\n    }\\n    public void helper(int[] nums, int i, List<List<Integer>> ans, ArrayList<Integer> curr){\\n        if(i == nums.length){\\n            ans.add(new ArrayList<Integer>(curr));\\n            return;\\n        }\\n        curr.add(nums[i]);\\n        helper(nums,i+1,ans,curr);\\n        curr.remove(curr.size()-1);\\n        helper(nums,i+1,ans,curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490893,
                "title": "c-solution-aditya-verma-recursive-method-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n                s.insert(op);\\n                ans.push_back(op);\\n            }\\n            return;\\n        }\\n        vector<int>op1=op;\\n        vector<int>op2=op;\\n        op2.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve (nums,op1);\\n        solve (nums,op2);\\n        \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return ans;\\n    }\\n};\\n*Hats off To Aditya Verma & P.D.*```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    set<vector<int>>s;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            if(s.find(op)==s.end())\\n            {\\n                s.insert(op);\\n                ans.push_back(op);\\n            }\\n            return;\\n        }\\n        vector<int>op1=op;\\n        vector<int>op2=op;\\n        op2.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve (nums,op1);\\n        solve (nums,op2);\\n        \\n    }\\n    \\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int>op;\\n        sort(nums.begin(),nums.end());\\n        solve(nums,op);\\n        return ans;\\n    }\\n};\\n*Hats off To Aditya Verma & P.D.*```",
                "codeTag": "Java"
            },
            {
                "id": 1458912,
                "title": "javascript-backtracking",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort();\\n    let output = [];\\n    backtracking(0, [], nums, output);\\n    return output\\n};\\n\\nfunction backtracking(index, list, nums, output) {\\n    if(index > nums.length) return\\n    console.log(\"output: \",output);\\n    console.log(\"list: \",list);\\n    output.push([...list]);\\n    for(let i = index; i < nums.length; i++) {\\n        if(i > index && nums[i] === nums[i - 1]) continue\\n        list.push(nums[i]);\\n        backtracking(i+1, list, nums, output);\\n        list.pop();\\n    }\\n    return output;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort();\\n    let output = [];\\n    backtracking(0, [], nums, output);\\n    return output\\n};\\n\\nfunction backtracking(index, list, nums, output) {\\n    if(index > nums.length) return\\n    console.log(\"output: \",output);\\n    console.log(\"list: \",list);\\n    output.push([...list]);\\n    for(let i = index; i < nums.length; i++) {\\n        if(i > index && nums[i] === nums[i - 1]) continue\\n        list.push(nums[i]);\\n        backtracking(i+1, list, nums, output);\\n        list.pop();\\n    }\\n    return output;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448506,
                "title": "c-easy-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    void recurse(int i,vector<int> &v,vector<vector<int>> &ans,vector<int>& nums)\\n    {\\n        if(i==nums.size())\\n        {\\n            if(find(ans.begin(),ans.end(),v)==ans.end())\\n            ans.push_back(v);\\n            return;\\n        }   \\n        recurse(i+1,v,ans,nums);\\n        v.push_back(nums[i]);\\n        recurse(i+1,v,ans,nums);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> empty;\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        recurse(0,empty,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void recurse(int i,vector<int> &v,vector<vector<int>> &ans,vector<int>& nums)\\n    {\\n        if(i==nums.size())\\n        {\\n            if(find(ans.begin(),ans.end(),v)==ans.end())\\n            ans.push_back(v);\\n            return;\\n        }   \\n        recurse(i+1,v,ans,nums);\\n        v.push_back(nums[i]);\\n        recurse(i+1,v,ans,nums);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<int> empty;\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        recurse(0,empty,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437563,
                "title": "js-backtracking",
                "content": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//when drawing the recursive tree, we can see that,\\n//               = we can take each element from the nums array and recurse down until we are at the end of the length of the nums array\\n//               = after recursing the element we are on, we can move on to the next element in the array and continue till the i < nums array.length\\n//we pass in index so that we can reset i when we want to, however i will most likely be ahead of the index value, when we recurse back\\n//\\n//before we backtrack: \\n//we will sort the the given array in ascending order which is time of (nlogn)  (i might be wrong about the time complexity, but 95% sure)\\n//and doing so, we can always check if the previous value is the same as the current value while iterating, \\n//we will be adding the value as we iterate on to the subsets array, but just not when we encounter the same value we previously saw\\nvar subsetsWithDup = function(nums) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let resultArray = new Array();\\n    \\n    function helper(nums, subSets, index){\\n        resultArray.push([...subSets]);\\n        \\n        for(let i = index; i < nums.length; i++){\\n            \\n            //making sure i > 0  so when we subtract nums[i - 1] we dont get nums[-1]\\n            //to avoid going back to duplicate sets, we can check previous value is not equal to the same value  nums[i-1] === nums[i]\\n            if(i > index && nums[i-1] === nums[i]) \\n                continue;\\n            \\n            //choose\\n            subSets.push(nums[i]);\\n            \\n            //explore\\n            helper(nums, subSets, i+1);\\n            \\n            //unchoose\\n            subSets.pop();\\n            \\n        }\\n    }\\n    helper(nums, new Array(), 0);\\n    \\n    return resultArray;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//when drawing the recursive tree, we can see that,\\n//               = we can take each element from the nums array and recurse down until we are at the end of the length of the nums array\\n//               = after recursing the element we are on, we can move on to the next element in the array and continue till the i < nums array.length\\n//we pass in index so that we can reset i when we want to, however i will most likely be ahead of the index value, when we recurse back\\n//\\n//before we backtrack: \\n//we will sort the the given array in ascending order which is time of (nlogn)  (i might be wrong about the time complexity, but 95% sure)\\n//and doing so, we can always check if the previous value is the same as the current value while iterating, \\n//we will be adding the value as we iterate on to the subsets array, but just not when we encounter the same value we previously saw\\nvar subsetsWithDup = function(nums) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let resultArray = new Array();\\n    \\n    function helper(nums, subSets, index){\\n        resultArray.push([...subSets]);\\n        \\n        for(let i = index; i < nums.length; i++){\\n            \\n            //making sure i > 0  so when we subtract nums[i - 1] we dont get nums[-1]\\n            //to avoid going back to duplicate sets, we can check previous value is not equal to the same value  nums[i-1] === nums[i]\\n            if(i > index && nums[i-1] === nums[i]) \\n                continue;\\n            \\n            //choose\\n            subSets.push(nums[i]);\\n            \\n            //explore\\n            helper(nums, subSets, i+1);\\n            \\n            //unchoose\\n            subSets.pop();\\n            \\n        }\\n    }\\n    helper(nums, new Array(), 0);\\n    \\n    return resultArray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431473,
                "title": "one-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t\\n        nums.sort()\\n        ans = [[]]\\n        \\n        for num in nums:\\n            for index in range(len(ans)):\\n                temp = ans[index] + [num]\\n                if temp not in ans:\\n                    ans.append(temp)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t\\n        nums.sort()\\n        ans = [[]]\\n        \\n        for num in nums:\\n            for index in range(len(ans)):\\n                temp = ans[index] + [num]\\n                if temp not in ans:\\n                    ans.append(temp)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414383,
                "title": "java-dfs-using-sorted-nums-to-skip-duplicate-subtrees-with-diagram-faster-than-99-5",
                "content": "This is a typical DFS solution, except we say that if we\\'re at a number with a repeating value, the left subtree will not choose an edge corresponding with the repeated value.\\n\\nSo general structure:\\nAt each step, recurse left excluding the duplicate number.\\nThen (unless this subtree is ignoring this value) recurse right with no limits.\\n\\nHere\\'s an example of how the execution for nums = [1, 2, 2] would go.\\n\\n![image](https://assets.leetcode.com/users/images/40155b43-c4c7-4ef2-b1ed-80431f7102d4_1629418968.448155.png)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        return generateSubsets(nums, new ArrayList<List<Integer>>());\\n    }\\n    \\n    private ArrayList<List<Integer>> generateSubsets(int[] nums, ArrayList<List<Integer>> output){\\n        Arrays.sort(nums);\\n        generateSubsetsHelper(nums, 0, new ArrayList<Integer>(), output, false);\\n        \\n        return output;\\n    }\\n    \\n    private void generateSubsetsHelper(int[] nums, int depth, List<Integer> currentSequence, ArrayList<List<Integer>> output, boolean ignoreValue){\\n        if(depth == nums.length){\\n            // Add a finished sequence to the result\\n            output.add(new ArrayList<Integer>(currentSequence));\\n            return;\\n        }\\n        \\n        // If the next two numbers are repeating, then our left subtree will ignore it.\\n        boolean ignoreNext =  depth < nums.length - 1 && nums[depth] == nums[depth + 1];\\n        generateSubsetsHelper(nums, depth + 1, currentSequence, output, ignoreNext);\\n        \\n        if(!ignoreValue) {\\n            // Include current num\\n            currentSequence.add(nums[depth]);\\n            generateSubsetsHelper(nums, depth + 1, currentSequence, output, false);\\n        \\n            // Clean up before backtracking\\n            currentSequence.remove(currentSequence.size() - 1);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        return generateSubsets(nums, new ArrayList<List<Integer>>());\\n    }\\n    \\n    private ArrayList<List<Integer>> generateSubsets(int[] nums, ArrayList<List<Integer>> output){\\n        Arrays.sort(nums);\\n        generateSubsetsHelper(nums, 0, new ArrayList<Integer>(), output, false);\\n        \\n        return output;\\n    }\\n    \\n    private void generateSubsetsHelper(int[] nums, int depth, List<Integer> currentSequence, ArrayList<List<Integer>> output, boolean ignoreValue){\\n        if(depth == nums.length){\\n            // Add a finished sequence to the result\\n            output.add(new ArrayList<Integer>(currentSequence));\\n            return;\\n        }\\n        \\n        // If the next two numbers are repeating, then our left subtree will ignore it.\\n        boolean ignoreNext =  depth < nums.length - 1 && nums[depth] == nums[depth + 1];\\n        generateSubsetsHelper(nums, depth + 1, currentSequence, output, ignoreNext);\\n        \\n        if(!ignoreValue) {\\n            // Include current num\\n            currentSequence.add(nums[depth]);\\n            generateSubsetsHelper(nums, depth + 1, currentSequence, output, false);\\n        \\n            // Clean up before backtracking\\n            currentSequence.remove(currentSequence.size() - 1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398718,
                "title": "python-solution-with-memoization-similar-to-subset-problem",
                "content": "Subset :\\n\\n\\t\\tres = []\\n        i=0\\n        temp=[]\\n        def dfs(nums,i,res,temp):\\n            if i >= len(nums):\\n                res.append(temp)\\n                return res\\n            dfs(nums,i+1,res,temp+[nums[i]])\\n            dfs(nums,i+1,res,temp)\\n            return res\\n        dfs(nums,i,res,temp)\\n        return res\\n\\nSubset 2\\t: using above approach and passing sorted num\\n\\n\\t\\tres = []\\n        i = 0\\n        temp = []\\n        nums.sort()\\n        memo = {}\\n        def dfs(i,nums,res,temp):\\n            if i>=len(nums):\\n                res.append(temp)\\n                return res\\n            if tuple(temp+[nums[i]]) not in memo:\\n                memo[tuple(temp+[nums[i]])] = 1\\n                dfs(i+1,nums,res,temp+[nums[i]])\\n            \\n            dfs(i+1,nums,res,temp)\\n            return res\\n        dfs(i,nums,res,temp)\\n        return res",
                "solutionTags": [],
                "code": "Subset :\\n\\n\\t\\tres = []\\n        i=0\\n        temp=[]\\n        def dfs(nums,i,res,temp):\\n            if i >= len(nums):\\n                res.append(temp)\\n                return res\\n            dfs(nums,i+1,res,temp+[nums[i]])\\n            dfs(nums,i+1,res,temp)\\n            return res\\n        dfs(nums,i,res,temp)\\n        return res\\n\\nSubset 2\\t: using above approach and passing sorted num\\n\\n\\t\\tres = []\\n        i = 0\\n        temp = []\\n        nums.sort()\\n        memo = {}\\n        def dfs(i,nums,res,temp):\\n            if i>=len(nums):\\n                res.append(temp)\\n                return res\\n            if tuple(temp+[nums[i]]) not in memo:\\n                memo[tuple(temp+[nums[i]])] = 1\\n                dfs(i+1,nums,res,temp+[nums[i]])\\n            \\n            dfs(i+1,nums,res,temp)\\n            return res\\n        dfs(i,nums,res,temp)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1381403,
                "title": "python-solution-97-75-faster-just-used-tuple-instead-of-array",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        def recur(index,asf):\\n\\t\\t\\n            ans.append(asf)\\n\\t\\t\\t\\n            if index>=len(nums): #base case\\n                return\\n\\t\\t\\t\\t\\n            s=set()\\n            for i in range(index,len(nums)):\\n                if nums[i] not in s:\\n                    s.add(nums[i])\\n                    recur(i+1,asf+(nums[i],))\\n\\t\\t#main====================================\\t\\t\\t\\n        ans=[]               \\n        recur(0,tuple())\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/ff697d3b-343d-4657-a867-36e3999c60bd_1628015519.1739736.png)\\n\\nanyone with 100% solution?",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        def recur(index,asf):\\n\\t\\t\\n            ans.append(asf)\\n\\t\\t\\t\\n            if index>=len(nums): #base case\\n                return\\n\\t\\t\\t\\t\\n            s=set()\\n            for i in range(index,len(nums)):\\n                if nums[i] not in s:\\n                    s.add(nums[i])\\n                    recur(i+1,asf+(nums[i],))\\n\\t\\t#main====================================\\t\\t\\t\\n        ans=[]               \\n        recur(0,tuple())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381101,
                "title": "python-easy-bitmasks",
                "content": "SIMILAR PROBLEM: \\nhttps://leetcode.com/problems/subsets\\nSOLUTION:\\nhttps://leetcode.com/problems/subsets/discuss/1381094/PYTHON-oror-BITMASK\\n\\n\\nApproach:\\nWe map each subset to a bitmask of length n, where 1 on the ith position in bitmask means\\nthe presence of nums[i] in the subset, and 0 means its absence.\\n\\nNow we want our subsets without duplicates, so we need to filter out the repeated subsets!\\nWho better can do this work except SET !!\\nAfter finding all subsets, we push them in set and get only unique subset entries, and we return that set as our output.\\n\\nTC: O(Nx2^N)\\nSC: O(N) to store \\'ans\\'\\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n\\t\\t\\t\\t\\t\\n            s.add(ans)\\n\\t\\t\\t\\n        return list(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n\\t\\t\\t\\t\\t\\n            s.add(ans)\\n\\t\\t\\t\\n        return list(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380607,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        int resultSize = 1;\\n        \\n        Arrays.sort(nums);\\n        result.add(new ArrayList<>());\\n        \\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int startIndex = 0;\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                startIndex = resultSize;\\n            }\\n            \\n            resultSize = result.size();\\n            \\n            while (startIndex < resultSize) {\\n                List<Integer> list = new ArrayList<>(result.get(startIndex));\\n                \\n                list.add(nums[i]);\\n                \\n                result.add(list);\\n                \\n                startIndex++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        int resultSize = 1;\\n        \\n        Arrays.sort(nums);\\n        result.add(new ArrayList<>());\\n        \\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int startIndex = 0;\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                startIndex = resultSize;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1380270,
                "title": "subset-ii-simple-backtracking-java-solution",
                "content": "**Approach:**\\nThe Magic happens at 3 places.\\n\\n1.) Sorting the input array\\n2.) checking for duplicates\\n3.) if(i > index) condition\\n\\nSo after sorting, all the duplicates are next to each other.\\n\\nFor Example: 1,3,5,2,5,3,2,3 becomes 1,2,2,3,3,3,5,5\\n\\nAfter sorting, as per the backtracking flow we can avoid making calls to duplicate numbers because the same pattern will follow again. \\nIn case of above example,\\n1,2,3,3,3,5,5\\nThe above subset will come for both 2\\'s at index 1 and 2.\\n\\nAnd finally the condition \"if(i > index &&  nums[i] == nums[i-1])\",\\nif the condition was if(i > 0), the code will still return some duplicate subset.\\nIn order to avoid duplicate subsets, you need to set the codition from the current index position of recursion. i.e if(i > index)\\n\\nHope this was helpful.\\n\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\n\\t\\t\\tList<List<Integer>> subsetList = new ArrayList<>();\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tdfs(subsetList, nums, 0, new ArrayList<>());\\n\\n\\t\\t\\treturn subsetList;\\n\\t\\t}\\n\\n\\t\\tprivate void dfs(List<List<Integer>> subsetList, int nums[], int index, List<Integer> tempList){\\n\\n\\t\\t\\tsubsetList.add(new ArrayList<>(tempList));\\n\\n\\t\\t\\tif(index>= nums.length)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tfor(int i = index; i < nums.length; i++){\\n\\n\\t\\t\\t\\tif(i > index &&  nums[i] == nums[i-1])\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\ttempList.add(nums[i]);\\n\\t\\t\\t\\tdfs(subsetList, nums, i+1, tempList);\\n\\t\\t\\t\\ttempList.remove(tempList.size() - 1);\\n\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n\\n\\t\\t\\tList<List<Integer>> subsetList = new ArrayList<>();\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tdfs(subsetList, nums, 0, new ArrayList<>());\\n\\n\\t\\t\\treturn subsetList;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1357701,
                "title": "easy-backtracking-using-python-3",
                "content": "```\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\tnums.sort()\\n\\tres = []\\n\\tstack = [([], 0)]\\n\\tl = len(nums)\\n\\n\\twhile stack:\\n\\t\\tsub, pos = stack.pop()\\n\\t\\tres.append(sub)\\n\\t\\tlast = None\\n\\n\\t\\twhile pos<l:\\n\\t\\t\\tif nums[pos]!=last:\\n\\t\\t\\t\\tstack.append((sub+[nums[pos]], pos+1))\\n\\t\\t\\t\\tlast = nums[pos]\\n\\t\\t\\tpos+=1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\tnums.sort()\\n\\tres = []\\n\\tstack = [([], 0)]\\n\\tl = len(nums)\\n\\n\\twhile stack:\\n\\t\\tsub, pos = stack.pop()\\n\\t\\tres.append(sub)\\n\\t\\tlast = None\\n\\n\\t\\twhile pos<l:\\n\\t\\t\\tif nums[pos]!=last:\\n\\t\\t\\t\\tstack.append((sub+[nums[pos]], pos+1))\\n\\t\\t\\t\\tlast = nums[pos]\\n\\t\\t\\tpos+=1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1316241,
                "title": "c-backtracking-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void sub(vector<int>& n,vector<vector<int>>& res,vector<int>& v,int idx){\\n        for(int i=idx;i!=n.size();++i){\\n            if(i==idx || n[i]!=n[i-1]){\\n                v.push_back(n[i]);\\n                res.push_back(v);\\n                sub(n,res,v,i+1);\\n                v.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        res.push_back(v);\\n        sub(nums,res,v,0);\\n        return res;\\n    }\\n};\\n```\\n\\nWe can use `unordered_set<vector<int>>` and sort it or `set<vector<int>>` for storing the possible subsets and after the recursion store all the possible subset in 2-D array and return it but that method increase the space as well as time . That approach is basically brute because we are only storing distinct subset without doing anything . Therefore we can use the above approach , and stop for call when we have duplicate elements.\\n\\nHope you liked the solution. If you have , pls upvote it.",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sub(vector<int>& n,vector<vector<int>>& res,vector<int>& v,int idx){\\n        for(int i=idx;i!=n.size();++i){\\n            if(i==idx || n[i]!=n[i-1]){\\n                v.push_back(n[i]);\\n                res.push_back(v);\\n                sub(n,res,v,i+1);\\n                v.pop_back();\\n            }\\n            \\n        }\\n        \\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        res.push_back(v);\\n        sub(nums,res,v,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300129,
                "title": "0-ms-faster-than-100-percent-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void find(int index,vector<vector<int>>&ans,vector<int>&ds,vector<int>&nums){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1])continue;\\n            ds.push_back(nums[i]);\\n            find(i+1,ans,ds,nums);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        find(0,ans,ds,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(int index,vector<vector<int>>&ans,vector<int>&ds,vector<int>&nums){\\n        ans.push_back(ds);\\n        for(int i=index;i<nums.size();i++){\\n            if(i!=index && nums[i]==nums[i-1])continue;\\n            ds.push_back(nums[i]);\\n            find(i+1,ans,ds,nums);\\n            ds.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int>ds;\\n        find(0,ans,ds,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255330,
                "title": "c-back-tracking-bit-masking-2-methods",
                "content": "**1. Back Tracking : Runtime: 4 ms, Memory Usage: 7.4 MB**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& v, vector<vector<int>> &res, vector<int>& temp, int start)\\n    {\\n        res.push_back(temp);\\n        for(int i=start;i!=v.size();i++)\\n        {\\n            if(i==start or v[i]!=v[i-1])\\n            {\\n                temp.push_back(v[i]);\\n                helper(v,res,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n\\n        sort(arr.begin(),arr.end());\\n        vector<int> temp;\\n        vector<vector<int>> res;\\n        helper(arr,res,temp,0);\\n        return res;        \\n    }\\n};\\n```\\n\\n**2. Bit Masking: Runtime: 20 ms, Memory Usage: 12.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    map<multiset<int>,int>m;\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n        \\n        m.clear();\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<multiset<int>> ans;\\n        vector<vector<int> > res;\\n        \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            multiset<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                    temp.insert(arr[j]);\\n            }\\n            if(m[temp]==0)\\n                ans.push_back(temp);\\n            m[temp]++;\\n        }\\n        \\n        for(auto s: ans)\\n        {\\n            vector<int>temp;\\n            for(auto i: s)\\n                temp.push_back(i);\\n\\t\\t\\t\\t\\n            res.push_back(temp);\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```\\n\\n**Important :** Back Tracking returns all the unique subsets in Lexicographical order.\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& v, vector<vector<int>> &res, vector<int>& temp, int start)\\n    {\\n        res.push_back(temp);\\n        for(int i=start;i!=v.size();i++)\\n        {\\n            if(i==start or v[i]!=v[i-1])\\n            {\\n                temp.push_back(v[i]);\\n                helper(v,res,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n\\n        sort(arr.begin(),arr.end());\\n        vector<int> temp;\\n        vector<vector<int>> res;\\n        helper(arr,res,temp,0);\\n        return res;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    map<multiset<int>,int>m;\\n    vector<vector<int>> subsetsWithDup(vector<int>& arr) {\\n        \\n        m.clear();\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<multiset<int>> ans;\\n        vector<vector<int> > res;\\n        \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            multiset<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                    temp.insert(arr[j]);\\n            }\\n            if(m[temp]==0)\\n                ans.push_back(temp);\\n            m[temp]++;\\n        }\\n        \\n        for(auto s: ans)\\n        {\\n            vector<int>temp;\\n            for(auto i: s)\\n                temp.push_back(i);\\n\\t\\t\\t\\t\\n            res.push_back(temp);\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244947,
                "title": "python-and-cpp-sort-bit-masking-simple-solution",
                "content": "Python Solution : \\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        for i in range(2**n):\\n            ans = []\\n            for j in range(n):\\n                if(i&(1<<j)):\\n                    ans.append(nums[j])\\n            if(ans not in res):\\n                res.append(ans)\\n                \\n        return res\\n```\\n\\n\\nC++ Solution :\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        set<vector<int>>  res;\\n        for(int i = 0; i < (1<<n); i++){\\n            vector<int> ans;\\n            for(int bit =0; bit < n; bit++){\\n                if(i&(1<<bit)){\\n                    ans.push_back(nums[bit]);\\n                }\\n            }\\n            sort(ans.begin(), ans.end());\\n            res.insert(ans);\\n        }\\n        \\n        vector<vector<int>> r(res.begin(), res.end());\\n\\n        return r;\\n    }\\n};\\n```\\n\\n\\n\\nLike Than Upvote This",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        for i in range(2**n):\\n            ans = []\\n            for j in range(n):\\n                if(i&(1<<j)):\\n                    ans.append(nums[j])\\n            if(ans not in res):\\n                res.append(ans)\\n                \\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        set<vector<int>>  res;\\n        for(int i = 0; i < (1<<n); i++){\\n            vector<int> ans;\\n            for(int bit =0; bit < n; bit++){\\n                if(i&(1<<bit)){\\n                    ans.push_back(nums[bit]);\\n                }\\n            }\\n            sort(ans.begin(), ans.end());\\n            res.insert(ans);\\n        }\\n        \\n        vector<vector<int>> r(res.begin(), res.end());\\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221403,
                "title": "simple-java-solution",
                "content": "\\n\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        int n=nums.length;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            List<Integer> al = new ArrayList<Integer>();\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))!=0)\\n                {\\n                   al.add(nums[j]);\\n                }\\n                Collections.sort(al);\\n            }\\n            if(!res.contains(al))\\n            res.add(al);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "\\n\\tpublic List<List<Integer>> subsetsWithDup(int[] nums) \\n    {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        int n=nums.length;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            List<Integer> al = new ArrayList<Integer>();\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))!=0)\\n                {\\n                   al.add(nums[j]);\\n                }\\n                Collections.sort(al);\\n            }\\n            if(!res.contains(al))\\n            res.add(al);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1161736,
                "title": "python3-easy-solution",
                "content": "Runtime: 40 ms, faster than 45.92% of Python3 online submissions for Subsets II.\\nMemory Usage: 14.2 MB, less than 99.14% of Python3 online submissions for Subsets II.\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        for i in nums:\\n            \\n            output += [lst+[i] for lst in output if lst+[i] not in output]\\n            \\n        return output\\n\\t\\t\\nRECURSIVE APPROACH:\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        def backtrack(start,lst):\\n            if len(lst) == len(nums):\\n                return \\n            for i in range(start,len(nums)):\\n                if i>start and nums[i-1]==nums[i]:\\n                    continue\\n                output.append(lst+[nums[i]])\\n                \\n                backtrack(i+1,lst+[nums[i]])\\n        backtrack(0,[])\\n        return output",
                "solutionTags": [],
                "code": "Runtime: 40 ms, faster than 45.92% of Python3 online submissions for Subsets II.\\nMemory Usage: 14.2 MB, less than 99.14% of Python3 online submissions for Subsets II.\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        for i in nums:\\n            \\n            output += [lst+[i] for lst in output if lst+[i] not in output]\\n            \\n        return output\\n\\t\\t\\nRECURSIVE APPROACH:\\n\\n    class Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        output = [[]]\\n        \\n        nums.sort()\\n        \\n        def backtrack(start,lst):\\n            if len(lst) == len(nums):\\n                return \\n            for i in range(start,len(nums)):\\n                if i>start and nums[i-1]==nums[i]:\\n                    continue\\n                output.append(lst+[nums[i]])\\n                \\n                backtrack(i+1,lst+[nums[i]])\\n        backtrack(0,[])\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 1042854,
                "title": "python-solution-with-explanation",
                "content": "We will keep on adding stuff to result variable which will be a list of lists. The idea is that we first sort the array to just know if the current number is not same as previous number. If it is not same then it means we need to append this number to all the lists already there in result. If it is same, then in order to avoid duplicate we can only append current number to the lists which were generated(and added to result) using previous number. So we need to track previous which will contain a lists of lists generated from previous number. \\n\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n\\t\\t# Will store all unique subsets\\n        result = [[]]\\n        i = 0\\n\\t\\t# will store subsets generated by previous number\\n        prev = []\\n        while i < len(nums):\\n            temp = []\\n\\t\\t\\t# if it is first number or if current number is not same as previous number then we    know that we need to append current number to all the subsets already generated. So we make prev = result \\n            if i == 0 or nums[i] != nums[i-1]:\\n                prev = result\\n            k = len(prev)\\n            for j in range(k):\\n                tup = prev[j]\\n                temp.append(tup+[nums[i]])\\n                result.append(tup+[nums[i]])\\n            prev = temp    \\n            i += 1    \\n        return result        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n\\t\\t# Will store all unique subsets\\n        result = [[]]\\n        i = 0\\n\\t\\t# will store subsets generated by previous number\\n        prev = []\\n        while i < len(nums):\\n            temp = []\\n\\t\\t\\t# if it is first number or if current number is not same as previous number then we    know that we need to append current number to all the subsets already generated. So we make prev = result \\n            if i == 0 or nums[i] != nums[i-1]:\\n                prev = result\\n            k = len(prev)\\n            for j in range(k):\\n                tup = prev[j]\\n                temp.append(tup+[nums[i]])\\n                result.append(tup+[nums[i]])\\n            prev = temp    \\n            i += 1    \\n        return result        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 963168,
                "title": "python-3",
                "content": "\\n\\n```\\nclass Solution:\\n    def DFS(self, i, ans, res, nums):\\n        if i == len(nums):\\n            if ans not in res:\\n                res.append(ans)\\n            return res\\n        self.DFS(i+1, ans, res, nums)\\n        self.DFS(i+1, ans+[nums[i]], res, nums)\\n        \\n        \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.DFS(0, [], res, nums)\\n\\t\\treturn res",
                "solutionTags": [],
                "code": "\\n\\n```\\nclass Solution:\\n    def DFS(self, i, ans, res, nums):\\n        if i == len(nums):\\n            if ans not in res:\\n                res.append(ans)\\n            return res\\n        self.DFS(i+1, ans, res, nums)\\n        self.DFS(i+1, ans+[nums[i]], res, nums)\\n        \\n        \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.DFS(0, [], res, nums)\\n\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 926489,
                "title": "very-simple-backtrack-python-solution",
                "content": "I think (not sure) space and time complexity would be O(N*2^N), any thoughts?\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def backtrack(nums,path):\\n            res.append(path)\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                backtrack(nums[i+1:],path+[nums[i]])\\n        res=[]\\n        backtrack(sorted(nums),[])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def backtrack(nums,path):\\n            res.append(path)\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                backtrack(nums[i+1:],path+[nums[i]])\\n        res=[]\\n        backtrack(sorted(nums),[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851791,
                "title": "c-an-easy-solutions-for-subsets-i-and-subsets-ii",
                "content": "```\\n``----->>>>>>>>>>>>>>>>>>subsets I```\\n```class Solution {\\npublic:vector<vector<int>>ans;\\n    \\n    void solve(vector<int> nums,vector<int>temp,int start){\\n        ans.push_back(temp);\\n        for(int i=start;i<nums.size();i++){\\n            temp.push_back(nums[i]);\\n            solve(nums,temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>temp;\\n        solve(nums,temp,0);\\n        return ans;\\n    }\\n};\\n\\n---------->>>>>>>>>>>>>>Subsets II\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;vector<int>curr; //creating vector globally\\n    void solve(vector<int>A,int id ){\\n        ans.push_back(curr);\\n        if(id>A.size()){          //edge case\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int i=id;i<A.size();i++){\\n            if(i>id&&A[i]==A[i-1])continue;// to check for duplicates\\n            curr.push_back(A[i]);\\n            solve(A,i+1); //backtrack\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        solve(A,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n``----->>>>>>>>>>>>>>>>>>subsets I```\n```class Solution {\\npublic:vector<vector<int>>ans;\\n    \\n    void solve(vector<int> nums,vector<int>temp,int start){\\n        ans.push_back(temp);\\n        for(int i=start;i<nums.size();i++){\\n            temp.push_back(nums[i]);\\n            solve(nums,temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>temp;\\n        solve(nums,temp,0);\\n        return ans;\\n    }\\n};\\n\\n---------->>>>>>>>>>>>>>Subsets II\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;vector<int>curr; //creating vector globally\\n    void solve(vector<int>A,int id ){\\n        ans.push_back(curr);\\n        if(id>A.size()){          //edge case\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int i=id;i<A.size();i++){\\n            if(i>id&&A[i]==A[i-1])continue;// to check for duplicates\\n            curr.push_back(A[i]);\\n            solve(A,i+1); //backtrack\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        solve(A,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836880,
                "title": "c-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, int idx, vector<int>& nums, vector<int>& curr)\\n    {\\n        if(find(subset.begin(), subset.end(), curr) == subset.end())\\n            subset.push_back(curr);\\n        for(int i = idx; i < nums.size(); i++)\\n        {\\n            curr.push_back(nums[i]);\\n            dfs(subset, i+1, nums, curr);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        dfs(subset, 0, nums, curr);\\n        return subset;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, int idx, vector<int>& nums, vector<int>& curr)\\n    {\\n        if(find(subset.begin(), subset.end(), curr) == subset.end())\\n            subset.push_back(curr);\\n        for(int i = idx; i < nums.size(); i++)\\n        {\\n            curr.push_back(nums[i]);\\n            dfs(subset, i+1, nums, curr);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        dfs(subset, 0, nums, curr);\\n        return subset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654330,
                "title": "javascript-concise-recursive-solution",
                "content": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort()\\n    const powerset = [];\\n    \\n    function permute(arr, index) {\\n        powerset.push(arr)\\n        \\n        for(let i = index; i < nums.length; i++) {\\n            if(i !== index && nums[i] === nums[i-1]) continue;\\n            permute([...arr, nums[i]], i+1)\\n        }\\n    }\\n    permute([], 0);\\n    return powerset;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar subsetsWithDup = function(nums) {\\n    nums.sort()\\n    const powerset = [];\\n    \\n    function permute(arr, index) {\\n        powerset.push(arr)\\n        \\n        for(let i = index; i < nums.length; i++) {\\n            if(i !== index && nums[i] === nums[i-1]) continue;\\n            permute([...arr, nums[i]], i+1)\\n        }\\n    }\\n    permute([], 0);\\n    return powerset;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619897,
                "title": "simple-python-solution-using-set-and-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n            s.add(tuple(ans))\\n        return list(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        s = set()\\n        nums.sort()\\n        for i in range(2**len(nums)):\\n            ans = []\\n            for j in range(len(nums)):\\n                if i & (1<<j):\\n                    ans.append(nums[j])\\n            s.add(tuple(ans))\\n        return list(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576618,
                "title": "general-iterative-approach-with-queue-in-swift",
                "content": "**General Approach**\\nI prefer solving backtracking problems iteratively with a simple queue. The general approach I take:\\n1. Add element to queue\\n2. Loop over input\\n3. Loop over current queue size\\n4. Remove first element from queue\\n5. Use the removed element\\n\\n**Permutations**\\nhttps://leetcode.com/problems/permutations/\\n\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\\n\\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Permutations II**\\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\\n\\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Subset**\\nhttps://leetcode.com/problems/subsets/\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\\n\\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\\n\\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Letter Combinations of a Phone Number**\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\\n\\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking",
                    "Queue"
                ],
                "code": "```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557116,
                "title": "scala-beautifully-elegant-fold",
                "content": "```\\ndef subsetsWithDup(nums: Array[Int]): List[List[Int]] = {\\n\\tnums\\n\\t\\t.sorted\\n\\t\\t.foldLeft(Set(List.empty[Int])){ case(prev, n) =>\\n\\t\\t\\tprev ++ prev.map(_ :+ n) + List(n)\\n\\t\\t}.toList\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef subsetsWithDup(nums: Array[Int]): List[List[Int]] = {\\n\\tnums\\n\\t\\t.sorted\\n\\t\\t.foldLeft(Set(List.empty[Int])){ case(prev, n) =>\\n\\t\\t\\tprev ++ prev.map(_ :+ n) + List(n)\\n\\t\\t}.toList\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 528323,
                "title": "issac3-general-approach-to-backtracking-questions-in-cpp",
                "content": "Thanks ```Issac3``` for sharing. Here is same approach in C++. \\n\\nPermutation:\\nGiven a collection of distinct integers, return all possible permutations.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\\n\\nPermutation-II \\n\\n47. Permutations II\\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\\n\\n78. Subsets\\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\\n\\n90. Subsets II\\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\\n39. Combination Sum\\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\\n\\n40. Combination Sum II\\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```\\n131. Palindrome Partitioning\\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        backtrack(s, temp, result, 0);\\n        return result;        \\n    }\\n    \\n    void backtrack(string& s, vector<string>& temp, vector<vector<string>>& result, int start){\\n        \\n        if(start == s.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<s.size(); i++){\\n                if(isPalindrome(s, start, i)){\\n                    temp.emplace_back(s.substr(start, i-start+1));\\n                    backtrack(s, temp, result, i+1);\\n                    temp.pop_back();\\n                }\\n            }            \\n        }        \\n    }\\n    \\n    bool isPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "```Issac3```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572369,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571199,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1748905,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1781360,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1769485,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1573304,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571200,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1976912,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 2001079,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1760164,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1572369,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571199,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1748905,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1781360,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1769485,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1573304,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1571200,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1976912,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 2001079,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1760164,
                "content": [
                    {
                        "username": "pengel1",
                        "content": "Where does the output should be in sorted order?  This may need further explination or refinement."
                    },
                    {
                        "username": "TerpsX",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\nHow come [1,4,4,4] a subset for [4,4,4,1,4]??"
                    },
                    {
                        "username": "2uringTested",
                        "content": "its a subset not a subsequence so [4,4,1,4] is same as [4,4,4,1], the order does not matter and so it should only be counted once."
                    },
                    {
                        "username": "goldenwind",
                        "content": "The subset of a set A is a set that contains some elements of A or all elements of A. If it is a set, the order does not matter. [1,4,4,4] is the same as [4,1,4,4] as a set."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "proper explanation of question is not given, nums needs to be sorted."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I think you\\'re confusing subset with sub-sequence"
                    },
                    {
                        "username": "lampuiho",
                        "content": "you have [4,4,1,4], and [4,4,4,1] in your output. I fixed my code when I sorted the numbers first so that all the duplicates are grouped together. This is because my recursion relies on a position tracking parameter for skipping the duplicates in subsequent loops."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "There, the catch is to sort the nums array first.\\nThank you."
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro, helped me allot "
                    },
                    {
                        "username": "athravmehta06",
                        "content": "saved my day .. lol thanks"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fuck yAAR!THANK HYOU IT WORKED\\n"
                    },
                    {
                        "username": "srapol",
                        "content": "bro how did you come up with it ?? whats the logic??\\nP.S: it worked"
                    },
                    {
                        "username": "mochiball",
                        "content": "Facts. I was running into errors until I sorted. The weird thing is Sets don\\'t seem to account for the unsorted  "
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "thanks bro, stuff like this is why i read discussion post"
                    },
                    {
                        "username": "Oleas",
                        "content": "This problem is NOT asking for the power set of a set. It is asking for all, sorted, unique combinations of the terms in the input. This caused me a great deal of grief. This problem\\'s description should be changed to remove the power set  wording."
                    },
                    {
                        "username": "charonme",
                        "content": "This is clearly wrong. When the array contains duplicates, the duplicate elements are either the same element or they are different elements. If they are the same, then [1, 2, 2] and [1, 2] are the same subset of an array given as [1, 2, 2]. But the problem solution expects both [1, 2] and [1, 2, 2], so clearly the first 2 and the second 2 must be different elements, in which case subsets [1, 2] (with the first 2) and [1, 2] (with the second 2) should be accepted too, but they are not."
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "I went through some of the solutions to understand but why the need to sort?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You need to sort the array so, we can compare that previous element is same as current element or not. If you don\\'t sort the array, then it can\\'t find that element is same or different. ex,\\nint[] arr = {1,2,1};\\nhere you can see element at 0 index is equal to element at 2nd index.\\nIf you sort the array.  then it became \\nint[] arr = {1,1,2};\\nnow you can see that element at 0 index and 1 index are same and you can also easily write the code don\\'t run code from start. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets-ii/solutions/2986411/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "coldz",
                        "content": "Find a way to adapt subset I solution to subsets II problem."
                    },
                    {
                        "username": "rahul_jain89",
                        "content": "I think description is not clear.\\n\\nI guess they want \"each subset should be sorted and unique\".\\n\\nThat\\'s why first we need to sort to input array, so that it will generate sorted subsets,\\nAnd then we can use a set to store the subsets, it will ensure that only unique subsets will be stored to result."
                    },
                    {
                        "username": "OmarNaru",
                        "content": "Idk why we need sorting here :\\nif the given input array is : [3,2,1]\\nthe output if we didn\\'t use sort will be :\\n1\\n2\\n2 1\\n3\\n3 1\\n3 2\\n3 2 1\\n_____________________\\nbut if we used sort it will be :\\n1\\n1 2\\n1 2 3\\n1 3\\n2\\n2 3\\n3\\n\\nit\\'s literally different output, how this even works !?\\nI guess I understood something wrong in the description\\ncan anyone explain ?"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "why sorting of input array is need here?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@yadav_sahil](/yadav_sahil)  that\\'s not correct. It is because there are duplicate subsets [1,4] , [4,1] ,[4,4,1],[4,1,4] and [4,4,4,1],[4,4,1,4]. In the expected the total count of subarray is 10 while in output it is 13."
                    },
                    {
                        "username": "yadav_sahil",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\nlook in this testcase expected output there is subset 1,4,4,4 which is not possible if 4,4,4,1,4 is not sorted as there is only one 4 after 1.\\n"
                    }
                ]
            },
            {
                "id": 1572090,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1568913,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2070774,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2059050,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2052359,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2013448,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2010742,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 2009435,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1966724,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1960953,
                "content": [
                    {
                        "username": "zhanghuimeng",
                        "content": "I think it is obvious that, for an empty set, its power set should be a set containing an empty set. (`P({}) = { {} }`) \\uFF08[What is the power set of the empty set](https://www.quora.com/What-is-the-power-set-of-the-empty-set-emptyset)\\uFF09Which means, if the input is `[]`, we need to return `[[]]`. Most implementations here follow this pattern, like [this](https://leetcode.com/problems/subsets-ii/discuss/30168/C++-solution-and-explanation) and [that](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution).\\n\\nBut in the run code section, the \"Expected Answer\" doesn\\'t think so.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhanghuimeng1997/image_1534623169.png)\\n\\nThese codes above can pass, of course; when I make an special judgement for `[]` so that it outputs `[]`, I can still pass. So the OJ didn\\'t check for input `[]` at all. Also, I think there is a bug in the \"Expected Answer\" example program.\\n"
                    },
                    {
                        "username": "greatgrahambini",
                        "content": "A set is by definition, a collection of unique items."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "A set is a collection of unordered items"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Pre-requisite solve Permutation-I, Permutation-II, and Subset-I and this problem will be easy walk for you."
                    },
                    {
                        "username": "admiremeforever",
                        "content": "The problem description seems to be incorrect -"
                    },
                    {
                        "username": "ruchita1010",
                        "content": "Why is that a set results in wrong output? Given that in C++, set stores elements in sorted order! My code couldn\\'t pass from this test case - [4,4,4,1,4]. But after sorting the vector before passing it in the recursive function, it was accepted?!"
                    },
                    {
                        "username": "sk315425",
                        "content": "Input:\\n[4,4,4,1,4]\\nOutput:\\n[[],[4],[1],[1,4],[4,4],[4,1],[4,1,4],[4,4,4],[4,4,1],[4,4,1,4],[4,4,4,4],[4,4,4,1],[4,4,4,1,4]]\\nExpected:\\n[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]\\n\\narray need to be sorted for this ! \\n"
                    },
                    {
                        "username": "Tanya__",
                        "content": "provided description is incorrect\nExpected output =>return list  all sorted order and unique possible subsets"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Extremely poor question description. You need to constantly submit and find out what the question wants from the test cases instead of the description."
                    },
                    {
                        "username": "uma_gadde",
                        "content": "like seriouslyyy!!!\\nsorted ordered!! problem desc should be changed:("
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Why the function name is subsetsWithDup , it should be without right  :)"
                    }
                ]
            },
            {
                "id": 1946014,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1938381,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1935888,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1928000,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1922658,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1890598,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1848069,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1833839,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1812431,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1789409,
                "content": [
                    {
                        "username": "shivam2612002",
                        "content": "to find subsets, a simple approach is to use a pick-skip method.\\nbut when we do have to find unique subsets, do we have to use for loop?\\ni mean can we do it without loops? "
                    },
                    {
                        "username": "AshleyXM",
                        "content": "The description of this problem is sooooooo ambiguous. The number of examples is too small to clarify the problem."
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        List<Integer> a = new ArrayList<>();\\n        subsetsall(nums,0,ans,a);\\n        List<List<Integer>> d = new ArrayList<>(ans);\\n        return d;\\n\\n    }\\n    public void subsetsall (int nums[], int index, Set<List<Integer>> subsets , List<Integer> subset){\\n        if(index==nums.length){\\n            subsets.add(subset);\\n        }\\n        else{\\n            subset.add(nums[index]);\\n            subsetsall(nums,index+1,subsets,subset);\\n            subset.remove(subset.size()-1);\\n            subsetsall(nums,index+1,subsets,subset);\\n        }\\n    }\\n}\\n\\nwhy this gives empty list  why is this wrong??\\n"
                    },
                    {
                        "username": "hemanth0010",
                        "content": "//why this code is not working\\nclass Solution {\\n    public void solve(int[] nums, int i, List<Integer> ds, Set<List<Integer>> st) {\\n        if (i == nums.length) {\\n            Collections.sort(ds);\\n            st.add(ds);\\n            return;\\n        }\\n        ds.add(nums[i]);\\n        solve(nums, i + 1, ds, st);\\n        ds.remove(ds.size() - 1);\\n        solve(nums, i + 1, ds, st);\\n    }\\n\\n    public List<List<Integer>> subsetsWithDup(int nums[]) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<List<Integer>> st = new HashSet<>();\\n        List<Integer> ds = new ArrayList<>();\\n        solve(nums, 0, ds, st);\\n        for (List<Integer> v : st) {\\n            ans.add(v);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "class Solution {\\n    void findit(vector<vector<int>>& ans,int index)\\n    {\\n        vector<vector<int>>::iterator it=ans.begin()+index;\\n        if(index>=ans.size())\\n        {\\n            return;\\n        }\\n        for(int i=index;i<ans.size();i++)\\n        {\\n            if(ans[index]==ans[i])\\n            {\\n                \\n                ans.erase(it);\\n            }\\n        }\\n        findit(ans,index+1);\\n    }\\n\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int> >& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n\\n\\n        \\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        findit(ans,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\nplease help me and find out where i am doing a mistake"
                    },
                    {
                        "username": "hucancode",
                        "content": "Input need to be sorted before generating subset. It was not mentioned in the problem description."
                    },
                    {
                        "username": "pratham2712",
                        "content": "the solution is similar to the subset1 just think about duplicates.\\n\\n\\n\\nhint : set,sort"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Sorting Matters"
                    },
                    {
                        "username": "Loncey",
                        "content": "The question says \"the solution set must not contain duplicate subsets.\", but the answer expects duplicate subsets of limited nature.\nIn the first example for nums = [1, 2, 2], subsets [1,2] and [1, 2, 2] are equal so one of them shouldn't be included, but the solution expects us to include both. And if every number of the same value were to be treated as a different object, then correct answer for an array [1, 2, 2] should include all combinations [], [1], [2], [2], [1,2], [1,2], [2, 2], [1, 2, 2] which is not the case.\nThe expected answer to the given question is simply incorrect. Either the question needs to be rephrased or the expected solution has to be changed."
                    },
                    {
                        "username": "Sahil_Rana",
                        "content": "//can someone please find the problem in this code. It gives the following \\n//  output:\\n//  [[],[2],[2],[1]]\\n\\n\\nvector<vector<int>> ans;\\n\\n//ans.push_back({});\\n\\nvoid helper(vector<int>& nums, vector<int> v){\\n\\n    if(nums.size()==0){\\n        ans.push_back(v);\\n        return ;\\n    }\\n\\n    vector<int> v1=v;\\n    vector<int> v2=v;\\n     \\n     v2.push_back(nums[0]);\\n     nums.erase(nums.begin()+0);\\n\\n     helper(nums,v1);\\n     helper(nums,v2);\\n     return;\\n \\n}\\n\\n\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        \\n        vector<int> v;\\n        helper(nums,v);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Bits",
        "question_content": "<p>Reverse bits of a given 32 bits unsigned integer.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer&#39;s internal binary representation is the same, whether it is signed or unsigned.</li>\n\t<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">2&#39;s complement notation</a>. Therefore, in <strong class=\"example\">Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 00000010100101000001111010011100\n<strong>Output:</strong>    964176192 (00111001011110000010100101000000)\n<strong>Explanation: </strong>The input binary string <strong>00000010100101000001111010011100</strong> represents the unsigned integer 43261596, so return 964176192 which its binary representation is <strong>00111001011110000010100101000000</strong>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11111111111111111111111111111101\n<strong>Output:</strong>   3221225471 (10111111111111111111111111111111)\n<strong>Explanation: </strong>The input binary string <strong>11111111111111111111111111111101</strong> represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is <strong>10111111111111111111111111111111</strong>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The input must be a <strong>binary string</strong> of length <code>32</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If this function is called many times, how would you optimize it?</p>\n",
        "solutions": [
            {
                "id": 54738,
                "title": "sharing-my-2ms-java-solution-with-explanation",
                "content": "\\n\"\\nWe first intitialize result to 0. We then iterate from\\n0 to 31 (an integer has 32 bits).  In each iteration:  \\n  We first shift result to the left by 1 bit.\\n  Then, if the last digit of input n is 1, we add 1 to result. To\\n  find the last digit of n, we just do: (n & 1)\\n    Example, if n=5 (101), n&1 = 101 & 001 = 001 = 1;\\n    however, if n = 2 (10), n&1 = 10 & 01 = 00 = 0).\\n\\n  Finally, we update n by shifting it to the right by 1 (n >>= 1). This is because the last digit is already taken care of, so we need to drop it by shifting n to the right by 1.\\n\\nAt the end of the iteration, we return result.\\n\\nExample, if input n = 13 (represented in binary as\\n0000_0000_0000_0000_0000_0000_0000_1101, the \"_\" is for readability),\\ncalling reverseBits(13) should return:\\n1011_0000_0000_0000_0000_0000_0000_0000\\n\\nHere is how our algorithm would work for input n = 13:\\n\\nInitially, result = 0 = 0000_0000_0000_0000_0000_0000_0000_0000,\\nn = 13 = 0000_0000_0000_0000_0000_0000_0000_1101\\n\\nStarting for loop:\\n  i = 0:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0000.\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_1101 \\n           & 0000_0000_0000_0000_0000_0000_0000_0001 \\n           = 0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n          0000_0000_0000_0000_0000_0000_0000_0000 \\n       + 0000_0000_0000_0000_0000_0000_0000_0001 \\n       = 0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n    \\nNext, we right shift n by 1 (n >>= 1) (i.e. we drop the least significant bit) to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0110.\\n    We then go to the next iteration.\\n\\n  i = 1:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0010;\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0110 &\\n          0000_0000_0000_0000_0000_0000_0000_0001\\n        = 0000_0000_0000_0000_0000_0000_0000_0000 = 0;\\n    therefore we don't increment result.\\n    We right shift n by 1 (n >>= 1) to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0011.\\n    We then go to the next iteration.\\n\\n  i = 2:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0100.\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0011 &\\n          0000_0000_0000_0000_0000_0000_0000_0001 =\\n          0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n          0000_0000_0000_0000_0000_0000_0000_0100 +\\n          0000_0000_0000_0000_0000_0000_0000_0001 =\\n          result = 0000_0000_0000_0000_0000_0000_0000_0101\\n    We right shift n by 1 to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0001.\\n    We then go to the next iteration.\\n\\n  i = 3:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_1010. \\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0001 &\\n              0000_0000_0000_0000_0000_0000_0000_0001 =\\n              0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n                           = 0000_0000_0000_0000_0000_0000_0000_1011\\n    We right shift n by 1 to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0000 = 0.\\n\\n  Now, from here to the end of the iteration, n is 0, so (n&1)\\n  will always be 0 and and n >>=1 will not change n. The only change\\n  will be for result <<=1, i.e. shifting result to the left by 1 digit.\\n  Since there we have i=4 to i = 31 iterations left, this will result\\n  in padding 28 0's to the right of result. i.e at the end, we get\\n  result = 1011_0000_0000_0000_0000_0000_0000_0000\\n\\n  This is exactly what we expected to get\\n\"\\n\\n    \\n    public int reverseBits(int n) {\\n        if (n == 0) return 0;\\n        \\n        int result = 0;\\n        for (int i = 0; i < 32; i++) {\\n            result <<= 1;\\n            if ((n & 1) == 1) result++;\\n            n >>= 1;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "\\n\"\\nWe first intitialize result to 0. We then iterate from\\n0 to 31 (an integer has 32 bits).  In each iteration:  \\n  We first shift result to the left by 1 bit.\\n  Then, if the last digit of input n is 1, we add 1 to result. To\\n  find the last digit of n, we just do: (n & 1)\\n    Example, if n=5 (101), n&1 = 101 & 001 = 001 = 1;\\n    however, if n = 2 (10), n&1 = 10 & 01 = 00 = 0).\\n\\n  Finally, we update n by shifting it to the right by 1 (n >>= 1). This is because the last digit is already taken care of, so we need to drop it by shifting n to the right by 1.\\n\\nAt the end of the iteration, we return result.\\n\\nExample, if input n = 13 (represented in binary as\\n0000_0000_0000_0000_0000_0000_0000_1101, the \"_\" is for readability),\\ncalling reverseBits(13) should return:\\n1011_0000_0000_0000_0000_0000_0000_0000\\n\\nHere is how our algorithm would work for input n = 13:\\n\\nInitially, result = 0 = 0000_0000_0000_0000_0000_0000_0000_0000,\\nn = 13 = 0000_0000_0000_0000_0000_0000_0000_1101\\n\\nStarting for loop:\\n  i = 0:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0000.\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_1101 \\n           & 0000_0000_0000_0000_0000_0000_0000_0001 \\n           = 0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n          0000_0000_0000_0000_0000_0000_0000_0000 \\n       + 0000_0000_0000_0000_0000_0000_0000_0001 \\n       = 0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n    \\nNext, we right shift n by 1 (n >>= 1) (i.e. we drop the least significant bit) to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0110.\\n    We then go to the next iteration.\\n\\n  i = 1:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0010;\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0110 &\\n          0000_0000_0000_0000_0000_0000_0000_0001\\n        = 0000_0000_0000_0000_0000_0000_0000_0000 = 0;\\n    therefore we don't increment result.\\n    We right shift n by 1 (n >>= 1) to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0011.\\n    We then go to the next iteration.\\n\\n  i = 2:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_0100.\\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0011 &\\n          0000_0000_0000_0000_0000_0000_0000_0001 =\\n          0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n          0000_0000_0000_0000_0000_0000_0000_0100 +\\n          0000_0000_0000_0000_0000_0000_0000_0001 =\\n          result = 0000_0000_0000_0000_0000_0000_0000_0101\\n    We right shift n by 1 to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0001.\\n    We then go to the next iteration.\\n\\n  i = 3:\\n    result = result << 1 = 0000_0000_0000_0000_0000_0000_0000_1010. \\n    n&1 = 0000_0000_0000_0000_0000_0000_0000_0001 &\\n              0000_0000_0000_0000_0000_0000_0000_0001 =\\n              0000_0000_0000_0000_0000_0000_0000_0001 = 1\\n          therefore result = result + 1 =\\n                           = 0000_0000_0000_0000_0000_0000_0000_1011\\n    We right shift n by 1 to get:\\n    n = 0000_0000_0000_0000_0000_0000_0000_0000 = 0.\\n\\n  Now, from here to the end of the iteration, n is 0, so (n&1)\\n  will always be 0 and and n >>=1 will not change n. The only change\\n  will be for result <<=1, i.e. shifting result to the left by 1 digit.\\n  Since there we have i=4 to i = 31 iterations left, this will result\\n  in padding 28 0's to the right of result. i.e at the end, we get\\n  result = 1011_0000_0000_0000_0000_0000_0000_0000\\n\\n  This is exactly what we expected to get\\n\"\\n\\n    \\n    public int reverseBits(int n) {\\n        if (n == 0) return 0;\\n        \\n        int result = 0;\\n        for (int i = 0; i < 32; i++) {\\n            result <<= 1;\\n            if ((n & 1) == 1) result++;\\n            n >>= 1;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54741,
                "title": "o-1-bit-operation-c-solution-8ms",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            n = (n >> 16) | (n << 16);\\n            n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n            n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n            n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n            n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n            return n;\\n        }\\n    };\\n\\nfor 8 bit binary number *abcdefgh*, the process is as follow:\\n\\n*abcdefgh -> efghabcd -> ghefcdab -> hgfedcba*",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            n = (n >> 16) | (n << 16);\\n            n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n            n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n            n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n            n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1232842,
                "title": "java-c-0ms-o-1-time-complexity-in-place-detailed-explanation",
                "content": "<u>**COMPLEXITY**</u>\\n* **Time: O(1)**, constant time\\n* **Space: O(1)**, in-place\\n\\n\\n**BASIC IDEA**\\n\\tIn this implementation we have followed **\"Divide and Conquer\"** strategy where **Original problem is divided into sub problems**\\n\\n<iframe src=\"https://leetcode.com/playground/23MFqfwn/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nLet\\'s understand in terms of decimal number to understand how the code is implemented\\n Suppose we have a number `12345678` and we have to reverse it to get `87654321` as desired output\\nThe process will be as follows:\\n\\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`12345678` --> original number\\n1. \\t`56781234`\\n1. \\t`78563412`\\n1. \\t`87654321` --> desired number(reversed number)\\n\\nExplanation of above process is as follows:\\n\\t\\n* \\tDivide original number`(12345678)` into 2 parts(**4 - 4 each**)\\n    `1234|5678` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;&#95;&#95;&#95;|\\n\\t\\n    `5678|1234`(it can also be said that we are **right shifting** the 1st part`(1234)` **to 4 places** from its original position and **left shifting** the 2nd part`(5678)` **to 4 places** from its original position)\\n\\n*   Divide this obtained number`(56781234)` into 4 parts(**2 - 2 each**)\\n    `56|78|12|34` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;|&#95;&#95;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|\\n\\t\\n    `78|56|34|12`(it can also be said that we are **right shifting** the 1st part`(56)` and 3rd part`(12)` **to 2 places** from their original positions and **left shifting** the 2nd part`(78)` and 4th part`(34)` **to 2 places** from their original positions)\\n\\n* Divide the obtained number`(78563412)` into 8 parts(**1 - 1 each**)\\n    `7|8|5|6|3|4|1|2` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|\\n\\t\\n    `8|7|6|5|4|3|2|1`(it can also be said that we are **right shifting** the 1st part`(7)`, 3rd part`(5)`, 5th part`(3)` and 7th part`(1)`  **to 1 place** from their original positions and **left shifting** the 2nd part`(8)`, 4th part`(6)`, 6th part`(4)` and 8th part`(2)`  **to 1 place** from their original positions)\\n\\t\\n    We got the desired output as `87654321`\\n\\t<hr>\\n\\t\\n\\t**Time to play with bits!!!!!!**\\n\\t\\n\\tTo get better understanding of how the 32 bits are reversed in binary, we will take 8 bits instead of 32.\\n\\t**If the number is of 8 bits**, **the bits will be reversed in 3 steps** as we are using **Divide and Conquer** approach which is nothing **dividing the original problem into sub problems** i.e. log(O(Number_Of_Bits)) i.e. log(O(8)) --> 3 and the same Idea applies **for 32 bits** where **the bits will be reversed in 5 steps** as log(O(32)) --> 5\\n\\t\\n\\tFirst let\\'s understand with 8 bits\\n\\tSuppose we have bits as 00010111 and we have to reverse it to get 11101000 as desired output\\n\\tThe Process will be as follows:\\n\\t00010111(8 bits)  --> Original Number\\n\\t\\n1. 01110001\\n1. 11010100\\n1. 11101000  --> Reversed Numer\\n\\nExplanation of above process is as follows:\\n\\n1. Divide original bits into 4 - 4 each (4 * 2 = 8 bits)\\n`0001|0111` and swap with each other i.e.\\n&nbsp;&nbsp;|&#95;&#95;&#95;&#95;&#95;|\\n`0111|0001` (It can also be said that we are **right shifting** 1st part(first 4 bits) **to 4 places** from their original positions and **left shifting** the 2nd part(last 4 bits) **to 4 places** from their original positions)<br>\\nFollowing is the process of doing it:\\na) **Preserve 1st part(first 4 bits)** and we know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve the first 4 bits**\\n**mask = 0xf0** (which is nothing but `1111 0000` i.e. `1111`(15 == f) and 0000(0))\\n&nbsp;&nbsp;&nbsp;`0001 0111` --> num\\n&&nbsp;<u>`1111 0000`</u> --> 0xf0\\n&nbsp;&nbsp;&nbsp;`0001 0000`<br>\\nb) **Right shift** the obtained number from its original position **by 4 places** i.e. (num & 0xf0) >>> 4\\n&nbsp;&nbsp;&nbsp;&nbsp;`00000001`<br>\\nc) **Preserve the 2nd part(last 4 bits)**\\nFor this, will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve the last 4 bits**\\n**mask = 0x0f** (which is nothing but `0000 1111` i.e. `0000`(0) and `1111`(15 == f))\\n&nbsp;&nbsp;&nbsp;`0001 0111` --> num\\n&&nbsp;<u>`0000 1111`</u> --> 0x0f\\n&nbsp;&nbsp;&nbsp;`0000 0111`<br>\\nd) **Left shift** the obtained number from its original position **by 4 places** i.e. (num & 0x0f) << 4\\n &nbsp;&nbsp;&nbsp;`01110000`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers to **merge intermediate results** into a single number which is used as an input for the next step.\\n &nbsp;&nbsp;&nbsp;`0000 0001` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`0111 0000`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`0111 0001`<br>\\nf) **Assign the result into num** after apply bitwise or into num again to proceed furthur\\n&nbsp;&nbsp;&nbsp;num = `01110001`\\n\\n**Till here, 1 of 3 steps of process has been completed. 2 More remaining!!!**\\n\\n2. Divide obtained bits(`01110001`) into 2 - 2 each (2 * 4 = 8 bits)\\n`01|11|00|01` and swap with each other i.e.\\n&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|\\n`11|01|01|00` (It can also be said that we are **right shifting** 1st part(01) and 3rd part(00) **to 2 places** from their original positions and **left shifting** the 2nd part(11) and 4th part(01) **to 2 places** from their original positions)<br>\\nFollowing is the process of doing it:\\na) **Preserve 1st part(01) and 3rd part(00)** and we know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 1st part(01) and 3rd part(00)**\\n**mask = 0xcc** (which is nothing but 1100 1100 i.e. (12 == c) and (12 == c))\\n&nbsp;&nbsp;&nbsp;`01 11 00 01` --> num\\n&&nbsp;<u>`11 00 11 00`</u> --> 0xcc\\n&nbsp;&nbsp;&nbsp;`01 00 00 00`<br>\\nb) **Right shift** the obtained number(`01 00 00 00`) from its original position **by 2 places** i.e. (num & 0xcc) >>> 2\\n&nbsp;&nbsp;&nbsp;&nbsp;`00 01 00 00`<br>\\nc) **Preserve the 2nd part(11) and 4th part(01)**\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 2nd part(11) and 4th part(01)**\\n**mask = 0x33** (which is nothing but 0011 0011 i.e. 0011(3) and 0011(3))\\n&nbsp;&nbsp;&nbsp;`01 11 00 01` --> num\\n&&nbsp;<u>`00 11 00 11`</u> --> 0x33\\n&nbsp;&nbsp;&nbsp;`00 11 00 01`<br>\\nd) **Left shift** the obtained number(00 11 00 01) from its original position **by 2 places** i.e. (num & 0x33) << 2\\n &nbsp;&nbsp;&nbsp;`11 00 01 00`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers to **merge intermediate results** into a single number which is used as an input for the next step.\\n &nbsp;&nbsp;&nbsp;`00 01 00 00` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`11 00 01 00`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`11 01 01 00`<br>\\nf) **Assign the result into num** after apply bitwise or into num again to proceed furthur\\n&nbsp;&nbsp;&nbsp;num = `11010100`\\n\\n**Till here, 2 of 3 steps of process has been completed. Only 1 more to go!!!!!!!!!**\\n\\n3. Divide obtained bits(`11010100`) into 1 - 1 each (1 * 8 = 8 bits)\\n1|1|0|1|0|1|0|0 and swap with each other i.e.\\n&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|\\n1|1|1|0|1|0|0|0 (It can also be said that we are **right shifting** 1st(1), 3rd(0), 5th(0) and 7th(0) parts **to 1 place** from their original positions and **left shifting** the 2nd(1), 4th(1), 6th(1) and 8th(0) parts **to 1 place** from their original positions)<br>\\nFollowing is the process of doing it\\na) **Preserve 1st(1), 3rd(0), 5th(0) and 7th(0) parts** \\nWe know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 1st(1), 3rd(0), 5th(0) and 7th(0) parts**\\n**mask = 0xaa** (which is nothing but `1010 1010` i.e. (10 == a) and (10 == a))\\n&nbsp;&nbsp;&nbsp;`1 1 0 1 0 1 0 0` --> num\\n&&nbsp;<u>`1 0 1 0 1 0 1 0`</u> --> 0xaa\\n&nbsp;&nbsp;&nbsp;`1 0 0 0 0 0 0 0`<br>\\nb) **Right shift** the obtained number(`1 0 0 0 0 0 0 0`) from its original position **by 1 place** i.e. (num & 0xaa) >>> 1\\n&nbsp;&nbsp;&nbsp;&nbsp;`0 1 0 0 0 0 0 0`<br>\\nc) **Preserve the 2nd(1), 4th(1), 6th(1) and 8th(0) parts**\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 2nd(1), 4th(1), 6th(1) and 8th(0) parts**\\n**mask = 0x55** (which is nothing but 0101 0101 i.e. 0101(5) and 0101(5))\\n&nbsp;&nbsp;&nbsp;`1 1 0 1 0 1 0 0` --> num\\n&&nbsp;<u>`0 1 0 1 0 1 0 1`</u> --> 0x55\\n&nbsp;&nbsp;&nbsp;`0 1 0 1 0 1 0 0`<br>\\nd) **Left shift** the obtained number(0 1 0 1 0 1 0 0) from its original position **by 1 place** i.e. (num & 0x55) << 1\\n &nbsp;&nbsp;&nbsp;`1 0 1 0 1 0 0 0`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers\\n &nbsp;&nbsp;&nbsp;`0 1 0 0 0 0 0 0` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`1 0 1 0 1 0 0 0`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`1 1 1 0 1 0 0 0`<br>\\nf) **Assign the result into num** after apply bitwise or into num again\\n&nbsp;&nbsp;&nbsp;num = `11101000`\\n\\nNow, **return the num**.\\n\\n**We have finally reversed the original number i.e. `00010111` -> `11101000`**\\n<br>\\nSame idea goes for 32 bits \\neg: \\nbreak the 32 bits into half(16 - 16 each) and right shift 1st half part to 16 positions and left shift the 2nd half to 16 positions\\nbreak the 16 bits into half(8 - 8 each) and right shift to 8 positions and left shift to 8 positions\\nbreak the 8 bits into half(4 - 4 each) and right shift to 4 positions and left shift to 4 positions\\nbreak the 4 bits into half(2 - 2 each) and right shift to 2 positions and left shift to 2 positions\\nbreak the 2 bits into half(1 - 1 each) and right shift to 1 positions and left shift to 1 positions\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find this post helpful :)**\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "<u>**COMPLEXITY**</u>\\n* **Time: O(1)**, constant time\\n* **Space: O(1)**, in-place\\n\\n\\n**BASIC IDEA**\\n\\tIn this implementation we have followed **\"Divide and Conquer\"** strategy where **Original problem is divided into sub problems**\\n\\n<iframe src=\"https://leetcode.com/playground/23MFqfwn/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nLet\\'s understand in terms of decimal number to understand how the code is implemented\\n Suppose we have a number `12345678` and we have to reverse it to get `87654321` as desired output\\nThe process will be as follows:\\n\\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`12345678` --> original number\\n1. \\t`56781234`\\n1. \\t`78563412`\\n1. \\t`87654321` --> desired number(reversed number)\\n\\nExplanation of above process is as follows:\\n\\t\\n* \\tDivide original number`(12345678)` into 2 parts(**4 - 4 each**)\\n    `1234|5678` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;&#95;&#95;&#95;|\\n\\t\\n    `5678|1234`(it can also be said that we are **right shifting** the 1st part`(1234)` **to 4 places** from its original position and **left shifting** the 2nd part`(5678)` **to 4 places** from its original position)\\n\\n*   Divide this obtained number`(56781234)` into 4 parts(**2 - 2 each**)\\n    `56|78|12|34` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;|&#95;&#95;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|\\n\\t\\n    `78|56|34|12`(it can also be said that we are **right shifting** the 1st part`(56)` and 3rd part`(12)` **to 2 places** from their original positions and **left shifting** the 2nd part`(78)` and 4th part`(34)` **to 2 places** from their original positions)\\n\\n* Divide the obtained number`(78563412)` into 8 parts(**1 - 1 each**)\\n    `7|8|5|6|3|4|1|2` and swap with each other i.e.\\n\\t&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;&nbsp;&nbsp;|&#95;|\\n\\t\\n    `8|7|6|5|4|3|2|1`(it can also be said that we are **right shifting** the 1st part`(7)`, 3rd part`(5)`, 5th part`(3)` and 7th part`(1)`  **to 1 place** from their original positions and **left shifting** the 2nd part`(8)`, 4th part`(6)`, 6th part`(4)` and 8th part`(2)`  **to 1 place** from their original positions)\\n\\t\\n    We got the desired output as `87654321`\\n\\t<hr>\\n\\t\\n\\t**Time to play with bits!!!!!!**\\n\\t\\n\\tTo get better understanding of how the 32 bits are reversed in binary, we will take 8 bits instead of 32.\\n\\t**If the number is of 8 bits**, **the bits will be reversed in 3 steps** as we are using **Divide and Conquer** approach which is nothing **dividing the original problem into sub problems** i.e. log(O(Number_Of_Bits)) i.e. log(O(8)) --> 3 and the same Idea applies **for 32 bits** where **the bits will be reversed in 5 steps** as log(O(32)) --> 5\\n\\t\\n\\tFirst let\\'s understand with 8 bits\\n\\tSuppose we have bits as 00010111 and we have to reverse it to get 11101000 as desired output\\n\\tThe Process will be as follows:\\n\\t00010111(8 bits)  --> Original Number\\n\\t\\n1. 01110001\\n1. 11010100\\n1. 11101000  --> Reversed Numer\\n\\nExplanation of above process is as follows:\\n\\n1. Divide original bits into 4 - 4 each (4 * 2 = 8 bits)\\n`0001|0111` and swap with each other i.e.\\n&nbsp;&nbsp;|&#95;&#95;&#95;&#95;&#95;|\\n`0111|0001` (It can also be said that we are **right shifting** 1st part(first 4 bits) **to 4 places** from their original positions and **left shifting** the 2nd part(last 4 bits) **to 4 places** from their original positions)<br>\\nFollowing is the process of doing it:\\na) **Preserve 1st part(first 4 bits)** and we know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve the first 4 bits**\\n**mask = 0xf0** (which is nothing but `1111 0000` i.e. `1111`(15 == f) and 0000(0))\\n&nbsp;&nbsp;&nbsp;`0001 0111` --> num\\n&&nbsp;<u>`1111 0000`</u> --> 0xf0\\n&nbsp;&nbsp;&nbsp;`0001 0000`<br>\\nb) **Right shift** the obtained number from its original position **by 4 places** i.e. (num & 0xf0) >>> 4\\n&nbsp;&nbsp;&nbsp;&nbsp;`00000001`<br>\\nc) **Preserve the 2nd part(last 4 bits)**\\nFor this, will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve the last 4 bits**\\n**mask = 0x0f** (which is nothing but `0000 1111` i.e. `0000`(0) and `1111`(15 == f))\\n&nbsp;&nbsp;&nbsp;`0001 0111` --> num\\n&&nbsp;<u>`0000 1111`</u> --> 0x0f\\n&nbsp;&nbsp;&nbsp;`0000 0111`<br>\\nd) **Left shift** the obtained number from its original position **by 4 places** i.e. (num & 0x0f) << 4\\n &nbsp;&nbsp;&nbsp;`01110000`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers to **merge intermediate results** into a single number which is used as an input for the next step.\\n &nbsp;&nbsp;&nbsp;`0000 0001` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`0111 0000`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`0111 0001`<br>\\nf) **Assign the result into num** after apply bitwise or into num again to proceed furthur\\n&nbsp;&nbsp;&nbsp;num = `01110001`\\n\\n**Till here, 1 of 3 steps of process has been completed. 2 More remaining!!!**\\n\\n2. Divide obtained bits(`01110001`) into 2 - 2 each (2 * 4 = 8 bits)\\n`01|11|00|01` and swap with each other i.e.\\n&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#95;&#95;|\\n`11|01|01|00` (It can also be said that we are **right shifting** 1st part(01) and 3rd part(00) **to 2 places** from their original positions and **left shifting** the 2nd part(11) and 4th part(01) **to 2 places** from their original positions)<br>\\nFollowing is the process of doing it:\\na) **Preserve 1st part(01) and 3rd part(00)** and we know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 1st part(01) and 3rd part(00)**\\n**mask = 0xcc** (which is nothing but 1100 1100 i.e. (12 == c) and (12 == c))\\n&nbsp;&nbsp;&nbsp;`01 11 00 01` --> num\\n&&nbsp;<u>`11 00 11 00`</u> --> 0xcc\\n&nbsp;&nbsp;&nbsp;`01 00 00 00`<br>\\nb) **Right shift** the obtained number(`01 00 00 00`) from its original position **by 2 places** i.e. (num & 0xcc) >>> 2\\n&nbsp;&nbsp;&nbsp;&nbsp;`00 01 00 00`<br>\\nc) **Preserve the 2nd part(11) and 4th part(01)**\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 2nd part(11) and 4th part(01)**\\n**mask = 0x33** (which is nothing but 0011 0011 i.e. 0011(3) and 0011(3))\\n&nbsp;&nbsp;&nbsp;`01 11 00 01` --> num\\n&&nbsp;<u>`00 11 00 11`</u> --> 0x33\\n&nbsp;&nbsp;&nbsp;`00 11 00 01`<br>\\nd) **Left shift** the obtained number(00 11 00 01) from its original position **by 2 places** i.e. (num & 0x33) << 2\\n &nbsp;&nbsp;&nbsp;`11 00 01 00`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers to **merge intermediate results** into a single number which is used as an input for the next step.\\n &nbsp;&nbsp;&nbsp;`00 01 00 00` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`11 00 01 00`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`11 01 01 00`<br>\\nf) **Assign the result into num** after apply bitwise or into num again to proceed furthur\\n&nbsp;&nbsp;&nbsp;num = `11010100`\\n\\n**Till here, 2 of 3 steps of process has been completed. Only 1 more to go!!!!!!!!!**\\n\\n3. Divide obtained bits(`11010100`) into 1 - 1 each (1 * 8 = 8 bits)\\n1|1|0|1|0|1|0|0 and swap with each other i.e.\\n&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|&nbsp;&nbsp;|&#95;|\\n1|1|1|0|1|0|0|0 (It can also be said that we are **right shifting** 1st(1), 3rd(0), 5th(0) and 7th(0) parts **to 1 place** from their original positions and **left shifting** the 2nd(1), 4th(1), 6th(1) and 8th(0) parts **to 1 place** from their original positions)<br>\\nFollowing is the process of doing it\\na) **Preserve 1st(1), 3rd(0), 5th(0) and 7th(0) parts** \\nWe know the property of bitwise and(&) opertor i.e. 0, 1 -> 0 and 1, 1 -> 1\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 1st(1), 3rd(0), 5th(0) and 7th(0) parts**\\n**mask = 0xaa** (which is nothing but `1010 1010` i.e. (10 == a) and (10 == a))\\n&nbsp;&nbsp;&nbsp;`1 1 0 1 0 1 0 0` --> num\\n&&nbsp;<u>`1 0 1 0 1 0 1 0`</u> --> 0xaa\\n&nbsp;&nbsp;&nbsp;`1 0 0 0 0 0 0 0`<br>\\nb) **Right shift** the obtained number(`1 0 0 0 0 0 0 0`) from its original position **by 1 place** i.e. (num & 0xaa) >>> 1\\n&nbsp;&nbsp;&nbsp;&nbsp;`0 1 0 0 0 0 0 0`<br>\\nc) **Preserve the 2nd(1), 4th(1), 6th(1) and 8th(0) parts**\\nFor this, we will take a mask in **hexadecimal form** and **apply bitwise and(&) to preserve 2nd(1), 4th(1), 6th(1) and 8th(0) parts**\\n**mask = 0x55** (which is nothing but 0101 0101 i.e. 0101(5) and 0101(5))\\n&nbsp;&nbsp;&nbsp;`1 1 0 1 0 1 0 0` --> num\\n&&nbsp;<u>`0 1 0 1 0 1 0 1`</u> --> 0x55\\n&nbsp;&nbsp;&nbsp;`0 1 0 1 0 1 0 0`<br>\\nd) **Left shift** the obtained number(0 1 0 1 0 1 0 0) from its original position **by 1 place** i.e. (num & 0x55) << 1\\n &nbsp;&nbsp;&nbsp;`1 0 1 0 1 0 0 0`<br>\\n e) **Do the bitwise OR(|)** operation on both shifted numbers\\n &nbsp;&nbsp;&nbsp;`0 1 0 0 0 0 0 0` --> number obtained by right shift at step b)\\n |&nbsp;&nbsp;<u>`1 0 1 0 1 0 0 0`</u> --> number obtained by left shift at step d)\\n &nbsp;&nbsp;&nbsp;`1 1 1 0 1 0 0 0`<br>\\nf) **Assign the result into num** after apply bitwise or into num again\\n&nbsp;&nbsp;&nbsp;num = `11101000`\\n\\nNow, **return the num**.\\n\\n**We have finally reversed the original number i.e. `00010111` -> `11101000`**\\n<br>\\nSame idea goes for 32 bits \\neg: \\nbreak the 32 bits into half(16 - 16 each) and right shift 1st half part to 16 positions and left shift the 2nd half to 16 positions\\nbreak the 16 bits into half(8 - 8 each) and right shift to 8 positions and left shift to 8 positions\\nbreak the 8 bits into half(4 - 4 each) and right shift to 4 positions and left shift to 4 positions\\nbreak the 4 bits into half(2 - 2 each) and right shift to 2 positions and left shift to 2 positions\\nbreak the 2 bits into half(1 - 1 each) and right shift to 1 positions and left shift to 1 positions\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find this post helpful :)**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 54746,
                "title": "java-solution-and-optimization",
                "content": "The Java solution is straightforward, just bitwise operation:\\n\\n    public int reverseBits(int n) {\\n        int result = 0;\\n        for (int i = 0; i < 32; i++) {\\n            result += n & 1;\\n            n >>>= 1;   // CATCH: must do unsigned shift\\n            if (i < 31) // CATCH: for last digit, don't shift!\\n                result <<= 1;\\n        }\\n        return result;\\n    }\\n\\nHow to optimize if this function is called multiple times? We can divide an int into 4 bytes, and reverse each byte then combine into an int. For each byte, we can use cache to improve performance.\\n\\n    // cache\\n    private final Map<Byte, Integer> cache = new HashMap<Byte, Integer>();\\n    public int reverseBits(int n) {\\n        byte[] bytes = new byte[4];\\n        for (int i = 0; i < 4; i++) // convert int into 4 bytes\\n            bytes[i] = (byte)((n >>> 8*i) & 0xFF);\\n        int result = 0;\\n        for (int i = 0; i < 4; i++) {\\n            result += reverseByte(bytes[i]); // reverse per byte\\n            if (i < 3)\\n                result <<= 8;\\n        }\\n        return result;\\n    }\\n    \\n    private int reverseByte(byte b) {\\n        Integer value = cache.get(b); // first look up from cache\\n        if (value != null)\\n            return value;\\n        value = 0;\\n        // reverse by bit\\n        for (int i = 0; i < 8; i++) {\\n            value += ((b >>> i) & 1);\\n            if (i < 7)\\n                value <<= 1;\\n        }\\n        cache.put(b, value);\\n        return value;\\n    }",
                "solutionTags": [],
                "code": "The Java solution is straightforward, just bitwise operation:\\n\\n    public int reverseBits(int n) {\\n        int result = 0;\\n        for (int i = 0; i < 32; i++) {\\n            result += n & 1;\\n            n >>>= 1;   // CATCH: must do unsigned shift\\n            if (i < 31) // CATCH: for last digit, don't shift!\\n                result <<= 1;\\n        }\\n        return result;\\n    }\\n\\nHow to optimize if this function is called multiple times? We can divide an int into 4 bytes, and reverse each byte then combine into an int. For each byte, we can use cache to improve performance.\\n\\n    // cache\\n    private final Map<Byte, Integer> cache = new HashMap<Byte, Integer>();\\n    public int reverseBits(int n) {\\n        byte[] bytes = new byte[4];\\n        for (int i = 0; i < 4; i++) // convert int into 4 bytes\\n            bytes[i] = (byte)((n >>> 8*i) & 0xFF);\\n        int result = 0;\\n        for (int i = 0; i < 4; i++) {\\n            result += reverseByte(bytes[i]); // reverse per byte\\n            if (i < 3)\\n                result <<= 8;\\n        }\\n        return result;\\n    }\\n    \\n    private int reverseByte(byte b) {\\n        Integer value = cache.get(b); // first look up from cache\\n        if (value != null)\\n            return value;\\n        value = 0;\\n        // reverse by bit\\n        for (int i = 0; i < 8; i++) {\\n            value += ((b >>> i) & 1);\\n            if (i < 7)\\n                value <<= 1;\\n        }\\n        cache.put(b, value);\\n        return value;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54760,
                "title": "my-3ms-pure-c-solution",
                "content": "    uint32_t reverseBits(uint32_t n) {\\n        uint32_t m = 0;\\n        for (int i = 0; i < 32; i++, n >>= 1) {\\n            m <<= 1;\\n            m |= n & 1;\\n        }\\n        return m;\\n    }\\n\\nThe process is straightforward, just iterate over all bits.",
                "solutionTags": [],
                "code": "    uint32_t reverseBits(uint32_t n) {\\n        uint32_t m = 0;\\n        for (int i = 0; i < 32; i++, n >>= 1) {\\n            m <<= 1;\\n            m |= n & 1;\\n        }\\n        return m;\\n    }\\n\\nThe process is straightforward, just iterate over all bits.",
                "codeTag": "Unknown"
            },
            {
                "id": 54748,
                "title": "ac-python-44-ms-solution-bit-manipulation",
                "content": "    def reverseBits(self, n):\\n        ans = 0\\n        for i in xrange(32):\\n            ans = (ans << 1) + (n & 1)\\n            n >>= 1\\n        return ans\\n\\n\\n    # 600 / 600 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 98.59%\\n\\n\\n\\nJust generate the answer bit by bit, do not use things like \"% 2\" or \"2 ** k\" or \"bin\". Bit manipulation is a lot faster. One small thing is the plus operator can be replaced by \"bitwise or\", aka \"|\". However i found plus is more readable and fast in python.",
                "solutionTags": [],
                "code": "    def reverseBits(self, n):\\n        ans = 0\\n        for i in xrange(32):\\n            ans = (ans << 1) + (n & 1)\\n            n >>= 1\\n        return ans\\n\\n\\n    # 600 / 600 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 98.59%\\n\\n\\n\\nJust generate the answer bit by bit, do not use things like \"% 2\" or \"2 ** k\" or \"bin\". Bit manipulation is a lot faster. One small thing is the plus operator can be replaced by \"bitwise or\", aka \"|\". However i found plus is more readable and fast in python.",
                "codeTag": "Python3"
            },
            {
                "id": 54772,
                "title": "the-concise-c-solution-9ms",
                "content": "    class Solution {\\n    public:\\n        uint32_t  reverseBits(uint32_t n) {\\n            uint32_t result= 0;\\n            for(int i=0; i<32; i++)\\n                result = (result<<1) + (n>>i &1);\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t  reverseBits(uint32_t n) {\\n            uint32_t result= 0;\\n            for(int i=0; i<32; i++)\\n                result = (result<<1) + (n>>i &1);\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 732138,
                "title": "python-o-32-simple-solution-explained",
                "content": "We are asked to reverse bits in our number. What is the most logical way to do it? Create number `out`, process original number bit by bit from end and add this bit to the end of our `out` number, and that is all! Why it is works? \\n1. `out = (out << 1)^(n & 1)` adds last bit of `n` to `out`\\n2. `n >>= 1` removes last bit from `n`.\\n\\nImagine number `n = 11011010`, and `out = 0`\\n1. `out = 0`, `n = 1101101`\\n2. `out = 01`, `n = 110110`\\n3. `out = 010`, `n = 11011`\\n4. `out = 0101`, `n = 1101`\\n5. `out = 01011`, `n = 110`\\n6. `out = 010110`, `n = 11`\\n7. `out = 0101101`, `n = 1`\\n8. `out = 01011011`, `n = 0` \\n\\n**Compexity**: time complexity is `O(32)`, space complexity is `O(1)`.\\n\\n**Follow up** There is `O(5)` smart solution which quite impressive, see the most voted post in discussion by @tworuler. We also can hash some `8`-bits parts, so we can inverse `4` parts on the fly, with time complexity `O(4)` and memory complexity `O(256)` (and preprocessing `O(256)` as well).\\n\\n\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        out = 0\\n        for i in range(32):\\n            out = (out << 1)^(n & 1)\\n            n >>= 1\\n        return out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n):\\n        out = 0\\n        for i in range(32):\\n            out = (out << 1)^(n & 1)\\n            n >>= 1\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55011,
                "title": "javascript-solution",
                "content": "    var reverseBits = function(n) {\\n      var result = 0;\\n      var count = 32;\\n    \\n      while (count--) {\\n        result *= 2;\\n        result += n & 1;\\n        n = n >> 1;\\n      }\\n      return result;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var reverseBits = function(n) {\\n      var result = 0;\\n      var count = 32;\\n    \\n      while (count--) {\\n        result *= 2;\\n        result += n & 1;\\n        n = n >> 1;\\n      }\\n      return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 54740,
                "title": "python-ac-with-63ms-3lines",
                "content": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n        def reverseBits(self, n):\\n            oribin='{0:032b}'.format(n)\\n            reversebin=oribin[::-1]\\n            return int(reversebin,2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n        def reverseBits(self, n):\\n            oribin='{0:032b}",
                "codeTag": "Java"
            },
            {
                "id": 1334532,
                "title": "c-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            res <<= 1;\\n            res += n % 2;\\n            n >>= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            res <<= 1;\\n            res += n % 2;\\n            n >>= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791099,
                "title": "python-3-40ms-real-bit-manipulation-solution",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res = 0\\n        for _ in range(32):\\n            res = (res<<1) + (n&1)\\n            n>>=1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res = 0\\n        for _ in range(32):\\n            res = (res<<1) + (n&1)\\n            n>>=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54938,
                "title": "a-short-simple-java-solution",
                "content": "public int reverseBits(int n) {\\n\\n        int res=0;\\n        for(int i=0;i<32;i++){\\n        \\tres= ( res << 1 ) | ( n & 1 );         \\n        \\tn = n >> 1;                  \\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int reverseBits(int n) {\\n\\n        int res=0;\\n        for(int i=0;i<32;i++){\\n        \\tres= ( res << 1 ) | ( n & 1 );         \\n        \\tn = n >> 1;                  \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54950,
                "title": "concise-java-solution",
                "content": "     public int reverseBits(int n) {\\n\\t  int result = 0;\\n\\t  for (int i = 0; i < 32; ++i) {\\n\\t    result = result<<1  | (n & 1);\\n\\t    n >>>= 1;\\n\\t  }\\n\\treturn result;  }",
                "solutionTags": [],
                "code": "     public int reverseBits(int n) {\\n\\t  int result = 0;\\n\\t  for (int i = 0; i < 32; ++i) {\\n\\t    result = result<<1  | (n & 1);\\n\\t    n >>>= 1;\\n\\t  }\\n\\treturn result;  }",
                "codeTag": "Unknown"
            },
            {
                "id": 55042,
                "title": "8ms-c-code-some-ideas-about-optimization-spoiler",
                "content": "The key idea of the optimization is to look up a 4 bit chuck and find out what the reverse is. For example, reverse of 0001 is 1000 (in decimal reverse of 1 is 8). Another example, reverse of 1010 is 0101, meaning reverse of 10 is 5. \\n\\nBased on this idea we could create a look up table:\\n\\nvalue -> reverse\\n\\n0  ------>  0\\n\\n1  ------> 8\\n\\n... ------> ...\\n\\n15 ------> 15\\n\\nThis can be further optimized by using bytes lookup table of size 256 but I am too lazy to generate the table : ).  Note, place the table initialization outside the reverseBits() routine is necessary for performance.\\n\\n\\nIn theory, using look up table may improve the performance as we are dealing with 4 bits each time. Comparing to the method that iteratively swaps two bits each time, the method below should be faster.\\nGiven the 600 test cases, the performance difference is not dramatic though.\\n\\n\\n\\nDuring each iteration, shift the output 4 bits to the left, and discard the lowest 4 bits from the input. Make sure the reverse of current lowest 4 bits is saved to the current highest 4 bits in the output. \\n\\n\\n\\n    char tb[16] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};\\n\\n    uint32_t reverseBits(uint32_t n) {\\n            int curr = 0;\\n            uint32_t ret = 0;\\n            uint32_t msk = 0xF;\\n            for(int i = 0; i< 8; i++) {\\n                ret = ret << 4;\\n                curr = msk&n;\\n                ret |= tb[curr];\\n                n = n >> 4;\\n            }\\n            return ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "The key idea of the optimization is to look up a 4 bit chuck and find out what the reverse is. For example, reverse of 0001 is 1000 (in decimal reverse of 1 is 8). Another example, reverse of 1010 is 0101, meaning reverse of 10 is 5. \\n\\nBased on this idea we could create a look up table:\\n\\nvalue -> reverse\\n\\n0  ------>  0\\n\\n1  ------> 8\\n\\n... ------> ...\\n\\n15 ------> 15\\n\\nThis can be further optimized by using bytes lookup table of size 256 but I am too lazy to generate the table : ).  Note, place the table initialization outside the reverseBits() routine is necessary for performance.\\n\\n\\nIn theory, using look up table may improve the performance as we are dealing with 4 bits each time. Comparing to the method that iteratively swaps two bits each time, the method below should be faster.\\nGiven the 600 test cases, the performance difference is not dramatic though.\\n\\n\\n\\nDuring each iteration, shift the output 4 bits to the left, and discard the lowest 4 bits from the input. Make sure the reverse of current lowest 4 bits is saved to the current highest 4 bits in the output. \\n\\n\\n\\n    char tb[16] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};\\n\\n    uint32_t reverseBits(uint32_t n) {\\n            int curr = 0;\\n            uint32_t ret = 0;\\n            uint32_t msk = 0xF;\\n            for(int i = 0; i< 8; i++) {\\n                ret = ret << 4;\\n                curr = msk&n;\\n                ret |= tb[curr];\\n                n = n >> 4;\\n            }\\n            return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54765,
                "title": "one-line-solution-in-python",
                "content": "I love Python! It has such a lot of cool features with string manipulation, such as slicing.\\n\\n    def reverseBits(self, n):\\n        return int(bin(n)[2:].zfill(32)[::-1], 2)\\n\\nRuntime is 52ms. Slower than most solutions posted here though. I'm just trying to get my hands dirty on Python :)",
                "solutionTags": [],
                "code": "I love Python! It has such a lot of cool features with string manipulation, such as slicing.\\n\\n    def reverseBits(self, n):\\n        return int(bin(n)[2:].zfill(32)[::-1], 2)\\n\\nRuntime is 52ms. Slower than most solutions posted here though. I'm just trying to get my hands dirty on Python :)",
                "codeTag": "Python3"
            },
            {
                "id": 2680791,
                "title": "handwritten-solution",
                "content": "![image](https://assets.leetcode.com/users/images/0f627884-02ec-42ef-bffe-e79fe6b08cd4_1665309768.1695473.jpeg)\\n![image](https://assets.leetcode.com/users/images/30ef3d02-0e36-4dd2-976b-305e6be99d30_1665309849.1929986.jpeg)\\n![image](https://assets.leetcode.com/users/images/53f628b4-6a5f-49d9-a59e-40e47b069473_1665309881.6886282.jpeg)\\n**\\n//CODE-\\n\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n\\t\\n       int ans = 0;\\n        for(int i=0;i<32;i++){\\n            int lsb = n & 1 ;\\n            int temp= lsb<<(31-i);\\n            ans = ans|temp;\\n            n = n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n\\t\\n       int ans = 0;\\n        for(int i=0;i<32;i++){\\n            int lsb = n & 1 ;\\n            int temp= lsb<<(31-i);\\n            ans = ans|temp;\\n            n = n>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2089559,
                "title": "python-fast-beginer-freendly",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**SOME PYTHON FUNCTIONS**\\n\\n* ```bin(n)``` -> Converts a decimal to binary, Result is returned as a string with ```0b``` as a prefix. \\n**EG**-> ```bin(7) -> \"0b111\"```\\n\\n* ```s=s[i:]``` ->String slicing -> It return the substring starting from index ```i```. \\n**EG**-> ```s=\"0b111\" -> s[2:] = \"111\"```\\n\\n* ```s=s[::-1]``` ->String slicing -> With no two initial arguments, it reverses the string. \\n**EG** -> ```s=\"0101\", s[::-1]=\"1010\"```\\n\\n* ```int(s,2)```->converts a binary string to a decimal number. \\n**EG**-> ```int(\"101\",2) = 5```\\n\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        s=bin(n)\\n        s=s[2:]\\n        s=s[::-1] + (\"0\"*(32-len(s)))\\n        return int(s,2)\\n\\t\\t\\n\\t\\t#  (\"0\"*(32-len(s))) is added to reversed string AS WE ARE TO ASSUME INITIAL NUMBER IS 32 bit, so all preceding zeroes will now be at end.\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4049293b-de11-4b60-9320-cd56c5bbcf44_1657465280.5308366.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```bin(n)```\n```0b```\n```bin(7) -> \"0b111\"```\n```s=s[i:]```\n```i```\n```s=\"0b111\" -> s[2:] = \"111\"```\n```s=s[::-1]```\n```s=\"0101\", s[::-1]=\"1010\"```\n```int(s,2)```\n```int(\"101\",2) = 5```\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        s=bin(n)\\n        s=s[2:]\\n        s=s[::-1] + (\"0\"*(32-len(s)))\\n        return int(s,2)\\n\\t\\t\\n\\t\\t#  (\"0\"*(32-len(s))) is added to reversed string AS WE ARE TO ASSUME INITIAL NUMBER IS 32 bit, so all preceding zeroes will now be at end.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795526,
                "title": "java-bit-manipulation-easy",
                "content": "### **Please Upvote** :D\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int rev = 0;\\n        for (int i = 0; i < 32; i++) {\\n            rev <<= 1;\\n            rev |= (n & 1);\\n            n >>= 1;\\n        }\\n        return rev;\\n    }\\n}\\n\\n// TC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int rev = 0;\\n        for (int i = 0; i < 32; i++) {\\n            rev <<= 1;\\n            rev |= (n & 1);\\n            n >>= 1;\\n        }\\n        return rev;\\n    }\\n}\\n\\n// TC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218837,
                "title": "190-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can reverse bits of a given number by iterating over all bits of the given number and adding the bits in the reverse order. To reverse the bits, we can use a variable and left shift it by 1 in each iteration. We can then add the last bit of the given number to the reversed number by performing an AND operation with the last bit of the given number. Once we add the last bit of the given number, we can right shift the given number by 1 to remove the last bit.\\n\\nAlgorithm:\\n\\n1. Initialize the reversed number to 0.\\n2. Iterate over all 32 bits of the given number.\\n3. In each iteration, left shift the reversed number by 1 and add the last bit of the given number to it.\\n4. To add the last bit of the given number to the reversed number, perform an AND operation with the given number and 1.\\n5. Right shift the given number by 1 to remove the last bit.\\n6. Repeat steps 3-5 for all 32 bits of the given number.\\n7. Return the reversed number.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the above algorithm is O(1) as we are iterating over all 32 bits of the given number.\\n73.76%\\n\\n- Space complexity:\\nThe space complexity of the above algorithm is O(1) as we are not using any extra data structures to store the intermediate results.\\n91.81%\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        # Initialize the reversed number to 0\\n        reversed_num = 0\\n        \\n        # Iterate over all 32 bits of the given number\\n        for i in range(32):\\n            # Left shift the reversed number by 1 and add the last bit of the given number to it\\n            reversed_num = (reversed_num << 1) | (n & 1)\\n            # To add the last bit of the given number to the reversed number, perform an AND operation with the given number and 1\\n            n >>= 1\\n        \\n        # Return the reversed number\\n        return reversed_num\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        # Initialize the reversed number to 0\\n        reversed_num = 0\\n        \\n        # Iterate over all 32 bits of the given number\\n        for i in range(32):\\n            # Left shift the reversed number by 1 and add the last bit of the given number to it\\n            reversed_num = (reversed_num << 1) | (n & 1)\\n            # To add the last bit of the given number to the reversed number, perform an AND operation with the given number and 1\\n            n >>= 1\\n        \\n        # Return the reversed number\\n        return reversed_num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54932,
                "title": "three-different-solutions-in-python",
                "content": "    class Solution(object):\\n        # Pythonic way, easy to understand.\\n        def reverseBits(self, n):\\n            bit_str = '{0:032b}'.format(n)\\n            reverse_str = bit_str[::-1]\\n            return int(reverse_str, 2)\\n    \\n        # General way, easy to understand.\\n        def reverseBits_1(self, n):\\n            reversed = 0\\n            for i in range(32):\\n                reversed = reversed << 1\\n                reversed |= (n >> i) & 0x1\\n            return reversed\\n    \\n        \"\"\"\\n        Divide and Conquer!  Someway like merge sort.\\n        For example, if there are 8 bit binary number abcdefgh,\\n        the process is as follow:\\n        abcdefgh -> efghabcd -> ghefcdab -> hgfedcba\\n        \"\"\"\\n        def reverseBits_2(self, n):\\n            # For python, there is no 32bit int, so we need to force it 32 bits.\\n            n = (n >> 16) | (n << 16) & 0xffffffff\\n            n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8) & 0xffffffff\\n            n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4) & 0xffffffff\\n            n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2) & 0xffffffff\\n            n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1) & 0xffffffff\\n            return n\\n\\n Refer to: https://leetcode.com/discuss/27405/o-1-bit-operation-c-solution-8ms",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "class Solution(object):\\n        # Pythonic way, easy to understand.\\n        def reverseBits(self, n):\\n            bit_str = '{0:032b}",
                "codeTag": "Java"
            },
            {
                "id": 1555748,
                "title": "java-tc-o-1-sc-o-1-two-simple-approaches-using-bit-manipulation",
                "content": "**Use masks to select the desired bits and shift them to generate the result**\\n```java\\n/**\\n * Mask and Shift\\n *\\n * Time Complexity: O(1)\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        // Swap 16 bits <--> 16 bits\\n        n = (n >>> 16) | (n << 16);\\n\\t\\t\\n        // Swap 8 bits <--> 8 bits\\n        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);\\n        \\n\\t\\t// Swap 4 bits <--> 4 bits\\n        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);\\n        \\n\\t\\t// Swap 2 bits <--> 2 bits\\n        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);\\n        \\n\\t\\t// Swap 1 bits <--> 1 bits\\n        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);\\n\\n        return n;\\n    }\\n}\\n```\\n\\n---\\n**Reverse Bit by Bit. This solution can take maximum 32 iterations**\\n```java\\n/**\\n * Bit by Bit\\n *\\n * Time Complexity: O(32) = O(1)\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int power = 31;\\n\\n        while (n != 0) {\\n            result |= (n & 1) << power;\\n            n >>>= 1;\\n            power--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```java\\n/**\\n * Mask and Shift\\n *\\n * Time Complexity: O(1)\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        // Swap 16 bits <--> 16 bits\\n        n = (n >>> 16) | (n << 16);\\n\\t\\t\\n        // Swap 8 bits <--> 8 bits\\n        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);\\n        \\n\\t\\t// Swap 4 bits <--> 4 bits\\n        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);\\n        \\n\\t\\t// Swap 2 bits <--> 2 bits\\n        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);\\n        \\n\\t\\t// Swap 1 bits <--> 1 bits\\n        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);\\n\\n        return n;\\n    }\\n}\\n```\n```java\\n/**\\n * Bit by Bit\\n *\\n * Time Complexity: O(32) = O(1)\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int power = 31;\\n\\n        while (n != 0) {\\n            result |= (n & 1) << power;\\n            n >>>= 1;\\n            power--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54873,
                "title": "java-two-methods-using-string-or-bit-operation-6ms-and-2ms-easy-understand",
                "content": "`method1 : using String, 6ms`\\n\\n    //\\u65b9\\u6cd51\\uff1a\\u4f7f\\u7528\\u5b57\\u7b26\\u4e32(\\u6ce8\\u610f-1\\uff1affffffff\\u6700\\u540e\\u4e00\\u6b65r=Inteter.MAX_VALUE+(1<<31)\\u662fMIN_VALUE,\\u7ed3\\u679c\\u521a\\u597d\\u8fd8\\u662f-1)\\n        public int reverseBits(int n) {\\n        \\tStringBuffer sb = new StringBuffer();\\n        \\tString s = Integer.toBinaryString(n);\\n        \\tfor(int i = 0; i < 32-s.length(); i++)\\n        \\t\\tsb.append('0');\\n        \\ts = sb.toString() + s;\\n            char[]  c = s.toCharArray();\\n            int r = 0;\\n            for(int i = 0; i < 32; i++){\\n            \\tif(c[i] == '1')\\n            \\t\\tr += (1 << i);\\n            }\\n            return r;\\n        }\\n`method2:using bit opeeation, 2ms`\\n\\n    //\\u65b9\\u6cd52\\uff1a\\u4f7f\\u7528\\u4f4d\\u64cd\\u4f5c\\n    \\tpublic int reverseBits2(int n){\\n    \\t\\tn = ((n & 0xAAAAAAAA ) >>> 1) | ((n & 0x55555555) << 1);\\n    \\t\\tn = ((n & 0xCCCCCCCC ) >>> 2) | ((n & 0x33333333) << 2);\\n    \\t\\tn = ((n & 0xf0f0f0f0 ) >>> 4) | ((n & 0x0f0f0f0f) << 4);\\n    \\t\\tn = ((n & 0xff00ff00 ) >>> 8) | ((n & 0x00ff00ff) << 8);\\n    \\t\\tn = ((n & 0xffff0000 ) >>> 16) | ((n & 0x0000ffff) << 16);\\n    \\t\\treturn n;\\n    \\t}\\n\\n         /*\\n    \\t * \\u5229\\u7528\\u9ad8\\u5730\\u4f4d\\u4ea4\\u6362\\u5b9e\\u73b0\\u9006\\u5e8f\\n    \\t * \\u4e24\\u4f4d\\u4e00\\u7ec4\\uff0c\\u9ad8\\u4f4e\\u4f4d\\u4e92\\u6362\\uff0c\\u65b9\\u6cd5\\u662f\\uff08\\u53d6\\u5947\\u6570\\u4f4d\\uff0c\\u5076\\u6570\\u4f4d\\u88650\\uff0c\\u53f3\\u79fb1\\u4f4d\\uff09| \\uff08\\u53d6\\u5076\\u6570\\u4e3a\\uff0c\\u5947\\u6570\\u4f4d\\u88650\\uff0c\\u5de6\\u79fb1\\u4f4d\\uff09\\n    \\t * \\u4f9d\\u6b21\\u56db\\u4f4d\\u4e00\\u7ec4\\uff0c\\u516b\\u4f4d\\u4e00\\u7ec4\\uff0c\\u5341\\u516d\\u4f4d\\u4e00\\u7ec4\\uff0c\\u4e09\\u5341\\u4e8c\\u4f4d\\u4e00\\u7ec4\\n    \\t * \\u7531\\u4e8e\\u662f\\u65e0\\u7b26\\u53f7\\u4f4d\\uff0c\\u6240\\u4ee5\\u6ce8\\u610f\\u5f97\\u662f\\u903b\\u8f91\\u53f3\\u79fb\\n    \\t */",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "`method1 : using String, 6ms`\\n\\n    //\\u65b9\\u6cd51\\uff1a\\u4f7f\\u7528\\u5b57\\u7b26\\u4e32(\\u6ce8\\u610f-1\\uff1affffffff\\u6700\\u540e\\u4e00\\u6b65r=Inteter.MAX_VALUE+(1<<31)\\u662fMIN_VALUE,\\u7ed3\\u679c\\u521a\\u597d\\u8fd8\\u662f-1)\\n        public int reverseBits(int n) {\\n        \\tStringBuffer sb = new StringBuffer();\\n        \\tString s = Integer.toBinaryString(n);\\n        \\tfor(int i = 0; i < 32-s.length(); i++)\\n        \\t\\tsb.append('0');\\n        \\ts = sb.toString() + s;\\n            char[]  c = s.toCharArray();\\n            int r = 0;\\n            for(int i = 0; i < 32; i++){\\n            \\tif(c[i] == '1')\\n            \\t\\tr += (1 << i);\\n            }\\n            return r;\\n        }\\n`method2:using bit opeeation, 2ms`\\n\\n    //\\u65b9\\u6cd52\\uff1a\\u4f7f\\u7528\\u4f4d\\u64cd\\u4f5c\\n    \\tpublic int reverseBits2(int n){\\n    \\t\\tn = ((n & 0xAAAAAAAA ) >>> 1) | ((n & 0x55555555) << 1);\\n    \\t\\tn = ((n & 0xCCCCCCCC ) >>> 2) | ((n & 0x33333333) << 2);\\n    \\t\\tn = ((n & 0xf0f0f0f0 ) >>> 4) | ((n & 0x0f0f0f0f) << 4);\\n    \\t\\tn = ((n & 0xff00ff00 ) >>> 8) | ((n & 0x00ff00ff) << 8);\\n    \\t\\tn = ((n & 0xffff0000 ) >>> 16) | ((n & 0x0000ffff) << 16);\\n    \\t\\treturn n;\\n    \\t}\\n\\n         /*\\n    \\t * \\u5229\\u7528\\u9ad8\\u5730\\u4f4d\\u4ea4\\u6362\\u5b9e\\u73b0\\u9006\\u5e8f\\n    \\t * \\u4e24\\u4f4d\\u4e00\\u7ec4\\uff0c\\u9ad8\\u4f4e\\u4f4d\\u4e92\\u6362\\uff0c\\u65b9\\u6cd5\\u662f\\uff08\\u53d6\\u5947\\u6570\\u4f4d\\uff0c\\u5076\\u6570\\u4f4d\\u88650\\uff0c\\u53f3\\u79fb1\\u4f4d\\uff09| \\uff08\\u53d6\\u5076\\u6570\\u4e3a\\uff0c\\u5947\\u6570\\u4f4d\\u88650\\uff0c\\u5de6\\u79fb1\\u4f4d\\uff09\\n    \\t * \\u4f9d\\u6b21\\u56db\\u4f4d\\u4e00\\u7ec4\\uff0c\\u516b\\u4f4d\\u4e00\\u7ec4\\uff0c\\u5341\\u516d\\u4f4d\\u4e00\\u7ec4\\uff0c\\u4e09\\u5341\\u4e8c\\u4f4d\\u4e00\\u7ec4\\n    \\t * \\u7531\\u4e8e\\u662f\\u65e0\\u7b26\\u53f7\\u4f4d\\uff0c\\u6240\\u4ee5\\u6ce8\\u610f\\u5f97\\u662f\\u903b\\u8f91\\u53f3\\u79fb\\n    \\t */",
                "codeTag": "Unknown"
            },
            {
                "id": 744794,
                "title": "easy-python-100-speed",
                "content": "**Easy Python | 100% Speed**\\n\\n**A) Bit Manipulation**\\n\\nIn this algorithm, we basically print each bit into its reversed counterpart. It looks a bit ugly, but it makes a lot of sense after a while :)\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        res    = 0\\n        for i in range(32):\\n            if n&1:\\n                res += 1 << (31-i)\\n            n >>= 1\\n        return res\\n```\\n\\n**B) String Padding**\\nWe can take advantage of the Python\\'s \\'bin\\' function to obtain a string representation of the binary number, add padding zeros, and convert the reversed string back into a number:\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        n = bin(n)[2:]         # convert to binary, and remove the usual 0b prefix\\n        n = \\'%32s\\' % n         # print number into a pre-formatted string with space-padding\\n        n = n.replace(\\' \\',\\'0\\') # Convert the useful space-padding into zeros\\n        # Now we have a  proper binary representation, so we can make the final transformation\\n        return int(n[::-1],2)\\n```\\n\\n**C) One-Liner String Padding Conversion**\\n\\nSolution B in One-Liner format.\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        return int( (\\'%32s\\' % bin(n)[2:]).replace(\\' \\',\\'0\\')[::-1] ,2)\\n```\\n\\n**D) High-Speed Code**\\n\\nI ran a benchmark in my laptop with 1 million random test cases, and this Solution proved to be faster than all previous versions:\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        n = bin(n)[2:]\\n        n = \\'0\\'*( 32-len(n) ) + n\\n        return int( n[::-1] ,2)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n):\\n        res    = 0\\n        for i in range(32):\\n            if n&1:\\n                res += 1 << (31-i)\\n            n >>= 1\\n        return res\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        n = bin(n)[2:]         # convert to binary, and remove the usual 0b prefix\\n        n = \\'%32s\\' % n         # print number into a pre-formatted string with space-padding\\n        n = n.replace(\\' \\',\\'0\\') # Convert the useful space-padding into zeros\\n        # Now we have a  proper binary representation, so we can make the final transformation\\n        return int(n[::-1],2)\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        return int( (\\'%32s\\' % bin(n)[2:]).replace(\\' \\',\\'0\\')[::-1] ,2)\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n):\\n        n = bin(n)[2:]\\n        n = \\'0\\'*( 32-len(n) ) + n\\n        return int( n[::-1] ,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732028,
                "title": "c-bitwise-solution-explained-100-time-100-space",
                "content": "Basically we need to construct our accumulator variable `res` shaving off the leftmost digit at each iteration and adding it to the double (`<< 1` works like `* 2` in this case) to our previously computed `res`; similarly, at each iteration we remove the just used leftmost bit with a right shift: `>> 1`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i = 0; i < 31; i++) {\\n            res = (n % 2) + res << 1;\\n            n >>= 1;\\n        }\\n        return res + n % 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i = 0; i < 31; i++) {\\n            res = (n % 2) + res << 1;\\n            n >>= 1;\\n        }\\n        return res + n % 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129802,
                "title": "javascript-one-liner",
                "content": "```\\n/**\\n *\\n * Reverse Bits\\n *\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nfunction reverseBits(n) {\\n  return Number.parseInt(n.toString(2).split(\"\").reverse().join(\"\").padEnd(32, \"0\"), 2);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n *\\n * Reverse Bits\\n *\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nfunction reverseBits(n) {\\n  return Number.parseInt(n.toString(2).split(\"\").reverse().join(\"\").padEnd(32, \"0\"), 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2339454,
                "title": "easiest-way-to-do-bit-manipulation-java-code",
                "content": "public class Solution {\\n\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int binaryNum = 0;\\n        \\n        for(int i=0;i<32;i++) {\\n            binaryNum = binaryNum<<1;                   //multiply by 2\\n            binaryNum = binaryNum + (n&1);              //add last digit to binaryNum \\n            n=n>>1;                                     //update n by removing last digit\\n        }\\n        \\n        return binaryNum ;\\n        \\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int binaryNum = 0;\\n        \\n        for(int i=0;i<32;i++) {\\n            binaryNum = binaryNum<<1;                   //multiply by 2\\n            binaryNum = binaryNum + (n&1);              //add last digit to binaryNum \\n            n=n>>1;                                     //update n by removing last digit\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3060703,
                "title": "c-solution-beats-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t k = 0;\\n    int l = 31;\\n    uint32_t reverseBits(uint32_t n) {\\n        if(n == 0)\\n        return 0;\\n\\n        if(n & 1)\\n        {\\n            k += 1 << l;\\n        }\\n        l--;\\n        reverseBits(n >> 1);\\n\\n        return k;\\n    }\\n};\\n```\\n\\nPlease upvote if you like it and also give suggestions.",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t k = 0;\\n    int l = 31;\\n    uint32_t reverseBits(uint32_t n) {\\n        if(n == 0)\\n        return 0;\\n\\n        if(n & 1)\\n        {\\n            k += 1 << l;\\n        }\\n        l--;\\n        reverseBits(n >> 1);\\n\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628641,
                "title": "python3-solution-one-line",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(((\\'{0:032b}\\'.format(n))[::-1]),2)\\n```\\n* (\\'{0:032b}\\'.format(n) Converts to a 32 bit representation of the number in binary. This is formatted as a string\\n* [::-1] Reverses the String\\n* int(...., 2) converts the number back to the appropriate base",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(((\\'{0:032b}\\'.format(n))[::-1]),2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426492,
                "title": "golang-100-super-simple",
                "content": "Simple solution using bit operations.\\n32 iterations, each time we:\\n1. Shift result left by 1 bit and append to it last bit from input number\\n2. Shift input number right by 1 bit\\n\\nYou can imagive it as two stacks, we pop items from one and push to another. Only your stacks have same length and always autofilled with 0s.\\n\\nHere is code:\\n```\\nfunc reverseBits(num uint32) uint32 {\\n    var res uint32\\n    for i := 0; i < 32; i++ {\\n        res = res << 1 + num & 1\\n        num >>= 1\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var res uint32\\n    for i := 0; i < 32; i++ {\\n        res = res << 1 + num & 1\\n        num >>= 1\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54997,
                "title": "simple-4ms-c-solution-with-updated-explanation",
                "content": "This does literally what the problem asks, it swaps each pair of bits from the outside in. The swap operation looks at the pair of bits to see if they're different, and if so, flips each bit. For each pair of indices *i* and *j*, we can select the *ith* bit and the *jth* bit with the expressions `((n >> i) & 1)` and  `(n >> j) & 1)`. We then compare the two bits. If they are equal, we don't need to do anything because swapping them would have no effect. If they're not equal, we flip each bit by XORing it with 1. This has the effect of \"swapping\" the bits even though we're really just flipping each one. So the pair (0, 1) would get changed to (1, 0) and (1, 0) would get changed to (0, 1). To XOR the *ith* and *jth* bits each with ones, we form a number with 1's in the *ith* and *jth* places using OR: `((1U << i) | (1U << j))`. Then we can just XOR this with our number to flip the bits in the *ith* and *jth* places.\\n\\nIf we needed to process lots of numbers, a faster way to do this would be to build up a table of preprocessed answers for numbers up to some bit count, and then reverse the overall number block by block.\\n\\n    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            int i = 0, j = 31;\\n            while (i < j) {\\n                if (((n >> i) & 1) != ((n >> j) & 1)) {\\n                    n ^= ((1U << i) | (1U << j));\\n                }\\n                i++, j--;\\n            }\\n            return n;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            int i = 0, j = 31;\\n            while (i < j) {\\n                if (((n >> i) & 1) != ((n >> j) & 1)) {\\n                    n ^= ((1U << i) | (1U << j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2321365,
                "title": "faster-than-100-of-the-users",
                "content": "**we will traverse till 32 bits and find the last digit of n by using n&1 . After this we will add this value in ans ans then right shift the value of n and repeat till last item.   hope this helped you please upvote.**\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for( int i= 0; i < 32 ;i++){\\n            ans = (ans << 1) | (n&1);\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for( int i= 0; i < 32 ;i++){\\n            ans = (ans << 1) | (n&1);\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54806,
                "title": "2ms-java-solution",
                "content": "    public class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int answer = 0; // initializing answer\\n            for (int i = 0; i < 32; i++) { // 32 bit integers\\n                answer <<= 1; // shifts answer over 1 to open a space\\n                answer |= ((n >> i) & 1); // inserts bits from n\\n            }\\n            return answer;\\n        }\\n    }\\n\\nIf anyone has a faster solution, please comment below.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int answer = 0; // initializing answer\\n            for (int i = 0; i < 32; i++) { // 32 bit integers\\n                answer <<= 1; // shifts answer over 1 to open a space\\n                answer |= ((n >> i) & 1); // inserts bits from n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 54979,
                "title": "c-4-lines-4-ms",
                "content": "    uint32_t reverseBits(uint32_t n) {\\n        uint32_t m = 0;\\n        for (int i = 0; i< 32 ; i++,n/=2)\\n            m = (m<<1) + (n%2);\\n        return m;\\n    }",
                "solutionTags": [],
                "code": "    uint32_t reverseBits(uint32_t n) {\\n        uint32_t m = 0;\\n        for (int i = 0; i< 32 ; i++,n/=2)\\n            m = (m<<1) + (n%2);\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1941906,
                "title": "c-solution-with-explanation",
                "content": "The logic is to push 1 bit at a time from end of one register to another.\\n\\nConsider a 4 bit number n = 1101, result = 0000\\n1) First iteration: result = 0000 ( after left shift of 1), n & 1 = 0001 (since n is odd), result | n & 1 = 0001, n >> 1 right shifts n, now n = 0110. You can see last bit of n in now added to result.\\n2) Second iteration: result = 0010 (left shift of 1), n & 1 = 0000 (n is even), result | (n&1) = 0010, n >> 1 gives n = 0011\\n3) Third iteration: result = 0100, n & 1 = 0001, result | (n & 1) = 0101, n >> 1 = 0001\\n4) Fourth iteration: result = 1010, n & 1 = 0001, result | (n & 1) = 1011, n >> 1 = 0000\\n\\nIn this way, we remove element from right side of n and append it to result, then we push result to 1 bit left. \\n\\nPlease upvote if you like it.\\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t result = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            result <<= 1;\\n            result |= n & 1;\\n            n >>= 1;\\n        }\\n        return result;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t result = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            result <<= 1;\\n            result |= n & 1;\\n            n >>= 1;\\n        }\\n        return result;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55025,
                "title": "my-c-4ms-solution-with-two-line",
                "content": "    uint32_t reverseBits(uint32_t n){\\n       int i,bin=0;\\n         for (i = 0; i < 32; i++) \\n    \\t bin+=(n >> i & 1)<<(31-i);\\n        return bin;\\n    }",
                "solutionTags": [],
                "code": "    uint32_t reverseBits(uint32_t n){\\n       int i,bin=0;\\n         for (i = 0; i < 32; i++) \\n    \\t bin+=(n >> i & 1)<<(31-i);\\n        return bin;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54751,
                "title": "c-solution-9ms-without-loop-without-calculation",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            struct bs\\n            {\\n                unsigned int _00:1; unsigned int _01:1; unsigned int _02:1; unsigned int _03:1;\\n                unsigned int _04:1; unsigned int _05:1; unsigned int _06:1; unsigned int _07:1;\\n                unsigned int _08:1; unsigned int _09:1; unsigned int _10:1; unsigned int _11:1;\\n                unsigned int _12:1; unsigned int _13:1; unsigned int _14:1; unsigned int _15:1;\\n                unsigned int _16:1; unsigned int _17:1; unsigned int _18:1; unsigned int _19:1;\\n                unsigned int _20:1; unsigned int _21:1; unsigned int _22:1; unsigned int _23:1;\\n                unsigned int _24:1; unsigned int _25:1; unsigned int _26:1; unsigned int _27:1;\\n                unsigned int _28:1; unsigned int _29:1; unsigned int _30:1; unsigned int _31:1;\\n            } *b = (bs*)&n, \\n            c = \\n            {\\n                  b->_31, b->_30, b->_29, b->_28\\n                , b->_27, b->_26, b->_25, b->_24\\n                , b->_23, b->_22, b->_21, b->_20\\n                , b->_19, b->_18, b->_17, b->_16\\n                , b->_15, b->_14, b->_13, b->_12\\n                , b->_11, b->_10, b->_09, b->_08\\n                , b->_07, b->_06, b->_05, b->_04\\n                , b->_03, b->_02, b->_01, b->_00\\n            };\\n    \\n            return *(unsigned int *)&c;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            struct bs\\n            {\\n                unsigned int _00:1; unsigned int _01:1; unsigned int _02:1; unsigned int _03:1;\\n                unsigned int _04:1; unsigned int _05:1; unsigned int _06:1; unsigned int _07:1;\\n                unsigned int _08:1; unsigned int _09:1; unsigned int _10:1; unsigned int _11:1;\\n                unsigned int _12:1; unsigned int _13:1; unsigned int _14:1; unsigned int _15:1;\\n                unsigned int _16:1; unsigned int _17:1; unsigned int _18:1; unsigned int _19:1;\\n                unsigned int _20:1; unsigned int _21:1; unsigned int _22:1; unsigned int _23:1;\\n                unsigned int _24:1; unsigned int _25:1; unsigned int _26:1; unsigned int _27:1;\\n                unsigned int _28:1; unsigned int _29:1; unsigned int _30:1; unsigned int _31:1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55046,
                "title": "concise-java-solution-300ms",
                "content": "    public class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            long sum=0;\\n            for(int i=0;i<32;i++){\\n               sum+=Math.pow(2,31-i)*(n&1);\\n                n=n>>1;\\n            }\\n           return (int)sum;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            long sum=0;\\n            for(int i=0;i<32;i++){\\n               sum+=Math.pow(2,31-i)*(n&1);\\n                n=n>>1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1776103,
                "title": "c-bit-manipulation-100-faster-0-ms-easy-to-understand",
                "content": "\\uD83D\\uDCBB --  **Upvote , If found helpful**\\n\\n* **Approach** - find the ith bit and put it in ith bit from last in answer \\n\\n* **Explaination**\\n1. let n = 00000010100101000001111010011100\\n2. To find the 2nd bit in n , right shift by 2 (**n>>2**) and taking its and with 1\\nbecause anything and with 1 remains same \\n3. now make ith bit from last according to mask in new number (**which we have to return**) i.e (**31-i**). \\n\\n\\n\\n* **Code**\\n```\\nuint32_t reverseBits(uint32_t n) {\\n        int ans = 0;\\n        for(int i = 0 ; i < 32 ; i++){\\n            int mask = (n>>i)&1;\\n            ans = ans|(mask<<(31-i));\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nuint32_t reverseBits(uint32_t n) {\\n        int ans = 0;\\n        for(int i = 0 ; i < 32 ; i++){\\n            int mask = (n>>i)&1;\\n            ans = ans|(mask<<(31-i));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1296934,
                "title": "easy-java-solution-1-line-of-code-using-in-built-class-1ms-beats-98",
                "content": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        return Integer.reverse(n);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        return Integer.reverse(n);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491045,
                "title": "c-beginner-friendly-solution-explantion-fast-easy-3ms",
                "content": "**Given problem:** To reverse the binary representation of a number.\\nHere ```uint32_t``` is used to store the 32 bits.\\n\\n**Read this First**\\n1. If ```num = 1101``` then either of these are possible:\\n\\ta. ```num = num>>1``` will make ```num = 0110        //right shift``` .\\n\\tb.```num = num<<1``` will make ```num = 1010        //left shift```.\\n\\t\\n2. If ```num = 1101```, then ```&``` (AND) operation:\\n\\ta. ```a = num & 1``` will give ```a = 1``` which is the right most bit of num.\\n\\t\\n3. If ```num = 1010```, then ```|``` (OR) operation:\\n\\ta. ```a = num | 1``` will give ```a = 1011``` where 1 gets added to the right most bit of num.\\n<br></br>\\n\\n**Solution Steps:**\\n1. We create a new variable to store the answer i.e. the *reversed binary representation*.\\n\\n\\n2. Initially ```ans``` variable is ```0```. To store more bits we need to expand its space. \\nSo we perform ``` ans<<=1``` which can also be written as ```ans = ans << 1```.\\nThis **left shifts** ```ans``` variable **by 1 space towards its left**. So now ```ans``` is ```0 0```.\\n3. We read only the last bit of the given binary form ```n```, using ```&``` operation like ```n & 1```.\\n4. Then we add this last bit of ```n``` to ```ans```. If the last bit of n was ```1```, then ```ans``` is ```0 1``` now.\\nWe can add in 2 ways: ```ans = ans + (n&1)``` or ``` ans = ans | (n&1)```. \\nThe second ```OR``` operation is **much faster**.\\n5. As we have dealt with the current last bit, we remove it by right shifting ```n```; ```n = n>>1```.\\n6. We repeat all the above steps 2 to 5, for 32 times for each of the 32 bits.\\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0; int i=32;\\n        while(i--){\\n            ans<<=1;\\n            ans|=n&1;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<br></br>\\n***Upvote** if this is helpful. Comment if there any mistake in explanation or any doubt.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```uint32_t```\n```num = 1101```\n```num = num>>1```\n```num = 0110        //right shift```\n```num = num<<1```\n```num = 1010        //left shift```\n```num = 1101```\n```&```\n```a = num & 1```\n```a = 1```\n```num = 1010```\n```|```\n```a = num | 1```\n```a = 1011```\n```ans```\n```0```\n``` ans<<=1```\n```ans = ans << 1```\n```ans```\n```ans```\n```0 0```\n```n```\n```&```\n```n & 1```\n```n```\n```ans```\n```1```\n```ans```\n```0 1```\n```ans = ans + (n&1)```\n``` ans = ans | (n&1)```\n```OR```\n```n```\n```n = n>>1```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0; int i=32;\\n        while(i--){\\n            ans<<=1;\\n            ans|=n&1;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037664,
                "title": "python-pure-bit-manipulation-no-string-reversal-34-ms-beats-85",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n\\n        out = 0  # Initialize output with \\'0000...{32 times}...000\\'\\n        for _ in range(31):\\n            bit = n & 1  # 1. Take the last bit of n \\n            out |= bit   # 2. Set the last bit of output to the last bit of n \\n            out <<= 1    # 3. Left shift output by 1 so that the last bit set is now one step to the left\\n            n >>= 1      # 4. Right shift n by 1 so that in the next iteration, we can extract the next bit\\n        \\n        # We set the 32nd bit outside of the loop because we don\\'t want to left shift output after this.\\n        out |= n  \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n\\n        out = 0  # Initialize output with \\'0000...{32 times}...000\\'\\n        for _ in range(31):\\n            bit = n & 1  # 1. Take the last bit of n \\n            out |= bit   # 2. Set the last bit of output to the last bit of n \\n            out <<= 1    # 3. Left shift output by 1 so that the last bit set is now one step to the left\\n            n >>= 1      # 4. Right shift n by 1 so that in the next iteration, we can extract the next bit\\n        \\n        # We set the 32nd bit outside of the loop because we don\\'t want to left shift output after this.\\n        out |= n  \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294666,
                "title": "c-a-different-soln-using-bitset",
                "content": "```\\n// This is not the best way to do it, but it is defienlty differnt than most of the top rated solns\\n// so I thought it\\'s a good soln to give a glance\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) \\n    {\\n        bitset<32> orig(n);\\n        bitset<32> num;\\n        for (int j = 31, i = 0; j >= 0; j--)\\n            num[i++] = orig[j];\\n        return num.to_ulong();\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) \\n    {\\n        string s = bitset<32>(n).to_string();\\n        reverse(s.begin(), s.end());\\n        bitset<32> num(s);\\n        return num.to_ulong();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// This is not the best way to do it, but it is defienlty differnt than most of the top rated solns\\n// so I thought it\\'s a good soln to give a glance\\n```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) \\n    {\\n        bitset<32> orig(n);\\n        bitset<32> num;\\n        for (int j = 31, i = 0; j >= 0; j--)\\n            num[i++] = orig[j];\\n        return num.to_ulong();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) \\n    {\\n        string s = bitset<32>(n).to_string();\\n        reverse(s.begin(), s.end());\\n        bitset<32> num(s);\\n        return num.to_ulong();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243746,
                "title": "bit-by-bit-js-solution",
                "content": "```\\n/*\\nProcess the right-most bit for 32 times (at most)\\n*/\\nvar reverseBits = function(n) {\\n    let res = 0, pow = 31;\\n    while (n > 0) {\\n        let rightMost = n & 1;\\n        res = res + (rightMost << pow);\\n        pow--;\\n        n = n >>> 1;\\n    }\\n    // take negative into positive\\n    return res >>> 0;\\n    // T.C: O(1)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nProcess the right-most bit for 32 times (at most)\\n*/\\nvar reverseBits = function(n) {\\n    let res = 0, pow = 31;\\n    while (n > 0) {\\n        let rightMost = n & 1;\\n        res = res + (rightMost << pow);\\n        pow--;\\n        n = n >>> 1;\\n    }\\n    // take negative into positive\\n    return res >>> 0;\\n    // T.C: O(1)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54957,
                "title": "my-simple-solution",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits( uint32_t n ) {\\n            uint32_t result = 0;\\n            for( int i = 0; i < 32; i++, n >>= 1 )\\n                if( n & 1 )\\n                    result |=  1 << ( 31 - i );\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits( uint32_t n ) {\\n            uint32_t result = 0;\\n            for( int i = 0; i < 32; i++, n >>= 1 )\\n                if( n & 1 )\\n                    result |=  1 << ( 31 - i );\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54974,
                "title": "no-loop-bit-manipulation-but-many-inst",
                "content": "    \\n    uint32_t reverseBits(uint32_t n)\\n    {\\n       n = ((n<<16) | (n>>16));                         //swap [31:16]<=>[15:0]\\n       n = ((n&0x00ff00ff)<< 8 | (n&0xff00ff00)>> 8);   //swap [31:24]<=>[23:16] , [15:8]<=>[7:0]\\n       n = ((n&0x0f0f0f0f)<< 4 | (n&0xf0f0f0f0)>> 4);   //swap ...\\n       n = ((n&0x33333333)<< 2 | (n&0xcccccccc)>> 2);   //swap ...\\n       n = ((n&0x55555555)<< 1 | (n&0xaaaaaaaa)>> 1);   //swap ...\\n       return n;    \\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    \\n    uint32_t reverseBits(uint32_t n)\\n    {\\n       n = ((n<<16) | (n>>16));                         //swap [31:16]<=>[15:0]\\n       n = ((n&0x00ff00ff)<< 8 | (n&0xff00ff00)>> 8);   //swap [31:24]<=>[23:16] , [15:8]<=>[7:0]\\n       n = ((n&0x0f0f0f0f)<< 4 | (n&0xf0f0f0f0)>> 4);   //swap ...\\n       n = ((n&0x33333333)<< 2 | (n&0xcccccccc)>> 2);   //swap ...\\n       n = ((n&0x55555555)<< 1 | (n&0xaaaaaaaa)>> 1);   //swap ...\\n       return n;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54971,
                "title": "very-neat-c-solution",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            for (int i = 0; i < 16; i++)\\n                // toggle bits when the 2 bits in a pair are different\\n                if ((n >> i & 1) ^ (n >> (31 - i) & 1))\\n                    n ^= (1 << i | 1 << (31 - i));\\n            return n;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            for (int i = 0; i < 16; i++)\\n                // toggle bits when the 2 bits in a pair are different\\n                if ((n >> i & 1) ^ (n >> (31 - i) & 1))\\n                    n ^= (1 << i | 1 << (31 - i));\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54754,
                "title": "javascript-bit-solution-139ms-matters-explained",
                "content": "> The << operator is defined as working on signed 32-bit integers (converted from the native Number storage of double-precision float). So 1<<31 must result in a negative number.\\n\\n-- source https://stackoverflow.com/a/1908655/2013580\\n\\n> The >> is arithmetic shift right, >>> is logical shift right.\\nIn an arithmetic shift, the sign bit is extended to preserve the signedness of the number.\\n\\n-- source https://stackoverflow.com/a/2811372/2013580\\n\\n```\\nvar reverseBits = function(n) {\\n    let ans = 0;\\n    for (let i = 0; i < 32; i += 1) {\\n        ans <<= 1;\\n        ans |= n & 1;\\n        n >>= 1;\\n    }\\n    return ans >>> 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseBits = function(n) {\\n    let ans = 0;\\n    for (let i = 0; i < 32; i += 1) {\\n        ans <<= 1;\\n        ans |= n & 1;\\n        n >>= 1;\\n    }\\n    return ans >>> 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032438,
                "title": "easy-to-understand-solution-bitwise-operation-c-solution",
                "content": "# Intuition\\nThe intuition is play on bits using bit manipulation.\\n\\n# Approach\\nSo, for a 32 bit integer, we got 32 bits as 01010100.....\\nNow, since we need to reverse the given number, we have to do 32 operations(changing/shifting the bit).\\n\\nSo, first of all, we can consider number \"1\" whose binary value would be -\"00000000000000000000000000000001\" (32 bits)\\nnow, since we need to reverse the given number n\\n\\nConsidering n\\'s binary representation from test case -\\n00000010100101000001111010011100\\nWe need to reverse it to ->\\n00111001011110000010100101000000\\n\\nSo, we need to start from least significant bit(lsb) and therefore to get the lsb, we perform bitwise And operation on n and 1 (n & 1)\\nthis gives us, 0 in this case. Now, we need to store it at first place. So we left shift the result by (31-i) bits where i is the i-th time we are operating on bits.\\n\\nnow, to save result, we can perform bitwise OR operation on result (initially 0) and lsb_reverse.\\n\\nNow, when we have stored lsb, we can now shift the n by 1 bit and operate for new lsb.\\n\\nThis we continue for 32 times and finally we get the number with reversed bits.  \\n\\nHope you liked the solution!! \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public uint reverseBits(uint n) {\\n        uint res=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            uint lsb=n & 1;\\n            uint lsb_reverse=lsb<<(31-i);\\n            res= res | lsb_reverse;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public uint reverseBits(uint n) {\\n        uint res=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            uint lsb=n & 1;\\n            uint lsb_reverse=lsb<<(31-i);\\n            res= res | lsb_reverse;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038308,
                "title": "java-integer-api-and-bit-by-bit-implementation",
                "content": "Bit-by-Bit\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        var rev = 0;\\n        for (int i = 0; i < 32; i++) {\\n    \\t    rev = ( rev << 1 ) | ( n & 1 );         \\n    \\t    n = n >> 1;                  \\n        }\\n        return rev;\\n    }\\n}\\n```\\nInteger API\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        return Integer.reverse(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        var rev = 0;\\n        for (int i = 0; i < 32; i++) {\\n    \\t    rev = ( rev << 1 ) | ( n & 1 );         \\n    \\t    n = n >> 1;                  \\n        }\\n        return rev;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        return Integer.reverse(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936391,
                "title": "easy-solution-without-any-in-built-functions",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res=0\\n        for i in range(32): # since it is 32 bit integer\\n            res=res<<1   # left shift to check it till 32 bits\\n            res+=n%2  # checking if rightmost bit of n is 1 and adding to result\\n            n=n>>1     # checking all bits of n till n becomes 0\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res=0\\n        for i in range(32): # since it is 32 bit integer\\n            res=res<<1   # left shift to check it till 32 bits\\n            res+=n%2  # checking if rightmost bit of n is 1 and adding to result\\n            n=n>>1     # checking all bits of n till n becomes 0\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 455724,
                "title": "python-3-solution-in-2-lines",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        num = bin(n)[2:].zfill(32)\\n        return int(num[::-1], 2)\\n```\\n\\n\\n\\nExplanation:\\n\\n* `bin(n)` -> converts the integer no. to binary [e.g 5 to 101]. It will return a string in the format \\'0b101\\' which has a prefix 0b , which stands for binary representation. So, to remove 0b on the left side `[2:]` has been  done.\\n\\n* `zfill(32)` -> returns a copy of the string with \\u20180\\u2019 characters padded to the left side of the given string.\\n\\n* `num` -> now has a string of length 32 which is a binary no. \\n   e.g\\n\\t `num = bin(5)[2:].zfill(32)`\\n\\n     `num` is now equals to \\'00000000000000000000000000000101\\'\\n\\n* `int(num[::-1], 2)` -> returns reverse of string `num`. Second parameter (2) in the int() represent the base of the no.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        num = bin(n)[2:].zfill(32)\\n        return int(num[::-1], 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54954,
                "title": "simply-great-performance-java-solution",
                "content": "    public class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int res = 0;\\n            int count = 31;\\n            while (n != 0) {\\n                if ((n & 1) == 1) {\\n                    res = res + (1 << count);\\n                } \\n                n >>>= 1;\\n                count--;\\n            }\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int res = 0;\\n            int count = 31;\\n            while (n != 0) {\\n                if ((n & 1) == 1) {\\n                    res = res + (1 << count);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 55036,
                "title": "very-simple-non-iterate-solution",
                "content": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n        def reverseBits(self, n):\\n            n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1)\\n            n = ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC) >> 2)\\n            n = ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4)\\n            n = ((n & 0x00FF00FF) << 8) | ((n & 0xFF00FF00) >> 8)\\n            n = ((n & 0x0000FFFF) << 16) | ((n & 0xFFFF0000) >> 16)\\n            return n\\n\\nLike merge sort, swap two bits, 4 bits, 8 bits, 16 bits and 32 bits, Then it reversed",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n        def reverseBits(self, n):\\n            n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1)\\n            n = ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC) >> 2)\\n            n = ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4)\\n            n = ((n & 0x00FF00FF) << 8) | ((n & 0xFF00FF00) >> 8)\\n            n = ((n & 0x0000FFFF) << 16) | ((n & 0xFFFF0000) >> 16)\\n            return n\\n\\nLike merge sort, swap two bits, 4 bits, 8 bits, 16 bits and 32 bits, Then it reversed",
                "codeTag": "Java"
            },
            {
                "id": 3578130,
                "title": "simple-c-solution-beats-100",
                "content": "# Intuition\\nTO convert the bitstring  **to reversed **\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        bitset<32> bi(n);\\n        string str= bi.to_string();\\n        reverse(str.begin(),str.end());\\n        bitset<32> b2(str);\\n        return b2.to_ullong();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        bitset<32> bi(n);\\n        string str= bi.to_string();\\n        reverse(str.begin(),str.end());\\n        bitset<32> b2(str);\\n        return b2.to_ullong();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089314,
                "title": "java-easy-solution-2ms-easy-to-understand-for-begineer",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int res =0;\\n        for(int i =0;i<32;i++) {\\n            //this is used to find least significant digit (lsb)\\n            // 00000010100101000001111010011100 & 1 = 00000010100101000001111010011100<- lsb =0\\n            int lsb = n & 1;\\n\\n            // soo, left shift of lsb lsb<<(31-i) so our 1st position zero will swaped with 31-i.so on...\\n            int revLsb = lsb<<(31-i);\\n           // store the revLsb in our result variable \\n            res = res|revLsb;\\n\\n            // right sift of n , one time ans soo on...\\n            n= n>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int res =0;\\n        for(int i =0;i<32;i++) {\\n            //this is used to find least significant digit (lsb)\\n            // 00000010100101000001111010011100 & 1 = 00000010100101000001111010011100<- lsb =0\\n            int lsb = n & 1;\\n\\n            // soo, left shift of lsb lsb<<(31-i) so our 1st position zero will swaped with 31-i.so on...\\n            int revLsb = lsb<<(31-i);\\n           // store the revLsb in our result variable \\n            res = res|revLsb;\\n\\n            // right sift of n , one time ans soo on...\\n            n= n>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005453,
                "title": "s5bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761429,
                "title": "easy-explanation-with-comments-java",
                "content": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        // return (int)Integer.reverse(n);\\n        \\n        int ans=0;\\n        int j=0;\\n        \\n        //iterate in bits and update ans\\n        \\n        for(int i=31;i>=0;i--){\\n            \\n            int mask=1<<i;\\n            \\n            //means at position i is off, skip\\n            if((n&mask)==0){\\n            }\\n            \\n            //bit is on so shift our pointer to jth position and add it to ans;\\n            else{\\n                ans+=(1<<j);\\n            }   \\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        // return (int)Integer.reverse(n);\\n        \\n        int ans=0;\\n        int j=0;\\n        \\n        //iterate in bits and update ans\\n        \\n        for(int i=31;i>=0;i--){\\n            \\n            int mask=1<<i;\\n            \\n            //means at position i is off, skip\\n            if((n&mask)==0){\\n            }\\n            \\n            //bit is on so shift our pointer to jth position and add it to ans;\\n            else{\\n                ans+=(1<<j);\\n            }   \\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685305,
                "title": "python-with-20ms-super-simple-clear-explanation",
                "content": "**1. Solution**\\n```    \\ndef reverseBits(self, n):\\n        num = 0              # contains the reversed number\\n        for i in range(32):\\n            num = num << 1   # (1) shift left to have space for a new bit  \\n            bit = n % 2      # (2) get the rightmost bit of the input\\n            num += bit       # (3) add this bit to the output number \\n\\t\\t\\t                 #     and it will be shifted leftwards later\\n            n = n >> 1       # (4) drop the rightmost bit of the input\\n        return num\\n          \\n\\n```\\n**2. Explanation**\\nThere\\'s mainly just 4 steps:\\n1) Get the rightmost bit of the input\\n2) Add the bit to the rightmost position of the output\\n3) Shift this bit leftwards in the output\\n4) Drop this (rightmost) bit at the input\\nRepeat these steps for all 32 bits, and you\\'re done.\\n\\n***Hope this post helps! Please upvote if you find it useful.\\nHave a good coding and have a good day!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```    \\ndef reverseBits(self, n):\\n        num = 0              # contains the reversed number\\n        for i in range(32):\\n            num = num << 1   # (1) shift left to have space for a new bit  \\n            bit = n % 2      # (2) get the rightmost bit of the input\\n            num += bit       # (3) add this bit to the output number \\n\\t\\t\\t                 #     and it will be shifted leftwards later\\n            n = n >> 1       # (4) drop the rightmost bit of the input\\n        return num\\n          \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1493349,
                "title": "bit-manipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=0; i < 32; i++){\\n            ans = ans << 1;\\n            if(n & 1 == 1) ans++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=0; i < 32; i++){\\n            ans = ans << 1;\\n            if(n & 1 == 1) ans++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746561,
                "title": "divide-and-conquer-without-bit-masking",
                "content": "The following solution approaches the problem using bit shifting and divide and conquer. It divides the problem using `start` and `end` pointers, and uses those values to shift the input and account for the base case.\\n\\n```java\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        return reverse(n, 0, 31);\\n    }\\n    \\n    private int reverse(int n, int start, int end) {\\n        if (start == end) {            \\n            return (n >>> (31-start)) % 2;\\n        }\\n        \\n        int mid = (end-start)/2+start;\\n        \\n        int left = reverse(n, start, mid);\\n        int right = reverse(n, mid+1, end);\\n\\n        return (right << (end-mid)) + left;\\n    }\\n}\\n```\\n\\nBasically, it keeps dividing the problem by half, until it reaches the base case where the subproblem is of size 1. In the base case, it returns the bit at the current position.\\n\\nIn a non-base case, it gets the reversed bits in the left and right subproblems, and uses bit shifting to concatenate the right subsolution and the left subsolution.",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```java\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        return reverse(n, 0, 31);\\n    }\\n    \\n    private int reverse(int n, int start, int end) {\\n        if (start == end) {            \\n            return (n >>> (31-start)) % 2;\\n        }\\n        \\n        int mid = (end-start)/2+start;\\n        \\n        int left = reverse(n, start, mid);\\n        int right = reverse(n, mid+1, end);\\n\\n        return (right << (end-mid)) + left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54867,
                "title": "share-my-one-line-python-solution",
                "content": "- def reverseBits(self, n):\\n\\n        return int('{0:032b}'.format(n)[::-1],2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "- def reverseBits(self, n):\\n\\n        return int('{0:032b}'.format(n)[::-1],2)",
                "codeTag": "Python3"
            },
            {
                "id": 54865,
                "title": "2ms-java-solution",
                "content": "    public class ReverseBits {\\n    \\t// you need treat n as an unsigned value\\n    \\tpublic int reverseBits(int n) {\\n    \\t\\tint reverse = 0;\\n    \\t\\tfor (int i = 0; i < 32; i++) {\\n    \\t\\t\\treverse |= ((n >>> i) & 1) << (31 - i);\\n    \\t\\t}\\n    \\t\\treturn reverse;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "    public class ReverseBits {\\n    \\t// you need treat n as an unsigned value\\n    \\tpublic int reverseBits(int n) {\\n    \\t\\tint reverse = 0;\\n    \\t\\tfor (int i = 0; i < 32; i++) {\\n    \\t\\t\\treverse |= ((n >>> i) & 1) << (31 - i);\\n    \\t\\t}\\n    \\t\\treturn reverse;\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 54916,
                "title": "what-s-with-the-follow-up",
                "content": "OK, first off, here is the Hacker's Delight (figure 7-1) classics in Java:\\n\\n    public int reverseBits(int n) {\\n        // note: mutating formal parameter\\n        n = ((n & 0x5555_5555) << 1) | ((n >>> 1) & 0x5555_5555);\\n        n = ((n & 0x3333_3333) << 2) | ((n >>> 2) & 0x3333_3333);\\n        n = ((n & 0x0F0F_0F0F) << 4) | ((n >>> 4) & 0x0F0F_0F0F);\\n        return (n >>> 24) | ((n >>> 8) & 0xFF00) | ((n & 0xFF00) << 8) | (n << 24);\\n    }\\n\\nIt's quite obvious once you figure it out. Just reverse bits in pairs, then reverse pairs in quadruples, then reverse quadruples in \\u201coctuples\\u201d (well, bytes or octets), then just reverse bytes. It may seem computation-heavy, but considering that bitwise and shift operations are among the fastest and that it will probably all be done in registers (and the code even minimizes the number of constants involved!), it will be very fast. In fact, that's exactly what `Integer.reverse` does.\\n\\nNow, I see a lot of solutions using a cache. In fact, we can do even better. Suppose our function is called so many times that initialization time doesn't really matter. So it could look like this:\\n\\n    private static final int[] map = new int[65536];\\n    \\n    static {\\n        for (int i = 0; i <= 65535; ++i) {\\n            int n = i;\\n            n = ((n & 0x5555) << 1) | ((n >>> 1) & 0x5555);\\n            n = ((n & 0x3333) << 2) | ((n >>> 2) & 0x3333);\\n            n = ((n & 0x0F0F) << 4) | ((n >>> 4) & 0x0F0F);\\n            map[i] = ((n >>> 8) | (n << 8)) & 0xFFFF;\\n        }\\n    }\\n    \\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        return (map[n & 0xFFFF] << 16) | map[n >>> 16];\\n    }\\n\\nNow class loading will be slow, but then the function will be amazingly fast, as there are only two shifts and one bitwise AND involved. Or will it? Now instead of a lot of arithmetics we have two table lookups. Not to mention this could be hard on cache, memory read operations are obviously much slower than in-register bitwise arithmetics. Maybe changing shorts to bytes can be easier on cache, but then combining the whole thing will look very much like the last [HD] line which is about half of the job. Plus *four* table lookups.\\n\\nThe solution above runs in 55 ms, by the way, while the first one runs in 2. But I don't know whether the OJ loads the class each time for every test case, and there's probably not enough test cases for the \\u201cimprovement\\u201d above to work (assuming it works at all).\\n\\nSo, my question is, isn't the follow-up basically asking to do a premature optimization that not only won't make things any better, but in fact could make it much worse? Or maybe that's exactly the point? Maybe we should answer that using a table is a bad idea and that we should concentrate on optimizing our math instead, referring to [HD] and `Integer.reverse`?",
                "solutionTags": [
                    "Java"
                ],
                "code": "OK, first off, here is the Hacker's Delight (figure 7-1) classics in Java:\\n\\n    public int reverseBits(int n) {\\n        // note: mutating formal parameter\\n        n = ((n & 0x5555_5555) << 1) | ((n >>> 1) & 0x5555_5555);\\n        n = ((n & 0x3333_3333) << 2) | ((n >>> 2) & 0x3333_3333);\\n        n = ((n & 0x0F0F_0F0F) << 4) | ((n >>> 4) & 0x0F0F_0F0F);\\n        return (n >>> 24) | ((n >>> 8) & 0xFF00) | ((n & 0xFF00) << 8) | (n << 24);\\n    }\\n\\nIt's quite obvious once you figure it out. Just reverse bits in pairs, then reverse pairs in quadruples, then reverse quadruples in \\u201coctuples\\u201d (well, bytes or octets), then just reverse bytes. It may seem computation-heavy, but considering that bitwise and shift operations are among the fastest and that it will probably all be done in registers (and the code even minimizes the number of constants involved!), it will be very fast. In fact, that's exactly what `Integer.reverse` does.\\n\\nNow, I see a lot of solutions using a cache. In fact, we can do even better. Suppose our function is called so many times that initialization time doesn't really matter. So it could look like this:\\n\\n    private static final int[] map = new int[65536];\\n    \\n    static {\\n        for (int i = 0; i <= 65535; ++i) {\\n            int n = i;\\n            n = ((n & 0x5555) << 1) | ((n >>> 1) & 0x5555);\\n            n = ((n & 0x3333) << 2) | ((n >>> 2) & 0x3333);\\n            n = ((n & 0x0F0F) << 4) | ((n >>> 4) & 0x0F0F);\\n            map[i] = ((n >>> 8) | (n << 8)) & 0xFFFF;\\n        }\\n    }\\n    \\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        return (map[n & 0xFFFF] << 16) | map[n >>> 16];\\n    }\\n\\nNow class loading will be slow, but then the function will be amazingly fast, as there are only two shifts and one bitwise AND involved. Or will it? Now instead of a lot of arithmetics we have two table lookups. Not to mention this could be hard on cache, memory read operations are obviously much slower than in-register bitwise arithmetics. Maybe changing shorts to bytes can be easier on cache, but then combining the whole thing will look very much like the last [HD] line which is about half of the job. Plus *four* table lookups.\\n\\nThe solution above runs in 55 ms, by the way, while the first one runs in 2. But I don't know whether the OJ loads the class each time for every test case, and there's probably not enough test cases for the \\u201cimprovement\\u201d above to work (assuming it works at all).\\n\\nSo, my question is, isn't the follow-up basically asking to do a premature optimization that not only won't make things any better, but in fact could make it much worse? Or maybe that's exactly the point? Maybe we should answer that using a table is a bad idea and that we should concentrate on optimizing our math instead, referring to [HD] and `Integer.reverse`?",
                "codeTag": "Java"
            },
            {
                "id": 54943,
                "title": "c-3ms-solution-with-lookup-table",
                "content": "    const uint8_t lookup[] = {0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255};\\n    \\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ret;\\n        register uint8_t *p = (uint8_t *)&n, *q = (uint8_t *)&ret;\\n            \\n        q[0] = lookup[p[3]];\\n        q[1] = lookup[p[2]];\\n        q[2] = lookup[p[1]];\\n        q[3] = lookup[p[0]];\\n        \\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "    const uint8_t lookup[] = {0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255};\\n    \\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ret;\\n        register uint8_t *p = (uint8_t *)&n, *q = (uint8_t *)&ret;\\n            \\n        q[0] = lookup[p[3]];\\n        q[1] = lookup[p[2]];\\n        q[2] = lookup[p[1]];\\n        q[3] = lookup[p[0]];\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3287155,
                "title": "simple-java-code-with-explanation-with-less-time-complexity",
                "content": "The given Java code is an implementation of the \"Reverse Bits\" problem, which requires reversing the bits of a 32-bit unsigned integer.\\n\\nHere\\'s a detailed explanation of how the code works:\\n\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int x=0;\\n        int i=31;\\n        while(i>=0){\\n            x |= ((n >> i) & 1) << (31 - i);\\n            i--;\\n        }\\n        return x;\\n    }\\n}\\n```\\nThe function reverseBits takes an integer n as input, which is to be treated as an unsigned 32-bit integer. The function returns the reversed version of n.\\n\\nThe variable x is initially set to zero. This variable will hold the reversed integer. The variable i is initialized to 31, which is the index of the most significant bit in a 32-bit unsigned integer.\\n\\nThe while loop iterates from i = 31 to i = 0. In each iteration, the i-th bit of n is extracted using the right shift operator >> and the bitwise AND operator &. Specifically, the expression (n >> i) & 1 extracts the i-th bit of n. The extracted bit is then shifted to the correct position in the reversed integer x using the left shift operator <<. Specifically, the expression ((n >> i) & 1) << (31 - i) shifts the extracted bit to the (31-i)th position in x. Finally, the shifted bit is OR-ed with the existing bits in x using the bitwise OR operator |. Specifically, the expression x |= ... sets the (31-i)th bit of x to the value of the i-th bit of n.\\n\\nAfter all 32 bits have been processed, the reversed integer x is returned as the output of the function.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int x=0;\\n        int i=31;\\n        while(i>=0){\\n            x |= ((n >> i) & 1) << (31 - i);\\n            i--;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081380,
                "title": "100-beat-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int arr[32]={0};\\n        // for(int i=0;i<32;i++){\\n        //     arr[i]=n%10;\\n        //     n=n/10;\\n        // }\\n        int i=0;\\n        while(n!=0){\\n            int rem=0;\\n            rem=n%2;\\n             arr[i]=rem;\\n              n=n/2;\\n              i++;\\n    }\\n\\n        long long ans=0;\\n        for(int i=0;i<32;i++){\\n            ans+=arr[i]*pow(2,32-1-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int arr[32]={0};\\n        // for(int i=0;i<32;i++){\\n        //     arr[i]=n%10;\\n        //     n=n/10;\\n        // }\\n        int i=0;\\n        while(n!=0){\\n            int rem=0;\\n            rem=n%2;\\n             arr[i]=rem;\\n              n=n/2;\\n              i++;\\n    }\\n\\n        long long ans=0;\\n        for(int i=0;i<32;i++){\\n            ans+=arr[i]*pow(2,32-1-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401921,
                "title": "c-simple-bit-manipulation-0ms-brief-explanation",
                "content": "In this approach , First you will initialize result(k) with 0. As we have 32 bits in 32 bit unsigned integer(n) so we can ran loop 32 times. In each iteration , we will left shift one bit of our current result and then we do `n&1` so that we can know that whether we have 0 or 1 as first (right most ) bit . Now we can update our result with the equation ` k=(k|(n&1))` and also we update our number(n) by right shifting of one bit of it . After 32 iteration we can find that we have result k as reversed bit of number n. \\n\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int i=32;\\n        uint32_t k=0;\\n    while(i--){\\n      k<<=1;\\n        k=(k|(n&1));\\n        n>>=1;\\n        }\\n        return k;\\n    }\\n};\\n```\\nPlease upvote if you like this solution !\\nAll the Best !!\\n\\n\\n\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int i=32;\\n        uint32_t k=0;\\n    while(i--){\\n      k<<=1;\\n        k=(k|(n&1));\\n        n>>=1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703007,
                "title": "simple-java-solution-with-comments-bitwise",
                "content": "think it like converting number to 10 base number. so we iterate big number diigit by digit and  do multiply each digit by 10 and then add last digit to it.\\nlike 123 can be written as 1 * 100 + 2 * 10 + 3 * 1 = 123\\nand for reverse -> \\n3 * 10 + 2 = 32\\n32 * 10 + 1 = 321\\n\\nin same way we will do conversion in 2 base. so loop from 0 to 31 digit and keep on preparing result. \\n```\\npublic int reverseBits(int n) {\\n        int res=0;\\n        for(int i=0;i<32;i++) {\\n\\t\\t   //multiply by 2\\n            res=res<<1;\\n\\t\\t\\t//add last digit to res\\n            res=res+(n&1);\\n\\t\\t\\t//update n by removing last digit\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int reverseBits(int n) {\\n        int res=0;\\n        for(int i=0;i<32;i++) {\\n\\t\\t   //multiply by 2\\n            res=res<<1;\\n\\t\\t\\t//add last digit to res\\n            res=res+(n&1);\\n\\t\\t\\t//update n by removing last digit\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375685,
                "title": "0ms-c-solution-beginner-friendly",
                "content": "```\\n uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0;\\n        for(int i=0;i<32;i++){\\n            ans=(ans<<1)+(n&1);\\n           n= n>>1;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0;\\n        for(int i=0;i<32;i++){\\n            ans=(ans<<1)+(n&1);\\n           n= n>>1;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1008703,
                "title": "rust-bit-operation-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Reverse Bits.\\nMemory Usage: 1.9 MB, less than 95.83% of Rust online submissions for Reverse Bits.\\n```\\nimpl Solution {\\n    pub fn reverse_bits(x: u32) -> u32 {\\n        let (mut res, mut x) = (0u32, x);\\n        for _ in 0..32 {\\n            res = (res << 1) | (x & 1);\\n            x >>= 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_bits(x: u32) -> u32 {\\n        let (mut res, mut x) = (0u32, x);\\n        for _ in 0..32 {\\n            res = (res << 1) | (x & 1);\\n            x >>= 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562090,
                "title": "swift-very-simple-solution",
                "content": "```\\nclass Solution {\\n    func reverseBits(_ n: Int) -> Int {\\n        let raw = String(n, radix: 2)\\n        let str = String(repeating: \"0\", count: 32 - raw.count) + raw\\n        return Int(String(str.reversed()), radix: 2) ?? -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func reverseBits(_ n: Int) -> Int {\\n        let raw = String(n, radix: 2)\\n        let str = String(repeating: \"0\", count: 32 - raw.count) + raw\\n        return Int(String(str.reversed()), radix: 2) ?? -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474948,
                "title": "simple-java-solution-beats-100-with-explaination",
                "content": "<img src=\"https://assets.leetcode.com/users/magi003769/image_1578547693.png\" style=\"zoom:50%\" />\\n\\nIn each loop, use logical AND operation `n & 1` to get the least significant bit and add it to the `ans`. To reverse the bit, shift `n` and `ans` in opposite directions. What needs attention is that, after we add the last bit of `n`  to `ans` at the 32th loop, the following left shift of `ans` is no longer needed. The most significant bit of `n` has already at the right most position after previous 31 loops. \\n\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for(int i=0; i < 31; i++) {\\n            ans += (n & 1);    // add the new bit\\n            ans = ans << 1;   // left shift ans to mantain previous bits\\n            n = n >> 1;         // get the right most bit\\n        }\\n        ans += (n & 1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for(int i=0; i < 31; i++) {\\n            ans += (n & 1);    // add the new bit\\n            ans = ans << 1;   // left shift ans to mantain previous bits\\n            n = n >> 1;         // get the right most bit\\n        }\\n        ans += (n & 1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427104,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nvar reverseBits = function(n) {\\n    let result = 0;\\n    \\n    for(let i = 0; i < 32; i++) {    \\n        result <<= 1;  \\n        result |= n & 1;  \\n        n >>= 1;\\n    }\\n    \\n    return result >>> 0;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nvar reverseBits = function(n) {\\n    let result = 0;\\n    \\n    for(let i = 0; i < 32; i++) {    \\n        result <<= 1;  \\n        result |= n & 1;  \\n        n >>= 1;\\n    }\\n    \\n    return result >>> 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 245459,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\nTime complexity: `O(k) = O(log n)` - where `k` is the number of bits in the integer.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int reverseBits(int n)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tresult <<= 1;\\n\\t\\t\\tresult += n & 1;\\n\\t\\t\\tn >>>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n- For 8 bit binary number `A B C D E F G H`, the process is like: `A B C D E F G H --> E F G H A B C D --> G H E F C D A B --> H G F E D C B A`\\n\\nTime complexity: `O(k) = O(log n)` - where `k` is the number of bits in the integer.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int reverseBits(int n)\\n\\t{\\n\\t\\tn = (n >>> 16) | (n << 16);\\n        n = ((n & 0xFF00FF00) >>> 8) | ((n & 0x00FF00FF) << 8);\\n        n = ((n & 0xF0F0F0F0) >>> 4) | ((n & 0x0F0F0F0F) << 4);\\n        n = ((n & 0xCCCCCCCC) >>> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xAAAAAAAA) >>> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n\\tpublic int reverseBits(int n)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tresult <<= 1;\\n\\t\\t\\tresult += n & 1;\\n\\t\\t\\tn >>>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic int reverseBits(int n)\\n\\t{\\n\\t\\tn = (n >>> 16) | (n << 16);\\n        n = ((n & 0xFF00FF00) >>> 8) | ((n & 0x00FF00FF) << 8);\\n        n = ((n & 0xF0F0F0F0) >>> 4) | ((n & 0x0F0F0F0F) << 4);\\n        n = ((n & 0xCCCCCCCC) >>> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xAAAAAAAA) >>> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213951,
                "title": "javascript-commented-bitwise-solution-64ms-100-and-es8-string-wranglin-solution-72ms",
                "content": "**TLDR**: 100% solution is at the bottom\\n\\nMy initial solution converts n to a string, pads the start with the missing 0s, converts the str to an array, reverses it, and then converts it back to a string to parse as a base2 number. This attempt landed me at 76ms and a sad ~29.  I replaced [...str] with str.split(\\'\\') for a 4ms which seems small, but moved my solution from being faster than ~29% to 54%. No further optimizations were made on this solution and I moved to a \\'bitwiser\\' (lol) solution.\\n###### es8 string wranglin\\' solution (72ms, 54%)\\n```\\nconst reverseBits = n => {\\n    const str = n.toString(2).padStart(32, \\'0\\');\\n    return parseInt(str.split(\\'\\').reverse().join(\\'\\'), 2)      \\n};\\n```\\n\\nMy next attempt loops through each bit left shifting the result by 1, adding the value of n\\'s right most bit to result, and then right shifting n by 1. Finally we use `result >>> 0` to force javascript to treat it as unsigned.\\n\\n###### \\'bitwiser\\' solution (64ms, 100%)\\n```\\nconst reverseBits = n => {\\n    let result = 0;\\n    for ( let i = 0; i < 32; i++) {\\n        result <<= 1;\\n        result |= n & 1;\\n        n >>>= 1;\\n        // uncomment for help visualiziing\\n        // console.log(result.toString(2), \\'<<<\\', n.toString(2));\\n    }\\n    return result >>> 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst reverseBits = n => {\\n    const str = n.toString(2).padStart(32, \\'0\\');\\n    return parseInt(str.split(\\'\\').reverse().join(\\'\\'), 2)      \\n};\\n```\n```\\nconst reverseBits = n => {\\n    let result = 0;\\n    for ( let i = 0; i < 32; i++) {\\n        result <<= 1;\\n        result |= n & 1;\\n        n >>>= 1;\\n        // uncomment for help visualiziing\\n        // console.log(result.toString(2), \\'<<<\\', n.toString(2));\\n    }\\n    return result >>> 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166657,
                "title": "python-with-bitwise-reversal",
                "content": "```\\n    def reverseBits(self, n):\\n        if n==0:\\n            return 0\\n        \\n        res = 0\\n        for i in range(32):\\n            res = res<<1\\n            res += n & 1 # last bit\\n            n = n >> 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def reverseBits(self, n):\\n        if n==0:\\n            return 0\\n        \\n        res = 0\\n        for i in range(32):\\n            res = res<<1\\n            res += n & 1 # last bit\\n            n = n >> 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 54792,
                "title": "one-line-python-solution-with-brief-explanation",
                "content": "My basic idea is:\\n1.  Convert the given integer to an 32-bit binary string;\\n2.  Reverse the string;\\n3.  Convert it back to integer and return\\n\\nFor step 1: we can use '{0:032b}.format() to do it. The first '0' means that we will format the 0th(the first) argument; and the second '0' represents the padding symbol; '32' means total length of the output and 'b' represents binary.\\nAfter this, we can use slicing and built-in functions to finish.\\n\\nBy the way, I personally don't like the one-line code, because I think readability is very important while some people are kind of crazy about very short code; Another thing is that, although Python provides a lot powerful built-in functions, but don't rely too much on it. \\nHave fun. \\n```\\nclass Solution:\\n  def reverseBits(self, n):\\n    return int('{0:032b}'.format(n)[::-1], 2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def reverseBits(self, n):\\n    return int('{0:032b}'.format(n)[::-1], 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54853,
                "title": "most-simple-c-solution",
                "content": "```\\npublic class Solution {\\n    public uint reverseBits(uint n)\\n    {\\n        uint num = 0;\\n        for(int i = 0; i < 32; ++i){\\n            num <<= 1;\\n            num += n % 2;\\n            n >>= 1;\\n        }\\n        return num;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public uint reverseBits(uint n)\\n    {\\n        uint num = 0;\\n        for(int i = 0; i < 32; ++i){\\n            num <<= 1;\\n            num += n % 2;\\n            n >>= 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54870,
                "title": "c-naive-and-optimized",
                "content": "    class Solution {\\n    public:\\n        // naive solution\\n        /*\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t ans = 0;\\n            for(int i = 0, j = 31; i <= 31; ++i, --j){\\n                uint32_t tmp = n & (1 << i);\\n                if(tmp){\\n                    ans |= (1 << j);\\n                }\\n            }\\n            return ans;\\n        }\\n        */\\n        //look up a 4 bit chuck and find out what the reverse is\\n        char tb[16] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t cur = 0;\\n            uint32_t ans = 0;\\n            uint32_t msk = 0xf;\\n            for(int i = 0;i < 8; ++i){\\n                ans <<= 4;\\n                cur = n & msk;\\n                cur = tb[cur];\\n                ans = ans | cur;\\n                n >>= 4;\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        // naive solution\\n        /*\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t ans = 0;\\n            for(int i = 0, j = 31; i <= 31; ++i, --j){\\n                uint32_t tmp = n & (1 << i);\\n                if(tmp){\\n                    ans |= (1 << j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 54923,
                "title": "java-solution-using-java-functions",
                "content": "    public class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        String op = String.format(\"%32s\", Integer.toBinaryString(n)).replace(' ', '0');\\n        op = new StringBuilder(op).reverse().toString();\\n        int num = Integer.parseUnsignedInt(op,2);\\n        return num;\\n    }}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        String op = String.format(\"%32s\", Integer.toBinaryString(n)).replace(' ', '0');\\n        op = new StringBuilder(op).reverse().toString();\\n        int num = Integer.parseUnsignedInt(op,2);\\n        return num;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 55040,
                "title": "pure-c-solution-with-3ms",
                "content": "    uint32_t reverseBits(uint32_t n) {\\n    int i;\\n    uint32_t res = 0;\\n    for(i = 0; i < 32; i++) {\\n        res = (res << 1) ^ (n & 1);\\n        n >>= 1;\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "    uint32_t reverseBits(uint32_t n) {\\n    int i;\\n    uint32_t res = 0;\\n    for(i = 0; i < 32; i++) {\\n        res = (res << 1) ^ (n & 1);\\n        n >>= 1;\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 54958,
                "title": "one-of-most-concise-solutions-in-java",
                "content": "    public class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int reverse = 0;\\n            for (int i = 0; i < 32; ++i) {\\n                reverse = (reverse << 1) ^ (n & 0x1);\\n                n >>>= 1;\\n            }\\n            return reverse;\\n        }\\n    }\\n\\nAny suggestions? Thanks.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need treat n as an unsigned value\\n        public int reverseBits(int n) {\\n            int reverse = 0;\\n            for (int i = 0; i < 32; ++i) {\\n                reverse = (reverse << 1) ^ (n & 0x1);\\n                n >>>= 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3945442,
                "title": "beats-100-easy-solution-explained-with-dry-run-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is to reverse the bits of an unsigned integer by iteratively extracting the least significant bit (LSB) of the input number n and building the reversed number bit by bit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe create reversed variable, then we iterate over the bits of n here\\'s a dry run to understand better.\\n\\n    Initial values:\\n\\n    n = 110 (in binary: 0110110)\\n    reversed = 0 (in binary: 0)\\n\\n- Iteration 1:\\n    - Shift reversed left by 1: reversed = 0 (in binary: 00)\\n    - Get the LSB of n using n & 1, which is 0.\\n    - Add the least significant bit to reversed:\\n    `reversed = 0 (in binary: 00)`\\n    `Right shift n by 1: n = 55 (in binary: 0011011)`\\n\\n- Iteration 2:\\n    - Shift reversed left by 1: reversed = 0 (in binary: 000)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 1 (in binary: 0001)`\\n`    Right shift n by 1: n = 27 (in binary: 0001101)`\\n\\n- Iteration 3:\\n    - Shift reversed left by 1: reversed = 2 (in binary: 0010)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 3 (in binary: 0011)`\\n    `Right shift n by 1: n = 13 (in binary: 00001101)`\\n\\n- Iteration 4:\\n    - Shift reversed left by 1: reversed = 6 (in binary: 0110)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 7 (in binary: 0111)`\\n    `Right shift n by 1: n = 6 (in binary: 00000110)`\\n\\n- Iteration 5:\\n    - Shift reversed left by 1: reversed = 14 (in binary: 1110)\\n    - Get the LSB of n using n & 1, which is 0.\\n    - Add the least significant bit to reversed:\\n    `reversed = 14 (in binary: 1110)`\\n    `Right shift n by 1: n = 3 (in binary: 00000011)`\\n\\n- Iteration 6:\\n    - Shift reversed left by 1: reversed = 28 (in binary: 11100)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 29 (in binary: 11101)`\\n    `Right shift n by 1: n = 1 (in binary: 00000001)`\\n\\n- Iteration 7:\\n    - Shift reversed left by 1: reversed = 58 (in binary: 111010)\\n    - Get the LSB of n using n & 1, which is 1.\\n    - Add the least significant bit to reversed: \\n    `reversed = 59 (in binary: 111011)`\\n    `Right shift n by 1: n = 0 (in binary: 00000000)`\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int reversed = 0; \\n\\n        for (int i = 0; i < 32; i++) {\\n            \\n            // Left shift the reversed cause\\n            // we need to set new bit value and\\n            // don\\'t need to override the previous one\\n            reversed <<= 1; \\n\\n            // Add the least significant bit of n to reversed\\n            reversed += n & 1; \\n            \\n            // Right shift n to move to the next bit\\n            n >>= 1; \\n        }\\n\\n        return reversed;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int reversed = 0; \\n\\n        for (int i = 0; i < 32; i++) {\\n            \\n            // Left shift the reversed cause\\n            // we need to set new bit value and\\n            // don\\'t need to override the previous one\\n            reversed <<= 1; \\n\\n            // Add the least significant bit of n to reversed\\n            reversed += n & 1; \\n            \\n            // Right shift n to move to the next bit\\n            n >>= 1; \\n        }\\n\\n        return reversed;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232945,
                "title": "powerful-logic-python3-java-golang",
                "content": "\\n# 1. Python3 Solution\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output=0\\n        for i in range(32):\\n            bits=n & 1\\n            output= output | bits << (31-i)\\n            n=n >> 1\\n        return output\\n\\n```\\n# 2. Golang Solution\\n```\\nfunc reverseBits(num uint32) uint32 {\\n    var answer uint32\\n    for i:=0;i<32;i++{\\n        answer=answer | (num&1)<<(31-i)\\n        num=num>>1\\n    }\\n    return answer \\n}\\n```\\n# 3. Java Solution\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int answer=0;\\n        for (int i=0;i<32;i++){\\n            answer=answer | (n&1)<<(31-i);\\n            n=n>>1;\\n        }\\n        return answer;\\n        \\n    }\\n}\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output=0\\n        for i in range(32):\\n            bits=n & 1\\n            output= output | bits << (31-i)\\n            n=n >> 1\\n        return output\\n\\n```\n```\\nfunc reverseBits(num uint32) uint32 {\\n    var answer uint32\\n    for i:=0;i<32;i++{\\n        answer=answer | (num&1)<<(31-i)\\n        num=num>>1\\n    }\\n    return answer \\n}\\n```\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int answer=0;\\n        for (int i=0;i<32;i++){\\n            answer=answer | (n&1)<<(31-i);\\n            n=n>>1;\\n        }\\n        return answer;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005457,
                "title": "easy-c-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005451,
                "title": "easyc-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005432,
                "title": "s1bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005372,
                "title": "rb6c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005370,
                "title": "rb4-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005364,
                "title": "rb3-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005362,
                "title": "rb1c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005321,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727766,
                "title": "my-brute-force-bit-manipulation-3ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t a=0;\\n     for (int i=0;i<31;i++)\\n     {\\n        if(n&1)\\n         a+=1;\\n         a<<=1;\\n         n=n>>1;\\n     }\\n        if(n&1)a+=1;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t a=0;\\n     for (int i=0;i<31;i++)\\n     {\\n        if(n&1)\\n         a+=1;\\n         a<<=1;\\n         n=n>>1;\\n     }\\n        if(n&1)a+=1;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493907,
                "title": "simple-solution-in-python-directly-created-a-32-bit-representation-of-given-integer",
                "content": "def reverseBits(self, n: int) -> int:\\n        a = f\\'{n:032b}\\'\\n        a= a[::-1]\\n        return int(a,2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "def reverseBits(self, n: int) -> int:\\n        a = f\\'{n:032b}\\'\\n        a= a[::-1]\\n        return int(a,2)",
                "codeTag": "Python3"
            },
            {
                "id": 2440929,
                "title": "c-python-optimized-o-n-solution",
                "content": "### C++\\nRuntime: 5 ms, faster than 32.53% of C++ online submissions for Reverse Bits.\\nMemory Usage: 5.9 MB, less than 51.91% of C++ online submissions for Reverse Bits.\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i = 0; i<32; i++) {\\n            res <<= 1;\\n            res += n % 2;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n### Python\\nRuntime: 59 ms, faster than 31.44% of Python3 online submissions for Reverse Bits.\\nMemory Usage: 13.8 MB, less than 49.77% of Python3 online submissions for Reverse Bits.\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res = 0\\n        for i in range(32):\\n            res = (res<<1) + (n&1)\\n            n>>=1\\n        return res\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n##### I hope that you\\'ve found this useful. If you like the solution and find it understandable, then do upvote it & Share it with others.\\n##### It only motivates me to write more such posts, If you found any error, any suggestions then do comment for any query\\n##### Thanks alot ! Cheers to your coding",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i = 0; i<32; i++) {\\n            res <<= 1;\\n            res += n % 2;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        res = 0\\n        for i in range(32):\\n            res = (res<<1) + (n&1)\\n            n>>=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076297,
                "title": "reverse-bits-in-3ms-using-basic-technique",
                "content": "class Solution {\\n    private:\\n     \\n    int digit(uint32_t n,int a){\\n        uint32_t num=n>>a;\\n        return num&1;\\n    }\\n    \\n    void push(uint32_t &n,int dig){\\n        n=n<<1;\\n        n=n | dig;\\n    }\\n       \\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        \\n        vector<int> v;\\n        for(int i=0;i<32;i++){\\n            v.push_back(digit(n,i));\\n        }\\n        \\n        uint32_t ans=00000000000000000000000000000000;\\n        for(int i=0;i<v.size();i++){\\n            push(ans,v[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    private:\\n     \\n    int digit(uint32_t n,int a){\\n        uint32_t num=n>>a;\\n        return num&1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1776019,
                "title": "1ms-approach-explained-with-comments",
                "content": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        int res =0;   // initialize reverse res as zero (no bit is set)\\n        int j = 0;    // j pointing to MSB (most significant bit) of res\\n        \\n        // Traverse n which is of 32 bit from end and check if ith\\'s ith bit set or not\\n        for(int i = 31; i>=0 ;i--)\\n        {   \\n            // the mask is used to move 1 to left each time when i move to left\\n            int mask = 1<<i;\\n            \\n            // if n & mask results in non - zero number then it means bit is set at ith place hence set the bit in res at jth place also\\n            if((n & mask) != 0) // & operator is used to check if bit is 1 or 0 i.e set or unset\\n            {   \\n                // In order to set bit at jth place we need setmask which would have 1 (set bit) at jth position only\\n                int smask = 1<<j;\\n                res = res | smask;  // | (or) operator is used to set bit \\n                j++;  // don\\'t forget to move j pointer too, as it is helpful in setting res \\n            }\\n            // if n & mask results in  zero number then it means bit is unset at ith place hence no need to set the bit in res at jth place , just move j to next\\n            else\\n                j++;\\n            \\n        } return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        int res =0;   // initialize reverse res as zero (no bit is set)\\n        int j = 0;    // j pointing to MSB (most significant bit) of res\\n        \\n        // Traverse n which is of 32 bit from end and check if ith\\'s ith bit set or not\\n        for(int i = 31; i>=0 ;i--)\\n        {   \\n            // the mask is used to move 1 to left each time when i move to left\\n            int mask = 1<<i;\\n            \\n            // if n & mask results in non - zero number then it means bit is set at ith place hence set the bit in res at jth place also\\n            if((n & mask) != 0) // & operator is used to check if bit is 1 or 0 i.e set or unset\\n            {   \\n                // In order to set bit at jth place we need setmask which would have 1 (set bit) at jth position only\\n                int smask = 1<<j;\\n                res = res | smask;  // | (or) operator is used to set bit \\n                j++;  // don\\'t forget to move j pointer too, as it is helpful in setting res \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1750702,
                "title": "c-100-faster-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t y=0;\\n        for(int i=31; i>=0; i--) {\\n            int p=n & 1;\\n            if(p) {\\n            y+=(1<<i);\\n            }\\n            n=n>>1;\\n        }\\n     return y;\\n    }\\n};\\n\\n// if(find helpful) {\\ndo upvote(); // thanks\\n}",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t y=0;\\n        for(int i=31; i>=0; i--) {\\n            int p=n & 1;\\n            if(p) {\\n            y+=(1<<i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1736337,
                "title": "typescript-javascript-bitwise-solution-why-the-correct-solution-won-t-work",
                "content": "I noticed almost no solutions actually successfully used bitwise operations at all. There are a several of pitfalls due to the fact that JavaScript has some surprising behavior. This covers  why the \"correct\" solution doesn\\'t actually work and several other common pitfalls.\\n\\nThe solution you would expect to work since it will work in languages with actual integer types.\\n```\\nfunction reverseBits(n: number): number {\\n  let ret: number = 0;\\n  let power: number = 31;\\n  while (n) {\\n    ret += (n & 1) << power;\\n    n = n >> 1;\\n    power -= 1;\\n  }\\n  return ret;\\n};\\n```\\nThere are at least two things wrong with this solution for JS. Before we get into it, realize that numbers in JS are actually double-precision 64-bit binary format IEEE 754 which means they are considered `doubles` in most other languages and are basically hacked together to make them feel like integers when we need them.\\n\\nFirstly, if the `n` is signed, using `>>` will cause the number to have some unexpected behavior. If you print `n` in the loop `console.debug(n, n.toString(2))` you\\'ll notice something strange happening. You\\'ll see the binary representation of the number change to `-1` over time and stay there which causes an infinite loop until **TLE**. This is the most common cause of **TLE** I see in the comments. To overcome this you have to use the Zero Fill Right Shift Operator `>>>`. This prevents the unsigned number from being interpreted as a signed integer and being ruined from a comparison standpoint. \\n\\nSecondly, at least in the V8 JavaScript engine, you can\\'t convert a signed integer into an unsigned integer via bitwise manipulation. What I mean literally is you can\\'t left shift 2^30 and expect to get 2^31. You have to inform the engine that you want whatever the number if to be considered a undesigned int.\\n\\n```\\nfunction reverseBits(n: number): number {\\n  let ret: number = 0;\\n  let power: number = 31;\\n  while (n) {\\n    ret += (n & 1) << power;\\n\\t// Zero Fill Right Shift Operator\\n    n = n >>> 1;\\n    power -= 1;\\n  }\\n  // Converts the number from a signed to an unsigned int\\n  return ret >>> 0;\\n};\\n```\\n\\nAll that being said, this is purely academic. It\\'s pretty slow because JS isn\\'t optimized for bitwise operations and very prone to pitfalls since it\\'s not really doing what it\\'s pretending to be doing since numbers are actually 64 bit doubles so don\\'t do this kind of garbage in production.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction reverseBits(n: number): number {\\n  let ret: number = 0;\\n  let power: number = 31;\\n  while (n) {\\n    ret += (n & 1) << power;\\n    n = n >> 1;\\n    power -= 1;\\n  }\\n  return ret;\\n};\\n```\n```\\nfunction reverseBits(n: number): number {\\n  let ret: number = 0;\\n  let power: number = 31;\\n  while (n) {\\n    ret += (n & 1) << power;\\n\\t// Zero Fill Right Shift Operator\\n    n = n >>> 1;\\n    power -= 1;\\n  }\\n  // Converts the number from a signed to an unsigned int\\n  return ret >>> 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592120,
                "title": "weeb-does-python",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef reverseBits(self, n: int) -> int:\\n\\t\\t\\tbinary = list(bin(n))[2:] # we don\\'t need 0b\\n\\t\\t\\tremainder = [\"0\"]\\n\\t\\t\\tzerosNeeded = 32 - len(binary)\\n\\t\\t\\tnewBinary = binary[::-1] + remainder * zerosNeeded # add the missing zeros\\n\\n\\t\\t\\treturn int(\"\".join(newBinary), 2)\\n\\t\\t\\t\\nIt ain\\'t bit manipulation, but it works\\nI\\'m just trynna take a different approach to solve the problem\\nAnyways, take a break fellow leetcoders, watch some anime instead\\nCheck out **\\u30AA\\u30FC\\u30D0\\u30FC\\u30ED\\u30FC\\u30C9 (Overlord)**\\n\\n\\n# Episodes: 39 (3 Seasons)\\n# Genres: Action, Adventure, Fantasy, Supernatural\\n# Theme: Game\\n\\nThere is also a series called **\\u30AA\\u30FC\\u30D0\\u30FC\\u30ED\\u30FC\\u30C9\\u3000\\u3077\\u308C\\u3077\\u308C\\u3077\\u308C\\u3042\\u3067\\u3059 (Overlord: Ple Ple Pleiades)** which is just some\\nparody shorts of the main series in the anime. These have no effect on the main storyline so you could choose to skip them.\\n\\nBy the way, season 4 of Overlord is confirmed!!! So if you happen to like this anime, there is more to come.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef reverseBits(self, n: int) -> int:\\n\\t\\t\\tbinary = list(bin(n))[2:] # we don\\'t need 0b\\n\\t\\t\\tremainder = [\"0\"]\\n\\t\\t\\tzerosNeeded = 32 - len(binary)\\n\\t\\t\\tnewBinary = binary[::-1] + remainder * zerosNeeded # add the missing zeros\\n\\n\\t\\t\\treturn int(\"\".join(newBinary), 2)\\n\\t\\t\\t\\nIt ain\\'t bit manipulation, but it works\\nI\\'m just trynna take a different approach to solve the problem\\nAnyways, take a break fellow leetcoders, watch some anime instead\\nCheck out **\\u30AA\\u30FC\\u30D0\\u30FC\\u30ED\\u30FC\\u30C9 (Overlord)**\\n\\n\\n# Episodes: 39 (3 Seasons)\\n# Genres: Action, Adventure, Fantasy, Supernatural\\n# Theme: Game\\n\\nThere is also a series called **\\u30AA\\u30FC\\u30D0\\u30FC\\u30ED\\u30FC\\u30C9\\u3000\\u3077\\u308C\\u3077\\u308C\\u3077\\u308C\\u3042\\u3067\\u3059 (Overlord: Ple Ple Pleiades)** which is just some\\nparody shorts of the main series in the anime. These have no effect on the main storyline so you could choose to skip them.\\n\\nBy the way, season 4 of Overlord is confirmed!!! So if you happen to like this anime, there is more to come.",
                "codeTag": "Java"
            },
            {
                "id": 1559893,
                "title": "simple-javascript-solution",
                "content": "Runtime: 84 ms, faster than 77.96% of JavaScript online submissions for Reverse Bits.\\nMemory Usage: 40.5 MB, less than 63.55% of JavaScript online submissions for Reverse Bits.\\n\\n\\n```\\nvar reverseBits = function(n) {\\n    let str = (n>>>0).toString(2).padStart(32, \\'0\\');\\n    let strReverse = str.split(\\'\\').reverse().join(\\'\\');\\n    let output = parseInt(strReverse, 2)\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar reverseBits = function(n) {\\n    let str = (n>>>0).toString(2).padStart(32, \\'0\\');\\n    let strReverse = str.split(\\'\\').reverse().join(\\'\\');\\n    let output = parseInt(strReverse, 2)\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378710,
                "title": "approach-3-mask-and-shift-visual-explanation",
                "content": "Here is my code. I hope it will help you with a better understanding. If you realize a misspelling, please write a comment. Thanks.\\n\\n\\n        \\n\\t\\t#Mask -> using \"AND\" to separate n by 2 pieces\\n        #Shift -> using \">>\" or \"<<\"\\n        #Combine -> using \"OR\" or \"XOR\"\\n        \\n        # ..:: Step #0 ::..\\n        # n = abcdefgh\\n        # Note: \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\' are not hex representation.\\n        #       Those are just block names. Every letter represents a block with 4 bits.\\n\\t\\t\\n        n = (n >> 16) ^ (n << 16)\\n\\t\\t\\n        # ..:: Step #1 ::..\\n        # Mask -> not required because we have only two blocks\\n        #------------------\\n        # Shift -> (n >> 16) = 0000abcd\\n        #          (n << 16) = efgh0000\\n        #------------------\\n        # Combine -> 0000abcd\\n        #            efgh0000\\n        #         XOR--------\\n        #            efghabcd       \\n\\t\\t\\n        n = ( (n & 0xff00ff00) >> 8 ) ^ ( (n & 0x00ff00ff) << 8 )\\n\\t\\t\\n        # ..:: Step #2 ::..\\n        # Mask -> (n & 0xff00ff00) = ef00ab00\\n        #         (n & 0x00ff00ff) = 00gh00cd\\n        #------------------\\n        # Shift -> (n & 0xff00ff00) >> 8 = 00ef00ab\\n        #          (n & 0x00ff00ff) << 8 = gh00cd00\\n        #------------------\\n        # Combine -> 00ef00ab\\n        #            gh00cd00\\n        #         XOR--------\\n        #            ghefcdab    \\n\\t\\t\\n        n = ( (n & 0xf0f0f0f0) >> 4 ) ^ ( (n & 0x0f0f0f0f) << 4 )\\n\\t\\t\\n        # ..:: Step #3 ::..\\n        # Mask -> (n & 0xf0f0f0f0) = g0e0c0a0\\n        #         (n & 0x0f0f0f0f) = 0h0f0d0b\\n        #------------------\\n        # Shift -> (n & 0xf0f0f0f0) >> 4 = 0g0e0c0a\\n        #          (n & 0x0f0f0f0f) << 4 = h0f0d0b0\\n        #------------------\\n        # Combine -> 0g0e0c0a\\n        #            h0f0d0b0\\n        #         XOR--------\\n        #            hgfedcba    \\n\\t\\t\\n        n = ( (n & 0xcccccccc) >> 2 ) ^ ( (n & 0x33333333) << 2 )\\n\\t\\t\\n        # ..:: Step #4 ::..\\n        # Note: Before reading Step #4, please take a look at the note on Step #0.\\n        #       \\'a\\' = 1234\\n        #       \\'b\\' = 1234\\n        #       \\'c\\' = 1234\\n        #       \\'d\\' = 1234\\n        #       \\'e\\' = 1234\\n        #       \\'f\\' = 1234\\n        #       \\'g\\' = 1234\\n        #       \\'h\\' = 1234\\n        #       \\'.\\' = Seperate blocks for every 4 bits. This is added to improve readability of 32 bits.\\n        #       Please look above, every integer represents a block with 1 bits.\\n        #\\n        # Mask -> \\'c\\' represents \"1100\" in 4 bit.\\n        #         \\'3\\' represents \"0011\" in 4 bit.\\n        #         n = hgfedcba = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #         (n & 0xcccccccc) = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #                            1100.1100.1100.1100.1100.1100.1100.1100\\n        #                         AND---------------------------------------\\n        #                            1200.1200.1200.1200.1200.1200.1200.1200\\n        #     \\n        #         (n & 0x33333333) = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #                            0011.0011.0011.0011.0011.0011.0011.0011\\n        #                         AND---------------------------------------\\n        #                            0034.0034.0034.0034.0034.0034.0034.0034\\n        #------------------\\n        # Shift -> (n & 0xcccccccc) >> 2 = 0012.0012.0012.0012.0012.0012.0012.0012\\n        #          (n & 0x33333333) << 2 = 3400.3400.3400.3400.3400.3400.3400.3400\\n        #------------------\\n        # Combine -> 0012.0012.0012.0012.0012.0012.0012.0012\\n        #            3400.3400.3400.3400.3400.3400.3400.3400\\n        #         XOR---------------------------------------\\n        #            3412.3412.3412.3412.3412.3412.3412.3412 \\n\\t\\t\\n        n = ( (n & 0xaaaaaaaa) >> 1 ) ^ ( (n & 0x55555555) << 1 )\\n\\t\\t\\n        # ..:: Step #5 ::..\\n        # Note: Before reading Step #5, please take a look at notes on Step #0 and Step#4.\\n        #\\n        # Mask -> \\'a\\' represents \"1010\" in 4 bit.\\n        #         \\'5\\' represents \"0101\" in 4 bit.\\n        #         n = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #         (n & 0xaaaaaaaa) = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #                            1010.1010.1010.1010.1010.1010.1010.1010\\n        #                         AND---------------------------------------\\n        #                            3010.3010.3010.3010.3010.3010.3010.3010\\n        #     \\n        #         (n & 0x55555555) = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #                            0101.0101.0101.0101.0101.0101.0101.0101\\n        #                         AND---------------------------------------\\n        #                            0402.0402.0402.0402.0402.0402.0402.0402\\n        #------------------\\n        # Shift -> (n & 0xaaaaaaaa) >> 1 = 0301.0301.0301.0301.0301.0301.0301.0301\\n        #          (n & 0x55555555) << 1 = 4020.4020.4020.4020.4020.4020.4020.4020\\n        #------------------\\n        # Combine -> 0301.0301.0301.0301.0301.0301.0301.0301\\n        #            4020.4020.4020.4020.4020.4020.4020.4020\\n        #         XOR---------------------------------------\\n        #            4321.4321.4321.4321.4321.4321.4321.4321\\n\\t\\t\\n        return n\\n",
                "solutionTags": [],
                "code": "Here is my code. I hope it will help you with a better understanding. If you realize a misspelling, please write a comment. Thanks.\\n\\n\\n        \\n\\t\\t#Mask -> using \"AND\" to separate n by 2 pieces\\n        #Shift -> using \">>\" or \"<<\"\\n        #Combine -> using \"OR\" or \"XOR\"\\n        \\n        # ..:: Step #0 ::..\\n        # n = abcdefgh\\n        # Note: \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\' are not hex representation.\\n        #       Those are just block names. Every letter represents a block with 4 bits.\\n\\t\\t\\n        n = (n >> 16) ^ (n << 16)\\n\\t\\t\\n        # ..:: Step #1 ::..\\n        # Mask -> not required because we have only two blocks\\n        #------------------\\n        # Shift -> (n >> 16) = 0000abcd\\n        #          (n << 16) = efgh0000\\n        #------------------\\n        # Combine -> 0000abcd\\n        #            efgh0000\\n        #         XOR--------\\n        #            efghabcd       \\n\\t\\t\\n        n = ( (n & 0xff00ff00) >> 8 ) ^ ( (n & 0x00ff00ff) << 8 )\\n\\t\\t\\n        # ..:: Step #2 ::..\\n        # Mask -> (n & 0xff00ff00) = ef00ab00\\n        #         (n & 0x00ff00ff) = 00gh00cd\\n        #------------------\\n        # Shift -> (n & 0xff00ff00) >> 8 = 00ef00ab\\n        #          (n & 0x00ff00ff) << 8 = gh00cd00\\n        #------------------\\n        # Combine -> 00ef00ab\\n        #            gh00cd00\\n        #         XOR--------\\n        #            ghefcdab    \\n\\t\\t\\n        n = ( (n & 0xf0f0f0f0) >> 4 ) ^ ( (n & 0x0f0f0f0f) << 4 )\\n\\t\\t\\n        # ..:: Step #3 ::..\\n        # Mask -> (n & 0xf0f0f0f0) = g0e0c0a0\\n        #         (n & 0x0f0f0f0f) = 0h0f0d0b\\n        #------------------\\n        # Shift -> (n & 0xf0f0f0f0) >> 4 = 0g0e0c0a\\n        #          (n & 0x0f0f0f0f) << 4 = h0f0d0b0\\n        #------------------\\n        # Combine -> 0g0e0c0a\\n        #            h0f0d0b0\\n        #         XOR--------\\n        #            hgfedcba    \\n\\t\\t\\n        n = ( (n & 0xcccccccc) >> 2 ) ^ ( (n & 0x33333333) << 2 )\\n\\t\\t\\n        # ..:: Step #4 ::..\\n        # Note: Before reading Step #4, please take a look at the note on Step #0.\\n        #       \\'a\\' = 1234\\n        #       \\'b\\' = 1234\\n        #       \\'c\\' = 1234\\n        #       \\'d\\' = 1234\\n        #       \\'e\\' = 1234\\n        #       \\'f\\' = 1234\\n        #       \\'g\\' = 1234\\n        #       \\'h\\' = 1234\\n        #       \\'.\\' = Seperate blocks for every 4 bits. This is added to improve readability of 32 bits.\\n        #       Please look above, every integer represents a block with 1 bits.\\n        #\\n        # Mask -> \\'c\\' represents \"1100\" in 4 bit.\\n        #         \\'3\\' represents \"0011\" in 4 bit.\\n        #         n = hgfedcba = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #         (n & 0xcccccccc) = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #                            1100.1100.1100.1100.1100.1100.1100.1100\\n        #                         AND---------------------------------------\\n        #                            1200.1200.1200.1200.1200.1200.1200.1200\\n        #     \\n        #         (n & 0x33333333) = 1234.1234.1234.1234.1234.1234.1234.1234\\n        #                            0011.0011.0011.0011.0011.0011.0011.0011\\n        #                         AND---------------------------------------\\n        #                            0034.0034.0034.0034.0034.0034.0034.0034\\n        #------------------\\n        # Shift -> (n & 0xcccccccc) >> 2 = 0012.0012.0012.0012.0012.0012.0012.0012\\n        #          (n & 0x33333333) << 2 = 3400.3400.3400.3400.3400.3400.3400.3400\\n        #------------------\\n        # Combine -> 0012.0012.0012.0012.0012.0012.0012.0012\\n        #            3400.3400.3400.3400.3400.3400.3400.3400\\n        #         XOR---------------------------------------\\n        #            3412.3412.3412.3412.3412.3412.3412.3412 \\n\\t\\t\\n        n = ( (n & 0xaaaaaaaa) >> 1 ) ^ ( (n & 0x55555555) << 1 )\\n\\t\\t\\n        # ..:: Step #5 ::..\\n        # Note: Before reading Step #5, please take a look at notes on Step #0 and Step#4.\\n        #\\n        # Mask -> \\'a\\' represents \"1010\" in 4 bit.\\n        #         \\'5\\' represents \"0101\" in 4 bit.\\n        #         n = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #         (n & 0xaaaaaaaa) = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #                            1010.1010.1010.1010.1010.1010.1010.1010\\n        #                         AND---------------------------------------\\n        #                            3010.3010.3010.3010.3010.3010.3010.3010\\n        #     \\n        #         (n & 0x55555555) = 3412.3412.3412.3412.3412.3412.3412.3412\\n        #                            0101.0101.0101.0101.0101.0101.0101.0101\\n        #                         AND---------------------------------------\\n        #                            0402.0402.0402.0402.0402.0402.0402.0402\\n        #------------------\\n        # Shift -> (n & 0xaaaaaaaa) >> 1 = 0301.0301.0301.0301.0301.0301.0301.0301\\n        #          (n & 0x55555555) << 1 = 4020.4020.4020.4020.4020.4020.4020.4020\\n        #------------------\\n        # Combine -> 0301.0301.0301.0301.0301.0301.0301.0301\\n        #            4020.4020.4020.4020.4020.4020.4020.4020\\n        #         XOR---------------------------------------\\n        #            4321.4321.4321.4321.4321.4321.4321.4321\\n\\t\\t\\n        return n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 755158,
                "title": "simple-solution-in-js",
                "content": "If we take an input as 00110\\nResult will be a list of {0,1,1,0,0}, then we join and convert it into decimal number which is the same as output: 01100\\n![image](https://assets.leetcode.com/users/images/7e5b6285-52f3-4d67-a815-1b3f2a3002ca_1595702441.2824879.png)\\n\\nvar reverseBits = function(n) {\\n    var len = 32;\\n    var arr = new Array()\\n    while(len > 0){\\n        var t = n & 1;\\n        n = n >> 1;\\n        arr.push(t);\\n        len--;\\n    }\\n    var res = arr.join(\\'\\');\\n    return parseInt(res, 2);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "If we take an input as 00110\\nResult will be a list of {0,1,1,0,0}, then we join and convert it into decimal number which is the same as output: 01100\\n![image](https://assets.leetcode.com/users/images/7e5b6285-52f3-4d67-a815-1b3f2a3002ca_1595702441.2824879.png)\\n\\nvar reverseBits = function(n) {\\n    var len = 32;\\n    var arr = new Array()\\n    while(len > 0){\\n        var t = n & 1;\\n        n = n >> 1;\\n        arr.push(t);\\n        len--;\\n    }\\n    var res = arr.join(\\'\\');\\n    return parseInt(res, 2);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 733084,
                "title": "java-clean-code-easy-to-understand-1-ms-time-99-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int reverseBits (int n) {\\n\\t\\t\\n\\t\\tint ans = 0;\\n \\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tans += (n & 1);\\n\\t\\t\\tif (i == 31) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans <<= 1;\\n\\t\\t\\tn >>= 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int reverseBits (int n) {\\n\\t\\t\\n\\t\\tint ans = 0;\\n \\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tans += (n & 1);\\n\\t\\t\\tif (i == 31) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans <<= 1;\\n\\t\\t\\tn >>= 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678194,
                "title": "java-solution-with-full-explanation",
                "content": "Java solution with full explanation\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        boolean isNegative = n < 0;\\n        \\n        int reverseNumber = 0;\\n        \\n        // counter to track the number of bits in the number\\n        int count = 31;\\n        \\n        while(count != 0){\\n            //getting the last bit from the number\\n\\t\\t\\t// Suppose number is 5, i.e. 0000 0101, then we perform AND operation with 0000 0001,\\n\\t\\t\\t// so we get 0000 0001 i.e. the last bit of the number 5\\n            int lastBit = n & 1;\\n            \\n            // add it to the reverseNumber variable using OR operation, initially reverse number is 0\\n\\t\\t\\t// 0000 0000 | 0000 0001 = 0000 0001(Based on the example of number 5)\\n            reverseNumber = reverseNumber | lastBit;\\n            \\n            // shift one position to the left\\n\\t\\t\\t// After left shift, current reverse number will become : 0000 0010\\n            reverseNumber = reverseNumber << 1;\\n            \\n            // now right shift the number one position\\n\\t\\t\\t// After right shift of 5, current input number : 0000 0010\\n            n = n >> 1;\\n            \\n            count--;\\n        }// Now we repeat the process\\n        \\n        \\n        return isNegative?reverseNumber+1:reverseNumber;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        \\n        boolean isNegative = n < 0;\\n        \\n        int reverseNumber = 0;\\n        \\n        // counter to track the number of bits in the number\\n        int count = 31;\\n        \\n        while(count != 0){\\n            //getting the last bit from the number\\n\\t\\t\\t// Suppose number is 5, i.e. 0000 0101, then we perform AND operation with 0000 0001,\\n\\t\\t\\t// so we get 0000 0001 i.e. the last bit of the number 5\\n            int lastBit = n & 1;\\n            \\n            // add it to the reverseNumber variable using OR operation, initially reverse number is 0\\n\\t\\t\\t// 0000 0000 | 0000 0001 = 0000 0001(Based on the example of number 5)\\n            reverseNumber = reverseNumber | lastBit;\\n            \\n            // shift one position to the left\\n\\t\\t\\t// After left shift, current reverse number will become : 0000 0010\\n            reverseNumber = reverseNumber << 1;\\n            \\n            // now right shift the number one position\\n\\t\\t\\t// After right shift of 5, current input number : 0000 0010\\n            n = n >> 1;\\n            \\n            count--;\\n        }// Now we repeat the process\\n        \\n        \\n        return isNegative?reverseNumber+1:reverseNumber;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661484,
                "title": "c-3-lines-with-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        string str(bitset<32>(n).to_string());\\n        reverse(str.begin(), str.end());\\n        return bitset<32>(str).to_ulong();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        string str(bitset<32>(n).to_string());\\n        reverse(str.begin(), str.end());\\n        return bitset<32>(str).to_ulong();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492436,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int((format(n,\\'#034b\\')[2:])[::-1], 2)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int((format(n,\\'#034b\\')[2:])[::-1], 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54827,
                "title": "javascript-solution",
                "content": "    /**\\n     * @param {number} n - a positive integer\\n     * @return {number} - a positive integer\\n     */\\n    var reverseBits = function(n) {\\n        var res = 0;\\n        var i = 31;\\n        while(i > 0){\\n            res = res << 1;\\n            if(n & 1){\\n                res = res | 1;\\n            }\\n            n = n >> 1;\\n            i -= 1;\\n        }\\n        if(n & 1){\\n            return  res * 2 + 1;\\n        } else {\\n            return res * 2;\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @param {number} n - a positive integer\\n     * @return {number} - a positive integer\\n     */\\n    var reverseBits = function(n) {\\n        var res = 0;\\n        var i = 31;\\n        while(i > 0){\\n            res = res << 1;\\n            if(n & 1){\\n                res = res | 1;\\n            }\\n            n = n >> 1;\\n            i -= 1;\\n        }\\n        if(n & 1){\\n            return  res * 2 + 1;\\n        } else {\\n            return res * 2;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 54904,
                "title": "my-simple-javascript-solution",
                "content": "    var reverseBits = function(n) {\\n    \\n    var str=n.toString(2).split(\"\").reverse().join(\"\");\\n    while(str.length<32){\\n        str=str+'0';\\n    }\\n    console.log(str);\\n    return parseInt(str, 2);\\n    \\n};",
                "solutionTags": [],
                "code": "    var reverseBits = function(n) {\\n    \\n    var str=n.toString(2).split(\"\").reverse().join(\"\");\\n    while(str.length<32){\\n        str=str+'0';\\n    }\\n    console.log(str);\\n    return parseInt(str, 2);\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 54930,
                "title": "share-my-solution-how-to-optimize-it-when-this-function-is-called-many-times",
                "content": "\\n    private int[] reverseHex = new int[] {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15};\\n\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int rev = 0;\\n        while (n != 0) {\\n            rev = (rev << 4) + reverseHex[n & 0xF];\\n            n >>>= 4;\\n        }\\n        return rev;\\n    }\\n\\n1. Create an array that contains the reverse number of 0-15.\\n2. Divide the number into 8 parts, each part has 4 bits which can represent number 0-15. Get the reverse number of each part using the array.",
                "solutionTags": [],
                "code": "\\n    private int[] reverseHex = new int[] {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15};\\n\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int rev = 0;\\n        while (n != 0) {\\n            rev = (rev << 4) + reverseHex[n & 0xF];\\n            n >>>= 4;\\n        }\\n        return rev;\\n    }\\n\\n1. Create an array that contains the reverse number of 0-15.\\n2. Divide the number into 8 parts, each part has 4 bits which can represent number 0-15. Get the reverse number of each part using the array.",
                "codeTag": "Unknown"
            },
            {
                "id": 54975,
                "title": "python-easy-to-understand-solutions",
                "content": "```\\nclass Solution:\\n    def reverseBits1(self, n):\\n        res = 0\\n        for _ in range(32):\\n            res = res*2 + (n & 1)\\n            n >>= 1\\n        return res\\n\\n    def reverseBits(self, n):\\n        res, i = 0, 31\\n        while n:\\n            res += (n & 1) << i\\n            n >>= 1\\n            i -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits1(self, n):\\n        res = 0\\n        for _ in range(32):\\n            res = res*2 + (n & 1)\\n            n >>= 1\\n        return res\\n\\n    def reverseBits(self, n):\\n        res, i = 0, 31\\n        while n:\\n            res += (n & 1) << i\\n            n >>= 1\\n            i -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686805,
                "title": "simplest-way",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        // precomputed the 2^31 (1000...31times in bit form) value as we have to find reverse\\n        // otherwise it would have 2^0 (1 in bit form)\\n        uint32_t x = 1 << 31;\\n\\n        while (n) {\\n            // checks if the bit is set or not using (n&1)\\n            // if bit is set then add x to the res\\n            // here x = 2^(31-i)\\n            // where i will be the ith bit from right\\n            if (n&1) res += x;\\n\\n            // update the n i.e n = n/2\\n            n >>= 1;\\n            // update the x i.e x = x/2\\n            // since, we have to find reverse so instead of multiplying by 2 we have to divide by 2\\n            x >>= 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        // precomputed the 2^31 (1000...31times in bit form) value as we have to find reverse\\n        // otherwise it would have 2^0 (1 in bit form)\\n        uint32_t x = 1 << 31;\\n\\n        while (n) {\\n            // checks if the bit is set or not using (n&1)\\n            // if bit is set then add x to the res\\n            // here x = 2^(31-i)\\n            // where i will be the ith bit from right\\n            if (n&1) res += x;\\n\\n            // update the n i.e n = n/2\\n            n >>= 1;\\n            // update the x i.e x = x/2\\n            // since, we have to find reverse so instead of multiplying by 2 we have to divide by 2\\n            x >>= 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612196,
                "title": "c-beats-100-most-easy-and-best-solution-ever",
                "content": "# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans;\\n        for(int i = 0; i < 32; i++) {\\n            ans = ans << 1;\\n            bool bit = n & 1;\\n            ans = ans | bit;\\n            n = n >> 1;\\n            // cout << bit << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans;\\n        for(int i = 0; i < 32; i++) {\\n            ans = ans << 1;\\n            bool bit = n & 1;\\n            ans = ans | bit;\\n            n = n >> 1;\\n            // cout << bit << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3394452,
                "title": "explained-beginner-friendly-one-liner-python3-fast-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInt -> Bin -> reverse -> Int\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n- Detailed \\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        bin_convert = bin(n) \\n        bin_convert_2 = bin_convert[2:]\\n        bin_fill_zero = bin_convert_2.zfill(32)\\n        reverse_bin = bin_fill_zero[::-1]\\n        answer = int(reverse_bin, 2)\\n        return answer\\n```\\n- One-Liner\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return (int((bin(n)[2:].zfill(32))[::-1], 2))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        bin_convert = bin(n) \\n        bin_convert_2 = bin_convert[2:]\\n        bin_fill_zero = bin_convert_2.zfill(32)\\n        reverse_bin = bin_fill_zero[::-1]\\n        answer = int(reverse_bin, 2)\\n        return answer\\n```\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return (int((bin(n)[2:].zfill(32))[::-1], 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005456,
                "title": "easyc-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005360,
                "title": "rb2c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942145,
                "title": "easiest-question-reversebits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t x = 0;\\n        int d = 0;\\n        while(n>0){\\n            x+=(n%2) << (31-d);\\n            n >>= 1;\\n            d++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789487,
                "title": "c-0ms-easy-to-understand",
                "content": "# Upvote if its helps\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0,count=32;\\n        //ans<<=1;\\n        //n>>=1;\\n        while(count){\\n            ans+=n&1;\\n            count--;\\n            n>>=1;\\n            if(count) ans<<=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans=0,count=32;\\n        //ans<<=1;\\n        //n>>=1;\\n        while(count){\\n            ans+=n&1;\\n            count--;\\n            n>>=1;\\n            if(count) ans<<=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770969,
                "title": "java-easy-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int reverseBits(int n) \\n    {\\n        int i , reverse = 0 ;\\n        for( i = 0 ; i < 32 ; i++ )\\n        {\\n            reverse = reverse << 1 ;\\n            if( ( n & 1 ) == 1 )\\n            {\\n                reverse = reverse | 1 ;\\n            }\\n            n = n >> 1 ;\\n        }\\n        return reverse ;       \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int reverseBits(int n) \\n    {\\n        int i , reverse = 0 ;\\n        for( i = 0 ; i < 32 ; i++ )\\n        {\\n            reverse = reverse << 1 ;\\n            if( ( n & 1 ) == 1 )\\n            {\\n                reverse = reverse | 1 ;\\n            }\\n            n = n >> 1 ;\\n        }\\n        return reverse ;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461453,
                "title": "javascript-bit-manipulation-watch-out-for-negative-numbers",
                "content": "```\\nfunction reverseBits(n) {\\n    let ans = 0;\\n    \\n    for (let i = 0; i < 32; i++) {\\n        ans = ans * 2 + n % 2;\\n        n >>>= 1;\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction reverseBits(n) {\\n    let ans = 0;\\n    \\n    for (let i = 0; i < 32; i++) {\\n        ans = ans * 2 + n % 2;\\n        n >>>= 1;\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456553,
                "title": "javascript-simple-functional-approach",
                "content": "```\\nfunction reverseBits(bits) {\\n    return parseInt(bits.toString(2).split(\"\").reverse().join(\"\").padEnd(32, \"0\"), 2);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction reverseBits(bits) {\\n    return parseInt(bits.toString(2).split(\"\").reverse().join(\"\").padEnd(32, \"0\"), 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391999,
                "title": "javascript",
                "content": "```\\nvar reverseBits = function (n) {\\n  let res = 0;\\n  for (let i = 0; i < 32; i++) {\\n    res = (res << 1) | (n & 1);\\n    n >>= 1;\\n  }\\n  return res >>> 0;\\n};",
                "solutionTags": [],
                "code": "```\\nvar reverseBits = function (n) {\\n  let res = 0;\\n  for (let i = 0; i < 32; i++) {\\n    res = (res << 1) | (n & 1);\\n    n >>= 1;\\n  }\\n  return res >>> 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2370464,
                "title": "faster-than-90-solutions-in-3-lines",
                "content": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\n\\n// remember the binary must always be of length 32 ;);\\nvar reverseBits = function(n) {\\n    const reversedBin = n.toString(2).split(\\'\\').reverse().join(\\'\\');\\n    const result =  reversedBin.padEnd(32,\\'0\\'); \\n    return parseInt(result, 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\n\\n// remember the binary must always be of length 32 ;);\\nvar reverseBits = function(n) {\\n    const reversedBin = n.toString(2).split(\\'\\').reverse().join(\\'\\');\\n    const result =  reversedBin.padEnd(32,\\'0\\'); \\n    return parseInt(result, 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192172,
                "title": "c-code-100-optimal-beginner-s-friendly",
                "content": "**Please Upvote the solution if it helped you because a single upvote motivate the creator\\'s like us to create more content...........**\\n\\nCode ->\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int res=0;\\n        for(int i=0 ;i<32;i++){\\n            int t=n&1;\\n            int ans=t<<(31-i);\\n            res=res|ans;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nHappy Coding :-)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int res=0;\\n        for(int i=0 ;i<32;i++){\\n            int t=n&1;\\n            int ans=t<<(31-i);\\n            res=res|ans;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118386,
                "title": "java-bitwise-simple-short-solution",
                "content": "This is quite simple to understand java solution. \\n\\nThe main idea is loop on each digit of the number (32 digits in total):\\n- take the least significant digit from the number and place it on the least significant digit of the new number\\n- shift the digits of the new number to the left to make them older\\n\\n```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int reversed = 0, digit = -1;\\n\\n        while (++digit < 32) {\\n            reversed <<= 1;\\n            reversed |= n & 0b1;\\n            n >>= 1;\\n        }\\n\\n        return reversed;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int reverseBits(int n) {\\n        int reversed = 0, digit = -1;\\n\\n        while (++digit < 32) {\\n            reversed <<= 1;\\n            reversed |= n & 0b1;\\n            n >>= 1;\\n        }\\n\\n        return reversed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075869,
                "title": "mask-shift-c-solution",
                "content": "```\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t result = 0;\\n    for (int i = 0; i < 32; i++) {\\n        result = (result << 1) + (n & 1);\\n        n >>= 1;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t result = 0;\\n    for (int i = 0; i < 32; i++) {\\n        result = (result << 1) + (n & 1);\\n        n >>= 1;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074789,
                "title": "reverse-bits-o-n-time-complexity-o-1-space-complexity-100-percent-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int i=0;\\n        uint32_t number=0;\\n        while(i<32){\\n            number = (number<<1)+(n&1);// Multiplication using left shift\\n            n=n>>1;// Division using right shift\\n            i++;\\n        }\\n        return number;\\n    }\\n};\\n```\\n**if(Helpful) {\\n\\tplease upvote;\\n}**\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int i=0;\\n        uint32_t number=0;\\n        while(i<32){\\n            number = (number<<1)+(n&1);// Multiplication using left shift\\n            n=n>>1;// Division using right shift\\n            i++;\\n        }\\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001398,
                "title": "bit-algorithm-explained",
                "content": "\\n\\n\\n\\n* As size is fixed of 32 bits \\n* Create a for loop for looping upto 32 times \\n* and store the last digit of n using n&1\\n* than add into res than left shift to i \\n* than store the res into ans by ans | res\\n* return ans \\n\\n\\n\\n```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for(int i = 31;i>=0;i--)\\n        {\\n            int res = n&1;\\n            res = res<<i;\\n            ans = ans|res;\\n            n = n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need treat n as an unsigned value\\n    public int reverseBits(int n) {\\n        int ans = 0;\\n        for(int i = 31;i>=0;i--)\\n        {\\n            int res = n&1;\\n            res = res<<i;\\n            ans = ans|res;\\n            n = n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839116,
                "title": "c-100-faster-o-1-space-3-lines-code-bit-manipulation",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        \\n        int sum = 0, ln=32;\\n        while(ln--){\\n            sum = 2LL*sum + n%2;\\n            n >>= 1;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        \\n        int sum = 0, ln=32;\\n        while(ln--){\\n            sum = 2LL*sum + n%2;\\n            n >>= 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1615371,
                "title": "c-explanation-for-absolute-beginners",
                "content": "**Solution Explanation**\\n\\nEach time we divide the number by 2, we actually get the right most bit from its binary representation\\nFor example;\\n110**1** = 13\\n1 is the right most bit\\n\\n13 % 2 = **1**\\n13 / 2 = 6\\n6 % 2 = **0**\\n6 / 2 = 3\\n3 % 2 = **1**\\n1 / 2 = 0\\n1 % 2 = **1**\\n\\nIn this way, we can get the bits in the binary representation starting form right to left. By using this division method, we can also get the real value(result integer value) of reversed number by multiplicating the digits by their correct 2 to the powers.\\n\\nOriginal Number\\n```\\n0       0       0       .....      1       1       0       1\\n2^31   2^30    2^29               2^3     2^2     2^1     2^0\\n```\\n\\nReversed Number\\n```\\n1       0       1      1      .....                0       0       0\\n2^31   2^30    2^29    2^28                       2^2     2^1     2^0\\n```\\n\\nAs you can see, once we get the right most bit, we can multiply it with 2^nth and add up onto result value, so that we will have the output.\\n\\n**C++ O(32) Time & O(1) Memory Solution**\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t result = 0;\\n        for (int k = 32, power = 31; k > 0; k--, power--) {\\n            int rem = n % 2;\\n            if (rem > 0) {\\n                result += pow(2, power);\\n            }\\n            n >>= 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n0       0       0       .....      1       1       0       1\\n2^31   2^30    2^29               2^3     2^2     2^1     2^0\\n```\n```\\n1       0       1      1      .....                0       0       0\\n2^31   2^30    2^29    2^28                       2^2     2^1     2^0\\n```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t result = 0;\\n        for (int k = 32, power = 31; k > 0; k--, power--) {\\n            int rem = n % 2;\\n            if (rem > 0) {\\n                result += pow(2, power);\\n            }\\n            n >>= 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480288,
                "title": "c-simple-beginner-easy-to-understand",
                "content": "Idea : idea is simple we make res by finding current rightmost of n and then rightshift n!!!\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int res = 0;\\n        for(int i = 0 ; i < 32 ; ++i)\\n        {\\n            res = (res << 1) + (n & 1); // inserting 0 or 1 in res on the basis of last bit of n\\n            n = n >> 1; // righshifting n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int res = 0;\\n        for(int i = 0 ; i < 32 ; ++i)\\n        {\\n            res = (res << 1) + (n & 1); // inserting 0 or 1 in res on the basis of last bit of n\\n            n = n >> 1; // righshifting n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428971,
                "title": "easy-clean-c-solution",
                "content": "right shift n after every iteration, left shift the result after every iteration. iterate for 32 times.\\nwhat this basically translates to is that we keep getting the rightmost bit of the number ,store it in the result and then left shift the result whlie simultaneously removing the rightmost bit of n in every iteration.\\n```\\n uint32_t reverseBits(uint32_t n) {\\n        uint32_t result=0;\\n        for(int i=0;i<32;++i){\\n            result=result<<1;\\n            result|=(n&1);\\n            n=n>>1;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n uint32_t reverseBits(uint32_t n) {\\n        uint32_t result=0;\\n        for(int i=0;i<32;++i){\\n            result=result<<1;\\n            result|=(n&1);\\n            n=n>>1;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352859,
                "title": "c-o-1-time-o-1-space-clean-concise-solution-with-detailed-explaination",
                "content": "* **Solution**\\nA 32 bits unsigned integer will have 32 bits with index from 0 to 31 from right to left. So to inverse 32 bits unsigned integer we will go through all the bits of n from 0 to 31 and add the the bit to our result. In order to do that we must know some knowledge about binary number :\\nn << 1 = n shift left 1 = move all the bits of n value to the left by 1 unit\\nexample: 0001 << 1 = 0010\\nn >> 1 = n shift right 1 = move all the bits of n value to right by 1 unit\\nexample: 1000 >> 1 = 0100\\nTherefore to solve this problem we get the rightmost bit ( by doing n mod 2 because we\\'re calculating in base 2 ) then add it to **result << 1**. To make sure the next bit is the rightmost bit we do **n>>1**, keep doing until we go through all 32 bits of n.\\n\\n\\n* **Time Complexity**\\nWe use a constant loop so the time complexity is O(32) which means **O(1)**.\\n\\n* **Space Complexity**\\nBecause we use constant number of variables so the space complexity is **O(1)**.\\n\\n* **Source Code**\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i=0;i<32;++i) {\\n            res = (res<<1) + (n % 2);\\n            n = (n>>1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for (int i=0;i<32;++i) {\\n            res = (res<<1) + (n % 2);\\n            n = (n>>1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265259,
                "title": "100-c",
                "content": "This is a little non-intuitive at first, but here is the explaination:\\n* \\tMake a uint_32t variable res initalised to zero and power initialised to 31.\\n* \\tNow, while(n), pick the rightmost bit of n (n&1) and leftshift it by 31 places and store in res.\\n* \\tRightshift n (n>>1) and decrement power.\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res=0,power=31;\\n        while(n){\\n            res+=(n&1)<<power;\\n            n=n>>1;\\n            power-=1;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t res=0,power=31;\\n        while(n){\\n            res+=(n&1)<<power;\\n            n=n>>1;\\n            power-=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237141,
                "title": "2-liner-python",
                "content": "Approach:\\n* keep extracting bits from 1st to 32nd by periodically masking the input (shifting the mask bit right by one)\\n* if the extracted bit is 1 then add the corresponding power of 2 to the answer\\n\\n```\\n    def reverseBits(self, n: int) -> int:\\n        mask = 2**31\\n        return sum(2**i for i in range(32) if n&(mask>>i))\\n```\\n\\nLonger and more readable form:\\n```\\n    def reverseBits_1(self, n:int) -> int:\\n        mask = 2**31\\n        ans = 0\\n        for i in range(32):\\n            if n & mask : ans += 2**i\\n            mask >>= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\n    def reverseBits(self, n: int) -> int:\\n        mask = 2**31\\n        return sum(2**i for i in range(32) if n&(mask>>i))\\n```\n```\\n    def reverseBits_1(self, n:int) -> int:\\n        mask = 2**31\\n        ans = 0\\n        for i in range(32):\\n            if n & mask : ans += 2**i\\n            mask >>= 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1169541,
                "title": "simple-java-1ms-solution",
                "content": "\\tpublic int reverseBits(int n) { \\n\\n        int res = 0;\\n\\t\\t\\n        for(int i=0;i<32;i++){\\n\\t\\t\\n\\t\\t\\t//calculate least significant bit\\n            int lsb = n & 1;\\n\\t\\t\\t\\n\\t\\t\\t// left shift lsb bit by (31-i) times\\n            lsb = lsb << (31-i);\\n\\t\\t\\t\\n\\t\\t\\t// update result by performing OR between result and least significant bit\\n            res = res | lsb;\\n\\t\\t\\t\\n\\t\\t\\t// lsb is added to the result, so right shift the number by one\\n            n = n >> 1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "\\tpublic int reverseBits(int n) { \\n\\n        int res = 0;\\n\\t\\t\\n        for(int i=0;i<32;i++){\\n\\t\\t\\n\\t\\t\\t//calculate least significant bit\\n            int lsb = n & 1;\\n\\t\\t\\t\\n\\t\\t\\t// left shift lsb bit by (31-i) times\\n            lsb = lsb << (31-i);\\n\\t\\t\\t\\n\\t\\t\\t// update result by performing OR between result and least significant bit\\n            res = res | lsb;\\n\\t\\t\\t\\n\\t\\t\\t// lsb is added to the result, so right shift the number by one\\n            n = n >> 1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1017982,
                "title": "scala",
                "content": "```\\ndef reverseBits(x: Int): Int = {\\nimport scala.annotation.tailrec\\n    @tailrec\\n    def reverse(in: Int, n: Int = 32, out: Int = 0): Int =\\n      if (n == 0) out\\n      else reverse(in >>> 1, n - 1, (out << 1) | (in & 1)) //magic\\n\\n    reverse(x)\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef reverseBits(x: Int): Int = {\\nimport scala.annotation.tailrec\\n    @tailrec\\n    def reverse(in: Int, n: Int = 32, out: Int = 0): Int =\\n      if (n == 0) out\\n      else reverse(in >>> 1, n - 1, (out << 1) | (in & 1)) //magic\\n\\n    reverse(x)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 733451,
                "title": "javascript-clean-one-liner",
                "content": "```javascript\\nvar reverseBits = function(n) {\\n    const bits = n.toString(2).padStart(32, \\'0\\').split(\\'\\').reverse().join(\\'\\');\\n    return parseInt(bits, 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar reverseBits = function(n) {\\n    const bits = n.toString(2).padStart(32, \\'0\\').split(\\'\\').reverse().join(\\'\\');\\n    return parseInt(bits, 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732071,
                "title": "c-two-solutions",
                "content": "### Solution 1 - Swapping the bits using bitset\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        bitset<32>b = {n}; \\n        int right = 0,left=31; \\n        while(right < left){\\n\\t\\t\\tint t  = b[right];\\n            b[right++] = b[left];\\n            b[left--] = t;\\n        }\\n        return b.to_ulong();\\n\\n    }\\n};\\n```\\n\\n### Solution 2 - Set the 31-ith bit if ith bit is set\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;  // set ans as 0\\n\\t\\t//  if the ith bit of n is set then set 31-i th bit of ans  (similar to the swap)\\n        for (int i=0;i<=31;i++) ans += (n & (1<<i)) ? 1<<(31-i) : 0; \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        bitset<32>b = {n}; \\n        int right = 0,left=31; \\n        while(right < left){\\n\\t\\t\\tint t  = b[right];\\n            b[right++] = b[left];\\n            b[left--] = t;\\n        }\\n        return b.to_ulong();\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;  // set ans as 0\\n\\t\\t//  if the ith bit of n is set then set 31-i th bit of ans  (similar to the swap)\\n        for (int i=0;i<=31;i++) ans += (n & (1<<i)) ? 1<<(31-i) : 0; \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535299,
                "title": "go",
                "content": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var result uint32   \\n    for i := 0; i < 32; i++ {\\n        result += num >> i << 31 >> i\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var result uint32   \\n    for i := 0; i < 32; i++ {\\n        result += num >> i << 31 >> i\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 411157,
                "title": "c-o-1-lookup-table-with-explanation",
                "content": "\\n```\\n    uint32_t reverseBits(uint32_t x) {\\n\\t\\n        uint32_t lookupTable[256]; // To achieve O(1) we need to do work beforehand, create a lookup table.\\n\\t\\t\\n        for (uint32_t i{}; i < 256; i++) { // 256 combinations in 8 bits (1 byte)\\n            lookupTable[i] = (i&1) * pow(2,7) + // If a bit exists at position 1, the reverse will have a bit at position 8.\\n                            ((i&2)>>1) * pow(2,6) + // As you can see, (i&2)>>1 is either 1 or 0. If it\\'s 1, \\n                            ((i&4)>>2) * pow(2,5) + // we add 2^6 (turn on a bit at position 7). \\n                            ((i&8)>>3) * pow(2,4) + // We continue this for every bit position for eight bits in a byte.\\n                            ((i&16)>>4) * pow(2,3) +\\n                            ((i&32)>>5) * pow(2,2) +\\n                            ((i&64)>>6) * pow(2,1) +\\n                            ((i&128)>>7) * pow(2,0);\\n        }\\n        \\n        uint32_t result = 0; // The new result starts at 0.\\n        result = (lookupTable[x & 0xff] << 24) + (lookupTable[x>>8 & 0xff] << 16) + (lookupTable[x>>16 & 0xff] << 8) \\n\\t\\t+ lookupTable[x>>24 & 0xff]; \\n\\t\\t\\n\\t\\t// This part is worth explaining. I explain below.\\n\\t\\t\\n        return result;\\n    }\\n```\\n\\t\\n\\tWe start by looking at the first 8 bits (x & 0xff). We look the number up in the table to find it\\'s reverse. \\n\\tWe then add 24 zeros in its binary representation such that this first block of 8 bits is now the last block \\n\\tof eight bits (it\\'s like a mirror image).\\n\\t\\n\\tFor example, if our first number was 0000\\'0001, we find the reverse via the lookup table and \\n\\tget: 1000\\'0000. We then push it over 24 times so it looks as follows. We repeat for the next three chunks of 8 bits \\n\\tsuch that we are left with these four  lookup results:\\n\\t\\n\\t1) 1000\\'0000\\'0000\\'0000\\'0000\\'0000\\'0000\\'0000\\n\\t2) ....\\'....\\'0101\\'0100\\'0000\\'0000\\'0000\\'0000// Note these numbers are random for display purposes\\n\\t3) ....\\'....\\'....\\'....\\'1011\\'0000\\'0000\\'0000\\n\\t4) ....\\'....\\'....\\'....\\'....\\'....\\'1011\\'0000\\n\\t\\n\\tWhen we add all these shifted over lookup values together to the result, which was initially 0, we get:\\n\\t1000\\'0000\\'0101\\'0100\\'1011\\'0000\\'1011\\'0000",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    uint32_t reverseBits(uint32_t x) {\\n\\t\\n        uint32_t lookupTable[256]; // To achieve O(1) we need to do work beforehand, create a lookup table.\\n\\t\\t\\n        for (uint32_t i{}; i < 256; i++) { // 256 combinations in 8 bits (1 byte)\\n            lookupTable[i] = (i&1) * pow(2,7) + // If a bit exists at position 1, the reverse will have a bit at position 8.\\n                            ((i&2)>>1) * pow(2,6) + // As you can see, (i&2)>>1 is either 1 or 0. If it\\'s 1, \\n                            ((i&4)>>2) * pow(2,5) + // we add 2^6 (turn on a bit at position 7). \\n                            ((i&8)>>3) * pow(2,4) + // We continue this for every bit position for eight bits in a byte.\\n                            ((i&16)>>4) * pow(2,3) +\\n                            ((i&32)>>5) * pow(2,2) +\\n                            ((i&64)>>6) * pow(2,1) +\\n                            ((i&128)>>7) * pow(2,0);\\n        }\\n        \\n        uint32_t result = 0; // The new result starts at 0.\\n        result = (lookupTable[x & 0xff] << 24) + (lookupTable[x>>8 & 0xff] << 16) + (lookupTable[x>>16 & 0xff] << 8) \\n\\t\\t+ lookupTable[x>>24 & 0xff]; \\n\\t\\t\\n\\t\\t// This part is worth explaining. I explain below.\\n\\t\\t\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387487,
                "title": "golang-solution-without-bit-ops",
                "content": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var result uint32\\n    \\n    for i := 0; i < 32; i++ {\\n        result *= 2\\n        if num != 0 {\\n            result += num %2\\n            num /= 2\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseBits(num uint32) uint32 {\\n    var result uint32\\n    \\n    for i := 0; i < 32; i++ {\\n        result *= 2\\n        if num != 0 {\\n            result += num %2\\n            num /= 2\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54759,
                "title": "c-solution-with-explanation-3ms",
                "content": "````    \\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for(int i = 0; i<32; i++){\\n            res = (res << 1 | n & 1);\\n            n = n>>1;\\n        }\\n        return res;\\n````\\n\\nEvery loop, we shift our result number to left by 1 digit. Then update result number. If the rightmost digit of n is 1 then update result number last digit be 1. If the rightmost digit of n is 0 then update result number last digit be 0. Then shift n to right by one for another update\\n\\n\\nI use 8 bit int as example to explain my idea:\\nFor example we want to reverse 01010101. \\n\\n````\\nloop     res                 n\\n0          0             01010101\\n1          1             0101010\\n2          10            10101\\n3          101           01010\\n4          1010          0101\\n5          10101         010\\n6          101010        10\\n7          1010101       0\\n8          10101010      0\\n````",
                "solutionTags": [],
                "code": "````    \\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t res = 0;\\n        for(int i = 0; i<32; i++){\\n            res = (res << 1 | n & 1);\\n            n = n>>1;\\n        }\\n        return res;\\n```\n````\\nloop     res                 n\\n0          0             01010101\\n1          1             0101010\\n2          10            10101\\n3          101           01010\\n4          1010          0101\\n5          10101         010\\n6          101010        10\\n7          1010101       0\\n8          10101010      0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54769,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func reverseBits(_ n: Int) -> Int {\\n        var n = n\\n        var result = 0\\n        \\n        for i in 0..<32 {\\n            result += (n & 1)\\n            n >>= 1\\n            if i < 31 {\\n                result <<= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func reverseBits(_ n: Int) -> Int {\\n        var n = n\\n        var result = 0\\n        \\n        for i in 0..<32 {\\n            result += (n & 1)\\n            n >>= 1\\n            if i < 31 {\\n                result <<= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54871,
                "title": "132-ms-solution-with-javascript",
                "content": "Hit 100% in performance with javascript submissions. Shift the results 1 bit leftwards; shift n 1 bit right wards, and bit AND with 1. Every time you will get the last bit as 0 or 1; if last bit is 1, add 1 to result. Get ready for next iteration. \\n\\nNote: in JS, you have to result>>>0 in order to get the result to be unsigned. \\n\\nvar reverseBits = function(n) {\\n    if (n === 0) return 0;\\n    \\n    var result = 0;\\n    for (var i = 0; i < 32; i ++) {\\n        result <<= 1;\\n        if (n & 1 === 1) {\\n            result += 1;\\n        }\\n        \\n        n >>= 1;\\n    }\\n    return result>>>0;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "Hit 100% in performance with javascript submissions. Shift the results 1 bit leftwards; shift n 1 bit right wards, and bit AND with 1. Every time you will get the last bit as 0 or 1; if last bit is 1, add 1 to result. Get ready for next iteration. \\n\\nNote: in JS, you have to result>>>0 in order to get the result to be unsigned. \\n\\nvar reverseBits = function(n) {\\n    if (n === 0) return 0;\\n    \\n    var result = 0;\\n    for (var i = 0; i < 32; i ++) {\\n        result <<= 1;\\n        if (n & 1 === 1) {\\n            result += 1;\\n        }\\n        \\n        n >>= 1;\\n    }\\n    return result>>>0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 54895,
                "title": "one-line-of-python-code-that-beats-86-of-all-python-submissions",
                "content": "    class Solution(object):\\n        def reverseBits(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            return int(bin(n).lstrip('0b').zfill(32)[::-1],2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseBits(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            return int(bin(n).lstrip('0b').zfill(32)[::-1],2)",
                "codeTag": "Java"
            },
            {
                "id": 54937,
                "title": "my-simple-solution-with-c",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t r = 0;\\n            for(int i = 0; i < 32; i++){\\n                r <<= 1;\\n                r += n & 1;\\n                n >>= 1;\\n            }\\n            return r;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            uint32_t r = 0;\\n            for(int i = 0; i < 32; i++){\\n                r <<= 1;\\n                r += n & 1;\\n                n >>= 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 54956,
                "title": "javascript-solution-using-prototype",
                "content": "    Number.prototype.bin = function () {\\n        var result = this.toString(2);\\n        while(result.length < 32) {\\n            result = \"0\" + result;\\n        }\\n        return result;\\n    };\\n    \\n    var reverseBits = function(n) {\\n        return parseInt(n.bin().split('').reverse().join(''), 2);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    Number.prototype.bin = function () {\\n        var result = this.toString(2);\\n        while(result.length < 32) {\\n            result = \"0\" + result;\\n        }\\n        return result;\\n    };\\n    \\n    var reverseBits = function(n) {\\n        return parseInt(n.bin().split('').reverse().join(''), 2);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 54959,
                "title": "three-lines-c-solution",
                "content": "    class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            decltype(n) res = 0;\\n            for (int i = 0; i < 32; i++, n >>= 1) res = (res << 1) | (n & 1);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        uint32_t reverseBits(uint32_t n) {\\n            decltype(n) res = 0;\\n            for (int i = 0; i < 32; i++, n >>= 1) res = (res << 1) | (n & 1);\\n            return res;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565743,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565429,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1990124,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565947,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1566836,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1576318,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569006,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1570134,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569405,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569007,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565743,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565429,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1990124,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1565947,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1566836,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1576318,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569006,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1570134,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569405,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1569007,
                "content": [
                    {
                        "username": "gen504240809",
                        "content": "int in java is 32-bit signed number ,the maximum signed number is 2147483647.when the last bit of the input number is '1' and we reverse bits,it will become negative number ,how can we return a positive int number and the number must be larger than 2147483647?"
                    },
                    {
                        "username": "shtian",
                        "content": "## Java ##\\n\\nUse [`>>>`\\\\*][1] instead of `>>`. `>>>`is unsigned right shift, and `>>` is signed.\\n\\nUse [`Integer.parseUnsignedInt`\\\\*][2] and [`Integer.toUnsignedString`\\\\*][3] if you want test your program locally.\\n\\n## JavaScript ##\\n\\nUse [`>>>`\\\\*][4] instead of `>>`. This is as same as Java.\\n\\nAfter `|`, `&`, `~`, `>>`, `<<`, the number was converted ToInt32. But you need return a positive value. So try `return result >>> 0;`. `>>>` will call [`ToUint32`\\\\*][5].\\n\\n\\n  [1]: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html\\n  [2]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseUnsignedInt-java.lang.String-\\n  [3]: http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toUnsignedString-int-int-\\n  [4]: http://www.ecma-international.org/ecma-262/5.1/#sec-11.7.2\\n  [5]: http://www.ecma-international.org/ecma-262/5.1/#sec-9.6"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "What is wrong with the developer of the question....Theyre saying that input is binary string and the input theyre taking is an integer...\\n"
                    },
                    {
                        "username": "jimmyzzxhlh",
                        "content": "Since the function is forced to return an int, how is it possible to return 2147483648?\\n\\nI've tried to return -2147483648 and it doesn't work."
                    },
                    {
                        "username": "loveytx",
                        "content": "use long long int "
                    },
                    {
                        "username": "daynis",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value when it doesn't have any unsigned integer types?In other words, how is the input sent as 2147483648 in an int variable given that the Java language itself doesn't let us hold 2147483648 in an int ?"
                    },
                    {
                        "username": "lordwerneo",
                        "content": "In case if you wonder, if it says that as input you get something like this: \\'00000000000000000000000000000100\\' it means that as input you just got int 4, and to get binary representation, you just need to format or f-string your input as f\\'{input:032b}\\' where input is your variable."
                    },
                    {
                        "username": "ThirteenBeans",
                        "content": "    def reverse_bits(n)\\n        sprintf(\"%.32b\", n).reverse.to_i(2)\\n    end"
                    },
                    {
                        "username": "ajitemk",
                        "content": "uint32_t reverseBits(uint32_t n) {\\n\\nThis below expression use to swap the bits.\\nLet an example, suppose num is 0100, after the above expression it will be 1000.\\n\\n    n = (((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1));\\n\\nbelow expression uses to swap the 2 bits of a nibble. Suppose num is 10 00, after the above expression, it will be 00 01.\\n\\nn = (((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2));\\n\\nExpression use to swaps the nibbles. like if num is 0011 0010 then after the below expression it will be 0010 0011.\\n\\n\\tn = (((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4));\\n\\t\\n\\tThis statement  uses to swap the bytes of an integer. Let num is 00001000 00001100, after the below expression, it will be 00001100 00001000.\\n\\t\\n\\tn = (((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8));\\n\\t\\nreturn((n >> 16) | (n << 16));\\nThe above expression uses to swap the half-word of an integer. Means that if the num is 0000000011001110 1000100100000110, after the above result number will be 1000100100000110 0000000011001110.\\n    \\n}"
                    },
                    {
                        "username": "Henton",
                        "content": "My solution show this.\\nRuntime: 2 ms, faster than 98.25% of Java online submissions for Reverse Bits."
                    },
                    {
                        "username": "vikas7",
                        "content": "In Q.190, The function prototype says return type is int (Java language). But for the input 1, the expected output is 2147483648, How can an int type can store that value?\\n\\nThank you"
                    }
                ]
            },
            {
                "id": 1907553,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1576001,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1941582,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1940765,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1801569,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1571401,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1571403,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1571402,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1574336,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1576137,
                "content": [
                    {
                        "username": "belyakovsergeyrus",
                        "content": "I did not immediately understand the task, so I will try to explain: in fact, the task is to return the \"revers\" of a given number"
                    },
                    {
                        "username": "user-online",
                        "content": "I\\'m not very familliar with bit operations. This is my first intuitive solution \\n`return int(bin(n)[::-1], 2)`.\\nI thought it should work but it failed actually with error\\n` ValueError: invalid literal for int() with base 2: \\'00111001011110000010100101b0\\'`\\nCan anyone help address my confusion? I really appreciate it."
                    },
                    {
                        "username": "pateldevarsh1206",
                        "content": "\\'b0\\' in ending is causing the problem. Try int(\\'0b\\' + bin(n)[2:][::-1], 2). \\n\\nHint : This is still not complete solution. You have to make string length 32"
                    },
                    {
                        "username": "pradyumnakr",
                        "content": "How to pass 32 bit unsigned integer to function in python?"
                    },
                    {
                        "username": "masterweb801",
                        "content": "My Issue is this error :-\\n`SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers`"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Why (1<<31) is not working in C programming??\\n\\nI\\'m trying with unsigned int and signed int both.\\n\\nError is showing -  \"left shift of 1 by 31 places cannot be represented in type \\'int\\' \"."
                    },
                    {
                        "username": "hellenyue002",
                        "content": "If I use >>> it will pass, but if I use >>, it will time exceed. \\n\\nWhy the performance has so much difference?"
                    },
                    {
                        "username": "icyfox",
                        "content": "If you want to test  **2147483648 (10000000000000000000000000000000)**\\n\\n\\nBut eclipse tell you it is too large for **int**\\n\\n\\nuse **1 << 31** instead"
                    },
                    {
                        "username": "lq60607@yahoo.com",
                        "content": "Besides the discussion whether it's meaningful or not,\\nis there any programming room to \"optimize\" such a problem?\\n\\nCaching the result of last call of reverse(n) to prepare the same call of reverse(n) to be called again?\\n\\nForgive me if the question is dumb. But please detail the answer.\\n\\nThanks."
                    },
                    {
                        "username": "asgakashgupta",
                        "content": "![image](https://assets.leetcode.com/users/images/1605fec6-7bb3-4f5e-90b4-a54e3e038804_1599381784.601867.png)\\n"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return int(\"{:032b}\".format(n)[::-1],2)`"
                    }
                ]
            },
            {
                "id": 1575918,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 2075354,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 2056572,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 2034322,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 2015527,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1976384,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1963653,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1931929,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1901966,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1881339,
                "content": [
                    {
                        "username": "Alptekin",
                        "content": "return Integer.reverse(n);\\n"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "Solution is of single line \" return Integer.reverse(n); \"\\nBeats 100%"
                    },
                    {
                        "username": "the_timmer",
                        "content": "For Python3, the Testcase / Result section was misleading to me.  It kept showing the Input as a binary.  But when I started off with a print(n), it clearly printed a decimal, not a binary.  This is more consistent with n being defined as int.  So I needed to convert n to a binary before doing anything else, and then I could get a successful submittal."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "supper easy in c. Time complexity O(1)\\nuint32_t reverseBits(uint32_t n) {\\n    uint32_t i = 0 , bit = 0;\\n    for(int j = 0 ; j<32;j++) i=i<<1,bit = (1&n) ,i += bit , n = n>>1;\\n    return i;\\n}"
                    },
                    {
                        "username": "imamanwp",
                        "content": "This question should be medium level of difficulty as this question is complex and requires understanding of bits manipulation and divide and conquer."
                    },
                    {
                        "username": "SiegeSailor",
                        "content": "My Python solution works on my terminal but not here:\\n\\n```python\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        output = list(bin(n)[2:])\\n        pointer_start, pointer_end = 0, len(output) - 1\\n        while pointer_start < pointer_end:\\n            output[pointer_start], output[pointer_end] = output[pointer_end], output[pointer_start]\\n            pointer_start += 1\\n            pointer_end -= 1\\n        return \"\".join(output)\\n```\\n\\nIt keeps complaining:\\n\\n> ValueError: Unknown format code \\'b\\' for object of type \\'str\\'\\n    out = \"%12d (%s)\" % (reversed_bits, \\'{:032b}\\'.format(reversed_bits))\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 35 in <module> (Solution.py)"
                    },
                    {
                        "username": "danek1313",
                        "content": "If I adapt Approach 1\\'s C++ option to Java, it fails with a Time Limit Exceeded. Why?"
                    },
                    {
                        "username": "ravikumarmanikyolla",
                        "content": "I have a more of a Java language question. My program failed for 2147483648 as an input. How is Java able to represent 2147483648 as an unsigned int value "
                    },
                    {
                        "username": "sethhu20",
                        "content": "I assume the follow up *If this function is called many times, how would you optimize it?* is just a \"interview\" style question without needing to necessarily code it out.\\n\\nBut I\\'m not quite sure what would be the idea for this question. It would be obvious to cache the results (as I saw some other answers), but that doesn\\'t sound like a convincing answer or if it is practical in real life, since if we assume the input is randomly distributed across the 32 bit unsigned integers range, then not only is the cache will rarely be useful, but also the space needed will grow to 32 bit size (a hashmap / array of 2^32 32 bit numbers takes up gigabytes of memory).\\n\\nWhat other optimization can be done in the event where these calls are randomly distributed along the 32 bit integer range?"
                    },
                    {
                        "username": "ankushmondal1y2t",
                        "content": "EASY 0ms BEATS 100% SOLUTION EASY TO UNDERSTAND\\n    uint32_t reverseBits(uint32_t n) {\\n        uint32_t r=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            //n=n>>1;\\n            r<<=1;\\n            if((n&1)==1)\\n            {\\n                r++;\\n            }\\n            n>>=1;\\n        }\\n        return r;\\n    }"
                    }
                ]
            },
            {
                "id": 1849699,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1841375,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1835764,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1798129,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1793181,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1787179,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1783590,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1772313,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1760330,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            },
            {
                "id": 1749872,
                "content": [
                    {
                        "username": "kingp",
                        "content": "This code is really hard to understand Please can anyone help me understand . Thanking you in Advance....\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        n = (n >> 16) | (n << 16);\\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\\n        return n;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "cheguvera",
                        "content": "Hi\\nKindly help me with the following\\nI am getting the following run time error.\\n\\nLine 17: Char 12: runtime error: shift exponent 32 is too large for 32-bit type \\'uint32_t\\' (aka \\'unsigned int\\') (solution.cpp)\\n\\nthe place corresponds to \\nb=b<<(32-cnt);\\nwhere cnt is bit length of number\\nIf i replace this by for loop to run till 32(bit size of uint32_t), i am not getting and also code is passed. \\nKindly help me why is this problem coming"
                    },
                    {
                        "username": "NIkhil_Rathi93",
                        "content": " public int reverseBits(int n) {\n        String num = Integer.toBinaryString(n);\n        String ans=\"\";\n        for(int i=num.length()-1;i>0;i--){\n            ans +=num.charAt(i);\n        } \n       int fn = Integer.parseInt(ans);  \n        return fn;\n    }\n\nWHAT AM I DOING WRONG HERE??"
                    },
                    {
                        "username": "codebothot",
                        "content": " `public class Solution {\\n\n    // you need treat n as an unsigned value\\n\n    public int reverseBits(int n) {\\n\n        int k = 32;\\n\n        int ans = 0;\n        while(k-- >= 0) {\n            ans += Math.pow(2,k) * (n %2);\n            n = n>>>1;\n        }\n        return ans;\n    }\n}`\n\nwhy does this Java code fail for I/P: 00000000000000000000000000000001\n\nexpected O/P: 2147483648\nO/P: 2147483647"
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int pos = 31,reverse = 0;\\n        while(pos >= 0 && n){\\n            if(n & 1){\\n                reverse |= (1 << pos);\\n            }\\n            n >>= 1;\\n            pos--;\\n        }\\n        return reverse;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Just a normal question until you realize"
                    },
                    {
                        "username": "mobeenyaqub",
                        "content": "class Solution:\\n    def reverseBits(self, n: int) -> int:\\n        n = str(n)\\n        ans = 0\\n        for i in range(len(n)):\\n            if n[i] == \\'1\\':\\n                ans += 2 ** i\\n\\n        return ans\\n\\n\\nPycharm is giving correct answer, but leetcode is giving me totally wrong answer for the sample inputs."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/190_Reverse_Bits.cpp"
                    },
                    {
                        "username": "AdiechaHK",
                        "content": "here is the quick solution for python3\\n\\n```\\nclass Solution:\\n    def reverseBits(self, n: int) -> int:\\n        return int(\"{:032b}\".format(n)[::-1], 2)\\n```"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Can anyone explain why it isn\\'t working\\n\\nuint32_t reverseBits(uint32_t n) {\\n        uint32_t ans = 0;\\n        for(int i=1; i<=32;i++) {\\n            ans = ans + (n&1)<<(32-i);\\n            n = n>>1;\\n        }\\n        return ans;\\n    } "
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "got it. it should be or instead of +\\nans = ans | (n&1)<<(32-i);"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Pattern",
        "question_content": "<p>Given a <code>pattern</code> and a string <code>s</code>, find if <code>s</code>&nbsp;follows the same pattern.</p>\n\n<p>Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 300</code></li>\n\t<li><code>pattern</code> contains only lower-case English letters.</li>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code> contains only lowercase English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> <strong>does not contain</strong> any leading or trailing spaces.</li>\n\t<li>All the words in <code>s</code> are separated by a <strong>single space</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 73402,
                "title": "8-lines-simple-java",
                "content": "    public boolean wordPattern(String pattern, String str) {\\n        String[] words = str.split(\" \");\\n        if (words.length != pattern.length())\\n            return false;\\n        Map index = new HashMap();\\n        for (Integer i=0; i<words.length; ++i)\\n            if (index.put(pattern.charAt(i), i) != index.put(words[i], i))\\n                return false;\\n        return true;\\n    }\\n\\nI go through the pattern letters and words in parallel and compare the indexes where they last appeared.\\n\\n**Edit 1:** Originally I compared the **first** indexes where they appeared, using `putIfAbsent` instead of `put`. That was based on [mathsam's solution](https://leetcode.com/discuss/36438/1-liner-in-python?show=39066#a39066) for the old [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/) problem. But then [czonzhu's answer](https://leetcode.com/discuss/62374/9-lines-simple-java?show=62383#a62383) below made me realize that `put` works as well and why.\\n\\n**Edit 2:** Switched from\\n\\n        for (int i=0; i<words.length; ++i)\\n            if (!Objects.equals(index.put(pattern.charAt(i), i),\\n                                index.put(words[i], i)))\\n                return false;\\n\\nto the current version with `i` being an `Integer` object, which allows to compare with just `!=` because there's no autoboxing-same-value-to-different-objects-problem anymore. Thanks to lap_218 for somewhat pointing that out in the comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean wordPattern(String pattern, String str) {\\n        String[] words = str.split(\" \");\\n        if (words.length != pattern.length())\\n            return false;\\n        Map index = new HashMap();\\n        for (Integer i=0; i<words.length; ++i)\\n            if (index.put(pattern.charAt(i), i) != index.put(words[i], i))\\n                return false;\\n        return true;\\n    }\\n\\nI go through the pattern letters and words in parallel and compare the indexes where they last appeared.\\n\\n**Edit 1:** Originally I compared the **first** indexes where they appeared, using `putIfAbsent` instead of `put`. That was based on [mathsam's solution](https://leetcode.com/discuss/36438/1-liner-in-python?show=39066#a39066) for the old [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/) problem. But then [czonzhu's answer](https://leetcode.com/discuss/62374/9-lines-simple-java?show=62383#a62383) below made me realize that `put` works as well and why.\\n\\n**Edit 2:** Switched from\\n\\n        for (int i=0; i<words.length; ++i)\\n            if (!Objects.equals(index.put(pattern.charAt(i), i),\\n                                index.put(words[i], i)))\\n                return false;\\n\\nto the current version with `i` being an `Integer` object, which allows to compare with just `!=` because there's no autoboxing-same-value-to-different-objects-problem anymore. Thanks to lap_218 for somewhat pointing that out in the comments.",
                "codeTag": "Unknown"
            },
            {
                "id": 73409,
                "title": "short-c-read-words-on-the-fly",
                "content": "I think all previous C++ solutions read all words into a vector at the start. Here I read them on the fly.\\n\\n    bool wordPattern(string pattern, string str) {\\n        map<char, int> p2i;\\n        map<string, int> w2i;\\n        istringstream in(str);\\n        int i = 0, n = pattern.size();\\n        for (string word; in >> word; ++i) {\\n            if (i == n || p2i[pattern[i]] != w2i[word])\\n                return false;\\n            p2i[pattern[i]] = w2i[word] = i + 1;\\n        }\\n        return i == n;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "I think all previous C++ solutions read all words into a vector at the start. Here I read them on the fly.\\n\\n    bool wordPattern(string pattern, string str) {\\n        map<char, int> p2i;\\n        map<string, int> w2i;\\n        istringstream in(str);\\n        int i = 0, n = pattern.size();\\n        for (string word; in >> word; ++i) {\\n            if (i == n || p2i[pattern[i]] != w2i[word])\\n                return false;\\n            p2i[pattern[i]] = w2i[word] = i + 1;\\n        }\\n        return i == n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73433,
                "title": "short-in-python",
                "content": "This problem is pretty much equivalent to [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/). Let me reuse two old solutions.\\n\\nFrom [here](https://leetcode.com/discuss/36438/1-liner-in-python?show=39070#c39070):\\n\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return map(s.find, s) == map(t.index, t)\\n\\nImproved version also from there:\\n\\n    def wordPattern(self, pattern, str):\\n        f = lambda s: map({}.setdefault, s, range(len(s)))\\n        return f(pattern) == f(str.split())\\n\\nFrom [here](https://leetcode.com/discuss/41379/1-line-in-python?show=41382#a41382):\\n        \\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)\\n\\nThanks to zhang38 for pointing out the need to check len(s) == len(t) here.",
                "solutionTags": [
                    "Python"
                ],
                "code": "This problem is pretty much equivalent to [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/). Let me reuse two old solutions.\\n\\nFrom [here](https://leetcode.com/discuss/36438/1-liner-in-python?show=39070#c39070):\\n\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return map(s.find, s) == map(t.index, t)\\n\\nImproved version also from there:\\n\\n    def wordPattern(self, pattern, str):\\n        f = lambda s: map({}.setdefault, s, range(len(s)))\\n        return f(pattern) == f(str.split())\\n\\nFrom [here](https://leetcode.com/discuss/41379/1-line-in-python?show=41382#a41382):\\n        \\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)\\n\\nThanks to zhang38 for pointing out the need to check len(s) == len(t) here.",
                "codeTag": "Python3"
            },
            {
                "id": 1695840,
                "title": "python3-single-hashmap-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nAt the first glance, the problem can be solved simply by using a hashmap `w_to_p` which maps words to letters from the pattern. But consider this example: `w = [\\'dog\\', \\'cat\\']` and  `p = \\'aa\\'`. In this case, the hashmap doesn\\'t allow us to verify whether we can assign the letter `a` as a value to the key `cat`.  This case can be handled by comparing length of the unique letters from the pattern and unique words from the string.\\n\\nSpace: **O(n)** - scan\\nTime: **O(n)** - for the hashmap\\n\\nRuntime: 28 ms, faster than **85.44%** of Python3 online submissions for Word Pattern.\\nMemory Usage: 14 MB, less than **94.65%** of Python3 online submissions for Word Pattern.\\n\\n```\\ndef wordPattern(self, p: str, s: str) -> bool:\\n    words, w_to_p = s.split(\\' \\'), dict()\\n\\n    if len(p) != len(words): return False\\n    if len(set(p)) != len(set(words)): return False # for the case w = [\\'dog\\', \\'cat\\'] and p = \\'aa\\'\\n\\n    for i in range(len(words)):\\n        if words[i] not in w_to_p: \\n            w_to_p[words[i]] = p[i]\\n        elif w_to_p[words[i]] != p[i]: \\n            return False\\n\\n    return True\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef wordPattern(self, p: str, s: str) -> bool:\\n    words, w_to_p = s.split(\\' \\'), dict()\\n\\n    if len(p) != len(words): return False\\n    if len(set(p)) != len(set(words)): return False # for the case w = [\\'dog\\', \\'cat\\'] and p = \\'aa\\'\\n\\n    for i in range(len(words)):\\n        if words[i] not in w_to_p: \\n            w_to_p[words[i]] = p[i]\\n        elif w_to_p[words[i]] != p[i]: \\n            return False\\n\\n    return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2977027,
                "title": "python-3-2-lines-w-explanation-t-m-98-100",
                "content": "A *bijection* is both *onto* and *one-to-one*. The figure below illustrates:\\n- ![Untitled.jpg](https://assets.leetcode.com/users/images/1fd20734-396d-48ef-b597-d2bab1ef7f4e_1672536501.2541006.jpeg)\\n\\n\\nThese conditions for bijectivity are satisfied if and only if the following is true:\\n- The counts of distinct elements in two groups and the count of distinct mappings are all equal.\\n\\nIn terms of the figure, the count of the orange dots, the count of the green dots, and the count of arrows must all be equal. We can count the first two using `len(set())` and the third one by `len(set(zip_longest()))`.\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n\\n        s = s.split()\\n\\n        return (len(set(pattern)) ==\\n                len(set(s)) ==\\n                len(set(zip_longest(pattern,s))))\\n```\\n[https://leetcode.com/problems/word-pattern/submissions/868765298/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n\\n        s = s.split()\\n\\n        return (len(set(pattern)) ==\\n                len(set(s)) ==\\n                len(set(zip_longest(pattern,s))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73399,
                "title": "very-fast-3ms-java-solution-using-hashmap",
                "content": "    public class Solution {\\n        public boolean wordPattern(String pattern, String str) {\\n            String[] arr= str.split(\" \");\\n            HashMap<Character, String> map = new HashMap<Character, String>();\\n            if(arr.length!= pattern.length())\\n                return false;\\n            for(int i=0; i<arr.length; i++){\\n                char c = pattern.charAt(i);\\n                if(map.containsKey(c)){\\n                    if(!map.get(c).equals(arr[i]))\\n                        return false;\\n                }else{\\n                    if(map.containsValue(arr[i]))\\n                        return false;\\n                    map.put(c, arr[i]);\\n                }    \\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean wordPattern(String pattern, String str) {\\n            String[] arr= str.split(\" \");\\n            HashMap<Character, String> map = new HashMap<Character, String>();\\n            if(arr.length!= pattern.length())\\n                return false;\\n            for(int i=0; i<arr.length; i++){\\n                char c = pattern.charAt(i);\\n                if(map.containsKey(c)){\\n                    if(!map.get(c).equals(arr[i]))\\n                        return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2977740,
                "title": "simple-java-solution-with-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n\\n        Map<Character, String> charToWord = new HashMap<>();\\n        Map<String, Character> wordToChar = new HashMap<>();\\n\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char c = pattern.charAt(i);\\n            String word = words[i];\\n\\n            if (!charToWord.containsKey(c)) {\\n                charToWord.put(c, word);\\n            }\\n\\n            if (!wordToChar.containsKey(word)) {\\n                wordToChar.put(word, c);\\n            }\\n\\n            if (!charToWord.get(c).equals(word) || !wordToChar.get(word).equals(c)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n\\n        Map<Character, String> charToWord = new HashMap<>();\\n        Map<String, Character> wordToChar = new HashMap<>();\\n\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char c = pattern.charAt(i);\\n            String word = words[i];\\n\\n            if (!charToWord.containsKey(c)) {\\n                charToWord.put(c, word);\\n            }\\n\\n            if (!wordToChar.containsKey(word)) {\\n                wordToChar.put(word, c);\\n            }\\n\\n            if (!charToWord.get(c).equals(word) || !wordToChar.get(word).equals(c)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695870,
                "title": "c-simple-intuitive-solution-0ms",
                "content": "**APPROACH :**\\n\\n* Use two maps, one maps the letters of ```pattern``` to ```index+1``` & the other maps the words in ```s``` to ```index+1```.\\n* Use ```istringstream``` to extract words from ```s``` & ```i``` to traverse ```pattern```.\\n* Return true if the values of both the keys ( m1[pattern[i]] & m2[word] ) are equal && i reaches ```pattern.size()``` & stops. (ie; No. of words in ```s``` = ```pattern.size()``` ), otherwise false.\\n\\n**Time Complexity :** O(m) - m = No. of words in ```s```.\\n\\n**Space Complexity :** O(m)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, int> p2i;\\n        unordered_map<string, int> w2i;\\n        \\n        istringstream in(s); string word;\\n        int i = 0, n = pattern.size();\\n\\n        \\n        for(word; in>>word; i++){\\n            if(i==n || p2i[pattern[i]] != w2i[word]) return false; //If it reaches end before all the words in string \\'s\\' are traversed || if values of keys : pattern[i] & word don\\'t match return false\\n            \\n            p2i[pattern[i]] = w2i[word] = i+1; //Otherwise map to both to a value i+1\\n        }\\n        return i==n; //both the lengths should be equal\\n    }\\n};\\n```\\n\\n**Do upvote if you like my solution & explanation :)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```pattern```\n```index+1```\n```s```\n```index+1```\n```istringstream```\n```s```\n```i```\n```pattern```\n```pattern.size()```\n```s```\n```pattern.size()```\n```s```\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, int> p2i;\\n        unordered_map<string, int> w2i;\\n        \\n        istringstream in(s); string word;\\n        int i = 0, n = pattern.size();\\n\\n        \\n        for(word; in>>word; i++){\\n            if(i==n || p2i[pattern[i]] != w2i[word]) return false; //If it reaches end before all the words in string \\'s\\' are traversed || if values of keys : pattern[i] & word don\\'t match return false\\n            \\n            p2i[pattern[i]] = w2i[word] = i+1; //Otherwise map to both to a value i+1\\n        }\\n        return i==n; //both the lengths should be equal\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010245,
                "title": "c-each-line-explained-solution-faster-100",
                "content": "Kindly give a thumbs up if found any help. \\n\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s)\\n    {\\n        vector<string> v;\\n        // word variable to store word in the string s\\n        string word;\\n        // making a string stream\\n        stringstream iss(s);\\n       // Push each word in vector\\n        while (iss >> word)\\n            v.push_back(word);\\n      \\n        set<string> S; // To check if the same word is not mappped with another character\\n      // If vector and pattern are of different sizes there can be no mapping\\n        if (pattern.size() != v.size())\\n            return false;\\n        unordered_map<char, string> m;\\n        for (int i = 0; i < pattern.size(); i++) {\\n            // Take current character in pattern\\n            char ch = pattern[i];\\n            // If current character is present in the map\\n            if (m.find(ch) != m.end()) {\\n            //Check if the string mapped to that character is different or not if yes\\n\\t\\t\\t//return false\\n                if (m[ch] != v[i])\\n                    return false;\\n            }\\n            // If not present in the map\\n            else {\\n                // Check if the string is previously in set\\n                // If it is in set it means it is already mapped return false\\n                if (S.count(v[i]) > 0)\\n                    return false;\\n                // Other wise insert into map and set\\n                m[ch] = v[i];\\n                S.insert(v[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s)\\n    {\\n        vector<string> v;\\n        // word variable to store word in the string s\\n        string word;\\n        // making a string stream\\n        stringstream iss(s);\\n       // Push each word in vector\\n        while (iss >> word)\\n            v.push_back(word);\\n      \\n        set<string> S; // To check if the same word is not mappped with another character\\n      // If vector and pattern are of different sizes there can be no mapping\\n        if (pattern.size() != v.size())\\n            return false;\\n        unordered_map<char, string> m;\\n        for (int i = 0; i < pattern.size(); i++) {\\n            // Take current character in pattern\\n            char ch = pattern[i];\\n            // If current character is present in the map\\n            if (m.find(ch) != m.end()) {\\n            //Check if the string mapped to that character is different or not if yes\\n\\t\\t\\t//return false\\n                if (m[ch] != v[i])\\n                    return false;\\n            }\\n            // If not present in the map\\n            else {\\n                // Check if the string is previously in set\\n                // If it is in set it means it is already mapped return false\\n                if (S.count(v[i]) > 0)\\n                    return false;\\n                // Other wise insert into map and set\\n                m[ch] = v[i];\\n                S.insert(v[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695928,
                "title": "as-simple-explanation-as-you-want",
                "content": "```\\nThe concept is very simple. We will first of all gonna check wether the character has not been assigned with any word. \\nIf not, then assign it with that word and mark it assigned. So, that if any different character want to assign with same previous word. \\nIt will see it as marked and simply return false.\\nOtherwise, return true means every different character has been assigned with different word.\\n```\\n\\n**Let\\'s look at diagram 1st:**\\n![image](https://assets.leetcode.com/users/images/49315f97-ce60-4a4e-a4b0-57463b64a51b_1642388174.3373523.png)\\n\\n*So, now you will ask* \"**How can we solve this?**\" And my answer is to solve this we will use the help of `2 HashMap`. In the **1st HashMap** we will assign the **Characters with word.**\\nBut In the **2nd HashMap** we will mark that **word** to be **used** or **not** `i.e. wether the word has been assigned to any character or not. If it has assigned then label it as true;`\\n\\n**Let\\'s understand it with 1st testcase** \\n\\n![image](https://assets.leetcode.com/users/images/d29a9058-d918-4220-adac-100599dd48fb_1642388701.1553154.png)\\n\\nSo, if you see **a** is assigned with **dog** and **b** is assigned with **cat**. So, if we see  all of them are assigned with correct word. we gonna **return true**;\\n\\n**Let\\'s understand it with 2nd testcase** \\nWe have something like **a** is assigned with **dog** and **b** is assigned with **cat** and again **a** has to assigned with **fish**. Then it will **return false**, because **dog** is assigned with **a** & we cant assign **fish with a now.** \\n\\n![image](https://assets.leetcode.com/users/images/50ac9818-1158-4b9a-bf97-928680a66d7c_1642389672.011141.png)\\n\\n\\nI hope the concept is clear;\\n**Now let\\'s code it up**\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String words[] = s.split(\" \");\\n        \\n        if(words.length != pattern.length()) return false; // base condition, if words length not equals to pattern length\\n        // eg :- aaa != aa aa aa aa\\n        \\n        Map<Character, String> map1 = new HashMap<>(); // this hashmap assign the characters with words\\n        Map<String, Boolean> map2 = new HashMap<>(); // in this map we will mark the words as used\\n        \\n        for(int i = 0; i < pattern.length(); i++){\\n            char ch = pattern.charAt(i);\\n            \\n            if(map1.containsKey(ch) == false){ // if the pattern character has not been mapped\\n                if(map2.containsKey(words[i]) == true){ // but the word which we will assign to i character has been used\\n                    return false; // eg :- dog = a & now dog = b;\\n                }\\n                else{ // if the word has not been used;\\n                    map2.put(words[i], true); // now mark it as used\\n                    map1.put(ch, words[i]); // and put that word infront of character\\n                }\\n            }\\n            else{ \\n                // if that character has already been mapped, now check with whom it has been mapped\\n                String mwith = map1.get(ch);\\n                // if mwith word is not equals to words[i], means already mapped with someone, then return false; \\n                // eg :- a = dog & now a = cat\\n                if(mwith.equals(words[i]) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nThe concept is very simple. We will first of all gonna check wether the character has not been assigned with any word. \\nIf not, then assign it with that word and mark it assigned. So, that if any different character want to assign with same previous word. \\nIt will see it as marked and simply return false.\\nOtherwise, return true means every different character has been assigned with different word.\\n```\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String words[] = s.split(\" \");\\n        \\n        if(words.length != pattern.length()) return false; // base condition, if words length not equals to pattern length\\n        // eg :- aaa != aa aa aa aa\\n        \\n        Map<Character, String> map1 = new HashMap<>(); // this hashmap assign the characters with words\\n        Map<String, Boolean> map2 = new HashMap<>(); // in this map we will mark the words as used\\n        \\n        for(int i = 0; i < pattern.length(); i++){\\n            char ch = pattern.charAt(i);\\n            \\n            if(map1.containsKey(ch) == false){ // if the pattern character has not been mapped\\n                if(map2.containsKey(words[i]) == true){ // but the word which we will assign to i character has been used\\n                    return false; // eg :- dog = a & now dog = b;\\n                }\\n                else{ // if the word has not been used;\\n                    map2.put(words[i], true); // now mark it as used\\n                    map1.put(ch, words[i]); // and put that word infront of character\\n                }\\n            }\\n            else{ \\n                // if that character has already been mapped, now check with whom it has been mapped\\n                String mwith = map1.get(ch);\\n                // if mwith word is not equals to words[i], means already mapped with someone, then return false; \\n                // eg :- a = dog & now a = cat\\n                if(mwith.equals(words[i]) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73434,
                "title": "0ms-c-solution-using-istringstream-and-double-maps",
                "content": "        bool wordPattern(string pattern, string str) {\\n            istringstream strcin(str);\\n            string s;\\n            vector<string> vs;\\n            while(strcin >> s) vs.push_back(s);\\n            if (pattern.size() != vs.size()) return false;\\n            map<string, char> s2c;\\n            map<char, string> c2s;\\n            for (int i = 0; i < vs.size(); ++i) {\\n                if (s2c[vs[i]] == 0 && c2s[pattern[i]] == \"\") { \\n                    s2c[vs[i]] = pattern[i]; \\n                    c2s[pattern[i]] = vs[i]; \\n                    continue; \\n                }\\n                if (s2c[vs[i]] != pattern[i]) return false;\\n            }\\n            return true;\\n        }",
                "solutionTags": [],
                "code": "        bool wordPattern(string pattern, string str) {\\n            istringstream strcin(str);\\n            string s;\\n            vector<string> vs;\\n            while(strcin >> s) vs.push_back(s);\\n            if (pattern.size() != vs.size()) return false;\\n            map<string, char> s2c;\\n            map<char, string> c2s;\\n            for (int i = 0; i < vs.size(); ++i) {\\n                if (s2c[vs[i]] == 0 && c2s[pattern[i]] == \"\") { \\n                    s2c[vs[i]] = pattern[i]; \\n                    c2s[pattern[i]] = vs[i]; \\n                    continue; \\n                }\\n                if (s2c[vs[i]] != pattern[i]) return false;\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1695902,
                "title": "c-java-python-short-and-explained-100-faster",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n**Python**\\n```\\nRuntime: 16 ms, faster than 81.24% of Python online submissions for Word Pattern.\\nMemory Usage: 13.5 MB, less than 44.83% of Python online submissions for Word Pattern.\\n```\\n```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        dic = defaultdict()  # the projection dict, key is the char in pattern and the value is a word\\n        words = s.split(\\' \\')\\n\\t\\t# \\'aa\\' -> \\'dog\\', \\'ab\\' -> \\'dog dog\\', \\'abc\\'- > \\'cat dog cat\\'\\n        if len(pattern) != len(words) or len(set(pattern)) != len(set(words)): return False\\n        for i, c in enumerate(pattern):\\n            if c in dic:  # c has been projected to some word\\n                if dic[c] != words[i]: return False  # \\'aba\\' -> \\'cat dog dog\\'\\n            else:\\n                dic[c] = words[i]\\n        return True\\n```\\n\\n\\n**C++**\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Word Pattern.\\nMemory Usage: 6.6 MB, less than 18.34% of C++ online submissions for Word Pattern.\\n```\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, string> dic; // the projection map, key is the char in pattern and the value is a word\\n        set<string> word_set;\\n        set<char> pattern_set;\\n        vector<string> words;\\n        istringstream iss(s);\\n        string word;\\n        while (iss >> word) {  words.push_back(word); word_set.insert(word); }\\n        for (int i = 0; i < pattern.length(); i ++) pattern_set.insert(pattern[i]);\\n\\t\\t// \\'aa\\' -> \\'dog\\', \\'ab\\' -> \\'dog dog\\', \\'abc\\'- > \\'cat dog cat\\'\\n        if (words.size() != pattern.length() || word_set.size() != pattern_set.size()) return false;\\n        for (int i = 0; i < words.size(); i++) {\\n            if (dic.count(pattern[i]) > 0) { // pattern[i] has been projected to some word\\n                if (dic[pattern[i]] != words[i]) return false; // \\'aba\\' -> \\'cat dog dog\\'\\n            } else {\\n                dic[pattern[i]] = words[i];\\n            }\\n        }\\n        return true;    \\n    } \\n};\\n```\\n\\n**Java**\\n```\\nRuntime: 1 ms, faster than 86.67% of Java online submissions for Word Pattern.\\nMemory Usage: 38.6 MB, less than 26.22% of Java online submissions for Word Pattern.\\n```\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character, String> dic = new HashMap<Character, String>(); // the projection map, key is the char in pattern and the value is a word\\n        Set<String> word_set = new HashSet<String>();;\\n        Set<Character> pattern_set = new HashSet<Character>();\\n        String[] words = s.split(\" \");\\n        for (String word: words) word_set.add(word);\\n        for (char c: pattern.toCharArray()) pattern_set.add(c);\\n\\t\\t// \\'aa\\' -> \\'dog\\', \\'ab\\' -> \\'dog dog\\', \\'abc\\'- > \\'cat dog cat\\'\\n        if (words.length != pattern.length() || word_set.size() != pattern_set.size()) return false;\\n        for (int i = 0; i < words.length; i++) {\\n            if (dic.containsKey(pattern.charAt(i))) { // pattern[i] has been projected to some word\\n                if (!dic.get(pattern.charAt(i)).equals(words[i])) return false; // \\'aba\\' -> \\'cat dog dog\\'\\n            } else {\\n                dic.put(pattern.charAt(i), words[i]);\\n            }\\n        }\\n        return true;   \\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nRuntime: 16 ms, faster than 81.24% of Python online submissions for Word Pattern.\\nMemory Usage: 13.5 MB, less than 44.83% of Python online submissions for Word Pattern.\\n```\n```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        dic = defaultdict()  # the projection dict, key is the char in pattern and the value is a word\\n        words = s.split(\\' \\')\\n\\t\\t# \\'aa\\' -> \\'dog\\', \\'ab\\' -> \\'dog dog\\', \\'abc\\'- > \\'cat dog cat\\'\\n        if len(pattern) != len(words) or len(set(pattern)) != len(set(words)): return False\\n        for i, c in enumerate(pattern):\\n            if c in dic:  # c has been projected to some word\\n                if dic[c] != words[i]: return False  # \\'aba\\' -> \\'cat dog dog\\'\\n            else:\\n                dic[c] = words[i]\\n        return True\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Word Pattern.\\nMemory Usage: 6.6 MB, less than 18.34% of C++ online submissions for Word Pattern.\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, string> dic; // the projection map, key is the char in pattern and the value is a word\\n        set<string> word_set;\\n        set<char> pattern_set;\\n        vector<string> words;\\n        istringstream iss(s);\\n        string word;\\n        while (iss >> word) {  words.push_back(word); word_set.insert(word); }\\n        for (int i = 0; i < pattern.length(); i ++) pattern_set.insert(pattern[i]);\\n\\t\\t// \\'aa\\' -> \\'dog\\', \\'ab\\' -> \\'dog dog\\', \\'abc\\'- > \\'cat dog cat\\'\\n        if (words.size() != pattern.length() || word_set.size() != pattern_set.size()) return false;\\n        for (int i = 0; i < words.size(); i++) {\\n            if (dic.count(pattern[i]) > 0) { // pattern[i] has been projected to some word\\n                if (dic[pattern[i]] != words[i]) return false; // \\'aba\\' -> \\'cat dog dog\\'\\n            } else {\\n                dic[pattern[i]] = words[i];\\n            }\\n        }\\n        return true;    \\n    } \\n};\\n```\n```\\nRuntime: 1 ms, faster than 86.67% of Java online submissions for Word Pattern.\\nMemory Usage: 38.6 MB, less than 26.22% of Java online submissions for Word Pattern.\\n```\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character, String> dic = new HashMap<Character, String>(); // the projection map, key is the char in pattern and the value is a word\\n        Set<String> word_set = new HashSet<String>();;\\n        Set<Character> pattern_set = new HashSet<Character>();\\n        String[] words = s.split(\" \");\\n        for (String word: words) word_set.add(word);\\n        for (char c: pattern.toCharArray()) pattern_set.add(c);\\n\\t\\t// \\'aa\\' -> \\'dog\\', \\'ab\\' -> \\'dog dog\\', \\'abc\\'- > \\'cat dog cat\\'\\n        if (words.length != pattern.length() || word_set.size() != pattern_set.size()) return false;\\n        for (int i = 0; i < words.length; i++) {\\n            if (dic.containsKey(pattern.charAt(i))) { // pattern[i] has been projected to some word\\n                if (!dic.get(pattern.charAt(i)).equals(words[i])) return false; // \\'aba\\' -> \\'cat dog dog\\'\\n            } else {\\n                dic.put(pattern.charAt(i), words[i]);\\n            }\\n        }\\n        return true;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73411,
                "title": "my-solution-in-python",
                "content": "    class Solution(object):\\n        def wordPattern(self, pattern, str):\\n            \"\"\"\\n            :type pattern: str\\n            :type str: str\\n            :rtype: bool\\n            \"\"\"\\n            x = str.split(' ')\\n            lsp = len(set(pattern))\\n            lsx = len(set(x))\\n            return len(x)==len(pattern) and lsx==lsp and lsp== len(set(zip(pattern, x)))\\n\\nplease point out if there's anything i should improve",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def wordPattern(self, pattern, str):\\n            \"\"\"\\n            :type pattern: str\\n            :type str: str\\n            :rtype: bool\\n            \"\"\"\\n            x = str.split(' ')\\n            lsp = len(set(pattern))\\n            lsx = len(set(x))\\n            return len(x)==len(pattern) and lsx==lsp and lsp== len(set(zip(pattern, x)))\\n\\nplease point out if there's anything i should improve",
                "codeTag": "Java"
            },
            {
                "id": 2977910,
                "title": "c-hashmap-easy-to-understand",
                "content": "If any of these two conditions hold, the answer will be \"FALSE\" ; \\n#One character maps to two words\\n#One word maps to two characters\\n![image](https://assets.leetcode.com/users/images/ffa72888-fe8d-4b38-9b59-14a5b15ba476_1672551076.1935604.jpeg)\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) \\n    {\\n        map<char, string>chToWordMap;\\n        map<string, char>wordToChMap;\\n        s.push_back(\\' \\');\\n        string currWord = \"\";\\n        int chIdx = 0;\\n        //===============================================================================================\\n        for (int  i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\' \\') //recording words from string\\n            {\\n                char currCh = pattern[chIdx++];\\n                //==============================================\\n                if (chToWordMap.count(currCh))\\n                {\\n                    string alreadyMappedWord = chToWordMap[currCh];\\n                    if (alreadyMappedWord != currWord) return false; //one character map\\'s to two words\\n                }\\n                else if (wordToChMap.count(currWord))\\n                {\\n                    char alreadyMappedCh = wordToChMap[currWord];\\n                    if (alreadyMappedCh != currCh) return false; //one word map\\'s to two characters\\n                }\\n                else\\n                {\\n                    chToWordMap[currCh] = currWord;\\n                    wordToChMap[currWord] = currCh;\\n                }\\n                //=================================================\\n                currWord = \"\";\\n            }\\n            else currWord.push_back(s[i]);\\n        }\\n        //===============================================================================================\\n        return (chIdx == pattern.size());\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) \\n    {\\n        map<char, string>chToWordMap;\\n        map<string, char>wordToChMap;\\n        s.push_back(\\' \\');\\n        string currWord = \"\";\\n        int chIdx = 0;\\n        //===============================================================================================\\n        for (int  i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\' \\') //recording words from string\\n            {\\n                char currCh = pattern[chIdx++];\\n                //==============================================\\n                if (chToWordMap.count(currCh))\\n                {\\n                    string alreadyMappedWord = chToWordMap[currCh];\\n                    if (alreadyMappedWord != currWord) return false; //one character map\\'s to two words\\n                }\\n                else if (wordToChMap.count(currWord))\\n                {\\n                    char alreadyMappedCh = wordToChMap[currWord];\\n                    if (alreadyMappedCh != currCh) return false; //one word map\\'s to two characters\\n                }\\n                else\\n                {\\n                    chToWordMap[currCh] = currWord;\\n                    wordToChMap[currWord] = currCh;\\n                }\\n                //=================================================\\n                currWord = \"\";\\n            }\\n            else currWord.push_back(s[i]);\\n        }\\n        //===============================================================================================\\n        return (chIdx == pattern.size());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977723,
                "title": "java-100-fast-easy",
                "content": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [] arr = s.split(\" \");\\n        if(pattern.length()!=arr.length)return false;\\n        HashMap<Character,String> map = new HashMap<>(); \\n        for(int i = 0; i<pattern.length(); i++){\\n            char ch = pattern.charAt(i);\\n            boolean containsKey = map.containsKey(ch);\\n            if(map.containsValue(arr[i]) && !containsKey)return false;\\n            if(containsKey && !map.get(ch).equals(arr[i]))return false;\\n            else map.put(ch,arr[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [] arr = s.split(\" \");\\n        if(pattern.length()!=arr.length)return false;\\n        HashMap<Character,String> map = new HashMap<>(); \\n        for(int i = 0; i<pattern.length(); i++){\\n            char ch = pattern.charAt(i);\\n            boolean containsKey = map.containsKey(ch);\\n            if(map.containsValue(arr[i]) && !containsKey)return false;\\n            if(containsKey && !map.get(ch).equals(arr[i]))return false;\\n            else map.put(ch,arr[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979707,
                "title": "c-solution-using-two-hashmaps",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- First we\\u2019re taking the words from string *s* and storing in to vector ***v.***\\n- If no of words in string ***s*** is not equal to the no of the letters in string *********pattern,********* then it\\u2019ll be false because every words can\\u2019t be map with each letters.\\n- Then we\\u2019ll take 2 maps:\\n    - ***mp:*** to store the words based on the letters\\n    - ***m:*** to store the letters based on the words\\n- Next we\\u2019ll iterate over the elements & push them into maps. Same time we\\u2019ll compare if the words/letters mapped previously with anyone else. If mapped then return false.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> v;\\n        string word;\\n        stringstream iss(s);\\n        while (iss >> word)\\n            v.push_back(word);\\n\\n        if (pattern.size() != v.size())\\n            return false;\\n\\n        unordered_map<char, string> mp;\\n        unordered_map<string, char> m;\\n\\n        for(int i=0; i<v.size(); i++){\\n            if(mp.find(pattern[i]) != mp.end() && mp[pattern[i]] != v[i]) \\n                return false;\\n\\n            else if(m.find(v[i]) != m.end() && m[v[i]] != pattern[i]) \\n                return false;\\n\\n            mp[pattern[i]] = v[i];\\n            m[v[i]] = pattern[i];\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> v;\\n        string word;\\n        stringstream iss(s);\\n        while (iss >> word)\\n            v.push_back(word);\\n\\n        if (pattern.size() != v.size())\\n            return false;\\n\\n        unordered_map<char, string> mp;\\n        unordered_map<string, char> m;\\n\\n        for(int i=0; i<v.size(); i++){\\n            if(mp.find(pattern[i]) != mp.end() && mp[pattern[i]] != v[i]) \\n                return false;\\n\\n            else if(m.find(v[i]) != m.end() && m[v[i]] != pattern[i]) \\n                return false;\\n\\n            mp[pattern[i]] = v[i];\\n            m[v[i]] = pattern[i];\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833962,
                "title": "c-0-ms-beats-100-short-and-precise-explained-one-pass-tokenization",
                "content": "**Explanation**\\nThe key here is *bijection*, that is one-one and onto mapping. You can read about it here: https://en.wikipedia.org/wiki/Bijection.\\n\\nThe solution is simple: map a character in the pattern to a word in the string (in order) and map the same word to the same character. Throughout the loop over the string or pattern, ensure that there exists one and only one mapping between a character in pattern and a word in string *(one-one)* **and** each character is mapped to at least one word *(onto)*. That\\'s it!\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string str) {\\n        vector<int> pat_map (26, 0);\\n        unordered_map<string,int> str_map;\\n        int i=0, n = pattern.size();\\n        istringstream ss (str);\\n        string token;\\n        \\n        for(string token; ss >> token; ++i) {\\n            if(i == n || pat_map[pattern[i]-\\'a\\'] != str_map[token]) return false;\\n            \\n            // 1-based indexing since map assigns 0 as a default value for keys not found.\\n            pat_map[pattern[i]-\\'a\\'] = str_map[token] = i+1;\\n        }\\n        \\n        return i == n;\\n    }\\n};\\n```\\n\\nIf you like the solution and the explantion, please **Upvote** to help others!\\nHave a great day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string str) {\\n        vector<int> pat_map (26, 0);\\n        unordered_map<string,int> str_map;\\n        int i=0, n = pattern.size();\\n        istringstream ss (str);\\n        string token;\\n        \\n        for(string token; ss >> token; ++i) {\\n            if(i == n || pat_map[pattern[i]-\\'a\\'] != str_map[token]) return false;\\n            \\n            // 1-based indexing since map assigns 0 as a default value for keys not found.\\n            pat_map[pattern[i]-\\'a\\'] = str_map[token] = i+1;\\n        }\\n        \\n        return i == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834256,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar wordPattern = function(pattern, str) {\\n    const words = str.split(/\\\\s+/);\\n    const map = new Map();\\n    \\n    if(words.length !== pattern.length) return false;\\n    if(new Set(words).size !== new Set(pattern).size) return false;\\n    \\n    for(let i = 0; i < pattern.length; i++) {\\n        if(map.has(pattern[i]) && \\n           map.get(pattern[i]) !== words[i]) return false;\\n        map.set(pattern[i], words[i]);\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar wordPattern = function(pattern, str) {\\n    const words = str.split(/\\\\s+/);\\n    const map = new Map();\\n    \\n    if(words.length !== pattern.length) return false;\\n    if(new Set(words).size !== new Set(pattern).size) return false;\\n    \\n    for(let i = 0; i < pattern.length; i++) {\\n        if(map.has(pattern[i]) && \\n           map.get(pattern[i]) !== words[i]) return false;\\n        map.set(pattern[i], words[i]);\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833961,
                "title": "python-2-hash-tables-explained",
                "content": "Pretty straightforward problem, where we need to just try to do what is asked. We need to check if our strings follow the pattern, so let us try to create this pattern and make sure that we do not have conflicts.\\n\\n1. Split our string into `words`, so now we have list of words.\\n2. Check if length of `words` is equal to length of `pattern` and if not, immediatly return `False`.\\n3. Now, iterate one by one elements from `pattern` and `words`: let us keep two dictionaries: one is for correspondences `word -> letter` and another for `letter -> word`. Check if we already have `symb` in `d_symb`:\\n\\ta. If we do not have it, but it happen that our `word` is already occupied, we return `False`, we have a conflict.\\n\\tb. If word is not occupied, we create two connections: one for `d_symb` and one for `d_word`.\\n\\tc. Finally, if `symb` is already in our `d_symb`, but `word` is not the one we expect to see, we return `False`.\\n4. If we reached the end and did not return `False`, it means that we did not have any conflicts, so we need to return `True`.\\n\\n**Complexity**: time complexity is `O(n + m)`, where `n` is number of symbols in `pattern` and `m` is total number of symbols in `s`. Space complexity is `O(k)`, where `k` is total length of all unique words.\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern, s):\\n        d_symb, d_word, words = {}, {}, s.split()\\n        if len(words) != len(pattern): return False\\n        for symb, word in zip(pattern, words):\\n            if symb not in d_symb:\\n                if word in d_word: return False\\n                else:\\n                    d_symb[symb] = word\\n                    d_word[word] = symb\\n            elif d_symb[symb] != word: return False\\n        return True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern, s):\\n        d_symb, d_word, words = {}, {}, s.split()\\n        if len(words) != len(pattern): return False\\n        for symb, word in zip(pattern, words):\\n            if symb not in d_symb:\\n                if word in d_word: return False\\n                else:\\n                    d_symb[symb] = word\\n                    d_word[word] = symb\\n            elif d_symb[symb] != word: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73599,
                "title": "share-my-python-solution-with-two-dictionaries",
                "content": "Use two dictionaries with index as values\\n\\n    class Solution(object):\\n        def wordPattern(self, pattern, word_str):\\n            \"\"\"\\n            :type pattern: str\\n            :type str: str\\n            :rtype: bool\\n            \"\"\"\\n            words = word_str.split(\" \")\\n            if len(pattern) != len(words):\\n                return False\\n    \\n    \\t\\t# use two dictionaries, mapping character / string with index\\n            pattern_map, word_map = {}, {}\\n            for i in xrange(len(pattern)):\\n                if pattern_map.get(pattern[i], -1) != word_map.get(words[i], -1):\\n                    return False\\n                pattern_map[pattern[i]] = word_map[words[i]] = i\\n    \\n            return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        def wordPattern(self, pattern, word_str):\\n            \"\"\"\\n            :type pattern: str\\n            :type str: str\\n            :rtype: bool\\n            \"\"\"\\n            words = word_str.split(\" \")\\n            if len(pattern) != len(words):\\n                return False\\n    \\n    \\t\\t# use two dictionaries, mapping character / string with index\\n            pattern_map, word_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 2978591,
                "title": "c-hashmap-hashset-100-intuitive",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        bool wordPattern(string pattern, string s)\\n        {\\n            vector<string> v;\\n\\n            // separate the string with the whitespaces \\n            stringstream ss(s);\\n            string word;\\n            while( ss >> word ) v.push_back( word );\\n\\n            // if data is insufficient \\n            if (v.size() != pattern.size()) return false;\\n\\n            unordered_map<char, string> m;\\n            set<string> st;\\n\\n            for (int i = 0; i < pattern.size(); i++){\\n\\n                if (m.find(pattern[i]) != m.end()){\\n                \\t// pattern = \"abba\", s = \"dog cat cat fish\"\\n                    if (m[pattern[i]] != v[i]) return false;\\n                }\\n                else{\\n                    // if any of the alphabet have\\'nt matched with string\\n                    if (st.count(v[i]) > 0) return false;\\n                    m[pattern[i]] = v[i];\\n                    st.insert(v[i]);\\n                }\\n            }\\n\\n            return true;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool wordPattern(string pattern, string s)\\n        {\\n            vector<string> v;\\n\\n            // separate the string with the whitespaces \\n            stringstream ss(s);\\n            string word;\\n            while( ss >> word ) v.push_back( word );\\n\\n            // if data is insufficient \\n            if (v.size() != pattern.size()) return false;\\n\\n            unordered_map<char, string> m;\\n            set<string> st;\\n\\n            for (int i = 0; i < pattern.size(); i++){\\n\\n                if (m.find(pattern[i]) != m.end()){\\n                \\t// pattern = \"abba\", s = \"dog cat cat fish\"\\n                    if (m[pattern[i]] != v[i]) return false;\\n                }\\n                else{\\n                    // if any of the alphabet have\\'nt matched with string\\n                    if (st.count(v[i]) > 0) return false;\\n                    m[pattern[i]] = v[i];\\n                    st.insert(v[i]);\\n                }\\n            }\\n\\n            return true;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978094,
                "title": "two-different-solutions-java",
                "content": "# Using 1 HashMap\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] arr = s.split(\" \");\\n        if(arr.length != pattern.length()) return false;\\n\\n        Map<Character, String> hs = new HashMap<Character, String>();\\n\\n        for(int i=0; i<arr.length; i++){\\n            char c = pattern.charAt(i);\\n            String str = arr[i];\\n            if(hs.containsKey(c)){\\n                if(!hs.get(c).equals(str))\\n                return false; \\n            }\\n            else{\\n                if(hs.containsValue(str)) return false; \\n                hs.put(c, str);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Using 2 HashMap\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] array = s.split(\" \");\\n        if(array.length != pattern.length()) return false;\\n\\n        Map<Character, String> c2s = new HashMap<Character, String>();\\n        Map<String, Character> s2c = new HashMap<String, Character>();\\n\\n        for(int i=0; i<pattern.length(); i++){\\n            char c = pattern.charAt(i);\\n            String str = array[i];\\n            if(!c2s.containsKey(c)){\\n                c2s.put(c,str);\\n            }\\n            if(!s2c.containsKey(str)){\\n                s2c.put(str,c);\\n            }\\n            if(!c2s.get(c).equals(str) || !s2c.get(str).equals(c)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] arr = s.split(\" \");\\n        if(arr.length != pattern.length()) return false;\\n\\n        Map<Character, String> hs = new HashMap<Character, String>();\\n\\n        for(int i=0; i<arr.length; i++){\\n            char c = pattern.charAt(i);\\n            String str = arr[i];\\n            if(hs.containsKey(c)){\\n                if(!hs.get(c).equals(str))\\n                return false; \\n            }\\n            else{\\n                if(hs.containsValue(str)) return false; \\n                hs.put(c, str);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] array = s.split(\" \");\\n        if(array.length != pattern.length()) return false;\\n\\n        Map<Character, String> c2s = new HashMap<Character, String>();\\n        Map<String, Character> s2c = new HashMap<String, Character>();\\n\\n        for(int i=0; i<pattern.length(); i++){\\n            char c = pattern.charAt(i);\\n            String str = array[i];\\n            if(!c2s.containsKey(c)){\\n                c2s.put(c,str);\\n            }\\n            if(!s2c.containsKey(str)){\\n                s2c.put(str,c);\\n            }\\n            if(!c2s.get(c).equals(str) || !s2c.get(str).equals(c)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73533,
                "title": "java-solution-with-a-hashmap-and-a-hashset",
                "content": "    public class Solution {\\n        public boolean wordPattern(String pattern, String str) {\\n            String[] words = str.split(\" \");\\n            if (words.length != pattern.length()) {\\n      \\t\\t\\treturn false;\\n            }\\n            \\n            Map<Character, String> dict = new HashMap();\\n            Set<String> set = new HashSet();\\n            \\n            for (int i = 0; i < words.length; ++i) {\\n            \\tchar c = pattern.charAt(i);\\n            \\tif (!dict.containsKey(c)) {\\n            \\t    if (!set.add(words[i])) {\\n            \\t        return false;\\n            \\t    }\\n            \\t\\tdict.put(c, words[i]);\\n            \\t} else if (!dict.get(c).equals(words[i])) {\\n            \\t\\treturn false;\\n            \\t}\\n            }\\n            \\n            return true;\\n        }\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean wordPattern(String pattern, String str) {\\n            String[] words = str.split(\" \");\\n            if (words.length != pattern.length()) {\\n      \\t\\t\\treturn false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2978312,
                "title": "two-hash-map-line-by-line-comments-for-beginners",
                "content": "There is nothing smart about this solution.\\nSmarter solutions are **[Here](https://leetcode.com/problems/word-pattern/discuss/73433/Short-in-Python)** and **[Here](https://leetcode.com/problems/word-pattern/discuss/2977027/Python-3-oror-2-lines-w-explanation-oror-TM%3A-98-100)**\\n\\n```python\\nclass Solution:\\n    def wordPattern(self, p: str, s: str) -> bool:\\n        # split s by \\' \\' to create a list\\n        s = s.split()\\n        # if the length of p and s are different, they cannot match\\n        if len(p)!=len(s): return False\\n        \\n        # Two hash maps\\n        # s2p for mapping words in s to char in p\\n        # p2s for mapping char in p to words in p\\n        p2s, s2p = {}, {}\\n        \\n        for i in range(len(s)):\\n            \\n            # Add s[i] in s2p to map to p[i], if we haven\\'t seen it before.\\n            if s[i] not in s2p:\\n                s2p[s[i]] = p[i]\\n            # if s[i] is already in s2p, but its value is not p[i]\\n            # This means there are two different char in p matched to the same word in s, so return False\\n            elif s2p[s[i]] != p[i]:\\n                return False\\n            \\n            # Same as above just from p to s.\\n            if p[i] not in p2s:\\n                p2s[p[i]] = s[i]\\n            elif p2s[p[i]] != s[i]:\\n                return False\\n        \\n        # Everything matched, return True\\n        return True\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def wordPattern(self, p: str, s: str) -> bool:\\n        # split s by \\' \\' to create a list\\n        s = s.split()\\n        # if the length of p and s are different, they cannot match\\n        if len(p)!=len(s): return False\\n        \\n        # Two hash maps\\n        # s2p for mapping words in s to char in p\\n        # p2s for mapping char in p to words in p\\n        p2s, s2p = {}, {}\\n        \\n        for i in range(len(s)):\\n            \\n            # Add s[i] in s2p to map to p[i], if we haven\\'t seen it before.\\n            if s[i] not in s2p:\\n                s2p[s[i]] = p[i]\\n            # if s[i] is already in s2p, but its value is not p[i]\\n            # This means there are two different char in p matched to the same word in s, so return False\\n            elif s2p[s[i]] != p[i]:\\n                return False\\n            \\n            # Same as above just from p to s.\\n            if p[i] not in p2s:\\n                p2s[p[i]] = s[i]\\n            elif p2s[p[i]] != s[i]:\\n                return False\\n        \\n        # Everything matched, return True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140265,
                "title": "c-easy-to-understand-hashmap-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool wordPattern(string pattern, string s) {\\n\\t\\t\\tvector<string> v;\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tstring temp = \"\";\\n\\t\\t\\twhile(i < s.size()){\\n\\t\\t\\t\\tif(s[i] == \\' \\'){\\n\\t\\t\\t\\t\\tv.push_back(temp);\\n\\t\\t\\t\\t\\ttemp = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp += s[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tv.push_back(temp);\\n\\n\\t\\t\\tif(v.size() != pattern.size()){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tunordered_map<char, string> m;\\n\\t\\t\\tset<string> st;\\n\\t\\t\\tfor(int i = 0; i < pattern.size(); i++){\\n\\t\\t\\t\\tif(m.find(pattern[i]) != m.end()){\\n\\t\\t\\t\\t\\tif(m[pattern[i]] != v[i]){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(st.count(v[i]) > 0){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tm[pattern[i]] = v[i];\\n\\t\\t\\t\\t\\tst.insert(v[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool wordPattern(string pattern, string s) {\\n\\t\\t\\tvector<string> v;\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tstring temp = \"\";\\n\\t\\t\\twhile(i < s.size()){\\n\\t\\t\\t\\tif(s[i] == \\' \\'){\\n\\t\\t\\t\\t\\tv.push_back(temp);\\n\\t\\t\\t\\t\\ttemp = \"\";\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 73519,
                "title": "haven-t-seen-a-c-solution-post-mine-here",
                "content": "    bool wordPattern(char* pattern, char* str)\\n    {\\n            int i, j, len = strlen(pattern);\\n            int search[len];\\n            char *token, *saveptr; char strtmp[strlen(str)];\\n            for(i = 0; i < len; i++) search[i] = -1;\\n    \\n            strcpy(strtmp, str);\\n            token = strtok_r(strtmp, \" \", &saveptr);\\n            for(i = 0; i < len; i++)\\n            {\\n                    int a = strchr(pattern, pattern[i]) - pattern;\\n    \\n                    if(token == NULL) break;\\n                    int b = strstr(str, token) - str;\\n    \\n                    for(j = 0; j < a; j++)\\n                            if(search[j] == b) return false;\\n                    if(search[a] == -1) search[a] = b;\\n                    else if(search[a]!= b) return false;\\n                    token = strtok_r(NULL, \" \", &saveptr);\\n            }\\n            if((token == NULL) ^ (i== len)) return false;\\n            return true;\\n    }",
                "solutionTags": [],
                "code": "    bool wordPattern(char* pattern, char* str)\\n    {\\n            int i, j, len = strlen(pattern);\\n            int search[len];\\n            char *token, *saveptr; char strtmp[strlen(str)];\\n            for(i = 0; i < len; i++) search[i] = -1;\\n    \\n            strcpy(strtmp, str);\\n            token = strtok_r(strtmp, \" \", &saveptr);\\n            for(i = 0; i < len; i++)\\n            {\\n                    int a = strchr(pattern, pattern[i]) - pattern;\\n    \\n                    if(token == NULL) break;\\n                    int b = strstr(str, token) - str;\\n    \\n                    for(j = 0; j < a; j++)\\n                            if(search[j] == b) return false;\\n                    if(search[a] == -1) search[a] = b;\\n                    else if(search[a]!= b) return false;\\n                    token = strtok_r(NULL, \" \", &saveptr);\\n            }\\n            if((token == NULL) ^ (i== len)) return false;\\n            return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2387645,
                "title": "c-easy-0ms-solution-detail-explanation",
                "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n\\t\\n//         Create vector for storing individual word\\n\\n        vector<string> v;\\n        string word;\\n        \\n//         Dividing string into words using string stream\\n\\n        stringstream iss(s);\\n        \\n        while(iss>>word){\\n            v.push_back(word);\\n        }\\n        \\n//         Checking size of pattern and string if both not same then return false  \\n\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        \\n//         Create unorderd map to store pattern as well as word eg. a: dog, b: cat\\n\\n        unordered_map<char, string> m;\\n        set<string> st;\\n        \\n\\n//          Traverse through pattern\\n\\n        for(int i=0;i<pattern.size();i++){\\n//         check if pattern is already present in map\\n\\n            if(m.find(pattern[i])!=m.end()){\\n\\t\\t\\t\\n//          if yes then check if privious word matches with current or not if not return false\\n\\n\\t\\t\\t\\t\\tif(m[pattern[i]]!=v[i]){\\n                    return false;\\n                }\\n            }\\n//         If pattern is not already present in map then add \\n//         Before adding check if count of set is greater than 0 then that word is already                there in map ie. different pattern with same word which is false\\n            \\n            else{\\n                if(st.count(v[i])>0){\\n                    return false;\\n                }\\n                m[pattern[i]]= v[i];\\n                st.insert(v[i]);\\n            }\\n            \\n        }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n\\t\\n//         Create vector for storing individual word\\n\\n        vector<string> v;\\n        string word;\\n        \\n//         Dividing string into words using string stream\\n\\n        stringstream iss(s);\\n        \\n        while(iss>>word){\\n            v.push_back(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 456240,
                "title": "python-20ms-solution-beats-99-using-dict",
                "content": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        # dictionary approach \\n        # Time complexity: O(n)\\n        # Space complexity: O(n)\\n        \\n        words = str.split(\" \")\\n        if not len(words) == len(pattern):\\n            return False\\n        \\n        mapping = dict() # key is the pattern, value is the word\\n        \\n        for i in range(len(words)):\\n            if pattern[i] not in mapping:\\n                # values() is a set - fast membership testing - O(1) amortised search\\n                if words[i] not in mapping.values(): \\n                    mapping[pattern[i]] = words[i]\\n                else:\\n                    return False\\n            else:\\n                if not mapping[pattern[i]] == words[i]:\\n                    return False\\n        return True\\n                \\n                \\n           \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        # dictionary approach \\n        # Time complexity: O(n)\\n        # Space complexity: O(n)\\n        \\n        words = str.split(\" \")\\n        if not len(words) == len(pattern):\\n            return False\\n        \\n        mapping = dict() # key is the pattern, value is the word\\n        \\n        for i in range(len(words)):\\n            if pattern[i] not in mapping:\\n                # values() is a set - fast membership testing - O(1) amortised search\\n                if words[i] not in mapping.values(): \\n                    mapping[pattern[i]] = words[i]\\n                else:\\n                    return False\\n            else:\\n                if not mapping[pattern[i]] == words[i]:\\n                    return False\\n        return True\\n                \\n                \\n           \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978007,
                "title": "c-100-faster-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s+=\\' \\';\\n    int c=0;\\n        int p=pattern.size();\\n        int n=s.size();\\n        string str=\"\";\\n        vector<string>res;\\n        for(int i=0;i<n;i++){\\n             if(s[i]!=\\' \\'){\\n                  str+=s[i];\\n             }\\n             else{\\n                 res.push_back(str);\\n                 str=\"\";\\n             }\\n            }\\n            int size=res.size();\\n            if(p!=size)\\n            return false;\\n            for(int i=0;i<p-1;i++){\\n                for(int j=i+1;j<p;j++){\\n                    if(pattern[i]==pattern[j]&&res[i]==res[j])\\n                      c++;\\n                      else if(pattern[i]!=pattern[j]&&res[i]!=res[j])\\n                      c++;\\n                      else\\n                      return false;\\n                }\\n            }\\n       \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s+=\\' \\';\\n    int c=0;\\n        int p=pattern.size();\\n        int n=s.size();\\n        string str=\"\";\\n        vector<string>res;\\n        for(int i=0;i<n;i++){\\n             if(s[i]!=\\' \\'){\\n                  str+=s[i];\\n             }\\n             else{\\n                 res.push_back(str);\\n                 str=\"\";\\n             }\\n            }\\n            int size=res.size();\\n            if(p!=size)\\n            return false;\\n            for(int i=0;i<p-1;i++){\\n                for(int j=i+1;j<p;j++){\\n                    if(pattern[i]==pattern[j]&&res[i]==res[j])\\n                      c++;\\n                      else if(pattern[i]!=pattern[j]&&res[i]!=res[j])\\n                      c++;\\n                      else\\n                      return false;\\n                }\\n            }\\n       \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977947,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=aKCWUKdhCD4&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        // convert s to a vector of strings\\n        // e.g. \"dog cat cat dog\" -> [\"dog\", \"cat\", \"cat\", \"dog\"]\\n        stringstream ss(s);\\n        string word;\\n        vector<string> words;\\n        while (ss >> word) {\\n            words.push_back(word);\\n        }\\n        // the size of words needs to be same as that of pattern\\n        // e.g. words = [\"xxx\"], pattern = \"xxx\"\\n        if (words.size() != pattern.size()) {\\n            return false;\\n        }\\n        // char in pattern -> word\\n        // e.g. a -> dog\\n        // e.g. b -> cat\\n        unordered_map<char, string> m;\\n        set<string> used;\\n        // for each word in words ...\\n        for (int i = 0; i < words.size(); i++) {\\n            // check if map the pattern\\n            if (m.count(pattern[i])) {\\n                // if pattern[i] exists in the hashmap,\\n                // then we need to make sure that the word is correct\\n                if (m[pattern[i]] != words[i]) {\\n                    return false;\\n                }\\n            } else {\\n                // each word can only map to one pattern\\n                // e.g. pattern = \"ab\", s = \"dog dog\"\\n                if (used.find(words[i]) != used.end()) {\\n                    return false;\\n                }\\n                // if not, then map it   \\n                // e.g. a -> dog\\n                m[pattern[i]] = words[i];\\n                used.insert(words[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n// abba\\n// dog cat cat dog\\n// a -> dog\\n// b -> cat\\n// hashmap\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        // convert s to a vector of strings\\n        // e.g. \"dog cat cat dog\" -> [\"dog\", \"cat\", \"cat\", \"dog\"]\\n        stringstream ss(s);\\n        string word;\\n        vector<string> words;\\n        while (ss >> word) {\\n            words.push_back(word);\\n        }\\n        // the size of words needs to be same as that of pattern\\n        // e.g. words = [\"xxx\"], pattern = \"xxx\"\\n        if (words.size() != pattern.size()) {\\n            return false;\\n        }\\n        // char in pattern -> word\\n        // e.g. a -> dog\\n        // e.g. b -> cat\\n        unordered_map<char, string> m;\\n        set<string> used;\\n        // for each word in words ...\\n        for (int i = 0; i < words.size(); i++) {\\n            // check if map the pattern\\n            if (m.count(pattern[i])) {\\n                // if pattern[i] exists in the hashmap,\\n                // then we need to make sure that the word is correct\\n                if (m[pattern[i]] != words[i]) {\\n                    return false;\\n                }\\n            } else {\\n                // each word can only map to one pattern\\n                // e.g. pattern = \"ab\", s = \"dog dog\"\\n                if (used.find(words[i]) != used.end()) {\\n                    return false;\\n                }\\n                // if not, then map it   \\n                // e.g. a -> dog\\n                m[pattern[i]] = words[i];\\n                used.insert(words[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n// abba\\n// dog cat cat dog\\n// a -> dog\\n// b -> cat\\n// hashmap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696147,
                "title": "java-easy-to-understand-using-hashmap",
                "content": "```\\npublic class Solution {\\n    public boolean wordPattern(String pattern, String str) {\\n        String[] arr= str.split(\" \");\\n        HashMap<Character, String> map = new HashMap<Character, String>();\\n        if(arr.length!= pattern.length())\\n            return false;\\n        for(int i=0; i<arr.length; i++){\\n            char c = pattern.charAt(i);\\n            if(map.containsKey(c)){\\n                if(!map.get(c).equals(arr[i]))\\n                    return false;\\n            }else{\\n                if(map.containsValue(arr[i]))\\n                    return false;\\n                map.put(c, arr[i]);\\n            }    \\n        }\\n        return true;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean wordPattern(String pattern, String str) {\\n        String[] arr= str.split(\" \");\\n        HashMap<Character, String> map = new HashMap<Character, String>();\\n        if(arr.length!= pattern.length())\\n            return false;\\n        for(int i=0; i<arr.length; i++){\\n            char c = pattern.charAt(i);\\n            if(map.containsKey(c)){\\n                if(!map.get(c).equals(arr[i]))\\n                    return false;\\n            }else{\\n                if(map.containsValue(arr[i]))\\n                    return false;\\n                map.put(c, arr[i]);\\n            }    \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977218,
                "title": "java-single-hashmap-1ms-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to check whether String `s` follows the pattern in `pattern`.\\n- So we\\'ve got to have some sort of mapping. We hence need to use a HashMap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First split `s` to an array of strings `str[]` using split function and consider `\" \"`(space) as delimiter.\\n- Check whether the length of `pattern` is equal to length of `str`. If no, then return false.\\n- Create a HashMap `map <Character, String>`.\\n- Now iterate over the `pattern` and check the following\\n    1. If `map` is not empty and map contains `pattern[i]` as a key the check\\n        1.  If the value associated with the key matches `str[i]`. If it matches `continue`.\\n        1. If the value doesn\\'t match simply return false.\\n    2. If `map` is not empty and map doesn\\'t contains `pattern[i]` as a key the check\\n        1. There is any value `str[i]` present in the map. If this evaluates to true then this would mean that `map` has a value present in `str`  but is mapped to some other key other than `pattern[i]`. Hence we return false.\\n\\n    3. If None of the above cases match we simply put the key as `pattern[i]` and value as `str[i]` in `map`\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character, String> map = new HashMap<>();\\n\\n        String[] str = s.split(\" \");\\n\\n        if(str.length != pattern.length()) return false;\\n\\n        for(int i=0; i<pattern.length(); i++){\\n            char a = pattern.charAt(i);\\n            if(!map.isEmpty() && map.containsKey(a) && !map.get(a).equals(str[i])) return false;\\n\\n            if(!map.isEmpty() && map.containsKey(a) && map.get(a).equals(str[i])) continue;\\n    \\n            if(!map.isEmpty() && map.containsValue(str[i])) return false;\\n            \\n            map.put(a,str[i]);\\n        }\\n        return true;\\n    }\\n\\n}\\n```\\n\\nIf This solution can be improved further please do mention it in the comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character, String> map = new HashMap<>();\\n\\n        String[] str = s.split(\" \");\\n\\n        if(str.length != pattern.length()) return false;\\n\\n        for(int i=0; i<pattern.length(); i++){\\n            char a = pattern.charAt(i);\\n            if(!map.isEmpty() && map.containsKey(a) && !map.get(a).equals(str[i])) return false;\\n\\n            if(!map.isEmpty() && map.containsKey(a) && map.get(a).equals(str[i])) continue;\\n    \\n            if(!map.isEmpty() && map.containsValue(str[i])) return false;\\n            \\n            map.put(a,str[i]);\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977131,
                "title": "c-begineer-friendly-easy-understanding-heap-video-solution",
                "content": "# Intuition && Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=J3vuesaIGsA/\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool wordPattern(string pattern, string s) {\\n\\n        unordered_map<char,string>mp;\\n        unordered_map<string,bool>visited;\\n        vector<string>wordList;\\n\\n        // stringstream s\\n        stringstream st(s);\\n\\n        string word;\\n        int count = 0;\\n\\n        while(st>>word){\\n            count++;\\n            wordList.push_back(word);\\n        }\\n\\n\\n       if(pattern.size() != count){\\n            return false;\\n        }else{\\n            for(int i=0;i<pattern.size();i++){\\n\\n\\n                 char c=pattern[i];\\n\\n                //case1. if not visted for new letter eg: abba s[dog,dog,dog,dog] so dog is already assinged to \\'a\\' so \"dog\" will be visited before it comes to the letter b.\\n                 if(mp[c] == \"\" && visited[wordList[i]] == true ){\\n                     return false;\\n                 }\\n\\n                //case 2 .if not visited we will make it visited and assign value as v[i]\\n                else if(mp[c] == \"\"){\\n\\u2003\\u2003\\u2003\\u2003\\u2003  mp[c] = wordList[i];\\n                     visited[wordList[i]] =true;\\n                 }else{\\n                    //case 3. if value is already assigned so not equal to the v[i].\\n                     if(mp[c] != wordList[i]) return false;\\n                 }\\n\\n            }\\n\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool wordPattern(string pattern, string s) {\\n\\n        unordered_map<char,string>mp;\\n        unordered_map<string,bool>visited;\\n        vector<string>wordList;\\n\\n        // stringstream s\\n        stringstream st(s);\\n\\n        string word;\\n        int count = 0;\\n\\n        while(st>>word){\\n            count++;\\n            wordList.push_back(word);\\n        }\\n\\n\\n       if(pattern.size() != count){\\n            return false;\\n        }else{\\n            for(int i=0;i<pattern.size();i++){\\n\\n\\n                 char c=pattern[i];\\n\\n                //case1. if not visted for new letter eg: abba s[dog,dog,dog,dog] so dog is already assinged to \\'a\\' so \"dog\" will be visited before it comes to the letter b.\\n                 if(mp[c] == \"\" && visited[wordList[i]] == true ){\\n                     return false;\\n                 }\\n\\n                //case 2 .if not visited we will make it visited and assign value as v[i]\\n                else if(mp[c] == \"\"){\\n\\u2003\\u2003\\u2003\\u2003\\u2003  mp[c] = wordList[i];\\n                     visited[wordList[i]] =true;\\n                 }else{\\n                    //case 3. if value is already assigned so not equal to the v[i].\\n                     if(mp[c] != wordList[i]) return false;\\n                 }\\n\\n            }\\n\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976894,
                "title": "daily-leetcoding-challenge-january-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2601454,
                "title": "python-easy-solution",
                "content": "```\\ndef wordPattern(self, pattern: str, s: str) -> bool:\\n        arr = s.split()\\n        if len(arr) != len(pattern):\\n            return False\\n        \\n        for i in range(len(arr)):\\n            if pattern.find(pattern[i]) != arr.index(arr[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef wordPattern(self, pattern: str, s: str) -> bool:\\n        arr = s.split()\\n        if len(arr) != len(pattern):\\n            return False\\n        \\n        for i in range(len(arr)):\\n            if pattern.find(pattern[i]) != arr.index(arr[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 73543,
                "title": "a-simple-python-solution-using-bif-zip-36ms",
                "content": "    class Solution(object):\\n        def wordPattern(self, pattern, str):\\n            \"\"\"\\n            :type pattern: str\\n            :type str: str\\n            :rtype: bool\\n            \"\"\"            \\n            # split str into single words.\\n            slist = str.split()\\n            \\n           \\n            # here we need to consider the len difference\\n            # eg: pattern:\"aaa\" str:\"aa aa aa aa\"\\n            if len(pattern) != len(slist):\\n                return False\\n            \\n            # just like we do in isomorphic problem.\\n            return (len(set(pattern)) == len(set(slist)) == len(set(zip(pattern, slist))))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def wordPattern(self, pattern, str):\\n            \"\"\"\\n            :type pattern: str\\n            :type str: str\\n            :rtype: bool\\n            \"\"\"            \\n            # split str into single words.\\n            slist = str.split()\\n            \\n           \\n            # here we need to consider the len difference\\n            # eg: pattern:\"aaa\" str:\"aa aa aa aa\"\\n            if len(pattern) != len(slist):\\n                return False\\n            \\n            # just like we do in isomorphic problem.\\n            return (len(set(pattern)) == len(set(slist)) == len(set(zip(pattern, slist))))",
                "codeTag": "Java"
            },
            {
                "id": 73591,
                "title": "my-java-hashtable-solution",
                "content": "    import java.util.Hashtable;\\n    public class Solution {\\n        public boolean wordPattern(String pattern, String str) {\\n            String[] arr = str.split(\" \");\\n            int len = pattern.length();\\n            if(arr.length != len){\\n                return false;\\n            }\\n            Hashtable<Character, String> table = new Hashtable<Character, String>();\\n            for( int i = 0; i < len; i++){\\n                char c = pattern.charAt(i);\\n                if( table.containsKey(c) && !table.get(c).equals(arr[i])){\\n                    return false;\\n                }\\n                else if( !table.containsKey(c) && table.contains(arr[i])){\\n                    return false;\\n                }\\n                else{\\n                    table.put(c, arr[i]);\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean wordPattern(String pattern, String str) {\\n            String[] arr = str.split(\" \");\\n            int len = pattern.length();\\n            if(arr.length != len){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3236534,
                "title": "290-space-97-92-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n54.85%\\n\\n- Space complexity:\\n97.92%\\n\\n# Code\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        words = s.split() # split the string s into a list of words\\n        if len(pattern) != len(words): # if the lengths don\\'t match, there can\\'t be a bijection\\n            return False\\n        \\n        pattern_to_word = {} # dictionary to store the mapping from pattern letters to words\\n        word_to_pattern = {} # dictionary to store the mapping from words to pattern letters\\n        \\n        for i in range(len(pattern)):\\n            p = pattern[i]\\n            w = words[i]\\n            if p in pattern_to_word and pattern_to_word[p] != w: # if p already maps to a different word, there\\'s no bijection\\n                return False\\n            if w in word_to_pattern and word_to_pattern[w] != p: # if w already maps to a different pattern letter, there\\'s no bijection\\n                return False\\n            pattern_to_word[p] = w # add the mapping from p to w\\n            word_to_pattern[w] = p # add the mapping from w to p\\n            \\n        return True # if we get here, there\\'s a bijection between pattern letters and words\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        words = s.split() # split the string s into a list of words\\n        if len(pattern) != len(words): # if the lengths don\\'t match, there can\\'t be a bijection\\n            return False\\n        \\n        pattern_to_word = {} # dictionary to store the mapping from pattern letters to words\\n        word_to_pattern = {} # dictionary to store the mapping from words to pattern letters\\n        \\n        for i in range(len(pattern)):\\n            p = pattern[i]\\n            w = words[i]\\n            if p in pattern_to_word and pattern_to_word[p] != w: # if p already maps to a different word, there\\'s no bijection\\n                return False\\n            if w in word_to_pattern and word_to_pattern[w] != p: # if w already maps to a different pattern letter, there\\'s no bijection\\n                return False\\n            pattern_to_word[p] = w # add the mapping from p to w\\n            word_to_pattern[w] = p # add the mapping from w to p\\n            \\n        return True # if we get here, there\\'s a bijection between pattern letters and words\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977017,
                "title": "straight-forward-solution",
                "content": "# Complexity\\nTime complexity: O(n)\\nSpace complexity: O(2n) => O(n)\\n\\n(where `n` is the length of the pattern)\\n\\n# Code\\n```\\nvar wordPattern = function(pattern, s) {\\n\\n    // place words into an array\\n    sArr = s.split(\\' \\')\\n\\n    // if the pattern is lopsided return false\\n    if (pattern.length !== sArr.length) return false\\n    \\n    // create a key map and value map\\n    /* as a caveat, we can\\'t use one map here\\n     * in the edge-case that a pattern key \\n     * and values in s contain the same characters\\n     * \\n     * eg. pattern = \\'abc\\', s = \\'c b a\\'\\n     */\\n    const kMap = {} // key map\\n    const vMap = {} // value map\\n\\n    for (let i = 0; i < pattern.length; i++) {\\n        const key = pattern[i] // letter at index i in pattern\\n        const value = sArr[i] // word at index i in s \\n\\n        // if key or value already exists and does not correspond to\\n        // eachother, return false because we don\\'t have a valid pattern\\n        if (key in kMap || value in vMap) {\\n            if (kMap[key] !== value) return false\\n            if (vMap[value] !== key) return false\\n        } else {\\n            kMap[key] = value\\n            vMap[value] = key\\n        }\\n    }\\n\\n    return true // pattern is valid\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar wordPattern = function(pattern, s) {\\n\\n    // place words into an array\\n    sArr = s.split(\\' \\')\\n\\n    // if the pattern is lopsided return false\\n    if (pattern.length !== sArr.length) return false\\n    \\n    // create a key map and value map\\n    /* as a caveat, we can\\'t use one map here\\n     * in the edge-case that a pattern key \\n     * and values in s contain the same characters\\n     * \\n     * eg. pattern = \\'abc\\', s = \\'c b a\\'\\n     */\\n    const kMap = {} // key map\\n    const vMap = {} // value map\\n\\n    for (let i = 0; i < pattern.length; i++) {\\n        const key = pattern[i] // letter at index i in pattern\\n        const value = sArr[i] // word at index i in s \\n\\n        // if key or value already exists and does not correspond to\\n        // eachother, return false because we don\\'t have a valid pattern\\n        if (key in kMap || value in vMap) {\\n            if (kMap[key] !== value) return false\\n            if (vMap[value] !== key) return false\\n        } else {\\n            kMap[key] = value\\n            vMap[value] = key\\n        }\\n    }\\n\\n    return true // pattern is valid\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699786,
                "title": "without-hashmap-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        if (pattern.size() == 0 && s.size() == 0)\\n            return true;\\n        if (pattern.size() == 0 || s.size() == 0)\\n            return false;\\n        int l=0,r=0;\\n        vector<string>ans;\\n        while(r!=s.size())\\n        {\\n            if(s[r]==\\' \\')\\n            {\\n                ans.push_back(s.substr(l,r-l));\\n                l=r+1;\\n            }\\n            r++;\\n        }\\n        ans.push_back(s.substr(l,r-l));\\n        if (pattern.size() != ans.size()) return false;\\n        for (int i = 0; i < pattern.size(); i++) {\\n            if(pattern.find_last_of(pattern[i]) != (find_end(ans.begin(), ans.end(), ans.begin() + i, ans.begin() + i+1) - ans.begin()))\\n                return false;            \\n        } \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        if (pattern.size() == 0 && s.size() == 0)\\n            return true;\\n        if (pattern.size() == 0 || s.size() == 0)\\n            return false;\\n        int l=0,r=0;\\n        vector<string>ans;\\n        while(r!=s.size())\\n        {\\n            if(s[r]==\\' \\')\\n            {\\n                ans.push_back(s.substr(l,r-l));\\n                l=r+1;\\n            }\\n            r++;\\n        }\\n        ans.push_back(s.substr(l,r-l));\\n        if (pattern.size() != ans.size()) return false;\\n        for (int i = 0; i < pattern.size(); i++) {\\n            if(pattern.find_last_of(pattern[i]) != (find_end(ans.begin(), ans.end(), ans.begin() + i, ans.begin() + i+1) - ans.begin()))\\n                return false;            \\n        } \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696934,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string word;\\n        stringstream iss(s);\\n        while(iss >> word){\\n            words.push_back(word);\\n        }\\n        if(words.size() != pattern.length())return false;\\n        unordered_map<char,string>mp;\\n        set<string>uniq;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mp.find(pattern[i])!=mp.end()){\\n                if(mp[pattern[i]] != words[i])return false;\\n            }else{\\n                \\n                if(uniq.count(words[i]))return false;\\n                mp[pattern[i]] = words[i];\\n                uniq.insert(words[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string word;\\n        stringstream iss(s);\\n        while(iss >> word){\\n            words.push_back(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1695821,
                "title": "java-explained-clean-bimap",
                "content": "**Idea:**\\n* Problem requies for a [Bijection](https://en.wikipedia.org/wiki/Bijection) between letters and words, i.e. every letter must map to a unique word and every word must map back to the same letter. \\n* This means we\\'ll need a letter-to-word hashMap and a reverse (word-to-letter) hashMap to perform quick look-ups and insertions\\n* This also means that size(pattern) must be equal to words in `s`, else bijection is impossible\\n* When a new letter or word is seen, populate both the maps\\n* When an existing letter or word is seen, check if the letter or the word corresponds to the word or letter respectively in the 2 maps\\n* If there\\'s a mismatch, return false. Do this for all the letters in pattern/words in `s`\\n* If no mismatch found, return true\\n* Java Collections API doesn\\'t have a BiMap out of the box, but you can check it out in [Guava library](https://guava.dev/releases/23.0/api/docs/com/google/common/collect/BiMap.html)\\n>**T/S:** O(n)/O(n), where n = size(pattern)\\n```\\npublic boolean wordPattern(String pattern, String s) {\\n\\tvar words = s.split(\" \");\\n\\tvar n = words.length;\\n\\tif (pattern.length() != n)\\n\\t\\treturn false;\\n\\t\\t\\n\\tvar letterToWord = new HashMap<Character, String>();\\n\\tvar wordToLetter = new HashMap<String, Character>();\\n\\n\\tfor (var i = 0; i < n; i++) {\\n\\t\\tvar letter = pattern.charAt(i);\\n\\t\\tvar word = words[i];\\n\\n\\t\\tif (!letterToWord.computeIfAbsent(letter, k -> word).equals(word) ||\\n\\t\\t\\twordToLetter.computeIfAbsent(word, k -> letter) != letter)\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean wordPattern(String pattern, String s) {\\n\\tvar words = s.split(\" \");\\n\\tvar n = words.length;\\n\\tif (pattern.length() != n)\\n\\t\\treturn false;\\n\\t\\t\\n\\tvar letterToWord = new HashMap<Character, String>();\\n\\tvar wordToLetter = new HashMap<String, Character>();\\n\\n\\tfor (var i = 0; i < n; i++) {\\n\\t\\tvar letter = pattern.charAt(i);\\n\\t\\tvar word = words[i];\\n\\n\\t\\tif (!letterToWord.computeIfAbsent(letter, k -> word).equals(word) ||\\n\\t\\t\\twordToLetter.computeIfAbsent(word, k -> letter) != letter)\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73613,
                "title": "my-3ms-java-solution-using-only-one-hashmap",
                "content": "\\n    public boolean wordPattern(String pattern, String str) {\\n        if (pattern == null || str == null) {\\n            return false;\\n        }\\n        char[] patterns = pattern.toCharArray();\\n        String[] strs = str.split(\" \");\\n        if (patterns.length != strs.length) {\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<Character, String>();\\n        for (int i=0; i<patterns.length; i++) {\\n            if (map.containsKey(patterns[i])) {\\n                if (!map.get(patterns[i]).equals(strs[i])) {\\n                    return false;\\n                }\\n            } else if (map.containsValue(strs[i])) {\\n                return false;\\n            }\\n            map.put(patterns[i], strs[i]);\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean wordPattern(String pattern, String str) {\\n        if (pattern == null || str == null) {\\n            return false;\\n        }\\n        char[] patterns = pattern.toCharArray();\\n        String[] strs = str.split(\" \");\\n        if (patterns.length != strs.length) {\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<Character, String>();\\n        for (int i=0; i<patterns.length; i++) {\\n            if (map.containsKey(patterns[i])) {\\n                if (!map.get(patterns[i]).equals(strs[i])) {\\n                    return false;\\n                }\\n            } else if (map.containsValue(strs[i])) {\\n                return false;\\n            }\\n            map.put(patterns[i], strs[i]);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3632665,
                "title": "word-pattern-beats-99-enjoy-leetcode",
                "content": "# KARRAR\\n>Strings problem...\\n>>Word pattern...\\n>>> Usage of array...\\n>>>>Optimized and generalized code...\\n>>>>>Easy to understand...\\n-     PLEASE UPVOTE...\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n            First split the string...\\n            Then compare if the string is according to the given pattern or not...\\n            At last return boolean values according to the result...\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity:\\n- Time complexity: Beats 99% (19 ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Beats 27% (16 MB)\\n\\n![Screenshot from 2023-06-13 14-35-12.png](https://assets.leetcode.com/users/images/d271af19-c102-4296-af61-41964116156f_1686649446.5122435.png)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        arr = s.split()\\n        if len(arr) != len(pattern):\\n            return False\\n        \\n        for i in range(len(arr)):\\n            if pattern.find(pattern[i]) != arr.index(arr[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        arr = s.split()\\n        if len(arr) != len(pattern):\\n            return False\\n        \\n        for i in range(len(arr)):\\n            if pattern.find(pattern[i]) != arr.index(arr[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980130,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        s = s.split()\\n        a=len(set(pattern))\\n        b=len(set(s))\\n        c=len(set(zip_longest(pattern,s)))\\n        if a==b and b==c:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        s = s.split()\\n        a=len(set(pattern))\\n        b=len(set(s))\\n        c=len(set(zip_longest(pattern,s)))\\n        if a==b and b==c:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978539,
                "title": "c-use-hashmap-intuitive-approach",
                "content": "# Intuition\\nBijection means only one charater is associated with one word i.e.one-to-one correspondence for applying this we use hashmaps.\\n\\n# Approach\\nWe need to use two hashmaps- one for \\'char to word\\' and another for \\'word to char\\' mapping. While traversing in string s, we extract word from s and check whether that word is available in map, if it is then we check whether only one char is associated with it, if it is not then we return false. At last when we get full match we return true;\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool wordPattern(string p, string s) \\n    {\\n        unordered_map<char, string> p2s;\\n        unordered_map<string, char> s2p;\\n        string temp=\"\";\\n        int idx=0, n=s.size();\\n        for(int i=0; i<=n; i++)\\n        {\\n            if(s[i]==\\' \\' || i==n)\\n            {\\n                if(idx<p.size() && (p2s.find(p[idx]) != p2s.end() || s2p.find(temp) != s2p.end()))\\n                {\\n                    if(p2s[p[idx]]!=temp || s2p[temp]!=p[idx]) return false;\\n                }\\n\\n                else\\n                {\\n                    p2s[p[idx]] = temp;\\n                    s2p[temp] = p[idx];\\n                }\\n                temp=\"\";\\n                idx++; \\n            }\\n            else\\n                temp += s[i];\\n        }\\n\\n        return idx==p.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool wordPattern(string p, string s) \\n    {\\n        unordered_map<char, string> p2s;\\n        unordered_map<string, char> s2p;\\n        string temp=\"\";\\n        int idx=0, n=s.size();\\n        for(int i=0; i<=n; i++)\\n        {\\n            if(s[i]==\\' \\' || i==n)\\n            {\\n                if(idx<p.size() && (p2s.find(p[idx]) != p2s.end() || s2p.find(temp) != s2p.end()))\\n                {\\n                    if(p2s[p[idx]]!=temp || s2p[temp]!=p[idx]) return false;\\n                }\\n\\n                else\\n                {\\n                    p2s[p[idx]] = temp;\\n                    s2p[temp] = p[idx];\\n                }\\n                temp=\"\";\\n                idx++; \\n            }\\n            else\\n                temp += s[i];\\n        }\\n\\n        return idx==p.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303450,
                "title": "c-unordered-map-easy-solution-word-pattern",
                "content": "**Upvote if it helps :)**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstore all the strings of s into a vector.\\nCreate two maps for two way mapping. Traverse the pattern and check both ways that is if current character is not present in map1 and current string is not present in map2 then insert `{ch,str}` in map1 and `{str,ch}` in map 2. now if curr character or current string is already present in map1 or map2 respectively and its value is not matching then return false.\\n **Dry run on** `pattern = \"abba\", s = \"dog dog dog dog\"`\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlog(n)), n is the size of pattern.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m) m is the size of s.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        string str=\"\";\\n        vector<string>v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\' \\') str+=s[i];\\n            else{\\n                v.push_back(str);\\n                str=\"\";\\n            }\\n        }\\n        v.push_back(str);\\n        if(v.size()!=pattern.size()) return false;\\n        unordered_map<char,string>mp;\\n        unordered_map<string,char>mp2;\\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            if(mp.find(pattern[i])==mp.end()) mp[pattern[i]]=v[i];\\n            if(mp2.find(v[i])==mp2.end()) mp2[v[i]]=pattern[i];\\n            \\n            if(mp[pattern[i]]!=v[i]||mp2[v[i]]!=pattern[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Code2**\\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool wordPattern(string pattern, string s) {\\n\\t\\t\\tvector<string>v;\\n\\t\\t\\tstring str=\"\";\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]!=\\' \\')\\n\\t\\t\\t\\t\\tstr+=s[i];\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(str);\\n\\t\\t\\t\\t\\tstr=\"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv.push_back(str);\\n\\t\\t\\tif(v.size()!=pattern.size()) return false;\\n\\t\\t\\tunordered_map<char,string>m;\\n\\t\\t\\tunordered_set<string>st;\\n\\t\\t\\tfor(int i=0;i<pattern.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(m.find(pattern[i])!=m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(m[pattern[i]]!=v[i]) return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// we came in else block means curr character is new character \\n\\t\\t\\t\\t\\t//if the string correcponding to this character is already in set \\n\\t\\t\\t\\t\\t// then there will be many to one mapping \\n\\t\\t\\t\\t\\t// i.e. same string is matching to two different character \\n\\t\\t\\t\\t\\tif(st.count(v[i])>0) return false;\\n\\t\\t\\t\\t\\tm[pattern[i]]=v[i];\\n\\t\\t\\t\\t\\tst.insert(v[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        string str=\"\";\\n        vector<string>v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\' \\') str+=s[i];\\n            else{\\n                v.push_back(str);\\n                str=\"\";\\n            }\\n        }\\n        v.push_back(str);\\n        if(v.size()!=pattern.size()) return false;\\n        unordered_map<char,string>mp;\\n        unordered_map<string,char>mp2;\\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            if(mp.find(pattern[i])==mp.end()) mp[pattern[i]]=v[i];\\n            if(mp2.find(v[i])==mp2.end()) mp2[v[i]]=pattern[i];\\n            \\n            if(mp[pattern[i]]!=v[i]||mp2[v[i]]!=pattern[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool wordPattern(string pattern, string s) {\\n\\t\\t\\tvector<string>v;\\n\\t\\t\\tstring str=\"\";\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]!=\\' \\')\\n\\t\\t\\t\\t\\tstr+=s[i];\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(str);\\n\\t\\t\\t\\t\\tstr=\"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv.push_back(str);\\n\\t\\t\\tif(v.size()!=pattern.size()) return false;\\n\\t\\t\\tunordered_map<char,string>m;\\n\\t\\t\\tunordered_set<string>st;\\n\\t\\t\\tfor(int i=0;i<pattern.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(m.find(pattern[i])!=m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(m[pattern[i]]!=v[i]) return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// we came in else block means curr character is new character \\n\\t\\t\\t\\t\\t//if the string correcponding to this character is already in set \\n\\t\\t\\t\\t\\t// then there will be many to one mapping \\n\\t\\t\\t\\t\\t// i.e. same string is matching to two different character \\n\\t\\t\\t\\t\\tif(st.count(v[i])>0) return false;\\n\\t\\t\\t\\t\\tm[pattern[i]]=v[i];\\n\\t\\t\\t\\t\\tst.insert(v[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491344,
                "title": "javascript-easy-to-understand",
                "content": "```\\n/**\\n * @param {string} pattern\\n * @param {string} str\\n * @return {boolean}\\n */\\nvar wordPattern = function(pattern, str) {\\n  const strArr = str.split(\\' \\');\\n  if (pattern.length !== strArr.length) return false;\\n  const patMap = new Map();\\n  const strMap = new Map();\\n  for (let i = 0; i < pattern.length; i++) {\\n    if (\\n      (patMap.has(pattern[i]) && patMap.get(pattern[i]) !== strArr[i]) ||\\n      (strMap.has(strArr[i]) && strMap.get(strArr[i]) !== pattern[i])\\n    ) {\\n      return false;\\n    }\\n    patMap.set(pattern[i], strArr[i]);\\n    strMap.set(strArr[i], pattern[i]);\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} pattern\\n * @param {string} str\\n * @return {boolean}\\n */\\nvar wordPattern = function(pattern, str) {\\n  const strArr = str.split(\\' \\');\\n  if (pattern.length !== strArr.length) return false;\\n  const patMap = new Map();\\n  const strMap = new Map();\\n  for (let i = 0; i < pattern.length; i++) {\\n    if (\\n      (patMap.has(pattern[i]) && patMap.get(pattern[i]) !== strArr[i]) ||\\n      (strMap.has(strArr[i]) && strMap.get(strArr[i]) !== pattern[i])\\n    ) {\\n      return false;\\n    }\\n    patMap.set(pattern[i], strArr[i]);\\n    strMap.set(strArr[i], pattern[i]);\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482188,
                "title": "c-100",
                "content": "class Solution \\n{\\n    public:\\n    \\n    bool wordPattern(std::string pa, std::string str) \\n    {\\n        std::string w;                 \\n        std::stringstream ss(str);\\n        std::vector<std::string> words; \\n\\n        while (ss >> w)\\n        {\\n            words.push_back(w);\\n        }\\n        \\n        if(words.size() != pa.size()) return false;\\n        \\n        std::map<char, std::string> ma;\\n        std::map<std::string, char> mb;\\n        \\n        for(size_t i = 0; i < words.size(); i++)\\n        {\\n            ma[pa[i]] = words[i];\\n            mb[words[i]] = pa[i];\\n        }\\n        \\n        for(size_t i = 0; i < words.size(); i++)\\n        {\\n            if(ma[pa[i]] != words[i] || mb[words[i]] != pa[i])\\n            {\\n                return false;\\n            }\\n        }\\n         \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n    \\n    bool wordPattern(std::string pa, std::string str) \\n    {\\n        std::string w;                 \\n        std::stringstream ss(str);\\n        std::vector<std::string> words; \\n\\n        while (ss >> w)\\n        {\\n            words.push_back(w);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 73511,
                "title": "c-0-ms-very-clean-and-easy-to-read",
                "content": "    bool wordPattern(string pattern, string str) \\n    {\\n        istringstream ss(str);\\n        string word;\\n        unordered_map<char, string> bmap;\\n        unordered_map<string, char>rbmap;\\n        \\n        for (char c : pattern)\\n        {\\n            if (! (getline(ss, word, ' ')))\\n                return false;\\n            if ( bmap.emplace(c,word).first->second != word)\\n                return false;\\n            if (rbmap.emplace(word,c).first->second != c)\\n                return false;\\n        }\\n        return ! getline(ss, word, ' ');   \\n    }",
                "solutionTags": [],
                "code": "    bool wordPattern(string pattern, string str) \\n    {\\n        istringstream ss(str);\\n        string word;\\n        unordered_map<char, string> bmap;\\n        unordered_map<string, char>rbmap;\\n        \\n        for (char c : pattern)\\n        {\\n            if (! (getline(ss, word, ' ')))\\n                return false;\\n            if ( bmap.emplace(c,word).first->second != word)\\n                return false;\\n            if (rbmap.emplace(word,c).first->second != c)\\n                return false;\\n        }\\n        return ! getline(ss, word, ' ');   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73452,
                "title": "python-solution-using-1-dictionary",
                "content": "        wordList = str.split()\\n        n1 = len(pattern)\\n        n2 = len(wordList)\\n        if (n1 != n2):\\n            return False\\n        else:\\n            wordList = str.split()\\n            # wordList = [s.encode('ascii') for s in wordList]\\n            # pattern = [s.encode('ascii') for s in pattern]\\n            mydict = {}\\n            result = True\\n            for i in range(len(pattern)):\\n                if (pattern[i] not in mydict):\\n                    if wordList[i] not in mydict.values():\\n                        mydict[pattern[i]] = wordList[i]\\n                    else:\\n                        result = False\\n                        break\\n                else:\\n                    if (mydict[pattern[i]] != wordList[i]):\\n                        result = False\\n                        break\\n            return result",
                "solutionTags": [],
                "code": "        wordList = str.split()\\n        n1 = len(pattern)\\n        n2 = len(wordList)\\n        if (n1 != n2):\\n            return False\\n        else:\\n            wordList = str.split()\\n            # wordList = [s.encode('ascii') for s in wordList]\\n            # pattern = [s.encode('ascii') for s in pattern]\\n            mydict = {}\\n            result = True\\n            for i in range(len(pattern)):\\n                if (pattern[i] not in mydict):\\n                    if wordList[i] not in mydict.values():\\n                        mydict[pattern[i]] = wordList[i]\\n                    else:\\n                        result = False\\n                        break\\n                else:\\n                    if (mydict[pattern[i]] != wordList[i]):\\n                        result = False\\n                        break\\n            return result",
                "codeTag": "Unknown"
            },
            {
                "id": 73528,
                "title": "0-ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool wordPattern(string pattern, string str) {\\n            map<char, string> m;\\n            set<string> set_string;\\n            istringstream input(str);\\n            string s;\\n\\n            for(int i = 0; i < pattern.size(); i++){\\n                if(input>>s){\\n                if(m.find(pattern[i]) != m.end()){\\n                    if(m[pattern[i]] != s)return false; //pattern already mapped with some other string\\n                }\\n                else {\\n                    if(set_string.count(s)){\\n                        return false;//string already exist for some pattern char \\n                    }\\n                    else{\\n                        m[pattern[i]] = s;\\n                        set_string.insert(s);\\n                    }\\n                }\\n                }\\n                else return false ;\\n            }\\n            if(input>>s)return false ;//more string compared to pattern\\n            return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool wordPattern(string pattern, string str) {\\n            map<char, string> m;\\n            set<string> set_string;\\n            istringstream input(str);\\n            string s;\\n\\n            for(int i = 0; i < pattern.size(); i++){\\n                if(input>>s){\\n                if(m.find(pattern[i]) != m.end()){\\n                    if(m[pattern[i]] != s)return false; //pattern already mapped with some other string\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2977828,
                "title": "js-fast-and-clean-beginer-everybody-friendly",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\nThis solution is aimed to divide big problem into small ones.\\nPlease upvote if you found this is helpful~\\n# Code\\n```\\nvar wordPattern = function (pattern, s) {\\n//First of all, create an array contains words from s.\\n//And a template to track key value pairs (we use this a bit later)\\n  const arr = s.split(\" \"),temp = {};\\n\\n//Check if both has the same length and amount of unique charactors.\\n  if (arr.length !== pattern.length || \\nnew Set([...pattern]).size !== new Set(arr).size) return false;\\n  \\n//Iterate over the pattern. \\n//1.If template has not seen pattern before,\\n//add patter as key word as value.\\n//2. Else, compare, return false if key value do not match.\\n  for (let i = 0; i < pattern.length; i++) {\\n    if (!temp[pattern[i]]) {temp[pattern[i]] = arr[i];}\\n     else if (temp[pattern[i]] !== arr[i]) {return false;}\\n  }\\n  return true;\\n};\\n//Happy new year!\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar wordPattern = function (pattern, s) {\\n//First of all, create an array contains words from s.\\n//And a template to track key value pairs (we use this a bit later)\\n  const arr = s.split(\" \"),temp = {};\\n\\n//Check if both has the same length and amount of unique charactors.\\n  if (arr.length !== pattern.length || \\nnew Set([...pattern]).size !== new Set(arr).size) return false;\\n  \\n//Iterate over the pattern. \\n//1.If template has not seen pattern before,\\n//add patter as key word as value.\\n//2. Else, compare, return false if key value do not match.\\n  for (let i = 0; i < pattern.length; i++) {\\n    if (!temp[pattern[i]]) {temp[pattern[i]] = arr[i];}\\n     else if (temp[pattern[i]] !== arr[i]) {return false;}\\n  }\\n  return true;\\n};\\n//Happy new year!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976957,
                "title": "simple-python-easy-10-lines-to-understand-faster-then-95",
                "content": "Here is my code it takes O(n) Time complexity \\n```\\ndef wordPattern(pattern: str, s: str) -> bool:\\n    words = s.split()  # Split the string into a list of words\\n    \\n    if len(pattern) != len(words):  # Check if the number of characters in the pattern and the number of words in the string are equal\\n        return False\\n    \\n    mapping = [-1] * 26  # Initialize an array of size 26 to store the mapping between characters and words\\n    for i in range(len(pattern)):\\n        char = ord(pattern[i]) - ord(\\'a\\')  # Convert the character to an integer index in the range 0-25\\n        word = words[i]\\n        \\n        if mapping[char] != -1:  # If the character is already in the mapping, check if it maps to the same word as before\\n            if mapping[char] != word:\\n                return False\\n        else:  # If the character is not in the mapping, check if the word is already mapped to a different character\\n            for j in range(26):\\n                if mapping[j] == word:\\n                    return False\\n            mapping[char] = word  # Add the mapping to the array\\n    \\n    return True  # If all checks pass, return True\\n\\n```\\nFeel free to ask the doubts and post issues ,\\nUpvote if you find it useful",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef wordPattern(pattern: str, s: str) -> bool:\\n    words = s.split()  # Split the string into a list of words\\n    \\n    if len(pattern) != len(words):  # Check if the number of characters in the pattern and the number of words in the string are equal\\n        return False\\n    \\n    mapping = [-1] * 26  # Initialize an array of size 26 to store the mapping between characters and words\\n    for i in range(len(pattern)):\\n        char = ord(pattern[i]) - ord(\\'a\\')  # Convert the character to an integer index in the range 0-25\\n        word = words[i]\\n        \\n        if mapping[char] != -1:  # If the character is already in the mapping, check if it maps to the same word as before\\n            if mapping[char] != word:\\n                return False\\n        else:  # If the character is not in the mapping, check if the word is already mapped to a different character\\n            for j in range(26):\\n                if mapping[j] == word:\\n                    return False\\n            mapping[char] = word  # Add the mapping to the array\\n    \\n    return True  # If all checks pass, return True\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2162460,
                "title": "java-solution-w-explanation",
                "content": "I personally really like this problem. The problem description is very straightforward and easy to understand. I was given a similar problem during the interview, but the problem is a bit different. There is no single whitespace between each word in input String s so I think it\\'s a little bit harder.\\n  Below is my Solution in **Java** with the explanation. Hope it helps.\\n\\n```\\nclass Solution \\n{\\n    public boolean wordPattern(String pattern, String s)\\n    {\\n        // O(n) time | O(n) space\\n        HashMap<Character, String> myMap = new HashMap<>();\\n        String[] words = s.split(\" \");\\n        \\n        // pattern = \" a b c\" && s = \"mice cat dog chicken\" then return false directly\\n        if(pattern.length() != words.length)    return false;\\n\\n        // update myMap in for-loop\\n        for(int i = 0; i < words.length; i++)\\n        {\\n            char ch = pattern.charAt(i);\\n            \\n            if(!myMap.containsKey(ch))\\n            {\\n                // we need to check the case that, we dont\\' have such a key in map but value already exists\\n                // for example, pattern = \"abab\" && s = \"dog dog dog dog\"\\n                if(myMap.containsValue(words[i]))\\n                    return false;\\n                \\n                myMap.put(ch, words[i]);\\n            }\\n            else\\n                if(!myMap.get(ch).equals(words[i]))\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean wordPattern(String pattern, String s)\\n    {\\n        // O(n) time | O(n) space\\n        HashMap<Character, String> myMap = new HashMap<>();\\n        String[] words = s.split(\" \");\\n        \\n        // pattern = \" a b c\" && s = \"mice cat dog chicken\" then return false directly\\n        if(pattern.length() != words.length)    return false;\\n\\n        // update myMap in for-loop\\n        for(int i = 0; i < words.length; i++)\\n        {\\n            char ch = pattern.charAt(i);\\n            \\n            if(!myMap.containsKey(ch))\\n            {\\n                // we need to check the case that, we dont\\' have such a key in map but value already exists\\n                // for example, pattern = \"abab\" && s = \"dog dog dog dog\"\\n                if(myMap.containsValue(words[i]))\\n                    return false;\\n                \\n                myMap.put(ch, words[i]);\\n            }\\n            else\\n                if(!myMap.get(ch).equals(words[i]))\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696590,
                "title": "simple-python-solution-faster-than-99-34",
                "content": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        li = s.split(\\' \\')\\n        di = {}\\n        if len(li) != len(pattern):\\n            return False\\n        \\n        for i, val in enumerate(pattern):\\n            if val in di and di[val] != li[i]:\\n                return False\\n            elif val not in di and li[i] in di.values():\\n                return False\\n            elif val not in di:\\n                di[val] = li[i]\\n                    \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        li = s.split(\\' \\')\\n        di = {}\\n        if len(li) != len(pattern):\\n            return False\\n        \\n        for i, val in enumerate(pattern):\\n            if val in di and di[val] != li[i]:\\n                return False\\n            elif val not in di and li[i] in di.values():\\n                return False\\n            elif val not in di:\\n                di[val] = li[i]\\n                    \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616905,
                "title": "290-word-pattern-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String words[] = s.split(\" \");\\n        if(words.length!=pattern.length()){\\n            return false;\\n        } \\n        HashMap<Character, String> map = new HashMap<>();\\n        for(int i=0; i<pattern.length(); i++){\\n            char current_char = pattern.charAt(i);\\n            if(map.containsKey(current_char)){\\n                if(!map.get(current_char).equals(words[i])){\\n                    return false;\\n                }\\n            } else {\\n                if(map.containsValue(words[i])){\\n                    return false;\\n                }\\n                map.put(current_char, words[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String words[] = s.split(\" \");\\n        if(words.length!=pattern.length()){\\n            return false;\\n        } \\n        HashMap<Character, String> map = new HashMap<>();\\n        for(int i=0; i<pattern.length(); i++){\\n            char current_char = pattern.charAt(i);\\n            if(map.containsKey(current_char)){\\n                if(!map.get(current_char).equals(words[i])){\\n                    return false;\\n                }\\n            } else {\\n                if(map.containsValue(words[i])){\\n                    return false;\\n                }\\n                map.put(current_char, words[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507792,
                "title": "simple-map-c-100-faster",
                "content": "\\n    bool wordPattern(string pattern, string s) {\\n\\t//Store all words of \"string s\" in a Vector of String.\\n        vector<string> v;\\n        string g=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                v.push_back(g);\\n                g.clear();\\n            }\\n            else\\n                g+=s[i];\\n        }\\n        v.push_back(g);\\n        \\n\\t\\t// \"mp1\" for pattern matching and \"mp2\" for the frequency of string.\\n        map<char,string> mp1;\\n        map<string,int> mp2;\\n        \\n        if(pattern.size()!=v.size())\\n            return false;\\n        \\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            if(mp1.find(pattern[i])==mp1.end())\\n            {\\n                if(mp2[v[i]]==0){\\n                    mp1[pattern[i]]=v[i];\\n                    mp2[v[i]]++;\\n                }\\n                else\\n                    return false;\\n            }\\n            else\\n            {\\n                if(mp1[pattern[i]]!=v[i])\\n                    return false;\\n                else{\\n                    mp2[v[i]]++;\\n                }\\n            }\\n        }\\n        return true;        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    bool wordPattern(string pattern, string s) {\\n\\t//Store all words of \"string s\" in a Vector of String.\\n        vector<string> v;\\n        string g=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                v.push_back(g);\\n                g.clear();\\n            }\\n            else\\n                g+=s[i];\\n        }\\n        v.push_back(g);\\n        \\n\\t\\t// \"mp1\" for pattern matching and \"mp2\" for the frequency of string.\\n        map<char,string> mp1;\\n        map<string,int> mp2;\\n        \\n        if(pattern.size()!=v.size())\\n            return false;\\n        \\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            if(mp1.find(pattern[i])==mp1.end())\\n            {\\n                if(mp2[v[i]]==0){\\n                    mp1[pattern[i]]=v[i];\\n                    mp2[v[i]]++;\\n                }\\n                else\\n                    return false;\\n            }\\n            else\\n            {\\n                if(mp1[pattern[i]]!=v[i])\\n                    return false;\\n                else{\\n                    mp2[v[i]]++;\\n                }\\n            }\\n        }\\n        return true;        \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1434099,
                "title": "c-0ms-double-mapping-well-commented",
                "content": "I am using two maps, one will map the characters to the words and the other will map the words to the characters. This is necessary because if we just implement the former, we will fail the test case of `pattern = \"abba\"` & `s = \"dog dog dog dog`, because even though a character is not mapped to more than one word, a word is mapped to more than one characters.\\n\\nAlgorithm:\\n* Split the given string into words, and store them in a vector `sHolder`. \\n* If the number of characters is not equal to the number of words, return false.\\n* Map the characters to words. If a character has already been mapped to some other word, return false.\\n* Map the words to characters. If a word has already been mapped to some other character, return false.\\n* If the input passes all the previous checks, that means it is a valid pattern and string. Return true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        map<char, string> pairMapper;   //map characters to string\\n        map<string, char> pairMapper2;  //map the string to characters\\n\\n        // split the words of the given string s\\n        // use sHolder to store those words \\n        // independently\\n        vector<string> sHolder;\\n\\n        int startingIdx = 0;    // starting index of the word\\n        int length = 0;         // the length of the word currently under consideration\\n        for(int i = 0; i<s.size(); i++){\\n            if(s[i] == \\' \\'){    // this marks the end of a word, so that substring into sHolder\\n                sHolder.push_back(s.substr(startingIdx, length));\\n                startingIdx = i + 1;    // move starting index to be at the index next to the space\\n                length = 0;             // reset length to zero\\n            } else {\\n                length++;               // increase length till a space is not encountered\\n            }\\n        }\\n\\n\\t\\t//manually add the last word\\n        sHolder.push_back(s.substr(startingIdx, length));\\n\\n        // if the number of characters is not equal to \\n        // the number of words, return false\\n        if(pattern.size() != sHolder.size()){\\n            return false;\\n        }\\n\\n        // map characters to string\\n        for(int i = 0; i<pattern.size(); i++){\\n    \\t\\t// if character has not been mapped previously, map it\\n            if(pairMapper.find(pattern[i]) == pairMapper.end()){\\n                pairMapper[pattern[i]] = sHolder[i];\\n            } else {\\n\\t    \\t\\t// if the character has already been mapped to a \\n\\t\\t\\t\\t// different word, return false\\n                if(pairMapper[pattern[i]] != sHolder[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        //map strings to the characters\\n        for(int i = 0; i<sHolder.size(); i++){\\n\\t\\t    // if the word has not been mapped previously, map it\\n            if(pairMapper2.find(sHolder[i]) == pairMapper2.end()){\\n                pairMapper2[sHolder[i]] = pattern[i];\\n            } else {\\n\\t\\t\\t    // if the word has already been mapped to a \\n\\t\\t\\t\\t// different character, return false\\n                if(pairMapper2[sHolder[i]] != pattern[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        map<char, string> pairMapper;   //map characters to string\\n        map<string, char> pairMapper2;  //map the string to characters\\n\\n        // split the words of the given string s\\n        // use sHolder to store those words \\n        // independently\\n        vector<string> sHolder;\\n\\n        int startingIdx = 0;    // starting index of the word\\n        int length = 0;         // the length of the word currently under consideration\\n        for(int i = 0; i<s.size(); i++){\\n            if(s[i] == \\' \\'){    // this marks the end of a word, so that substring into sHolder\\n                sHolder.push_back(s.substr(startingIdx, length));\\n                startingIdx = i + 1;    // move starting index to be at the index next to the space\\n                length = 0;             // reset length to zero\\n            } else {\\n                length++;               // increase length till a space is not encountered\\n            }\\n        }\\n\\n\\t\\t//manually add the last word\\n        sHolder.push_back(s.substr(startingIdx, length));\\n\\n        // if the number of characters is not equal to \\n        // the number of words, return false\\n        if(pattern.size() != sHolder.size()){\\n            return false;\\n        }\\n\\n        // map characters to string\\n        for(int i = 0; i<pattern.size(); i++){\\n    \\t\\t// if character has not been mapped previously, map it\\n            if(pairMapper.find(pattern[i]) == pairMapper.end()){\\n                pairMapper[pattern[i]] = sHolder[i];\\n            } else {\\n\\t    \\t\\t// if the character has already been mapped to a \\n\\t\\t\\t\\t// different word, return false\\n                if(pairMapper[pattern[i]] != sHolder[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        //map strings to the characters\\n        for(int i = 0; i<sHolder.size(); i++){\\n\\t\\t    // if the word has not been mapped previously, map it\\n            if(pairMapper2.find(sHolder[i]) == pairMapper2.end()){\\n                pairMapper2[sHolder[i]] = pattern[i];\\n            } else {\\n\\t\\t\\t    // if the word has already been mapped to a \\n\\t\\t\\t\\t// different character, return false\\n                if(pairMapper2[sHolder[i]] != pattern[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834530,
                "title": "python-simple-solution-explained-video-code-96-faster",
                "content": "[](https://www.youtube.com/watch?v=XC0dpyntbyA)\\nhttps://www.youtube.com/watch?v=XC0dpyntbyA\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        words = str.split()\\n        if len(words) != len(pattern):\\n            return False \\n        d = {}\\n        for x in range(len(words)):\\n            if pattern[x] not in d:\\n                if words[x] in d.values():\\n                    return False\\n                d[pattern[x]] = words[x]\\n            else:\\n                if d[pattern[x]] != words[x]:\\n                    return False\\n        return True\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        words = str.split()\\n        if len(words) != len(pattern):\\n            return False \\n        d = {}\\n        for x in range(len(words)):\\n            if pattern[x] not in d:\\n                if words[x] in d.values():\\n                    return False\\n                d[pattern[x]] = words[x]\\n            else:\\n                if d[pattern[x]] != words[x]:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834158,
                "title": "runtime-0-ms-100-faster-c-1-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<char,string> map;\\n     bool ContainsValue(string value)\\n    {\\n    bool found = false;\\n    auto it =map.begin(); \\n    while(it != map.end())\\n    {\\n        found = (it->second == value);\\n        if(found)\\n            break;\\n        ++it;\\n    }\\n    return found;\\n    }\\n    bool wordPattern(string pattern, string str) {\\n        string w;                 \\n\\t\\t//A stringstream associates a string object with a stream allowing you to read from the string as if        it were a stream (like cin).\\n        stringstream ss(str);\\n        vector<string> words; \\n\\n        while (ss >> w)\\n            words.push_back(w);\\n    \\n        if(words.size() != pattern.size()) return false;\\n        for(int i=0;i<pattern.size();i++){\\n            char currchar=pattern[i];\\n            if(map.count(currchar)){\\n                if(map[currchar]!=words[i]) return false;\\n            }\\n            else{\\n                if(ContainsValue(words[i])) return false;\\n                map[currchar]=words[i];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section**.\\nI hope that you\\'ve found the solution useful.\\nIn that case,  **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<char,string> map;\\n     bool ContainsValue(string value)\\n    {\\n    bool found = false;\\n    auto it =map.begin(); \\n    while(it != map.end())\\n    {\\n        found = (it->second == value);\\n        if(found)\\n            break;\\n        ++it;\\n    }\\n    return found;\\n    }\\n    bool wordPattern(string pattern, string str) {\\n        string w;                 \\n\\t\\t//A stringstream associates a string object with a stream allowing you to read from the string as if        it were a stream (like cin).\\n        stringstream ss(str);\\n        vector<string> words; \\n\\n        while (ss >> w)\\n            words.push_back(w);\\n    \\n        if(words.size() != pattern.size()) return false;\\n        for(int i=0;i<pattern.size();i++){\\n            char currchar=pattern[i];\\n            if(map.count(currchar)){\\n                if(map[currchar]!=words[i]) return false;\\n            }\\n            else{\\n                if(ContainsValue(words[i])) return false;\\n                map[currchar]=words[i];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833942,
                "title": "python-2-lines",
                "content": "**Approach:**\\n1. First, split the string into a list of words\\n2. Create 2 hash-sets:\\n\\t* \\t One having words of the string \\n\\t* \\t And other having characters of the given pattern \\n3. Now for the string to follow the same pattern as of given pattern, it should satisfy following conditions: \\n\\t\\n\\t\\t\\t1]  length(pattern) == length(list of words)\\t\\n\\t\\t\\t2]  length(hashset(pattern_characters)) == length(hashset(string_words)) \\n\\t\\t\\t3]  length(hashset(pattern_characters)) == length(hashset(indexWiseMap(pattern_characters, string_words)))\\n\\t\\n**Solution :**\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        str = str.split(\\' \\')\\n        return len(set(pattern)) == len(set(str)) == len(set(zip(pattern, str))) and len(pattern) == len(str)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        str = str.split(\\' \\')\\n        return len(set(pattern)) == len(set(str)) == len(set(zip(pattern, str))) and len(pattern) == len(str)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833907,
                "title": "python-short-and-simple-explained-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        my_dict = {}\\n        words = str.split()\\n        \\n        # pattern is not the same length as list of words:\\n        if len(words) != len(pattern):\\n            return False\\n        \\n        # keep in dictionary each letter in pattern with corresponding word:\\n        for i, p in enumerate(pattern):\\n            if my_dict.get(p):\\n                # found a word that doesn\\'t match previous letter in pattern:\\n                if my_dict.get(p) != words[i]:\\n                    return False\\n            else:\\n                # same letter in pattern for two different words:\\n                if words[i] in my_dict.values():\\n                    return False\\n                my_dict[p] = words[i]\\n                \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        my_dict = {}\\n        words = str.split()\\n        \\n        # pattern is not the same length as list of words:\\n        if len(words) != len(pattern):\\n            return False\\n        \\n        # keep in dictionary each letter in pattern with corresponding word:\\n        for i, p in enumerate(pattern):\\n            if my_dict.get(p):\\n                # found a word that doesn\\'t match previous letter in pattern:\\n                if my_dict.get(p) != words[i]:\\n                    return False\\n            else:\\n                # same letter in pattern for two different words:\\n                if words[i] in my_dict.values():\\n                    return False\\n                my_dict[p] = words[i]\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228074,
                "title": "c-0-ms-100",
                "content": "```\\nbool wordPattern(char* pattern, char* str) {\\n    int strCount = 0;\\n    int patternSize = strlen(pattern);\\n    char** translate = calloc(26, sizeof(char*));\\n    char *token;\\n    \\n    // Seperate the string by space and assign pointer at the beginning of\\n    // each word to the pattern associated table\\n    token = strtok(str, \" \");\\n    while( token != NULL && strCount < patternSize) \\n    {\\n        if(!translate[pattern[strCount] - \\'a\\'])\\n        {\\n            translate[pattern[strCount] - \\'a\\'] = token;\\n        }\\n        else\\n        {\\n            if(strcmp(translate[pattern[strCount] - \\'a\\'], token))\\n            {\\n                return false;\\n            }\\n        }\\n        token = strtok(NULL, \" \");\\n        strCount++;\\n    }\\n    \\n    // If pattern and words have different size return false\\n    if(strCount < patternSize || token != NULL) return false;\\n    \\n    // Check if two character have assigned to the same word\\n    for(int i = 0; i < 25; i++)\\n    {\\n        if(translate[i])\\n        {\\n            //printf(\"%s\\\\n\", translate[i]);\\n            for(int j = i+1; j < 26; j++)\\n            {\\n                if(translate[j])\\n                {\\n                    if(strcmp(translate[i], translate[j]) == 0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n  \\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool wordPattern(char* pattern, char* str) {\\n    int strCount = 0;\\n    int patternSize = strlen(pattern);\\n    char** translate = calloc(26, sizeof(char*));\\n    char *token;\\n    \\n    // Seperate the string by space and assign pointer at the beginning of\\n    // each word to the pattern associated table\\n    token = strtok(str, \" \");\\n    while( token != NULL && strCount < patternSize) \\n    {\\n        if(!translate[pattern[strCount] - \\'a\\'])\\n        {\\n            translate[pattern[strCount] - \\'a\\'] = token;\\n        }\\n        else\\n        {\\n            if(strcmp(translate[pattern[strCount] - \\'a\\'], token))\\n            {\\n                return false;\\n            }\\n        }\\n        token = strtok(NULL, \" \");\\n        strCount++;\\n    }\\n    \\n    // If pattern and words have different size return false\\n    if(strCount < patternSize || token != NULL) return false;\\n    \\n    // Check if two character have assigned to the same word\\n    for(int i = 0; i < 25; i++)\\n    {\\n        if(translate[i])\\n        {\\n            //printf(\"%s\\\\n\", translate[i]);\\n            for(int j = i+1; j < 26; j++)\\n            {\\n                if(translate[j])\\n                {\\n                    if(strcmp(translate[i], translate[j]) == 0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n  \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73394,
                "title": "javascript-solution",
                "content": "```\\nvar wordPattern = function(pattern, str) {\\n    str = str.split(' ');\\n    \\n    if ( str.length != pattern.length) {\\n        return false;\\n    }\\n    \\n    var hash = {};\\n    \\n    for (var i = 0; i < str.length; i++) {\\n        if (hash[pattern[i]]) {\\n            if (hash[pattern[i]] !== str[i]) {\\n                return false;\\n           } \\n        } else {\\n            if (Object.values(hash).indexOf(str[i]) !== -1){\\n                return false;\\n            } else {\\n                 hash[pattern[i]] = str[i];\\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar wordPattern = function(pattern, str) {\\n    str = str.split(' ');\\n    \\n    if ( str.length != pattern.length) {\\n        return false;\\n    }\\n    \\n    var hash = {};\\n    \\n    for (var i = 0; i < str.length; i++) {\\n        if (hash[pattern[i]]) {\\n            if (hash[pattern[i]] !== str[i]) {\\n                return false;\\n           } \\n        } else {\\n            if (Object.values(hash).indexOf(str[i]) !== -1){\\n                return false;\\n            } else {\\n                 hash[pattern[i]] = str[i];\\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206167,
                "title": "check-if-a-string-follows-a-given-pattern-using-a-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem requires checking if a given string follows a certain pattern. To do that, we need to first split the string into words and then check if there is a one-to-one correspondence between the characters in the pattern and the words in the string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a hash map to store the mapping between the characters in the pattern and the corresponding words in the string. We first split the string into words using the `split()` method. We then check if the length of the pattern is the same as the number of words in the string. If not, we can immediately return False, as there cannot be a one-to-one correspondence between the characters in the pattern and the words in the string.\\n\\nWe then iterate through the pattern and the words in the string at the same time using a for loop. For each character in the pattern, we check if it has already been mapped to a word by checking if it is in the keys of the hash map. If it has, we check if the corresponding word in the string matches the previously mapped word by comparing it to the value of the hash map at the key corresponding to the current character in the pattern. If it does not match, we return false. If the character in the pattern has not been mapped yet, we check if the word in the string has already been mapped to another character in the pattern by checking if it is in the values of the hash map. If it has, we return false. If it has not, we create a new mapping between the character in the pattern and the word in the string by adding it to the hash map.\\n\\nAt the end of the for loop, we check if we have iterated through both the pattern and the string at the same time by comparing the value of the loop variable `i` to the length of the pattern. If they are not equal, we return false. Otherwise, we return true.\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the length of the pattern or the number of words in the string, whichever is smaller. We need to iterate through both the pattern and the string, but we only need to iterate up to the length of the shorter one.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(m)$$, where $$m $$ is the number of unique characters in the pattern or the number of unique words in the string, whichever is smaller. We need to store the mapping between the characters in the pattern and the corresponding words in the string in a hash map, which can have at most m entries.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        words = s.split()\\n        if len(pattern) != len(words):\\n            return False\\n        mapping = {}\\n        for i in range(len(pattern)):\\n            if pattern[i] in mapping:\\n                if mapping[pattern[i]] != words[i]:\\n                    return False\\n            else:\\n                if words[i] in mapping.values():\\n                    return False\\n                mapping[pattern[i]] = words[i]\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        words = s.split()\\n        if len(pattern) != len(words):\\n            return False\\n        mapping = {}\\n        for i in range(len(pattern)):\\n            if pattern[i] in mapping:\\n                if mapping[pattern[i]] != words[i]:\\n                    return False\\n            else:\\n                if words[i] in mapping.values():\\n                    return False\\n                mapping[pattern[i]] = words[i]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980786,
                "title": "c-dictionary-method-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool WordPattern(string pattern, string s) {\\n      var dict1 = new Dictionary<char,string>();\\n      var dict2 = new Dictionary<string,char>();\\n      var sList = s.Split(\\' \\', StringSplitOptions.None);\\n\\n      if(pattern.Length != sList.Count()) return false;\\n\\n      for(int i=0;i<sList.Count();i++){\\n        dict1.TryAdd(pattern[i], sList[i]);\\n        dict2.TryAdd(sList[i],pattern[i]);\\n        if(dict1[pattern[i]] != sList[i]) return false;\\n        if(dict2[sList[i]] != pattern[i]) return false;\\n      }\\n      \\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool WordPattern(string pattern, string s) {\\n      var dict1 = new Dictionary<char,string>();\\n      var dict2 = new Dictionary<string,char>();\\n      var sList = s.Split(\\' \\', StringSplitOptions.None);\\n\\n      if(pattern.Length != sList.Count()) return false;\\n\\n      for(int i=0;i<sList.Count();i++){\\n        dict1.TryAdd(pattern[i], sList[i]);\\n        dict2.TryAdd(sList[i],pattern[i]);\\n        if(dict1[pattern[i]] != sList[i]) return false;\\n        if(dict2[sList[i]] != pattern[i]) return false;\\n      }\\n      \\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980320,
                "title": "c-easy-solution-using-map-and-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        int n=pattern.size(),m=s.size();\\n        vector<string> v;\\n        string str;\\n        for(int i=0;i<m;i++){\\n            if(s[i]!=\\' \\'){\\n                str.push_back(s[i]);\\n            }\\n            else{\\n                v.push_back(str);\\n                str=\"\";\\n            }\\n        }\\n        v.push_back(str);\\n        if(v.size()!=n){\\n            return false;\\n        }\\n        map<char,string> hash;\\n        for(int i=0;i<n;i++){\\n            if(hash.find(pattern[i])==hash.end()){\\n                hash[pattern[i]]=v[i];\\n            }\\n            else{\\n                auto it=hash.find(pattern[i]);\\n                if(it->second!=v[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        auto it=hash.begin();\\n        set<string> st;\\n        for(;it!=hash.end();it++){\\n            st.insert(it->second);\\n        }\\n        if(st.size()!=hash.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        int n=pattern.size(),m=s.size();\\n        vector<string> v;\\n        string str;\\n        for(int i=0;i<m;i++){\\n            if(s[i]!=\\' \\'){\\n                str.push_back(s[i]);\\n            }\\n            else{\\n                v.push_back(str);\\n                str=\"\";\\n            }\\n        }\\n        v.push_back(str);\\n        if(v.size()!=n){\\n            return false;\\n        }\\n        map<char,string> hash;\\n        for(int i=0;i<n;i++){\\n            if(hash.find(pattern[i])==hash.end()){\\n                hash[pattern[i]]=v[i];\\n            }\\n            else{\\n                auto it=hash.find(pattern[i]);\\n                if(it->second!=v[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        auto it=hash.begin();\\n        set<string> st;\\n        for(;it!=hash.end();it++){\\n            st.insert(it->second);\\n        }\\n        if(st.size()!=hash.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977852,
                "title": "fast-and-simple-python-solution-with-code-comments",
                "content": "# 290. Word Pattern\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        # Split the string into a list of words\\n        words = s.split()\\n\\n        # Create Counter objects for the pattern, list of words, and list of tuples (pattern character, word)\\n        pattern_counter = Counter(pattern)\\n        words_counter = Counter(words)\\n        pair_counter = Counter(zip(pattern, words))\\n\\n        # Return True if the lengths of the Counter objects and the pattern and list of words are equal\\n        return len(pattern_counter) == len(words_counter) == len(pair_counter) and len(pattern) == len(words)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        # Split the string into a list of words\\n        words = s.split()\\n\\n        # Create Counter objects for the pattern, list of words, and list of tuples (pattern character, word)\\n        pattern_counter = Counter(pattern)\\n        words_counter = Counter(words)\\n        pair_counter = Counter(zip(pattern, words))\\n\\n        # Return True if the lengths of the Counter objects and the pattern and list of words are equal\\n        return len(pattern_counter) == len(words_counter) == len(pair_counter) and len(pattern) == len(words)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976948,
                "title": "python-3-lines-check-one-to-one-relationship",
                "content": "# Complexity\\n- Time complexity:\\n    $$O(n)$$\\n- Space complexity:\\n    $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ls = s.split()\\n        k, v, p = Counter(pattern), Counter(ls), Counter(zip(pattern, ls))\\n        return len(k) == len(v) == len(p) and len(pattern) == len(ls)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ls = s.split()\\n        k, v, p = Counter(pattern), Counter(ls), Counter(zip(pattern, ls))\\n        return len(k) == len(v) == len(p) and len(pattern) == len(ls)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912814,
                "title": "simple-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} pattern\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar wordPattern = function(pattern, s) {\\n    s = s.split(\\' \\')\\n    //edge cases:\\n    if (pattern.length !== s.length) return false;\\n    if (new Set(pattern).size !== new Set(s).size) return false;\\n\\n    let map = new Map()\\n    for (let i = 0; i < pattern.length; i++) {\\n        if (!map.has(pattern[i])) {\\n            map.set(pattern[i], s[i])\\n        }\\n\\n        if (s[i] !== map.get(pattern[i])) return false;\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {string} pattern\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar wordPattern = function(pattern, s) {\\n    s = s.split(\\' \\')\\n    //edge cases:\\n    if (pattern.length !== s.length) return false;\\n    if (new Set(pattern).size !== new Set(s).size) return false;\\n\\n    let map = new Map()\\n    for (let i = 0; i < pattern.length; i++) {\\n        if (!map.has(pattern[i])) {\\n            map.set(pattern[i], s[i])\\n        }\\n\\n        if (s[i] !== map.get(pattern[i])) return false;\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697654,
                "title": "3-cases-explained-properly-in-c-but-it-s-not-like-easy-it-s-medium-with-some-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n  \\n        string s3=\"\";\\n        vector<string>v;\\n        s+=\\' \\';\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\' )\\n            {\\n                v.push_back(s3);\\n                s3=\"\";\\n            }\\n            else\\n            {\\n                s3+=s[i];\\n            }\\n        }\\n\\n        \\n        if(v.size()!=pattern.length())\\n        {\\n            return false;\\n        }\\n         \\n        map<char,string>mp;\\n   \\n        set<string>ch;\\n        \\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            // 1.   if it\\'s not in  both\\n            // 2.   if it\\'s in another and came again\\n            // 3.   if it\\'s present and isn\\'t equal to previous one then\\n            \\n            if(mp.count(pattern[i])==0 && ch.count(v[i])==0)\\n            {\\n                mp[pattern[i]]=v[i];\\n                ch.insert(v[i]);\\n            }\\n            else if(mp.count(pattern[i])==0 && ch.count(v[i])!=0)\\n            {\\n                return false;\\n            }\\n            else if(mp[pattern[i]]!=v[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n  \\n        string s3=\"\";\\n        vector<string>v;\\n        s+=\\' \\';\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\' )\\n            {\\n                v.push_back(s3);\\n                s3=\"\";\\n            }\\n            else\\n            {\\n                s3+=s[i];\\n            }\\n        }\\n\\n        \\n        if(v.size()!=pattern.length())\\n        {\\n            return false;\\n        }\\n         \\n        map<char,string>mp;\\n   \\n        set<string>ch;\\n        \\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            // 1.   if it\\'s not in  both\\n            // 2.   if it\\'s in another and came again\\n            // 3.   if it\\'s present and isn\\'t equal to previous one then\\n            \\n            if(mp.count(pattern[i])==0 && ch.count(v[i])==0)\\n            {\\n                mp[pattern[i]]=v[i];\\n                ch.insert(v[i]);\\n            }\\n            else if(mp.count(pattern[i])==0 && ch.count(v[i])!=0)\\n            {\\n                return false;\\n            }\\n            else if(mp[pattern[i]]!=v[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696849,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn word_pattern(pattern: String, s: String) -> bool {\\n        use std::collections::{HashMap, HashSet};\\n\\n        if pattern.len() != s.matches(\\' \\').count() + 1 {\\n            return false;\\n        }\\n        let mut hm = HashMap::new();\\n        let mut word_set = HashSet::new();\\n\\n        for (word, c) in s.split_ascii_whitespace().zip(pattern.chars()) {\\n            if let Some(w) = hm.insert(c, word) {\\n                if w != word {\\n                    return false;\\n                }\\n            } else if !word_set.insert(word) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "String"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn word_pattern(pattern: String, s: String) -> bool {\\n        use std::collections::{HashMap, HashSet};\\n\\n        if pattern.len() != s.matches(\\' \\').count() + 1 {\\n            return false;\\n        }\\n        let mut hm = HashMap::new();\\n        let mut word_set = HashSet::new();\\n\\n        for (word, c) in s.split_ascii_whitespace().zip(pattern.chars()) {\\n            if let Some(w) = hm.insert(c, word) {\\n                if w != word {\\n                    return false;\\n                }\\n            } else if !word_set.insert(word) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696094,
                "title": "c-map-stl-0-ms-faster-than-100-00",
                "content": "*Please **upvote** if you find it helpful :)*\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        int words=0;\\n        for(int i=0;s[i];i++)\\n            if(s[i]==\\' \\')\\n                words++;\\n        words+=1;\\n        if(words!=pattern.length())\\n            return false;\\n        unordered_map<char, string> mp;          // letter to word\\n        unordered_map<string, char> mp2;       // word to letter\\n        vector<string> v;\\n        string s1=\"\";\\n        for(int i=0;s[i];i++) {\\n            if(s[i]!=\\' \\') {\\n                s1+=s[i];\\n            }\\n            else {\\n                v.push_back(s1);\\n                s1=\"\";\\n            }\\n        }\\n        v.push_back(s1);\\n        for(int i=0;pattern[i];i++) {\\n            if(mp.find(pattern[i])==mp.end() && mp2.find(v[i])==mp2.end()) {\\n                mp[pattern[i]] = v[i];\\n                mp2[v[i]] = pattern[i];\\n            }\\n            else if(mp2.find(v[i])!=mp2.end() && mp.find(pattern[i])!=mp.end()) {\\n                if(mp[pattern[i]]!=v[i])\\n                    return false;\\n                if(mp2[v[i]]!=pattern[i])\\n                    return false;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        int words=0;\\n        for(int i=0;s[i];i++)\\n            if(s[i]==\\' \\')\\n                words++;\\n        words+=1;\\n        if(words!=pattern.length())\\n            return false;\\n        unordered_map<char, string> mp;          // letter to word\\n        unordered_map<string, char> mp2;       // word to letter\\n        vector<string> v;\\n        string s1=\"\";\\n        for(int i=0;s[i];i++) {\\n            if(s[i]!=\\' \\') {\\n                s1+=s[i];\\n            }\\n            else {\\n                v.push_back(s1);\\n                s1=\"\";\\n            }\\n        }\\n        v.push_back(s1);\\n        for(int i=0;pattern[i];i++) {\\n            if(mp.find(pattern[i])==mp.end() && mp2.find(v[i])==mp2.end()) {\\n                mp[pattern[i]] = v[i];\\n                mp2[v[i]] = pattern[i];\\n            }\\n            else if(mp2.find(v[i])!=mp2.end() && mp.find(pattern[i])!=mp.end()) {\\n                if(mp[pattern[i]]!=v[i])\\n                    return false;\\n                if(mp2[v[i]]!=pattern[i])\\n                    return false;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330482,
                "title": "simple-c-solution-using-two-maps-0ms",
                "content": "```\\nbool wordPattern(string pattern, string s) {\\n        vector<string> v;\\n        string p;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(p);\\n                p.clear();\\n            }else{\\n                p.push_back(s[i]);\\n            }\\n        }\\n        v.push_back(p);\\n        \\n        if(pattern.length()!=v.size()){\\n            return false;\\n        }\\n        unordered_map<char,string> mp1;\\n        unordered_map<string,char> mp2;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mp1[pattern[i]] == \"\" && mp2[v[i]] == 0){\\n                mp1[pattern[i]]=v[i];\\n                mp2[v[i]]=pattern[i];\\n            }else if(v[i]!=mp1[pattern[i]] || pattern[i]!=mp2[v[i]]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool wordPattern(string pattern, string s) {\\n        vector<string> v;\\n        string p;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(p);\\n                p.clear();\\n            }else{\\n                p.push_back(s[i]);\\n            }\\n        }\\n        v.push_back(p);\\n        \\n        if(pattern.length()!=v.size()){\\n            return false;\\n        }\\n        unordered_map<char,string> mp1;\\n        unordered_map<string,char> mp2;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mp1[pattern[i]] == \"\" && mp2[v[i]] == 0){\\n                mp1[pattern[i]]=v[i];\\n                mp2[v[i]]=pattern[i];\\n            }else if(v[i]!=mp1[pattern[i]] || pattern[i]!=mp2[v[i]]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265439,
                "title": "0-ms-c-solution",
                "content": "I have first converted **string s** to **vector of strings** and then using double map compared \\nif they are mapping of character in pattern matches to a string and no two characters point to same string or no to string point to same character.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> st;\\n        \\n        string k;\\n        int i,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]-0==32)\\n            {\\n                st.push_back(k);\\n                \\n                k.clear();\\n            }\\n            else\\n            {\\n                k.push_back(s[i]);\\n            }\\n        }\\n        st.push_back(k);\\n        k.clear();\\n        \\n        unordered_map<char,string> mp;\\n        unordered_map<string,char> mp2;\\n        n=pattern.size();\\n        if(n!=st.size())\\n            return false;\\n        for(i=0;i<n;i++)\\n        {\\n            if(mp.find(pattern[i])==mp.end())\\n            {\\n                mp.insert({pattern[i],st[i]});\\n            }\\n            else\\n            {\\n                auto it=mp.find(pattern[i]);\\n                if(it->second!=st[i])\\n                    return false;\\n            }\\n            if(mp2.find(st[i])==mp2.end())\\n            {\\n                mp2.insert({st[i],pattern[i]});\\n            }\\n            else\\n            {\\n                auto it=mp2.find(st[i]);\\n                if(it->second!=pattern[i])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> st;\\n        \\n        string k;\\n        int i,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]-0==32)\\n            {\\n                st.push_back(k);\\n                \\n                k.clear();\\n            }\\n            else\\n            {\\n                k.push_back(s[i]);\\n            }\\n        }\\n        st.push_back(k);\\n        k.clear();\\n        \\n        unordered_map<char,string> mp;\\n        unordered_map<string,char> mp2;\\n        n=pattern.size();\\n        if(n!=st.size())\\n            return false;\\n        for(i=0;i<n;i++)\\n        {\\n            if(mp.find(pattern[i])==mp.end())\\n            {\\n                mp.insert({pattern[i],st[i]});\\n            }\\n            else\\n            {\\n                auto it=mp.find(pattern[i]);\\n                if(it->second!=st[i])\\n                    return false;\\n            }\\n            if(mp2.find(st[i])==mp2.end())\\n            {\\n                mp2.insert({st[i],pattern[i]});\\n            }\\n            else\\n            {\\n                auto it=mp2.find(st[i]);\\n                if(it->second!=pattern[i])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928202,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        def convert(words: List[str]) -> List[str]:\\n            i, d = 0, {}\\n            for word in words:\\n                if word not in d:\\n                    d[word] = i\\n                    i += 1\\n            return [d[word] for word in words]\\n\\n        return convert(list(pattern)) == convert(s.split())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        def convert(words: List[str]) -> List[str]:\\n            i, d = 0, {}\\n            for word in words:\\n                if word not in d:\\n                    d[word] = i\\n                    i += 1\\n            return [d[word] for word in words]\\n\\n        return convert(list(pattern)) == convert(s.split())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893874,
                "title": "java-solution-clean-code-with-full-comments-minimal-use-of-library",
                "content": "```\\nclass Solution \\n{\\n    public boolean wordPattern(String pattern, String str) \\n    {\\n        String[] words = str.split(\" \"); // Use java  library method split() to turn String str into string array- words.\\n        \\n        char[] ch = new char[pattern.length()]; // Set characters array- ch that match String pattern length().\\n        \\n        for(int i = 0; i < pattern.length(); i++) // Load pattern characters into ch thus making char array without java  library.\\n        {\\n            ch[i] = pattern.charAt(i);\\n        }\\n      \\n        if(ch.length != words.length) // Check the lengths of the two arrays, if they are not equals return false.\\n        {\\n            return false;\\n        }\\n          HashMap <Character, String> map = new HashMap(); // Set HashMap so we can assign characters from ch array to be keys of values from the words array.\\n       \\n        for(int i = 0; i < words.length; i++) // Move through words length, (that are the same length of ch)!\\n        {\\n            char Character = ch[i]; // For better readability, mark the elements of the arrays.\\n            String word = words[i];\\n            \\n            if(!map.containsKey(Character) && !map.containsValue(word)) // If both the key and the value does not exist, create them.\\n            {\\n                map.put(Character, word);\\n            }\\n            \\n            if((!map.containsKey(Character) && map.containsValue(word)) || (!map.get(Character).equals(word))) // If by any chance the key does not exist but the value does, or when we check if the character equals to the assign value we get false, thats mean that we got unmatching keys or values.\\n            {\\n                return false;\\n            }\\n        }\\n        return true;    \\n\\t\\t\\n    } // Runtime: 1 ms, faster than 44.69% of Java online submissions for Word Pattern.\\n      //Memory Usage: 36.9 MB, less than 6.17% of Java online submissions for Word Pattern.\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public boolean wordPattern(String pattern, String str) \\n    {\\n        String[] words = str.split(\" \"); // Use java  library method split() to turn String str into string array- words.\\n        \\n        char[] ch = new char[pattern.length()]; // Set characters array- ch that match String pattern length().\\n        \\n        for(int i = 0; i < pattern.length(); i++) // Load pattern characters into ch thus making char array without java  library.\\n        {\\n            ch[i] = pattern.charAt(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 839393,
                "title": "java-beats-100-easy-understanding",
                "content": "Java is **God Language** for HashMap\\n\\nIdea is simple.\\n\\n1. Split str into array of string named strs\\n\\n2. map a,b,c with string from strs.\\na->dog\\nb->cat\\nc->fish\\n\\n3. if a,b,c repeats then compare the string from map and string from strs, if it not equal return false.\\n\\n4. else a,b,c is appearing first time, check if the string from strs is previously associated with any a,b,c , yes then return false, else map it.\\n```\\n String[] strs = str.split(\" \");\\n        HashMap<Character,String> map = new HashMap<Character,String>();\\n        if(strs.length != pattern.length())\\n        {\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++)\\n        {\\n            char c = pattern.charAt(i);\\n            if(map.containsKey(c))\\n            {\\n                if(!map.get(c).equals(strs[i]))\\n                    return false;\\n            }\\n            else\\n            {\\n                if(map.containsValue(strs[i]))\\n                    return false;\\n                map.put(c,strs[i]);\\n            }\\n        }\\n        return true;\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n String[] strs = str.split(\" \");\\n        HashMap<Character,String> map = new HashMap<Character,String>();\\n        if(strs.length != pattern.length())\\n        {\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++)\\n        {\\n            char c = pattern.charAt(i);\\n            if(map.containsKey(c))\\n            {\\n                if(!map.get(c).equals(strs[i]))\\n                    return false;\\n            }\\n            else\\n            {\\n                if(map.containsValue(strs[i]))\\n                    return false;\\n                map.put(c,strs[i]);\\n            }\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765243,
                "title": "java-0ms-using-hashmap",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n     String arr[] = s.split(\" \");\\n     if(pattern.length() != arr.length) return false;\\n     Map<Character, String> map = new HashMap<>();\\n     for(int i = 0; i < pattern.length(); i ++) {\\n         char ch = pattern.charAt(i);\\n         boolean containsKey = map.containsKey(ch);\\n         if(map.containsValue(arr[i]) && !containsKey) return false;\\n         if(containsKey && !map.get(ch).equals(arr[i]))return false;\\n         else map.put(ch, arr[i]);\\n     }  \\n     return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n     String arr[] = s.split(\" \");\\n     if(pattern.length() != arr.length) return false;\\n     Map<Character, String> map = new HashMap<>();\\n     for(int i = 0; i < pattern.length(); i ++) {\\n         char ch = pattern.charAt(i);\\n         boolean containsKey = map.containsKey(ch);\\n         if(map.containsValue(arr[i]) && !containsKey) return false;\\n         if(containsKey && !map.get(ch).equals(arr[i]))return false;\\n         else map.put(ch, arr[i]);\\n     }  \\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412107,
                "title": "typescript-javascript-o-n-solution-map",
                "content": "* Time Complexity: O(n)\\n * Space Complexity: O(n)\\n# Code\\n```\\nfunction wordPattern(pattern: string, s: string): boolean {\\n    const patternMap: Map<string, number> = new Map<string, number>();\\n    const sMap: Map<string, number> = new Map<string, number>(); \\n    \\n    // Split the string \\'s\\' into an array of words\\n    const splitS = s.split(\" \");\\n\\n    // If the lengths of \\'pattern\\' and \\'splitS\\' are not equal, then patter can not match.\\n    if (pattern.length !== splitS.length) return false;\\n\\n    // We give each character in pattern a unique id which is the index\\n    // and we give also each word in sSplit the same index.\\n\\n    for (let i = 0; i < pattern.length; i++) {\\n        if (!patternMap.has(pattern[i])) patternMap.set(pattern[i], i);\\n        if (!sMap.has(splitS[i])) sMap.set(splitS[i], i);\\n    }\\n\\n    // By comparing the indices we can easily \\n    // see whether s matches the pattern\\n    // pattern = \"abba\", s = \"dog cat cat dog\"\\n    // patternMap = {a:0,b:1}\\n    // sMap = {dog:0,cat:1}\\n    for (let i = 0; i < pattern.length; i++) {\\n        if (sMap.get(splitS[i]) !== patternMap.get(pattern[i])) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction wordPattern(pattern: string, s: string): boolean {\\n    const patternMap: Map<string, number> = new Map<string, number>();\\n    const sMap: Map<string, number> = new Map<string, number>(); \\n    \\n    // Split the string \\'s\\' into an array of words\\n    const splitS = s.split(\" \");\\n\\n    // If the lengths of \\'pattern\\' and \\'splitS\\' are not equal, then patter can not match.\\n    if (pattern.length !== splitS.length) return false;\\n\\n    // We give each character in pattern a unique id which is the index\\n    // and we give also each word in sSplit the same index.\\n\\n    for (let i = 0; i < pattern.length; i++) {\\n        if (!patternMap.has(pattern[i])) patternMap.set(pattern[i], i);\\n        if (!sMap.has(splitS[i])) sMap.set(splitS[i], i);\\n    }\\n\\n    // By comparing the indices we can easily \\n    // see whether s matches the pattern\\n    // pattern = \"abba\", s = \"dog cat cat dog\"\\n    // patternMap = {a:0,b:1}\\n    // sMap = {dog:0,cat:1}\\n    for (let i = 0; i < pattern.length; i++) {\\n        if (sMap.get(splitS[i]) !== patternMap.get(pattern[i])) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328326,
                "title": "0ms-beats-100-solution-java-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBefore diving  into problem lets first understand what does Bijection in the question actually mean:\\n\\n\\n\\n![bijective-function-1629606712-removebg-preview.jpg](https://assets.leetcode.com/users/images/410a3ddc-7746-419d-8477-4d645df681dd_1679482490.1344478.jpeg)\\n\\nlets take a string : \" **abbc** \"\\npattern : \"dog cat cat dog\"\\n\\nAbove stated input voilates bijection since both **a** and **c** are mapping to same value **dog**\\n\\nwith using hashmap alone in this case we can only know if all **a\\'s**\\nare mapping to **dog\\'s** but it becomes difficult to track if dog is used by another key.\\n\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. split the given pattren at whitespace(\" \")\\n2. traverse the string from start and we will end up with 2 cases\\n- **element is not in hashmap** - > we shall put the character(key) in hashmap if the corresponding value in pattren array is not present in hashset else we return false if not we put the value in hashset.\\n- **element is in hashmap** - > we check if given key in hashmap if it matches with corresponding value in pattren array if it dosent then we simpy return false.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattren, String s) {\\n        HashSet<String> hs=new HashSet<>();\\n        HashMap<Character,String> hm=new HashMap<>();\\n        String arr[]=s.trim().split(\" \");\\n        if(arr.length!=pattren.length())\\n        return false;\\n        for(int i=0;i<pattren.length();i++)\\n        {\\n            char temp=pattren.charAt(i);\\n            if(hm.containsKey(temp))\\n            {\\n                if(hm.get(temp).equals(arr[i]))\\n                {\\n\\n                }\\n                else\\n                {\\n                   return false;\\n                   \\n                }\\n            }\\n            else{\\n                if(hs.contains(arr[i]))\\n                return false;\\n\\n             hm.put(temp,arr[i]);\\n             hs.add(arr[i]);\\n\\n             }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattren, String s) {\\n        HashSet<String> hs=new HashSet<>();\\n        HashMap<Character,String> hm=new HashMap<>();\\n        String arr[]=s.trim().split(\" \");\\n        if(arr.length!=pattren.length())\\n        return false;\\n        for(int i=0;i<pattren.length();i++)\\n        {\\n            char temp=pattren.charAt(i);\\n            if(hm.containsKey(temp))\\n            {\\n                if(hm.get(temp).equals(arr[i]))\\n                {\\n\\n                }\\n                else\\n                {\\n                   return false;\\n                   \\n                }\\n            }\\n            else{\\n                if(hs.contains(arr[i]))\\n                return false;\\n\\n             hm.put(temp,arr[i]);\\n             hs.add(arr[i]);\\n\\n             }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160922,
                "title": "python-clean-one-dictionnary-solution",
                "content": "#### \\u2705 Upvote if it helps!\\n\\n# Code\\n```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        equivalence = {}\\n\\n        words = s.split()\\n        if len(pattern) != len(words): return False # 0\\n\\n        for p, word in zip(pattern, words):\\n            if p in equivalence: \\n                if word != equivalence[p]: # 1\\n                    return False\\n            elif word in equivalence.values(): # 2\\n                    return False\\n            else:\\n                equivalence[p] = word # 3\\n        return True\\n            \\n```\\n\\n# Explanations\\n<!-- Describe your approach to solving the problem. -->\\n- ```equivalence``` is a dictionnary that associates a character of the ```pattern``` to the corresponding word in ```s```.\\n- ```# 0```: First, if ```len(pattern) != len(words)``` it means that ```s``` cannot follow the ```pattern```.\\n- Then we have to check the equivalence for each word:\\n    - ```# 1```: We have to check if a character in ```pattern``` is associated to 2 different words.\\n    - ```# 2```: But we also have to check if a same word is associated to 2 different characters in ```pattern```.\\n        - Example: ```pattern = \"abba\"``` and ```s = \"dog dog dog dog\"```.\\n        - An option is also to have 2 dictionnares but it\\'s not an optmal solution.\\n    - ```# 3```: We also have to keep updated the dictionnary if there are no problems.    \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        equivalence = {}\\n\\n        words = s.split()\\n        if len(pattern) != len(words): return False # 0\\n\\n        for p, word in zip(pattern, words):\\n            if p in equivalence: \\n                if word != equivalence[p]: # 1\\n                    return False\\n            elif word in equivalence.values(): # 2\\n                    return False\\n            else:\\n                equivalence[p] = word # 3\\n        return True\\n            \\n```\n```equivalence```\n```pattern```\n```s```\n```# 0```\n```len(pattern) != len(words)```\n```s```\n```pattern```\n```# 1```\n```pattern```\n```# 2```\n```pattern```\n```pattern = \"abba\"```\n```s = \"dog dog dog dog\"```\n```# 3```",
                "codeTag": "Java"
            },
            {
                "id": 2987914,
                "title": "simple-map-c-easy-appraoch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply take two maps and set each character of pattern string to a value and similarly set each word of string s to same value and then check if two sequences generated are same or not\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        map<char,int>mp1;\\n        map<string ,int>mp2;\\n        int n=s.size(),m=p.size();\\n        //int j=0;\\n        int i=0,j=0;\\n        int k=1,k2=1;\\n        vector<int>v,v2;\\n        while(i<n and j<m){\\n            string w;\\n            while(i<n and s[i]!=\\' \\')w+=s[i++];\\n            i++;\\n            if(mp1[p[j]]==0)v.push_back(k),mp1[p[j]]=k++;\\n            else v.push_back(mp1[p[j]]);\\n             if(mp2[w]==0)v2.push_back(k2),mp2[w]=k2++;\\n            else v2.push_back(mp2[w]);\\n         j++;\\n        }\\n        if(j<m or i<n)return false;\\n        if(v==v2)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        map<char,int>mp1;\\n        map<string ,int>mp2;\\n        int n=s.size(),m=p.size();\\n        //int j=0;\\n        int i=0,j=0;\\n        int k=1,k2=1;\\n        vector<int>v,v2;\\n        while(i<n and j<m){\\n            string w;\\n            while(i<n and s[i]!=\\' \\')w+=s[i++];\\n            i++;\\n            if(mp1[p[j]]==0)v.push_back(k),mp1[p[j]]=k++;\\n            else v.push_back(mp1[p[j]]);\\n             if(mp2[w]==0)v2.push_back(k2),mp2[w]=k2++;\\n            else v2.push_back(mp2[w]);\\n         j++;\\n        }\\n        if(j<m or i<n)return false;\\n        if(v==v2)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981111,
                "title": "c-easy-code-easy-to-implement-easy-to-implement-using-map-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n As we are using a for loop, inside the for loop we are using a find function which takes O(n) to excute.So overall $$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        int n=strlen(&s[0]);\\n        map<char,string>m1;\\n        map<string,char> m2;\\n        vector<string> v;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n            }\\n        }\\n       \\n        v.push_back(str);\\n        if(p.size()!=v.size()){\\n            return false;}\\n        for(int i=0;i<strlen(&p[0]);i++){\\n            if(m1.find(p[i])==m1.end()&&m2.find(v[i])==m2.end()){\\n                m1[p[i]]=v[i];\\n                m2[v[i]]=p[i];\\n            }\\n            else{\\n                if(m1[p[i]]!=v[i]||m2[v[i]]!=p[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n\\nreturn true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        int n=strlen(&s[0]);\\n        map<char,string>m1;\\n        map<string,char> m2;\\n        vector<string> v;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n            }\\n        }\\n       \\n        v.push_back(str);\\n        if(p.size()!=v.size()){\\n            return false;}\\n        for(int i=0;i<strlen(&p[0]);i++){\\n            if(m1.find(p[i])==m1.end()&&m2.find(v[i])==m2.end()){\\n                m1[p[i]]=v[i];\\n                m2[v[i]]=p[i];\\n            }\\n            else{\\n                if(m1[p[i]]!=v[i]||m2[v[i]]!=p[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n\\nreturn true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980855,
                "title": "javascript-o-n-solution-beats-99-using-objects-well-commented",
                "content": "\\n# Code\\n```\\nvar wordPattern = function(pattern, s) {\\n    let obj = {};\\n    s = s.split(\" \"); // converting string to array\\n    if(pattern.length !== s.length) return false;\\n\\n    for(let i=0; i<pattern.length; i++){\\n        if(obj[pattern[i]]===undefined) obj[pattern[i]] = s[i];\\n            // declaring values for every symbol (pattern)\\n        else if (obj[pattern[i]]!==s[i]) return false\\n            // if the new value does not matches its last value (symbol\\'s) previous value.\\n    }\\n    // the other way round\\n    let obj2 = {};\\n    for(let i=0; i<pattern.length; i++){\\n        if(obj2[s[i]]===undefined) obj2[s[i]] = pattern[i];\\n            // declaring symbols for every value \\n        else if (obj2[s[i]]!==pattern[i]) return false\\n            // if the new symbol does not matches its symbol (word\\'s) \\n    }\\n    return true\\n};\\n```\\n## Upvotes will be appreciated.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar wordPattern = function(pattern, s) {\\n    let obj = {};\\n    s = s.split(\" \"); // converting string to array\\n    if(pattern.length !== s.length) return false;\\n\\n    for(let i=0; i<pattern.length; i++){\\n        if(obj[pattern[i]]===undefined) obj[pattern[i]] = s[i];\\n            // declaring values for every symbol (pattern)\\n        else if (obj[pattern[i]]!==s[i]) return false\\n            // if the new value does not matches its last value (symbol\\'s) previous value.\\n    }\\n    // the other way round\\n    let obj2 = {};\\n    for(let i=0; i<pattern.length; i++){\\n        if(obj2[s[i]]===undefined) obj2[s[i]] = pattern[i];\\n            // declaring symbols for every value \\n        else if (obj2[s[i]]!==pattern[i]) return false\\n            // if the new symbol does not matches its symbol (word\\'s) \\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2980732,
                "title": "c-100-faster-double-map-easy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> vect;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vect.push_back(str);\\n                str = \"\";\\n            }else{\\n                str += s[i];\\n            }\\n        }\\n        vect.push_back(str);\\n\\n        map<string,char> reverseMap;\\n        map<char,string> map;\\n        \\n        if(pattern.length() != vect.size())\\n            return false;\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            if(map.count(pattern[i]) && map[pattern[i]] != vect[i]){\\n                return false;\\n            }\\n            if(reverseMap.count(vect[i]) && reverseMap[vect[i]] != pattern[i]){\\n                return false;\\n            }\\n            map.insert(pair<char,string>(pattern[i],vect[i]));\\n            reverseMap.insert(pair<string,char>(vect[i],pattern[i]));\\n        }\\n        // for(int i=0;i<vect.size();i++){\\n        //     cout<<vect[i]<<endl;\\n        // }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> vect;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vect.push_back(str);\\n                str = \"\";\\n            }else{\\n                str += s[i];\\n            }\\n        }\\n        vect.push_back(str);\\n\\n        map<string,char> reverseMap;\\n        map<char,string> map;\\n        \\n        if(pattern.length() != vect.size())\\n            return false;\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            if(map.count(pattern[i]) && map[pattern[i]] != vect[i]){\\n                return false;\\n            }\\n            if(reverseMap.count(vect[i]) && reverseMap[vect[i]] != pattern[i]){\\n                return false;\\n            }\\n            map.insert(pair<char,string>(pattern[i],vect[i]));\\n            reverseMap.insert(pair<string,char>(vect[i],pattern[i]));\\n        }\\n        // for(int i=0;i<vect.size();i++){\\n        //     cout<<vect[i]<<endl;\\n        // }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2980267,
                "title": "c-python-hashmap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First simply split the string s containing words to a vector/array of words. \\n\\n- Using two maps to map characters in pattern to words in vector/array and vice-versa.\\n\\n- Then again check if it is still same after iterating through the whole string pattern.\\n\\n# Complexity\\n- Time complexity:O(n) -> n == s.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n\\nCPP / C++\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> res;\\n        string temp = \"\";\\n        for(int i=0; i<s.length(); i++) {\\n            if( s[i] == \\' \\' ) {\\n                res.push_back(temp);\\n                temp = \"\";\\n                continue;\\n            }\\n            temp += s[i];\\n        }\\n        res.push_back(temp);\\n\\n        if( res.size() != pattern.length() ) return false;\\n    \\n        unordered_map<char, string> m1;\\n        unordered_map<string, char> m2;\\n\\n        for(int i=0; i<pattern.length(); i++) {\\n            m1[ pattern[i] ] = res[i];\\n            m2[ res[i] ] = pattern[i];\\n        }\\n\\n        for(int i=0; i<pattern.length(); i++) {\\n            if( m1[ pattern[i] ] != res[i] || m2[ res[i] ] != pattern[i] ) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n---\\n\\nPYTHON\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        res = []\\n        temp = \"\"\\n        for i in s:\\n            if( i == \" \" ):\\n                res.append(temp)\\n                temp = \"\"\\n                continue\\n            temp += i\\n        res.append(temp)\\n\\n        if( len(pattern) != len(res) ): return False\\n        m ,n = {}, {}\\n        for i,j in zip(pattern, res):\\n            m[i] = j\\n            n[j] = i\\n        \\n        for i,j in zip(pattern, res):\\n            if m[i] != j or n[j] != i:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> res;\\n        string temp = \"\";\\n        for(int i=0; i<s.length(); i++) {\\n            if( s[i] == \\' \\' ) {\\n                res.push_back(temp);\\n                temp = \"\";\\n                continue;\\n            }\\n            temp += s[i];\\n        }\\n        res.push_back(temp);\\n\\n        if( res.size() != pattern.length() ) return false;\\n    \\n        unordered_map<char, string> m1;\\n        unordered_map<string, char> m2;\\n\\n        for(int i=0; i<pattern.length(); i++) {\\n            m1[ pattern[i] ] = res[i];\\n            m2[ res[i] ] = pattern[i];\\n        }\\n\\n        for(int i=0; i<pattern.length(); i++) {\\n            if( m1[ pattern[i] ] != res[i] || m2[ res[i] ] != pattern[i] ) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        res = []\\n        temp = \"\"\\n        for i in s:\\n            if( i == \" \" ):\\n                res.append(temp)\\n                temp = \"\"\\n                continue\\n            temp += i\\n        res.append(temp)\\n\\n        if( len(pattern) != len(res) ): return False\\n        m ,n = {}, {}\\n        for i,j in zip(pattern, res):\\n            m[i] = j\\n            n[j] = i\\n        \\n        for i,j in zip(pattern, res):\\n            if m[i] != j or n[j] != i:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978985,
                "title": "simple-c-solution-with-explanation-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking you to determine whether the string s follows the same pattern as the string pattern. This means that for each character in pattern, there is a corresponding non-empty word in s, and for each non-empty word in s, there is a corresponding character in pattern.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCode checks whether the given pattern string and s string follow the same pattern. It does this by creating two unordered maps: umap and umap2. umap maps characters in pattern to words in s, and umap2 maps words in s to characters in pattern.\\n\\nThe code then iterates through each character in pattern, and for each character, it extracts the corresponding word from s. It does this by reading characters from s until it reaches a space or the end of s. The extracted word is then stored in the variable word.\\n\\nThe code then checks whether the character is already in umap. If it is not, it adds the character and the corresponding word to both umap and umap2. If the character is already in umap, it checks whether the stored word in umap for that character is the same as the extracted word. If they are not the same, the function returns false. If they are the same, the function checks whether the stored character in umap2 for the word is the same as the current character. If they are not the same, the function returns false.\\n\\nFinally, the code checks whether all of the characters in s have been processed. If there are any characters in s that have not been processed, the function returns false. If all characters in both pattern and s have been processed and all checks have passed, the function returns true.\\n# Complexity\\nThe time complexity of this code is O(n), where n is the length of the pattern string. This is because the code processes each character in pattern once.\\n\\nThe space complexity of this code is also O(n), because the code stores all of the characters in pattern and all of the words in s in the two unordered maps. The size of the unordered maps is proportional to the size of the input, so the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define debug(x) cout<<#x<<\":\"<<x<<endl;\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char,string> umap;\\n        unordered_map<string,char> umap2;\\n        int j = 0;\\n        for(int i = 0; i < pattern.size(); i++){\\n            char ch = pattern[i];\\n            string word = \"\";\\n            if(j >= s.size()) return false;\\n            while(j < s.size() && s[j] != \\' \\'){\\n                word += s[j];\\n                j++;\\n            }\\n            j++;\\n            if(umap.count(ch) == 0){\\n                umap[ch] = word;\\n                if(umap2.count(word) != 0){\\n                    return false;\\n                }\\n                umap2[word] = ch;\\n            }else{\\n                if(umap[ch] == word){\\n                    // pass\\n                    if(umap2[word] == ch){\\n                        // pass\\n                    }else{\\n                        return false;\\n                    }\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(j < s.size()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define debug(x) cout<<#x<<\":\"<<x<<endl;\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char,string> umap;\\n        unordered_map<string,char> umap2;\\n        int j = 0;\\n        for(int i = 0; i < pattern.size(); i++){\\n            char ch = pattern[i];\\n            string word = \"\";\\n            if(j >= s.size()) return false;\\n            while(j < s.size() && s[j] != \\' \\'){\\n                word += s[j];\\n                j++;\\n            }\\n            j++;\\n            if(umap.count(ch) == 0){\\n                umap[ch] = word;\\n                if(umap2.count(word) != 0){\\n                    return false;\\n                }\\n                umap2[word] = ch;\\n            }else{\\n                if(umap[ch] == word){\\n                    // pass\\n                    if(umap2[word] == ch){\\n                        // pass\\n                    }else{\\n                        return false;\\n                    }\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(j < s.size()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2977924,
                "title": "beats-95-explanation-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def wordPattern(self,pattern: str, s: str) -> bool:\\n        # Split the string into a list of words\\n        words = s.split()\\n        \\n        # Check if the number of words in the string is equal to the number of letters in the pattern\\n        if len(words) != len(pattern):\\n            return False\\n        \\n        # Create two dictionaries to store the mappings between letters and words and between words and letters\\n        letter_mapping = {}\\n        word_mapping = {}\\n        \\n        # Iterate through the pattern and words simultaneously\\n        for letter, word in zip(pattern, words):\\n            # If the letter is not in the letter mapping, add it and map it to the word\\n            if letter not in letter_mapping:\\n                letter_mapping[letter] = word\\n            # If the letter is already in the letter mapping, check if it is mapped to the same word\\n            elif letter_mapping[letter] != word:\\n                return False\\n            \\n            # If the word is not in the word mapping, add it and map it to the letter\\n            if word not in word_mapping:\\n                word_mapping[word] = letter\\n            # If the word is already in the word mapping, check if it is mapped to the same letter\\n            elif word_mapping[word] != letter:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self,pattern: str, s: str) -> bool:\\n        # Split the string into a list of words\\n        words = s.split()\\n        \\n        # Check if the number of words in the string is equal to the number of letters in the pattern\\n        if len(words) != len(pattern):\\n            return False\\n        \\n        # Create two dictionaries to store the mappings between letters and words and between words and letters\\n        letter_mapping = {}\\n        word_mapping = {}\\n        \\n        # Iterate through the pattern and words simultaneously\\n        for letter, word in zip(pattern, words):\\n            # If the letter is not in the letter mapping, add it and map it to the word\\n            if letter not in letter_mapping:\\n                letter_mapping[letter] = word\\n            # If the letter is already in the letter mapping, check if it is mapped to the same word\\n            elif letter_mapping[letter] != word:\\n                return False\\n            \\n            # If the word is not in the word mapping, add it and map it to the letter\\n            if word not in word_mapping:\\n                word_mapping[word] = letter\\n            # If the word is already in the word mapping, check if it is mapped to the same letter\\n            elif word_mapping[word] != letter:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977454,
                "title": "java-solution-space-optimized-o-n-beats-100",
                "content": "# Intuition\\n1. Create array `arr` of string;\\n2. Create array `a` of size 26(Number of Alphabets);\\n3. Store String of `arr` in array `a` of pattern index;\\n4. And then check for the matching of pattern and given string;\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr[] = s.split(\" \");\\n        if (arr.length != pattern.length())\\n            return false;\\n        String a[] = new String[26];\\n        for (int i = 0; i < arr.length; i++) {\\n            a[pattern.charAt(i) - \\'a\\'] = arr[i];\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n            if (!a[pattern.charAt(i) - \\'a\\'].equals(arr[i]))\\n                return false;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                if (a[i] != null && a[j] != null && a[i].equals(a[j]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr[] = s.split(\" \");\\n        if (arr.length != pattern.length())\\n            return false;\\n        String a[] = new String[26];\\n        for (int i = 0; i < arr.length; i++) {\\n            a[pattern.charAt(i) - \\'a\\'] = arr[i];\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n            if (!a[pattern.charAt(i) - \\'a\\'].equals(arr[i]))\\n                return false;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                if (a[i] != null && a[j] != null && a[i].equals(a[j]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976917,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Happy New Year\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        stringstream str(s);\\n        string word;\\n        vector<string> words;\\n        while(str>>word){\\n            words.push_back(word);\\n        }\\n        if(pattern.size()!=words.size()){\\n            return false;\\n        }\\n        map<char,string> charToString;\\n        map<string,char> stringToChar;\\n        for(int i=0;i<n;i++){\\n        if(charToString.find(pattern[i])==charToString.end()&&\\n            stringToChar.find(words[i])==stringToChar.end()){\\n                charToString[pattern[i]]=words[i];\\n                stringToChar[words[i]]=pattern[i];\\n            }\\n            else if(charToString[pattern[i]]!=words[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n//Happy New Year\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        stringstream str(s);\\n        string word;\\n        vector<string> words;\\n        while(str>>word){\\n            words.push_back(word);\\n        }\\n        if(pattern.size()!=words.size()){\\n            return false;\\n        }\\n        map<char,string> charToString;\\n        map<string,char> stringToChar;\\n        for(int i=0;i<n;i++){\\n        if(charToString.find(pattern[i])==charToString.end()&&\\n            stringToChar.find(words[i])==stringToChar.end()){\\n                charToString[pattern[i]]=words[i];\\n                stringToChar[words[i]]=pattern[i];\\n            }\\n            else if(charToString[pattern[i]]!=words[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949234,
                "title": "beats-100-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n       unordered_map<char,string> mp1;\\n       unordered_map<string,char>mp2;\\n       int i=0;\\n       vector<string> vec;\\n       string temp;\\n       while(i<s.size()){\\n           if(s[i]==\\' \\'){vec.push_back(temp);\\n           temp=\"\";\\n           }\\n           else{\\n               temp.push_back(s[i]);\\n           }\\n           i++;\\n        }\\n        \\n        vec.push_back(temp);\\n        if(vec.size()!=p.size())return false;\\n       for(int i=0;i<p.size();i++)mp1[p[i]]=vec[i];\\n       for(int i=0;i<vec.size();i++)mp2[vec[i]]=p[i];\\n       for(int i=0;i<p.size();i++){\\n           if(mp1[p[i]]!=vec[i])return false;\\n       }\\n       for(int i=0;i<p.size();i++){\\n           if(mp2[vec[i]]!=p[i])return false;\\n       }\\n      \\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n       unordered_map<char,string> mp1;\\n       unordered_map<string,char>mp2;\\n       int i=0;\\n       vector<string> vec;\\n       string temp;\\n       while(i<s.size()){\\n           if(s[i]==\\' \\'){vec.push_back(temp);\\n           temp=\"\";\\n           }\\n           else{\\n               temp.push_back(s[i]);\\n           }\\n           i++;\\n        }\\n        \\n        vec.push_back(temp);\\n        if(vec.size()!=p.size())return false;\\n       for(int i=0;i<p.size();i++)mp1[p[i]]=vec[i];\\n       for(int i=0;i<vec.size();i++)mp2[vec[i]]=p[i];\\n       for(int i=0;i<p.size();i++){\\n           if(mp1[p[i]]!=vec[i])return false;\\n       }\\n       for(int i=0;i<p.size();i++){\\n           if(mp2[vec[i]]!=p[i])return false;\\n       }\\n      \\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773533,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n\\n        Map<Character, String> map1 = new HashMap<>();\\n        Map<String, Boolean> map2 = new HashMap<>();\\n\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char S = pattern.charAt(i);\\n            String word = words[i];\\n\\n            if (map1.containsKey(S)) {\\n                if (!map1.get(S).equals(word)) return false;\\n            }\\n\\n            else {\\n                if (map2.containsKey(word)) return false;\\n                else {\\n                    map1.put(S, word);\\n                    map2.put(word, true);\\n                }\\n            }\\n        }\\n\\n        return true;\\n \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n\\n        Map<Character, String> map1 = new HashMap<>();\\n        Map<String, Boolean> map2 = new HashMap<>();\\n\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char S = pattern.charAt(i);\\n            String word = words[i];\\n\\n            if (map1.containsKey(S)) {\\n                if (!map1.get(S).equals(word)) return false;\\n            }\\n\\n            else {\\n                if (map2.containsKey(word)) return false;\\n                else {\\n                    map1.put(S, word);\\n                    map2.put(word, true);\\n                }\\n            }\\n        }\\n\\n        return true;\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504209,
                "title": "c-o-n-one-pass-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char,string> mp; unordered_map<string,char> mps;int j = 0,i=0;\\n        for(i = 0;i<pattern.size();i++){\\n            string temp ;\\n            while(j<s.size()){\\n                temp.push_back(s[j++]);\\n                if(s[j]==\\' \\') {j++;break;}\\n            }\\n            if(mp.count(pattern[i]) || mps.count(temp)){  \\n                if(mp[pattern[i]]!=temp) return false;\\n            }\\n            else mp[pattern[i]] = temp,mps[temp] = pattern[i];\\n            if(j==s.size()) {i++;break;}\\n        }\\n        return j==s.size() and i==pattern.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char,string> mp; unordered_map<string,char> mps;int j = 0,i=0;\\n        for(i = 0;i<pattern.size();i++){\\n            string temp ;\\n            while(j<s.size()){\\n                temp.push_back(s[j++]);\\n                if(s[j]==\\' \\') {j++;break;}\\n            }\\n            if(mp.count(pattern[i]) || mps.count(temp)){  \\n                if(mp[pattern[i]]!=temp) return false;\\n            }\\n            else mp[pattern[i]] = temp,mps[temp] = pattern[i];\\n            if(j==s.size()) {i++;break;}\\n        }\\n        return j==s.size() and i==pattern.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466609,
                "title": "a-very-simple-java",
                "content": "IF YOU LIKE MY APPROACH PLZ UPVOTE\\n\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length())\\n            return false;\\n        Map index = new HashMap();\\n        for (Integer i=0; i<words.length; ++i)\\n            if (index.put(pattern.charAt(i), i) != index.put(words[i], i))\\n                return false;\\n        return true;\\n    }\\n}\\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length())\\n            return false;\\n        Map index = new HashMap();\\n        for (Integer i=0; i<words.length; ++i)\\n            if (index.put(pattern.charAt(i), i) != index.put(words[i], i))\\n                return false;\\n        return true;\\n    }\\n}\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021871,
                "title": "c-easy-fast",
                "content": "**In this question we are using 2 maps first mapping char to string and then using another map to map string to map. For each map if the mapping is consistent then we return true else false.**\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>vec;\\n        string temp=\"\";\\n        for(char c:s)\\n        {\\n            if(c!=\\' \\') temp+=c;\\n            else\\n            {\\n                vec.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp!=\"\") vec.push_back(temp);        \\n        if(vec.size()!=pattern.size())return false;\\n        map<string,char>m;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            char c=pattern[i];\\n            if(m.find(vec[i])==m.end())m[vec[i]]=c;\\n            else\\n            {\\n                if(m[vec[i]]!=c)return false;\\n            }\\n        }\\n        map<char,string>m1;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            char c=pattern[i];\\n            if(m1.find(c)==m1.end())m1[c]=vec[i];\\n            else\\n            {\\n                if(m1[c]!=vec[i])return false;\\n            }\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>vec;\\n        string temp=\"\";\\n        for(char c:s)\\n        {\\n            if(c!=\\' \\') temp+=c;\\n            else\\n            {\\n                vec.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp!=\"\") vec.push_back(temp);        \\n        if(vec.size()!=pattern.size())return false;\\n        map<string,char>m;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            char c=pattern[i];\\n            if(m.find(vec[i])==m.end())m[vec[i]]=c;\\n            else\\n            {\\n                if(m[vec[i]]!=c)return false;\\n            }\\n        }\\n        map<char,string>m1;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            char c=pattern[i];\\n            if(m1.find(c)==m1.end())m1[c]=vec[i];\\n            else\\n            {\\n                if(m1[c]!=vec[i])return false;\\n            }\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697980,
                "title": "python-code-word-pattern",
                "content": "```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        dic = defaultdict()\\n        words = s.split(\\' \\')\\n        if len(pattern) != len(words) or len(set(pattern)) != len(set(words)):\\n            return False\\n        for i, c in enumerate(pattern):\\n            if c in dic:\\n                if dic[c] != words[i]:\\n                    return False\\n            else:\\n                dic[c] = words[i]\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        dic = defaultdict()\\n        words = s.split(\\' \\')\\n        if len(pattern) != len(words) or len(set(pattern)) != len(set(words)):\\n            return False\\n        for i, c in enumerate(pattern):\\n            if c in dic:\\n                if dic[c] != words[i]:\\n                    return False\\n            else:\\n                dic[c] = words[i]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696289,
                "title": "c-0ms-100-faster-simple-and-optimal-solution",
                "content": "**Simple Solution**\\n*(RunTime: 0 ms (100%), Memory: 6.5MB (20.98%)*\\n\\nApproach:\\n* \\tconvert the sentence into array of strings. \\n* \\tCheck for the pattern using two hashmaps \\n\\t* \\t**C2W** -> char to string map\\n\\t* \\t**W2C** -> string to char map\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string word=\"\";\\n        \\n        //converting senetence to array of str\\n        for(auto it:s){\\n            if(it==\\' \\'){\\n                v.push_back(word);\\n                word=\"\";\\n            }else{\\n                word+=it;\\n            }\\n        }\\n        v.push_back(word);\\n        \\n        if(v.size()!=pattern.size())\\n            return false;\\n        \\n        unordered_map<string,char>W2C;\\n        unordered_map<char,string>C2W;\\n        \\n        for(int i=0;i<v.size();i++){\\n            //word is not appeared before\\n            if(W2C.count(v[i])==0){\\n                //char is not appeared before in pattern\\n                if(C2W.count(pattern[i])==0){\\n                    //setting in both map\\n                    W2C[v[i]]=pattern[i];\\n                    C2W[pattern[i]]=v[i];                    \\n                }\\n                else{\\n                    //means word not exists but char exists\\n                    return false;\\n                }\\n            }else{\\n                \\n                //means word exists but char not exists  (or)  word , char pair mismatched\\n                if(C2W.count(pattern[i])==0||W2C[v[i]]!=pattern[i]){\\n                  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Optimal Solution**\\n*(RunTime: 0 ms (100%), Memory: 6.2MB (84.24%)*\\n\\nApproach:\\n* \\tExtract word by word from given string s using `istringstream`  \\n* \\tCheck for the pattern using two hashmaps \\n\\t* \\t**C2W** -> char to string map\\n\\t* \\t**W2C** -> string to char map\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        int c = count(s.begin(),s.end(),\\' \\');\\n        \\n        if(c!=pattern.size()-1){\\n            return false;\\n        }\\n        istringstream ss(s);\\n        unordered_map<string,char>W2C;\\n        unordered_map<char,string>C2W;\\n        for(int i=0;i<pattern.size();i++){\\n            ss>>s;\\n            if(W2C.count(s)==0){\\n                if(C2W.count(pattern[i])==0){\\n                    W2C[s]=pattern[i];\\n                    C2W[pattern[i]]=s;    \\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                if(C2W.count(pattern[i])==0||W2C[s]!=pattern[i]){\\n                  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nThanks ! ! !\\n\\n```\\n\\tUseful == true ? Upvote() : Comment();   \\n```\\n\\nBy \\uD83D\\uDC93 JS",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string word=\"\";\\n        \\n        //converting senetence to array of str\\n        for(auto it:s){\\n            if(it==\\' \\'){\\n                v.push_back(word);\\n                word=\"\";\\n            }else{\\n                word+=it;\\n            }\\n        }\\n        v.push_back(word);\\n        \\n        if(v.size()!=pattern.size())\\n            return false;\\n        \\n        unordered_map<string,char>W2C;\\n        unordered_map<char,string>C2W;\\n        \\n        for(int i=0;i<v.size();i++){\\n            //word is not appeared before\\n            if(W2C.count(v[i])==0){\\n                //char is not appeared before in pattern\\n                if(C2W.count(pattern[i])==0){\\n                    //setting in both map\\n                    W2C[v[i]]=pattern[i];\\n                    C2W[pattern[i]]=v[i];                    \\n                }\\n                else{\\n                    //means word not exists but char exists\\n                    return false;\\n                }\\n            }else{\\n                \\n                //means word exists but char not exists  (or)  word , char pair mismatched\\n                if(C2W.count(pattern[i])==0||W2C[v[i]]!=pattern[i]){\\n                  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        int c = count(s.begin(),s.end(),\\' \\');\\n        \\n        if(c!=pattern.size()-1){\\n            return false;\\n        }\\n        istringstream ss(s);\\n        unordered_map<string,char>W2C;\\n        unordered_map<char,string>C2W;\\n        for(int i=0;i<pattern.size();i++){\\n            ss>>s;\\n            if(W2C.count(s)==0){\\n                if(C2W.count(pattern[i])==0){\\n                    W2C[s]=pattern[i];\\n                    C2W[pattern[i]]=s;    \\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                if(C2W.count(pattern[i])==0||W2C[s]!=pattern[i]){\\n                  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\n\\tUseful == true ? Upvote() : Comment();   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696176,
                "title": "simple-c-solution-using-unordered-map-stringstream",
                "content": "Since the pattern matching should be bijection, we need to map both characters to string and string to character.\\n\\n```\\nbool wordPattern(string pattern, string s) {\\n        unordered_map<char,string> char2string;\\n        unordered_map<string,char> string2char;\\n        \\n        int patternIdx = 0;\\n        stringstream ss(s);\\n        string word;\\n        \\n        while(ss >> word){\\n            if(patternIdx >= pattern.length()) return false;\\n            if(char2string.find(pattern[patternIdx]) == char2string.end() and string2char.find(word) == string2char.end()){\\n                char2string[pattern[patternIdx]] = word;\\n                string2char[word] = pattern[patternIdx];\\n            }\\n            \\n            else if(char2string[pattern[patternIdx]] != word || string2char[word] != pattern[patternIdx]) return false;\\n            \\n            patternIdx++;\\n        }\\n        \\n        if(patternIdx != pattern.length()) return false;\\n        return true;\\n    }\\n```\\n**Time Complexity: O(n)\\nSpace Complexity: O(n)**\\n\\n***Please Upvote, if you find the solution helpful!***",
                "solutionTags": [],
                "code": "```\\nbool wordPattern(string pattern, string s) {\\n        unordered_map<char,string> char2string;\\n        unordered_map<string,char> string2char;\\n        \\n        int patternIdx = 0;\\n        stringstream ss(s);\\n        string word;\\n        \\n        while(ss >> word){\\n            if(patternIdx >= pattern.length()) return false;\\n            if(char2string.find(pattern[patternIdx]) == char2string.end() and string2char.find(word) == string2char.end()){\\n                char2string[pattern[patternIdx]] = word;\\n                string2char[word] = pattern[patternIdx];\\n            }\\n            \\n            else if(char2string[pattern[patternIdx]] != word || string2char[word] != pattern[patternIdx]) return false;\\n            \\n            patternIdx++;\\n        }\\n        \\n        if(patternIdx != pattern.length()) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 968805,
                "title": "c-one-dictionary-only",
                "content": "```\\npublic class Solution {\\n    public bool WordPattern(string pattern, string s) {\\n        var dict = new Dictionary<Object, int>(); // pattern to index\\n        var words = s.Split(\\' \\');\\n        if (words.Length != pattern.Length) return false;\\n        \\n        for (int i=0; i<words.Length; i++) {\\n            var c = pattern[i];\\n            var word = words[i];\\n            \\n            if (!dict.ContainsKey(c)) {\\n                dict[c] = i;\\n            }\\n            if (!dict.ContainsKey(word)) {\\n                dict[word] = i;\\n            }\\n            \\n            if (dict[c] != dict[word]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool WordPattern(string pattern, string s) {\\n        var dict = new Dictionary<Object, int>(); // pattern to index\\n        var words = s.Split(\\' \\');\\n        if (words.Length != pattern.Length) return false;\\n        \\n        for (int i=0; i<words.Length; i++) {\\n            var c = pattern[i];\\n            var word = words[i];\\n            \\n            if (!dict.ContainsKey(c)) {\\n                dict[c] = i;\\n            }\\n            if (!dict.ContainsKey(word)) {\\n                dict[word] = i;\\n            }\\n            \\n            if (dict[c] != dict[word]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579550,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String str) {\\n        \\n        \\n        char[] p=pattern.toCharArray();\\n        String[] s=str.split(\" \");\\n        if(p.length!=s.length || str.isEmpty())\\n        {\\n            return false;\\n        }\\n        \\n        \\n        HashMap<Character, String> hm=new HashMap<Character, String>();\\n        \\n        for(int i=0;i<s.length;i++)\\n        {\\n            if(!hm.containsKey(p[i]) && !hm.containsValue(s[i]))\\n            {\\n                hm.put(p[i],s[i]);\\n            }\\n            \\n            if((!hm.containsKey(p[i]) && hm.containsValue(s[i]))\\n              || (!hm.get(p[i]).equals(s[i])))\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n    return true;    \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean wordPattern(String pattern, String str) {\\n        \\n        \\n        char[] p=pattern.toCharArray();\\n        String[] s=str.split(\" \");\\n        if(p.length!=s.length || str.isEmpty())\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 547778,
                "title": "scala-4-lines",
                "content": "We get all distinctive **pairs** (word - letter). Next we check if every letter and every word are uniq among this pairs.\\nwords = `[cat dog dog cat]`\\npattern = `abca`\\npairs: `[a - cat, b - dog, c - dog, a - cat]`\\nuniq pairs: `[a - cat, b - dog, c - dog]`\\nletters from uniq pairs: `abc` - are uniq\\nwords from uniq pairs: `[cat dog dog]` - are not uniq - answer - false\\n```\\n    val words = str.split(\\' \\')\\n      \\n    (words.length == pattern.length) && {\\n      val (wd, pd) = (words zip pattern).distinct.unzip\\n      (wd.length == wd.distinct.length) && (pd.length == pd.distinct.length)\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    val words = str.split(\\' \\')\\n      \\n    (words.length == pattern.length) && {\\n      val (wd, pd) = (words zip pattern).distinct.unzip\\n      (wd.length == wd.distinct.length) && (pd.length == pd.distinct.length)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 397147,
                "title": "javascript-44ms-faster-than-97-23-javascript-submission",
                "content": "\\n```\\nvar wordPattern = function(pattern, str) {\\n    str = str.split(\\' \\');\\n    pattern = pattern.split(\\'\\');\\n\\n    if(str.length !== pattern.length) return false;\\n    if(new Set(str).size !== new Set(pattern).size) return false;\\n\\n    let obj = {};\\n    pattern.forEach((p, i) => {\\n        obj[p] = str[i];\\n    });\\n    \\n    return pattern.map(p => obj[p]).join(\\' \\') === str.join(\\' \\')   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar wordPattern = function(pattern, str) {\\n    str = str.split(\\' \\');\\n    pattern = pattern.split(\\'\\');\\n\\n    if(str.length !== pattern.length) return false;\\n    if(new Set(str).size !== new Set(pattern).size) return false;\\n\\n    let obj = {};\\n    pattern.forEach((p, i) => {\\n        obj[p] = str[i];\\n    });\\n    \\n    return pattern.map(p => obj[p]).join(\\' \\') === str.join(\\' \\')   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390715,
                "title": "java-one-pass-two-pointer-solution-without-split-beat-100",
                "content": "We could `split()` the `str` to get an array of words, but in extreme case when `str` is significantly longer than `pattern`, this is not as efficient. \\nBelow is a one pass two(three?) pointer solution that compares the pattern to word only when a space is reached. \\n\\n```java\\nclass Solution {\\n    public boolean wordPattern(String pattern, String str) {\\n        String[] map = new String[26];\\n        Set<String> set = new HashSet<>();\\n        \\n        int i = 0, j = 0, start = 0;\\n        while (i < pattern.length() && j <= str.length()) {\\n            if (j == str.length() || str.charAt(j) == \\' \\') {\\n                String cur = str.substring(start, j);\\n                char c = pattern.charAt(i);\\n                if (map[c - \\'a\\'] == null) {\\n                    map[c - \\'a\\'] = cur;\\n                    if (!set.add(cur)) return false;\\n                }\\n                if (!map[c - \\'a\\'].equals(cur)) return false;\\n                start = j + 1;\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return i == pattern.length() && j == str.length() + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean wordPattern(String pattern, String str) {\\n        String[] map = new String[26];\\n        Set<String> set = new HashSet<>();\\n        \\n        int i = 0, j = 0, start = 0;\\n        while (i < pattern.length() && j <= str.length()) {\\n            if (j == str.length() || str.charAt(j) == \\' \\') {\\n                String cur = str.substring(start, j);\\n                char c = pattern.charAt(i);\\n                if (map[c - \\'a\\'] == null) {\\n                    map[c - \\'a\\'] = cur;\\n                    if (!set.add(cur)) return false;\\n                }\\n                if (!map[c - \\'a\\'].equals(cur)) return false;\\n                start = j + 1;\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return i == pattern.length() && j == str.length() + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052432,
                "title": "easy-to-understand-python-code-single-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to maintain two dictionaries, one for mapping characters in the pattern to words in the string (dic) and the other for checking if there is a one-to-one mapping in the reverse direction.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, the code splits the input string s into a list of words.\\nIt checks two conditions:\\nIf the number of unique characters in the pattern does not match the number of unique words in the string, return False. This ensures that there is a one-to-one mapping between characters and words.\\nIf the lengths of the pattern and the list of words are not equal, return False.\\nNext, it iterates through each character in the pattern and word in the list of words.\\nIf the character is not already in the dic dictionary, it adds the character as a key and the corresponding word as the value.\\nIf the character is in the dictionary, it checks if the stored word matches the current word. If they match, continue to the next character; otherwise, return False.\\nIf all characters and words have been processed without any mismatches, return True.\\n\\n# Complexity\\nTime complexity: The code iterates through both the pattern and the list of words, so the time complexity is O(n), where n is the length of the input string s.\\n\\nSpace complexity: The code uses a dictionary to store character-to-word mappings, which can have at most 26 unique characters (assuming the pattern contains only lowercase English letters). Therefore, the space complexity is O(26) or O(1), as it\\'s a constant space requirement.\\n\\nOverall, the code provides a correct solution to the problem with a time complexity of O(n) and a constant space complexity.\\n\\n# Code\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        dic = {}\\n        s = s.split()\\n        if len(set(pattern)) != len(set(s)):\\n            return False\\n        if len(pattern) != len(s):\\n            return False\\n        for i in range(len(pattern)):\\n            if pattern[i] not in dic:\\n                dic[pattern[i]] = s[i]\\n            elif dic[pattern[i]] == s[i]:\\n                continue\\n            else:\\n                return False\\n        return True\\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        dic = {}\\n        s = s.split()\\n        if len(set(pattern)) != len(set(s)):\\n            return False\\n        if len(pattern) != len(s):\\n            return False\\n        for i in range(len(pattern)):\\n            if pattern[i] not in dic:\\n                dic[pattern[i]] = s[i]\\n            elif dic[pattern[i]] == s[i]:\\n                continue\\n            else:\\n                return False\\n        return True\\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768947,
                "title": "cpp-100",
                "content": "# Complexity\\n- Time complexity: O(N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstatic auto _enhancer = []()\\n{\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\nclass Solution \\n{\\npublic:\\n    bool wordPattern(string pt, string s) \\n    {\\n        unordered_map<char,string> mp;\\n        unordered_map<string,char> m;\\n        int i=0;\\n\\n        istringstream iss(s); \\n        do \\n        { \\n            string temp; \\n            iss >> temp; \\n            if(mp.find(pt[i])!=mp.end() || m.find(temp)!=m.end())\\n            {\\n                if(mp[pt[i]]!=temp || m[temp]!=pt[i])\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                mp[pt[i]]=temp;\\n                m[temp]=pt[i];\\n            }\\n            i++;\\n        } while (iss);  \\n\\n        if(i-1!=pt.size())\\n        {\\n            return false;\\n        }\\n        return true;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic auto _enhancer = []()\\n{\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\nclass Solution \\n{\\npublic:\\n    bool wordPattern(string pt, string s) \\n    {\\n        unordered_map<char,string> mp;\\n        unordered_map<string,char> m;\\n        int i=0;\\n\\n        istringstream iss(s); \\n        do \\n        { \\n            string temp; \\n            iss >> temp; \\n            if(mp.find(pt[i])!=mp.end() || m.find(temp)!=m.end())\\n            {\\n                if(mp[pt[i]]!=temp || m[temp]!=pt[i])\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                mp[pt[i]]=temp;\\n                m[temp]=pt[i];\\n            }\\n            i++;\\n        } while (iss);  \\n\\n        if(i-1!=pt.size())\\n        {\\n            return false;\\n        }\\n        return true;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435909,
                "title": "100-beginners-friendly",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        one key= one value and vice-versa I have used two hashMaps\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] t=s.split(\" \");\\n        if(t.length!= pattern.length()) return false;\\n        HashMap<Character, String> h1= new HashMap<>();\\n        HashMap<String, Character> h2=new HashMap<>();\\n\\n        for(int i=0;i<pattern.length();i++){\\n            if(h1.containsKey(pattern.charAt(i))){\\n                if(!h1.get(pattern.charAt(i)).equals(t[i])) return false;\\n            }\\n            if(h2.containsKey(t[i])){\\n                if(!h2.get(t[i]).equals(pattern.charAt(i))) return false;\\n            }\\n\\n            h1.put(pattern.charAt(i),t[i]);\\n            h2.put(t[i],pattern.charAt(i));\\n\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] t=s.split(\" \");\\n        if(t.length!= pattern.length()) return false;\\n        HashMap<Character, String> h1= new HashMap<>();\\n        HashMap<String, Character> h2=new HashMap<>();\\n\\n        for(int i=0;i<pattern.length();i++){\\n            if(h1.containsKey(pattern.charAt(i))){\\n                if(!h1.get(pattern.charAt(i)).equals(t[i])) return false;\\n            }\\n            if(h2.containsKey(t[i])){\\n                if(!h2.get(t[i]).equals(pattern.charAt(i))) return false;\\n            }\\n\\n            h1.put(pattern.charAt(i),t[i]);\\n            h2.put(t[i],pattern.charAt(i));\\n\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117105,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, string> mp;\\n        string p;\\n        vector<string> v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                v.push_back(p);\\n                p=\"\";\\n            }\\n            else\\n            p+=s[i];\\n        }\\n        v.push_back(p);\\n        unordered_set<string> st;\\n        if(v.size()!=pattern.size())\\n        return false;\\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            if(mp.find(pattern[i])!=mp.end())\\n            {\\n                if(mp[pattern[i]]!=v[i])\\n                return false;\\n            }\\n            else\\n            {\\n                if (st.count(v[i]) > 0)\\n                  return false;\\n                st.insert(v[i]);\\n                mp[pattern[i]] = v[i];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, string> mp;\\n        string p;\\n        vector<string> v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                v.push_back(p);\\n                p=\"\";\\n            }\\n            else\\n            p+=s[i];\\n        }\\n        v.push_back(p);\\n        unordered_set<string> st;\\n        if(v.size()!=pattern.size())\\n        return false;\\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            if(mp.find(pattern[i])!=mp.end())\\n            {\\n                if(mp[pattern[i]]!=v[i])\\n                return false;\\n            }\\n            else\\n            {\\n                if (st.count(v[i]) > 0)\\n                  return false;\\n                st.insert(v[i]);\\n                mp[pattern[i]] = v[i];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019045,
                "title": "java-90-beats-easy-solution-with-time-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String str) \\n    {\\n        HashMap<Character,String>h=new HashMap<>();\\n        String [] s=str.split(\"\\\\\\\\ \");\\n        char c=\\'a\\';\\n        String b=\"\";\\n        if(s.length!=pattern.length())return false;\\n        for(int i=0;i<s.length;i++)\\n        {\\n            c=pattern.charAt(i);\\n            b=s[i];\\n            if(!h.containsKey(c) && !h.containsValue(b))\\n            {\\n                h.put(c,b);\\n            }\\n            else if(h.containsKey(c))\\n            {\\n                if(!h.get(c).equals(b))\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(h.containsValue(b))\\n            {\\n                int x=0;\\n                for(Map.Entry<Character,String> m:h.entrySet())\\n                {\\n                    if(m.getValue()==b)\\n                    {\\n                        x=m.getKey();\\n                    }\\n                }\\n                if(x!=c)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String str) \\n    {\\n        HashMap<Character,String>h=new HashMap<>();\\n        String [] s=str.split(\"\\\\\\\\ \");\\n        char c=\\'a\\';\\n        String b=\"\";\\n        if(s.length!=pattern.length())return false;\\n        for(int i=0;i<s.length;i++)\\n        {\\n            c=pattern.charAt(i);\\n            b=s[i];\\n            if(!h.containsKey(c) && !h.containsValue(b))\\n            {\\n                h.put(c,b);\\n            }\\n            else if(h.containsKey(c))\\n            {\\n                if(!h.get(c).equals(b))\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(h.containsValue(b))\\n            {\\n                int x=0;\\n                for(Map.Entry<Character,String> m:h.entrySet())\\n                {\\n                    if(m.getValue()==b)\\n                    {\\n                        x=m.getKey();\\n                    }\\n                }\\n                if(x!=c)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018865,
                "title": "simple-and-intuitive-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> There must exist must sort of mapping between the WORDS of STRING and LETTERS of PATTERN. This can imply the following observations:\\n- if length of pattern is not equal to number of words in string, return false\\n- otherwise, we create a dictionary mapping LETTERS of PATTERN with WORDS of STRING \\n\\n# Approach\\n- <!-- Describe your approach to solving the problem. --> Create a list of words of string and an empty hashmap.\\n- We iterate over the pattern keeping track of index of letter and the letter itself\\n- If this letter is not present in hashmap (hasn\\'t been mapped yet), then we map it to the corresponding word in the string (through index)\\n- Otherwise, we check if the current WORD is same as the PREVIOUSLY MAPPED WORD, if no then we return False\\n- Lastly, we handle the case where same word is mapped to multiple letters (example - pattern = \\'abba\\' string = \\'dog dog dog dog\\').\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n), where n is the number of letters in pattern.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(l*n), where l is length of longest word in string and n is number of number of words in string.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        # create a list containing words of string\\n        ls = s.split()\\n        dic = {}\\n        # if number of letters and number of words don\\'t match\\n        if len(ls)!=len(pattern):\\n            return False\\n        for i,letter in enumerate(pattern):\\n            if letter in dic and dic[letter]!=ls[i]:\\n                # if a mapping exists and new word doesn\\'t match\\n                return False\\n            else:\\n                dic[letter]=ls[i]\\n        s = set()\\n        # if same word has multiple mapping with different letters\\n        for key,value in dic.items():\\n            s.add(value)\\n        if len(s)!=len(dic):\\n            return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        # create a list containing words of string\\n        ls = s.split()\\n        dic = {}\\n        # if number of letters and number of words don\\'t match\\n        if len(ls)!=len(pattern):\\n            return False\\n        for i,letter in enumerate(pattern):\\n            if letter in dic and dic[letter]!=ls[i]:\\n                # if a mapping exists and new word doesn\\'t match\\n                return False\\n            else:\\n                dic[letter]=ls[i]\\n        s = set()\\n        # if same word has multiple mapping with different letters\\n        for key,value in dic.items():\\n            s.add(value)\\n        if len(s)!=len(dic):\\n            return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986088,
                "title": "stringstream-only",
                "content": "# Intuition\\nUse `stringstream` to separate each word in given string and `map` them with pattern.\\n\\n# Approach\\nMatch every character of pattern to vector of string formed using `stringstream`. Also check same `value` should not have same `key`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        unordered_map<char, string>mp;\\n        stringstream ss(s);\\n        string word;\\n        while(ss>>word)\\n            v.push_back(word);\\n        if(v.size()!=pattern.length())\\n            return false;\\n        for(int i=0, j=0; i<pattern.length(); i++, j++){\\n            if(mp.find(pattern[i])==mp.end()){\\n                mp[pattern[i]] = v[j];\\n            }\\n            else if(mp[pattern[i]]!=v[j])\\n                return false;\\n            for(auto it=mp.begin(); it!=mp.end(); it++){\\n                if(it->second==v[j] and it->first!=pattern[i])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        unordered_map<char, string>mp;\\n        stringstream ss(s);\\n        string word;\\n        while(ss>>word)\\n            v.push_back(word);\\n        if(v.size()!=pattern.length())\\n            return false;\\n        for(int i=0, j=0; i<pattern.length(); i++, j++){\\n            if(mp.find(pattern[i])==mp.end()){\\n                mp[pattern[i]] = v[j];\\n            }\\n            else if(mp[pattern[i]]!=v[j])\\n                return false;\\n            for(auto it=mp.begin(); it!=mp.end(); it++){\\n                if(it->second==v[j] and it->first!=pattern[i])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981978,
                "title": "simple-solution-with-reduce",
                "content": "# Code\\n```\\nconst wordPattern = function(pattern, s) {\\n    const words = s.split(\\' \\');\\n    const patternArr = pattern.split(\\'\\');\\n\\n    if (s.split(\\' \\').length !== patternArr.length) {\\n        return false;\\n    }\\n\\n    const patternRule = patternArr.reduce((acc, el, i) => {\\n        if (Object.values(acc).includes(words[i])) {\\n            return acc;\\n        }\\n\\n        return {\\n            ...acc,\\n            [el]: words[i]\\n        }\\n    }, {});\\n\\n    return patternArr.every((el, i) => patternRule[el] === words[i])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst wordPattern = function(pattern, s) {\\n    const words = s.split(\\' \\');\\n    const patternArr = pattern.split(\\'\\');\\n\\n    if (s.split(\\' \\').length !== patternArr.length) {\\n        return false;\\n    }\\n\\n    const patternRule = patternArr.reduce((acc, el, i) => {\\n        if (Object.values(acc).includes(words[i])) {\\n            return acc;\\n        }\\n\\n        return {\\n            ...acc,\\n            [el]: words[i]\\n        }\\n    }, {});\\n\\n    return patternArr.every((el, i) => patternRule[el] === words[i])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981349,
                "title": "0-ms-code-using-map-set-100-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>arr;\\n        string temp=\"\";\\n        int i=0;\\n        while(i<s.length()){\\n            if(s[i]==\\' \\'){\\n                arr.push_back(temp);\\n                temp=\"\";\\n                \\n            }\\n            else{\\n                temp += s[i];\\n            }\\n            i++;\\n        }\\n        arr.push_back(temp);\\n        if(pattern.length()!=arr.size()){\\n            return false;\\n        }\\n        \\n        map<char,string>m;\\n        set<string>str;\\n        for(int i=0;i<pattern.length();i++){\\n            if(m.find(pattern[i])!=m.end()){\\n                if(m[pattern[i]]!=arr[i]){\\n                return false;\\n            }\\n            }\\n            else{\\n                    if(str.find(arr[i])!=str.end()){\\n                        return false;\\n                    }\\n                    m[pattern[i]]=arr[i];\\n                    str.insert(arr[i]);\\n            }\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>arr;\\n        string temp=\"\";\\n        int i=0;\\n        while(i<s.length()){\\n            if(s[i]==\\' \\'){\\n                arr.push_back(temp);\\n                temp=\"\";\\n                \\n            }\\n            else{\\n                temp += s[i];\\n            }\\n            i++;\\n        }\\n        arr.push_back(temp);\\n        if(pattern.length()!=arr.size()){\\n            return false;\\n        }\\n        \\n        map<char,string>m;\\n        set<string>str;\\n        for(int i=0;i<pattern.length();i++){\\n            if(m.find(pattern[i])!=m.end()){\\n                if(m[pattern[i]]!=arr[i]){\\n                return false;\\n            }\\n            }\\n            else{\\n                    if(str.find(arr[i])!=str.end()){\\n                        return false;\\n                    }\\n                    m[pattern[i]]=arr[i];\\n                    str.insert(arr[i]);\\n            }\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980138,
                "title": "cpp-solution-using-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        string resulyarr[26];\\n        vector<string> stored;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string some = \"\";\\n            while(s[i] != \\' \\' && i<s.size())\\n            {\\n                some += s[i];\\n                i++;\\n            }\\n        stored.push_back(some);\\n        }\\n        if(pattern.size() != stored.size())\\n        {\\n            return false;\\n        }\\n        // for(int i=0;i<stored.size();i++)\\n        // {\\n        //     cout<<stored[i];\\n        // }\\n        int index=0;\\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(resulyarr[j]==stored[index] && j!=(pattern[i]-\\'a\\'))\\n                {\\n                    return false;\\n                }\\n            }\\n            resulyarr[pattern[i]-\\'a\\'] = stored[index++];\\n        }\\n        string res = \"\";\\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            if(i==0)\\n            res += resulyarr[pattern[i]-\\'a\\'];\\n            else\\n            res +=\" \" + resulyarr[pattern[i]-\\'a\\'];\\n        }\\n        cout<<s<<endl<<res;\\n        return s == res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        string resulyarr[26];\\n        vector<string> stored;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string some = \"\";\\n            while(s[i] != \\' \\' && i<s.size())\\n            {\\n                some += s[i];\\n                i++;\\n            }\\n        stored.push_back(some);\\n        }\\n        if(pattern.size() != stored.size())\\n        {\\n            return false;\\n        }\\n        // for(int i=0;i<stored.size();i++)\\n        // {\\n        //     cout<<stored[i];\\n        // }\\n        int index=0;\\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(resulyarr[j]==stored[index] && j!=(pattern[i]-\\'a\\'))\\n                {\\n                    return false;\\n                }\\n            }\\n            resulyarr[pattern[i]-\\'a\\'] = stored[index++];\\n        }\\n        string res = \"\";\\n        for(int i=0;i<pattern.size();i++)\\n        {\\n            if(i==0)\\n            res += resulyarr[pattern[i]-\\'a\\'];\\n            else\\n            res +=\" \" + resulyarr[pattern[i]-\\'a\\'];\\n        }\\n        cout<<s<<endl<<res;\\n        return s == res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2979874,
                "title": "simple-and-easily-explained-with-proper-points",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we have to understand what Bijection says, Bijection is a type of one to one mapping from both side.Since it\\'s a one to one mapping from both side we need 2 map data structure because map is one to many mapping. We will keep the track of pattern\\'s character to non empty words in one map and in other we will keep track of non empty words to pattern\\'s character.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Declare 2 unordered map, map<char,string> and other <string, char>.\\n2. if the current pattern\\'s character is not found in map, insert it . If found , check the found value and the current word. If not matched, **return false**.\\n3. Iterate through string s, make an variable of string dayaset and store the word in that dataset. If the word is not found initially to the mapped paatern character, insert in the map. If found and there is difference between the current word and the word that is initially present, **return false**.\\n4. increment the pointer by 1.\\n5. There will be the case where one pointer will reach to it\\'s final length and other\\'s not, in that case also **return false**.\\n6. else **return true**.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, string>mS;\\n        unordered_map<string, char>mT;\\n        int i=0, j=0;\\n        int m = pattern.length(), n = s.length();\\n        while(i<m && j<n)\\n        {\\n            string str;\\n            while(j<n && s[j]!=\\' \\')\\n            {\\n                str.push_back(s[j]);\\n                j++;\\n            }\\n            if(mS.find(pattern[i])==mS.end() && i<m)\\n            {\\n                mS[pattern[i]] = str;\\n            }\\n            else if(mS.find(pattern[i])!=mS.end() && mS[pattern[i]]!=str)\\n            {\\n                return false;\\n            }\\n            if(mT.find(str)==mT.end())\\n            {\\n                mT[str] = pattern[i];\\n            }\\n            else if(mT.find(str)!=mT.end() && mT[str]!=pattern[i])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if(i!=m)\\n        {\\n            return false;\\n        }\\n        if(j!=n+1)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, string>mS;\\n        unordered_map<string, char>mT;\\n        int i=0, j=0;\\n        int m = pattern.length(), n = s.length();\\n        while(i<m && j<n)\\n        {\\n            string str;\\n            while(j<n && s[j]!=\\' \\')\\n            {\\n                str.push_back(s[j]);\\n                j++;\\n            }\\n            if(mS.find(pattern[i])==mS.end() && i<m)\\n            {\\n                mS[pattern[i]] = str;\\n            }\\n            else if(mS.find(pattern[i])!=mS.end() && mS[pattern[i]]!=str)\\n            {\\n                return false;\\n            }\\n            if(mT.find(str)==mT.end())\\n            {\\n                mT[str] = pattern[i];\\n            }\\n            else if(mT.find(str)!=mT.end() && mT[str]!=pattern[i])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if(i!=m)\\n        {\\n            return false;\\n        }\\n        if(j!=n+1)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979616,
                "title": "python-solution-beats-97-10-ms",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        l = s.split()\\n        if len(pattern) != len(l):\\n            return False\\n        hash = {}\\n        for key in range(len(pattern)):\\n            if pattern[key] not in hash and l[key] in hash.values():\\n                return False\\n            if pattern[key] not in hash:\\n                hash[pattern[key]] = l[key]\\n            elif hash[pattern[key]] != l[key]:\\n                return False\\n        return True\\n```\\n# HAPPY NEW YEAR LEETCODE!!!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        l = s.split()\\n        if len(pattern) != len(l):\\n            return False\\n        hash = {}\\n        for key in range(len(pattern)):\\n            if pattern[key] not in hash and l[key] in hash.values():\\n                return False\\n            if pattern[key] not in hash:\\n                hash[pattern[key]] = l[key]\\n            elif hash[pattern[key]] != l[key]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979483,
                "title": "simple-c-code-with-o-n-complexity",
                "content": "# Intuition:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Check if each charcter from string $$pattern$$ mapped to only one word from string $$s$$ and vice versa.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First convert String $$s$$ in vector of string which will store all words int it without spaces. Then check each character from string $$pattern$$ mapped to same word from earlier created vector and Vice versa, if not then return false else true.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> v;\\n\\t\\tint i = 0;\\n\\t\\tstring temp = \"\";\\n\\t\\twhile(i < s.size()){\\n\\t\\t\\tif(s[i] == \\' \\'){\\n\\t\\t\\t\\tv.push_back(temp);\\n\\t\\t\\t\\ttemp = \"\";\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ttemp += s[i];\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tv.push_back(temp);\\n\\n        if(v.size() != pattern.size()){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n        unordered_map<char, string> m;\\n\\t\\tset<string> st;\\n\\n        for(int i = 0; i < pattern.size(); i++){\\n\\t\\t\\tif(m.find(pattern[i]) != m.end()){ //pattern in  hashmap\\n                if(m[pattern[i]] != v[i]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(st.count(v[i]) > 0){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tm[pattern[i]] = v[i];\\n\\t\\t\\t\\tst.insert(v[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n        \\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> v;\\n\\t\\tint i = 0;\\n\\t\\tstring temp = \"\";\\n\\t\\twhile(i < s.size()){\\n\\t\\t\\tif(s[i] == \\' \\'){\\n\\t\\t\\t\\tv.push_back(temp);\\n\\t\\t\\t\\ttemp = \"\";\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ttemp += s[i];\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tv.push_back(temp);\\n\\n        if(v.size() != pattern.size()){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n        unordered_map<char, string> m;\\n\\t\\tset<string> st;\\n\\n        for(int i = 0; i < pattern.size(); i++){\\n\\t\\t\\tif(m.find(pattern[i]) != m.end()){ //pattern in  hashmap\\n                if(m[pattern[i]] != v[i]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(st.count(v[i]) > 0){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tm[pattern[i]] = v[i];\\n\\t\\t\\t\\tst.insert(v[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n        \\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978657,
                "title": "0ms-100-efficient-solution-using-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) \\n    {\\n        HashMap<Character,String> map=new HashMap<>();\\n        String arr[]=s.split(\" \");\\n        if(pattern.length()!=arr.length)\\n            return false;\\n        for(int i=0;i<pattern.length();i++)\\n        {\\n            if(map.containsKey(pattern.charAt(i))==true)\\n            {\\n                if(map.get(pattern.charAt(i)).equals(arr[i])==false)\\n                    return false;\\n            }\\n            else\\n            {\\n                if(map.containsValue(arr[i])==true)\\n                    return false;\\n                map.put(pattern.charAt(i),arr[i]);\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) \\n    {\\n        HashMap<Character,String> map=new HashMap<>();\\n        String arr[]=s.split(\" \");\\n        if(pattern.length()!=arr.length)\\n            return false;\\n        for(int i=0;i<pattern.length();i++)\\n        {\\n            if(map.containsKey(pattern.charAt(i))==true)\\n            {\\n                if(map.get(pattern.charAt(i)).equals(arr[i])==false)\\n                    return false;\\n            }\\n            else\\n            {\\n                if(map.containsValue(arr[i])==true)\\n                    return false;\\n                map.put(pattern.charAt(i),arr[i]);\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978245,
                "title": "very-easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        \\n        if(pattern==s){\\n            if(pattern.size()==1){\\n                return true;\\n               \\n            }\\n            return false;\\n        }\\n        int n=s.length();\\n        vector<string> words;\\n        string t=\"\";\\n        for(int i=0; i<=s.size(); i++) {\\n            if(s[i] == \\'\\\\0\\') {\\n                words.push_back(t);\\n                break;\\n            }\\n            else if(s[i] == \\' \\') {\\n                words.push_back(t);\\n                t=\"\";\\n            }\\n            else t+=s[i];\\n            \\n        }\\n        int a=words.size();\\n        if(pattern.size() != words.size()){\\n            return false;\\n        }\\n        for(int i=0;i<a;i++){\\n            for(int j=0;j<a;j++){\\n                if(words[i]==words[j] && pattern[i]!=pattern[j]){\\n                    return false;\\n                }\\n                if(pattern[i]==pattern[j] && words[i]!=words[j]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        \\n        if(pattern==s){\\n            if(pattern.size()==1){\\n                return true;\\n               \\n            }\\n            return false;\\n        }\\n        int n=s.length();\\n        vector<string> words;\\n        string t=\"\";\\n        for(int i=0; i<=s.size(); i++) {\\n            if(s[i] == \\'\\\\0\\') {\\n                words.push_back(t);\\n                break;\\n            }\\n            else if(s[i] == \\' \\') {\\n                words.push_back(t);\\n                t=\"\";\\n            }\\n            else t+=s[i];\\n            \\n        }\\n        int a=words.size();\\n        if(pattern.size() != words.size()){\\n            return false;\\n        }\\n        for(int i=0;i<a;i++){\\n            for(int j=0;j<a;j++){\\n                if(words[i]==words[j] && pattern[i]!=pattern[j]){\\n                    return false;\\n                }\\n                if(pattern[i]==pattern[j] && words[i]!=words[j]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978143,
                "title": "java-easy-to-understand-using-map",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing map to associate the words with the pattern alphabets. Now if key is already present in map and the Values are not same then we will return false otherwise if value is already present return false other wise we simply add the elements in the map.\\n\\nIf all the words are added and loop ends that means String s follows pattern and hence we return true.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> mp = new HashMap<>();\\n        char[] alpha = pattern.toCharArray();\\n        String[] words = s.split(\"\\\\\\\\s+\");\\n        if(words.length!=pattern.length()) return false;\\n        int i=0;\\n        for(char ch : alpha){\\n            if(mp.containsKey(ch)){\\n                if(!mp.get(ch).equals(words[i++]))\\n                return false;\\n            }\\n            else{\\n                if(mp.containsValue(words[i]))\\n                return false;\\n                mp.put(ch,words[i++]);\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> mp = new HashMap<>();\\n        char[] alpha = pattern.toCharArray();\\n        String[] words = s.split(\"\\\\\\\\s+\");\\n        if(words.length!=pattern.length()) return false;\\n        int i=0;\\n        for(char ch : alpha){\\n            if(mp.containsKey(ch)){\\n                if(!mp.get(ch).equals(words[i++]))\\n                return false;\\n            }\\n            else{\\n                if(mp.containsValue(words[i]))\\n                return false;\\n                mp.put(ch,words[i++]);\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978061,
                "title": "c-easy",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, int> p2i;\\n        unordered_map<string, int> w2i;\\n        istringstream in(s); string word;\\n        int i = 0, n = pattern.size();\\n        for(word; in>>word; i++){\\n            if(i==n || p2i[pattern[i]] != w2i[word]) return false;\\n            p2i[pattern[i]] = w2i[word] = i+1;\\n        }\\n        return i==n; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, int> p2i;\\n        unordered_map<string, int> w2i;\\n        istringstream in(s); string word;\\n        int i = 0, n = pattern.size();\\n        for(word; in>>word; i++){\\n            if(i==n || p2i[pattern[i]] != w2i[word]) return false;\\n            p2i[pattern[i]] = w2i[word] = i+1;\\n        }\\n        return i==n; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977825,
                "title": "c-easy-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        int i=0;\\n        string temp=\"\";\\n        while(i<s.size()){\\n            if(s[i]== \\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else{\\n                temp+=s[i];\\n            }\\n            i++;\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()) return false;\\n        unordered_map<char,string>m;\\n        set<string>st;\\n        for(int i=0;i<pattern.size();i++){\\n            if(m.find(pattern[i])!=m.end()){\\n                if(m[pattern[i]]!=v[i]) return false;\\n            }\\n            else{\\n                if(st.count(v[i])>0) return false;\\n                m[pattern[i]]=v[i];\\n                st.insert(v[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        int i=0;\\n        string temp=\"\";\\n        while(i<s.size()){\\n            if(s[i]== \\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else{\\n                temp+=s[i];\\n            }\\n            i++;\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()) return false;\\n        unordered_map<char,string>m;\\n        set<string>st;\\n        for(int i=0;i<pattern.size();i++){\\n            if(m.find(pattern[i])!=m.end()){\\n                if(m[pattern[i]]!=v[i]) return false;\\n            }\\n            else{\\n                if(st.count(v[i])>0) return false;\\n                m[pattern[i]]=v[i];\\n                st.insert(v[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977149,
                "title": "easy-to-understand-100-fast-c-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst I make all word separate and make a hash set with compare to pattern to string and string to pattern than just check that it was use other or not and check the word miss match with other word.\\n# Complexity\\n- Time complexity:O(n)\\n- ![Capture.PNG](https://assets.leetcode.com/users/images/4f70503f-3431-4c6a-b2c0-be76d60c4c15_1672542388.633656.png)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        vector<string>st;\\n        string cur = \"\";\\n        for(auto it : s){\\n            if(it == \\' \\'){\\n                st.push_back(cur);\\n                cur = \"\";\\n                continue;\\n            }\\n            cur += it;\\n        }\\n        st.push_back(cur);\\n        if(st.size() != p.size())return false;\\n        map<char, string>mp;\\n        map<string, char>check;\\n        for(int i=0; i<p.size(); i++){\\n            if(!mp.count(p[i])){\\n                mp[p[i]] = st[i];\\n                if(check.count(st[i]))return false;\\n                check[st[i]] = p[i];\\n            }\\n            else{\\n                if(mp[p[i]] != st[i])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        vector<string>st;\\n        string cur = \"\";\\n        for(auto it : s){\\n            if(it == \\' \\'){\\n                st.push_back(cur);\\n                cur = \"\";\\n                continue;\\n            }\\n            cur += it;\\n        }\\n        st.push_back(cur);\\n        if(st.size() != p.size())return false;\\n        map<char, string>mp;\\n        map<string, char>check;\\n        for(int i=0; i<p.size(); i++){\\n            if(!mp.count(p[i])){\\n                mp[p[i]] = st[i];\\n                if(check.count(st[i]))return false;\\n                check[st[i]] = p[i];\\n            }\\n            else{\\n                if(mp[p[i]] != st[i])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977009,
                "title": "c-solution-beats-100-using-two-unordered-maps",
                "content": "# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        std::unordered_map<char, string> map1;\\n        std::unordered_map<string, char> map2;\\n        vector<string> words;\\n\\n        int index = 0;\\n        string temp = \"\";\\n        while(index < s.size()){\\n            if(s[index] == \\' \\') {\\n                words.push_back(temp);\\n                temp = \"\";\\n            }\\n            else {\\n                temp += s[index];\\n            }\\n            index++;\\n        }\\n        words.push_back(temp);\\n\\n        if(pattern.size() != words.size())\\n            return false;\\n\\n        for(int i=0; i<pattern.size(); i++) {\\n            auto got1 = map1.find(pattern[i]);\\n            if(got1 == map1.end())\\n                map1[pattern[i]] = words[i];\\n            else if(got1->second != words[i])\\n                return false;\\n\\n            auto got2 = map2.find(words[i]);\\n            if(got2 == map2.end())\\n                map2[words[i]] = pattern[i];\\n            else if(got2->second != pattern[i])\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        std::unordered_map<char, string> map1;\\n        std::unordered_map<string, char> map2;\\n        vector<string> words;\\n\\n        int index = 0;\\n        string temp = \"\";\\n        while(index < s.size()){\\n            if(s[index] == \\' \\') {\\n                words.push_back(temp);\\n                temp = \"\";\\n            }\\n            else {\\n                temp += s[index];\\n            }\\n            index++;\\n        }\\n        words.push_back(temp);\\n\\n        if(pattern.size() != words.size())\\n            return false;\\n\\n        for(int i=0; i<pattern.size(); i++) {\\n            auto got1 = map1.find(pattern[i]);\\n            if(got1 == map1.end())\\n                map1[pattern[i]] = words[i];\\n            else if(got1->second != words[i])\\n                return false;\\n\\n            auto got2 = map2.find(words[i]);\\n            if(got2 == map2.end())\\n                map2[words[i]] = pattern[i];\\n            else if(got2->second != pattern[i])\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977001,
                "title": "c-unordered-map-set-100-speed-96-mem",
                "content": "# Intuition\\nWe ingest a stream of words and compare each one against the mappings we have seen so far, if it contradicts a mapping then return false, if the word has already been mapped to a different char then return false. If we consume all the words and don\\'t run into any problems then we can check that we have compared against the entire pattern and return true or false accordingly.\\n\\n# Approach\\nTo optimse the memory usage of the map and set, we hash each word to represent it as `size_t`, this is smaller than using `string`.\\n\\n# Complexity\\nWhere $$n$$ is the number of words.\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, size_t> dp;\\n        unordered_set<size_t> seenWords;\\n        istringstream ss(s);\\n        string word; \\n        size_t h;\\n        int i = 0;\\n        while (ss >> word) {\\n            h = hash<string>()(word);\\n            if (dp[pattern[i]] != 0) {\\n                if (dp[pattern[i]] != h) return false;\\n            } else if (seenWords.find(h) != seenWords.end()) {\\n                return false;\\n            } else {\\n                seenWords.insert(h);\\n                dp[pattern[i]] = h;\\n            }\\n            i++;\\n        }\\n        if (pattern.size() > i)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, size_t> dp;\\n        unordered_set<size_t> seenWords;\\n        istringstream ss(s);\\n        string word; \\n        size_t h;\\n        int i = 0;\\n        while (ss >> word) {\\n            h = hash<string>()(word);\\n            if (dp[pattern[i]] != 0) {\\n                if (dp[pattern[i]] != h) return false;\\n            } else if (seenWords.find(h) != seenWords.end()) {\\n                return false;\\n            } else {\\n                seenWords.insert(h);\\n                dp[pattern[i]] = h;\\n            }\\n            i++;\\n        }\\n        if (pattern.size() > i)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863769,
                "title": "javascript-best-solution",
                "content": "```\\nconst wordPattern = (pattern, s) => {\\n    const obj = {}, map = {};\\n    const splitted = s.split(\\' \\');\\n\\n    for (let i = 0; i < pattern.length; i++) {\\n        const curPat = pattern[i], curS = splitted[i];\\n        if (curPat in obj) {\\n            if (map[curS] !== curPat) return false;\\n        } else {\\n            obj[curPat] = curS;\\n            map[curS] = curPat;\\n        } \\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst wordPattern = (pattern, s) => {\\n    const obj = {}, map = {};\\n    const splitted = s.split(\\' \\');\\n\\n    for (let i = 0; i < pattern.length; i++) {\\n        const curPat = pattern[i], curS = splitted[i];\\n        if (curPat in obj) {\\n            if (map[curS] !== curPat) return false;\\n        } else {\\n            obj[curPat] = curS;\\n            map[curS] = curPat;\\n        } \\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575880,
                "title": "maps-c-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n     \\n    vector<string>word; // stores words of s --> dog at 0th index and so on\\n        \\n    string dummy=\"\";\\n        \\n// storing every words in word \\n    for(int i=0;i<s.size();i++)\\n    {\\n        if(s[i]==\\' \\')\\n        {\\n            word.push_back(dummy);\\n            dummy.clear();\\n        }\\n        else    { dummy+=s[i];   }\\n    }\\n        // last word still left add it as well\\n    word.push_back(dummy);\\n    \\n    \\n\\t// using two maps --> first one m for pattern and mp for storing frequency of word\\n    map<char,string> m;\\n    map<string,int> mp;\\n        \\n        \\n        // case 1 --> when size not equal ex-> abb  , dog cat  --> false\\n    if(pattern.size()!=word.size())   return false;\\n    \\n    \\n    for(int i=0;i<pattern.size();i++)\\n    {\\n        // find key --> a   if not exist in map than only go inside\\n        if(m.find(pattern[i])==m.end())\\n        {\\n            \\n            if(mp[word[i]]==0){\\n        // corresponding to a --> dog \\n                m[pattern[i]]=word[i];\\n                // store freq of dog than\\n                mp[word[i]]++;\\n            }\\n      // ex-> ab , cat cat --> first frequency of cat increase to 1 --> but for b->cat not possible as cat already exist in term of frequency \\n            else return false;\\n        }\\n   \\n    //abba -->  after we stored a and b  and came again to a than just see if  a-->dog (correspond) and b-->cat\\n        else\\n        {\\n            if(m[pattern[i]]!=word[i])\\n                return false;\\n        }\\n    }\\n    return true;    \\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n     \\n    vector<string>word; // stores words of s --> dog at 0th index and so on\\n        \\n    string dummy=\"\";\\n        \\n// storing every words in word \\n    for(int i=0;i<s.size();i++)\\n    {\\n        if(s[i]==\\' \\')\\n        {\\n            word.push_back(dummy);\\n            dummy.clear();\\n        }\\n        else    { dummy+=s[i];   }\\n    }\\n        // last word still left add it as well\\n    word.push_back(dummy);\\n    \\n    \\n\\t// using two maps --> first one m for pattern and mp for storing frequency of word\\n    map<char,string> m;\\n    map<string,int> mp;\\n        \\n        \\n        // case 1 --> when size not equal ex-> abb  , dog cat  --> false\\n    if(pattern.size()!=word.size())   return false;\\n    \\n    \\n    for(int i=0;i<pattern.size();i++)\\n    {\\n        // find key --> a   if not exist in map than only go inside\\n        if(m.find(pattern[i])==m.end())\\n        {\\n            \\n            if(mp[word[i]]==0){\\n        // corresponding to a --> dog \\n                m[pattern[i]]=word[i];\\n                // store freq of dog than\\n                mp[word[i]]++;\\n            }\\n      // ex-> ab , cat cat --> first frequency of cat increase to 1 --> but for b->cat not possible as cat already exist in term of frequency \\n            else return false;\\n        }\\n   \\n    //abba -->  after we stored a and b  and came again to a than just see if  a-->dog (correspond) and b-->cat\\n        else\\n        {\\n            if(m[pattern[i]]!=word[i])\\n                return false;\\n        }\\n    }\\n    return true;    \\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554542,
                "title": "python-using-zip",
                "content": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        if(len(s.split(\" \")) != len(pattern)):\\n            return False\\n        ar = set(zip(pattern, s.split(\" \")))\\n        b = [i[1] for i in ar]\\n        if(len(ar) == len(set(pattern)) and len(set(b)) == len(ar)):\\n            return True\\n        return False\\n```\\n\\nEvery other solutions seems bit of a  drag",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        if(len(s.split(\" \")) != len(pattern)):\\n            return False\\n        ar = set(zip(pattern, s.split(\" \")))\\n        b = [i[1] for i in ar]\\n        if(len(ar) == len(set(pattern)) and len(set(b)) == len(ar)):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524654,
                "title": "java-faster-solution",
                "content": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        List<String> s1 = Arrays.asList(s.split(\" \"));\\n        if (pattern.length() != s1.size()) {\\n            return false;\\n        }\\n        for (int i = 0; i < pattern.length(); i++) {\\n            if (pattern.indexOf(pattern.charAt(i)) != s1.indexOf(s1.get(i))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        List<String> s1 = Arrays.asList(s.split(\" \"));\\n        if (pattern.length() != s1.size()) {\\n            return false;\\n        }\\n        for (int i = 0; i < pattern.length(); i++) {\\n            if (pattern.indexOf(pattern.charAt(i)) != s1.indexOf(s1.get(i))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502652,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string str) {\\n        \\n        int n = str.size();\\n       \\n        // mp1 will be like (char -> word)\\n        \\n        unordered_map<char, string> mp1;\\n        \\n        // mp2 will be like (word -> char)\\n        \\n        unordered_map<string, char> mp2;\\n        \\n        // count will store the no. of words in str\\n        \\n        int count = 0;\\n        \\n        // k will point to the character of pattern\\n        \\n        int k = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            // find the word\\n            \\n            string word = \"\";\\n            \\n            while(i < n && str[i] != \\' \\')\\n            {\\n                word += str[i];\\n                \\n                i++;\\n            }\\n            \\n            // if pattern[k] is mapped with more than one word\\n            \\n            if(mp1.count(pattern[k]) && mp1[pattern[k]] != word)\\n            {\\n                return false;\\n            }\\n            \\n            // if word is mapped with more than one char\\n            \\n            if(mp2.count(word) && mp2[word] != pattern[k])\\n            {\\n                return false;\\n            }\\n            \\n            // map the pattern[k] with word\\n            \\n            mp1[pattern[k]] = word;\\n            \\n            // map the word with the char\\n            \\n            mp2[word] = pattern[k];\\n            \\n            count++;\\n            \\n            k++;\\n            \\n            i++;\\n        }\\n        \\n        // if no. of words in str is not equal to no. of char in pattern\\n        \\n        if(count != pattern.size())\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string str) {\\n        \\n        int n = str.size();\\n       \\n        // mp1 will be like (char -> word)\\n        \\n        unordered_map<char, string> mp1;\\n        \\n        // mp2 will be like (word -> char)\\n        \\n        unordered_map<string, char> mp2;\\n        \\n        // count will store the no. of words in str\\n        \\n        int count = 0;\\n        \\n        // k will point to the character of pattern\\n        \\n        int k = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            // find the word\\n            \\n            string word = \"\";\\n            \\n            while(i < n && str[i] != \\' \\')\\n            {\\n                word += str[i];\\n                \\n                i++;\\n            }\\n            \\n            // if pattern[k] is mapped with more than one word\\n            \\n            if(mp1.count(pattern[k]) && mp1[pattern[k]] != word)\\n            {\\n                return false;\\n            }\\n            \\n            // if word is mapped with more than one char\\n            \\n            if(mp2.count(word) && mp2[word] != pattern[k])\\n            {\\n                return false;\\n            }\\n            \\n            // map the pattern[k] with word\\n            \\n            mp1[pattern[k]] = word;\\n            \\n            // map the word with the char\\n            \\n            mp2[word] = pattern[k];\\n            \\n            count++;\\n            \\n            k++;\\n            \\n            i++;\\n        }\\n        \\n        // if no. of words in str is not equal to no. of char in pattern\\n        \\n        if(count != pattern.size())\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441012,
                "title": "java-simple-and-fast-solution",
                "content": "```\\npublic boolean wordPattern(String pattern, String s) {\\n        HashMap<Character, String> matching = new HashMap<>();\\n        String[] list = s.split(\" \");\\n        if (list.length != pattern.length()) return false;\\n        for (int index = 0; index < pattern.length(); index++) {\\n            if (matching.containsValue(list[index]) && !matching.containsKey(pattern.charAt(index))) {\\n                return false;\\n            } else if (matching.get(pattern.charAt(index)) == null) {\\n                matching.put(pattern.charAt(index), list[index]);\\n            } else if (!Objects.equals(matching.get(pattern.charAt(index)), list[index])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean wordPattern(String pattern, String s) {\\n        HashMap<Character, String> matching = new HashMap<>();\\n        String[] list = s.split(\" \");\\n        if (list.length != pattern.length()) return false;\\n        for (int index = 0; index < pattern.length(); index++) {\\n            if (matching.containsValue(list[index]) && !matching.containsKey(pattern.charAt(index))) {\\n                return false;\\n            } else if (matching.get(pattern.charAt(index)) == null) {\\n                matching.put(pattern.charAt(index), list[index]);\\n            } else if (!Objects.equals(matching.get(pattern.charAt(index)), list[index])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2285082,
                "title": "word-pattern-o-n-java-solution-using-hashmap",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        \\n       HashMap<Character,String> m=new HashMap<>();\\n        List<String> l=new ArrayList<>();\\n        String s1[]=s.split(\" \");\\n        if(pattern.length()!=s1.length){\\n            return false;\\n        }\\n        for(int i=0;i<pattern.length();i++){\\n            if(!(m.containsKey(pattern.charAt(i)))){\\n                m.put(pattern.charAt(i),s1[i]);\\n                if(l.contains(s1[i])){\\n                    return false;\\n                }\\n                l.add(s1[i]);\\n            }\\n            else{\\n                if(!m.get(pattern.charAt(i)).equals(s1[i])){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        \\n       HashMap<Character,String> m=new HashMap<>();\\n        List<String> l=new ArrayList<>();\\n        String s1[]=s.split(\" \");\\n        if(pattern.length()!=s1.length){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2204066,
                "title": "simple-solution-in-cpp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, string>m;\\n        unordered_set<string>st;\\n        int i, j;\\n        for(i = 0, j = 0; i < pattern.size(); i++, j++){\\n            string tmp;\\n            if(j >= s.size())return false; //if pattern is greater than s\\n            while(j < s.size() and s[j] != \\' \\')tmp += s[j++];\\n            if(m.find(pattern[i]) == m.end()){\\n                if(st.find(tmp) != st.end())return false; // all patterns for particular char is unique\\n                m[pattern[i]] = tmp;\\n                st.insert(tmp);\\n            }\\n            else if(m[pattern[i]] != tmp)return false;\\n        }\\n        if(j < s.size())return false; //if pattern is less than s\\n        return true;\\n    }\\n};\\n```\\n***For Advanced DSA Solutions refer to README files***\\nhttps://github.com/teja963/Advanced-DSA\\n***Find Helpful Do Upvote it***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char, string>m;\\n        unordered_set<string>st;\\n        int i, j;\\n        for(i = 0, j = 0; i < pattern.size(); i++, j++){\\n            string tmp;\\n            if(j >= s.size())return false; //if pattern is greater than s\\n            while(j < s.size() and s[j] != \\' \\')tmp += s[j++];\\n            if(m.find(pattern[i]) == m.end()){\\n                if(st.find(tmp) != st.end())return false; // all patterns for particular char is unique\\n                m[pattern[i]] = tmp;\\n                st.insert(tmp);\\n            }\\n            else if(m[pattern[i]] != tmp)return false;\\n        }\\n        if(j < s.size())return false; //if pattern is less than s\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044750,
                "title": "0ms-100-faster-simple-java-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        if(s.split(\" \").length!=pattern.length())return false;\\n        Map<Character,String>map=new HashMap<>();\\n        int i=0;\\n        for(String str : s.split(\" \")){\\n            if(!map.containsKey(pattern.charAt(i))&&!map.containsValue(str))\\n                map.put(pattern.charAt(i++),str);\\n            else if(map.containsKey(pattern.charAt(i)) && !map.get(pattern.charAt(i)).equals(str))\\n                return false;\\n            else if(!map.containsKey(pattern.charAt(i))&&map.containsValue(str))return false;\\n            else i++;\\n        }\\n        return true;\\n    }\\n}\\n# ```\\n# Time : O(n) linear\\n# Space : O(n) linear\\n# \\n# Please Upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        if(s.split(\" \").length!=pattern.length())return false;\\n        Map<Character,String>map=new HashMap<>();\\n        int i=0;\\n        for(String str : s.split(\" \")){\\n            if(!map.containsKey(pattern.charAt(i))&&!map.containsValue(str))\\n                map.put(pattern.charAt(i++),str);\\n            else if(map.containsKey(pattern.charAt(i)) && !map.get(pattern.charAt(i)).equals(str))\\n                return false;\\n            else if(!map.containsKey(pattern.charAt(i))&&map.containsValue(str))return false;\\n            else i++;\\n        }\\n        return true;\\n    }\\n}\\n# ```",
                "codeTag": "Java"
            },
            {
                "id": 1783064,
                "title": "python-simple-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        \"\"\"\\n        :type pattern: str\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        s = s.split(\" \")\\n        if len(pattern) != len(s) or len(set(s)) != len(set(pattern)):\\n\\t\\t\\treturn False\\n        hash_map = {}\\n        for char in range(len(pattern)):\\n            if pattern[char] not in hash_map:\\n                hash_map[pattern[char]] = s[char]\\n            elif hash_map[pattern[char]] != s[char]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordPattern(self, pattern, s):\\n        \"\"\"\\n        :type pattern: str\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        s = s.split(\" \")\\n        if len(pattern) != len(s) or len(set(s)) != len(set(pattern)):\\n\\t\\t\\treturn False\\n        hash_map = {}\\n        for char in range(len(pattern)):\\n            if pattern[char] not in hash_map:\\n                hash_map[pattern[char]] = s[char]\\n            elif hash_map[pattern[char]] != s[char]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768760,
                "title": "one-line-python-24-ms-faster-than-98-20-of-python3-online-submissions-for-word-pattern",
                "content": "24 ms, faster than 98.20% of Python3  online submissions for Word Pattern...\\n\\n\\t\\tllist1 = [i for i in pattern]\\n        llist2 = list(s.strip(\" \").split(\\' \\'))\\n        findPattern = lambda lst: [lst.index(i) for i in lst]\\n        return findPattern(llist1) == findPattern(llist2) \\n\\nOne line Approach...\\n\\n\\t\\treturn [pattern.index(i) for i in pattern] == [s.split(\" \").index(i) for i in s.split(\" \")]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "24 ms, faster than 98.20% of Python3  online submissions for Word Pattern...\\n\\n\\t\\tllist1 = [i for i in pattern]\\n        llist2 = list(s.strip(\" \").split(\\' \\'))\\n        findPattern = lambda lst: [lst.index(i) for i in lst]\\n        return findPattern(llist1) == findPattern(llist2) \\n\\nOne line Approach...\\n\\n\\t\\treturn [pattern.index(i) for i in pattern] == [s.split(\" \").index(i) for i in s.split(\" \")]",
                "codeTag": "Unknown"
            },
            {
                "id": 1696677,
                "title": "can-you-make-it-run-different-approach-not-accepted",
                "content": "**29 / 36 Test Case Passed**\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<string,int> map;\\n        string word = \"\";\\n        int a = 1;\\n        for(int index = 0 ; index < s.size() ; index++)\\n        {\\n            if(s[index] == \\' \\')\\n            { \\n                if(map[word] > 0) continue;\\n                else\\n                {\\n                  map[word] = a++ ;\\n                  word = \"\";\\n                }\\n            }\\n            else word += s[index];\\n        }\\n        \\n        if(!map[word])\\n        map[word] = a++;\\n        \\n        if(pattern.size() == 1)return 1;\\n        \\n        word = \"\";\\n        string pt = \"\";\\n        \\n        for(int index = 0 ; index < s.size() ; index++)\\n        {\\n            if(s[index] == \\' \\') pt += map[word] + pattern[0] - 1 , word = \"\";\\n            else word += s[index];\\n        }\\n        pt += map[word] + pattern[0] - 1;\\n        cout<<pt; \\n        return pt == pattern;\\n    }\\n};\\n```\\nLast Test Case\\n\"deadbeef\"\\n\"d e a d b e e f\"",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<string,int> map;\\n        string word = \"\";\\n        int a = 1;\\n        for(int index = 0 ; index < s.size() ; index++)\\n        {\\n            if(s[index] == \\' \\')\\n            { \\n                if(map[word] > 0) continue;\\n                else\\n                {\\n                  map[word] = a++ ;\\n                  word = \"\";\\n                }\\n            }\\n            else word += s[index];\\n        }\\n        \\n        if(!map[word])\\n        map[word] = a++;\\n        \\n        if(pattern.size() == 1)return 1;\\n        \\n        word = \"\";\\n        string pt = \"\";\\n        \\n        for(int index = 0 ; index < s.size() ; index++)\\n        {\\n            if(s[index] == \\' \\') pt += map[word] + pattern[0] - 1 , word = \"\";\\n            else word += s[index];\\n        }\\n        pt += map[word] + pattern[0] - 1;\\n        cout<<pt; \\n        return pt == pattern;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1696397,
                "title": "c-faster-than-100-0ms-well-commented-solution",
                "content": "![image](https://assets.leetcode.com/users/images/e6f3450a-e70e-43eb-859e-2a0fa46a3d92_1642402263.0114586.png)\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char,string> m;// to map every char to corresponding word\\n        int p=0;// to iterate s \\n        int c=0;// to count spaces in s\\n        set <string> u;// set to check if the string is already mappped with a key check below for better understanding\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\' \\')// conting number of words in s (spaces+1)\\n                c++;\\n        }\\n        if(c+1!=pattern.length())// if number of word in s is not equal to number of char in pattern false\\n            return 0;\\n        for(int i=0;i<pattern.length();i++)// traverse pattern\\n        {\\n            string k=\"\";// string to form for words in s\\n           \\n            while( p<s.length())\\n            {\\n                if(s[p]==\\' \\')\\n                {\\n                    p++;\\n                    break;\\n                }\\n               k+=s[p];\\n                p++;\\n            }\\n            if(m.find(pattern[i])!=m.end())// if char is already mapped then check if equal to current k(string)\\n            {\\n                if(m[pattern[i]]!=k)// if not return 0(false)\\n                    return 0;\\n            }\\n            else if(m.find(pattern[i])==m.end())// if not found the key pattern(char)\\n            {\\n                if(u.find(k)==u.end())// if the current string is also not mapped earlier\\n                {\\n                    u.insert(k);// insert and map\\n                  m[pattern[i]]=k;\\n                }\\n                else\\n                  return 0;// if string already present we cannot update map return \\n            }       \\n            \\n        }\\n        return 1;// all cases passed return 1 :)\\n    }\\n};\\n```\\n\\nplease upvote if you get it happy coding ;)",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        unordered_map<char,string> m;// to map every char to corresponding word\\n        int p=0;// to iterate s \\n        int c=0;// to count spaces in s\\n        set <string> u;// set to check if the string is already mappped with a key check below for better understanding\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\' \\')// conting number of words in s (spaces+1)\\n                c++;\\n        }\\n        if(c+1!=pattern.length())// if number of word in s is not equal to number of char in pattern false\\n            return 0;\\n        for(int i=0;i<pattern.length();i++)// traverse pattern\\n        {\\n            string k=\"\";// string to form for words in s\\n           \\n            while( p<s.length())\\n            {\\n                if(s[p]==\\' \\')\\n                {\\n                    p++;\\n                    break;\\n                }\\n               k+=s[p];\\n                p++;\\n            }\\n            if(m.find(pattern[i])!=m.end())// if char is already mapped then check if equal to current k(string)\\n            {\\n                if(m[pattern[i]]!=k)// if not return 0(false)\\n                    return 0;\\n            }\\n            else if(m.find(pattern[i])==m.end())// if not found the key pattern(char)\\n            {\\n                if(u.find(k)==u.end())// if the current string is also not mapped earlier\\n                {\\n                    u.insert(k);// insert and map\\n                  m[pattern[i]]=k;\\n                }\\n                else\\n                  return 0;// if string already present we cannot update map return \\n            }       \\n            \\n        }\\n        return 1;// all cases passed return 1 :)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668131,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        string word;\\n        vector<string>v;\\n        stringstream obj(s);\\n        while (obj >> word) v.push_back(word);   // To push each word in vector\\n        \\n        if(pattern.size() != v.size()) return false; \\n        \\n        unordered_map<char, string>mp;\\n        unordered_set<string>st;\\n        for(int i = 0; i < pattern.size(); i++){\\n            if(mp.find(pattern[i]) == mp.end()){\\n                if(st.find(v[i]) == st.end()){\\n                    mp[pattern[i]] = v[i];\\n                    st.insert(v[i]);\\n                }\\n                else return false;\\n            }\\n            else \\n\\t\\t\\t\\tif(mp[pattern[i]] != v[i]) return false;  \\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        string word;\\n        vector<string>v;\\n        stringstream obj(s);\\n        while (obj >> word) v.push_back(word);   // To push each word in vector\\n        \\n        if(pattern.size() != v.size()) return false; \\n        \\n        unordered_map<char, string>mp;\\n        unordered_set<string>st;\\n        for(int i = 0; i < pattern.size(); i++){\\n            if(mp.find(pattern[i]) == mp.end()){\\n                if(st.find(v[i]) == st.end()){\\n                    mp[pattern[i]] = v[i];\\n                    st.insert(v[i]);\\n                }\\n                else return false;\\n            }\\n            else \\n\\t\\t\\t\\tif(mp[pattern[i]] != v[i]) return false;  \\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604543,
                "title": "100-faster-c-solution-using-hashmap",
                "content": "```\\n   bool wordPattern(string pattern, string s) {\\n        vector<string>word;\\n        string str=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                word.push_back(str);\\n                str=\"\";\\n            }\\n            else if(i==s.length()-1){\\n                str += s[i];\\n                word.push_back(str);\\n            }\\n            else{\\n                str += s[i];\\n            }\\n        }\\n        if(word.size()!=pattern.size()){\\n            return false;\\n        }\\n        vector<int>v1,v2;\\n        unordered_map<char,int>mp1;\\n        unordered_map<string,int>mp2;\\n        for(int i=0;i<pattern.size();i++){\\n            if(mp1[pattern[i]]==0){\\n                mp1[pattern[i]]=i+1;\\n            }\\n            if(mp2[word[i]]==0){\\n                mp2[word[i]]=i+1;\\n            }\\n            v1.push_back(mp1[pattern[i]]);\\n            v2.push_back(mp2[word[i]]);\\n        }\\n        if(v1==v2){\\n            return true;\\n        }\\n        return false;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n   bool wordPattern(string pattern, string s) {\\n        vector<string>word;\\n        string str=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                word.push_back(str);\\n                str=\"\";\\n            }\\n            else if(i==s.length()-1){\\n                str += s[i];\\n                word.push_back(str);\\n            }\\n            else{\\n                str += s[i];\\n            }\\n        }\\n        if(word.size()!=pattern.size()){\\n            return false;\\n        }\\n        vector<int>v1,v2;\\n        unordered_map<char,int>mp1;\\n        unordered_map<string,int>mp2;\\n        for(int i=0;i<pattern.size();i++){\\n            if(mp1[pattern[i]]==0){\\n                mp1[pattern[i]]=i+1;\\n            }\\n            if(mp2[word[i]]==0){\\n                mp2[word[i]]=i+1;\\n            }\\n            v1.push_back(mp1[pattern[i]]);\\n            v2.push_back(mp2[word[i]]);\\n        }\\n        if(v1==v2){\\n            return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1536196,
                "title": "c-0ms-faster-than-100-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> mp;\\n        int j=0,i=0,np=p.size(),ns=s.size();\\n        while(i<np && j<ns){\\n            string t=\"\";\\n            while(j<ns && s[j]!=\\' \\')t+=s[j++];\\n            if(mp.count(p[i])){\\n                if(mp[p[i]]!=t) return false;\\n            } \\n            else {\\n                for(auto x:mp)\\n                    if(x.second==t)return false;\\n                mp[p[i]]=t;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return i==np && j==ns+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> mp;\\n        int j=0,i=0,np=p.size(),ns=s.size();\\n        while(i<np && j<ns){\\n            string t=\"\";\\n            while(j<ns && s[j]!=\\' \\')t+=s[j++];\\n            if(mp.count(p[i])){\\n                if(mp[p[i]]!=t) return false;\\n            } \\n            else {\\n                for(auto x:mp)\\n                    if(x.second==t)return false;\\n                mp[p[i]]=t;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return i==np && j==ns+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470489,
                "title": "character-mapping-dictionary-easy-to-understand",
                "content": "Hi Everyone, ***(Jump directly to code for detailed explanation)***\\n\\nI have tried to explain ***how to map characters between two equivalent form of inputs*** and find out if they are following certain conditions or not. If you are solving this, I will suggest that ***knowing the concept*** ***of Isomorphic Strings (and the problem associated with it)*** will be very useful as it is based on this exact concept used in the question.\\n\\n***Time Complexity - O(N)\\nSpace Complexity - O(N)***\\n\\n\\nNote - ***Below code takes test case 1 as input to show the flow of code at each step***\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        \\n        #i/p : pattern = \"abba\" and s = \"dog cat cat dog\"\\n        \\n        arr1 = list(pattern) #arr1 = [\"a\", \"b\", \"b\", \"a\"] \\n        arr2 = s.split() #arr2 = [\"dog\", \"cat\", \"cat\", \"dog\"]\\n        n = len(arr2) #len(arr1) == len(arr2) in all cases where True is possible \\n        \\n        if len(arr1) != len(arr2): #we will never be able to map all characters \\n            return False\\n        \\n        d1 = {} #to handle character mapping from arr1 to arr2 \\n        d2 = {} #to handle character mapping from arr2 to arr1\\n        \\n        #Below is our character mapping logic\\n        \\n        for i in range(0, n):\\n            \\n            if arr1[i] in d1 and d1[arr1[i]] != arr2[i]:\\n                return False\\n            \\n            if arr2[i] in d2 and d2[arr2[i]] != arr1[i]:\\n                return False\\n            \\n            d1[arr1[i]] = arr2[i] #after all loops : d1 = {\"a\" : \"dog\", \"b\" : \"cat\"}\\n            d2[arr2[i]] = arr1[i] #after all loops : d2 = {\"dog\" : \"a\", \"cat\" : \"b\"}\\n        \\n\\t\\t#if none of the above condition returns False\\n\\t\\t#it means that all characters of arr1 can be legally mapped to arr2, so, return True\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        \\n        #i/p : pattern = \"abba\" and s = \"dog cat cat dog\"\\n        \\n        arr1 = list(pattern) #arr1 = [\"a\", \"b\", \"b\", \"a\"] \\n        arr2 = s.split() #arr2 = [\"dog\", \"cat\", \"cat\", \"dog\"]\\n        n = len(arr2) #len(arr1) == len(arr2) in all cases where True is possible \\n        \\n        if len(arr1) != len(arr2): #we will never be able to map all characters \\n            return False\\n        \\n        d1 = {} #to handle character mapping from arr1 to arr2 \\n        d2 = {} #to handle character mapping from arr2 to arr1\\n        \\n        #Below is our character mapping logic\\n        \\n        for i in range(0, n):\\n            \\n            if arr1[i] in d1 and d1[arr1[i]] != arr2[i]:\\n                return False\\n            \\n            if arr2[i] in d2 and d2[arr2[i]] != arr1[i]:\\n                return False\\n            \\n            d1[arr1[i]] = arr2[i] #after all loops : d1 = {\"a\" : \"dog\", \"b\" : \"cat\"}\\n            d2[arr2[i]] = arr1[i] #after all loops : d2 = {\"dog\" : \"a\", \"cat\" : \"b\"}\\n        \\n\\t\\t#if none of the above condition returns False\\n\\t\\t#it means that all characters of arr1 can be legally mapped to arr2, so, return True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377498,
                "title": "c-0-ms-faster-100-tokenized-two-maps",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n\\n        vector<string> tokens;\\n        int startIndex = 0;\\n        \\n        for(int i = 0; i < s.size(); i++ ) {\\n            if ( s[i] == \\' \\' ) {\\n                tokens.push_back(s.substr(startIndex, i - startIndex));\\n                startIndex = i + 1;\\n            }\\n        }\\n        \\n        if ( pattern.size() != tokens.size() ) { return false; }\\n        \\n        map<char, string> charMap;\\n        map<string, char> strMap;\\n                \\n        for(int i = 0; i < pattern.size(); i++) {\\n            \\n            if ( charMap.count(pattern[i]) == 0 && strMap.count(tokens[i]) == 0) {\\n                \\n                charMap[pattern[i]] = tokens[i];\\n                strMap[tokens[i]] = pattern[i];\\n            }\\n            \\n            if ( tokens[i] != charMap[pattern[i]] ) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n\\n        vector<string> tokens;\\n        int startIndex = 0;\\n        \\n        for(int i = 0; i < s.size(); i++ ) {\\n            if ( s[i] == \\' \\' ) {\\n                tokens.push_back(s.substr(startIndex, i - startIndex));\\n                startIndex = i + 1;\\n            }\\n        }\\n        \\n        if ( pattern.size() != tokens.size() ) { return false; }\\n        \\n        map<char, string> charMap;\\n        map<string, char> strMap;\\n                \\n        for(int i = 0; i < pattern.size(); i++) {\\n            \\n            if ( charMap.count(pattern[i]) == 0 && strMap.count(tokens[i]) == 0) {\\n                \\n                charMap[pattern[i]] = tokens[i];\\n                strMap[tokens[i]] = pattern[i];\\n            }\\n            \\n            if ( tokens[i] != charMap[pattern[i]] ) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288499,
                "title": "100-faster-java-solution",
                "content": "```\\npublic boolean wordPattern(String pattern, String s) {\\n\\tString[] words = s.split(\" \");\\n\\t//Return false if the pattern and amount of words are different lengths\\n\\tif(words.length != pattern.length()){\\n\\t\\treturn false;\\n\\t}\\n\\n\\tHashMap<Character, String> map = new HashMap<Character, String>();\\n\\tfor(int i = 0; i < pattern.length(); i++){\\n\\t\\tchar c = pattern.charAt(i);\\n\\t\\tif(map.containsKey(c)){\\n\\t\\t\\t//Return false if the map contains the key but has a differing value already assigned\\n\\t\\t\\tif(!map.get(c).equals(words[i])){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//Return false if the value is already in the map, but the key is not\\n\\t\\telse if(map.containsValue(words[i])){\\n\\t\\t\\treturn false;\\n\\n\\t\\t}\\n\\t\\t//Add the key value pair to the map if the key and value are not already in it\\n\\t\\telse{\\n\\t\\t\\tmap.put(c, words[i]);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean wordPattern(String pattern, String s) {\\n\\tString[] words = s.split(\" \");\\n\\t//Return false if the pattern and amount of words are different lengths\\n\\tif(words.length != pattern.length()){\\n\\t\\treturn false;\\n\\t}\\n\\n\\tHashMap<Character, String> map = new HashMap<Character, String>();\\n\\tfor(int i = 0; i < pattern.length(); i++){\\n\\t\\tchar c = pattern.charAt(i);\\n\\t\\tif(map.containsKey(c)){\\n\\t\\t\\t//Return false if the map contains the key but has a differing value already assigned\\n\\t\\t\\tif(!map.get(c).equals(words[i])){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//Return false if the value is already in the map, but the key is not\\n\\t\\telse if(map.containsValue(words[i])){\\n\\t\\t\\treturn false;\\n\\n\\t\\t}\\n\\t\\t//Add the key value pair to the map if the key and value are not already in it\\n\\t\\telse{\\n\\t\\t\\tmap.put(c, words[i]);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261727,
                "title": "rust-0ms-hashmap",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn word_pattern(pattern: String, s: String) -> bool {\\n        \\n        let words : Vec<String> = s.split(\\' \\').map(|x| String::from(x)).collect();\\n        if words.len() != pattern.len() {\\n            return false;\\n        }\\n        \\n        let mut pmap : HashMap<char, Vec<usize>> = HashMap::new();\\n        let mut wmap : HashMap<String, Vec<usize>> = HashMap::new();\\n        \\n        for (i, c) in pattern.chars().enumerate() {\\n            let v1 = wmap.entry(words[i].clone()).or_insert(vec![]);\\n            v1.push(i);\\n            let v2 = pmap.entry(c).or_insert(vec![]);\\n            v2.push(i);\\n        }\\n        \\n        for (c,w) in pattern.chars().zip(words.iter()) {\\n            if wmap[w] != pmap[&c] {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn word_pattern(pattern: String, s: String) -> bool {\\n        \\n        let words : Vec<String> = s.split(\\' \\').map(|x| String::from(x)).collect();\\n        if words.len() != pattern.len() {\\n            return false;\\n        }\\n        \\n        let mut pmap : HashMap<char, Vec<usize>> = HashMap::new();\\n        let mut wmap : HashMap<String, Vec<usize>> = HashMap::new();\\n        \\n        for (i, c) in pattern.chars().enumerate() {\\n            let v1 = wmap.entry(words[i].clone()).or_insert(vec![]);\\n            v1.push(i);\\n            let v2 = pmap.entry(c).or_insert(vec![]);\\n            v2.push(i);\\n        }\\n        \\n        for (c,w) in pattern.chars().zip(words.iter()) {\\n            if wmap[w] != pmap[&c] {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194802,
                "title": "100-faster-code-with-explanation",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n***Read Explanation and code once , you will definitely get it***\\n\\n**Quick Explanation:-**\\n**1.** Push all the words present in the string in the vector.\\n**2.** If the size of vector and length of pattern string is unequal then return false.\\n**3.** Take a map and a set.\\n**4.** If we have found the char already present in the map , then we check whether both the words in map and vector are same or not . If not return false.\\n**5.** If char is not present in the map but the word is already present in the string, then we return false because it surely belongs to some different char.\\n**6.** Push the char and string into the map and the string into the set.\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> v;\\n        int i = 0;\\n        string temp = \"\";\\n        while(i < s.length())\\n        {\\n            if(s[i] == \\' \\')\\n            {\\n                v.push_back(temp);\\n                temp = \"\";\\n            }\\n            else\\n            {\\n                temp+=s[i];\\n            }\\n            i++;\\n        }\\n        v.push_back(temp);\\n\\t\\t\\n        if(v.size() != pattern.length())\\n            return false;\\n\\t\\t\\t\\n        unordered_map<char,string> u;\\n        set<string> st;\\n        for(i = 0 ; i<pattern.length() ; i++)\\n        {\\n            if(u.find(pattern[i]) != u.end())\\n            {\\n                if(u[pattern[i]] != v[i])\\n                { \\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n            }\\n            else{\\n                \\n                if(st.count(v[i]) > 0)\\n                {\\n                    return false;\\n                }\\n              u[pattern[i]] = v[i];\\n              st.insert(v[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string> v;\\n        int i = 0;\\n        string temp = \"\";\\n        while(i < s.length())\\n        {\\n            if(s[i] == \\' \\')\\n            {\\n                v.push_back(temp);\\n                temp = \"\";\\n            }\\n            else\\n            {\\n                temp+=s[i];\\n            }\\n            i++;\\n        }\\n        v.push_back(temp);\\n\\t\\t\\n        if(v.size() != pattern.length())\\n            return false;\\n\\t\\t\\t\\n        unordered_map<char,string> u;\\n        set<string> st;\\n        for(i = 0 ; i<pattern.length() ; i++)\\n        {\\n            if(u.find(pattern[i]) != u.end())\\n            {\\n                if(u[pattern[i]] != v[i])\\n                { \\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n            }\\n            else{\\n                \\n                if(st.count(v[i]) > 0)\\n                {\\n                    return false;\\n                }\\n              u[pattern[i]] = v[i];\\n              st.insert(v[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169247,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String str) {\\n        String[] s=str.split(\" \");\\n     HashMap<Character,String> map=new HashMap<Character,String>();\\n\\t\\tif(s.length!=pattern.length())\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<s.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(map.containsKey(pattern.charAt(i)))\\n\\t\\t\\t{\\n\\t\\t\\t  if(!(map.get(pattern.charAt(i))).equals(s[i]))\\n\\t\\t\\t  {\\n\\t\\t\\t\\t  return false;\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(map.containsValue(s[i]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(pattern.charAt(i), s[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordPattern(String pattern, String str) {\\n        String[] s=str.split(\" \");\\n     HashMap<Character,String> map=new HashMap<Character,String>();\\n\\t\\tif(s.length!=pattern.length())\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<s.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(map.containsKey(pattern.charAt(i)))\\n\\t\\t\\t{\\n\\t\\t\\t  if(!(map.get(pattern.charAt(i))).equals(s[i]))\\n\\t\\t\\t  {\\n\\t\\t\\t\\t  return false;\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(map.containsValue(s[i]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(pattern.charAt(i), s[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834860,
                "title": "c-python-2-hashmap-for-2-way-mapping-checking",
                "content": "Solution 1: Smarter with two tricks \\n```\\nclass Solution { // use two hashmap to handle bijection (two direction mapping) validation, [1]\\npublic:\\n    bool wordPattern(string pattern, string str) {\\n        unordered_map<char, int> p2i;\\n        unordered_map<string, int> w2i;\\n        istringstream in(str);\\n        int i = 0, n = pattern.size();\\n        for (string word; in >> word; ++i) { // read word in str on the fly\\n            if (i == n || p2i[pattern[i]] != w2i[word]) return false;\\n            //avoid collision: use i + 1 as the value to avoid 0 since map will assign default 0 value for non-existing keys\\n            p2i[pattern[i]] = w2i[word] = i + 1; \\n        }\\n        return i == n;\\n    }\\n};\\n```\\n\\nSolution 2: Straightforward solution\\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string str) {\\n        unordered_map<char, int> dict;\\n        const int n1 = pattern.size();\\n        if(n1 == 0) return false;\\n        string encoding; //On example 1,  \"abba\" -> \"0110\"\\n        for(int i = 0; i < n1; i++){            \\n            if( !dict.count(pattern[i])) dict[pattern[i]] = i;\\n            encoding+=dict[pattern[i]];\\n        }\\n        stringstream ss(str);\\n        string word;\\n        int i = 0;        \\n        unordered_map<string, int> dict2; // on example 1: {\"dog\":0, \"cat\":1}\\n        while(ss>>word){ // read\\n            if(i>n1) return false;            \\n            if(!dict2.count(word)) dict2[word] = i;\\n            if(dict2[word] != encoding[i]) return false;\\n            i++;            \\n        }\\n        return i == n1;\\n    }\\n};\\n```\\n\\nSolution 3: Python\\n```\\nclass Solution: \\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        map_char = {}\\n        map_word = {}\\n        \\n        words = str.split(\\' \\')\\n        if len(words) != len(pattern):\\n            return False\\n        \\n        for c, w in zip(pattern, words):\\n            if c not in map_char:\\n                if w in map_word: #case 1: NY, not matched\\n                    return False\\n                else:             #case 2: YY. matched\\n                    map_char[c] = w\\n                    map_word[w] = c\\n            else:                 #case 3: YN, not matched\\n                if map_char[c] != w:\\n                    return False\\n                #else:            #case 4: YY. matched\\n        return True\\n```\\nReference:\\n[1] https://leetcode.com/problems/word-pattern/discuss/73409/Short-C%2B%2B-read-words-on-the-fly\\n[2] https://leetcode.com/problems/word-pattern/solution/",
                "solutionTags": [],
                "code": "```\\nclass Solution { // use two hashmap to handle bijection (two direction mapping) validation, [1]\\npublic:\\n    bool wordPattern(string pattern, string str) {\\n        unordered_map<char, int> p2i;\\n        unordered_map<string, int> w2i;\\n        istringstream in(str);\\n        int i = 0, n = pattern.size();\\n        for (string word; in >> word; ++i) { // read word in str on the fly\\n            if (i == n || p2i[pattern[i]] != w2i[word]) return false;\\n            //avoid collision: use i + 1 as the value to avoid 0 since map will assign default 0 value for non-existing keys\\n            p2i[pattern[i]] = w2i[word] = i + 1; \\n        }\\n        return i == n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string str) {\\n        unordered_map<char, int> dict;\\n        const int n1 = pattern.size();\\n        if(n1 == 0) return false;\\n        string encoding; //On example 1,  \"abba\" -> \"0110\"\\n        for(int i = 0; i < n1; i++){            \\n            if( !dict.count(pattern[i])) dict[pattern[i]] = i;\\n            encoding+=dict[pattern[i]];\\n        }\\n        stringstream ss(str);\\n        string word;\\n        int i = 0;        \\n        unordered_map<string, int> dict2; // on example 1: {\"dog\":0, \"cat\":1}\\n        while(ss>>word){ // read\\n            if(i>n1) return false;            \\n            if(!dict2.count(word)) dict2[word] = i;\\n            if(dict2[word] != encoding[i]) return false;\\n            i++;            \\n        }\\n        return i == n1;\\n    }\\n};\\n```\n```\\nclass Solution: \\n    def wordPattern(self, pattern: str, str: str) -> bool:\\n        map_char = {}\\n        map_word = {}\\n        \\n        words = str.split(\\' \\')\\n        if len(words) != len(pattern):\\n            return False\\n        \\n        for c, w in zip(pattern, words):\\n            if c not in map_char:\\n                if w in map_word: #case 1: NY, not matched\\n                    return False\\n                else:             #case 2: YY. matched\\n                    map_char[c] = w\\n                    map_word[w] = c\\n            else:                 #case 3: YN, not matched\\n                if map_char[c] != w:\\n                    return False\\n                #else:            #case 4: YY. matched\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834656,
                "title": "c-2-pointers-efficient-solution-constant-memory-explained-100-time-100-space",
                "content": "Okay, I approached this problem this morning with an odd approach.\\n\\nI knew what I did NOT want to use both to save resources and give myself an extra challenge:\\n* hashmaps to map characters to substrings;\\n* storing substrings;\\n* string streams or equivalent.\\n\\nAnd I decided to use an array of pairs (`seen`) to store the beginning and the end of each substring, as simple integers and accessing said array taking the value of each character in `pattern` and subtracting `\\'a\\'` to it (thus getting a `0 - 25` value.\\n\\nI initialised all the pairs in `seen` to be `{-1, -1}` in order to know which values I did not see yet and, after declaring a few support variables (`i`, `j` and `len`), I was able to start grinding through all the characters in `pattern`.\\n\\nFirst of all, I would convert the value of the character `c` to be in the `0 - 25` range, as mentioned, then I will increase `j` until it either meets the next space or reaches the end of `str`.\\n\\nAfter that, 2 things can happen:\\n* if I have never encountered that specific `c` (and thus `seen[c].first == -1`), I would check if any other character before matched the same string from `i` to `j` (excluded) and if so, return `false` (I discovered this requirement the hard way and find it silly, but okay...) otherwise add both pointers to `seen`;\\n* if it is a value I already encountered, I would check if the current substring between `i` and `j` matches the equivalent pair in `seen[c]` and if not, return `false`.\\n\\nAfter I am done, I set `i` to be `j + 1` and j to be `i + 1` - ready for the next substring or matching the end of the word.\\n\\nNow, a few more words on string comparisons: they are done using the helper `compareStringByIndexes` that first of all compares their length (and saves me the pain of a few edge cases), then compares if they match character by character - if either test fails, it returns `false`, otherwise it returns `true`.\\n\\nIf I am done with the main loop, I just need to return if `i == len + 1` - meaning all the substrings in `str` matched the same character in `pattern` and there is not a single one left uncounted for :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool compareStringByIndexes(string &str, int i, int j, int strStart, int strEnd) {\\n        // checking if both strings have the same length\\n        if (j - i != strEnd - strStart) return false;\\n        // checking characters one by one\\n        for (int k = i, l = strStart; k < j; k++) if (str[k] != str[l++]) return false;\\n        return true;\\n    }\\n    bool wordPattern(string pattern, string str) {\\n        pair<int, int> seen[26];\\n        int i = 0, j = 1, len = str.size();\\n        for (auto &s: seen) s = {-1, -1};\\n        for (char c: pattern) {\\n            // moving j to the end of the next word (or of the string)\\n            while (j < len && str[j] != \\' \\') j++;\\n            c -= \\'a\\';\\n            if (seen[c].first == -1) {\\n                // need to check if it is identical to an already found match, for some reason\\n                for (auto s: seen) if (s.first != -1 && compareStringByIndexes(str, i, j, s.first, s.second)) return false;\\n                // otherwise, we just add the new string to seen\\n                seen[c] = {i, j};\\n            } else {\\n                if (!compareStringByIndexes(str, i, j, seen[c].first, seen[c].second)) return false;\\n            };\\n            // updating i and j\\n            i = j + 1;\\n            j = i + 1;\\n        }\\n        return i == len + 1;\\n    }\\n};\\n```\\nIf you fancy, [similar solution to a similar problem](https://leetcode.com/problems/isomorphic-strings/discuss/836844/).",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool compareStringByIndexes(string &str, int i, int j, int strStart, int strEnd) {\\n        // checking if both strings have the same length\\n        if (j - i != strEnd - strStart) return false;\\n        // checking characters one by one\\n        for (int k = i, l = strStart; k < j; k++) if (str[k] != str[l++]) return false;\\n        return true;\\n    }\\n    bool wordPattern(string pattern, string str) {\\n        pair<int, int> seen[26];\\n        int i = 0, j = 1, len = str.size();\\n        for (auto &s: seen) s = {-1, -1};\\n        for (char c: pattern) {\\n            // moving j to the end of the next word (or of the string)\\n            while (j < len && str[j] != \\' \\') j++;\\n            c -= \\'a\\';\\n            if (seen[c].first == -1) {\\n                // need to check if it is identical to an already found match, for some reason\\n                for (auto s: seen) if (s.first != -1 && compareStringByIndexes(str, i, j, s.first, s.second)) return false;\\n                // otherwise, we just add the new string to seen\\n                seen[c] = {i, j};\\n            } else {\\n                if (!compareStringByIndexes(str, i, j, seen[c].first, seen[c].second)) return false;\\n            };\\n            // updating i and j\\n            i = j + 1;\\n            j = i + 1;\\n        }\\n        return i == len + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1735921,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1571541,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1735918,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1735971,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1736350,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1736633,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1566776,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1567946,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1735990,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1736393,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1735921,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1571541,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1735918,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1735971,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1736350,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1736633,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1566776,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1567946,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1735990,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1736393,
                "content": [
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better. \\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n1. each character in pattern represents a word in s\\n2. No two distinct characters in pattern can represent the same word in s\\n3. No single character in pattern can represent two distinct words in s.\\n\\ne.g.:\\n1. pattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\'  represents \\'dog\\' and \\'b\\' represents cat\\n\\n2. pattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.) \\n\\n3. pattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "jumanamurad1",
                        "content": "That was so useful, Thank you 🙏🏼"
                    },
                    {
                        "username": "GanaVaraha108",
                        "content": "Thanks \\n"
                    },
                    {
                        "username": "george333",
                        "content": "Yes the description did not make any sense!"
                    },
                    {
                        "username": "richgod93",
                        "content": "I agree that this problem is poorly worded."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "[@alxolr](/alxolr) \\nA bijection is a case where\\n1.  each element of set 1 has a corresponding match in set 2 and vice versa,\\n2.  no two elements of set 1 can match with a single element of set 2\\n3.  no two elements of set 2 can match with a single element of set 1\\n\\nhere set 1 = characters in pattern\\nset 2 = words in the string.\\nPoint #1 means that number of words in set2 == number of characters in set 1"
                    },
                    {
                        "username": "siamaktj",
                        "content": "I did not get the qs until I read your explanation !! thank you \\uD83D\\uDC4D\\uD83C\\uDFFD"
                    },
                    {
                        "username": "hari4742",
                        "content": "Thanks, that\\'s really helpful"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Actually bijections means same only what u written in simplified way!!"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@alxolr](/alxolr) same i too failed probably this is best test case for this problem and critical one too!!\\nhere is my code that failed for this test case I used hashing to solve problem !!\\nbool wordPattern(string pattern, string s) {\\n        int n=pattern.size();\\n        char arr[n];\\n        for(int i=0;i<n;i++)\\n        arr[i]=pattern[i];\\n        vector<string> vec;\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                vec.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=s[i];\\n            }\\n        }\\n        vec.push_back(str);\\n        if(vec.size()!=n) return false;\\n        int j=0;\\n        unordered_map<char,string> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(arr[i])==mp.end()){\\n                mp[arr[i]]=vec[i];\\n            }else{\\n                if(mp[arr[i]]!=vec[i]) return false;\\n            }\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "piyushbora1999",
                        "content": "I think you should understand wha a bijection means, and that makes it clear. IMO the wording in the problem is fine!"
                    },
                    {
                        "username": "anandatleetcode",
                        "content": "thanks for explaining !"
                    },
                    {
                        "username": "arjun202",
                        "content": "[@alxolr](/alxolr) it is returning false , not true."
                    },
                    {
                        "username": "alxolr",
                        "content": "There is a test case which I failed and doesn't follow the rule:\n>No two distinct characters in pattern can represent the same word in s\n```\npattern = \"abba\"\ns = \"dog dog dog dog\"\noutput: true\n```\nWhich I don't get.\n"
                    },
                    {
                        "username": "rohitmittal",
                        "content": "Worst problem statement ever! Please explain and re-write the problem statement."
                    },
                    {
                        "username": "Suraj_Nanavare",
                        "content": "yesssssssssssssssss"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Question clearly mentions the word bijection. Even the people not aware about bijection gets the chance to google it and learn some basic math terms. This way, the question remains understandable even if someone is not clear at the first place. Is this not better??"
                    },
                    {
                        "username": "w0nt0nb4c0n",
                        "content": "[@dkashi](/dkashi) thank you friend"
                    },
                    {
                        "username": "dkashi",
                        "content": "Poorly worded problem. Here is an attempt to explain it better.\\n\\nGiven a pattern and a string s, find if s follows the same pattern. pattern and s are same if:\\n\\neach character in pattern represents a word in s\\nNo two distinct characters in pattern can represent the same word in s\\nNo single character in pattern can represent two distinct words in s.\\ne.g.:\\n\\npattern = \\'abab\\'; s = \\'dog cat dog cat\\'; return True\\n\\'a\\' represents \\'dog\\' and \\'b\\' represents cat\\n\\npattern = \\'abcb\\'; s = \\'dog cat dog cat\\'; return False\\n\\'a\\' represents \\'dog\\', \\'b\\' represents \\'cat\\'. Then \\'c\\' cannot represent \\'dog\\' again as \\'a\\' already represents \\'dog\\' (#2 condition is: No two distinct characters in pattern i.e. \\'a\\' and \\'c\\' can represent same word i.e \\'dog\\'.)\\n\\npattern = \\'abcb\\'; s = \\'dog cat hat cat\\'; return True\\n\\'a\\' represents \\'dog\\'; \\'b\\' represents \\'cat\\'; \\'c\\' represents \\'hat\\'; and last \\'cat\\' is already represented by \\'b\\' and last character in pattern is also \\'b\\'.\\n\\nHope this helps!"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) I totally agree. I was just able to figure out what was being asked when I read the Word Pattern II problem. There it is much better explained."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos) thanks man i appreciate your help..\\n\\nI solved this question but to be very honest the problem statement is worst i still dislike this question."
                    },
                    {
                        "username": "leocampos",
                        "content": "[@jaiyadav](/jaiyadav) Because a single letter pattern will always be true for a single word.\\n\\nLet me see if I can explain: Imagine pattern\\nabcdce\\nand s \"I am a not a German\"\\n\\na is the first letter of the pattern, it should be matched with the first Word \"I\", since there is no \"a\" in the pattern, there should be no more \"I\" word in the text;\\nb is then matched to \"am\"\\nc is matched to \"a\"\\nd is matched to \"not\"\\n\\nsince at this position \"c\" appears again, c was already matched, so \"a\" should be in the String, and it is.\\ne is matched to \"German\".\\n\\nSee that for a single character, it will always match the first word. If it is the only word, it is true, if not, it is false."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@leocampos](/leocampos)   pattern =\\n\"e\"\\ns =\\n\"eukera\" \\nwhy this is giving true then\\n"
                    },
                    {
                        "username": "leocampos",
                        "content": "What I understood is that each letter in the pattern should be represented as a word in the s string.\\n\\nSo, for pattern \"abba\" and s \"dog cat cat dog\"\\na relates to dog, b to cat. So, a dog, two cats and yet another dog is expected."
                    },
                    {
                        "username": "charkhaniakash",
                        "content": "True even i am also thinking in wrong way\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Easy-difficulty problem to start out the year 2023! Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "p190095",
                        "content": "[@rahulkumarbaraswal30](/rahulkumarbaraswal30) \\n Do you solve the problem by yourself or with help of tutorial solution that doesn\\'t matter a lot , do you understand the code or not , that matters .\\n"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Perfect simple problem for being hangover. Happy New Year."
                    },
                    {
                        "username": "rahulkumarbaraswal30",
                        "content": "Do you solve the problem by yourself or with help of tutorial solution let me know."
                    },
                    {
                        "username": "shyam07",
                        "content": "happy new year"
                    },
                    {
                        "username": "odyssey1048",
                        "content": "Happy New Year and happy hacking!"
                    },
                    {
                        "username": "Cam18",
                        "content": "Happy new years\\n"
                    },
                    {
                        "username": "Maheshreddy5599",
                        "content": "haha really the description lol "
                    },
                    {
                        "username": "72engineers",
                        "content": "Thanks God, 2023 begins with an easy problem, this would mean all of the people in LeetCode community would have an easy 2023! Happy new year to Everyone!"
                    },
                    {
                        "username": "Malavipande",
                        "content": "Lol XD"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "A Hard but easy problem to finish the year.\\nAnd now An Easy but hard problem to start the year.\\n\\nWell Played LeetCode \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Priyesh1997",
                        "content": "true"
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "well said !!\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This question level needs to medium..\\nagree or not.."
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "Probably yes, although the difficulty comes more from the extremely poor explanation, rather than from the algorithm itself"
                    },
                    {
                        "username": "luofun",
                        "content": "![0_1509037172269_0c49ce74-866a-4e1f-85d1-10f906c54af3-image.png](/assets/uploads/files/1509037178417-0c49ce74-866a-4e1f-85d1-10f906c54af3-image-resized.png)"
                    },
                    {
                        "username": "eduard92",
                        "content": "[@harisriram2002](/harisriram2002) the routing to replies doesn\\'t work anyways..."
                    },
                    {
                        "username": "gajjarjenil2004",
                        "content": "I think you should use dictionary/map "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@user1618PE](/user1618PE)  You are replying to a comment that was made atleast 5 years ago"
                    },
                    {
                        "username": "user1618PE",
                        "content": "What is the language are you using luofun? In Python3 I am getting LeetCode answer as true"
                    },
                    {
                        "username": "frederic.chen.35",
                        "content": "when input\\n 'aaa'\\n'aa aa aa aa'\\n\\nleetcode give true and it should be false I think"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "just make an if statement in the beginning that if (pattern.length() != word.size()) return false;\\nhere i have taken word a vector of string data type"
                    },
                    {
                        "username": "Jay9874",
                        "content": "No, the number of words and characters are not same."
                    },
                    {
                        "username": "wangchao426",
                        "content": "no, leetcode gives false"
                    },
                    {
                        "username": "nishant7372",
                        "content": "number of words in `s` should be equal to number of letters in `pattern`."
                    },
                    {
                        "username": "ursachu",
                        "content": "Yeah but it\\'s doesn\\'t match the strict pattern. Something like a* in regex"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Perfect Easy Level Problem to start 2023! But carefully read the problem statement:)"
                    },
                    {
                        "username": "devhindo",
                        "content": "this should be a medium problem"
                    }
                ]
            },
            {
                "id": 1565922,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 1569349,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 1569233,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 1736239,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 2017736,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 1736272,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 1950677,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 1928119,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 1735998,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 2030208,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Hash Maps\n\n  \n**Approach 2:** Single Index Hash Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "smeraldo",
                        "content": "input pattern shouldn\\'t begin with \"a\" ?"
                    },
                    {
                        "username": "GoodGame-WellPlay",
                        "content": "\\tstr = str.split(\\' \\')\\n\\tif  not len(str) == len(pattern):\\n\\t\\t\\treturn False\\n\\treturn len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "premprtp",
                        "content": "As a hint \\nbijection between a letter in pattern and a non-empty word in s.  (it means length of pattern = length of word)\\n\\nstep1: convert [\\'this is\\'] -> [\\'this\\', \\'is\\']\\nstep2: think which data structure store as a keys and values\\nstep3: choose key as a first set and value of that key as a second set\\nstep4: \\n    Hint: make that data structure\\'s key as a element of first set and values as a element of second set .\\n\\nFull solution on Solution section.\\nHAPPY NEW YEAR \\u263A"
                    },
                    {
                        "username": "abdallahsherdy",
                        "content": "pattern= \"jquery\"\\ns=\"jquery\"\\noutput: true\\nExpected false\\nwhy?"
                    },
                    {
                        "username": "MarioKuzmanov1",
                        "content": "Because they are of different length to begin with. s should be treated as an array of words, in this case you have len(pattern) = 6 and len(arr(s)) = 1. So the match at most is one letter from pattern to the jquery. I dont know if you understood, but I hope it is useful. "
                    },
                    {
                        "username": "Buburino",
                        "content": "Happy New Year folks! I hope all of you stay safe and have another year of happy coding!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For javascript/typescript leetcoders. Watch out \"constructor\" for when using plain object (`{}`). Test case 40 has \"constructor\" to fail the codes using plain objects. Use Map instead of plain objects."
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "why for the test case  39:\\npattern =\\n\"jquery\"\\ns =\\n\"jquery\"\\nevery single element is maping to the elements of the string s . then why leetcode is stating it false.I  am very well aware that my theory might fail and if so ,please enlighten me."
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "WHY this code gives me Wrong Answer????\\n\\n\\nif(pattern.length()!=s.length()) return false;\\n        Map<Character, String> m = new HashMap<>();\\n\\n        String []str = s.split(\" \");\\n        for(int i=0; i<str.length; i++)\\n        {\\n            if(m.containsKey(pattern.charAt(i)))\\n            {\\n                if(m.get(pattern.charAt(i))!=str[i])\\n                    return false;\\n            }\\n            m.put(pattern.charAt(i), str[i]);\\n        }\\n        return true;"
                    },
                    {
                        "username": "KumarTarun",
                        "content": "Consider this case \\nPattern : abcabc\\ns : dog cat dog dog cat dog dog\\n\\nthis code will return true for this also thats the problem"
                    },
                    {
                        "username": "vamsi_dath",
                        "content": "Splitting should be done before you check for pattern.length() != s.length(). so change the if statement to pattern.length() != str.length(), and do the split before if. I hope this will help.\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "i did the same but i also got error dont know why?"
                    },
                    {
                        "username": "huzaifa69",
                        "content": "bro ... fk this."
                    }
                ]
            },
            {
                "id": 2019247,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 2016856,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1793552,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1742978,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1737296,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1737248,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1736934,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1736662,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1736495,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1736302,
                "content": [
                    {
                        "username": "bajorek",
                        "content": "It\\'s very good problem but description is vaguely explained and it\\'s should be medium level."
                    },
                    {
                        "username": "abhistin",
                        "content": "This question needs to be in medium category"
                    },
                    {
                        "username": "lawkwok",
                        "content": "I think the example should include a case where the pattern does not begin with `\"a\"`. There is a test case where `pattern = \"e\"` and `s = \"eureka\"`. Since we can\\'t ask questions like in an actual interview, the examples should be more varied."
                    },
                    {
                        "username": "satishnaidu400",
                        "content": "it should be medium rated 1"
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "********************* TIP to Solve ***************************\\nThe question is really simple but careful to read.\\n\\n1-> All you have to do is make a link to each character in patter to a sub-string in s, you can use a map for it.\\n2-> Now you have to see if the key char for which you assign the sub-string already exists or not, if it does and value of \\n       key does not match with sub-string, return false. Else if key don\\'t exist insert it in map.\\n3-> If the key exists and its value is same as substring, leave it as it is.\\n4->Now, you have to check if the value of your substring is assign to another key or not if it does, return false.\\n5->You have to also check if the iterator of pattern size ends loop and your string s size iterator doesn\\'t end the loop then return false, as the string s iterator must be at its end.\\n\\nUPVOTE IF YOU LIKE MY METHOD.\\n\\nHAPPY CODING   :)\\n\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# HashMap | HashSet Approach\n# Intuition\nWe can use a HashMap to map each character in the pattern to each word in the string. We can then scan through the pattern and string and check if the characters map to the corresponding words.\n\n---\n\n\n# Approach\n- The approach used in the code is to use a HashMap and a Set to store the pattern and the string respectively.\n- We iterate over the pattern and the string and compare each character of the pattern to the corresponding word in the string.\n- If a new entry is made in the map then add that corresponding word from string to the HashSet.\n- If the pattern character is already present in the HashMap, then compare its value from HashSet if its not same return false.\n\n---\n\n\n# Complexity\n- Time complexity:\n$$O(n)$$\n\n- Space complexity:\n$$O(n)$$\n\nRefer My Solution - [Java | Easy | 100% Fast Solution | HashMap | HashSet\n](https://leetcode.com/problems/word-pattern/solutions/2981594/java-easy-100-fast-solution-hashmap-hashset/)"
                    },
                    {
                        "username": "abhijeetak47aj",
                        "content": "C++ ppl try  using two unordered hashmaps\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "One unordered map and one set is enough I guess \\uD83E\\uDD14.\\nInstead of another map for hashing String/Char for duplicate checking One can use Set as well."
                    },
                    {
                        "username": "kzlatt",
                        "content": "Feeling good with this especially after totally humiliated by Kadane\\'s algo (max sum sub-list) that I tried yesterday for ~4hrs brute forcing and all the looping messes. Then I read Kadane\\'s algo on wiki and I felt like shit. Now this is better."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Not a Easy but Not so difficult <br>\\nIt should marked as Medium <br>\\nJust think about the brute force<br>\\nBase cases are very important . I got to 2 wrong submissions <br>\\nMy 0ms solution link : https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/?orderBy=most_votes\\n<br>\\nHappy New Year ."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Good way to start the new year!"
                    }
                ]
            },
            {
                "id": 1736243,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 1574366,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 1571542,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 1569332,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 1670820,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 1574344,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 2049630,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 2040396,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 2029514,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 1993240,
                "content": [
                    {
                        "username": "six519",
                        "content": "No discussion needed.. :D "
                    },
                    {
                        "username": "zxak",
                        "content": "Java solution \\nhttps://thefellowprogrammer.blogspot.com/2020/09/word-pattern.html"
                    },
                    {
                        "username": "scott",
                        "content": "why the test \"abba\" \"dog cat dog\"\" and \"abba\" and \"e\" return false ?\\n\\nFrom the problem description , Each letter in pattern must map to a word with length that is at least 1. \\n\\nSo for the above tests , can I see 'a' match  dog and 'bb' match 'cat' \\n\\nand the whole String 'abba' match the 'e' ?\\n\\nThanks in advance !"
                    },
                    {
                        "username": "yatharthm22",
                        "content": "i dont think bb can match one single word. each letter is associated with a single word. Hence the length of pattern and number of words in \\'s\\' should always be =="
                    },
                    {
                        "username": "wenjzhu",
                        "content": "I think it is self explainatory\\n\\n\\tdef wordPattern(self, pattern, str):\\n\\t\\t\\tstr = str.split(\\' \\')\\n\\t\\t\\tif len(pattern) != len(str): return False\\n\\t\\t\\treturn len(set(zip(pattern, str))) == len(set(str)) and len(set(str)) == len(set(pattern))"
                    },
                    {
                        "username": "mouertani",
                        "content": "Below my code written in C++ | Runtime 0 ms | Beats 100%\n\n```\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        istream_iterator<string> begin(ss);\n        istream_iterator<string> end;\n\t    vector<string> tokens(begin, end);\n        map<char,string> container;\n        if(tokens.size() != pattern.size())\n            return false;\n        for(int i = 0; i < pattern.size(); i++) {\n            if(container.count(pattern[i]) > 0) {\n                if(container.at(pattern[i]) != tokens[i])\n                    return false;\n            }else {\n                for(auto &it : container) {\n                    if(it.second == tokens[i])\n                        return false;\n                }\n                container[pattern[i]] = tokens[i];\n            }\n        }\n        return true;\n    }\n};\n```"
                    },
                    {
                        "username": "Denim",
                        "content": "\"abbc\"\\n\"dog dog cat mouse\"\\n\\nThis is a bijection too right? But we are expected to return false here. Why is that?"
                    },
                    {
                        "username": "tweet_ycode",
                        "content": "no b is for dog and in next b is mapped to cat which is false"
                    },
                    {
                        "username": "sinquirls",
                        "content": "Problem description should also state that the pattern is non-repeating. Pattern = \"aa\" and s = \"dog dog dog dog\" is expected to be FALSE.  I don\\'t think enough thought was put into this."
                    },
                    {
                        "username": "reassurance",
                        "content": "THIS QUESTION IS EXACTLY SAME AS [ISOMORPHIC STRINGS](https://leetcode.com/problems/isomorphic-strings/).\\nsorry for the caps!"
                    },
                    {
                        "username": "MarkDementev",
                        "content": "Be sure to watching constraints!"
                    },
                    {
                        "username": "Omerdw",
                        "content": "Not a hard one yet it\\'s not properly explained, you need to try and fail in order to understand what\\'s allowed - and that\\'s just annoying.\\n\\nlike:\\n\"abba\" and \"dog dog dog dog\" \\nis it legal or not? it follows the pattern even though the word is the same\\nalso, are there cases of mismatch between pattern length and word count?\\n\\nannoying..."
                    }
                ]
            },
            {
                "id": 1979745,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1972964,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1972699,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1950577,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1946537,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1945209,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1939024,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1916340,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1901310,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1896506,
                "content": [
                    {
                        "username": "alighraibeh87",
                        "content": "case 39 \\npattern =\"aa\" ,s =\"dog dog dog dog\" output is true but expected is false\\nis the length must be equal for both pattern and string?"
                    },
                    {
                        "username": "lpaben62",
                        "content": "Actually it is a great question for you to think of some use cases that are still \"vague\" from the problem statement. For those vague situations, you can easily think of the correct behavior imo."
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String>map=new HashMap<>();\\n        String splited[] = s.split(\"\\\\\\\\s+\");\\n        if(pattern.length()!=splited.length) return false;\\n        for(int i=0;i<pattern.length();i++){\\n            char ch=pattern.charAt(i);\\n            if(map.containsKey(ch)==true){\\n                if(map.get(ch)!=splited[i]) return false;\\n            }\\n            else{\\n                map.put(ch,splited[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//Error for example 1\\n\\nCan anyone tell what is the error in this program. It is giving error for example 1. \\n\\nCreated a hashmap and splited the given string into words.\\nMapping each character with words.\\n\\nKindly help me!!"
                    },
                    {
                        "username": "Eswar_balla",
                        "content": "Approach\\n1.create a stack and store the words from string s without space\\n2.return false if length of string-pattern and stack are not equal\\n3.create a map and map the stack with the letters in pattern string in reverse order(because stack is lifo)\\n4.while mapping if the char is already mapped with another word then return false\\n5.Or if new char is mapping with existing word(it->second) then return false\\n6.If all the loops passed without termination then return true"
                    },
                    {
                        "username": "siaaam",
                        "content": "Testcase: 32/41\\npattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nOutput: true\\nExpected: false\\n\\nI use hashmap to solve this question\\na -> dog\\nb -> dog\\nb -> dog\\na -> dog\\nkey contain same value then why it is showing expected false. "
                    },
                    {
                        "username": "sjrj0604",
                        "content": "The mapping is supposed to be bijective so every element should have a one-one relation"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "Mine one is failing for example 1"
                    },
                    {
                        "username": "sitanggang",
                        "content": "what\\'s wrong with word constructor here??"
                    },
                    {
                        "username": "pyush98",
                        "content": "identical to problem #205"
                    },
                    {
                        "username": "Socrii13",
                        "content": "Here it states that both the string should be in same pattern \\nfor example \\nin the very first case : [abba ] [dog cat cat dog]\\nlet represent dog as ->a ,and cat as-> b\\nnow match the pattern [a b b a]\\nlet\\'s consider a test case [a b a b] and [dog cat dog cat]\\nit will return true .\\nhope it might help\\n"
                    },
                    {
                        "username": "danielisro",
                        "content": "how to do \\nhow to think \\n"
                    },
                    {
                        "username": "manikantanynala97",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) return false;\\n        HashMap<Character,String> map = new HashMap<Character,String>(); // s-> pattern\\n        HashMap<String,Character> map1 = new HashMap<String,Character>(); // pattern -> s\\n\\n     for(int i = 0;i< pattern.length();i++)\\n     {\\n         char ch = pattern.charAt(i);\\n         String str = words[i];\\n         if(map.containsKey(ch) == false && map1.containsKey(str) == false )\\n         {\\n               map.put(ch,str);\\n               map1.put(str,ch);\\n         }\\n\\n         else if (map.containsKey(ch) == false && map1.containsKey(str) == true)\\n         {\\n                 return false;\\n         }\\n\\n         else if (map.containsKey(ch) == true  && map1.containsKey(str) == false)\\n         {\\n                return false;\\n         }\\n\\n         else if(map.containsKey(ch) == true && map1.containsKey(str) == true)\\n         {\\n               if(map.get(ch) !=  str)\\n               {\\n                   return false;\\n               }\\n\\n         }\\n     }\\n                  return true;\\n    }\\n}\\n\\nWhy am I getting wrong answer ? please tell"
                    }
                ]
            },
            {
                "id": 1875715,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1859264,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1856957,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1848655,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1824966,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1820498,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1809979,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1808444,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1802494,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1801197,
                "content": [
                    {
                        "username": "mayankgagneja2002",
                        "content": "why the heck the output for the test case: s= j query pattern=j query is false"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character,String> map = new HashMap<>();\\n        String patAr[] = s.split(\" \");\\n\\n        if(patAr.length!=pattern.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            char key = pattern.charAt(i);\\n            if(map.containsKey(key)){\\n                if(!map.get(key).equals(patAr[i])){\\n                    return false;\\n                }\\n            }else{\\n                if(map.containsValue(patAr[i])){\\n                    return false;\\n                }\\n                map.put(key,patAr[i]);\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "psionl0",
                        "content": "A straight forward problem that took me hours to get right and fought me every line of the way."
                    },
                    {
                        "username": "mikhailkaryamin",
                        "content": "Why \\npattern = \"aa\"\\ns =\"dog dog dog dog\"\\nis false?\\n"
                    },
                    {
                        "username": "al3xxxgm",
                        "content": "2 != 4"
                    },
                    {
                        "username": "anubhavrai013",
                        "content": "so there is one issue particularly with JS if you use has map\\n\\nfor test case with string \"dog constructor constructor dog\"\\nif you look for \\n\\nlet obj = {}\\n\\nand try finding if(ob[\\'constructor\\']) this will return false , since in JS all object has constructor method by default\\n\\nany idea how to read reserved keyword as string???"
                    },
                    {
                        "username": "sylthiel",
                        "content": "I\\'ve ran into a weird issue where one solution works and the one randomly works or doesn\\'t on certain tests:\\nSPOILERS BELOW\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\n...\\nSolution that works every time:\\n```class Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        pattern_map = {}\\n        s_map = {}\\n        pattern_positions = []\\n        s_positions = []\\n        \\n        for i, x in enumerate(pattern):\\n            if x not in pattern_map:\\n                pattern_map[x] = len(pattern_map)\\n            pattern_positions.append(pattern_map[x])\\n            \\n        for i, x in enumerate(s.split()):\\n            if x not in s_map:\\n                s_map[x] = len(s_map)\\n            s_positions.append(s_map[x])\\n        \\n        return pattern_positions == s_positions\\n```\\nOriginal solution that works sometimes:\\n\\n```\\nclass Solution:\\n    def wordPattern(self, pattern: str, s: str) -> bool:\\n        ptrn = {x: i for i, x in enumerate(set(pattern))}\\n        translation = [ptrn[x] for x in pattern]\\n        target = {x: i for i, x in enumerate(set(s.split(\" \")))}\\n        target_translation = [target[x] for x in s.split(\" \")]\\n        print(translation)\\n        print(target_translation)\\n        return translation == target_translation\\n```\\nCan somebody explain this to me?\\nFor what it\\'s worth, ChatGPT says they are equivalent and both should work"
                    },
                    {
                        "username": "dm-vev",
                        "content": "pattern=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]] in testcase, python. wtf?"
                    },
                    {
                        "username": "realstruggleranurag1001",
                        "content": "how to convert a 2-D matrix array into set (in pair form)."
                    },
                    {
                        "username": "ROBIN_MAHESHWARY",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string p, string s) {\\n        unordered_map<char,string> m1, m2;\\n        int n = p.size();\\n        vector<string> st;\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n            st[k]=st[k]+s[i];\\n             }\\n             else k+=1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if(m1[p[i]] != m2[st[i]]) return false;\\n            m1[p[i]] = i + 1;\\n            m2[st[i]] = i + 1;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\nwhy there is an error?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "`Javascript` `constructor` cannot be object `key` holy, today I learned"
                    }
                ]
            },
            {
                "id": 1800586,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1780907,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1773010,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1769783,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1766761,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1757794,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1741327,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1738386,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1737617,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1737339,
                "content": [
                    {
                        "username": "Vinit171",
                        "content": "Hint - \\nYou can use Dictionary in python."
                    },
                    {
                        "username": "Evil_123",
                        "content": " //easy c++ solution\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>v;\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                v.push_back(temp);\\n                temp=\"\";\\n            }\\n            else\\n            temp+=s[i];\\n        }\\n        v.push_back(temp);\\n        if(v.size()!=pattern.size()){\\n            return false;\\n        }\\n        map<char,string>m;\\n        set<string>sab;\\n        for(int j=0;j<pattern.size();j++){\\n            //checking \\n           if(m.find(pattern[j])!=m.end()){\\n               if(m[pattern[j]]!=v[j]){\\n                   return false;\\n               }\\n           }\\n           //filling or mapping is done \\n           else{\\n               if(sab.count(v[j])>0){\\n                   return false;\\n               }\\n               m[pattern[j]]=v[j];\\n               sab.insert(v[j]);\\n           }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasien99",
                        "content": "Here I will explain my approach to solve this problem.\\n- First we here have two strings and we want to know that our string \"s\" follow the same pattern as the string \"pattern\". \\n- So I start thinking how to compare this 2 strings and found it difficult to deal with them as string.\\n- My solution was to iterate over each string and do two things:\\n        **1**. if this char is new and this first time I saw it in the string, give this char a number, store it in a hash table, to retrieve the value attached to this char if I found it again in my string and then appended this number to a list I made for this string pattern.\\n     **2**. if I found a number that already defined in my hash table of this string then retrieve the value attached to this char and appended it in the list.\\n\\n- Make the prev step for both the strings and then compare the 2 generated list if it has the same numbers then the two strings have the same pattern. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "HA_RI",
                        "content": " my solution in c++ simple way to solve\\n  bool wordPattern(string pattern, string str) {\\n         const int n = pattern.length();\\n    istringstream iss(str);\\n    vector<int> charToIndex(128);\\n    unordered_map<string, int> stringToIndex;\\n\\n    int i = 0;\\n    for (string word; iss >> word; ++i) {\\n      if (i == n)  // Out of bound\\n        return false;\\n      if (charToIndex[pattern[i]] != stringToIndex[word])\\n        return false;\\n      charToIndex[pattern[i]] = i + 1;\\n      stringToIndex[word] = i + 1;\\n    }\\n\\n    return i == n;\\n    }"
                    },
                    {
                        "username": "lumi1717",
                        "content": "This question does not make sense to me, can someone explain ?"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Can anybody explain to me why the following should not result in `true`?\\n\\nThere is a bijection between between \"a\" and \"dog\" and \"b\" and \"cat\", even though order is different between pattern and words.\\n\\n```\\nInput: pattern = \"abba\", s = \"dog cat dog cat\"\\nOutput: false\\n```"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "[@narfallzg](/narfallzg) Thanks, now I got it. I was confused because I was mostly focusing on bijection part while forgetting about pattern part."
                    },
                    {
                        "username": "narfallzg",
                        "content": "if \"a = dog\" and \"b = cat\", then \"pattern\" would be \"abab\" to produce \"true\". Alternatively, \"s\" would be \"dog cat cat dog\" to produce \"true\"."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Java || Beats 100% runtime || Easy to Understand\\nhttps://leetcode.com/problems/word-pattern/solutions/2981104/java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\"abba\"\\n\"dog dog dog dog\"\\n\\nhow do i solve the duplicate problem? "
                    },
                    {
                        "username": "narfallzg",
                        "content": "Research \"bijection\". I made this mistake too."
                    },
                    {
                        "username": "denkochev",
                        "content": "You have to figure out how to storage unique symbols from pattern and unique words from s."
                    },
                    {
                        "username": "20kb1a0581",
                        "content": "Hmm"
                    }
                ]
            },
            {
                "id": 1737278,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737269,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737265,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737263,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737246,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737240,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737221,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737213,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737171,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737143,
                "content": [
                    {
                        "username": "try_again",
                        "content": "Bad day too me bit time, but still not satisfied with efficiency, it will be great if someone provide efficient solution\n\nI have created Dict, storing pattern as a keys and string as a values,\nIf Key not present in Dict and Value also not present in Dict then setting the value against the key else return False\n\nIf Key present in Dict but it's value and matching with my current value then return False\n\nWorst case it's taking N*N"
                    },
                    {
                        "username": "denkochev",
                        "content": "Tricky thing :D"
                    },
                    {
                        "username": "mrping_11",
                        "content": "TLDR :  the number of characters should be equal to the number of words in the sentence and for each character, say 3rd character in the word can be mapped to the 3rd word in the sentence and this mapping shouldn\\'t be violated further in the word or the sentence. \\n\\n\\nps : an easy problem but \"aaa\" and \"aa aa aa aa\" confused me :)"
                    },
                    {
                        "username": "user8579YM",
                        "content": "My solution in Java.\\nI just map characters from pattern and words from string to subsequent integer starting from 0.\\nRuntime 1ms, beats 95%\\n\\npublic boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length!=pattern.length()) return false;\\n\\n        Map<Character, Integer> cToInt = new HashMap<>();\\n        Map<String, Integer> strToInt = new HashMap<>();\\n\\n        int k=0;\\n        int l=0;\\n        for (int i=0; i<pattern.length(); i++){\\n            \\n            if (!cToInt.containsKey(pattern.charAt(i))) {\\n                cToInt.put(pattern.charAt(i), k++);\\n            }\\n            if (!strToInt.containsKey(words[i])){\\n                strToInt.put(words[i], l++);\\n            }\\n            int cRes = cToInt.get(pattern.charAt(i));\\n            int sRes = strToInt.get(words[i]);\\n\\n            if (cRes!= sRes)\\n            return false;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "Easy solution using set and hashmap in c++\\n\\nclass Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        vector<string>words;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\' \\'){\\n                words.push_back(str);\\n                str=\"\";\\n            }\\n            else{\\n                str+=s[i];\\n\\n            }\\n        }\\n        words.push_back(str);\\n\\n        \\n        if(words.size()!=pattern.size()) return false;\\n\\n        set<pair<char>s1;\\n        set<string>s2;\\n        for(int i=0; i<words.size(); i++){\\n          s1.insert(pattern[i]);\\n          s2.insert(words[i]);\\n        }\\n        if(s1.size()!=s2.size()) return false;\\n        unordered_map<char,string>mp;\\n        for(int i=0; i<pattern.size(); i++){\\n            if(mp[pattern[i]]==\"\"){\\n                mp[pattern[i]]=words[i];\\n            }\\n            else if(mp[pattern[i]]!=\"\" and mp[pattern[i]]!=words[i]){\\n             return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ProJoy",
                        "content": "didn\\'t understand the logic\\n"
                    },
                    {
                        "username": "sujeet_varshney",
                        "content": "#solution in python with only 1 dictionary 1 set\n def wordPattern(self, pattern: str, s: str) -> bool:  \n        \n        ns=set()   #for counting unique words\n        words=s.split() #split the words \n        D={ } #dictionary to map all the \"char\":\"words\"\n        result=True  #set initial results as True\n        if len(pattern)!=len(words):  #if len of words != len of characters need not to check \n            result=False\n        else:\n            for i in range(len(pattern)): #check every char, word combination\n                ns.add(words[i]) #add every word to set\n                if pattern[i] not in D:  #if pattern not in dictionary add char:word\n                    D[pattern[i]]=words[i]  \n                else:                             #if pattern is already present in dictionary      \n                    if D[pattern[i]]!=words[i]:  #if old word mapped with char not matching\n                        result=False  #invalid mapping so stop\n                        break\n        if len(ns)!=len(D):   #if all the words have unique mapping length of dict/set equql\n            result=False #if length not matching mapping is wrong\n        return result #in same indentation with if \n "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VinayV9",
                        "content": "What is bijection?"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Happy new year ^^ "
                    },
                    {
                        "username": "addixit",
                        "content": "public class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        // Split the string into a list of words\\n        String[] words = s.split(\" \");\\n        \\n        // Check if the number of words and the number of letters in the pattern are different\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }\\n        \\n        // Create dictionaries to map letters in the pattern to words in the string and vice versa\\n        Map<Character, String> letterToWord = new HashMap<>();\\n        Map<String, Character> wordToLetter = new HashMap<>();\\n        \\n        // Iterate through the letters in the pattern\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char letter = pattern.charAt(i);\\n            String word = words[i];\\n            \\n            // Check if the letter has been seen before\\n            if (letterToWord.containsKey(letter)) {\\n                // If the letter has been seen before, check if it is mapped to the same word as before\\n                if (!letterToWord.get(letter).equals(word)) {\\n                    return false;\\n                }\\n            } else {\\n                // If the letter has not been seen before, add it to the dictionary\\n                letterToWord.put(letter, word);\\n            }\\n            \\n            // Check if the word has been seen before\\n            if (wordToLetter.containsKey(word)) {\\n                // If the word has been seen before, check if it is mapped to the same letter as before\\n                if (wordToLetter.get(word) != letter) {\\n                    return false;\\n                }\\n            } else {\\n                // If the word has not been seen before, add it to the dictionary\\n                wordToLetter.put(word, letter);\\n            }\\n        }\\n        \\n        // If the loop completes without returning false, return true\\n        return true;\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1737107,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1737035,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1737005,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1736986,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1736981,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1736974,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1736973,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1736957,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1736937,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1736929,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Beware of the corner cases of which there are more than one.\\n\\nSame word should not match multiple pattern characters.\\nNumber of words should be exactly same as the number of characters in pattern."
                    },
                    {
                        "username": "tpandey495",
                        "content": "poorly written problem.Please rewrite problem statement\\n"
                    },
                    {
                        "username": "seenu-cpu",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n    String[] key = pattern.split(\"\");\\n    String[] val = s.split(\" \");\\n    if(key.length!=val.length) return false;\\n    HashSet<String> one  = new HashSet<>();\\n    HashSet<String> two = new HashSet<>();\\n    for(int i=0;i<key.length;i++){\\n        one.add(key[i]);\\n        two.add(val[i]);\\n    }\\n     if(one.size() != two.size()) return false;\\n\\n        HashMap<String,String> hs = new HashMap<>();\\n        for (int i = 0; i < val.length; i++) {\\n            hs.put(key[i],val[i]);\\n        }\\n        for (int i = 0; i < key.length; i++) {\\n           if(hs.containsKey(key[i])){\\n               if(!(Objects.equals(val[i], hs.get(key[i])))){\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhagyajeet",
                        "content": "Solved the first problem of 2023. Happy new year and wish you all the best!!!"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "bijective means : one one onto \\n"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "please explain this code "
                    },
                    {
                        "username": "phoneix007",
                        "content": "Hard to understand the problem statement. Though it is easy but not straight forward. Change the wordings of the question."
                    },
                    {
                        "username": "2020B0101057",
                        "content": "Use two hashmaps one for finding pattern if similar pattern exist for another word  ,and another for finding word if similar word exist for another pattern ,because  in question bijection is mentioned."
                    },
                    {
                        "username": "jutta67",
                        "content": "Happy new year\\uFF01"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone. I wish from god that you all accomplish everythings you wish for in 2023\\uD83D\\uDE03\\uD83D\\uDE03"
                    }
                ]
            },
            {
                "id": 1736899,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736892,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736854,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736844,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736826,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736804,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736776,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736762,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736754,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736748,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "New Year Same Questions.. Let\\'s go!!!!"
                    },
                    {
                        "username": "naveen_engineer",
                        "content": "vector of pair se jana ho jayega\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**HAPPY NEW YEAR 2023**"
                    },
                    {
                        "username": "pauvpam",
                        "content": "class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        bool flag = true;\\n        stringstream ss(s);\\n        vector<string> arr;\\n        string temp;\\n        while(getline(ss, temp, \\' \\')){\\n            arr.push_back(temp);\\n        }\\n        if(pattern.length()!= arr.size()) return false;\\n        unordered_map<char, string> mymap;\\n        for(int i=0;i<pattern.length();i++){\\n            if(mymap.find(pattern[i]) != mymap.end()){\\n                if(mymap[pattern[i]] == arr[i]) flag = true;\\n                else return false;\\n            }else{\\n                mymap[pattern[i]] = arr[i];\\n            }\\n        }\\n        unordered_map<string, char> check_duplicates;\\n        for(int i=0;i<pattern.length();i++){\\n            if(check_duplicates.find(arr[i]) != check_duplicates.end()){\\n                flag = true;\\n            }else{\\n                check_duplicates[arr[i]] = pattern[i];\\n            }\\n        }\\n        if(check_duplicates.size() != mymap.size()) return false;\\n        return flag;\\n    }\\n};"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it took 1 and half hour to clear all the test cases may be question was easy but test cases were frustrating "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Easy-difficulty problem to start out the new year 2023! Happy new year and wish you all the best!!!\nI hope you guys are doing extremely well..."
                    },
                    {
                        "username": "ngnikhil98",
                        "content": " Easiest Java Solution\\n\\n\\n`class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String arr [] = s.split(\" \");\\n        if(arr.length != pattern.length()){\\n            return false;\\n        }\\n        Map<Character, String> map = new HashMap<>();\\n        Map<String, Integer> dupMap = new HashMap<>();\\n\\n        for(int i=0; i< pattern.length(); i++){\\n            if(!map.containsKey(pattern.charAt(i))){\\n                if(dupMap.containsKey(arr[i])){\\n                    return false;\\n                }\\n                map.put(pattern.charAt(i), arr[i]);\\n                dupMap.put(arr[i],1);\\n                continue;\\n            }\\n\\n            if(!map.get(pattern.charAt(i)).equals(arr[i])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "Nagaaa",
                        "content": "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        Map<Character,Integer> pattern_map = new HashMap<>();\\n        Map<String,Integer> s_map = new HashMap<>();\\n        String str[] = s.split(\" \");\\n\\n        if(str.length!=pattern.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            pattern_map.put(pattern.charAt(i),i);\\n            s_map.put(str[i],i);\\n        }\\n        for(int i=0;i<str.length;i++)\\n        {\\n            int a = pattern_map.get(pattern.charAt(i));\\n            int b = s_map.get(str[i]);\\n            if(a!=b) return false;\\n        }\\n\\n        return true;\\n\\n        \\n        \\n    }\\n}"
                    },
                    {
                        "username": "bhaveshgujar475",
                        "content": "This problem seems Easy but the problem statement is not written clearly!!!"
                    },
                    {
                        "username": "danishnit",
                        "content": "easy\\n class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String [ ] res=s.split(\" \");\\n         if (res.length != pattern.length()) {\\n            return false;\\n        }\\n        HashMap<Character, String> map1=new HashMap<>();\\n         HashMap<String,Boolean>   map2=new HashMap<>();\\n         for( int i=0;i<pattern.length();i++)\\n         {\\n             char ch= pattern.charAt(i);\\n             if(map1.containsKey(ch)==false)\\n             {\\n                 if(map2.containsKey(res[i])==true){\\n                   return false;\\n                 }\\n                   else{\\n                       map2.put(res[i],true);\\n                       map1.put(ch,res[i]);\\n                   }\\n             }\\n                   else{\\n                       String a=map1.get(ch);\\n                       if(a.equals(res[i])==false)\\n                            return false;\\n                   }\\n             }\\n         \\n         return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1736745,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736731,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736729,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736726,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736718,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736693,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736628,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736583,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736576,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736557,
                "content": [
                    {
                        "username": "sunnysunnyshine",
                        "content": "Happy new year! A great start for 2023!"
                    },
                    {
                        "username": "Melhalwagui",
                        "content": "Easy problem to start the year with "
                    },
                    {
                        "username": "mohanish35",
                        "content": "My code doesn\\'t work after removing the \"cout\" statement on line #12. Does anybody know what could be going on?\\n\\n ```class Solution {\\npublic:\\n    bool wordPattern(string pattern, string s) {\\n        s += \" \";\\n        unordered_map<char, string> mapper;\\n        set<string> collected;\\n        string word = \"\";\\n        int s_idx = 0;\\n\\n        for (int i; i < pattern.size(); i++) {\\n            if (s_idx == s.size()) {\\n                cout << i << endl;\\n                return false;\\n            }\\n\\n            for (; s_idx < s.size(); s_idx++) {\\n                if (s[s_idx] == \\' \\') {\\n                    if (mapper.find(pattern[i]) == mapper.end()) {\\n                        if (collected.find(word) == collected.end()) {\\n                            collected.insert(word);\\n                            mapper[pattern[i]] = word;\\n                       } else\\n                            return false;\\n                    } else if (mapper[pattern[i]] != word) {\\n                        return false;\\n                    }\\n\\n                    word = \"\";\\n                    s_idx++;\\n                    break;\\n                } else {\\n                    word += s[s_idx];\\n                }\\n            }\\n        }\\n\\n        return s_idx == s.size();\\n    }\\n};"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Starting the year with a nice question!"
                    },
                    {
                        "username": "debug_04",
                        "content": "Constraints given:\n1 <= pattern.length <= 300\n1 <= s.length <= 3000\n\nWrong constraints are given, pattern length and s length should be same. May be its a typo. It should both like,\n1 <= pattern.length <= 300\n1 <= s.length <= 300"
                    },
                    {
                        "username": "iamavikb",
                        "content": "s.length denotes number of characters in s, not words."
                    },
                    {
                        "username": "Gaurav__Singh",
                        "content": "bool wordPattern(string pattern, string str)\\n{\\n\\n    // using isstringstream class to extract words from string.\\n    istringstream iss(str);\\n\\n    // variable (j) to traverse pattern.\\n    int j = 0;\\n\\n    // maps.\\n    unordered_map<char, string> charToString;\\n    unordered_map<string, char> stringToChar;\\n\\n    // extrack all words from string and push it into vector.\\n    vector<string> words;\\n    while (iss >> str)\\n    {\\n        words.push_back(str);\\n    }\\n\\n    // Base Case\\n    // if total no. of words is not equal to total no. of charater in a pattern string, \\n    // then there is no bijection, simply return false.\\n    if (words.size() != pattern.length())\\n    {\\n        return false;\\n    }\\n\\n    // traverse the words vector.\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        // just taking variables of word and char.\\n        string word = words[i];\\n        char ch = pattern[j++];\\n        \\n        // find the word and character, check if it is previously appear or not. \\n        auto findChar = charToString.find(ch);\\n        auto findWord = stringToChar.find(word);\\n\\n        // if character is already appear in the past,\\n        // this character is mapped to some word.\\n        if (findChar != charToString.end())\\n        {\\n            // extract the mapped word.\\n            string previousStoredString = charToString[ch];\\n\\n            // if previously mapped word is not equal to present word, return false.\\n            if (previousStoredString != word)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if character is not present, store it in map.\\n            charToString[ch] = word;\\n        }\\n\\n        // if word is already appear in the past,\\n        // this word is mapped to some character.\\n        if (findWord != stringToChar.end())\\n        {\\n            // extract the mapped character.\\n            char previousStoredChar = stringToChar[word];\\n\\n            // if previously mapped character is not equal to present chaacter, return false.\\n            if (previousStoredChar != ch)\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            // if word is not present, store it in map.\\n            stringToChar[word] = ch;\\n        }\\n    }\\n\\n    return true;\\n}"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "like if you got it wrong first time!  -_-"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "An easy question to start with new year 2023, Happy New Year! Leetcoders !! :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "an easy problem took 7 submission to be accepted this problem.\\nBad start for me 2023. Maybe this year will be a hard one for me."
                    },
                    {
                        "username": "er_sushant",
                        "content": "**Happy New Year Everyone!** \\uD83C\\uDF89\\nI hope you all get what you are working on even on the 1st day of new year.\\nGood luck beautiful people<33"
                    }
                ]
            },
            {
                "id": 1736551,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736515,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736472,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736467,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736455,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736447,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736444,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736428,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736396,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736387,
                "content": [
                    {
                        "username": "user8296H",
                        "content": "It\\'s important to know the meaning of bijection: each element of one set is paired with exactly one element of the other set, and each element of the other set is paired with exactly one element of the first set and there are no unpaired elements.\\n\\nSo, This implies that \\n1) It\\'s 1 to 1 mapping from both sides.\\n2) The number of characters in pattern and number of strings in s must be equal."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Starting 2023 with Easy Problem. Happy New Year Everyone!"
                    },
                    {
                        "username": "somveer2002",
                        "content": "Journey starts now, for a continuous of 180 days.\\n.\\n.\\nWill meet after completing challenge. "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Such a poorly written problem"
                    },
                    {
                        "username": "Syed_M_Ahsan",
                        "content": "pattern = \"syys\"\\ns = \"a abc abc a\"\\nOutput = false\\nExpected = true\\n\\nCan anybody explain this why it is true?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Every letter in Pattern is assigned to same word in s. Hence its true. For Ex: \\'s\\' in pattern is \\'a\\' in s and \\'y\\' in pattern is \\'abc\\' in s."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "yes it is true because its pattern is same if you are not able to solve it check my solution and don\\'t forgot to upvote it . https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ekansh88",
                        "content": "https://leetcode.com/problems/word-pattern/solutions/2978622/100-faster-explanation-of-code-tc-o-n-sc-o-n-easy-approach/\n\nI HAVE EXPLAIN THE CODE OF MINE, it is 100% faster and tc-O(n)\n\nHappy New year 🎉\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Although the Problem Statement is confusing, understanding it using the Sample Test Cases is quite easy"
                    },
                    {
                        "username": "0417taehyun",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "user5130F",
                        "content": "pattern = \"abba\"\\ns = \"dog dog dog dog\"\\n\\nHow is the \\'false\\' answer?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Because pattern is not same let say dog is a then dog dog dog dog is aaaa but pattern given is abba that\\'s why it is false . Check my solution and don\\'t forgot to upvote it .https://leetcode.com/problems/word-pattern/solutions/2978804/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "SK_baranwal",
                        "content": "It is quite less worded, I hope Leetcode team will edit it.\\nLeetcode take care of its user, to start with easy!\\nHappy 2023, Everyone"
                    }
                ]
            },
            {
                "id": 1736376,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736375,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736374,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736371,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736362,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736232,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736229,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736216,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736153,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736150,
                "content": [
                    {
                        "username": "Suraj_Nanavare",
                        "content": "**Explanation about bijection in letters**: \\n \\nSuppose we have a pattern p and a string str, we have to check whether str follows the same pattern or not. Here follow means there is a bijection between a letter in pattern and a non-empty word in str. So, if the input is like pattern = \"cbbc\", str = \"word pattern pattern word\", then the output will be True."
                    },
                    {
                        "username": "sahil_kr",
                        "content": "Problem statement might be more detailed . But easy question . \\nHappy New Year Everyone"
                    },
                    {
                        "username": "jaideep_sai_",
                        "content": "\\uD835\\uDC7E\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC89\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96 \\uD835\\uDC82\\uD835\\uDC8F\\uD835\\uDC85 \\uD835\\uDC9A\\uD835\\uDC90\\uD835\\uDC96\\uD835\\uDC93 \\uD835\\uDC87\\uD835\\uDC82\\uD835\\uDC8E\\uD835\\uDC8A\\uD835\\uDC8D\\uD835\\uDC9A \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC82 \\uD835\\uDC7E\\uD835\\uDC90\\uD835\\uDC8F\\uD835\\uDC85\\uD835\\uDC86\\uD835\\uDC93\\uD835\\uDC87\\uD835\\uDC96\\uD835\\uDC8D \\uD835\\uDC75\\uD835\\uDC6C\\uD835\\uDC7E \\uD835\\uDC80\\uD835\\uDC6C\\uD835\\uDC68\\uD835\\uDC79 \\uD835\\uDC82\\uD835\\uDC89\\uD835\\uDC86\\uD835\\uDC82\\uD835\\uDC85 :)"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "I solved in :) "
                    },
                    {
                        "username": "darasingh12998",
                        "content": "             \\n        class Solution:\\n    def wordPattern(self, pattern, str):\\n        s = pattern\\n        t = str.split()\\n        return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)"
                    },
                    {
                        "username": "Vikasprajapati7075",
                        "content": "Dear everyone,\\n\\nA new year is like a blank book, and the pen is in your hands. It is your chance to write a beautiful story for yourself.\\n\\nI wish you all Happy new year 2023!"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "A very happy new year to everyone. https://sites.google.com/view/iamavik/290-word-pattern"
                    },
                    {
                        "username": "HALOGENMAN",
                        "content": "happy new year"
                    },
                    {
                        "username": "foxtrain",
                        "content": "Happy new year guys."
                    },
                    {
                        "username": "joshi22",
                        "content": "what happens if we have 26+ different words in s? how would the pattern be for it to be true?"
                    }
                ]
            },
            {
                "id": 1736117,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1736098,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1736035,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1735982,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1735969,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1735960,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1735957,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1735954,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1735949,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            },
            {
                "id": 1735928,
                "content": [
                    {
                        "username": "chprvaibhav",
                        "content": "how can i match it in such a way that the code will no it is parallel and matching??"
                    },
                    {
                        "username": "zahid_hasan_sahin",
                        "content": "Started 2023 with an easy problem. :3"
                    },
                    {
                        "username": "yabyer1",
                        "content": "class Solution {\\n    \\n    public boolean wordPattern(String pattern, String s) {\\n        String b = s;\\n        String next = \" \";\\n        Map<Character, String> AlphaMap = new HashMap<>();\\n        for(int i = 0; i < pattern.length(); i++){\\n            \\n            if(i < pattern.length() - 1){\\n              next = b.substring(0, b.indexOf(\\' \\'));\\n            b = b.substring(b.indexOf(\\' \\') + 1);\\n            }\\n            else{\\n                 next = b;\\n            }\\n            String checker = AlphaMap.get(pattern.charAt(i));\\n            if(checker == null){\\n                for (int j = 0; j < i; j++){\\n                    if(next.equals(AlphaMap.get(pattern.charAt(j)))){\\n                        return false;\\n                    }\\n                }\\n           AlphaMap.put(pattern.charAt(i),next);\\n            }\\n            if (!next.equals(AlphaMap.get(pattern.charAt(i)))){\\n                  return false;\\n            }\\n        }\\n        return true;\\n        /*\\n        for(int i = 0; i< pattern.length(); i++){\\n            String x = b.substring(0, b.index)\\n        }\\n        */\\n    }\\n}\\nThis code is passing 20/37 testcases, but for some reason a test case is yielding \"IndexOutofBounds\" I have tried looking but I am not sure why this issue still keeps persisting. Any help is aappreciated!"
                    },
                    {
                        "username": "pan__",
                        "content": "Happy New Year!!!!!"
                    },
                    {
                        "username": "abdulhathi",
                        "content": "# Python Time : O(n) Space : O(n)\\n    class Solution:\\n        def wordPattern(self, pattern: str, s: str) -> bool:\\n            patterns = list(pattern)\\n            words = s.split(\" \")\\n            if len(patterns) != len(words):\\n                return False\\n            patternDic = {}\\n            wordDic = {}\\n            for c, word in zip(patterns, words):\\n                if word in wordDic and wordDic[word] != c:\\n                    return False\\n                if c in patternDic and patternDic[c] != word:\\n                    return False\\n                patternDic[c] = word\\n                wordDic[word] = c\\n            return True"
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "Great start from 2023. Wish you all the best for next 364 days, keep maintain the streak friends"
                    },
                    {
                        "username": "Ash990",
                        "content": "The only best way to start a new year. Happy New Year coders !!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "For people failing on test case \\npattern=\"abba\" s=\"dog dog dog dog\" giving false because the question it has mentioned that each letter gets only one word which no onle else gets , in short the letters and strings are in bijection , each letter in pattern gets its own unique word in s.\\nso \\'a\\' and \\'b\\' has both dog , which isn\\'t bijection. "
                    },
                    {
                        "username": "Gayoon1234",
                        "content": "pattern: \"abba\"\ns = \"dog dog dog dog\"\nexpected = false\n\nIn the instructions it doesn't seem to specify that a != b. As I would say that the answer is true since a = b = dog.\n\nEDIT: Turns out bijection means one-to-one, it's been a while since I've studied set theory...\n\nHappy New Year folks!"
                    },
                    {
                        "username": "theaksaa",
                        "content": "the best way to start 2023"
                    }
                ]
            }
        ]
    }
]