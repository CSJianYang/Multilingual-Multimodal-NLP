[
    {
        "title": "Restore IP Addresses",
        "question_content": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\n\tFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n&nbsp;\nExample 1:\n\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\n\nExample 2:\n\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\n\nExample 3:\n\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 20\n\ts consists of digits only.",
        "solutions": [
            {
                "id": 30972,
                "title": "who-can-beat-this-code",
                "content": "\\n        // c++  code\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> ret;\\n            string ans;\\n            \\n            for (int a=1; a<=3; a++)\\n            for (int b=1; b<=3; b++)\\n            for (int c=1; c<=3; c++)\\n            for (int d=1; d<=3; d++)\\n                if (a+b+c+d == s.length()) {\\n                    int A = stoi(s.substr(0, a));\\n                    int B = stoi(s.substr(a, b));\\n                    int C = stoi(s.substr(a+b, c));\\n                    int D = stoi(s.substr(a+b+c, d));\\n                    if (A<=255 && B<=255 && C<=255 && D<=255)\\n                        if ( (ans=to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D)).length() == s.length()+3)\\n                            ret.push_back(ans);\\n                }    \\n            \\n            return ret;\\n        }",
                "solutionTags": [],
                "code": "\\n        // c++  code\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> ret;\\n            string ans;\\n            \\n            for (int a=1; a<=3; a++)\\n            for (int b=1; b<=3; b++)\\n            for (int c=1; c<=3; c++)\\n            for (int d=1; d<=3; d++)\\n                if (a+b+c+d == s.length()) {\\n                    int A = stoi(s.substr(0, a));\\n                    int B = stoi(s.substr(a, b));\\n                    int C = stoi(s.substr(a+b, c));\\n                    int D = stoi(s.substr(a+b+c, d));\\n                    if (A<=255 && B<=255 && C<=255 && D<=255)\\n                        if ( (ans=to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D)).length() == s.length()+3)\\n                            ret.push_back(ans);\\n                }    \\n            \\n            return ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 30949,
                "title": "my-code-in-java",
                "content": "    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<String>();\\n            int len = s.length();\\n            for(int i = 1; i<4 && i<len-2; i++){\\n                for(int j = i+1; j<i+4 && j<len-1; j++){\\n                    for(int k = j+1; k<j+4 && k<len; k++){\\n                        String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);\\n                        if(isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)){\\n                            res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4);\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        public boolean isValid(String s){\\n            if(s.length()>3 || s.length()==0 || (s.charAt(0)=='0' && s.length()>1) || Integer.parseInt(s)>255)\\n                return false;\\n            return true;\\n        }\\n    }\\n\\n3-loop divides the string s into 4 substring: s1, s2, s3, s4. Check if each substring is valid.\\nIn isValid, strings whose length greater than 3 or equals to 0 is not valid; or if the string's length is longer than 1 and the first letter is '0' then it's invalid; or the string whose integer representation greater than 255 is invalid.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<String>();\\n            int len = s.length();\\n            for(int i = 1; i<4 && i<len-2; i++){\\n                for(int j = i+1; j<i+4 && j<len-1; j++){\\n                    for(int k = j+1; k<j+4 && k<len; k++){\\n                        String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);\\n                        if(isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)){\\n                            res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 30944,
                "title": "very-simple-dfs-solution",
                "content": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> solutions = new ArrayList<String>();\\n        restoreIp(s, solutions, 0, \"\", 0);\\n        return solutions;\\n    }\\n    \\n    private void restoreIp(String ip, List<String> solutions, int idx, String restored, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && idx == ip.length()) solutions.add(restored);\\n        \\n        for (int i=1; i<4; i++) {\\n            if (idx+i > ip.length()) break;\\n            String s = ip.substring(idx,idx+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)) continue;\\n            restoreIp(ip, solutions, idx+i, restored+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> solutions = new ArrayList<String>();\\n        restoreIp(s, solutions, 0, \"\", 0);\\n        return solutions;\\n    }\\n    \\n    private void restoreIp(String ip, List<String> solutions, int idx, String restored, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && idx == ip.length()) solutions.add(restored);\\n        \\n        for (int i=1; i<4; i++) {\\n            if (idx+i > ip.length()) break;\\n            String s = ip.substring(idx,idx+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)) continue;\\n            restoreIp(ip, solutions, idx+i, restored+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31140,
                "title": "python-easy-to-understand-solution-backtracking",
                "content": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        res = []\\n        self.dfs(s, 0, \"\", res)\\n        return res\\n    \\n    def dfs(self, s, idx, path, res):\\n        if idx > 4:\\n            return \\n        if idx == 4 and not s:\\n            res.append(path[:-1])\\n            return \\n        for i in range(1, len(s)+1):\\n            if s[:i]==\\'0\\' or (s[0]!=\\'0\\' and 0 < int(s[:i]) < 256):\\n                self.dfs(s[i:], idx+1, path+s[:i]+\".\", res)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        res = []\\n        self.dfs(s, 0, \"\", res)\\n        return res\\n    \\n    def dfs(self, s, idx, path, res):\\n        if idx > 4:\\n            return \\n        if idx == 4 and not s:\\n            res.append(path[:-1])\\n            return \\n        for i in range(1, len(s)+1):\\n            if s[:i]==\\'0\\' or (s[0]!=\\'0\\' and 0 < int(s[:i]) < 256):\\n                self.dfs(s[i:], idx+1, path+s[:i]+\".\", res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079368,
                "title": "c-easy-solution-iterative-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFIterative Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/KfMMaxgF/shared\" frameBorder=\"0\" width=\"800\" height=\"1010\"></iframe>\\n\\n***Time Complexity : `O(1)`\\nSpace Complexity : `O(1)`***\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFIterative Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/KfMMaxgF/shared\" frameBorder=\"0\" width=\"800\" height=\"1010\"></iframe>\\n\\n***Time Complexity : `O(1)`\\nSpace Complexity : `O(1)`***\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3079183,
                "title": "easy-explanation-with-video-and-pics-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Screenshot 2023-01-21 at 6.45.12 AM.png](https://assets.leetcode.com/users/images/a62d9067-6cbb-417d-8f3f-bf9fb150d0d1_1674263738.058996.png)\\n\\nLets take a very simple scenario where we insert just one dot.\\nQuick Observation: The length of the string can be 1, 2 or 3 as the range is 0,255.\\n\\nOnce the function has inserted the dot it will verify if the string is valid or not, in the above example 355 is not valid, so we can discard it.\\n\\nHowever we have one more invalid case i.e 3.555 The approach we can use here is though we are inserting one dot we will make it to insert 2 dots so that the same function will check the validitity of the second part and remove the last dot from ans.\\n\\nThe same approach goes for 3 dots, at each step add a dot --> generate valid answers and pass it down again. \\n\\n![Screenshot 2023-01-21 at 6.51.38 AM.png](https://assets.leetcode.com/users/images/b58bfe69-5df9-4dfb-8d17-ea1cf7e3551b_1674264111.1136658.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse an additional input to the function that is index, which says the function where the string starts from, it is as good as forgetting the already dotted part of the string.\\n\\n\\nAdditional Improvement: Check if the string length is greater than 12, than its completely invalid, Similarly if already 2 dots inserted and the remaining string length is 7 its invalid as well.\\n\\nhttps://youtu.be/h2HmKNdmZ_c\\n\\n![sfw-please-upvote-me-v0-u5cacra0rnca1.webp](https://assets.leetcode.com/users/images/15fbfe1e-a57a-475a-a229-a438ed3f1672_1674264427.05538.webp)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    String str;\\n    public List<String> restoreIpAddresses(String s) {\\n        str = s;\\n        magical(\"\", 0, 0);\\n        return ans;\\n    } \\n\\n    void magical( String path, int index, int dots) {\\n        if (dots > 4) return;\\n        if (dots == 4 && index >= str.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int length = 1; length <= 3 && index + length <= str.length(); length++) {\\n            String num = str.substring(index, index + length);\\n            if (num.charAt(0) == \\'0\\' && length != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                magical( path + str.substring(index, index + length) + \".\", index + length,dots + 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    String str;\\n    public List<String> restoreIpAddresses(String s) {\\n        str = s;\\n        magical(\"\", 0, 0);\\n        return ans;\\n    } \\n\\n    void magical( String path, int index, int dots) {\\n        if (dots > 4) return;\\n        if (dots == 4 && index >= str.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int length = 1; length <= 3 && index + length <= str.length(); length++) {\\n            String num = str.substring(index, index + length);\\n            if (num.charAt(0) == \\'0\\' && length != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                magical( path + str.substring(index, index + length) + \".\", index + length,dots + 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079269,
                "title": "beats-100-0ms-easy-solution-fully-explained-c-python3-java",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful.\\n\\n```\\n# Intuition\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can\\'t be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n# Approach : Backtracking\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        int sz = s.size();\\n        for(int i=ind;i<min(ind+3, sz);i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def valid(self, temp: str) -> bool:\\n        if len(temp) > 3 or len(temp) == 0:\\n            return False\\n        if len(temp) > 1 and temp[0] == \\'0\\':\\n            return False\\n        if len(temp) and int(temp) > 255:\\n            return False\\n        return True\\n\\n    def solve(self, ans, output, ind, s, dots):\\n        if dots == 3:\\n            if self.valid(s[ind:]):\\n                ans.append(output + s[ind:])\\n            return\\n        for i in range(ind, min(ind+3, len(s))):\\n            if self.valid(s[ind:i+1]):\\n                new_output = output + s[ind:i+1] + \\'.\\'\\n                self.solve(ans, new_output, i+1, s, dots+1)\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.solve(ans, \"\", 0, s, 0)\\n        return ans\\n\\n```\\n```Java []\\n private List<String> ipes;\\n   private int l;\\n   public List<String> restoreIpAddresses(String s) {\\n       ipes = new ArrayList<>();\\n       l = s.length();\\n       f(s, 0, \"\", 0);\\n       return ipes;\\n   }\\n   \\n   private boolean isIp(String ip){\\n       if(ip.length() > 3 || ip.length() == 0) return false;\\n       if(ip.length() > 1 && ip.charAt(0) == \\'0\\') return false;\\n       if(ip.length() > 0 && Integer.parseInt(ip) > 255) return false;\\n       return true; \\n   }\\n\\n   private void f(String s, int index, String ip, int dot){\\n       //base case\\n       if(dot == 3){\\n           if(isIp(s.substring(index))) {\\n               ip += s.substring(index);\\n               ipes.add(ip);\\n           }\\n           return;\\n       }\\n\\n       //do all the stuff\\n       for(int i = index; i < l; i++){\\n           if(isIp(s.substring(index, i +1))){\\n               int k = s.substring(index, i+1).length();\\n               ip += s.substring(index, i+1) + \".\";\\n               f(s, i+1, ip, dot+1);\\n               ip = ip.substring(0, ip.length() - k -1);\\n           }\\n       }\\n   }\\n}\\n```\\n```\\n                               Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        int sz = s.size();\\n        for(int i=ind;i<min(ind+3, sz);i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def valid(self, temp: str) -> bool:\\n        if len(temp) > 3 or len(temp) == 0:\\n            return False\\n        if len(temp) > 1 and temp[0] == \\'0\\':\\n            return False\\n        if len(temp) and int(temp) > 255:\\n            return False\\n        return True\\n\\n    def solve(self, ans, output, ind, s, dots):\\n        if dots == 3:\\n            if self.valid(s[ind:]):\\n                ans.append(output + s[ind:])\\n            return\\n        for i in range(ind, min(ind+3, len(s))):\\n            if self.valid(s[ind:i+1]):\\n                new_output = output + s[ind:i+1] + \\'.\\'\\n                self.solve(ans, new_output, i+1, s, dots+1)\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.solve(ans, \"\", 0, s, 0)\\n        return ans\\n\\n```\n```Java []\\n private List<String> ipes;\\n   private int l;\\n   public List<String> restoreIpAddresses(String s) {\\n       ipes = new ArrayList<>();\\n       l = s.length();\\n       f(s, 0, \"\", 0);\\n       return ipes;\\n   }\\n   \\n   private boolean isIp(String ip){\\n       if(ip.length() > 3 || ip.length() == 0) return false;\\n       if(ip.length() > 1 && ip.charAt(0) == \\'0\\') return false;\\n       if(ip.length() > 0 && Integer.parseInt(ip) > 255) return false;\\n       return true; \\n   }\\n\\n   private void f(String s, int index, String ip, int dot){\\n       //base case\\n       if(dot == 3){\\n           if(isIp(s.substring(index))) {\\n               ip += s.substring(index);\\n               ipes.add(ip);\\n           }\\n           return;\\n       }\\n\\n       //do all the stuff\\n       for(int i = index; i < l; i++){\\n           if(isIp(s.substring(index, i +1))){\\n               int k = s.substring(index, i+1).length();\\n               ip += s.substring(index, i+1) + \".\";\\n               f(s, i+1, ip, dot+1);\\n               ip = ip.substring(0, ip.length() - k -1);\\n           }\\n       }\\n   }\\n}\\n```\n```\\n                               Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30998,
                "title": "my-concise-ac-java-code",
                "content": "the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1~3 digits and it must be <255. \\n\\n    static List<String> restoreIpAddresses(String s) {\\n    \\tList<String> ans = new ArrayList<String>();\\n    \\tint len = s.length();\\n    \\tfor (int i = 1; i <=3; ++i){  // first cut\\n    \\t\\tif (len-i > 9) continue;    \\t\\t\\n    \\t\\tfor (int j = i+1; j<=i+3; ++j){  //second cut\\n    \\t\\t\\tif (len-j > 6) continue;    \\t\\t\\t\\n    \\t\\t\\tfor (int k = j+1; k<=j+3 && k<len; ++k){  // third cut\\n    \\t\\t\\t\\tint a,b,c,d;                // the four int's seperated by \".\"\\n    \\t\\t\\t\\ta = Integer.parseInt(s.substring(0,i));  \\n    \\t\\t\\t\\tb = Integer.parseInt(s.substring(i,j)); // notice that \"01\" can be parsed into 1. Need to deal with that later.\\n    \\t\\t\\t\\tc = Integer.parseInt(s.substring(j,k));\\n    \\t\\t\\t\\td = Integer.parseInt(s.substring(k));\\n    \\t\\t\\t\\tif (a>255 || b>255 || c>255 || d>255) continue; \\n    \\t\\t\\t\\tString ip = a+\".\"+b+\".\"+c+\".\"+d;\\n    \\t\\t\\t\\tif (ip.length()<len+3) continue;  // this is to reject those int's parsed from \"01\" or \"00\"-like substrings\\n    \\t\\t\\t\\tans.add(ip);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [],
                "code": "the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1~3 digits and it must be <255. \\n\\n    static List<String> restoreIpAddresses(String s) {\\n    \\tList<String> ans = new ArrayList<String>();\\n    \\tint len = s.length();\\n    \\tfor (int i = 1; i <=3; ++i){  // first cut\\n    \\t\\tif (len-i > 9) continue;    \\t\\t\\n    \\t\\tfor (int j = i+1; j<=i+3; ++j){  //second cut\\n    \\t\\t\\tif (len-j > 6) continue;    \\t\\t\\t\\n    \\t\\t\\tfor (int k = j+1; k<=j+3 && k<len; ++k){  // third cut\\n    \\t\\t\\t\\tint a,b,c,d;                // the four int's seperated by \".\"\\n    \\t\\t\\t\\ta = Integer.parseInt(s.substring(0,i));  \\n    \\t\\t\\t\\tb = Integer.parseInt(s.substring(i,j)); // notice that \"01\" can be parsed into 1. Need to deal with that later.\\n    \\t\\t\\t\\tc = Integer.parseInt(s.substring(j,k));\\n    \\t\\t\\t\\td = Integer.parseInt(s.substring(k));\\n    \\t\\t\\t\\tif (a>255 || b>255 || c>255 || d>255) continue; \\n    \\t\\t\\t\\tString ip = a+\".\"+b+\".\"+c+\".\"+d;\\n    \\t\\t\\t\\tif (ip.length()<len+3) continue;  // this is to reject those int's parsed from \"01\" or \"00\"-like substrings\\n    \\t\\t\\t\\tans.add(ip);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31098,
                "title": "easy-java-code-of-backtracking-within-16-lines",
                "content": "        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<>();\\n            helper(s,\"\",res,0);\\n            return res;\\n        }\\n        public void helper(String s, String tmp, List<String> res,int n){\\n            if(n==4){\\n                if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1));\\n                //substring here to get rid of last '.'\\n                return;\\n            }\\n            for(int k=1;k<=3;k++){\\n                if(s.length()<k) continue;\\n                int val = Integer.parseInt(s.substring(0,k));\\n                if(val>255 || k!=String.valueOf(val).length()) continue;\\n                /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/\\n                helper(s.substring(k),tmp+s.substring(0,k)+\".\",res,n+1);\\n            }\\n        }",
                "solutionTags": [],
                "code": "        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<>();\\n            helper(s,\"\",res,0);\\n            return res;\\n        }\\n        public void helper(String s, String tmp, List<String> res,int n){\\n            if(n==4){\\n                if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1));\\n                //substring here to get rid of last '.'\\n                return;\\n            }\\n            for(int k=1;k<=3;k++){\\n                if(s.length()<k) continue;\\n                int val = Integer.parseInt(s.substring(0,k));\\n                if(val>255 || k!=String.valueOf(val).length()) continue;\\n                /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/\\n                helper(s.substring(k),tmp+s.substring(0,k)+\".\",res,n+1);\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3079133,
                "title": "python3-backtracking-for-beginners",
                "content": "**Code with no comments at the end, in case you don\\'t want to read the story but just want to compare mine with yours**\\n\\nWe have no other choices but to generate **all** possible valid IP **addresses** as the problem asked, backtracking is a good candidate.\\n\\n**Backtracking** is basically **Brute Force**, where we check **all possibilities** using a **Recursive Function**.\\nThe most important parts of backtracking using recursive function are:\\n(1) **return** when we reach to the end and no more states can be generated.\\n(2) **restore the state** after calling the recursive function.\\ni.e.,\\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n(2) change the current state to its neighboring state\\n(3) backtrack(state)\\n(4) restore the state (backtrack)\\n```\\n\\n**For this problem**, we want to build all valid IP addresses one by one (Brute Force). So we do a recursive call on each state. \\n - State is defined as the position ```i``` in ```s``` we are currently visiting and the address we have previously build.\\n - If ```i == len(s)```, we have reached to the end of ```s```, and no more state can be generated. We check if the current ```address``` we build is of exactly four numbers, and add it to the result if it is.\\n - Now, at each position ```i```, we have at most two choices, and we need to check for each option to see if it will result in a valid address.\\n    (1) Add the current digit to the last number in ```address``` if the last number is not 0 (No leading zero) and the concatenated number is <= 255.\\n    (2) Add the current digit in ```address``` as a new number if ```address``` contains less than 4 numbers.\\n - We start the backtracking process by using the first digit in ```s``` as the first number in ```address```.\\n - I used intgers in the address I\\'m building for easier comparing and concatenation.\\n\\n**Code with comments**\\n\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is not 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n**Code with no comments**\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            if i==len(s):\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i])\\n                BT(i+1, address)\\n                address[-1] = lastItem\\n            \\n            if len(address)<4:\\n                BT(i+1,address + [int(s[i])])\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n\\n05/20/2023, Third time I see this question, here is what I did in 10 min:\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        def BT(i,cur):\\n            nonlocal res\\n            if i==len(s):\\n                if len(cur)==4:\\n                    res.append(\\'.\\'.join([str(x) for x in cur]))\\n                return\\n            if len(cur)>4:\\n                return\\n            \\n            BT(i+1, cur+[int(s[i])])\\n            if cur and cur[-1]!=0 and cur[-1]*10+int(s[i])<=255:\\n                cur[-1] = cur[-1]*10+int(s[i])\\n                BT(i+1, cur)\\n                cur[-1] = cur[-1]//10\\n        BT(0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n(2) change the current state to its neighboring state\\n(3) backtrack(state)\\n(4) restore the state (backtrack)\\n```\n```i```\n```s```\n```i == len(s)```\n```s```\n```address```\n```i```\n```address```\n```address```\n```address```\n```s```\n```address```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is not 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            if i==len(s):\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i])\\n                BT(i+1, address)\\n                address[-1] = lastItem\\n            \\n            if len(address)<4:\\n                BT(i+1,address + [int(s[i])])\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        def BT(i,cur):\\n            nonlocal res\\n            if i==len(s):\\n                if len(cur)==4:\\n                    res.append(\\'.\\'.join([str(x) for x in cur]))\\n                return\\n            if len(cur)>4:\\n                return\\n            \\n            BT(i+1, cur+[int(s[i])])\\n            if cur and cur[-1]!=0 and cur[-1]*10+int(s[i])<=255:\\n                cur[-1] = cur[-1]*10+int(s[i])\\n                BT(i+1, cur)\\n                cur[-1] = cur[-1]//10\\n        BT(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31151,
                "title": "share-0ms-neat-and-clear-c-solution-using-dfs",
                "content": "    class Solution {\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> result;\\n            string ip;\\n            dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n            return result;\\n        }\\n        void dfs(string s,int start,int step,string ip,vector<string>& result){\\n            if(start==s.size()&&step==4){\\n                ip.erase(ip.end()-1); //remove the last '.' from the last decimal number\\n                result.push_back(ip);\\n                return;\\n            }\\n            if(s.size()-start>(4-step)*3) return;\\n            if(s.size()-start<(4-step)) return;\\n            int num=0;\\n            for(int i=start;i<start+3;i++){\\n                num=num*10+(s[i]-'0');\\n                if(num<=255){\\n                    ip+=s[i];\\n                    dfs(s,i+1,step+1,ip+'.',result);\\n                }\\n                if(num==0) break;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> result;\\n            string ip;\\n            dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1272225,
                "title": "easy-to-understand-backtracking-c-with-comments",
                "content": "class Solution {\\npublic:\\n    \\n   bool isValid(string s1)\\n   {\\n      \\n       \\n       if(s1.size()>3||s1.size()==0) return false;\\n       \\n       if(s1.size()>1 && s1[0]==\\'0\\') return false;\\n       \\n\\t   // using stoi to convert string to integer \\n\\t   \\n       if(s1.size() && stoi(s1)>255) return false;\\n       \\n       \\n       \\n       return true;\\n           \\n   }\\n    \\n    void recur(int i, int dots, string temp, vector<string>& ans, string s)\\n    {\\n\\t\\t// we have to place 3 dots in the string to make 4 partitions\\n\\t\\t\\n        if(dots==3)\\n        {\\n           // pushing last partition after checking its validity\\n\\t\\t\\t\\t\\n            if(isValid(s.substr(i)))\\n            {\\n           \\n                ans.push_back(temp+s.substr(i));\\n                \\n            }\\n            return;\\n        }\\n\\t\\t\\n        // placing the dot at every valid position\\n\\t\\t\\n        for(int j=i; j<s.size() ;j++)\\n        {\\n\\n\\t\\tif( isValid(s.substr(i, j-i+1)))\\n\\t\\t{\\n\\t\\t\\ttemp.push_back(s[j]);\\n\\t\\t\\ttemp.push_back(\\'.\\');\\n\\n\\t\\t\\trecur(j+1, dots+1, temp, ans, s);\\n\\n\\t\\t   // removing the dot after calling recur function \\n\\n\\t\\t   // note that we don\\'t remove the last digit that was placed in temp string as we just have to change positions of dots only and not digits in string\\n\\t\\t\\ttemp.pop_back();\\n\\n\\n            }\\n        }\\n        \\n        return;\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        vector<string> ans;\\n        \\n        if(s.size()<4) return ans;\\n        \\n        recur(0, 0, \"\", ans, s);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n   bool isValid(string s1)\\n   {\\n      \\n       \\n       if(s1.size()>3||s1.size()==0) return false;\\n       \\n       if(s1.size()>1 && s1[0]==\\'0\\') return false;\\n       \\n\\t   // using stoi to convert string to integer \\n\\t   \\n       if(s1.size() && stoi(s1)>255) return false;\\n       \\n       \\n       \\n       return true;\\n           \\n   }",
                "codeTag": "Java"
            },
            {
                "id": 3079573,
                "title": "java-solution-with-explanation",
                "content": "\\n\\n# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. This code defines a class called \"Solution\" that contains a single public method called \"`restoreIpAddresses`\". This method takes a single input, a string called \"s\", and returns a list of strings.\\n\\n2. The method first initializes two lists, \"`addresses`\" and \"`address`\". \"addresses\" will ultimately hold all of the valid IP addresses that can be created from the input string \"s\", and \"address\" is a temporary list used to store each individual segment of an IP address (i.e., the four numbers that make up an IP address) as the code generates them.\\n\\n3. The method then calls a private helper function called \"`rec`\". This function takes four inputs: the input string \"s\", an integer \"i\" that keeps track of the current position in the string, the \"address\" list, and the \"addresses\" list.\\n\\n4. The function starts by checking if the \"address\" list has a size of 4. If it does, this means that all four segments of the IP address have been generated and it checks if i is equal to the length of the input string. If both of these conditions are true, it means that all of the characters in the input string have been used to generate a valid IP address, so the function converts the \"address\" list to a string and adds it to the \"addresses\" list.\\n\\n5. If the \"address\" list does not have a size of 4, the function enters a loop. The loop iterates from i+1 to i+3 (or until it reaches the end of the input string) and for each iteration, it creates a new string called \"nextInt\" which is a substring of the input string \"s\" starting from index i and ending at index j. Then it checks if the integer value of nextInt is less than or equal to 255 and either nextInt is equal to \"0\" or it doesn\\'t start with \"0\", then it adds this nextInt to the \"address\" list and recursively calls the function with updated inputs. After this call, it removes the last element of \"address\" list.\\n\\n6. This process continues until the function generates all possible valid IP addresses from the input string. The final list of valid IP addresses is returned by the \"restoreIpAddresses\" method.\\n\\n# Code\\n```\\nclass Solution {\\n    public static List<String> restoreIpAddresses(String s) {\\n        // Initialize the list to hold all valid IP addresses\\n        List<String> addresses = new ArrayList<>();\\n        // Initialize the list to hold the current IP address being built\\n        List<String> address = new ArrayList<>();\\n        // Call the recursive helper function to generate all possible IP addresses\\n        rec(s, 0, address, addresses);\\n        // Return the list of all valid IP addresses\\n        return addresses;\\n    }\\n    private static void rec(String s, int i, List<String> address, List<String> addresses) {\\n        // If the current address has 4 segments, check if we have reached the end of the input string\\n        if (address.size() == 4) {\\n            if (i == s.length()) {\\n                // If we have reached the end of the input string, add the current address to the list of valid addresses\\n                addresses.add(String.join(\".\", address));\\n            }\\n        } else {\\n            // Try all possible next segments for the current address\\n            for (int j = i + 1; j <= i + 3 && j <= s.length(); j++) {\\n                String nextInt = s.substring(i, j);\\n                // Check if the next segment is valid (between 0 and 255, and not starting with 0 unless it is 0)\\n                if (Integer.parseInt(nextInt) <= 255 && (nextInt.equals(\"0\") || !nextInt.startsWith(\"0\"))) {\\n                    // Add the next segment to the current address\\n                    address.add(nextInt);\\n                    // Recursively call the function to generate the next segment\\n                    rec(s, j, address, addresses);\\n                    // Remove the last segment from the current address\\n                    address.remove(address.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static List<String> restoreIpAddresses(String s) {\\n        // Initialize the list to hold all valid IP addresses\\n        List<String> addresses = new ArrayList<>();\\n        // Initialize the list to hold the current IP address being built\\n        List<String> address = new ArrayList<>();\\n        // Call the recursive helper function to generate all possible IP addresses\\n        rec(s, 0, address, addresses);\\n        // Return the list of all valid IP addresses\\n        return addresses;\\n    }\\n    private static void rec(String s, int i, List<String> address, List<String> addresses) {\\n        // If the current address has 4 segments, check if we have reached the end of the input string\\n        if (address.size() == 4) {\\n            if (i == s.length()) {\\n                // If we have reached the end of the input string, add the current address to the list of valid addresses\\n                addresses.add(String.join(\".\", address));\\n            }\\n        } else {\\n            // Try all possible next segments for the current address\\n            for (int j = i + 1; j <= i + 3 && j <= s.length(); j++) {\\n                String nextInt = s.substring(i, j);\\n                // Check if the next segment is valid (between 0 and 255, and not starting with 0 unless it is 0)\\n                if (Integer.parseInt(nextInt) <= 255 && (nextInt.equals(\"0\") || !nextInt.startsWith(\"0\"))) {\\n                    // Add the next segment to the current address\\n                    address.add(nextInt);\\n                    // Recursively call the function to generate the next segment\\n                    rec(s, j, address, addresses);\\n                    // Remove the last segment from the current address\\n                    address.remove(address.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31113,
                "title": "java-recursive-backtracking-easy-to-read",
                "content": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new LinkedList<>();\\n        int[] path = new int[4];\\n        helper(ret, s, 0,  path, 0);\\n        return ret;\\n    }\\n    \\n    void helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n        if(segment == 4 && idx == s.length() ){\\n            acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n            return ;\\n        }else if(segment == 4 || idx == s.length() ){\\n            return ;\\n        }\\n        \\n        for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n            int val = Integer.parseInt(s.substring(idx, idx + len));\\n            // range check, no leading 0.\\n            if(val > 255 || len >= 2  && s.charAt(idx) == '0') \\n                break; \\n                \\n            path[segment] = val;\\n            helper(acc, s, idx + len, path, segment + 1);\\n            path[segment] = -1; // for debug. \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new LinkedList<>();\\n        int[] path = new int[4];\\n        helper(ret, s, 0,  path, 0);\\n        return ret;\\n    }\\n    \\n    void helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n        if(segment == 4 && idx == s.length() ){\\n            acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n            return ;\\n        }else if(segment == 4 || idx == s.length() ){\\n            return ;\\n        }\\n        \\n        for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n            int val = Integer.parseInt(s.substring(idx, idx + len));\\n            // range check, no leading 0.\\n            if(val > 255 || len >= 2  && s.charAt(idx) == '0') \\n                break; \\n                \\n            path[segment] = val;\\n            helper(acc, s, idx + len, path, segment + 1);\\n            path[segment] = -1; // for debug. \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31184,
                "title": "beautiful-c-backtracking-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> result;\\n        string solution;\\n        \\n        vector<string> restoreIpAddresses(string s) {\\n            \\n            backtracking(s, 0, 0);\\n            \\n            return result;\\n        }\\n        \\n    private:\\n        void backtracking(string s, int start, int part)\\n        {\\n            if(start == s.size() && part == 4)\\n            {\\n                result.push_back(solution);\\n                return;\\n            }\\n            \\n            for(int i = start; i < s.size(); i++)\\n            {\\n                if(part < 4 && i-start < 3 && validIP(s, start, i))\\n                {\\n                    solution.append(s.substr(start, i-start+1));\\n                    part++;\\n                    if(part < 4) solution.push_back('.');\\n    \\n                    backtracking(s, i+1, part);\\n                    \\n                    if(part < 4) solution.pop_back();\\n                    part--;\\n                    for(int j = 0; j < i-start+1; j++) solution.pop_back();\\n                }\\n            }\\n        }\\n        \\n        bool validIP(string s, int start, int end)\\n        {\\n            string temp = s.substr(start, end-start+1);\\n            int ip = stoll(temp);\\n            \\n            if(s[start] == '0' && start != end) return false;\\n            else if(ip >= 0 && ip <= 255) return true;\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> result;\\n        string solution;\\n        \\n        vector<string> restoreIpAddresses(string s) {\\n            \\n            backtracking(s, 0, 0);\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3079263,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=Tw4Mfxv0MJM&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=21) if you are interested.\\n\\n---\\n\\n**Iterative Approach**\\n\\n<iframe src=\"https://leetcode.com/playground/MVq87gRz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=Tw4Mfxv0MJM&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=21) if you are interested.\\n\\n---\\n\\n**Iterative Approach**\\n\\n<iframe src=\"https://leetcode.com/playground/MVq87gRz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3079377,
                "title": "clean-codes-full-explanation-recursion-c-java-python3",
                "content": "# Exaplanation to Approach :\\n1. The main idea to solve this problem is to use Recursion.\\n2. Consider every position of the input string and, there exist two possible cases:\\n    - Place a dot over the current position.\\n    - Take this character, i.e don\\u2019t place the dot over this position.\\n3. At every step of the recursion, we have the following data:\\n    - curr stores the string between two dots.\\n    - res stores the possible IP Address.\\n    - index stores the current position in the input string.\\n4. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n5. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n# Request \\uD83D\\uDE0A :\\n- If you find this solution easy to understand and helpful, then Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/336747b3-ffea-40aa-b4e0-bf2146e509ea_1674271394.8886068.gif)\\n\\n# Code [C++] :\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void recurse(string res,string curr,int index,string s){\\n        if(index==s.length()){\\n            if(curr.empty() and count(res.begin(),res.end(),\\'.\\')==3){\\n                ans.push_back(res);\\n            }\\n            return;\\n        }\\n        if(!curr.empty() and stoi(curr)==0){\\n            return;\\n        }\\n        curr.push_back(s[index]);\\n        if(stoi(curr)>255){\\n            return;\\n        }\\n        recurse(res,curr,index+1,s);\\n        if(!res.empty()){\\n            recurse(res+\".\"+curr,\"\",index+1,s);\\n        }\\n        else{\\n            recurse(curr,\"\",index+1,s);\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        recurse(\"\",\"\",0,s);\\n        return ans;\\n    }\\n};\\n```\\n# Code [Java] :\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        recurse(s, ans, 0, \"\", 0);\\n        return ans;\\n    }\\n    private void recurse(String curr, List<String> ans, int index, String temp, int count) {\\n        if (count > 4)\\n            return;\\n        if (count == 4 && index == curr.length())\\n            ans.add(temp);\\n        for (int i=1; i<4; i++) {\\n            if (index+i > curr.length()){\\n                break;\\n            }\\n            String s = curr.substring(index,index+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)){\\n                continue;\\n            }\\n            recurse(curr, ans, index+i, temp+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }\\n}\\n```\\n# Code [Python3] :\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.recurse(s, ans, 0, \"\", 0)\\n        return ans\\n    \\n    def recurse(self, curr, ans, index, temp, count):\\n        if count > 4:\\n            return\\n        if count == 4 and index == len(curr):\\n            ans.append(temp)\\n        for i in range(1, 4):\\n            if index + i > len(curr):\\n                break\\n            s = curr[index:index+i]\\n            if (s.startswith(\"0\") and len(s) > 1) or (i == 3 and int(s) >= 256):\\n                continue\\n            self.recurse(curr, ans, index+i, temp + s + (\".\" if count < 3 else \"\"), count+1)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void recurse(string res,string curr,int index,string s){\\n        if(index==s.length()){\\n            if(curr.empty() and count(res.begin(),res.end(),\\'.\\')==3){\\n                ans.push_back(res);\\n            }\\n            return;\\n        }\\n        if(!curr.empty() and stoi(curr)==0){\\n            return;\\n        }\\n        curr.push_back(s[index]);\\n        if(stoi(curr)>255){\\n            return;\\n        }\\n        recurse(res,curr,index+1,s);\\n        if(!res.empty()){\\n            recurse(res+\".\"+curr,\"\",index+1,s);\\n        }\\n        else{\\n            recurse(curr,\"\",index+1,s);\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        recurse(\"\",\"\",0,s);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        recurse(s, ans, 0, \"\", 0);\\n        return ans;\\n    }\\n    private void recurse(String curr, List<String> ans, int index, String temp, int count) {\\n        if (count > 4)\\n            return;\\n        if (count == 4 && index == curr.length())\\n            ans.add(temp);\\n        for (int i=1; i<4; i++) {\\n            if (index+i > curr.length()){\\n                break;\\n            }\\n            String s = curr.substring(index,index+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)){\\n                continue;\\n            }\\n            recurse(curr, ans, index+i, temp+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.recurse(s, ans, 0, \"\", 0)\\n        return ans\\n    \\n    def recurse(self, curr, ans, index, temp, count):\\n        if count > 4:\\n            return\\n        if count == 4 and index == len(curr):\\n            ans.append(temp)\\n        for i in range(1, 4):\\n            if index + i > len(curr):\\n                break\\n            s = curr[index:index+i]\\n            if (s.startswith(\"0\") and len(s) > 1) or (i == 3 and int(s) >= 256):\\n                continue\\n            self.recurse(curr, ans, index+i, temp + s + (\".\" if count < 3 else \"\"), count+1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164573,
                "title": "c-c-python-super-clean-iterative-approach-and-fast-recursive-without-converting-to-numbers",
                "content": "# TL;DR\\n## Iterative solution. No pruning done.\\n#### Python\\n```python\\n  def restoreIpAddresses(self, s):\\n    ret = []\\n    for a in range(1, 4):\\n      for b in range(1, 4):\\n        for c in range(1, 4):\\n          d = len(s) - a - b - c\\n          \"\"\"\\n          Last number must use all remaining digits. Check;\\n          1. The size of the last number is valid\\n          2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          \"\"\"\\n          if (1 <= d <= 3 and\\n            (1 == a or \\'0\\' != s[0        ]) and (a != 3 or s[         :a        ] <= \"255\") and\\n            (1 == b or \\'0\\' != s[a        ]) and (b != 3 or s[a        :a + b    ] <= \"255\") and\\n            (1 == c or \\'0\\' != s[a + b    ]) and (c != 3 or s[a + b    :a + b + c] <= \"255\") and\\n            (1 == d or \\'0\\' != s[a + b + c]) and (d != 3 or s[a + b + c:         ] <= \"255\")):\\n            ret.append(\\'.\\'.join([s[0:a], s[a:a + b], s[a + b:a + b + c], s[a + b + c:]]))\\n    return ret\\n```\\t\\t\\n#### c++\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n   \\n    for (int a = 1; a <= 3; ++a) {\\n      for (int b = 1; b <= 3; ++b) {\\n        for (int c = 1; c <= 3; ++c) {\\n          int d = s.size() - a - b - c;\\n          // Last number must use all remaining digits. Check;\\n          // 1. The size of the last number is valid\\n          // 2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          if (1 <= d && d <= 3 && \\n            (1 == a || \\'0\\' != s[0        ] && (3 != a || 0 < memcmp(\"256\", &s[0        ], 3))) &&\\n            (1 == b || \\'0\\' != s[a        ] && (3 != b || 0 < memcmp(\"256\", &s[a        ], 3))) &&\\n            (1 == c || \\'0\\' != s[a + b    ] && (3 != c || 0 < memcmp(\"256\", &s[a + b    ], 3))) &&\\n            (1 == d || \\'0\\' != s[a + b + c] && (3 != d || 0 < memcmp(\"256\", &s[a + b + c], 3)))) \\n          {\\n            ret.emplace_back(s.substr(0, a) + \".\" + s.substr(a, b) + \".\" + s.substr(a + b, c) + \".\" + s.substr(a + b + c));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\\t\\n## Iterative solution, with pruning. Super fast with minimal loops.\\n### c\\n```\\nchar ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }\\n          char* dest = (char*) malloc(len + 4);\\n          memcpy(dest        , s    , a    );\\n          dest[a] = \\'.\\';\\n          memcpy(dest + a + 1, s + a, b - a);\\n          dest[b + 1] = \\'.\\';\\n          memcpy(dest + b + 2, s + b, c - b);\\n          dest[c + 2] = \\'.\\';\\n          memcpy(dest + c + 3, s + c, len - c);\\n          dest[len + 3] = \\'\\\\0\\';\\n          ret[(*returnSize)++] = dest;\\n        }\\n      }\\n    }\\n  }\\n  return ret;\\n}\\n```\\n## Recursive solution, with pruning. Not as pretty, but fast\\nI didn\\'t bother doing this in python, because... well you don\\'t care about speed if you\\'re using python.\\n### c++\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    char temp[15 + 1] = {0};\\n    \\n    // Recursive function that progressively cycles through valid numbers lengths \\n    std::function <void (const char* pos, int len, char* buf, int count)> helper;\\n    helper = [&ret, &temp, &helper] (const char* pos, int len, char* buf, int count) -> void {\\n      // Check if there is the right amount of input string left\\n      if (len >= (4 - count) && len <= (4 - count) * 3) {\\n        if (4 == count)\\n        {\\n          ret.push_back(temp);\\n        } else {\\n          // \\'0\\' is a special case. \\'0\\' is valid number, \"00\" is not. Only recurse on a single digit\\n          int sub_len = (\\'0\\' == *pos) ? 1 : std::min(3, len);\\n\\n          // Recurse around, using upto 3 digits for the number, then 2, then 1\\n          buf += sprintf(buf, \"%s%.*s\", ((count) ? \".\" : \"\"), sub_len, pos);\\n          switch (sub_len) {\\n            default: \\n              if (0 < memcmp(\"256\", pos, 3)) {\\n                helper(pos + 3, len - 3, buf, count + 1);\\n              }\\n              --buf;  // Fall-through*/\\n            case 2: helper(pos + 2, len - 2, buf--, count + 1); // Fall-through\\n            case 1: helper(pos + 1, len - 1, buf--, count + 1);\\n          }\\n        }\\n      }\\n    };\\n    \\n    helper(s.c_str(), s.size(), temp, 0);\\n    return ret;\\n  }\\n```\\t\\n# Details\\nA simple solution would be to just try every possible length for the 4 ip numbers. That\\'s 3^4 = 81 possible values, so quite doable if your time constant isn\\'t too bad. In fact, since the total length of all the numbers must equal the string size, if you know your first 3 number lengths, the 4th is known. Therefore there is actually only 3^3 = 27 possible values to check; very doable.\\n\\nThings to be aware of are;\\n1. Numbers, apart from _0_, do not start with \\'0\\'. _0_ itself is only ever a single digit. eg. \"00\" and \"01\" are not valid numbers.\\n2. Numbers must be less than or equal to 255.\\n\\nChecking 1. is relatively simple. `len == 1 || \\'0\\' != digit[0]` will handle that.\\n\\nChecking 2. can be done many ways;\\n* Convert the number string to an actual number using `atoi`, `stoi` or similar. This can be an expensive operation to do a lot, since it often requires terminateing the substring/creating a copy.\\n* An ugly as if. `if (3 != len || (\\'2\\' > digit[0] || (\\'2\\' == digit[0] && (\\'5\\' > digit[1] || (\\'5\\' == digit[1] && \\'5\\' >= digit[2])))))`, which is fast, but makes your eyes bleed.\\n* `memcmp` directly against a string. Fast and efficent.\\n\\nI choose to use the `memcmp` approach because it allows the entire solution to be done without ever converting a string to a number or a number to a string.\\n\\n### Iterative solution\\nWtih that decided and aiming for neat code, I produced the logical iterative approach. This has no pruning, so it will always perform 27 comparisons, even if the input string size means there is no possible solution. For example \"0\" or \"00000\" will not cause a quick bail out. I think the clean code was worth it, particularly since the constant will be low.\\n\\nI originally used some stl to follow the DRY principle, but it\\'s not as clean. This is what I had;\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    int len[4];\\n    int offs[4] = {0};\\n   \\n    for (len[0] = 1; len[0] <= 3; ++len[0]) {\\n      for (len[1] = 1; len[1] <= 3; ++len[1]) {\\n        for (len[2] = 1; len[2] <= 3; ++len[2]) {\\n          std::partial_sum(std::begin(len), std::end(len) - 1, std::begin(offs) + 1);\\n          if (offs[3] >= s.size() - 3 && 1 <= (len[3] = s.size() - offs[3]) && \\n            all_of(begin(offs), end(offs), [l_it = begin(len), &s] (int off) mutable { \\n              return (1 == *l_it || \\'0\\' != s[off]) && (3 != *l_it++ || 0 < memcmp(\"256\", &s[off], 3)); \\n            }))\\n          {\\n            ret.emplace_back(s.substr(0, len[0]) + \".\" + s.substr(offs[1], len[1]) + \".\" + s.substr(offs[2], len[2]) + \".\" + s.substr(offs[3]));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\\nI decided to unroll it and decided to keep it clean. It is the same reason I didn\\'t use the non concatinating and faster code below to build the final result string.\\n```cpp\\nsprintf(buf, \"%.*s.%.*s.%.*s.%s\", a, &s[0], b, &s[a], c, &s[a + b], &s[a + b + c]);\\nret.emplace_back(buf);\\n```\\n\\nThe fastest solution is in c and basically just builds on the above approaches, but shifts the individual checks for each group into the associated `for`. The reason for this is in the above cases, the outside loop could produce an invalid value but the value will only be checked after all the nesting in the `if`, thus causing multiple loops that bail because of the same condition. It\\'s a bit ugly, but super fast.\\n\\n### Recursive solution\\nThe pruning, recursive solution is not nearly as clean, but is very quick. The only real trick to was to use a `switch` statement and abuse the fall-though to try the diffent length and handle the less than 255 at the same time.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```python\\n  def restoreIpAddresses(self, s):\\n    ret = []\\n    for a in range(1, 4):\\n      for b in range(1, 4):\\n        for c in range(1, 4):\\n          d = len(s) - a - b - c\\n          \"\"\"\\n          Last number must use all remaining digits. Check;\\n          1. The size of the last number is valid\\n          2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          \"\"\"\\n          if (1 <= d <= 3 and\\n            (1 == a or \\'0\\' != s[0        ]) and (a != 3 or s[         :a        ] <= \"255\") and\\n            (1 == b or \\'0\\' != s[a        ]) and (b != 3 or s[a        :a + b    ] <= \"255\") and\\n            (1 == c or \\'0\\' != s[a + b    ]) and (c != 3 or s[a + b    :a + b + c] <= \"255\") and\\n            (1 == d or \\'0\\' != s[a + b + c]) and (d != 3 or s[a + b + c:         ] <= \"255\")):\\n            ret.append(\\'.\\'.join([s[0:a], s[a:a + b], s[a + b:a + b + c], s[a + b + c:]]))\\n    return ret\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n   \\n    for (int a = 1; a <= 3; ++a) {\\n      for (int b = 1; b <= 3; ++b) {\\n        for (int c = 1; c <= 3; ++c) {\\n          int d = s.size() - a - b - c;\\n          // Last number must use all remaining digits. Check;\\n          // 1. The size of the last number is valid\\n          // 2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          if (1 <= d && d <= 3 && \\n            (1 == a || \\'0\\' != s[0        ] && (3 != a || 0 < memcmp(\"256\", &s[0        ], 3))) &&\\n            (1 == b || \\'0\\' != s[a        ] && (3 != b || 0 < memcmp(\"256\", &s[a        ], 3))) &&\\n            (1 == c || \\'0\\' != s[a + b    ] && (3 != c || 0 < memcmp(\"256\", &s[a + b    ], 3))) &&\\n            (1 == d || \\'0\\' != s[a + b + c] && (3 != d || 0 < memcmp(\"256\", &s[a + b + c], 3)))) \\n          {\\n            ret.emplace_back(s.substr(0, a) + \".\" + s.substr(a, b) + \".\" + s.substr(a + b, c) + \".\" + s.substr(a + b + c));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\n```\\nchar ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }\\n          char* dest = (char*) malloc(len + 4);\\n          memcpy(dest        , s    , a    );\\n          dest[a] = \\'.\\';\\n          memcpy(dest + a + 1, s + a, b - a);\\n          dest[b + 1] = \\'.\\';\\n          memcpy(dest + b + 2, s + b, c - b);\\n          dest[c + 2] = \\'.\\';\\n          memcpy(dest + c + 3, s + c, len - c);\\n          dest[len + 3] = \\'\\\\0\\';\\n          ret[(*returnSize)++] = dest;\\n        }\\n      }\\n    }\\n  }\\n  return ret;\\n}\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    char temp[15 + 1] = {0};\\n    \\n    // Recursive function that progressively cycles through valid numbers lengths \\n    std::function <void (const char* pos, int len, char* buf, int count)> helper;\\n    helper = [&ret, &temp, &helper] (const char* pos, int len, char* buf, int count) -> void {\\n      // Check if there is the right amount of input string left\\n      if (len >= (4 - count) && len <= (4 - count) * 3) {\\n        if (4 == count)\\n        {\\n          ret.push_back(temp);\\n        } else {\\n          // \\'0\\' is a special case. \\'0\\' is valid number, \"00\" is not. Only recurse on a single digit\\n          int sub_len = (\\'0\\' == *pos) ? 1 : std::min(3, len);\\n\\n          // Recurse around, using upto 3 digits for the number, then 2, then 1\\n          buf += sprintf(buf, \"%s%.*s\", ((count) ? \".\" : \"\"), sub_len, pos);\\n          switch (sub_len) {\\n            default: \\n              if (0 < memcmp(\"256\", pos, 3)) {\\n                helper(pos + 3, len - 3, buf, count + 1);\\n              }\\n              --buf;  // Fall-through*/\\n            case 2: helper(pos + 2, len - 2, buf--, count + 1); // Fall-through\\n            case 1: helper(pos + 1, len - 1, buf--, count + 1);\\n          }\\n        }\\n      }\\n    };\\n    \\n    helper(s.c_str(), s.size(), temp, 0);\\n    return ret;\\n  }\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    int len[4];\\n    int offs[4] = {0};\\n   \\n    for (len[0] = 1; len[0] <= 3; ++len[0]) {\\n      for (len[1] = 1; len[1] <= 3; ++len[1]) {\\n        for (len[2] = 1; len[2] <= 3; ++len[2]) {\\n          std::partial_sum(std::begin(len), std::end(len) - 1, std::begin(offs) + 1);\\n          if (offs[3] >= s.size() - 3 && 1 <= (len[3] = s.size() - offs[3]) && \\n            all_of(begin(offs), end(offs), [l_it = begin(len), &s] (int off) mutable { \\n              return (1 == *l_it || \\'0\\' != s[off]) && (3 != *l_it++ || 0 < memcmp(\"256\", &s[off], 3)); \\n            }))\\n          {\\n            ret.emplace_back(s.substr(0, len[0]) + \".\" + s.substr(offs[1], len[1]) + \".\" + s.substr(offs[2], len[2]) + \".\" + s.substr(offs[3]));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\n```cpp\\nsprintf(buf, \"%.*s.%.*s.%.*s.%s\", a, &s[0], b, &s[a], c, &s[a + b], &s[a + b + c]);\\nret.emplace_back(buf);\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3080185,
                "title": "beats-100-simple-c-very-short-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply use brute force and one thing here is that length of any integer can\\'t be more than three because 255 is limit so we can use 4 loops of 3 size and check if individual integers are less than 256 .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse 4 loops from 1 to 3 and check the substrings are less than 256 .\\nSome Implementation Techniques to be taken care of:\\n- first check i+j+k+m== s.size because we should not take some part of string that is valid but not of given string size.\\n- then don\\'t take directly substr because it can have leading zeroes like \"`255 045 003 12`\" On taking stoi leading zeores will be gone then convert to string again.(Beacuse (str)\"045\"--> (int)$$45$$)\\n- then compare with 256 to all substrings use stoi again  for comparing .(Direct string comparison may not work)\\n- then add the dots in btween substrings and check if final length is given string length + 3 then push in ans (in case if it exceeds size or less than so make sure to check).\\n- **HelpFull?UpVoTe\\uD83D\\uDD3C:\\u2764**\\n# Complexity\\n- Time complexity:($$O(1)$$) Actually $$O(M^N*N)$$\\n- Since loops $$O(M*M*M*M)$$  and then substr take another N iterations.\\n- Here M=3 and N=4 so constant time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n- actually $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n       int temp=256;\\n        for(int i=1;i<=3;i++)\\n        for(int j=1;j<=3;j++)\\n        for(int k=1;k<=3;k++)\\n        for(int m=1;m<=3;m++)\\n            if(i+j+k+m==s.length()){\\n            string s1=to_string(stoi(s.substr(0,i)));\\n            string s2=to_string(stoi(s.substr(i,j)));\\n            string s3=to_string(stoi(s.substr(i+j,k)));\\n            string s4=to_string(stoi(s.substr(i+j+k,m)));\\n            if(stoi(s1)<temp and stoi(s2)<temp and stoi(s3)<temp and stoi(s4)<temp){\\n                string t=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                if(t.length()==s.length()+3)\\n                ans.push_back(t);\\n            }\\n            }\\n        return ans;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n       int temp=256;\\n        for(int i=1;i<=3;i++)\\n        for(int j=1;j<=3;j++)\\n        for(int k=1;k<=3;k++)\\n        for(int m=1;m<=3;m++)\\n            if(i+j+k+m==s.length()){\\n            string s1=to_string(stoi(s.substr(0,i)));\\n            string s2=to_string(stoi(s.substr(i,j)));\\n            string s3=to_string(stoi(s.substr(i+j,k)));\\n            string s4=to_string(stoi(s.substr(i+j+k,m)));\\n            if(stoi(s1)<temp and stoi(s2)<temp and stoi(s3)<temp and stoi(s4)<temp){\\n                string t=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                if(t.length()==s.length()+3)\\n                ans.push_back(t);\\n            }\\n            }\\n        return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079197,
                "title": "day-21-beginner-friendly-backtracking-solution-with-diagram",
                "content": "# Intuition\\n1. if length of string is greater than 12 then it never be a valid IP address.\\n2. we will put dot for every point and for each dot we have 3 choices.\\n![b58bfe69-5df9-4dfb-8d17-ea1cf7e3551b_1674264111.1136658.png](https://assets.leetcode.com/users/images/259966b7-f127-4826-b1e5-04fb798c881c_1674266598.3424137.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize an empty list (or vector in C++), res, to store the valid IP addresses.\\n2. Check if the length of the input string is greater than 12, if so return the empty list.\\n3. Create a backtrack function that takes four parameters: s, i, dots, and currIp.\\n4. s is the input string\\n5. i is the current index of the string being processed\\n6. dots represents the number of dots that have been added to the current IP address\\n7. currIp represents the current IP address being formed\\n8. Within the backtrack function, check if the number of dots is equal to 4 and the current index is equal to the length of the input string, in which case add the current IP address to the res list and return.\\n9. Check if the number of dots is greater than 4, if so return.\\n10. Iterate through the input string using a for loop, starting from the current index and ending at the minimum of current index plus 3 or the length of the input string.\\n11. Within the for loop, check if the substring of the input string from the current index to the current loop index is less than 256 and either the current index is equal to the loop index or the character at the current index of the input string is not equal to 0.\\n12. If the above conditions are met, recursively call the backtrack function, passing in the loop index plus 1, dots plus 1, current IP address concatenated with the substring of the input string and a dot as the parameters.\\n13. After the for loop, return the res list.\\n\\nThis algorithm generates all possible valid IP addresses from the given string by adding dots between the substrings of the input string and then checks if it is a valid IP address.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void backtrack(string s, int i, int dots, string currIp, vector<string>& res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.push_back(currIp.substr(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) \\n            return;\\n\\n        for (int j = i; j < min(i+3, (int)s.length()); j++) {\\n            //the i==j check is used to determine if the current substring being considered as a part of the IP address is a single digit or not. If i is equal to j, it means that the current substring is a single digit. This check is used in conjunction with the check s[i] != \\'0\\' to ensure that the IP address being considered is a valid one, where each segment is between 0-255 and no leading zeroes are present.\\n            if (stoi(s.substr(i, j-i+1)) < 256 && (i == j || s[i] != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substr(i, j-i+1) + \".\", res);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> res;\\n        if (s.length() > 12)\\n            return res;\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s.length() > 12) return res;\\n\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n    \\n    public void backtrack(String s, int i, int dots, String currIp, List<String> res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.add(currIp.substring(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) return;\\n\\n        for (int j = i; j < Math.min(i+3, s.length()); j++) {\\n            if (Integer.parseInt(s.substring(i, j+1)) < 256 && (i == j || s.charAt(i) != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substring(i, j+1) + \".\", res);\\n            }\\n        }\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        if len(s) > 12:\\n            return res\\n\\n        def backtrack(i , dots, currIp):\\n            if dots == 4 and i == len(s):\\n                res.append(currIp[:-1])\\n                return\\n            if dots > 4:\\n                return\\n\\n            for j in range(i, min(i+3, len(s))):\\n                if int(s[i:j+1]) < 256 and (i == j or s[i] != \"0\"):\\n                    backtrack(j + 1, dots + 1, currIp + s[i:j+1] + \".\")\\n\\n        backtrack(0, 0, \"\")\\n        return res\\n```\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Complexity\\n- Time complexity: **O(3^n)**\\nThe time complexity of the above code is O(3^4) which is equivalent to O(81).\\n\\n**The reason is that for each character in the input string, there are 3 choices:**\\n\\n1. The character is the last character of an octet, the next octet starts from the next character.\\n2. The character is the second last character of an octet, the next octet starts from the next character.\\n3. The character is the third last character of an octet, the next octet starts from the next character.\\n\\n**As we are using backtracking and at most 4 octets are possible , so it will check all the possible combinations of 3^4 which is equal to 81.**\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n1. The space complexity of the code is O(n), where n is the length of the input string. This is because the maximum recursion depth is equal to the length of the input string and each level of recursion requires O(n) space to store the current IP address. The resultant list of IP addresses also takes O(n) space as the length of each IP address is equal to the length of the input string.\\n2. It is worth noting that since we are keeping track of the number of dots and the current IP address, the actual space complexity is O(1) since the amount of extra space used does not depend on the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void backtrack(string s, int i, int dots, string currIp, vector<string>& res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.push_back(currIp.substr(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) \\n            return;\\n\\n        for (int j = i; j < min(i+3, (int)s.length()); j++) {\\n            //the i==j check is used to determine if the current substring being considered as a part of the IP address is a single digit or not. If i is equal to j, it means that the current substring is a single digit. This check is used in conjunction with the check s[i] != \\'0\\' to ensure that the IP address being considered is a valid one, where each segment is between 0-255 and no leading zeroes are present.\\n            if (stoi(s.substr(i, j-i+1)) < 256 && (i == j || s[i] != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substr(i, j-i+1) + \".\", res);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> res;\\n        if (s.length() > 12)\\n            return res;\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s.length() > 12) return res;\\n\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n    \\n    public void backtrack(String s, int i, int dots, String currIp, List<String> res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.add(currIp.substring(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) return;\\n\\n        for (int j = i; j < Math.min(i+3, s.length()); j++) {\\n            if (Integer.parseInt(s.substring(i, j+1)) < 256 && (i == j || s.charAt(i) != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substring(i, j+1) + \".\", res);\\n            }\\n        }\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        if len(s) > 12:\\n            return res\\n\\n        def backtrack(i , dots, currIp):\\n            if dots == 4 and i == len(s):\\n                res.append(currIp[:-1])\\n                return\\n            if dots > 4:\\n                return\\n\\n            for j in range(i, min(i+3, len(s))):\\n                if int(s[i:j+1]) < 256 and (i == j or s[i] != \"0\"):\\n                    backtrack(j + 1, dots + 1, currIp + s[i:j+1] + \".\")\\n\\n        backtrack(0, 0, \"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754098,
                "title": "must-read-highly-commented-cpp-code-each-and-every-line-commented-with-examples-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    string solution;\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        //initally our start==0 and part==0 as we haven\\'t start processing.\\n        backtracking(s, 0, 0);\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtracking(string s, int start, int part)\\n    {\\n        \\n        if(start == s.size() && part == 4)\\n        {\\n            result.push_back(solution);\\n            return;\\n        }\\n        //Start trasversing the string till the end of the string.\\n        for(int i = start; i < s.size(); i++)\\n        {\\n            //if we satisfy 3 Conditions, we need to continue else Not.\\n            /*\\n            1- if part<4 means if we have a.b. part==2, need more processing. \\n            2- (i-start<3): we are just handling max to max 3 characters. like if we have\\n                1234.5 stop processing.\\n            3- the string from start to current i. string(start,i)= is valid\\n            */\\n            if(part < 4 && i-start < 3 && validIP(s, start, i))\\n            {\\n                //append that string to solution.[ its appennd]\\n                solution.append(s.substr(start, i-start+1));\\n                //included 1 part so incrementing the part by 1.\\n                part++;\\n                //if parts remaining : then we add \\'.\\' else we dont need like 123.456.123.2\\n                if(part < 4) solution.push_back(\\'.\\');\\n                //go from i+1 and do the reaming from i+1 till end of the string.\\n                backtracking(s, i+1, part);\\n                // if its the last part No need of popping the last character eg: 255.255.111.35, \\n                //No need of popping the 35.\\n                if(part < 4) solution.pop_back();\\n                \\n                \\n                //decrement the parts coz we are trying the next combination.\\n                // eg: 255.255.11 part was 3, Now we are ready to remove 11, and try for 111 so do\\n                // parts--.\\n                part--;\\n                //remove the part added. \\n                for(int j = 0; j < i-start+1; j++) solution.pop_back();\\n            }\\n            //else continue;\\n        }\\n    }\\n    \\n    \\n    bool validIP(string s, int start, int end)\\n    {\\n        //find the substring from start to the end and convert into integer.\\n        string temp = s.substr(start, end-start+1);\\n        int ip = stoi(temp);\\n        \\n        //if we have ip=012, its invalid but if its ip=0 its valid like 127.0.0.1 :p\\n        if(s[start] == \\'0\\' && start != end) return false;\\n        //self explanatory\\n        else if(ip >= 0 && ip <= 255) return true;\\n        \\n        //eg: 256\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> result;\\n    string solution;\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        //initally our start==0 and part==0 as we haven\\'t start processing.\\n        backtracking(s, 0, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 30946,
                "title": "dfs-in-python",
                "content": "    class Solution(object):\\n        def restoreIpAddresses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            ans = []\\n            self.helper(ans, s, 4, [])\\n            return ['.'.join(x) for x in ans]\\n            \\n        def helper(self, ans, s, k, temp):\\n            if len(s) > k*3:\\n                return\\n            if k == 0:\\n                ans.append(temp[:])\\n            else:\\n                for i in range(min(3,len(s)-k+1)):\\n                    if i==2 and int(s[:3]) > 255 or i > 0 and s[0] == '0':\\n                        continue\\n                    self.helper(ans, s[i+1:], k-1, temp+[s[:i+1]])",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def restoreIpAddresses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            ans = []\\n            self.helper(ans, s, 4, [])\\n            return ['.'.join(x) for x in ans]\\n            \\n        def helper(self, ans, s, k, temp):\\n            if len(s) > k*3:\\n                return\\n            if k == 0:\\n                ans.append(temp[:])\\n            else:\\n                for i in range(min(3,len(s)-k+1)):\\n                    if i==2 and int(s[:3]) > 255 or i > 0 and s[0] == '0':\\n                        continue\\n                    self.helper(ans, s[i+1:], k-1, temp+[s[:i+1]])",
                "codeTag": "Java"
            },
            {
                "id": 672543,
                "title": "javascript-the-most-clean-backtracking-solution",
                "content": "```javascript\\nvar restoreIpAddresses = function(s) {\\n    const result = []\\n    \\n    function permute(arr, str) {\\n        if(arr.length === 3) {\\n            if(isValid(str)) result.push([...arr, str]);\\n            return;\\n        }\\n        \\n        for(let i = 1; i < 4; i++) {\\n            let subStr = str.slice(0, i);\\n            if(!isValid(subStr)) continue;\\n            permute([...arr, subStr], str.slice(i));\\n        }\\n    }\\n    \\n    function isValid(str) {\\n        if(+str > 255 || !str.length) return false;\\n        if(str.length >= 2 && str[0] === \\'0\\') return false;\\n        return true;\\n    }\\n    \\n    permute([], s);\\n    return result.map(x => x.join(\\'.\\'))\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar restoreIpAddresses = function(s) {\\n    const result = []\\n    \\n    function permute(arr, str) {\\n        if(arr.length === 3) {\\n            if(isValid(str)) result.push([...arr, str]);\\n            return;\\n        }\\n        \\n        for(let i = 1; i < 4; i++) {\\n            let subStr = str.slice(0, i);\\n            if(!isValid(subStr)) continue;\\n            permute([...arr, subStr], str.slice(i));\\n        }\\n    }\\n    \\n    function isValid(str) {\\n        if(+str > 255 || !str.length) return false;\\n        if(str.length >= 2 && str[0] === \\'0\\') return false;\\n        return true;\\n    }\\n    \\n    permute([], s);\\n    return result.map(x => x.join(\\'.\\'))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818933,
                "title": "python-backtracking-solution-99-with-illustration-and-example",
                "content": "The underlying backtracking algorithm is the same with problem 39/40/46/47/90.\\nBut this problem has more constraints thus needs to consider how to include each constraint in the codes.\\nFirstly, the condition to append one single answer to the answer list. I started with len(s) == 0 but found out I could have something like 0.0.0.0.0, which is an invalid IP address. Thus I added a counter k for each \\'.\\'  and k==4 is added to the condition\\n\\nSecond, I need to stop the operation if either hit the end(len(s)==0) or k==4. \\n\\nAlso, I need to include some validation conditions like below wihin the loop.    \\n\\t\\t\\'\\'\\'\\n\\t\\tif int(s[:i+1])>255:\\n            continue\\n        if i != 0 and s[0]==\\'0\\':\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nThe backtracking process illustrated below for better understanding. Also refer to my post for these backtracking problems for your information. \\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n\\n![image](https://assets.leetcode.com/users/images/c38255ec-14e1-4648-971f-6f6708447844_1598737546.865669.png)\\n\\n\\n\\t\\t\\n\\n\\n\\t\\'\\'\\'\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        k = 0\\n        self.backtrack(s,ans,k,\\'\\')\\n        return ans\\n        \\n    \\n    \\n    def backtrack(self, s, ans,k, temp=\\'\\'):\\n        if k==4 and len(s)==0:\\n            ans.append(temp[:-1])\\n            return\\n        if k==4 or len(s)==0:\\n            return\\n        \\n        for i in range(3):\\n            if k>4 or i+1>len(s):\\n                break\\n            \\n            if int(s[:i+1])>255:\\n                continue\\n            if i != 0 and s[0]==\\'0\\':\\n                continue\\n                    \\n            self.backtrack(s[i+1:], ans, k+1, temp+s[:i+1]+\\'.\\')",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "The underlying backtracking algorithm is the same with problem 39/40/46/47/90.\\nBut this problem has more constraints thus needs to consider how to include each constraint in the codes.\\nFirstly, the condition to append one single answer to the answer list. I started with len(s) == 0 but found out I could have something like 0.0.0.0.0, which is an invalid IP address. Thus I added a counter k for each \\'.\\'  and k==4 is added to the condition\\n\\nSecond, I need to stop the operation if either hit the end(len(s)==0) or k==4. \\n\\nAlso, I need to include some validation conditions like below wihin the loop.    \\n\\t\\t\\'\\'\\'\\n\\t\\tif int(s[:i+1])>255:\\n            continue\\n        if i != 0 and s[0]==\\'0\\':\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nThe backtracking process illustrated below for better understanding. Also refer to my post for these backtracking problems for your information. \\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n\\n![image](https://assets.leetcode.com/users/images/c38255ec-14e1-4648-971f-6f6708447844_1598737546.865669.png)\\n\\n\\n\\t\\t\\n\\n\\n\\t\\'\\'\\'\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        k = 0\\n        self.backtrack(s,ans,k,\\'\\')\\n        return ans\\n        \\n    \\n    \\n    def backtrack(self, s, ans,k, temp=\\'\\'):\\n        if k==4 and len(s)==0:\\n            ans.append(temp[:-1])\\n            return\\n        if k==4 or len(s)==0:\\n            return\\n        \\n        for i in range(3):\\n            if k>4 or i+1>len(s):\\n                break\\n            \\n            if int(s[:i+1])>255:\\n                continue\\n            if i != 0 and s[0]==\\'0\\':\\n                continue\\n                    \\n            self.backtrack(s[i+1:], ans, k+1, temp+s[:i+1]+\\'.\\')",
                "codeTag": "Python3"
            },
            {
                "id": 791997,
                "title": "beautiful-code-of-backtracking-with-generic-explanation",
                "content": "**Inspiration: BackToBackSWE**\\n* **Choice**: Take a snippet of length 1 to 3 \\n* **Constraint**: Each snippet must be in the range [0,255] and not leading zeroes\\n* **Goal**: When the build pointer will be at the end and we have 4 snippets or segments in total\\n\\n*If we have more than 4 segments or the build pointer goes out of limit, that won\\'t give the valid decomposition and we have to backtrack and try another length for the snippet.*\\n\\n**Time and space: O(1) since we have limited ip addresses (There are only 2^32 ip addresses since ipV4 is of 32 bit.)** (More about this at the end)\\n\\n```\\nclass Solution {\\npublic:\\n    void decomposeIpAddresses(string s, vector<string>&snippets, vector<string>&ipAddresses, int buildPointer){\\n\\n        // goal or base case\\n        if(buildPointer == s.size() && snippets.size() == 4){\\n            cout<<\"a\"<<endl;\\n            ipAddresses.push_back(snippets[0] + \\'.\\'+ snippets[1] + \\'.\\' + snippets[2] + \\'.\\' + snippets[3]);\\n            return ;\\n        }\\n        else if(buildPointer == s.size() || snippets.size() == 4){\\n            return ;\\n        }\\n\\n\\n        for(int len = 1; len <= 3 && buildPointer + len <= s.size(); len++){\\n            // choice\\n            string snippet = s.substr(buildPointer, len);\\n\\n            // constraint\\n            if( (stoi(snippet) > 255) || (snippet.size() > 1 && snippet[0] == \\'0\\') )break;\\n\\n            // Choose , explore , Unchoose\\n            snippets.push_back(snippet);\\n            decomposeIpAddresses(s, snippets, ipAddresses, buildPointer+len);\\n            snippets.pop_back();\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ipAddresses;\\n        vector<string>snippets;\\n        decomposeIpAddresses(s, snippets, ipAddresses, 0);\\n        return ipAddresses;\\n    }\\n};\\n```\\nTime complexity:  The big O notation shows an upper bound of number of your operations as your input size increases. But for this problem the input size cannot go over 12 digits and there are no more than 2^32 possibilities for your IP address. So the curve of your graph becomes constant beyond a point as n (size of the string) can\\'t be greater than 12. Hence the upper bound for this algorithm is constant.",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void decomposeIpAddresses(string s, vector<string>&snippets, vector<string>&ipAddresses, int buildPointer){\\n\\n        // goal or base case\\n        if(buildPointer == s.size() && snippets.size() == 4){\\n            cout<<\"a\"<<endl;\\n            ipAddresses.push_back(snippets[0] + \\'.\\'+ snippets[1] + \\'.\\' + snippets[2] + \\'.\\' + snippets[3]);\\n            return ;\\n        }\\n        else if(buildPointer == s.size() || snippets.size() == 4){\\n            return ;\\n        }\\n\\n\\n        for(int len = 1; len <= 3 && buildPointer + len <= s.size(); len++){\\n            // choice\\n            string snippet = s.substr(buildPointer, len);\\n\\n            // constraint\\n            if( (stoi(snippet) > 255) || (snippet.size() > 1 && snippet[0] == \\'0\\') )break;\\n\\n            // Choose , explore , Unchoose\\n            snippets.push_back(snippet);\\n            decomposeIpAddresses(s, snippets, ipAddresses, buildPointer+len);\\n            snippets.pop_back();\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ipAddresses;\\n        vector<string>snippets;\\n        decomposeIpAddresses(s, snippets, ipAddresses, 0);\\n        return ipAddresses;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 31211,
                "title": "adding-a-python-solution-also-requesting-for-improvement",
                "content": "\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n             \\n         def restoreIpAddresses(self,s):\\n     \\n             answer = []\\n     \\n             s_len = len(s)\\n     \\n             for i in [1,2,3]:\\n                 for j in [i+1,i+2,i+3]:\\n                     for k in [j+1,j+2,j+3]:\\n                         if k >= s_len:\\n                             continue\\n                         s1 = s[:i]\\n                         s2 = s[i:j]\\n                         s3 = s[j:k]\\n                         s4 = s[k:]\\n                         if self.check_valid([s1,s2,s3,s4]):\\n                             new_string = s1 + \".\" + s2 + \".\" + s3 + \".\" + s4\\n                             answer.append(new_string)\\n     \\n             return answer\\n     \\n         def check_valid(self,str_list):\\n     \\n             for s in str_list:\\n                 if s[0] == \"0\" and s != \"0\":\\n                     return False\\n                 if int(s) > 255:\\n                     return False\\n     \\n             return True",
                "solutionTags": [],
                "code": "\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n             \\n         def restoreIpAddresses(self,s):\\n     \\n             answer = []\\n     \\n             s_len = len(s)\\n     \\n             for i in [1,2,3]:\\n                 for j in [i+1,i+2,i+3]:\\n                     for k in [j+1,j+2,j+3]:\\n                         if k >= s_len:\\n                             continue\\n                         s1 = s[:i]\\n                         s2 = s[i:j]\\n                         s3 = s[j:k]\\n                         s4 = s[k:]\\n                         if self.check_valid([s1,s2,s3,s4]):\\n                             new_string = s1 + \".\" + s2 + \".\" + s3 + \".\" + s4\\n                             answer.append(new_string)\\n     \\n             return answer\\n     \\n         def check_valid(self,str_list):\\n     \\n             for s in str_list:\\n                 if s[0] == \"0\" and s != \"0\":\\n                     return False\\n                 if int(s) > 255:\\n                     return False\\n     \\n             return True",
                "codeTag": "Java"
            },
            {
                "id": 1554723,
                "title": "beats-100-of-c-submissions-clear-commented-code-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079093,
                "title": "python3-simple-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def works(self, s):\\n        return s == str(int(s)) and int(s) <= 255\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        n = len(s)\\n        ans = []\\n        for i in range(1, n):\\n            for j in range(i + 1, n):\\n                for k in range(j + 1, n):\\n                    a, b, c, d = s[:i], s[i:j], s[j:k], s[k:]\\n                    if self.works(a) and self.works(b) and self.works(c) and self.works(d):\\n                        ans.append(f\\'{a}.{b}.{c}.{d}\\')\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def works(self, s):\\n        return s == str(int(s)) and int(s) <= 255\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        n = len(s)\\n        ans = []\\n        for i in range(1, n):\\n            for j in range(i + 1, n):\\n                for k in range(j + 1, n):\\n                    a, b, c, d = s[:i], s[i:j], s[j:k], s[k:]\\n                    if self.works(a) and self.works(b) and self.works(c) and self.works(d):\\n                        ans.append(f\\'{a}.{b}.{c}.{d}\\')\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880655,
                "title": "easy-undersrtand-java-solution-with-explanation",
                "content": "```\\n   public List<String> restoreIpAddresses(String s) {\\n        List<String> addresses = new ArrayList<>();\\n        // if the length of the string is longer than 12 which can not form a valid IP\\n        if (s.length() > 12 || s.length() == 0)\\n            return addresses;\\n        backtracking(addresses, new ArrayList<String>(), s, 0);\\n        return addresses;\\n    }\\n\\n    private void backtracking(List<String> addresses, List<String> temp, String s, int start) {\\n        // once reach to end of the string and the have four num inside the list\\n        // then join these four nums and add to result list\\n        if (start == s.length() && temp.size() == 4) {\\n            addresses.add(String.join(\".\", temp));\\n            return;\\n        }\\n\\n        // each number is between 0 and 255\\n        // which is 1 digit to 3 digit\\n        // so we have three different choices for each number\\n        // 1. substring from start to start+1\\n        // 2. substring from start to start+2\\n        // 3. substring from start to start+3\\n        for (int i = 1; i <= 3; i++) {\\n            if (start + i > s.length())\\n                return;\\n            String address = s.substring(start, start + i);\\n            // check the address validation\\n            if (validAddress(address)) {\\n                // add valid num into List\\n                // start a new backtracking\\n                temp.add(address);\\n                backtracking(addresses, temp, s, start + i);\\n                temp.remove(temp.size() - 1);\\n\\n            }\\n        }\\n    }\\n\\n    // To valid the given address\\n    // each integer is between 0 and 255 and can not start with 0\\n    private boolean validAddress(String address) {\\n        return !((address.charAt(0) == \\'0\\' && address.length() > 1) || Integer.parseInt(address) > 255);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n   public List<String> restoreIpAddresses(String s) {\\n        List<String> addresses = new ArrayList<>();\\n        // if the length of the string is longer than 12 which can not form a valid IP\\n        if (s.length() > 12 || s.length() == 0)\\n            return addresses;\\n        backtracking(addresses, new ArrayList<String>(), s, 0);\\n        return addresses;\\n    }\\n\\n    private void backtracking(List<String> addresses, List<String> temp, String s, int start) {\\n        // once reach to end of the string and the have four num inside the list\\n        // then join these four nums and add to result list\\n        if (start == s.length() && temp.size() == 4) {\\n            addresses.add(String.join(\".\", temp));\\n            return;\\n        }\\n\\n        // each number is between 0 and 255\\n        // which is 1 digit to 3 digit\\n        // so we have three different choices for each number\\n        // 1. substring from start to start+1\\n        // 2. substring from start to start+2\\n        // 3. substring from start to start+3\\n        for (int i = 1; i <= 3; i++) {\\n            if (start + i > s.length())\\n                return;\\n            String address = s.substring(start, start + i);\\n            // check the address validation\\n            if (validAddress(address)) {\\n                // add valid num into List\\n                // start a new backtracking\\n                temp.add(address);\\n                backtracking(addresses, temp, s, start + i);\\n                temp.remove(temp.size() - 1);\\n\\n            }\\n        }\\n    }\\n\\n    // To valid the given address\\n    // each integer is between 0 and 255 and can not start with 0\\n    private boolean validAddress(String address) {\\n        return !((address.charAt(0) == \\'0\\' && address.length() > 1) || Integer.parseInt(address) > 255);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080515,
                "title": "recursion-deep-dive-explanation",
                "content": "\\n# Approach\\nFor every position, we have two choices, either to insert the dot over there, or to not insert, also we need all possible addresses. Recursion is a very obivous choice. for every possibility check whether there exists a valid address or not, if it does store it and return it.\\n\\n\\n# Code Explanation\\n***The convert_to_int(string str)*** function takes a string as input and converts it to an integer. It first checks if the string is empty or has more than 3 characters, in which case it returns 256. It then checks for leading zeroes in the string and if it finds any, it also returns 256. If the string is a valid number, it converts it to an integer and returns it.\\n\\n***The valid_ip(string IP_part)*** function takes a string as input and checks if it is a valid IP address. It first checks if the string contains any characters other than \\'.\\' or numbers and returns false if it finds any. It then iterates through the string, checking each substring between dots and using the convert_to_int(string str) function to convert it to an integer. If the integer is greater than 255 or the substring is empty, the function returns false. If all substrings are valid, the function returns true.\\n\\n***The recursive_function*** generates all possible IP addresses by adding dots to the input string. It takes four inputs: the input string, a vector to store the valid IP addresses, an integer \\'i\\' that keeps track of the current position in the string, and an integer \\'dot\\' that keeps track of the number of dots that have been added to the string. The function first checks if all 3 dots have been placed, and if so, it checks for the validity of the IP address using the valid_ip(string IP_part) function and stores it in the vector if it is valid. If all dots have not been placed yet, the function then checks if the current position \\'i\\' is within the bounds of the string. It then has two options: either not add a dot at the current position, or add a dot at the current position. In both cases, it calls itself recursively with the updated string, position and dot count.\\n\\nFinally, Call the recursive_function to generate **all possible IP addresses** and returns the vector of valid IP addresses.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    int convert_to_int(string str)\\n    {\\n        // Return 256 because number greater than 255 will return false\\n        if (str.size() == 0 || str.size() > 3)\\n            return 256;\\n        int leading_zeroes = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            if (str[i] != \\'0\\')\\n                break;\\n            else\\n                leading_zeroes++;\\n        }\\n        // If the number contains leading zeroes, we will return 256\\n        if (leading_zeroes >= 1 && (str.size() != 1))\\n            return 256;\\n        int converted_number = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            converted_number *= 10;\\n            converted_number += (str[i] - \\'0\\');\\n        }\\n        // Returning converted valid number\\n        return converted_number;\\n    }\\n    // Boolean function which will rwtuen true if IP address is valid\\n    bool valid_ip(string IP_part)\\n    {\\n        // If string contains characters other than \\'.\\' or numbers, we will return false\\n        for (int i = 0; i < IP_part.length(); i++)\\n            if (IP_part[i] != \\'.\\' && (IP_part[i] < \\'0\\' || IP_part[i] > \\'9\\'))\\n                return false;\\n        // Trying for a valid ip part between dots\\n        string valid_IP_part = \"\";\\n        for (int i = 0; i < IP_part.length(); i++)\\n        {\\n            if (IP_part[i] == \\'.\\')\\n            {\\n                // Return false if number is greater than 25 or 2 dots are adjacent\\n                if ((valid_IP_part == \"\") || (convert_to_int(valid_IP_part) > 255))\\n                    return false;\\n                else\\n                    valid_IP_part = \"\";\\n            }\\n            else\\n                valid_IP_part += IP_part[i];\\n        }\\n        // Checking the num because last nuumber escaped the check because of else\\n        if (convert_to_int(valid_IP_part) > 255)\\n            return false;\\n        return true;\\n    }\\n    void recursive_function(string s, vector<string> &ans, int i, int dot)\\n    {\\n        // If all dots have been placed, we will check for validity\\n        if (dot == 3)\\n        {\\n            // If IP adress will be Stored if valid\\n            if (valid_ip(s))\\n                ans.push_back(s);\\n            return;\\n        }\\n        if (i >= s.length())\\n            return;\\n        // Either we not put the dot\\n        recursive_function(s, ans, i + 1, dot);\\n        // Or we put the dot\\n        string temp;\\n        // Inserting the dot\\n        for (int k = 0; k < i; k++)\\n            temp += s[k];\\n        temp += \\'.\\';\\n        for (int k = i; k < s.length(); k++)\\n            temp += s[k];\\n        recursive_function(temp, ans, i + 1, dot + 1);\\n    }\\n\\npublic:\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        // Storing IP adresses\\n        vector<string> ans;\\n        recursive_function(s, ans, 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n***Exponential***: This is because for every position there are two operation, either to putting dot, or not putting dot. However this wont be done for more than three dots. (So, somewhere less than exponential.) The other functions have relatively lower complexities (is_valid: O(n), convert to int: O(str.length)).\\n\\n- Space complexity:\\n ***O(n)***: This is because after every function call a new stack frame to the call stack is added, and the maximum depth of the recursion stack is n.\\n\\n\\n*DO UPVOTE IF YOU FOUND THIS HELPFUL :)*",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    int convert_to_int(string str)\\n    {\\n        // Return 256 because number greater than 255 will return false\\n        if (str.size() == 0 || str.size() > 3)\\n            return 256;\\n        int leading_zeroes = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            if (str[i] != \\'0\\')\\n                break;\\n            else\\n                leading_zeroes++;\\n        }\\n        // If the number contains leading zeroes, we will return 256\\n        if (leading_zeroes >= 1 && (str.size() != 1))\\n            return 256;\\n        int converted_number = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            converted_number *= 10;\\n            converted_number += (str[i] - \\'0\\');\\n        }\\n        // Returning converted valid number\\n        return converted_number;\\n    }\\n    // Boolean function which will rwtuen true if IP address is valid\\n    bool valid_ip(string IP_part)\\n    {\\n        // If string contains characters other than \\'.\\' or numbers, we will return false\\n        for (int i = 0; i < IP_part.length(); i++)\\n            if (IP_part[i] != \\'.\\' && (IP_part[i] < \\'0\\' || IP_part[i] > \\'9\\'))\\n                return false;\\n        // Trying for a valid ip part between dots\\n        string valid_IP_part = \"\";\\n        for (int i = 0; i < IP_part.length(); i++)\\n        {\\n            if (IP_part[i] == \\'.\\')\\n            {\\n                // Return false if number is greater than 25 or 2 dots are adjacent\\n                if ((valid_IP_part == \"\") || (convert_to_int(valid_IP_part) > 255))\\n                    return false;\\n                else\\n                    valid_IP_part = \"\";\\n            }\\n            else\\n                valid_IP_part += IP_part[i];\\n        }\\n        // Checking the num because last nuumber escaped the check because of else\\n        if (convert_to_int(valid_IP_part) > 255)\\n            return false;\\n        return true;\\n    }\\n    void recursive_function(string s, vector<string> &ans, int i, int dot)\\n    {\\n        // If all dots have been placed, we will check for validity\\n        if (dot == 3)\\n        {\\n            // If IP adress will be Stored if valid\\n            if (valid_ip(s))\\n                ans.push_back(s);\\n            return;\\n        }\\n        if (i >= s.length())\\n            return;\\n        // Either we not put the dot\\n        recursive_function(s, ans, i + 1, dot);\\n        // Or we put the dot\\n        string temp;\\n        // Inserting the dot\\n        for (int k = 0; k < i; k++)\\n            temp += s[k];\\n        temp += \\'.\\';\\n        for (int k = i; k < s.length(); k++)\\n            temp += s[k];\\n        recursive_function(temp, ans, i + 1, dot + 1);\\n    }\\n\\npublic:\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        // Storing IP adresses\\n        vector<string> ans;\\n        recursive_function(s, ans, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778168,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737445,
                "title": "python-concise-backtracking-using-template",
                "content": "Runtime: 28 ms, faster than 94.82% of Python3 online submissions for Restore IP Addresses.\\nMemory Usage: 13.8 MB, less than 54.16% of Python3 online submissions for Restore IP Addresses.\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.res = []\\n        self.backtrack(s, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, s, current, start):\\n        if len(current) == 4 and start == len(s):\\n            self.res.append(\".\".join(current))\\n            return\\n        if len(current) > 4:\\n            return\\n        for i in range(start, min(start+3, len(s))):\\n            if s[start] == \\'0\\' and i > start:\\n                continue\\n            if int(s[start:i+1]) <= 255:\\n                self.backtrack(s, current + [s[start:i+1]], i + 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.res = []\\n        self.backtrack(s, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, s, current, start):\\n        if len(current) == 4 and start == len(s):\\n            self.res.append(\".\".join(current))\\n            return\\n        if len(current) > 4:\\n            return\\n        for i in range(start, min(start+3, len(s))):\\n            if s[start] == \\'0\\' and i > start:\\n                continue\\n            if int(s[start:i+1]) <= 255:\\n                self.backtrack(s, current + [s[start:i+1]], i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504942,
                "title": "java-clean-code-with-choose-explore-unchoose-template-of-backtracking",
                "content": "```java\\npublic List<String> restoreIpAddresses(String s) {\\n\\tList<String> result = new ArrayList<>();\\n\\tif (s == null || s.length() == 0 || s.length() > 12) return result;\\n\\n\\trestoreIpAddressesHelper(s, 0, 0, new StringBuilder(), result);\\n\\treturn result;\\n}\\n\\nprivate void restoreIpAddressesHelper(String s, int index, int count, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  StringBuilder sb, List<String> result) {\\n\\t// Base cases\\n\\tif (index == s.length() && count == 3) {\\n\\t\\tresult.add(sb.toString());\\n\\t\\treturn;\\n\\t}\\n\\tif (count > 3) return;\\n\\n\\tfor (int i = index; i < s.length(); i++) {\\n\\t\\tString part = s.substring(index, i + 1);\\n\\n\\t\\tif (part.length() == 0 || part.length() > 1 && part.charAt(0) == \\'0\\' || \\n\\t\\t   Integer.valueOf(part) > 255) break; // No point of exploring more, so break from the loop\\n\\n\\t\\tint len = sb.length();\\n\\t\\t// Choose\\n\\t\\tsb.append(part);\\n\\n\\t\\t// Explore\\n\\t\\tif (i + 1 == s.length())\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count, sb, result);\\n\\t\\telse {\\n\\t\\t\\tsb.append(\".\"); // Add . in each time, except the last part\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count + 1, sb, result);\\n\\t\\t}\\t\\t\\n\\t\\t// Unchoose\\n\\t\\tsb.setLength(len);\\n\\t}        \\n}\\n\\t",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\npublic List<String> restoreIpAddresses(String s) {\\n\\tList<String> result = new ArrayList<>();\\n\\tif (s == null || s.length() == 0 || s.length() > 12) return result;\\n\\n\\trestoreIpAddressesHelper(s, 0, 0, new StringBuilder(), result);\\n\\treturn result;\\n}\\n\\nprivate void restoreIpAddressesHelper(String s, int index, int count, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  StringBuilder sb, List<String> result) {\\n\\t// Base cases\\n\\tif (index == s.length() && count == 3) {\\n\\t\\tresult.add(sb.toString());\\n\\t\\treturn;\\n\\t}\\n\\tif (count > 3) return;\\n\\n\\tfor (int i = index; i < s.length(); i++) {\\n\\t\\tString part = s.substring(index, i + 1);\\n\\n\\t\\tif (part.length() == 0 || part.length() > 1 && part.charAt(0) == \\'0\\' || \\n\\t\\t   Integer.valueOf(part) > 255) break; // No point of exploring more, so break from the loop\\n\\n\\t\\tint len = sb.length();\\n\\t\\t// Choose\\n\\t\\tsb.append(part);\\n\\n\\t\\t// Explore\\n\\t\\tif (i + 1 == s.length())\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count, sb, result);\\n\\t\\telse {\\n\\t\\t\\tsb.append(\".\"); // Add . in each time, except the last part\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count + 1, sb, result);\\n\\t\\t}\\t\\t\\n\\t\\t// Unchoose\\n\\t\\tsb.setLength(len);\\n\\t}        \\n}\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3079578,
                "title": "java-easy-understanding-using-recursion-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>al=new ArrayList<>();\\n        if(s.length()>12) return al;\\n        help(0,s,al,new ArrayList<>());\\n        return al;\\n    }\\n    public static void help(int ind,String s,List<String>al,ArrayList<String>ds){\\n        if(ind==s.length()&&ds.size()==4){\\n            al.add(String.join(\".\",ds));\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(ind+i>s.length()) return;\\n            String add=s.substring(ind,ind+i);\\n            if(!(add.charAt(0)==\\'0\\'&&add.length()>1||Integer.parseInt(add)>255)){\\n                ds.add(add);\\n                help(ind+i,s,al,ds);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>al=new ArrayList<>();\\n        if(s.length()>12) return al;\\n        help(0,s,al,new ArrayList<>());\\n        return al;\\n    }\\n    public static void help(int ind,String s,List<String>al,ArrayList<String>ds){\\n        if(ind==s.length()&&ds.size()==4){\\n            al.add(String.join(\".\",ds));\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(ind+i>s.length()) return;\\n            String add=s.substring(ind,ind+i);\\n            if(!(add.charAt(0)==\\'0\\'&&add.length()>1||Integer.parseInt(add)>255)){\\n                ds.add(add);\\n                help(ind+i,s,al,ds);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926120,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        if s.count > 12 || s.count < 4 { return [] }\\n        \\n        var chars = Array(s)     \\n        var res: [String] = []\\n        \\n        func backtarck(_ path: [Int], _ length: Int) {\\n            if path.count == 4 {\\n                if length == chars.count {\\n                    var string = \"\"\\n                    for (i, c) in chars.enumerated() {\\n                        string += String(c)\\n                        if i < length - 1 && path.contains(i + 1) {\\n                            string += \".\"\\n                        }\\n                    }\\n                    res.append(string)\\n                }\\n                return\\n            }\\n            \\n            var path = path\\n            for i in 1..<4 {\\n                if i + length > chars.count { break }\\n                \\n                if i >= 2 {\\n                    if Int(String(chars[length]))! == 0 { break }\\n                }\\n                \\n                if i == 3 {\\n                    if Int(String(chars[length]) + String(chars[length + 1]) + String(chars[length + 2]))! > 255 { break }\\n                }\\n                \\n                path.append(length + i)\\n                backtarck(path, length + i)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([], 0)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        if s.count > 12 || s.count < 4 { return [] }\\n        \\n        var chars = Array(s)     \\n        var res: [String] = []\\n        \\n        func backtarck(_ path: [Int], _ length: Int) {\\n            if path.count == 4 {\\n                if length == chars.count {\\n                    var string = \"\"\\n                    for (i, c) in chars.enumerated() {\\n                        string += String(c)\\n                        if i < length - 1 && path.contains(i + 1) {\\n                            string += \".\"\\n                        }\\n                    }\\n                    res.append(string)\\n                }\\n                return\\n            }\\n            \\n            var path = path\\n            for i in 1..<4 {\\n                if i + length > chars.count { break }\\n                \\n                if i >= 2 {\\n                    if Int(String(chars[length]))! == 0 { break }\\n                }\\n                \\n                if i == 3 {\\n                    if Int(String(chars[length]) + String(chars[length + 1]) + String(chars[length + 2]))! > 255 { break }\\n                }\\n                \\n                path.append(length + i)\\n                backtarck(path, length + i)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([], 0)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336483,
                "title": "simple-dfs-python-solution-36ms",
                "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self, s: str, path: List, result: List):\\n        \\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self, s: str, path: List, result: List):\\n        \\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31084,
                "title": "java-easy-to-understand-recursive-solution",
                "content": "        \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new ArrayList<>();\\n        dfs(s, 0, 0, \"\", ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(String s, int idx, int c, String path, List<String> ret) {\\n        if (c >= 4) {\\n            if (idx == s.length()) {\\n                ret.add(path.substring(0, path.length()-1));\\n            }\\n            return;\\n        }\\n        for (int i = idx+1; i <= s.length(); i++) {\\n            if (isValid(s.substring(idx, i))) {\\n                dfs(s, i, c+1, path + s.substring(idx, i) + '.', ret);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.startsWith(\"0\") && !s.equals(\"0\")) {\\n            return false;\\n        }\\n        return s.length() < 4 && 0 <= Integer.valueOf(s) && Integer.valueOf(s) < 256;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new ArrayList<>();\\n        dfs(s, 0, 0, \"\", ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(String s, int idx, int c, String path, List<String> ret) {\\n        if (c >= 4) {\\n            if (idx == s.length()) {\\n                ret.add(path.substring(0, path.length()-1));\\n            }\\n            return;\\n        }\\n        for (int i = idx+1; i <= s.length(); i++) {\\n            if (isValid(s.substring(idx, i))) {\\n                dfs(s, i, c+1, path + s.substring(idx, i) + '.', ret);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.startsWith(\"0\") && !s.equals(\"0\")) {\\n            return false;\\n        }\\n        return s.length() < 4 && 0 <= Integer.valueOf(s) && Integer.valueOf(s) < 256;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3080285,
                "title": "c-simple-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void help(int idx, int k, vector<string> &make, string &s)\\n    {\\n        if (idx >= s.size())\\n        {\\n            if (k == -1)\\n            {\\n                string t;\\n                for (auto i : make)\\n                    t.append(i), t.push_back(\\'.\\');\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            return;\\n        }\\n\\n        if (k < 0)\\n            return;\\n\\n        if (s[idx] == \\'0\\')\\n        {\\n            string t;\\n            t.push_back(s[idx]);\\n            make.push_back(t);\\n            help(idx + 1, k - 1, make, s);\\n            make.pop_back();\\n            return;\\n        }\\n\\n        for (int i = idx; i < min(idx + 3, (int)s.size()); i++)\\n        {\\n            string t = s.substr(idx, i - idx + 1);\\n            int val = stoi(t);\\n            if (val >= 0 and val <= 255)\\n            {\\n                make.push_back(t);\\n                help(i + 1, k - 1, make, s);\\n                make.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        if (s.size() > 12)\\n            return {};\\n\\n        vector<string> make;\\n        help(0, 3, make, s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void help(int idx, int k, vector<string> &make, string &s)\\n    {\\n        if (idx >= s.size())\\n        {\\n            if (k == -1)\\n            {\\n                string t;\\n                for (auto i : make)\\n                    t.append(i), t.push_back(\\'.\\');\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            return;\\n        }\\n\\n        if (k < 0)\\n            return;\\n\\n        if (s[idx] == \\'0\\')\\n        {\\n            string t;\\n            t.push_back(s[idx]);\\n            make.push_back(t);\\n            help(idx + 1, k - 1, make, s);\\n            make.pop_back();\\n            return;\\n        }\\n\\n        for (int i = idx; i < min(idx + 3, (int)s.size()); i++)\\n        {\\n            string t = s.substr(idx, i - idx + 1);\\n            int val = stoi(t);\\n            if (val >= 0 and val <= 255)\\n            {\\n                make.push_back(t);\\n                help(i + 1, k - 1, make, s);\\n                make.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        if (s.size() > 12)\\n            return {};\\n\\n        vector<string> make;\\n        help(0, 3, make, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621595,
                "title": "c-simple-recursion-100-faster-than-all-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string &s , int indx , int len){\\n        if (indx + len > s.size()) return false;\\n        \\n        string _found = s.substr(indx , len);\\n        \\n        if (_found.size() > 1 && _found[0] == \\'0\\') return false;\\n        \\n        int num = stoi(_found);\\n        \\n        if (num > 255) return false;\\n        \\n        return true;\\n    }\\n    void recur(string &s , int indx , int used , vector<string> &res , string curr){\\n        if (indx == s.size() && used == 4){\\n            curr.pop_back();\\n            res.push_back(curr);\\n            return;\\n        }\\n        if (indx >= s.size() || used >= 4){\\n            return;\\n        }\\n        if (isValid(s , indx , 1)){\\n            recur(s , indx + 1 , used + 1 , res , curr + s.substr(indx,1) + \".\");\\n        }\\n        if (isValid(s , indx , 2)){\\n            recur(s , indx + 2 , used + 1 , res , curr + s.substr(indx,2) + \".\");\\n        }\\n        if (isValid(s , indx , 3)){\\n            recur(s , indx + 3 , used + 1 , res , curr + s.substr(indx,3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12) return {};\\n        vector<string> res;\\n        string curr = \"\";\\n        recur(s , 0 , 0 , res , curr);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string &s , int indx , int len){\\n        if (indx + len > s.size()) return false;\\n        \\n        string _found = s.substr(indx , len);\\n        \\n        if (_found.size() > 1 && _found[0] == \\'0\\') return false;\\n        \\n        int num = stoi(_found);\\n        \\n        if (num > 255) return false;\\n        \\n        return true;\\n    }\\n    void recur(string &s , int indx , int used , vector<string> &res , string curr){\\n        if (indx == s.size() && used == 4){\\n            curr.pop_back();\\n            res.push_back(curr);\\n            return;\\n        }\\n        if (indx >= s.size() || used >= 4){\\n            return;\\n        }\\n        if (isValid(s , indx , 1)){\\n            recur(s , indx + 1 , used + 1 , res , curr + s.substr(indx,1) + \".\");\\n        }\\n        if (isValid(s , indx , 2)){\\n            recur(s , indx + 2 , used + 1 , res , curr + s.substr(indx,2) + \".\");\\n        }\\n        if (isValid(s , indx , 3)){\\n            recur(s , indx + 3 , used + 1 , res , curr + s.substr(indx,3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12) return {};\\n        vector<string> res;\\n        string curr = \"\";\\n        recur(s , 0 , 0 , res , curr);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345810,
                "title": "easy-to-understand-javascript-backtracking",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if (s.length > 12 || s.length < 4) return [];\\n    const result = [];\\n    helper(s, [], result);\\n    return result;\\n};\\n\\nconst helper = (s, currSet, result) => {\\n    if (currSet.length === 4 && !s.length) {\\n        result.push(Array.from(currSet).join(\\'.\\'));\\n        return;\\n    }\\n    for (let i = 1; i < 4; i++) {\\n        if(s.length < i) continue; \\n        const str = s.slice(0,i);\\n        if ((str.length > 1 && str[0] === \\'0\\') || Number(str) > 255) continue;\\n        currSet.push(str);\\n        helper(s.slice(i), currSet, result);\\n        currSet.pop();\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if (s.length > 12 || s.length < 4) return [];\\n    const result = [];\\n    helper(s, [], result);\\n    return result;\\n};\\n\\nconst helper = (s, currSet, result) => {\\n    if (currSet.length === 4 && !s.length) {\\n        result.push(Array.from(currSet).join(\\'.\\'));\\n        return;\\n    }\\n    for (let i = 1; i < 4; i++) {\\n        if(s.length < i) continue; \\n        const str = s.slice(0,i);\\n        if ((str.length > 1 && str[0] === \\'0\\') || Number(str) > 255) continue;\\n        currSet.push(str);\\n        helper(s.slice(i), currSet, result);\\n        currSet.pop();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31060,
                "title": "c-backtracking-implementation",
                "content": "C# backtracking implementation\\n```\\n        public  IList<string> RestoreIpAddresses(string s)\\n        {\\n            List<string> res = new List<string>();\\n            List<string> ips = new List<string>();\\n\\n            Find(res, ips, s, 0);\\n            return res;\\n        }\\n\\n        private void Find(IList<string> res, IList<string> ips, string s, int start)\\n        {\\n            if (ips.Count == 4 && start == s.Length)\\n            {\\n                res.Add(string.Join(\".\", ips));\\n                return;\\n            }\\n\\n            if (s.Length - start > (4 - ips.Count) * 3) // pruning if right side contains more characters than needed\\n            {\\n                return;\\n            }\\n\\n            for (int i = start; i < start + 4 && i < s.Length; i++)\\n            {\\n                string ip = s.Substring(start, i - start + 1);\\n                if (int.Parse(ip) > 255 || int.Parse(ip).ToString() != ip) // prevent digit larger or starts with 0\\n                {\\n                    return;\\n                }\\n\\n                ips.Add(ip);\\n                Find(res, ips, s, i + 1);\\n                ips.RemoveAt(ips.Count - 1);\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public  IList<string> RestoreIpAddresses(string s)\\n        {\\n            List<string> res = new List<string>();\\n            List<string> ips = new List<string>();\\n\\n            Find(res, ips, s, 0);\\n            return res;\\n        }\\n\\n        private void Find(IList<string> res, IList<string> ips, string s, int start)\\n        {\\n            if (ips.Count == 4 && start == s.Length)\\n            {\\n                res.Add(string.Join(\".\", ips));\\n                return;\\n            }\\n\\n            if (s.Length - start > (4 - ips.Count) * 3) // pruning if right side contains more characters than needed\\n            {\\n                return;\\n            }\\n\\n            for (int i = start; i < start + 4 && i < s.Length; i++)\\n            {\\n                string ip = s.Substring(start, i - start + 1);\\n                if (int.Parse(ip) > 255 || int.Parse(ip).ToString() != ip) // prevent digit larger or starts with 0\\n                {\\n                    return;\\n                }\\n\\n                ips.Add(ip);\\n                Find(res, ips, s, i + 1);\\n                ips.RemoveAt(ips.Count - 1);\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079577,
                "title": "c-easy-code-comment-explanation-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:  \\n \\nbool subpart(string s, int i, int j){\\n         int len = j-i+1;\\n         if(len >3) return false;\\n         if(s[i] == \\'0\\'){\\n             if(len == 1) return true;\\n             return false;\\n                     }\\n         int num = stoi(s.substr(i,j-i+1));\\n         if(num>=0 && num<=255) return true;\\n         return false;\\n                          \\n   }\\n\\n  bool issafe(string s, int len, int i, int j, int k){\\n     if(subpart(s,0,i) && subpart(s,i+1,j) && subpart(s,j+1,k) && subpart(s,k+1,len-1))//checking each four part whether all these part is valid or not\\n        return true;\\n     else{\\n         return false;\\n         } \\n  }\\n\\n\\nvoid addstring(string s, int n, int i, int j, int k,vector<string> &res){//adding substring part along with . in our result string\\n    string temp;\\n    temp.append(s.substr(0,i+1));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(i+1,j-i));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(j+1,k-j));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(k+1,n-k-1));\\n    res.push_back(temp);\\n}\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        vector<string>res;\\n        int i,j,k;\\n        for(i=0;i<n-3;++i){//checking position of i,j,k in the string which can produce the required result\\n            for(j=i+1;j<n-2;++j){\\n                for(k=j+1;k<n-1;++k){\\n                    if(issafe(s,n,i,j,k))\\n                        addstring(s,n,i,j,k,res);\\n                }\\n            }\\n        }\\n          \\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```\\n**please upvote if you like my code**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n \\nbool subpart(string s, int i, int j){\\n         int len = j-i+1;\\n         if(len >3) return false;\\n         if(s[i] == \\'0\\'){\\n             if(len == 1) return true;\\n             return false;\\n                     }\\n         int num = stoi(s.substr(i,j-i+1));\\n         if(num>=0 && num<=255) return true;\\n         return false;\\n                          \\n   }\\n\\n  bool issafe(string s, int len, int i, int j, int k){\\n     if(subpart(s,0,i) && subpart(s,i+1,j) && subpart(s,j+1,k) && subpart(s,k+1,len-1))//checking each four part whether all these part is valid or not\\n        return true;\\n     else{\\n         return false;\\n         } \\n  }\\n\\n\\nvoid addstring(string s, int n, int i, int j, int k,vector<string> &res){//adding substring part along with . in our result string\\n    string temp;\\n    temp.append(s.substr(0,i+1));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(i+1,j-i));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(j+1,k-j));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(k+1,n-k-1));\\n    res.push_back(temp);\\n}\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        vector<string>res;\\n        int i,j,k;\\n        for(i=0;i<n-3;++i){//checking position of i,j,k in the string which can produce the required result\\n            for(j=i+1;j<n-2;++j){\\n                for(k=j+1;k<n-1;++k){\\n                    if(issafe(s,n,i,j,k))\\n                        addstring(s,n,i,j,k,res);\\n                }\\n            }\\n        }\\n          \\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745164,
                "title": "simple-backtracking-solution-runtime-100-faster-memory-97-lesser",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string str) {\\n        \\n        vector<string>v;\\n        string ans;\\n        helper(ans, str, 0, 0,v);\\n        return v;\\n        \\n    }\\n    \\n    void helper(string ans, string str, int idx, int k,vector<string>&v){\\n     \\n        if(k==4 ){\\n            if(idx>=str.length()){\\n                ans.pop_back();\\n                v.push_back(ans);\\n            }\\n            return ;\\n        }\\n\\t\\t\\n        string ip;\\n        for(int i=idx;i<str.length();i++){\\n            if(ip==\"0\"){\\n                return ;\\n            }\\n             ip=ip+str[i];\\n   \\n            if(stoi(ip)>=0 && stoi(ip) <=255){\\n                string x=ans;\\n                ans=ans+ip+\".\";\\n              \\n                helper(ans,str,i+1,k+1,v);\\n\\t\\t\\t\\t\\n                ans=x;\\n            }\\n            \\n            else if(stoi(ip)>255){\\n                return;\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string str) {\\n        \\n        vector<string>v;\\n        string ans;\\n        helper(ans, str, 0, 0,v);\\n        return v;\\n        \\n    }\\n    \\n    void helper(string ans, string str, int idx, int k,vector<string>&v){\\n     \\n        if(k==4 ){\\n            if(idx>=str.length()){\\n                ans.pop_back();\\n                v.push_back(ans);\\n            }\\n            return ;\\n        }\\n\\t\\t\\n        string ip;\\n        for(int i=idx;i<str.length();i++){\\n            if(ip==\"0\"){\\n                return ;\\n            }\\n             ip=ip+str[i];\\n   \\n            if(stoi(ip)>=0 && stoi(ip) <=255){\\n                string x=ans;\\n                ans=ans+ip+\".\";\\n              \\n                helper(ans,str,i+1,k+1,v);\\n\\t\\t\\t\\t\\n                ans=x;\\n            }\\n            \\n            else if(stoi(ip)>255){\\n                return;\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593871,
                "title": "javascript-backtracking-solution",
                "content": "Credits to https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\nThis is classical backtracking challenge.\\nI listed few more solutions for simmilar problems below:\\n* https://leetcode.com/problems/restore-ip-addresses\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    backtrack([], s, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, s, start) {\\n        if (start === s.length && tempArr.length === 4) {\\n            result.push(tempArr.join(\\'.\\'));\\n            return;\\n        } \\n\\n        if (tempArr.length === 4 || start > s.length) {\\n            return;\\n        }\\n\\n        for (let i = 1; i < 4; i++) {\\n            const sub = s.substring(start, start + i);\\n            if (sub.length > 1 && sub[0] === \\'0\\') {\\n                continue;\\n            }\\n            const int = parseInt(sub);\\n            if (int < 256 && int >= 0) {\\n                // 1:\\n                // tempArr.push(sub);\\n                // backtrack(tempArr, s, start + i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, sub], s, start + i);\\n            }\\n        }\\n    }\\n};\\n```\\n* https://leetcode.com/problems/combination-sum\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let result = [];\\n    backtrack([], target, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, remain, start){\\n        if(remain < 0){\\n            return;\\n        }\\n        else if (remain === 0){\\n            result.push(tempArr);\\n        }\\n        else {\\n            for(let i = start; i < candidates.length; i++){\\n                // 1:\\n                // tempArr.push(candidates[i]);\\n                // backtrack([...tempArr], remain - candidates[i], i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, candidates[i]], remain - candidates[i], i); // not i+1, because we can reuse same elements\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    backtrack([], s, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, s, start) {\\n        if (start === s.length && tempArr.length === 4) {\\n            result.push(tempArr.join(\\'.\\'));\\n            return;\\n        } \\n\\n        if (tempArr.length === 4 || start > s.length) {\\n            return;\\n        }\\n\\n        for (let i = 1; i < 4; i++) {\\n            const sub = s.substring(start, start + i);\\n            if (sub.length > 1 && sub[0] === \\'0\\') {\\n                continue;\\n            }\\n            const int = parseInt(sub);\\n            if (int < 256 && int >= 0) {\\n                // 1:\\n                // tempArr.push(sub);\\n                // backtrack(tempArr, s, start + i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, sub], s, start + i);\\n            }\\n        }\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let result = [];\\n    backtrack([], target, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, remain, start){\\n        if(remain < 0){\\n            return;\\n        }\\n        else if (remain === 0){\\n            result.push(tempArr);\\n        }\\n        else {\\n            for(let i = start; i < candidates.length; i++){\\n                // 1:\\n                // tempArr.push(candidates[i]);\\n                // backtrack([...tempArr], remain - candidates[i], i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, candidates[i]], remain - candidates[i], i); // not i+1, because we can reuse same elements\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168080,
                "title": "concise-java-backtracking-solution",
                "content": "```\\npublic List<String> restoreIpAddresses(String s)\\n    {\\n        List<String> result = new ArrayList<>();\\n        helper(result, s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void helper(List<String> result, String s, List<String> tempList)\\n    {\\n        if (tempList.size() == 4) {\\n            if (s.length() == 0) {\\n                result.add(String.join(\".\", tempList));\\n            }\\n            return;\\n        }\\n        for (int i = 1; i < 4; i++) {\\n            if (s.length() < i) {\\n                break;\\n            }\\n            String substring = s.substring(0, i);\\n            if ((substring.startsWith(\"0\") && substring.length() != 1) || Integer.parseInt(substring) > 255) {\\n                continue;\\n            }\\n            tempList.add(substring);\\n            helper(result, s.length() == i ? \"\" : s.substring(i, s.length()), tempList);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> restoreIpAddresses(String s)\\n    {\\n        List<String> result = new ArrayList<>();\\n        helper(result, s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void helper(List<String> result, String s, List<String> tempList)\\n    {\\n        if (tempList.size() == 4) {\\n            if (s.length() == 0) {\\n                result.add(String.join(\".\", tempList));\\n            }\\n            return;\\n        }\\n        for (int i = 1; i < 4; i++) {\\n            if (s.length() < i) {\\n                break;\\n            }\\n            String substring = s.substring(0, i);\\n            if ((substring.startsWith(\"0\") && substring.length() != 1) || Integer.parseInt(substring) > 255) {\\n                continue;\\n            }\\n            tempList.add(substring);\\n            helper(result, s.length() == i ? \"\" : s.substring(i, s.length()), tempList);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31066,
                "title": "simple-java-solution-beating-100-of-java-submissions",
                "content": "    /*Description of variables\\n    result - list of valid ip addr strings\\n    digits -char array representation of s\\n    len - length of s\\n    currIpAddr - char array that contains the IP addr we are building using backtracking\\n    remSegs - no. of segments remaining to be parsed. there 4 segments to an ip addr\\n    start - start index in the digits array for the current ip addr segment\\n    pos - next index to be populated in the currIpAddr array\\n\\n    */\\n\\n    public class Solution {\\n    \\n    private static final char DOT = '.';\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<String>();\\n        \\n        char[] digits = s.toCharArray();\\n        int len = s.length();\\n        char[] currIpAddr = new char[len+3];\\n        int pos = 0;\\n        generateIpAddresses(digits, 4, 0, len, currIpAddr, pos, result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateIpAddresses(char[] digits, int remSegs, int start, int len, \\n                                     char[] currIpAddr, int pos, List<String> result) {\\n            if(start == len && remSegs == 0) {\\n                result.add(String.valueOf(currIpAddr));\\n                return;\\n            }   \\n        \\n       //1. Checks for length of s too small\\n       //2. Maximum Length of the remaining segments. Since a sgemnt can be upto 3 digits\\n       // Length can not exceed 3x the remaining segments.\\n       //3. Minimum Length of s. Each segment has to be atleast 1 digit\\n        if((start > len) || ((len - start) > (3 * remSegs)) || ((len - start) < remSegs))\\n            return;\\n        \\n        if(remSegs < 4)\\n            currIpAddr[pos++] = DOT;\\n        \\n        int num = 0;\\n        \\n        for(int i = 0; i < Math.min(len-start, 3);i++) {\\n            num = (10*num) + (int)(digits[start+i] - '0');\\n            \\n            if(i > 0 && num < 10)// leading 0 cases i = 1, then the number should be > 10.\\n                return;\\n            \\n            ////\"010010\"\\n            //Valid: [\"0.10.0.10\",\"0.100.1.0\"]\\n            //Invalid: [\"0.1.0.010\",\"0.1.00.10\",\"0.1.001.0\",\"0.10.0.10\",\"0.10.01.0\",\"0.100.1.0\",\\n            //\"01.0.0.10\",\"01.0.01.0\",\"01.00.1.0\",\"010.0.1.0\"]\\n            \\n            if(num <= 255) {\\n                currIpAddr[pos+i] = digits[start+i];\\n                generateIpAddresses(digits, remSegs-1, start+i+1, len, currIpAddr, pos+i+1, result);\\n            }\\n        }\\n      }    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private static final char DOT = '.';\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<String>();\\n        \\n        char[] digits = s.toCharArray();\\n        int len = s.length();\\n        char[] currIpAddr = new char[len+3];\\n        int pos = 0;\\n        generateIpAddresses(digits, 4, 0, len, currIpAddr, pos, result);\\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 31146,
                "title": "my-short-c-recursive-version-4-ms-with-explanation",
                "content": "The idea is to have a recursive function buildIP to generate an IP string with \"num\" numbers using the substring [start, npos] of s. First it checks the substring has proper number of digits (>=num && <=3*num). Also it checks if the substring starts with '0' and has some extra digits. If so, it is not a valid case, so abandon it. Otherwise, if it is the last number, then check if it is no larger than 255 and if so, add to the resulting vector. If it is not the last number, recursively call itself to build the rest of the number sequence. For the current number, it can only be 1, 2, or 3 digits. Again, remember to check if it starts with '0' and is no larger than 255.\\n \\n\\n       class Solution {\\n        public:\\n            void  buildIP(vector<string> &res, string &s, int start, int num, string cur)\\n            {\\n                int numDigits = s.size()-start;\\n                if(numDigits<num || numDigits> 3*num) return;\\n                if(num==1)\\n                {\\n                    if((numDigits==1) || ( s[start]!='0' && atoi(s.substr(start).c_str())<=255))\\n                        res.push_back(cur + s.substr(start));\\n                }\\n                else\\n                {\\n                    buildIP(res, s, start+1, num-1, cur+ s.substr(start,1) + \".\");\\n                    if(s[start]!='0')\\n                    {\\n                        buildIP(res, s, start+2, num-1, cur+ s.substr(start,2) + \".\");\\n                        if(atoi(s.substr(start,3).c_str())<=255) buildIP(res, s, start+3, num-1, cur+ s.substr(start,3) + \".\");\\n                    }\\n                }\\n            }\\n        \\n            vector<string> restoreIpAddresses(string s) {\\n               int len = s.size();\\n               vector<string> res;\\n               buildIP(res, s, 0, 4, \"\");\\n               return res;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            void  buildIP(vector<string> &res, string &s, int start, int num, string cur)\\n            {\\n                int numDigits = s.size()-start;\\n                if(numDigits<num || numDigits> 3*num) return;\\n                if(num==1)\\n                {\\n                    if((numDigits==1) || ( s[start]!='0' && atoi(s.substr(start).c_str())<=255))\\n                        res.push_back(cur + s.substr(start));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3080381,
                "title": "c-backtracking-easy-approach-with-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntry out all possibilities. \\nfirst possibility: take single character\\nsecond and thirs possibility: take 2 and 3 characters respectively. for this case ensure that number doesn\\'t start with 0 and is less than 255\\ncount number of dots you add (i.e splits you have made). if this is equal to 3 (excluding last dot added ) and end of string is reached we have a valid ip\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can use dfs to explore all the combinations. \\nat each ith postion, we need to try out with next i +1, i+2 and i+3 substring. \\nif this substring is valid (for single digit 0-9 are valid cases and for 2 or 3 digits if them number doesn\\'t start with 0 and is less than 255) proceed for next 1 to 3 substr\\nwe stop only when \\n\\n# Complexity\\n- Time complexity:\\n- \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string sub) {\\n        if(sub.size()==1)\\n            return true;\\n        if(sub.size()>1 && sub[0]!=\\'0\\' && stoi(sub) <=255)\\n            return true;\\n        \\n        return false;\\n       \\n    }\\n    void dfs(vector<string>& ans, string s, string path, int i, int dots) {\\n// count number of dots, valid ip cannot have more than 3 dots.\\n// when end of string is reached and number of dot is 3 (after popping last one) then it is a valid ip\\n        if(dots==4) {\\n            if(i == s.length()) {\\n                path.pop_back();\\n                ans.push_back(path);\\n            }\\n            return; \\n        }\\n\\n        // iterate over next 1 to 3 substrings\\n        for(int k=1; k<=3; k++) {\\n            // if substr is >=0 and <=255 \\n            if(i+k<=s.length() && isValid(s.substr(i,k)))  {;\\n                dfs(ans, s, path+s.substr(i,k)+\\'.\\', i+k, dots+1);\\n            }\\n        }\\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans; \\n        string path; \\n        dfs(ans, s, path, 0, 0);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string sub) {\\n        if(sub.size()==1)\\n            return true;\\n        if(sub.size()>1 && sub[0]!=\\'0\\' && stoi(sub) <=255)\\n            return true;\\n        \\n        return false;\\n       \\n    }\\n    void dfs(vector<string>& ans, string s, string path, int i, int dots) {\\n// count number of dots, valid ip cannot have more than 3 dots.\\n// when end of string is reached and number of dot is 3 (after popping last one) then it is a valid ip\\n        if(dots==4) {\\n            if(i == s.length()) {\\n                path.pop_back();\\n                ans.push_back(path);\\n            }\\n            return; \\n        }\\n\\n        // iterate over next 1 to 3 substrings\\n        for(int k=1; k<=3; k++) {\\n            // if substr is >=0 and <=255 \\n            if(i+k<=s.length() && isValid(s.substr(i,k)))  {;\\n                dfs(ans, s, path+s.substr(i,k)+\\'.\\', i+k, dots+1);\\n            }\\n        }\\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans; \\n        string path; \\n        dfs(ans, s, path, 0, 0);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079523,
                "title": "java-backtracking-approach-better-than-leetcode-solution",
                "content": "```\\n// Approach #1: Backtracking Approach\\n\\n// Time complexity: O(m^n * n)\\n// Space complexity: O(m * n)\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        helper(s, 0, result, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void helper(String s, int index, List<String> result, List<String> list) {\\n        if (index >= s.length()) {\\n            if (list.size() == 4) \\n                result.add(String.join(\".\", list));\\n                \\n            return;\\n        }\\n        \\n        if (list.size() >= 4)\\n            return;   \\n        \\n        else {\\n            for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n                String str = s.substring(index, index + i);\\n                int ip = Integer.valueOf(str);\\n\\n                if (ip >= 0 && ip <= 255) {\\n                    list.add(str);\\n                    helper(s, index + i, result, list);\\n                    list.remove(list.size() - 1);\\n                }\\n                \\n                if (ip == 0)\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Approach #1: Backtracking Approach\\n\\n// Time complexity: O(m^n * n)\\n// Space complexity: O(m * n)\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        helper(s, 0, result, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void helper(String s, int index, List<String> result, List<String> list) {\\n        if (index >= s.length()) {\\n            if (list.size() == 4) \\n                result.add(String.join(\".\", list));\\n                \\n            return;\\n        }\\n        \\n        if (list.size() >= 4)\\n            return;   \\n        \\n        else {\\n            for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n                String str = s.substring(index, index + i);\\n                int ip = Integer.valueOf(str);\\n\\n                if (ip >= 0 && ip <= 255) {\\n                    list.add(str);\\n                    helper(s, index + i, result, list);\\n                    list.remove(list.size() - 1);\\n                }\\n                \\n                if (ip == 0)\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079507,
                "title": "java-easy-recursive",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new LinkedList<>();\\n        // Call the helper method with the input string, the ans list, a counter initialized to 0, and empty strings for the current decimal and current IP address\\n        helper(s,ans,0,\"\",\"\");\\n        return ans;\\n    }\\n\\n    public void helper(String s, List<String> ans, int dec, String r ,String a){\\n        if(r.length()>2 && Integer.parseInt(r)>255)return;\\n        // If the number of parts in the current IP address is greater than 4, return\\n        if(dec>4) return;\\n        // If the current decimal String has more than 1 digit and starts with 0, return\\n        if(r.length()>1 && Integer.parseInt(r.charAt(0)+\"\")==0)return;\\n        // Concatenate the current decimal to the current IP address\\n        a+=r;\\n        // If the number of decimals is 4 and the input string is empty, add the current IP address to the list of valid IP addresses\\n        if(dec==4 && s.length()==0)ans.add(a);\\n        // If the current decimal is not empty, add a period to the current IP address\\n        if(r.length()>0)a+=\".\";\\n        // Recursively call the helper method with various substrings of the input string, incremented counter and the current IP address\\n        if(s.length()>0) helper(s.substring(1,s.length()),ans,dec+1,s.substring(0,1),a);\\n        if(s.length()>1) helper(s.substring(2,s.length()),ans,dec+1,s.substring(0,2),a);\\n        if(s.length()>2) helper(s.substring(3,s.length()),ans,dec+1,s.substring(0,3),a);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new LinkedList<>();\\n        // Call the helper method with the input string, the ans list, a counter initialized to 0, and empty strings for the current decimal and current IP address\\n        helper(s,ans,0,\"\",\"\");\\n        return ans;\\n    }\\n\\n    public void helper(String s, List<String> ans, int dec, String r ,String a){\\n        if(r.length()>2 && Integer.parseInt(r)>255)return;\\n        // If the number of parts in the current IP address is greater than 4, return\\n        if(dec>4) return;\\n        // If the current decimal String has more than 1 digit and starts with 0, return\\n        if(r.length()>1 && Integer.parseInt(r.charAt(0)+\"\")==0)return;\\n        // Concatenate the current decimal to the current IP address\\n        a+=r;\\n        // If the number of decimals is 4 and the input string is empty, add the current IP address to the list of valid IP addresses\\n        if(dec==4 && s.length()==0)ans.add(a);\\n        // If the current decimal is not empty, add a period to the current IP address\\n        if(r.length()>0)a+=\".\";\\n        // Recursively call the helper method with various substrings of the input string, incremented counter and the current IP address\\n        if(s.length()>0) helper(s.substring(1,s.length()),ans,dec+1,s.substring(0,1),a);\\n        if(s.length()>1) helper(s.substring(2,s.length()),ans,dec+1,s.substring(0,2),a);\\n        if(s.length()>2) helper(s.substring(3,s.length()),ans,dec+1,s.substring(0,3),a);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079467,
                "title": "0ms-runtime-code-c-python-explained",
                "content": "# Solution:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n=s.size();\\n        //if the size of string is 1 that is always possible so return true\\n        if(n==1){\\n            return true;\\n        }\\n        //if we have length >3 or string starts with 0 return false\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        //we are converting string to integer to check if it is less than equalto 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        //return true at last\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        //we will store our ans in ans vector of strings\\n        vector<string>ans;\\n        //the max length of the ip address could be 12 as 255.255.255.255 so \\n        //all the string s with size greater than 12 can have ans\\n        if(n>12){\\n            return ans;\\n        }\\n        //now we have our string of length 12 or less than 12 so now \\n            //1. we have to spit the s in parts such that it satisfy the ip address conditions\\n            //2. if all 4 strings satisfy the condition we will push into ans vector\\n        \\n        for(int i=1;i<=3;i++){//for the length before first \\'.\\'\\n            for(int j=1;j<=3;j++){//for the length between first and second \\'.\\'\\n                for(int k=1;k<=3;k++){//for the length between second and third \\'.\\'\\n                    //checking condition if the last segment is of length 3 or less\\n                    if(i+j+k<n&&i+j+k+3>=n){\\n                        //dividing the s int substrings \\n                        string a=s.substr(0,i);\\n                        string b=s.substr(i,j);\\n                        string c=s.substr(j+i,k);\\n                        string d=s.substr(i+j+k);\\n                        //if all the substring satisfy the check function condition \\n                        //then we will push into ans vector \\n                        if(check(a)&&check(b)&&check(c)&&check(d)){\\n                            ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //return the ans vector\\n        return ans;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n*Please upvote if helped*",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n=s.size();\\n        //if the size of string is 1 that is always possible so return true\\n        if(n==1){\\n            return true;\\n        }\\n        //if we have length >3 or string starts with 0 return false\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        //we are converting string to integer to check if it is less than equalto 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        //return true at last\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        //we will store our ans in ans vector of strings\\n        vector<string>ans;\\n        //the max length of the ip address could be 12 as 255.255.255.255 so \\n        //all the string s with size greater than 12 can have ans\\n        if(n>12){\\n            return ans;\\n        }\\n        //now we have our string of length 12 or less than 12 so now \\n            //1. we have to spit the s in parts such that it satisfy the ip address conditions\\n            //2. if all 4 strings satisfy the condition we will push into ans vector\\n        \\n        for(int i=1;i<=3;i++){//for the length before first \\'.\\'\\n            for(int j=1;j<=3;j++){//for the length between first and second \\'.\\'\\n                for(int k=1;k<=3;k++){//for the length between second and third \\'.\\'\\n                    //checking condition if the last segment is of length 3 or less\\n                    if(i+j+k<n&&i+j+k+3>=n){\\n                        //dividing the s int substrings \\n                        string a=s.substr(0,i);\\n                        string b=s.substr(i,j);\\n                        string c=s.substr(j+i,k);\\n                        string d=s.substr(i+j+k);\\n                        //if all the substring satisfy the check function condition \\n                        //then we will push into ans vector \\n                        if(check(a)&&check(b)&&check(c)&&check(d)){\\n                            ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //return the ans vector\\n        return ans;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078796,
                "title": "commented-java-solution-using-backtracking",
                "content": "In order to produce all solutions we must iterate over all collections of characters of size 1-3 and see if they form a valid IP integer. If it does, we add it to our \"temp\" list and continue recursing through the input until temp has 4 strings and is using all the digits from input. To proceed producing the other results that don\\'t contain the first collection of characters we chose, we remove the item we just added to temp and continue iterating over the size of collection of characters we may include in one integer of the IP address.\\n\\n```\\nclass Solution {\\n    // Stores a list of all possible IPs\\n    LinkedList<String> result = new LinkedList<String>();\\n    \\n    // Stores the current IP being evaluated.\\n    // Each item in this list is a number to be joined by \".\" to form an IP address.\\n    LinkedList<String> temp = new LinkedList<String>();\\n    \\n    private void backtrack(String input, int start, int length) {\\n        int n = input.length();\\n        \\n        // If the collective string length of temp is equal to the length of input & temp has 4 different strings, then add temp to result\\n        if(length == input.length() && temp.size() == 4) {\\n            result.add(String.join(\".\", temp));\\n        }\\n        // If temp size is greater than 4 its not a valid IP\\n        else if(temp.size() >= 4) {\\n            return;\\n        }\\n        \\n        // Iteratively add the next 3 characters to temp\\n        for(int i = 1; i <= 3; i++) {\\n            if(start + i > n) break;\\n            \\n            // Parse the next 1-3 characters\\n            String nextChars = input.substring(start, start+i);\\n            \\n            // Validate the value\\n            if(!isValid(nextChars)) continue;\\n            \\n            // Add the next few chars to temp\\n            temp.add(nextChars);\\n            \\n            // Recurse after choosing a group of characters to include\\n            backtrack(input, start+i, length+nextChars.length());\\n            \\n            // Remove the few chars from temp that we just added to obtain other possible solutions\\n            temp.removeLast();\\n        }\\n    }\\n    \\n    // Returns true if s is a valid integer to form an IP address\\n    private boolean isValid(String s) {\\n        if(s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        \\n        return Integer.parseInt(s) <= 255;\\n    }\\n    \\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        int n = s.length();\\n        if(n == 0 || n > 12) return result;\\n        backtrack(s, 0, 0);\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nLet me know if you have questions",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // Stores a list of all possible IPs\\n    LinkedList<String> result = new LinkedList<String>();\\n    \\n    // Stores the current IP being evaluated.\\n    // Each item in this list is a number to be joined by \".\" to form an IP address.\\n    LinkedList<String> temp = new LinkedList<String>();\\n    \\n    private void backtrack(String input, int start, int length) {\\n        int n = input.length();\\n        \\n        // If the collective string length of temp is equal to the length of input & temp has 4 different strings, then add temp to result\\n        if(length == input.length() && temp.size() == 4) {\\n            result.add(String.join(\".\", temp));\\n        }\\n        // If temp size is greater than 4 its not a valid IP\\n        else if(temp.size() >= 4) {\\n            return;\\n        }\\n        \\n        // Iteratively add the next 3 characters to temp\\n        for(int i = 1; i <= 3; i++) {\\n            if(start + i > n) break;\\n            \\n            // Parse the next 1-3 characters\\n            String nextChars = input.substring(start, start+i);\\n            \\n            // Validate the value\\n            if(!isValid(nextChars)) continue;\\n            \\n            // Add the next few chars to temp\\n            temp.add(nextChars);\\n            \\n            // Recurse after choosing a group of characters to include\\n            backtrack(input, start+i, length+nextChars.length());\\n            \\n            // Remove the few chars from temp that we just added to obtain other possible solutions\\n            temp.removeLast();\\n        }\\n    }\\n    \\n    // Returns true if s is a valid integer to form an IP address\\n    private boolean isValid(String s) {\\n        if(s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        \\n        return Integer.parseInt(s) <= 255;\\n    }\\n    \\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        int n = s.length();\\n        if(n == 0 || n > 12) return result;\\n        backtrack(s, 0, 0);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597069,
                "title": "my-java-backtrack-solution",
                "content": "\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\tList<String> result = new ArrayList<>();\\n\\t\\tif(s == null || s.length() == 0) return result;\\n\\t\\tbacktrack(result, s, \"\", 0, 0);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic void backtrack(List<String> res, String s, String curr, int start, int level) {\\n\\t\\tif(level >= 4) {\\n\\t\\t\\tif(start == s.length()) {\\n\\t\\t\\t\\tres.add(curr);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i = start; i < Math.min(start+3, s.length()); i++) {\\n\\t\\t\\tif(start != i && s.charAt(start) == \\'0\\') continue;\\n\\t\\t\\tint num = Integer.parseInt(s.substring(start, i+1));\\n\\t\\t\\tif(num > 255) break;\\n\\t\\t\\tif(curr == \"\") {\\n\\t\\t\\t\\tbacktrack(res, s, \"\"+ num, i+1, level+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbacktrack(res, s, curr + \".\"+ num, i+1, level+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\tList<String> result = new ArrayList<>();\\n\\t\\tif(s == null || s.length() == 0) return result;\\n\\t\\tbacktrack(result, s, \"\", 0, 0);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic void backtrack(List<String> res, String s, String curr, int start, int level) {\\n\\t\\tif(level >= 4) {\\n\\t\\t\\tif(start == s.length()) {\\n\\t\\t\\t\\tres.add(curr);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i = start; i < Math.min(start+3, s.length()); i++) {\\n\\t\\t\\tif(start != i && s.charAt(start) == \\'0\\') continue;\\n\\t\\t\\tint num = Integer.parseInt(s.substring(start, i+1));\\n\\t\\t\\tif(num > 255) break;\\n\\t\\t\\tif(curr == \"\") {\\n\\t\\t\\t\\tbacktrack(res, s, \"\"+ num, i+1, level+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbacktrack(res, s, curr + \".\"+ num, i+1, level+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 31028,
                "title": "simple-python-backtracking-solution",
                "content": "If the length of current is 4 and start point equals to the length of s, then add it to the result.\\nThen check the next 3 number from index start, and make sure that it does not exceed the total length of s. If the first digit is 0 and i>start, like 09 or 01, then skip those conditions.\\n\\n```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def bt(start, current):\\n            if len(current) == 4:\\n                if start == len(s):\\n                    result.append('.'.join(current))\\n                return\\n            for i in xrange(start+1, min(start+4, len(s)+1)):\\n                if i-1>start and s[start] == '0':\\n                    continue\\n                a = s[start:i]\\n                if 0 <= int(a) <= 255:\\n                    current.append(a)\\n                    bt(i, current)\\n                    current.pop()\\n        \\n        result = []\\n        bt(0, [])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def bt(start, current):\\n            if len(current) == 4:\\n                if start == len(s):\\n                    result.append('.'.join(current))\\n                return\\n            for i in xrange(start+1, min(start+4, len(s)+1)):\\n                if i-1>start and s[start] == '0':\\n                    continue\\n                a = s[start:i]\\n                if 0 <= int(a) <= 255:\\n                    current.append(a)\\n                    bt(i, current)\\n                    current.pop()\\n        \\n        result = []\\n        bt(0, [])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31145,
                "title": "my-cpp-backtracking-solution",
                "content": "    class Solution {\\n    public:\\n    \\tvector<string> restoreIpAddresses(string s) {\\n    \\t\\tvector<string> res;\\n    \\t\\tstring ans;\\n    \\t\\tdfs(res, s,ans, 0,0);\\n    \\t\\treturn res;\\n    \\t}\\n    \\tvoid dfs(vector<string>& res, string s, string ans,int idx, int depth)\\n    \\t{\\n    \\t\\tif (depth > 4) return;\\n    \\t\\tif ((depth == 4) && (idx == s.size()))\\n    \\t\\t{\\n    \\t\\t    ans.erase(ans.end()-1);\\n    \\t\\t\\tres.push_back(ans);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = 1; i < 4; ++i)\\n    \\t\\t{\\n    \\t    \\tif (s[idx] == '0' && i>1) return;\\n    \\t\\t\\tif (idx + i > s.size()) return;\\n    \\t\\t\\tauto tmp = s.substr(idx, i);\\n    \\t\\t\\tif (stoi(tmp) < 256)\\n    \\t\\t\\t{\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\tdfs(res, s, ans+ tmp+\".\", idx + i, depth + 1);\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t{\\n    \\t\\t\\t\\treturn;\\n    \\t\\t\\t}\\n    \\t\\t}\\t\\t\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<string> restoreIpAddresses(string s) {\\n    \\t\\tvector<string> res;\\n    \\t\\tstring ans;\\n    \\t\\tdfs(res, s,ans, 0,0);\\n    \\t\\treturn res;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3083003,
                "title": "simplest-rejava-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe \"solve\" method uses a recursive approach to build all possible IP addresses by adding characters from the input string to the \"str\" variable either as it is or with a dot in front of it. When the index reaches the end of the input string or **the number of dots used reaches 4**, the current IP address is checked for validity using the \"correct\" method. If it is valid, it is added to the list of valid IP addresses.\\n\\nThe \"correct\" method checks if the given IP address is a valid IP address by checking **if the length of the IP address is not 0, if the last character is not a dot, if the length of each segment between dots is between 1 and 3 and if each segment is between 0 and 255 and also if there are 3 dots in the IP address.**\\n\\nIn summary, this code uses a recursive approach to generate all possible IP addresses from a given string and then checks each one for validity using the \"correct\" method.\\n\\n# Complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the above code is **O(n)** where **n is the length of the input string**. The main source of space usage is the *recursion stack* used by the \"solve\" method.\\n\\nThe maximum depth of the recursion will be equal to the length of the input string because at each level of the recursion, we are either adding a character or a dot to the IP address string. Since we are not storing any other data during the recursion, the space complexity is directly proportional to the length of the input string.\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        String str=\"\";\\n        List<String> ans=new ArrayList<>();\\n\\n        solve(ans,s,0,str,0,s.length());\\n        \\n        return ans;\\n    }\\n\\n    public void solve(List<String> a,String s,int index,String str, int nod,int n){\\n\\n        if(index==n || nod==4)\\n        {\\n            if(correct(str)==true )     a.add(str);\\n            \\n            return;\\n        }\\n\\n        //dont put a dot\\n        solve(a,s,index+1 , str+=s.charAt(index), nod,n);\\n\\n        //put the dot\\n        solve(a,s,index+1,str+=\\'.\\',nod+1,n);\\n        \\n        return;\\n    }\\n\\n    public boolean correct (String str)\\n    {\\n        \\n        if (str.length() == 0)                      return false;\\n        if(str.charAt(str.length() - 1) == \\'.\\' )    return false;\\n        \\n        String temp = \"\";\\n        int count = 0;\\n        for(int i = 0;i < str.length(); i++)\\n        {\\n           \\n            if(str.charAt(i) == \\'.\\' )\\n            {\\n                count++;\\n                if(temp.length()>3 || temp.length()==0)                     return false;\\n                if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n                if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n                temp=\"\";\\n            }\\n            else\\n            {\\n                temp+=str.charAt(i);\\n            }\\n            \\n        //last string will be left as in the string 125.34.54.789 temp will store 132 but as after 789 no \\'.\\' will be there so it wont check the conditions on \"789\"   \\n\\n        }\\n        if(temp.length()>3 || temp.length()==0)                     return false;\\n        if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n        if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n        if(count!=3)                                                return false;\\n       \\n        return true;\\n    }\\n}\\n\\n```\\n\\n***Please consider upvoting if you found this information helpful.***",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Recursion",
                    "String Matching"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        String str=\"\";\\n        List<String> ans=new ArrayList<>();\\n\\n        solve(ans,s,0,str,0,s.length());\\n        \\n        return ans;\\n    }\\n\\n    public void solve(List<String> a,String s,int index,String str, int nod,int n){\\n\\n        if(index==n || nod==4)\\n        {\\n            if(correct(str)==true )     a.add(str);\\n            \\n            return;\\n        }\\n\\n        //dont put a dot\\n        solve(a,s,index+1 , str+=s.charAt(index), nod,n);\\n\\n        //put the dot\\n        solve(a,s,index+1,str+=\\'.\\',nod+1,n);\\n        \\n        return;\\n    }\\n\\n    public boolean correct (String str)\\n    {\\n        \\n        if (str.length() == 0)                      return false;\\n        if(str.charAt(str.length() - 1) == \\'.\\' )    return false;\\n        \\n        String temp = \"\";\\n        int count = 0;\\n        for(int i = 0;i < str.length(); i++)\\n        {\\n           \\n            if(str.charAt(i) == \\'.\\' )\\n            {\\n                count++;\\n                if(temp.length()>3 || temp.length()==0)                     return false;\\n                if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n                if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n                temp=\"\";\\n            }\\n            else\\n            {\\n                temp+=str.charAt(i);\\n            }\\n            \\n        //last string will be left as in the string 125.34.54.789 temp will store 132 but as after 789 no \\'.\\' will be there so it wont check the conditions on \"789\"   \\n\\n        }\\n        if(temp.length()>3 || temp.length()==0)                     return false;\\n        if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n        if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n        if(count!=3)                                                return false;\\n       \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082691,
                "title": "python-simple-backtracking",
                "content": "**Solution**:\\n    We can solve this problem with backtracking. At each iteration, we will pick the next term for a proposed ip address as long as the term is valid. We know that we have a valid ip if we used all digits and we picked 4 terms and thus, we can append the proposed ip into the result. Then, we backtrack.  \\n\\n**Complexity**:\\n    Time: O(3**n) \\n    Space: O(3\\\\**n)\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n\\n        # Find the number of digits\\n        n = len(s)\\n\\n        # If we have too little or too many digits to form a valid ip, end the search\\n        if not (4 <= n <= 12):\\n            return []\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Recursively forming valid ips\\n        def backtrack(i, ip):\\n\\n            # If we used all digits or we have 4 terms, we end the search\\n            if i == n or len(ip) == 4:\\n\\n                # If both conditions hold true, we have found a valid ip\\n                if i == n and len(ip) == 4:\\n                    res.append(\".\".join(ip))\\n\\n                return\\n\\n            # Else, we will pick the next term\\n            for j in range(i + 1, min(i + 4, n + 1)):\\n\\n                # If the next term is greater than 255, end the search\\n                if int(s[i:j]) > 255:\\n                    return\\n\\n                # Else, add the term into the ip\\n                ip.append(s[i:j])\\n\\n                # Go to the next term\\n                backtrack(j, ip)\\n\\n                # Once we return, pop the picked term from the ip\\n                ip.pop()\\n\\n                # If there is leading 0, we will end the search after picked the first possible term\\n                if s[i] == \"0\":\\n                    return\\n\\n        backtrack(0, [])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n\\n        # Find the number of digits\\n        n = len(s)\\n\\n        # If we have too little or too many digits to form a valid ip, end the search\\n        if not (4 <= n <= 12):\\n            return []\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Recursively forming valid ips\\n        def backtrack(i, ip):\\n\\n            # If we used all digits or we have 4 terms, we end the search\\n            if i == n or len(ip) == 4:\\n\\n                # If both conditions hold true, we have found a valid ip\\n                if i == n and len(ip) == 4:\\n                    res.append(\".\".join(ip))\\n\\n                return\\n\\n            # Else, we will pick the next term\\n            for j in range(i + 1, min(i + 4, n + 1)):\\n\\n                # If the next term is greater than 255, end the search\\n                if int(s[i:j]) > 255:\\n                    return\\n\\n                # Else, add the term into the ip\\n                ip.append(s[i:j])\\n\\n                # Go to the next term\\n                backtrack(j, ip)\\n\\n                # Once we return, pop the picked term from the ip\\n                ip.pop()\\n\\n                # If there is leading 0, we will end the search after picked the first possible term\\n                if s[i] == \"0\":\\n                    return\\n\\n        backtrack(0, [])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080249,
                "title": "recursion-optimal-w-explanation-c-nmcodex",
                "content": "Please upvote if you like it. Upvote costs nothing \\uD83D\\uDE0E\\n\\n> Many coders have been shared the best solutions. Hope this will also help you a lot.\\n# Intuition\\nDefinitely we need to check each and every possible string.\\n> String length is 20, then we should not worry about time limit. \\n> Even if length is greater, time will be still constant *(better explained in `Complexity Section`)*\\n\\nWe have three conditions:\\n```\\n1. Number of dots should be exactly 3.\\n2. When we take 2 or 3 letters make sure first letter shouldn\\'t be zero.\\n3. We can only take any number from 0-255.  \\n```\\n\\n# Approach\\n1. Take initial string `temp` as empty and  a variable for `dot` count.\\n2. Take all possibilities.\\n```\\nPossibility 1: Take 1 number.\\nPossibility 2: Take 2 number but also check that first letter shouldn\\'t be \\'0\\'.\\nPossibility 3: Take 3 number but also check that first letter shouldn\\'t be \\'0\\'and number shouldn\\'t exceed 255.\\n```\\n3. When complete string traversed and `dots are 3` then insert it in `unordered_set`.\\n> In code, insert element when dots are 4 because we delete last dot as well before inserting.\\n4. `If dots exceeds 4 return`.\\n5. Copy all elements from `set to vector` and then `return vector`\\n\\n# Complexity\\n- Time complexity:\\n> The IP address ranges from 0.0.0.0 to 255.255.255.255\\nSo, there can be maximum 2^32 address \\nTime complexity will be `constant` ---- **O(2^32)**  ----> **`O(1)`**.\\n- Space complexity:\\n> **`O(N) + Auxiliary space`**\\nUsing a unordered_set and recursion stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> set;\\n    void sol(int i, string s, string temp,int dot)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(dot==4)\\n            {\\n                temp.pop_back();\\n                set.insert(temp);\\n            }\\n            return;\\n        }\\n        if(dot>=4) return;\\n        sol(i+1,s,temp+s.substr(i,1)+\\'.\\',dot+1);\\n        if(s[i] != \\'0\\') sol(i+2,s,temp+s.substr(i,2)+\\'.\\',dot+1);\\n        if(s[i] !=\\'0\\' && stoi(s.substr(i,3))<=255)\\n            sol(i+3,s,temp+s.substr(i,3)+\\'.\\',dot+1);\\n\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        sol(0,s,\"\",0);\\n        vector<string> ans(set.begin(),set.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Recursion"
                ],
                "code": "```\\n1. Number of dots should be exactly 3.\\n2. When we take 2 or 3 letters make sure first letter shouldn\\'t be zero.\\n3. We can only take any number from 0-255.  \\n```\n```\\nPossibility 1: Take 1 number.\\nPossibility 2: Take 2 number but also check that first letter shouldn\\'t be \\'0\\'.\\nPossibility 3: Take 3 number but also check that first letter shouldn\\'t be \\'0\\'and number shouldn\\'t exceed 255.\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> set;\\n    void sol(int i, string s, string temp,int dot)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(dot==4)\\n            {\\n                temp.pop_back();\\n                set.insert(temp);\\n            }\\n            return;\\n        }\\n        if(dot>=4) return;\\n        sol(i+1,s,temp+s.substr(i,1)+\\'.\\',dot+1);\\n        if(s[i] != \\'0\\') sol(i+2,s,temp+s.substr(i,2)+\\'.\\',dot+1);\\n        if(s[i] !=\\'0\\' && stoi(s.substr(i,3))<=255)\\n            sol(i+3,s,temp+s.substr(i,3)+\\'.\\',dot+1);\\n\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        sol(0,s,\"\",0);\\n        vector<string> ans(set.begin(),set.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079985,
                "title": "java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    HashSet<String> set=new HashSet<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        ArrayList<String> arr=new ArrayList<>();\\n        dfs(0,s,arr);\\n        return new ArrayList<String>(set);\\n    }\\n    void dfs(int i,String s,ArrayList<String> arr)\\n    {\\n        if(arr.size()==4 && i==s.length())\\n        {\\n        set.add(String.join(\".\",arr));\\n        return;\\n        }\\n        for(int j=i+1;j<=Math.min(i+3,s.length());j++)\\n        {\\n            String str=s.substring(i,j);\\n            if(Integer.parseInt(str)<=255 && (str.equals(\"0\") || str.charAt(0)!=\\'0\\'))\\n            {\\n                arr.add(str);\\n                dfs(j,s,arr);\\n                arr.remove(arr.size()-1);\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<String> set=new HashSet<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        ArrayList<String> arr=new ArrayList<>();\\n        dfs(0,s,arr);\\n        return new ArrayList<String>(set);\\n    }\\n    void dfs(int i,String s,ArrayList<String> arr)\\n    {\\n        if(arr.size()==4 && i==s.length())\\n        {\\n        set.add(String.join(\".\",arr));\\n        return;\\n        }\\n        for(int j=i+1;j<=Math.min(i+3,s.length());j++)\\n        {\\n            String str=s.substring(i,j);\\n            if(Integer.parseInt(str)<=255 && (str.equals(\"0\") || str.charAt(0)!=\\'0\\'))\\n            {\\n                arr.add(str);\\n                dfs(j,s,arr);\\n                arr.remove(arr.size()-1);\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079544,
                "title": "python3-31-ms-faster-than-95-31-of-python3-clean-and-easy-to-understand",
                "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self,s,path,result):\\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self,s,path,result):\\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3079244,
                "title": "c-backtracking-solution-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- base case if we place all dots then just check curr substr is valid or not, and push back to ans \\n- for every idx to n check if that curr substring (idx, i-idx+1) is valid or not .\\n    - if yes then push curr char and \\'.\\' and call furthur\\n    - backtrack also\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isSafe(string s){\\n    int n = s.size();\\n    if(n>=4||n<=0)return false;\\n    if(n>1&&s[0]==\\'0\\')return false;\\n    if(n&&stoi(s)>255)return false;\\n    return true;\\n}\\nvoid solve(string s,vector<string>& ans,string st,int idx,int dot){\\n    if(dot==3){\\n        if(isSafe(s.substr(idx))){\\n            ans.push_back(st+s.substr(idx));\\n        }\\n        return;\\n    }\\n    for(int i=idx;i<s.size();i++){\\n        if(isSafe(s.substr(idx,i-idx+1))){\\n            st.push_back(s[i]);\\n            st.push_back(\\'.\\');\\n            solve(s,ans,st,i+1,dot+1);\\n            st.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        string st = \"\";\\n        if(n<4)return ans;\\n        solve(s,ans,st,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isSafe(string s){\\n    int n = s.size();\\n    if(n>=4||n<=0)return false;\\n    if(n>1&&s[0]==\\'0\\')return false;\\n    if(n&&stoi(s)>255)return false;\\n    return true;\\n}\\nvoid solve(string s,vector<string>& ans,string st,int idx,int dot){\\n    if(dot==3){\\n        if(isSafe(s.substr(idx))){\\n            ans.push_back(st+s.substr(idx));\\n        }\\n        return;\\n    }\\n    for(int i=idx;i<s.size();i++){\\n        if(isSafe(s.substr(idx,i-idx+1))){\\n            st.push_back(s[i]);\\n            st.push_back(\\'.\\');\\n            solve(s,ans,st,i+1,dot+1);\\n            st.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        string st = \"\";\\n        if(n<4)return ans;\\n        solve(s,ans,st,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079131,
                "title": "95-javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/6vln3Liz3_g\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            res.push(temp.join(\\'.\\'))\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            if(arr.length < i) break;\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```\\nMap approach for avoiding duplicate\\n```\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n    let map ={}\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            let joined = temp.join(\\'.\\')\\n            if(map[joined] || temp[3] == \"\") return;\\n            map[joined] =1\\n            res.push(joined)\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            res.push(temp.join(\\'.\\'))\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            if(arr.length < i) break;\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```\n```\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n    let map ={}\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            let joined = temp.join(\\'.\\')\\n            if(map[joined] || temp[3] == \"\") return;\\n            map[joined] =1\\n            res.push(joined)\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152282,
                "title": "java-solution-brute-force-o-1-time-well-explained",
                "content": "I totally agree that the problem description should be more clear. If you are confused by the problem, feel free to take a look of the post. I also attach the code below and the explanation to the time complexity. Hope it is helpful.\\n\\nHere are several rules of a valid IP address:\\n\\n  (1) **Three dots**. A Valid IP address contains **ONLY 3 dots**, i.e. \"192.168.0.1\".\\n  (2) **No zero leading** in each section, i.e. \"192.168.00.1\" or \"192.168.0.01\" These two IP address are both invalid.\\n  (3) The number in each section should be in the range **[0, 255]**. No greater than 255 && no smaller than 0.\\n  (4) A valid IP address should contains at least four digits, i.e. \"0.0.0.0\". It\\'s a valid IP address.\\n\\nBy my solution, we can achieve **O(1) time** and O(1) space. The reason we can achieve constant time complexity is because that there are only 256 possible numbers in a section (0 - 255). 256 is 2^8, and we have four sections in an IP address. Therefore, (2^8) * (2^8) * (2^8) * (2^8) = 2^32. Hence, we can achieve O(2^32) time complexity which is O(1) time.  \\n\\n\\n```\\nclass Solution \\n{\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        // O(1) time | O(1) space\\n        if(s == null) return new ArrayList<>();\\n        \\n        ArrayList<String> res = new ArrayList<>();\\n        int n = s.length();\\n        \\n        for(int i = 1; i < Math.min(n, 4); i++)\\n        {\\n            String[] currentIPAddressParts = new String[] {\"\", \"\", \"\", \"\"};\\n            currentIPAddressParts[0] = s.substring(0, i);\\n            \\n            if(!isValidPart(currentIPAddressParts[0]))\\n                continue;\\n            \\n            for(int j = i+1; j < i + Math.min(n-i, 4); j++)\\n            {\\n                currentIPAddressParts[1] = s.substring(i, j);\\n                \\n                if(!isValidPart(currentIPAddressParts[1]))\\n                    continue;\\n                \\n                for(int k = j+1; k < j + Math.min(n-j, 4); k++)\\n                {\\n                    currentIPAddressParts[2] = s.substring(j, k);\\n                    currentIPAddressParts[3] = s.substring(k);\\n                    \\n                    if(isValidPart(currentIPAddressParts[2]) && isValidPart(currentIPAddressParts[3]))\\n                        res.add(join(currentIPAddressParts));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isValidPart(String str)\\n    {\\n        int n = str.length();\\n        \\n        if(n > 3)   return false;\\n        \\n        return (str.charAt(0) != \\'0\\') ? (Integer.valueOf(str) <= 255) : (n == 1);\\n    }\\n    \\n    public String join(String[] strs)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            sb.append(strs[i]);\\n            \\n            if(i != strs.length-1)\\n                sb.append(\".\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        // O(1) time | O(1) space\\n        if(s == null) return new ArrayList<>();\\n        \\n        ArrayList<String> res = new ArrayList<>();\\n        int n = s.length();\\n        \\n        for(int i = 1; i < Math.min(n, 4); i++)\\n        {\\n            String[] currentIPAddressParts = new String[] {\"\", \"\", \"\", \"\"};\\n            currentIPAddressParts[0] = s.substring(0, i);\\n            \\n            if(!isValidPart(currentIPAddressParts[0]))\\n                continue;\\n            \\n            for(int j = i+1; j < i + Math.min(n-i, 4); j++)\\n            {\\n                currentIPAddressParts[1] = s.substring(i, j);\\n                \\n                if(!isValidPart(currentIPAddressParts[1]))\\n                    continue;\\n                \\n                for(int k = j+1; k < j + Math.min(n-j, 4); k++)\\n                {\\n                    currentIPAddressParts[2] = s.substring(j, k);\\n                    currentIPAddressParts[3] = s.substring(k);\\n                    \\n                    if(isValidPart(currentIPAddressParts[2]) && isValidPart(currentIPAddressParts[3]))\\n                        res.add(join(currentIPAddressParts));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isValidPart(String str)\\n    {\\n        int n = str.length();\\n        \\n        if(n > 3)   return false;\\n        \\n        return (str.charAt(0) != \\'0\\') ? (Integer.valueOf(str) <= 255) : (n == 1);\\n    }\\n    \\n    public String join(String[] strs)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            sb.append(strs[i]);\\n            \\n            if(i != strs.length-1)\\n                sb.append(\".\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420292,
                "title": "java-dfs-simple",
                "content": "```\\nclass Solution {\\n    \\n    List<String> res = new ArrayList<>(); \\n    \\n    public void helper(String s, int start, List<String> curr) { \\n        if(curr.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(curr.get(0) + \".\" +curr.get(1) + \".\" + curr.get(2) + \".\" + curr.get(3)); \\n            }\\n            return; \\n        } \\n        for(int i=start; i<s.length(); i++) {\\n            if(i != start && s.charAt(start) == \\'0\\') break; \\n            if(Integer.valueOf(s.substring(start,i+1)) > 255) break; \\n            curr.add(s.substring(start,i+1)); \\n            helper(s, i+1, curr);\\n            curr.remove(curr.size()-1); \\n        }        \\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> curr = new ArrayList<>(); \\n        StringBuilder sb = new StringBuilder(); \\n        helper(s, 0, curr); \\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<String> res = new ArrayList<>(); \\n    \\n    public void helper(String s, int start, List<String> curr) { \\n        if(curr.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(curr.get(0) + \".\" +curr.get(1) + \".\" + curr.get(2) + \".\" + curr.get(3)); \\n            }\\n            return; \\n        } \\n        for(int i=start; i<s.length(); i++) {\\n            if(i != start && s.charAt(start) == \\'0\\') break; \\n            if(Integer.valueOf(s.substring(start,i+1)) > 255) break; \\n            curr.add(s.substring(start,i+1)); \\n            helper(s, i+1, curr);\\n            curr.remove(curr.size()-1); \\n        }        \\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> curr = new ArrayList<>(); \\n        StringBuilder sb = new StringBuilder(); \\n        helper(s, 0, curr); \\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363591,
                "title": "java-backtracking-solution",
                "content": "```\\nprivate final static int MAX_VALUE = 255;\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if (s.length() == 0) {\\n            return res;\\n        }\\n        \\n        List<String> path = new ArrayList<>();\\n        int len = s.length();\\n        dfs(0, 4, len, s, path, res);\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(int start, int count, int len, String s, List<String> path, List<String> res) {\\n        \\n        int numOfDigitsLeft = len - start;\\n        \\n        if (3*count <  numOfDigitsLeft || numOfDigitsLeft < count) { \\n            return;\\n        }\\n        \\n        if (count == 0) {\\n            res.add(String.join(\".\", path));\\n            return;\\n        }\\n        \\n        for (int size = 1; size <= 3; size++) {\\n            if (start + size - 1 >= len ) {\\n                continue;\\n            }\\n            \\n            String num = s.substring(start, start + size);\\n            \\n            if (Integer.valueOf(num) <= MAX_VALUE\\n                && (num.length() == 1 || num.charAt(0) != \\'0\\')) {\\n                \\n                path.add(num);\\n                dfs(start + size, count - 1, len, s, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate final static int MAX_VALUE = 255;\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if (s.length() == 0) {\\n            return res;\\n        }\\n        \\n        List<String> path = new ArrayList<>();\\n        int len = s.length();\\n        dfs(0, 4, len, s, path, res);\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(int start, int count, int len, String s, List<String> path, List<String> res) {\\n        \\n        int numOfDigitsLeft = len - start;\\n        \\n        if (3*count <  numOfDigitsLeft || numOfDigitsLeft < count) { \\n            return;\\n        }\\n        \\n        if (count == 0) {\\n            res.add(String.join(\".\", path));\\n            return;\\n        }\\n        \\n        for (int size = 1; size <= 3; size++) {\\n            if (start + size - 1 >= len ) {\\n                continue;\\n            }\\n            \\n            String num = s.substring(start, start + size);\\n            \\n            if (Integer.valueOf(num) <= MAX_VALUE\\n                && (num.length() == 1 || num.charAt(0) != \\'0\\')) {\\n                \\n                path.add(num);\\n                dfs(start + size, count - 1, len, s, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319009,
                "title": "python-short-and-simple-backtracking-python-solution",
                "content": "I use \"level\" to refer to different portions of the IP address\\n```\\n#255.255.255.255\\n# ^  ^   ^   ^\\n#lv1 lv2 lv3 lv4\\n ```\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def backtrack(comb, s, level):\\n            if (level == 0) and (s == \"\"):\\n                res.append(comb[:-1])\\n            elif (level != 0):\\n                for i in range(1,min(3+1, len(s)+1)):\\n                    if (i > 1) and (s[0] == \\'0\\'): # cannot start with \\'0\\', i.e. \\'1.001.0.1\\'\\n                        continue\\n                    if ( 0<= int(s[0:i]) <=255 ) :\\n                        backtrack(comb+s[0:i]+\\'.\\', s[i:], level-1)\\n        \\n        backtrack(\"\", s, 4)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n#255.255.255.255\\n# ^  ^   ^   ^\\n#lv1 lv2 lv3 lv4\\n ```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def backtrack(comb, s, level):\\n            if (level == 0) and (s == \"\"):\\n                res.append(comb[:-1])\\n            elif (level != 0):\\n                for i in range(1,min(3+1, len(s)+1)):\\n                    if (i > 1) and (s[0] == \\'0\\'): # cannot start with \\'0\\', i.e. \\'1.001.0.1\\'\\n                        continue\\n                    if ( 0<= int(s[0:i]) <=255 ) :\\n                        backtrack(comb+s[0:i]+\\'.\\', s[i:], level-1)\\n        \\n        backtrack(\"\", s, 4)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31087,
                "title": "short-easy-understand-4ms-backtracking-c-solution",
                "content": "    class Solution {\\n    private:\\n        void helper(string s,vector<string>& sol,vector<string>& res,int length){\\n            if(length==0 && sol.size() == 4){\\n                string tmp = \"\";\\n                tmp += (sol[0]+\".\");\\n                tmp += (sol[1]+\".\");\\n                tmp += (sol[2]+\".\");\\n                tmp += (sol[3]);\\n                res.push_back(tmp);\\n                return;\\n            }\\n            else if(sol.size()==4 && length!=0) return;\\n            else if(sol.size()!=4 && length==0) return;\\n            \\n            for(int i=1;i<=3 && i<=length;i++){\\n                string ts = s.substr(s.length()-length,i);\\n                int num = stoi(ts);\\n                if(num>=0 && num<=255 && (i==1 || ts[0]!='0')){\\n                    sol.push_back(ts);\\n                    helper(s,sol,res,length-i);\\n                    sol.pop_back();\\n                }\\n            }\\n        }\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> res;\\n            vector<string> sol;\\n            helper(s,sol,res,s.length());\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    private:\\n        void helper(string s,vector<string>& sol,vector<string>& res,int length){\\n            if(length==0 && sol.size() == 4){\\n                string tmp = \"\";\\n                tmp += (sol[0]+\".\");\\n                tmp += (sol[1]+\".\");\\n                tmp += (sol[2]+\".\");\\n                tmp += (sol[3]);\\n                res.push_back(tmp);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31095,
                "title": "backtracking-solution-in-java-easy-to-understand",
                "content": "    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> result = new ArrayList<String>();\\n            if(s == null || s.length() == 0 || s.length() > 12){\\n                return result;\\n            }\\n            StringBuilder builder = new StringBuilder();\\n            helper(result, s, builder, 0, 0);\\n            return result;\\n        }\\n        \\n        private void helper(List<String> result, String s, StringBuilder builder, int start, int count){\\n            if(start == s.length() && count == 3){\\n                result.add(builder.toString());\\n                return;\\n            }\\n            for(int i = start + 1; i <= s.length(); i++){\\n                String tmp = s.substring(start, i);\\n                if(tmp.length() > 3 || tmp.length() > 1 && tmp.charAt(0) == '0' || Integer.parseInt(tmp) > 255){\\n                    return;\\n                }\\n                StringBuilder newBuilder = new StringBuilder(builder);\\n                if(newBuilder.length() != 0){\\n                    newBuilder.append(\".\");\\n                }\\n                newBuilder.append(tmp);\\n                helper(result, s, newBuilder, i, newBuilder.length() == tmp.length() ? count : count + 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> result = new ArrayList<String>();\\n            if(s == null || s.length() == 0 || s.length() > 12){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3696351,
                "title": "superb-logic-with-backtracking-constraints-concept",
                "content": "# Awesome Logic with backtracking\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:# condition for valid IP address\\n                ans.append(temp[:-1])# to remove last dot\\n                return\\n            if k==4 or len(s)==0:# due to overflow IP address or not valid IP address\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s): # overflow condition or due to loop for 3 times irrespective of input size\\n                    break\\n                if int(s[:i+1])>255: # not valid Ip address condition\\n                    continue\\n                if i!=0 and s[0]==\"0\": to avoid \"0.011.34.012\" IP address\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  # main logic with restore ip address\\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:# condition for valid IP address\\n                ans.append(temp[:-1])# to remove last dot\\n                return\\n            if k==4 or len(s)==0:# due to overflow IP address or not valid IP address\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s): # overflow condition or due to loop for 3 times irrespective of input size\\n                    break\\n                if int(s[:i+1])>255: # not valid Ip address condition\\n                    continue\\n                if i!=0 and s[0]==\"0\": to avoid \"0.011.34.012\" IP address\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  # main logic with restore ip address\\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091216,
                "title": "c-string-partition-code-with-comments-simple-explanation",
                "content": "![93. Restore IP Addresses.png](https://assets.leetcode.com/users/images/f916078e-6ab9-48f4-bf63-a2f662defee9_1674494214.1065774.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string &s)\\n    {\\n        int n=s.size();\\n\\n        //base case\\n        if(n==1){\\n            return true;\\n        }\\n        //if length >3 or string starts with 0\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        // converting string to integer to check if it is less than equal to 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    // void solve(string &s, vector<string>&ans)\\n    // {\\n       \\n    // }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n\\n        // base case\\n        if(s.size()>12)\\n        return ans;\\n\\n        // divide string into 4 parts, each having length=3\\n        // iterate over each part & form corresponding substrings\\n\\n        for(int i=1;i<=3;i++) // 1st part\\n        {\\n            for(int j=1;j<=3;j++) // 2nd part\\n            {\\n                for(int k=1;k<=3;k++) // 3rd part\\n                {\\n                    if((i+j+k<s.size()) and (i+j+k+3>=s.size())) // check if last part is of length 3\\n                    {\\n                        string a=s.substr(0,i);\\n                        string b=s.substr((i+0),j);\\n                        string c=s.substr((j+i),k);\\n                        string d=s.substr(i+j+k);\\n\\n                        // if each substring is valid, then push into array\\n                        if(isValid(a) and isValid(b) and isValid(c) and isValid(d))\\n                        ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Pls upvote my solution, it helps me stay motivated to bring up more solutions like this :)**",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string &s)\\n    {\\n        int n=s.size();\\n\\n        //base case\\n        if(n==1){\\n            return true;\\n        }\\n        //if length >3 or string starts with 0\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        // converting string to integer to check if it is less than equal to 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    // void solve(string &s, vector<string>&ans)\\n    // {\\n       \\n    // }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n\\n        // base case\\n        if(s.size()>12)\\n        return ans;\\n\\n        // divide string into 4 parts, each having length=3\\n        // iterate over each part & form corresponding substrings\\n\\n        for(int i=1;i<=3;i++) // 1st part\\n        {\\n            for(int j=1;j<=3;j++) // 2nd part\\n            {\\n                for(int k=1;k<=3;k++) // 3rd part\\n                {\\n                    if((i+j+k<s.size()) and (i+j+k+3>=s.size())) // check if last part is of length 3\\n                    {\\n                        string a=s.substr(0,i);\\n                        string b=s.substr((i+0),j);\\n                        string c=s.substr((j+i),k);\\n                        string d=s.substr(i+j+k);\\n\\n                        // if each substring is valid, then push into array\\n                        if(isValid(a) and isValid(b) and isValid(c) and isValid(d))\\n                        ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085871,
                "title": "java-no-backtracking",
                "content": "# Please Upvote :D\\n---\\n![image.png](https://assets.leetcode.com/users/images/c68b647b-ba51-4581-9a86-8ca233011c3c_1674387621.138504.png)\\n\\n---\\n*We will be forming each part of the IP-address iteratively.*\\n``` java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s.length() > 12) {      // max length can be 3 x 4 = 12\\n            return ans;\\n        }\\n\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder(); // to store one address\\n        // length of each part can be min 1 and at max 3 \\n        // so we will one by one try with each length for first 3 parts\\n        for (int l1 = 1; l1 <= 3; l1++) {\\n            for (int l2 = 1; l2 <= 3; l2++) {\\n                for (int l3 = 1; l3 <= 3; l3++) {\\n                    // get the length for the 4th part\\n                    int l4 = len - l1 - l2 - l3;\\n                    // again, the 4th part should be of size 1-3\\n                    if (l4 > 0 && l4 <= 3) {    // if it is\\n                        // get the numbers from the partitioned strings\\n                        int p1 = getNum(s, 0, l1);\\n                        int p2 = getNum(s, l1, l1 + l2);\\n                        int p3 = getNum(s, l1 + l2, l1 + l2 + l3);\\n                        int p4 = getNum(s, l1 + l2 + l3, l1 + l2 + l3 + l4);\\n                        // if each of them is lesser than 255\\n                        // we can make it a candidate ip address\\n                        if (p1 <= 255 && p2 <= 255 && p3 <= 255 && p4 <= 255) {\\n                            sb.append(p1).append(\".\").append(p2).append(\".\")\\n                            .append(p3).append(\".\").append(p4);\\n                            \\n                            // IMPORTANT:\\n                            // We need to avoid leading zeros\\n                            // if in the string if we have \"025\", \\n                            // parseInt would convert it to 25\\n                            // so we will get a difference in the lengths\\n                            // otherwise length of our address should always be 3 + string\\'s length\\n                            // the +3 is because of the 3 \".\" (dots) that we have added\\n                            if (sb.length() == len + 3) {   // if that\\'s so\\n                                ans.add(sb.toString());     // add the IP to the ans list\\n                            }\\n                            // empty the stringbuilder coz we will create a new IP now\\n                            sb = new StringBuilder();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    // this method returns the numeric value of the part of the string\\n    // we chose to make the method separate to avoid typing the same long thing again and again\\n    private int getNum(String s, int i, int j) {\\n        return Integer.parseInt(s.substring(i, j));\\n    }\\n}\\n```\\n---\\n#### Time complexity: \\n- We are using `3` loops which would run `3 x 3 x 3` times.\\n- Inside that we are performing `substring()` operation `4` times on a string which can be at max `12` in length.\\n- So time complexity becomes $$O(3 * 3 * 3 * 4 * 12) => O(432)$$ in worst case which is constant in nature.\\n\\nSo we can say our time complexity is $$O(1)$$.\\n\\n---\\n#### Space complexity:\\nWe are using a stringbuilder who will store a string of size `12 + 3 = 15` at max which is again constant in nature.\\nSo we can say our space coplexity is $$O(1)$$.\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s.length() > 12) {      // max length can be 3 x 4 = 12\\n            return ans;\\n        }\\n\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder(); // to store one address\\n        // length of each part can be min 1 and at max 3 \\n        // so we will one by one try with each length for first 3 parts\\n        for (int l1 = 1; l1 <= 3; l1++) {\\n            for (int l2 = 1; l2 <= 3; l2++) {\\n                for (int l3 = 1; l3 <= 3; l3++) {\\n                    // get the length for the 4th part\\n                    int l4 = len - l1 - l2 - l3;\\n                    // again, the 4th part should be of size 1-3\\n                    if (l4 > 0 && l4 <= 3) {    // if it is\\n                        // get the numbers from the partitioned strings\\n                        int p1 = getNum(s, 0, l1);\\n                        int p2 = getNum(s, l1, l1 + l2);\\n                        int p3 = getNum(s, l1 + l2, l1 + l2 + l3);\\n                        int p4 = getNum(s, l1 + l2 + l3, l1 + l2 + l3 + l4);\\n                        // if each of them is lesser than 255\\n                        // we can make it a candidate ip address\\n                        if (p1 <= 255 && p2 <= 255 && p3 <= 255 && p4 <= 255) {\\n                            sb.append(p1).append(\".\").append(p2).append(\".\")\\n                            .append(p3).append(\".\").append(p4);\\n                            \\n                            // IMPORTANT:\\n                            // We need to avoid leading zeros\\n                            // if in the string if we have \"025\", \\n                            // parseInt would convert it to 25\\n                            // so we will get a difference in the lengths\\n                            // otherwise length of our address should always be 3 + string\\'s length\\n                            // the +3 is because of the 3 \".\" (dots) that we have added\\n                            if (sb.length() == len + 3) {   // if that\\'s so\\n                                ans.add(sb.toString());     // add the IP to the ans list\\n                            }\\n                            // empty the stringbuilder coz we will create a new IP now\\n                            sb = new StringBuilder();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    // this method returns the numeric value of the part of the string\\n    // we chose to make the method separate to avoid typing the same long thing again and again\\n    private int getNum(String s, int i, int j) {\\n        return Integer.parseInt(s.substring(i, j));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083045,
                "title": "c-solution-iterative-approach-simple-explanation",
                "content": "# Intuition \\nIterative Approach \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the length of the given string is greater than 12 that means there is no valid ip as maximum number is 255 and it has only 3 charater and we have to divide the string and insert dot 4 times.\\n2. Now divide the string into substrings and verify the condition on each substring\\n - length is less then or equal to 3 \\n - no leading zeros and\\n - it\\'s value in integer is less than or equal to 255\\n3. At the end insert the string into ans vector. \\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote if it helps you.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string str){\\n        if (str.size() == 1)\\n        return true;\\n        if (str.size() > 3|| str[0] == \\'0\\'|| stoi(str) > 255)\\n        return false;\\n        else\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        // check for length of the string as 255 has length 3 and only 4 such number are allowed\\n        if (s.size() > 12)\\n        return {};\\n        vector<string> v;\\n        for (int i = 1; i <= 3 ; i++)\\n        for (int j = 1 ; j <= 3 ; j++)\\n        for (int k = 1 ; k <= 3 ; k++)\\n        {\\n            if (i+j+k <s.size() && i+j+k+3 >= s.size()){\\n                string a =s.substr(0,i);\\n                string b =s.substr(i,j);\\n                string c =s.substr(i+j,k);\\n                string d =s.substr(i+j+k);\\n                if (check(a) && check(b) && check(c) && check(d))\\n                v.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string str){\\n        if (str.size() == 1)\\n        return true;\\n        if (str.size() > 3|| str[0] == \\'0\\'|| stoi(str) > 255)\\n        return false;\\n        else\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        // check for length of the string as 255 has length 3 and only 4 such number are allowed\\n        if (s.size() > 12)\\n        return {};\\n        vector<string> v;\\n        for (int i = 1; i <= 3 ; i++)\\n        for (int j = 1 ; j <= 3 ; j++)\\n        for (int k = 1 ; k <= 3 ; k++)\\n        {\\n            if (i+j+k <s.size() && i+j+k+3 >= s.size()){\\n                string a =s.substr(0,i);\\n                string b =s.substr(i,j);\\n                string c =s.substr(i+j,k);\\n                string d =s.substr(i+j+k);\\n                if (check(a) && check(b) && check(c) && check(d))\\n                v.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082015,
                "title": "golang-simple-solution",
                "content": "# Intuition\\nDivide given string into valid 4 substring and check if each substring is valid\\n\\n# Approach\\n1. Divide given string into valid 4 substrings\\n2. Check value of each substring is valid (0-255)\\n3. Join substring and check if there was not leading zeros. After joining lengths should match\\n\\n# Complexity\\n- Time complexity:\\nWe run 3 for loops for 3 values (1,2,3)\\nO(3*3) -> O(1). We are not dependent on length of input string\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc restoreIpAddresses(s string) []string { \\n    res := []string{}\\n\\n    for a := 1; a <= 3; a++ {\\n        for b := 1; b <= 3; b++ {\\n            for c := 1; c <= 3; c++ {\\n\\n                d := len(s) - (a + b + c)\\n                if d > 0 && d <= 3 && a+b+c+d == len(s) {\\n                    A, _ := strconv.Atoi(s[:a])\\n                    B, _ := strconv.Atoi(s[a:a+b])\\n                    C, _ := strconv.Atoi(s[a+b:a+b+c])\\n                    D, _ := strconv.Atoi(s[a+b+c:])\\n\\n                    if A <= 255 && B <= 255 && C <= 255 && D <= 255 {\\n                        addr := fmt.Sprintf(\"%d.%d.%d.%d\", A, B, C, D)\\n                        \\n                        // To check if there was any leading zeros, \\n                        // If leading zeros was there, then len will be reduced\\n                        // +3, for 3 \\'.\\'\\n                        if len(addr) == len(s) + 3 {\\n                            res = append(res, addr)\\n                        }\\n                    } \\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc restoreIpAddresses(s string) []string { \\n    res := []string{}\\n\\n    for a := 1; a <= 3; a++ {\\n        for b := 1; b <= 3; b++ {\\n            for c := 1; c <= 3; c++ {\\n\\n                d := len(s) - (a + b + c)\\n                if d > 0 && d <= 3 && a+b+c+d == len(s) {\\n                    A, _ := strconv.Atoi(s[:a])\\n                    B, _ := strconv.Atoi(s[a:a+b])\\n                    C, _ := strconv.Atoi(s[a+b:a+b+c])\\n                    D, _ := strconv.Atoi(s[a+b+c:])\\n\\n                    if A <= 255 && B <= 255 && C <= 255 && D <= 255 {\\n                        addr := fmt.Sprintf(\"%d.%d.%d.%d\", A, B, C, D)\\n                        \\n                        // To check if there was any leading zeros, \\n                        // If leading zeros was there, then len will be reduced\\n                        // +3, for 3 \\'.\\'\\n                        if len(addr) == len(s) + 3 {\\n                            res = append(res, addr)\\n                        }\\n                    } \\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3081001,
                "title": "recursive-iterative-c",
                "content": "# Recursive\\n```\\nclass Solution {\\n    void dfs(int i, int cnt, string &s, string t, vector<string> & ans) {\\n        if(i == s.size() && cnt == 4) {\\n            t.pop_back();\\n            ans.push_back(t);\\n            return;\\n        }\\n        if(cnt > 4) return;\\n        for(int j=i; j<min(i + 3, (int)s.size()); j++) {\\n            if(stoi(s.substr(i, j - i + 1)) <= 255 && (i == j || s[i] != \\'0\\')) {\\n                dfs(j + 1, cnt + 1, s, t + s.substr(i, j - i + 1) + \".\", ans);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        if(s.size() > 12) return ans;\\n\\n        dfs(0, 0, s, \"\", ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Iterative\\n```\\nclass Solution {\\n    bool good(string s) {\\n        string str;\\n        for(char c : s) {\\n            if(c == \\'.\\') {\\n                if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n                str = \"\";\\n            }\\n            else str += c;\\n        }\\n        if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n        return true;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    string ip = s.substr(0, i + 1) + \".\" + s.substr(i + 1, j - i) + \".\" + \\n                                s.substr(j + 1, k - j) + \".\" + s.substr(k + 1);\\n                    if(good(ip)) ans.push_back(ip);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int cnt, string &s, string t, vector<string> & ans) {\\n        if(i == s.size() && cnt == 4) {\\n            t.pop_back();\\n            ans.push_back(t);\\n            return;\\n        }\\n        if(cnt > 4) return;\\n        for(int j=i; j<min(i + 3, (int)s.size()); j++) {\\n            if(stoi(s.substr(i, j - i + 1)) <= 255 && (i == j || s[i] != \\'0\\')) {\\n                dfs(j + 1, cnt + 1, s, t + s.substr(i, j - i + 1) + \".\", ans);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        if(s.size() > 12) return ans;\\n\\n        dfs(0, 0, s, \"\", ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool good(string s) {\\n        string str;\\n        for(char c : s) {\\n            if(c == \\'.\\') {\\n                if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n                str = \"\";\\n            }\\n            else str += c;\\n        }\\n        if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n        return true;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    string ip = s.substr(0, i + 1) + \".\" + s.substr(i + 1, j - i) + \".\" + \\n                                s.substr(j + 1, k - j) + \".\" + s.substr(k + 1);\\n                    if(good(ip)) ans.push_back(ip);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080823,
                "title": "c-ez-recursive-solution-explained",
                "content": "**Time taken for execution : 4ms**\\nI am generating all the possible subsets by placing the 3 dots in every position of the given string and validating them before pushing them into the answer vector.\\nThe maximum valid IP address can be generated with a string of length 12 ***[ 255.255.255.255 ]*** .  So we can easily return an empty vector for strings of size > 12.\\nThe maximum possible set generated fore the string will be I guess some 1000, so generating all the set is feasible.\\n\\n**If someone can help me determine the time complexity of the following code it will be highly appreciated. Thank You.**\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string>ans;\\n    void calc(string &s,string w,int i,int dots,int prev){\\n        if(i==s.length()||dots==3){           \\n            ans.insert(w+s.substr(i));//If the number of dots is 3 and the rest of the string is not explored\\n            return;\\n        }\\n        for(int j=i;j<s.length();j++){            \\n            w+=s[j];           \\n            if(j-prev>=0&&j<s.length()-1){\\n                w+=\\'.\\';//Placing DOT\\n                calc(s,w,j+1,dots+1,j);                 \\n                w.pop_back();//Backtracking\\n            }\\n            else\\n                calc(s,w,j+1,dots,prev); \\n        }\\n    }\\nbool isValid(string s){\\n    int n=s.length();\\n    int i=0;\\n    int dots=0;\\n    while(i<n){\\n        if(s[i]==\\'.\\'){\\n            dots++;\\n            i++;\\n            continue;\\n        }\\n        string num=\"\";\\n        while(i<n&&s[i]!=\\'.\\'){\\n            num+=s[i];\\n            i++;\\n        }\\n        if((num[0]==\\'0\\'&&num.length()>1)||stoull(num)>255)//Avoid leading zeroes and if xcurrent number is greater than 255\\n            return false;\\n    }\\n    if(dots!=3)//Required number of dots not placed\\n        return false;\\n    return true;\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n        if(s.length()>12)//Max IP address possible is 255.255.255.255 ( Remove the dots so max length is 12)\\n            return {};\\n        calc(s,\"\",0,0,0);\\n        // for(auto i:ans)\\n        //     cout<<i<<\" \";\\n        vector<string>a;\\n        for(auto i:ans){\\n            if(isValid(i))\\n                a.push_back(i);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n    Keep count of the number of dots. Max dots should be 3    \\n    Put dot at position \\'i\\' [ 0 <= i < n-1 -> \\'n\\' is the length of the string]\\n    If dot is placed pop the last character of the string while backtracking.\\n    Generate all possible combination of IP addresses possible by placing the dots in various position\\n    Use a set for avoiding duplicates\\n    Validate each IP address according to the given conditions and push them into the answer vector.\\n    \\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>ans;\\n    void calc(string &s,string w,int i,int dots,int prev){\\n        if(i==s.length()||dots==3){           \\n            ans.insert(w+s.substr(i));//If the number of dots is 3 and the rest of the string is not explored\\n            return;\\n        }\\n        for(int j=i;j<s.length();j++){            \\n            w+=s[j];           \\n            if(j-prev>=0&&j<s.length()-1){\\n                w+=\\'.\\';//Placing DOT\\n                calc(s,w,j+1,dots+1,j);                 \\n                w.pop_back();//Backtracking\\n            }\\n            else\\n                calc(s,w,j+1,dots,prev); \\n        }\\n    }\\nbool isValid(string s){\\n    int n=s.length();\\n    int i=0;\\n    int dots=0;\\n    while(i<n){\\n        if(s[i]==\\'.\\'){\\n            dots++;\\n            i++;\\n            continue;\\n        }\\n        string num=\"\";\\n        while(i<n&&s[i]!=\\'.\\'){\\n            num+=s[i];\\n            i++;\\n        }\\n        if((num[0]==\\'0\\'&&num.length()>1)||stoull(num)>255)//Avoid leading zeroes and if xcurrent number is greater than 255\\n            return false;\\n    }\\n    if(dots!=3)//Required number of dots not placed\\n        return false;\\n    return true;\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n        if(s.length()>12)//Max IP address possible is 255.255.255.255 ( Remove the dots so max length is 12)\\n            return {};\\n        calc(s,\"\",0,0,0);\\n        // for(auto i:ans)\\n        //     cout<<i<<\" \";\\n        vector<string>a;\\n        for(auto i:ans){\\n            if(isValid(i))\\n                a.push_back(i);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n    Keep count of the number of dots. Max dots should be 3    \\n    Put dot at position \\'i\\' [ 0 <= i < n-1 -> \\'n\\' is the length of the string]\\n    If dot is placed pop the last character of the string while backtracking.\\n    Generate all possible combination of IP addresses possible by placing the dots in various position\\n    Use a set for avoiding duplicates\\n    Validate each IP address according to the given conditions and push them into the answer vector.\\n    \\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3080447,
                "title": "simple-recursion-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if(s.length()>12) return res;\\n        recursion(0,s,\"\",0);\\n        return res;\\n    }\\n    private void recursion(int idx, String str, String temp,int part){\\n        if(idx == str.length() || part == 4){\\n            if(idx == str.length() && part == 4) res.add(temp.substring(0, temp.length()-1));\\n            return;\\n        }\\n        recursion(idx+1,str,temp+str.charAt(idx)+\".\",part+1);\\n        if(idx+2<=str.length() && isValid(str.substring(idx, idx+2))) recursion(idx+2, str, temp+str.substring(idx, idx+2)+\".\", part+1);\\n        if(idx+3<=str.length() && isValid(str.substring(idx, idx+3))) recursion(idx+3, str, temp+str.substring(idx, idx+3)+\".\", part+1);\\n    }\\n    private boolean isValid(String str){\\n        if(str.charAt(0) == \\'0\\') return false;\\n        return Integer.parseInt(str)<=255;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if(s.length()>12) return res;\\n        recursion(0,s,\"\",0);\\n        return res;\\n    }\\n    private void recursion(int idx, String str, String temp,int part){\\n        if(idx == str.length() || part == 4){\\n            if(idx == str.length() && part == 4) res.add(temp.substring(0, temp.length()-1));\\n            return;\\n        }\\n        recursion(idx+1,str,temp+str.charAt(idx)+\".\",part+1);\\n        if(idx+2<=str.length() && isValid(str.substring(idx, idx+2))) recursion(idx+2, str, temp+str.substring(idx, idx+2)+\".\", part+1);\\n        if(idx+3<=str.length() && isValid(str.substring(idx, idx+3))) recursion(idx+3, str, temp+str.substring(idx, idx+3)+\".\", part+1);\\n    }\\n    private boolean isValid(String str){\\n        if(str.charAt(0) == \\'0\\') return false;\\n        return Integer.parseInt(str)<=255;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080432,
                "title": "python-backtracking",
                "content": "\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # isvalid function for checking ip number is valid or not\\n        def isvalid(str):\\n            if (str[0]==\"0\" and len(str)>1) or int(str)>255:\\n                return False\\n            return True\\n\\n        res=[]\\n        def back(i,ip,r):\\n            if i==len(s) and r==0:\\n                res.append(ip[:-1])\\n                return\\n            if i+1<=len(s) and isvalid(s[i:i+1]):\\n                back(i+1,ip+s[i:i+1]+\".\",r-1)\\n            if i+2<=len(s) and isvalid(s[i:i+2]):\\n                back(i+2,ip+s[i:i+2]+\".\",r-1)\\n            if i+3<=len(s) and isvalid(s[i:i+3]):\\n                back(i+3,ip+s[i:i+3]+\".\",r-1)\\n            return res\\n        return back(0,\"\",4)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # isvalid function for checking ip number is valid or not\\n        def isvalid(str):\\n            if (str[0]==\"0\" and len(str)>1) or int(str)>255:\\n                return False\\n            return True\\n\\n        res=[]\\n        def back(i,ip,r):\\n            if i==len(s) and r==0:\\n                res.append(ip[:-1])\\n                return\\n            if i+1<=len(s) and isvalid(s[i:i+1]):\\n                back(i+1,ip+s[i:i+1]+\".\",r-1)\\n            if i+2<=len(s) and isvalid(s[i:i+2]):\\n                back(i+2,ip+s[i:i+2]+\".\",r-1)\\n            if i+3<=len(s) and isvalid(s[i:i+3]):\\n                back(i+3,ip+s[i:i+3]+\".\",r-1)\\n            return res\\n        return back(0,\"\",4)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080261,
                "title": "easy-c-backtracking-approach-fast-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void helper(string s, int j, int count){\\n        //Hit the Bottom | Base Case\\n        if(count == 3)\\n        {\\n            if((s[0]!= \\'0\\' or 0==j) and j+1<=3 and stoi(s.substr(0, j+1))<=255)\\n                ans.push_back(s);\\n            return;\\n        }\\n        if(j==0)\\n            return;\\n\\n        for(int i=j; (i>0 and (i>= j-3)); i--){\\n            if((s[i]!= \\'0\\' or i==j) and stoi(s.substr(i, j-i+1))<=255){\\n                //Insert the \\'.\\' and call recursively\\n                s.insert(i, 1,\\'.\\');\\n                helper(s, i-1, count+1);\\n                //Backtrack\\n                s.erase(i, 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        helper(s, s.length()-1, 0);\\n        return ans;\\n    }\\n};\\n```\\n![fays.png](https://assets.leetcode.com/users/images/7890de43-b728-4040-b0ec-b8add9211e5c_1674286460.3253233.png)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void helper(string s, int j, int count){\\n        //Hit the Bottom | Base Case\\n        if(count == 3)\\n        {\\n            if((s[0]!= \\'0\\' or 0==j) and j+1<=3 and stoi(s.substr(0, j+1))<=255)\\n                ans.push_back(s);\\n            return;\\n        }\\n        if(j==0)\\n            return;\\n\\n        for(int i=j; (i>0 and (i>= j-3)); i--){\\n            if((s[i]!= \\'0\\' or i==j) and stoi(s.substr(i, j-i+1))<=255){\\n                //Insert the \\'.\\' and call recursively\\n                s.insert(i, 1,\\'.\\');\\n                helper(s, i-1, count+1);\\n                //Backtrack\\n                s.erase(i, 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        helper(s, s.length()-1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080237,
                "title": "easy-c-solution",
                "content": "Here is the simple c++ sol.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n        int n=s.size();\\n        string s1,s2,s3,s4,res;\\n        s1=s2=s3=s4=res=\"\";\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    s1=s.substr(0,i);\\n                    s2=s.substr(i,j-i);\\n                    s3=s.substr(j,k-j);\\n                    s4=s.substr(k);\\n                    if(s4.size()==0 || s3.size()==0 || s2.size()==0 || s1.size()==0) \\n                        continue;\\n                    \\n                    if(stoll(s1)>255 || (s1[0]==\\'0\\' && s1.size()>1)) continue;\\n                    if(stoll(s2)>255 || (s2[0]==\\'0\\' && s2.size()>1)) continue;                        \\n                    if(stoll(s3)>255 || (s3[0]==\\'0\\' && s3.size()>1)) continue;\\n                    if(stoll(s4)>255 || (s4[0]==\\'0\\' && s4.size()>1)) continue;\\n                    res=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                    ans.push_back(res);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n        int n=s.size();\\n        string s1,s2,s3,s4,res;\\n        s1=s2=s3=s4=res=\"\";\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    s1=s.substr(0,i);\\n                    s2=s.substr(i,j-i);\\n                    s3=s.substr(j,k-j);\\n                    s4=s.substr(k);\\n                    if(s4.size()==0 || s3.size()==0 || s2.size()==0 || s1.size()==0) \\n                        continue;\\n                    \\n                    if(stoll(s1)>255 || (s1[0]==\\'0\\' && s1.size()>1)) continue;\\n                    if(stoll(s2)>255 || (s2[0]==\\'0\\' && s2.size()>1)) continue;                        \\n                    if(stoll(s3)>255 || (s3[0]==\\'0\\' && s3.size()>1)) continue;\\n                    if(stoll(s4)>255 || (s4[0]==\\'0\\' && s4.size()>1)) continue;\\n                    res=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                    ans.push_back(res);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080191,
                "title": "c-sweet-n-simple-backtracking-solution-with-valid-function",
                "content": "```\\n# Intuition\\n<!-- The problem describes takign an action that means choice and is obviously a backtracking problem.-->\\n\\n# Approach\\n<!-- We define a backtracking soltution with a for loop that traverse every possibility and backtracks it back to the start.\\nWe also have a valid function which checks following.\\n1) No. of digits=0 pr greater than 3\\n2) No. of digits if greater than 1 then 1st digit shouldnt be 0.\\n3) No no. should be greater than 255. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- T.c. ==> 3^4 ==>O(1) -->\\n\\n- Space complexity:\\n<!-- Space complexity = O(3*4) ==>O(1)-->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool valid(string temp)\\n    {\\n        if(temp.size()==0 || temp.size()>3 ||(temp.size()>1 && temp[0]==\\'0\\') || stoi(temp)>255)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    void Rec(int indx, string s, string temp, vector<string> &ans, int dots)\\n    {\\n        if(dots==0)\\n        {\\n            if(indx==s.size())\\n            {\\n                ans.push_back(temp.substr(0, temp.size()-1));\\n            }\\n            return;\\n        }\\n\\n        for(int i =indx;i<s.size();i++)\\n        {\\n            if(valid(s.substr(indx, i-indx+1)))\\n            {\\n                temp.push_back(s[i]);\\n                temp.push_back(\\'.\\');\\n                Rec(i+1, s, temp, ans, dots-1);\\n                temp.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        string temp;\\n        vector<string> ans;\\n        Rec(0, s, temp, ans, 4);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n# Intuition\\n<!-- The problem describes takign an action that means choice and is obviously a backtracking problem.-->\\n\\n# Approach\\n<!-- We define a backtracking soltution with a for loop that traverse every possibility and backtracks it back to the start.\\nWe also have a valid function which checks following.\\n1) No. of digits=0 pr greater than 3\\n2) No. of digits if greater than 1 then 1st digit shouldnt be 0.\\n3) No no. should be greater than 255. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- T.c. ==> 3^4 ==>O(1) -->\\n\\n- Space complexity:\\n<!-- Space complexity = O(3*4) ==>O(1)-->\\n\\n# Code\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079824,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isValid(string& s, int i, int j)\\n    {\\n        cout<<i<<\" \"<<j<<\" \";\\n        if(i<j && s[i]==\\'0\\')\\n        return false;\\n        string k;\\n        // for(int l=i;l<=j;l++)\\n        // k+=s[l];\\n        k=s.substr(i, j-i+1);\\n        if(stoi(k)<256)\\n        return true;\\n        return false;\\n    }\\n    void solve(string s, int ind, vector<string> v, int c)\\n    {\\n        int n = s.length();\\n        if (ind == n && c==4) {\\n            v.pop_back();\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(c>3)\\n        return;\\n        for (int i = ind; i < n && i<ind+3; i++)\\n        {\\n            if (isValid(s, ind, i))\\n            {\\n                \\n                v.push_back(s.substr(ind, i-ind+1));\\n                v.push_back(\".\");\\n                solve(s, i+1, v, c+1);\\n                v.pop_back();\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s, 0, v, 0);\\n        vector<string> ret;\\n        for(auto v:ans)\\n        {\\n            string k=\"\";\\n            for(string a:v)\\n            k+=a;\\n            ret.push_back(k);\\n        }\\n        return ret;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isValid(string& s, int i, int j)\\n    {\\n        cout<<i<<\" \"<<j<<\" \";\\n        if(i<j && s[i]==\\'0\\')\\n        return false;\\n        string k;\\n        // for(int l=i;l<=j;l++)\\n        // k+=s[l];\\n        k=s.substr(i, j-i+1);\\n        if(stoi(k)<256)\\n        return true;\\n        return false;\\n    }\\n    void solve(string s, int ind, vector<string> v, int c)\\n    {\\n        int n = s.length();\\n        if (ind == n && c==4) {\\n            v.pop_back();\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(c>3)\\n        return;\\n        for (int i = ind; i < n && i<ind+3; i++)\\n        {\\n            if (isValid(s, ind, i))\\n            {\\n                \\n                v.push_back(s.substr(ind, i-ind+1));\\n                v.push_back(\".\");\\n                solve(s, i+1, v, c+1);\\n                v.pop_back();\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s, 0, v, 0);\\n        vector<string> ret;\\n        for(auto v:ans)\\n        {\\n            string k=\"\";\\n            for(string a:v)\\n            k+=a;\\n            ret.push_back(k);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3079820,
                "title": "sundar-susheel-ubla-hua-ekdum-simple-sada-garam-garam-code",
                "content": "# Intuition\\nWe will consider every 1 ,2 and 3 size substrings and try to partition the string into 4 parts and see if they match our condition. We will make use of recursion(backtracking) in it.\\n\\n# Approach\\nWe will consider every 1,2 and 3 size substrings with conditions-\\n- The total partitions should be 4\\n- We should not have any preceding 0.\\n- If we reach the end we will add the string to our ans\\n\\nSo at every ind, we have 3 cases. \\n- We will add the single char to our ans string and add \".\" at end\\n- We will add the next 2 characters and add \".\" at end. Here we have to check whether it is valid or not(first char should not be 0).\\n- We will add the next 3 characters and add \".\" at end. Here we have to check whether it is valid or not(first char should not be 0) along with that it should not be greater that 255.\\n\\n# Complexity\\n- Time complexity:\\nWe are making 3 recursion calls at every index. SO TC (3^n).\\n\\n- Space complexity:\\nSC O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'0\\')\\n            return false;\\n        int n=stoi(s);\\n        if(n<=255)return true;\\n        return false;\\n    }\\n\\n    void helper(int ind,int part,int n,string &s,string ans,vector<string>&res)\\n    {\\n        if(ind==n and part==4)\\n        {\\n            ans.pop_back(); //To remove that last dot \".\"\\n            res.push_back(ans);\\n        }\\n        if(ind==n || part==4)return;\\n        \\n        helper(ind+1,part+1,n,s,ans+s[ind]+\".\",res);\\n        if(ind+2<=n and isValid(s.substr(ind,2)))\\n            helper(ind+2,part+1,n,s,ans+s.substr(ind,2)+\".\",res);\\n        if(ind+3<=n and isValid(s.substr(ind,3)))\\n            helper(ind+3,part+1,n,s,ans+s.substr(ind,3)+\".\",res);\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n=s.size();\\n        helper(0,0,n,s,\"\",res); \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'0\\')\\n            return false;\\n        int n=stoi(s);\\n        if(n<=255)return true;\\n        return false;\\n    }\\n\\n    void helper(int ind,int part,int n,string &s,string ans,vector<string>&res)\\n    {\\n        if(ind==n and part==4)\\n        {\\n            ans.pop_back(); //To remove that last dot \".\"\\n            res.push_back(ans);\\n        }\\n        if(ind==n || part==4)return;\\n        \\n        helper(ind+1,part+1,n,s,ans+s[ind]+\".\",res);\\n        if(ind+2<=n and isValid(s.substr(ind,2)))\\n            helper(ind+2,part+1,n,s,ans+s.substr(ind,2)+\".\",res);\\n        if(ind+3<=n and isValid(s.substr(ind,3)))\\n            helper(ind+3,part+1,n,s,ans+s.substr(ind,3)+\".\",res);\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n=s.size();\\n        helper(0,0,n,s,\"\",res); \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079724,
                "title": "backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand",
                "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n1. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\n2. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n4.  (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\nRequest \\uD83D\\uDE0A :\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/684aadb8-5eea-47f4-aef2-31007841e162_1674279208.2528946.png)\\n\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        string ip;\\n        dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n        return result;\\n    }\\n    void dfs(string s,int start,int step,string ip,vector<string>& result){\\n        if(start==s.size()&&step==4){\\n            ip.erase(ip.end()-1); //remove the last \\'.\\' from the last decimal number\\n            result.push_back(ip);\\n            return;\\n        }\\n        if(s.size()-start>(4-step)*3) return;\\n        if(s.size()-start<(4-step)) return;\\n        int num=0;\\n        for(int i=start;i<start+3;i++){\\n            num=num*10+(s[i]-\\'0\\');\\n            if(num<=255){\\n                ip+=s[i];\\n                dfs(s,i+1,step+1,ip+\\'.\\',result);\\n            }\\n            if(num==0) break;\\n        }\\n    }\\n};\\n\\n```\\n\\n```c++_Comments_explanation []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        for(int i=ind;i<s.size();i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n   public List<String> restoreIpAddresses(String s) {\\n    List<String> ret = new LinkedList<>();\\n    int[] path = new int[4];\\n    helper(ret, s, 0,  path, 0);\\n    return ret;\\n}\\n\\nvoid helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n    if(segment == 4 && idx == s.length() ){\\n        acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n        return ;\\n    }else if(segment == 4 || idx == s.length() ){\\n        return ;\\n    }\\n    \\n    for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n        int val = Integer.parseInt(s.substring(idx, idx + len));\\n        // range check, no leading 0.\\n        if(val > 255 || len >= 2  && s.charAt(idx) == \\'0\\') \\n            break; \\n            \\n        path[segment] = val;\\n        helper(acc, s, idx + len, path, segment + 1);\\n        path[segment] = -1; // for debug. \\n    }\\n}\\n}\\n```\\n```javascript []\\nvar restoreIpAddresses = function(s) {\\n\\tconst result=[]\\n\\tif(s.length > 12) return result\\n\\n\\tfunction dfs(start, dots, curIp){\\n\\t\\tif(dots === 4 && start === s.length) return result.push(curIp.slice(0,-1))\\n\\n\\t\\tif(dots > 4) return\\n\\n\\t\\tconst len = Math.min(s.length, start+3)\\n\\t\\tfor(let j=start; j<len; j++){\\n\\t\\t\\tif(parseInt(s.slice(start,j+1)) < 256 && (start===j || s[start] !==\\'0\\')){\\n\\t\\t\\t\\tdfs(j+1, dots+1, curIp + s.slice(start, j+1) +\\'.\\')\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0,0,\\'\\')\\n\\treturn result\\n};\\n```\\n```python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if int(s) not in range(255255255256):\\n            return []\\n        \\n        def valid(seg):\\n            if not (1 <= len(seg) <= 3):\\n                return False\\n            num = int(seg)\\n            return num in range(256) and str(num) == seg\\n        \\n        ans = []\\n        for dot1 in range(1, 4):\\n            o1 = s[0:dot1]\\n            if valid(o1):\\n                for dot2 in range(dot1+1, dot1+4):\\n                    o2 = s[dot1:dot2]\\n                    if valid(o2):\\n                        for dot3 in range(dot2+1, dot2+4):\\n                            o3 = s[dot2:dot3]\\n                            o4 = s[dot3:]\\n                            if valid(o3) and valid(o4):\\n                                ans.append(\".\".join((o1,o2,o3,o4)))\\n        return ans\\n```\\n\\n\\n\\n\\n\\n\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```C++ []\\n\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        string ip;\\n        dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n        return result;\\n    }\\n    void dfs(string s,int start,int step,string ip,vector<string>& result){\\n        if(start==s.size()&&step==4){\\n            ip.erase(ip.end()-1); //remove the last \\'.\\' from the last decimal number\\n            result.push_back(ip);\\n            return;\\n        }\\n        if(s.size()-start>(4-step)*3) return;\\n        if(s.size()-start<(4-step)) return;\\n        int num=0;\\n        for(int i=start;i<start+3;i++){\\n            num=num*10+(s[i]-\\'0\\');\\n            if(num<=255){\\n                ip+=s[i];\\n                dfs(s,i+1,step+1,ip+\\'.\\',result);\\n            }\\n            if(num==0) break;\\n        }\\n    }\\n};\\n\\n```\n```c++_Comments_explanation []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        for(int i=ind;i<s.size();i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n   public List<String> restoreIpAddresses(String s) {\\n    List<String> ret = new LinkedList<>();\\n    int[] path = new int[4];\\n    helper(ret, s, 0,  path, 0);\\n    return ret;\\n}\\n\\nvoid helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n    if(segment == 4 && idx == s.length() ){\\n        acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n        return ;\\n    }else if(segment == 4 || idx == s.length() ){\\n        return ;\\n    }\\n    \\n    for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n        int val = Integer.parseInt(s.substring(idx, idx + len));\\n        // range check, no leading 0.\\n        if(val > 255 || len >= 2  && s.charAt(idx) == \\'0\\') \\n            break; \\n            \\n        path[segment] = val;\\n        helper(acc, s, idx + len, path, segment + 1);\\n        path[segment] = -1; // for debug. \\n    }\\n}\\n}\\n```\n```javascript []\\nvar restoreIpAddresses = function(s) {\\n\\tconst result=[]\\n\\tif(s.length > 12) return result\\n\\n\\tfunction dfs(start, dots, curIp){\\n\\t\\tif(dots === 4 && start === s.length) return result.push(curIp.slice(0,-1))\\n\\n\\t\\tif(dots > 4) return\\n\\n\\t\\tconst len = Math.min(s.length, start+3)\\n\\t\\tfor(let j=start; j<len; j++){\\n\\t\\t\\tif(parseInt(s.slice(start,j+1)) < 256 && (start===j || s[start] !==\\'0\\')){\\n\\t\\t\\t\\tdfs(j+1, dots+1, curIp + s.slice(start, j+1) +\\'.\\')\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0,0,\\'\\')\\n\\treturn result\\n};\\n```\n```python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if int(s) not in range(255255255256):\\n            return []\\n        \\n        def valid(seg):\\n            if not (1 <= len(seg) <= 3):\\n                return False\\n            num = int(seg)\\n            return num in range(256) and str(num) == seg\\n        \\n        ans = []\\n        for dot1 in range(1, 4):\\n            o1 = s[0:dot1]\\n            if valid(o1):\\n                for dot2 in range(dot1+1, dot1+4):\\n                    o2 = s[dot1:dot2]\\n                    if valid(o2):\\n                        for dot3 in range(dot2+1, dot2+4):\\n                            o3 = s[dot2:dot3]\\n                            o4 = s[dot3:]\\n                            if valid(o3) and valid(o4):\\n                                ans.append(\".\".join((o1,o2,o3,o4)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079606,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\n1. Generate all possible index `points` to divide given `s` into `4` parts such that `1 <= len(part) <= 3` for each `part`.\\n\\n2. Define `is_valid_ip` which takes `parts` and returns `true` if all `part` has `0 <= int(part) <= 255` and has no leading zeroes.\\n\\n3. Calculate `candidate_ips` by splitting `s` at `points`.\\n\\n4. Filter only the `valid_ips` from `candidate_ips`.\\n\\n5. Join each into a `string` and return.\\n\\n# Complexity\\n- Time complexity: $$O(m^n * n)$$\\n\\n- Space complexity: $$O(m * n)$$\\n\\nwhere,\\n`n is number of parts in ip, i.e 4`, and \\n`m is max length of each part, i.e 3`\\n\\n# Code\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n        n = len(s)\\n        points = (\\n            (i, j, k)\\n            for i in range(0 + 1, min(0 + 4, n))\\n            for j in range(i + 1, min(i + 4, n))\\n            for k in range(j + 1, min(j + 4, n))\\n        )\\n\\n        is_valid_ip = lambda ip: all(map(lambda x: int(x) <= 255 and (len(x) == 1 or x[0] != \\'0\\'), ip))\\n        \\n        candidate_ips = ((s[:i], s[i:j], s[j:k], s[k:]) for i, j, k in points)\\n        valid_ips = filter(is_valid_ip, candidate_ips)\\n        return [\\'.\\'.join(ip) for ip in valid_ips]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n        n = len(s)\\n        points = (\\n            (i, j, k)\\n            for i in range(0 + 1, min(0 + 4, n))\\n            for j in range(i + 1, min(i + 4, n))\\n            for k in range(j + 1, min(j + 4, n))\\n        )\\n\\n        is_valid_ip = lambda ip: all(map(lambda x: int(x) <= 255 and (len(x) == 1 or x[0] != \\'0\\'), ip))\\n        \\n        candidate_ips = ((s[:i], s[i:j], s[j:k], s[k:]) for i, j, k in points)\\n        valid_ips = filter(is_valid_ip, candidate_ips)\\n        return [\\'.\\'.join(ip) for ip in valid_ips]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060566,
                "title": "c-java-100-solution-using-backtracking-restore-ip-addresses",
                "content": "# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795387,
                "title": "python-solution-backtrack-recursive-easy-comments",
                "content": "### Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Backtrack (Recursive) approach***\\n\\n### Complexity\\n- Time complexity: O(3^5)    \\n   ( As there are max 4 integers (chunk) in all )\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        size = len(s)\\n        # Check Edge Condition\\n        if size > 12: return []\\n\\n        res = []\\n\\n        def backtrack(i, dots, curIp):\\n            if i == size and dots == 4:\\n                res.append(curIp[:-1])  # discarding the last 4th dot\\n                return \\n            if dots > 4:  # Cannot cover entore number into IP address\\n                return \\n            \\n            end_offset = min(i+3, size)  # end place where we can put the next dot\\n\\n            for j in range(i, end_offset):  # j is the offset to place from {i}\\n                # place dot\\n                part = s[i:j+1]\\n                # 1. number must be lte. 255\\n                # 2. number must not start with 0\\n                if int(part) <= 255 and (i == j or s[i] != \\'0\\'):\\n                    backtrack(j+1, dots+1, curIp + part + \\'.\\')\\n            \\n        backtrack(0, 0, \\'\\')\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        size = len(s)\\n        # Check Edge Condition\\n        if size > 12: return []\\n\\n        res = []\\n\\n        def backtrack(i, dots, curIp):\\n            if i == size and dots == 4:\\n                res.append(curIp[:-1])  # discarding the last 4th dot\\n                return \\n            if dots > 4:  # Cannot cover entore number into IP address\\n                return \\n            \\n            end_offset = min(i+3, size)  # end place where we can put the next dot\\n\\n            for j in range(i, end_offset):  # j is the offset to place from {i}\\n                # place dot\\n                part = s[i:j+1]\\n                # 1. number must be lte. 255\\n                # 2. number must not start with 0\\n                if int(part) <= 255 and (i == j or s[i] != \\'0\\'):\\n                    backtrack(j+1, dots+1, curIp + part + \\'.\\')\\n            \\n        backtrack(0, 0, \\'\\')\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718493,
                "title": "very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string> restoreIpAddresses(string s) \\n    {  \\n         int idx=0;\\n         string str=\"\";\\n         int count=0;\\n         fun(s,idx,str,count);\\n         return ans;\\n    }\\n    void fun(string &s , int idx ,string str,int count)\\n    {\\n         if(count>4)\\n         return;\\n\\n         if(idx >= s.length() and count==4)\\n         {\\n              str.pop_back();\\n              ans.push_back(str);\\n              return;\\n         }\\n\\n         int num=0;\\n         string temp=\"\";\\n\\n         for(int i=idx;i<s.length();i++)\\n         {\\n             char ch = s[i];\\n             int digit = ch - \\'0\\';\\n\\n             num = (num*10) + digit;\\n             temp.push_back(ch);\\n\\n             //we need to check for the leading zeor\\'s\\n              if(temp.length()>1 and temp[0]==\\'0\\' and (num>0 or num==0)) \\n              {\\n                 return;\\t\\n              }\\n\\n             //now if eveything is ok then call for next segment\\n             if((num>=0 and num<=255))\\n             {\\n               fun(s,i+1,str+temp+\\'.\\',count+1);\\t\\n             }\\n             else\\n             {\\n               return;\\t\\n             }\\n\\n         }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string> restoreIpAddresses(string s) \\n    {  \\n         int idx=0;\\n         string str=\"\";\\n         int count=0;\\n         fun(s,idx,str,count);\\n         return ans;\\n    }\\n    void fun(string &s , int idx ,string str,int count)\\n    {\\n         if(count>4)\\n         return;\\n\\n         if(idx >= s.length() and count==4)\\n         {\\n              str.pop_back();\\n              ans.push_back(str);\\n              return;\\n         }\\n\\n         int num=0;\\n         string temp=\"\";\\n\\n         for(int i=idx;i<s.length();i++)\\n         {\\n             char ch = s[i];\\n             int digit = ch - \\'0\\';\\n\\n             num = (num*10) + digit;\\n             temp.push_back(ch);\\n\\n             //we need to check for the leading zeor\\'s\\n              if(temp.length()>1 and temp[0]==\\'0\\' and (num>0 or num==0)) \\n              {\\n                 return;\\t\\n              }\\n\\n             //now if eveything is ok then call for next segment\\n             if((num>=0 and num<=255))\\n             {\\n               fun(s,i+1,str+temp+\\'.\\',count+1);\\t\\n             }\\n             else\\n             {\\n               return;\\t\\n             }\\n\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906017,
                "title": "backtracking-c-commented",
                "content": "-> We simply have to divide the given string into 4 parts where integer value of each part should be between 0 to 255 .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> local ;\\n    int n ;\\n\\t\\n\\t// function to calculate the integer value of a string\\n    int stoint(string s){\\n        int num = 0 ;\\n        for(auto c : s){\\n            num = num*10 + (c-\\'0\\');\\n        }\\n        return num ;\\n    }\\n\\t\\n    void helper(string s , int idx , vector<string>& path , int part){\\n\\t\\tif(idx==n && part==0){         // we have reached the end of the string and also divided it in 4 parts\\n            local.push_back(path) ;     // so we can include this path in our answer.\\n            return ; \\n        }\\n    \\n        for(int i=idx ;  i<n ; i++){\\n            if(i-idx+1 > 3)             // each part can\\'t be greater than 255 so not more than 3 digits\\n                return ;\\n            string temp = s.substr(idx , i-idx+1) ;\\n            if(stoint(temp)>=0 && stoint(temp)<=255){\\n                if(temp[0]==\\'0\\' && temp.length()>1) return ;   // As we can\\'t have strings with leading zeroes\\n                path.push_back(temp) ;\\n                helper(s , i+1 , path , part-1) ;    \\n                path.pop_back() ;      // simple backtracking \\n            }\\n        } \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        n =  s.length() ;\\n        vector<string> path ;\\n       if(n<4 || n>12)   return {} ;\\n        \\n        helper(s , 0 , path , 4) ;\\n        vector<string> ans  ; \\n        for(auto arr : local){   // creating our final ans array\\n            string temp  = \"\";\\n            for(auto t : arr ){\\n                temp += t ;\\n                temp += \\'.\\' ;\\n            }\\n            temp.pop_back() ;   //as last element of string will be \\'.\\' \\n            ans.push_back(temp) ;\\n        }\\n        return ans  ;\\n    }\\n};\\n// Plz upvote if it helped.\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> local ;\\n    int n ;\\n\\t\\n\\t// function to calculate the integer value of a string\\n    int stoint(string s){\\n        int num = 0 ;\\n        for(auto c : s){\\n            num = num*10 + (c-\\'0\\');\\n        }\\n        return num ;\\n    }\\n\\t\\n    void helper(string s , int idx , vector<string>& path , int part){\\n\\t\\tif(idx==n && part==0){         // we have reached the end of the string and also divided it in 4 parts\\n            local.push_back(path) ;     // so we can include this path in our answer.\\n            return ; \\n        }\\n    \\n        for(int i=idx ;  i<n ; i++){\\n            if(i-idx+1 > 3)             // each part can\\'t be greater than 255 so not more than 3 digits\\n                return ;\\n            string temp = s.substr(idx , i-idx+1) ;\\n            if(stoint(temp)>=0 && stoint(temp)<=255){\\n                if(temp[0]==\\'0\\' && temp.length()>1) return ;   // As we can\\'t have strings with leading zeroes\\n                path.push_back(temp) ;\\n                helper(s , i+1 , path , part-1) ;    \\n                path.pop_back() ;      // simple backtracking \\n            }\\n        } \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        n =  s.length() ;\\n        vector<string> path ;\\n       if(n<4 || n>12)   return {} ;\\n        \\n        helper(s , 0 , path , 4) ;\\n        vector<string> ans  ; \\n        for(auto arr : local){   // creating our final ans array\\n            string temp  = \"\";\\n            for(auto t : arr ){\\n                temp += t ;\\n                temp += \\'.\\' ;\\n            }\\n            temp.pop_back() ;   //as last element of string will be \\'.\\' \\n            ans.push_back(temp) ;\\n        }\\n        return ans  ;\\n    }\\n};\\n// Plz upvote if it helped.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905399,
                "title": "intuitive-python-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans=[]\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.recurse(s,3,0)\\n        return self.ans\\n    \\n    def recurse(self,s:str,dots:int,idx:int)->None:\\n        if dots==0:\\n            if self.isValid(s[idx:]): \\n                self.ans.append(s)\\n            return \\n        dots-=1\\n        self.recurse(s[:idx+1]+\".\"+s[idx+1:],dots,idx+2)\\n        if self.isValid(s[idx:idx+2]):\\n            self.recurse(s[:idx+2]+\".\"+s[idx+2:],dots,idx+3)\\n        if self.isValid(s[idx:idx+3]):\\n            self.recurse(s[:idx+3]+\".\"+s[idx+3:],dots,idx+4)\\n        \\n    def isValid(self,s:str)->bool:\\n        if len(s)==0:\\n            return False\\n        if len(s)==1: \\n            return True\\n        if len(s)==2: \\n            return (s[0]!=\"0\")\\n        return (s[0]!=\"0\") and int(s)<=255",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans=[]\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.recurse(s,3,0)\\n        return self.ans\\n    \\n    def recurse(self,s:str,dots:int,idx:int)->None:\\n        if dots==0:\\n            if self.isValid(s[idx:]): \\n                self.ans.append(s)\\n            return \\n        dots-=1\\n        self.recurse(s[:idx+1]+\".\"+s[idx+1:],dots,idx+2)\\n        if self.isValid(s[idx:idx+2]):\\n            self.recurse(s[:idx+2]+\".\"+s[idx+2:],dots,idx+3)\\n        if self.isValid(s[idx:idx+3]):\\n            self.recurse(s[:idx+3]+\".\"+s[idx+3:],dots,idx+4)\\n        \\n    def isValid(self,s:str)->bool:\\n        if len(s)==0:\\n            return False\\n        if len(s)==1: \\n            return True\\n        if len(s)==2: \\n            return (s[0]!=\"0\")\\n        return (s[0]!=\"0\") and int(s)<=255",
                "codeTag": "Java"
            },
            {
                "id": 1498413,
                "title": "python-iterative-solution-not-optimal-solution-but-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def valid(s):\\n            if len(s)<1 or len(s)>3:\\n                return False\\n            if int(s)>255:\\n                return False\\n            if int(s)!=0 and s[0]==\\'0\\':\\n                return False\\n            if int(s)==0 and len(s)>1:\\n                return False\\n            return True\\n       \\n        ans = []\\n        for i in range(4):\\n            \\n            if not valid(s[:i]):\\n                continue\\n            \\n            for j in range(i,i+4):\\n                \\n                if not valid(s[i:j]):\\n                    continue\\n                \\n                for k in range(j,j+4):\\n                    \\n                    if not valid(s[j:k]):\\n                        continue\\n                    \\n                    if not valid(s[k:]):\\n                        continue\\n    \\n                    ans.append(s[:i]+\".\"+s[i:j]+\".\"+s[j:k]+\".\"+s[k:])\\n                   \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def valid(s):\\n            if len(s)<1 or len(s)>3:\\n                return False\\n            if int(s)>255:\\n                return False\\n            if int(s)!=0 and s[0]==\\'0\\':\\n                return False\\n            if int(s)==0 and len(s)>1:\\n                return False\\n            return True\\n       \\n        ans = []\\n        for i in range(4):\\n            \\n            if not valid(s[:i]):\\n                continue\\n            \\n            for j in range(i,i+4):\\n                \\n                if not valid(s[i:j]):\\n                    continue\\n                \\n                for k in range(j,j+4):\\n                    \\n                    if not valid(s[j:k]):\\n                        continue\\n                    \\n                    if not valid(s[k:]):\\n                        continue\\n    \\n                    ans.append(s[:i]+\".\"+s[i:j]+\".\"+s[j:k]+\".\"+s[k:])\\n                   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383843,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s.length()>12) return new ArrayList<>();\\n        computeIP(\"\", s, 0, 0);\\n        return ans;\\n    }\\n    public void computeIP(String cur, String s, int idx, int seg_num) {\\n        if (seg_num==4 && idx>=s.length()) ans.add(cur);\\n        for (int i = 1; i <= Math.min(3, s.length()-idx); i++) {\\n            String sub = s.substring(idx, idx+i);\\n            if (sub.length()>1&&sub.charAt(0)==\\'0\\') return;\\n            int temp = Integer.parseInt(sub);\\n            if (temp<=255 && temp>=0) {\\n                if (!cur.equals(\"\")) {\\n                    computeIP(cur.concat(\".\" + sub), s, idx+i, seg_num+1);\\n                }\\n                else {\\n                    computeIP(cur.concat(sub), s, idx+i, seg_num+1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s.length()>12) return new ArrayList<>();\\n        computeIP(\"\", s, 0, 0);\\n        return ans;\\n    }\\n    public void computeIP(String cur, String s, int idx, int seg_num) {\\n        if (seg_num==4 && idx>=s.length()) ans.add(cur);\\n        for (int i = 1; i <= Math.min(3, s.length()-idx); i++) {\\n            String sub = s.substring(idx, idx+i);\\n            if (sub.length()>1&&sub.charAt(0)==\\'0\\') return;\\n            int temp = Integer.parseInt(sub);\\n            if (temp<=255 && temp>=0) {\\n                if (!cur.equals(\"\")) {\\n                    computeIP(cur.concat(\".\" + sub), s, idx+i, seg_num+1);\\n                }\\n                else {\\n                    computeIP(cur.concat(sub), s, idx+i, seg_num+1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206516,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public IList<string> RestoreIpAddresses(string s) \\n    {\\n        IList<string> ans = new List<string>();\\n\\n        if(s.Length > 12)\\n            return ans;\\n        \\n        Backtrack(s,0,new List<string>(),ans);\\n        return ans;\\n    }\\n    \\n    private void Backtrack(string s, int st, IList<string> li, IList<string> ans)\\n    {\\n        if(st==s.Length && li.Count==4)\\n        {\\n            string ip = string.Join(\".\", li.ToArray());\\n            ans.Add(ip);\\n            return;\\n        }\\n        \\n        for(int len=1; len<=s.Length-st; len++)\\n        {\\n            string str = s.Substring(st,len);\\n            \\n            if(IsValid(str))\\n            {\\n                li.Add(str);\\n                Backtrack(s,st+len,li,ans);\\n                li.RemoveAt(li.Count-1);\\n            }\\n        }\\n    }\\n    \\n    private bool IsValid(string str)\\n    {\\n        if(str.Length > 3)\\n            return false;\\n        \\n        int num = int.Parse(str);\\n        \\n        if(num < 0 || num > 255 || str.Length != num.ToString().Length)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public IList<string> RestoreIpAddresses(string s) \\n    {\\n        IList<string> ans = new List<string>();\\n\\n        if(s.Length > 12)\\n            return ans;\\n        \\n        Backtrack(s,0,new List<string>(),ans);\\n        return ans;\\n    }\\n    \\n    private void Backtrack(string s, int st, IList<string> li, IList<string> ans)\\n    {\\n        if(st==s.Length && li.Count==4)\\n        {\\n            string ip = string.Join(\".\", li.ToArray());\\n            ans.Add(ip);\\n            return;\\n        }\\n        \\n        for(int len=1; len<=s.Length-st; len++)\\n        {\\n            string str = s.Substring(st,len);\\n            \\n            if(IsValid(str))\\n            {\\n                li.Add(str);\\n                Backtrack(s,st+len,li,ans);\\n                li.RemoveAt(li.Count-1);\\n            }\\n        }\\n    }\\n    \\n    private bool IsValid(string str)\\n    {\\n        if(str.Length > 3)\\n            return false;\\n        \\n        int num = int.Parse(str);\\n        \\n        if(num < 0 || num > 255 || str.Length != num.ToString().Length)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179768,
                "title": "java-backtracking-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    List<String> list;\\n    public List<String> restoreIpAddresses(String s) {\\n        list = new ArrayList<>();\\n        //if string length is greater than 12 and smaller than 12 i can\\'t make a valid ip addres....think!\\n        if(s.length() < 4 || s.length() > 12){\\n            return list;\\n        }\\n        \\n        restoreIP(s, \"\" , 0);\\n        return list;\\n    }\\n    // idx shows the number of sections of ip we have covered like 123.22. now idx will be 2 cze we have used 2 dots\\n    // and atmost we can use 3\\n    void restoreIP(String s, String sub, int idx){\\n        \\n        if(s.length() == 0 || idx == 4){\\n            if(s.length() == 0 && idx == 4){\\n                //removing the last dot and then adding, because while making call we putted .\\n                // we do not need to check validity of string before adding because, while making call we have checked                 // all scenerio\\n                list.add(sub.substring(0, sub.length()-1));\\n            }\\n            return;\\n        }\\n        //1st chcek with string size of 1 i.e, 1. , 2.  etc. \\n        restoreIP(s.substring(1), sub + s.substring(0,1) + \".\" , idx+1);\\n        \\n        //2nd check for 2 length string\\n        if(s.length() >= 2 && s.charAt(0) != \\'0\\')\\n            restoreIP(s.substring(2), sub + s.substring(0,2) + \".\", idx + 1);\\n        \\n        //3rd check for 3 length string and if string value is greater than 255 it\\'s not valid..according to the question.\\n        if(s.length() >= 3 && s.charAt(0) != \\'0\\' && Integer.valueOf(s.substring(0,3)) <= 255)\\n            restoreIP(s.substring(3), sub + s.substring(0,3) + \".\" , idx + 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> list;\\n    public List<String> restoreIpAddresses(String s) {\\n        list = new ArrayList<>();\\n        //if string length is greater than 12 and smaller than 12 i can\\'t make a valid ip addres....think!\\n        if(s.length() < 4 || s.length() > 12){\\n            return list;\\n        }\\n        \\n        restoreIP(s, \"\" , 0);\\n        return list;\\n    }\\n    // idx shows the number of sections of ip we have covered like 123.22. now idx will be 2 cze we have used 2 dots\\n    // and atmost we can use 3\\n    void restoreIP(String s, String sub, int idx){\\n        \\n        if(s.length() == 0 || idx == 4){\\n            if(s.length() == 0 && idx == 4){\\n                //removing the last dot and then adding, because while making call we putted .\\n                // we do not need to check validity of string before adding because, while making call we have checked                 // all scenerio\\n                list.add(sub.substring(0, sub.length()-1));\\n            }\\n            return;\\n        }\\n        //1st chcek with string size of 1 i.e, 1. , 2.  etc. \\n        restoreIP(s.substring(1), sub + s.substring(0,1) + \".\" , idx+1);\\n        \\n        //2nd check for 2 length string\\n        if(s.length() >= 2 && s.charAt(0) != \\'0\\')\\n            restoreIP(s.substring(2), sub + s.substring(0,2) + \".\", idx + 1);\\n        \\n        //3rd check for 3 length string and if string value is greater than 255 it\\'s not valid..according to the question.\\n        if(s.length() >= 3 && s.charAt(0) != \\'0\\' && Integer.valueOf(s.substring(0,3)) <= 255)\\n            restoreIP(s.substring(3), sub + s.substring(0,3) + \".\" , idx + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789947,
                "title": "simple-python-backtracking",
                "content": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if not 4 <= len(s) <= 12:\\n            return []\\n        res = []\\n        self.backtrack(s, 0, \\'\\', res, 0)\\n        return res\\n\\n    def backtrack(self, s, start, path, res, count):\\n        if count == 4:\\n            if start == len(s):\\n                res.append(path[1:])\\n            return\\n\\n        for end in [start + 1, start + 2, start + 3]:\\n\\t\\t\\t# number between 0 and 255 and does not start with 0\\n            if end <= len(s) and 0 <= int(s[start: end]) <= 255 and str(int(s[start: end])) == s[start: end]:\\n                self.backtrack(s, end, path + \\'.\\' + s[start: end], res, count + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if not 4 <= len(s) <= 12:\\n            return []\\n        res = []\\n        self.backtrack(s, 0, \\'\\', res, 0)\\n        return res\\n\\n    def backtrack(self, s, start, path, res, count):\\n        if count == 4:\\n            if start == len(s):\\n                res.append(path[1:])\\n            return\\n\\n        for end in [start + 1, start + 2, start + 3]:\\n\\t\\t\\t# number between 0 and 255 and does not start with 0\\n            if end <= len(s) and 0 <= int(s[start: end]) <= 255 and str(int(s[start: end])) == s[start: end]:\\n                self.backtrack(s, end, path + \\'.\\' + s[start: end], res, count + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774340,
                "title": "java-backtracking-1ms",
                "content": "```\\nclass Solution {\\n    \\n    List<String> ansList = new ArrayList<>();\\n    \\n    boolean isValid(String s){\\n        if(s.length()>3 || (s.length()>1 && s.charAt(0)==\\'0\\')) return false; \\n        int val = Integer.valueOf(s);\\n        return val>=0 && val<=255 ;\\n    }\\n    \\n    void solve(int depth, String s, StringBuilder sb){\\n        if(depth == 3){\\n           if(isValid(s)){\\n               sb.append(s);\\n               ansList.add(sb.toString());\\n               sb.setLength(sb.length()-s.length());\\n           }\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(i>=s.length()) break;\\n            String temp = s.substring(0,i);\\n            if(isValid(temp)){\\n                sb.append(temp).append(\".\");\\n                solve(depth+1,s.substring(i),sb);\\n                sb.setLength(sb.length()-(temp.length()+1));\\n            }\\n        }\\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        solve(0,s,new StringBuilder(\"\"));\\n        return ansList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> ansList = new ArrayList<>();\\n    \\n    boolean isValid(String s){\\n        if(s.length()>3 || (s.length()>1 && s.charAt(0)==\\'0\\')) return false; \\n        int val = Integer.valueOf(s);\\n        return val>=0 && val<=255 ;\\n    }\\n    \\n    void solve(int depth, String s, StringBuilder sb){\\n        if(depth == 3){\\n           if(isValid(s)){\\n               sb.append(s);\\n               ansList.add(sb.toString());\\n               sb.setLength(sb.length()-s.length());\\n           }\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(i>=s.length()) break;\\n            String temp = s.substring(0,i);\\n            if(isValid(temp)){\\n                sb.append(temp).append(\".\");\\n                solve(depth+1,s.substring(i),sb);\\n                sb.setLength(sb.length()-(temp.length()+1));\\n            }\\n        }\\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        solve(0,s,new StringBuilder(\"\"));\\n        return ansList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283437,
                "title": "c-concise-recursive-solution",
                "content": "1. We try out all the three different lengths (1-3) at each index.\\n2. We check if the value obtained for each length is valid. If yes, we recursively proceed.\\n3. If the index reach the end and the number of strings on the path is 4, then we store the path.\\n4. For faster return, we can check if the current cout has already been at least 4.\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        size = s.size();\\n        helper(s, 0, 0);\\n        return ret;\\n    }\\nprivate:\\n    int size;\\n    vector<string> ret;\\n    vector<string> path;\\n    void helper(string& s, int idx, int count) {\\n        if(idx == size && count == 4) {\\n            string tmp; for(auto& p : path) tmp += p + \".\"; tmp.pop_back();\\n            ret.push_back(tmp);\\n            return;\\n        }\\n        if(count > 4) return;\\n        for(int len = 1; len<=3 && len+idx-1<size; len++){\\n            string tmp = s.substr(idx, len);\\n            int val = stoi(tmp);\\n            if(val > 255 || (tmp.size()>1 && tmp[0] == \\'0\\')) continue;\\n            path.push_back(tmp);\\n            helper(s, len+idx, count+1);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        size = s.size();\\n        helper(s, 0, 0);\\n        return ret;\\n    }\\nprivate:\\n    int size;\\n    vector<string> ret;\\n    vector<string> path;\\n    void helper(string& s, int idx, int count) {\\n        if(idx == size && count == 4) {\\n            string tmp; for(auto& p : path) tmp += p + \".\"; tmp.pop_back();\\n            ret.push_back(tmp);\\n            return;\\n        }\\n        if(count > 4) return;\\n        for(int len = 1; len<=3 && len+idx-1<size; len++){\\n            string tmp = s.substr(idx, len);\\n            int val = stoi(tmp);\\n            if(val > 255 || (tmp.size()>1 && tmp[0] == \\'0\\')) continue;\\n            path.push_back(tmp);\\n            helper(s, len+idx, count+1);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253515,
                "title": "beats-100-c-4-small-loops",
                "content": "class Solution {\\npublic:\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n = s.length();\\n        if (!n) return vector<string>();\\n        \\n        for (int a = 1; a <= 3; a++) {\\n            for (int b = 1; b <= 3; b++) {\\n                for (int c = 1; c <= 3; c++) {\\n                    for (int d = 1; d <= 3; d++) {\\n                        if (a+b+c+d == n) {\\n                            int A = stoi(s.substr(0, a));\\n                            int B = stoi(s.substr(a, b));\\n                            int C = stoi(s.substr(a+b, c));\\n                            int D = stoi(s.substr(a+b+c, d));\\n                            \\n                            if (A <= 255 && B <= 255 && C <= 255 && D <= 255) {\\n                                string r = to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D);\\n                                if (r.length() == n+3)\\n                                    res.push_back(r);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n = s.length();\\n        if (!n) return vector<string>();\\n        \\n        for (int a = 1; a <= 3; a++) {\\n            for (int b = 1; b <= 3; b++) {\\n                for (int c = 1; c <= 3; c++) {\\n                    for (int d = 1; d <= 3; d++) {\\n                        if (a+b+c+d == n) {\\n                            int A = stoi(s.substr(0, a));\\n                            int B = stoi(s.substr(a, b));\\n                            int C = stoi(s.substr(a+b, c));\\n                            int D = stoi(s.substr(a+b+c, d));\\n                            \\n                            if (A <= 255 && B <= 255 && C <= 255 && D <= 255) {\\n                                string r = to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D);\\n                                if (r.length() == n+3)\\n                                    res.push_back(r);\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 151356,
                "title": "javascript-backtracking",
                "content": "```js\\nfunction restoreIpAddresses(s) {\\n  const res = [];\\n  dfs([], 0);\\n  return res;\\n  \\n  function dfs(prefix, idx) {\\n    if (prefix.length === 4 && idx === s.length) {\\n      res.push(prefix.join(\\'.\\'));\\n      return;\\n    }\\n    \\n    if (prefix.length === 4 || idx === s.length) {\\n      return;\\n    }\\n    \\n    for (let r = idx; r < s.length; r++) {\\n      if (r !== idx && s[idx] === \\'0\\') return;\\n      \\n      const num = parseInt(s.slice(idx, r+1));\\n      if (num > 255) {\\n        return;\\n      }\\n      prefix.push(num);\\n      dfs(prefix, r+1);\\n      prefix.pop();\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction restoreIpAddresses(s) {\\n  const res = [];\\n  dfs([], 0);\\n  return res;\\n  \\n  function dfs(prefix, idx) {\\n    if (prefix.length === 4 && idx === s.length) {\\n      res.push(prefix.join(\\'.\\'));\\n      return;\\n    }\\n    \\n    if (prefix.length === 4 || idx === s.length) {\\n      return;\\n    }\\n    \\n    for (let r = idx; r < s.length; r++) {\\n      if (r !== idx && s[idx] === \\'0\\') return;\\n      \\n      const num = parseInt(s.slice(idx, r+1));\\n      if (num > 255) {\\n        return;\\n      }\\n      prefix.push(num);\\n      dfs(prefix, r+1);\\n      prefix.pop();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136053,
                "title": "c-runtime-beats-97-61-of-cpp-submissions",
                "content": "```\\nclass Solution {\\n  void solver(string s, int index, string address, vector<string> & res) {\\n    if (index == 4) {\\n      if (s.empty())\\n        res.push_back(address.substr(0, address.size() - 1)); // skip last dot.\\n      return;\\n    }\\n\\n    for (int i = 1; i < 4; ++i) {\\n      if (i <= s.size()) {\\n        if (i >= 2 && s[0] == \\'0\\') continue;\\n        string part = s.substr(0, i);\\n        if (i == 3 && atoi(part.c_str()) > 255) continue;\\n        solver(s.substr(i), index + 1, address + part + \".\", res);\\n      }\\n    }\\n  }\\n\\npublic:\\n  vector<string> restoreIpAddresses(string s) {\\n    vector<string> res;\\n    solver(s, 0, \"\", res);\\n    return res;\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  void solver(string s, int index, string address, vector<string> & res) {\\n    if (index == 4) {\\n      if (s.empty())\\n        res.push_back(address.substr(0, address.size() - 1)); // skip last dot.\\n      return;\\n    }\\n\\n    for (int i = 1; i < 4; ++i) {\\n      if (i <= s.size()) {\\n        if (i >= 2 && s[0] == \\'0\\') continue;\\n        string part = s.substr(0, i);\\n        if (i == 3 && atoi(part.c_str()) > 255) continue;\\n        solver(s.substr(i), index + 1, address + part + \".\", res);\\n      }\\n    }\\n  }\\n\\npublic:\\n  vector<string> restoreIpAddresses(string s) {\\n    vector<string> res;\\n    solver(s, 0, \"\", res);\\n    return res;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30942,
                "title": "c-0ms-recursive-solution-clean-and-easy-to-understand",
                "content": "```\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        help(ans, \"\", s, 0);\\n        return ans;\\n    }\\n    void help(vector<string>& ans, string cur, string s, int count){\\n        if(count == 4){\\n            if(s == \"\") ans.push_back(cur.substr(1));\\n            return;\\n        }\\n        if(s.size() >= 3 && s[0] != '0'){\\n            if(stoi(s.substr(0, 3)) <= 255)\\n                help(ans, cur + \".\" + s.substr(0, 3), s.substr(3), count + 1);\\n        }\\n        if(s.size() >= 2 && s[0] != '0') help(ans, cur + \".\" + s.substr(0, 2), s.substr(2), count + 1);\\n        if(s.size() >= 1) help(ans, cur + \".\" + s.substr(0, 1), s.substr(1), count + 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        help(ans, \"\", s, 0);\\n        return ans;\\n    }\\n    void help(vector<string>& ans, string cur, string s, int count){\\n        if(count == 4){\\n            if(s == \"\") ans.push_back(cur.substr(1));\\n            return;\\n        }\\n        if(s.size() >= 3 && s[0] != '0'){\\n            if(stoi(s.substr(0, 3)) <= 255)\\n                help(ans, cur + \".\" + s.substr(0, 3), s.substr(3), count + 1);\\n        }\\n        if(s.size() >= 2 && s[0] != '0') help(ans, cur + \".\" + s.substr(0, 2), s.substr(2), count + 1);\\n        if(s.size() >= 1) help(ans, cur + \".\" + s.substr(0, 1), s.substr(1), count + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31108,
                "title": "share-my-clean-dfs-java-code",
                "content": "    /*\\n        dfs. \\u5728\\u6bcf\\u4e00\\u5c42, \\u53d6\\u5b57\\u7b26\\u4e32\\u7684\\u524d1/2/3\\u4e2a\\u5b57\\u6bcd\\n        \\u7b2c\\u56db\\u5c42\\u65f6\\u68c0\\u67e5\\u5e76collect answer.\\n    */\\n    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n             List<String> ans = new ArrayList<>();\\n             dfs(ans, new StringBuilder(), s, 0);\\n             return ans;\\n        }\\n        \\n        private void dfs(List<String> ans, StringBuilder cur, String s, int level) {\\n            if (level == 4) {  // all previous 4 segments are done\\n                if (s.length() == 0) {  // s is entirely used\\n                    ans.add(cur.toString().substring(0, cur.length() - 1));  // remove the dot at tail\\n                }\\n                return;\\n            }\\n            for (int i = 1; i <= Math.min(3, s.length()); ++i) {  // length of each segment are at most 3\\n                String curPart = s.substring(0, i);\\n                if (curPart.length() > 1 && curPart.charAt(0) == '0' || Integer.parseInt(curPart) > 255) {\\n                    break;\\n                }\\n                cur.append(curPart).append(\".\");\\n                dfs(ans, cur, s.substring(i), level + 1);\\n                cur.delete(cur.length() - curPart.length() - 1, cur.length());\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n             List<String> ans = new ArrayList<>();\\n             dfs(ans, new StringBuilder(), s, 0);\\n             return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31130,
                "title": "c-backtracking-solution-easy-understand",
                "content": "    class Solution {\\n    public:\\n    vector<string> restoreIpAddresses(string s) \\n    {\\n    \\tstd::vector<string> ans;\\n    \\tstd::vector<string> v;\\n\\n    \\tsplitIP(0, 4, s, ans, v);\\n\\n    \\treturn ans;\\n    }\\n\\n    private:\\n\\tvoid splitIP(int startIndex, int segments, string &str, std::vector<string> &ans, std::vector<string> &ip)\\n\\t{\\n\\t\\tif (startIndex >= str.length() && segments != 0)\\n\\t\\t\\treturn;\\n\\t\\tif (startIndex != str.length() && segments == 0)\\n\\t\\t\\treturn;\\n\\t\\tif (startIndex == str.length() && segments == 0)\\n\\t\\t{\\n\\t\\t\\tans.push_back(ip[0] + '.' + ip[1] + '.' + ip[2] + '.' + ip[3]);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = startIndex; i < startIndex + 3 && i < str.length(); ++i)\\n\\t\\t{\\n\\t\\t\\tstring digit = str.substr(startIndex, i - startIndex + 1);\\n\\n\\t\\t\\tif (stoi(digit) > 255)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tip.push_back(digit);\\n\\t\\t\\tsplitIP(i + 1, segments - 1, str, ans, ip);\\n\\t\\t\\tip.pop_back();\\n\\n\\t\\t\\tif (str[startIndex] == '0')\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t}\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n    vector<string> restoreIpAddresses(string s) \\n    {\\n    \\tstd::vector<string> ans;\\n    \\tstd::vector<string> v;\\n\\n    \\tsplitIP(0, 4, s, ans, v);\\n\\n    \\treturn ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 31197,
                "title": "accepted-recurssive-python-solution",
                "content": " Function split2intgers need an additional input numDig to denote the number of integer that should separated from the string. At the beginning this number is 4. Then recursively check all possible cases. \\n\\n \\n\\n      class Solution:\\n            # @param s, a string\\n            # @return a list of strings\\n            def split2intgers(self,string,numDig):\\n                res=[]\\n                if numDig==1: \\n                    if len(string)==1 or (len(string)==2 and string[0]>'0') or (len(string)==3 and string[0]>'0' and int(string[0:3])<=255):\\n                        return [string]\\n                    else:\\n                        return []\\n                else:\\n                    if len(string)<numDig:\\n                        return []\\n                    for ii in range(1,min(len(string)-numDig+1,3)+1):\\n                        tmp=string[0:ii]\\n                        if len(tmp)==1 or (len(tmp)==2 and tmp[0]!='0') or (len(tmp)==3 and tmp[0]!='0' and int(tmp[0:3])<=255):\\n                            list=self.split2intgers(string[ii:],numDig-1)\\n                            if list:\\n                                res+=[string[0:ii]+'.'+elem for elem in list]\\n                return res\\n            def restoreIpAddresses(self, s):\\n                #should be seperate into four \\n                res=self.split2intgers(s,4)\\n                return res",
                "solutionTags": [],
                "code": " Function split2intgers need an additional input numDig to denote the number of integer that should separated from the string. At the beginning this number is 4. Then recursively check all possible cases. \\n\\n \\n\\n      class Solution:\\n            # @param s, a string\\n            # @return a list of strings\\n            def split2intgers(self,string,numDig):\\n                res=[]\\n                if numDig==1: \\n                    if len(string)==1 or (len(string)==2 and string[0]>'0') or (len(string)==3 and string[0]>'0' and int(string[0:3])<=255):\\n                        return [string]\\n                    else:\\n                        return []\\n                else:\\n                    if len(string)<numDig:\\n                        return []\\n                    for ii in range(1,min(len(string)-numDig+1,3)+1):\\n                        tmp=string[0:ii]\\n                        if len(tmp)==1 or (len(tmp)==2 and tmp[0]!='0') or (len(tmp)==3 and tmp[0]!='0' and int(tmp[0:3])<=255):\\n                            list=self.split2intgers(string[ii:],numDig-1)\\n                            if list:\\n                                res+=[string[0:ii]+'.'+elem for elem in list]\\n                return res\\n            def restoreIpAddresses(self, s):\\n                #should be seperate into four \\n                res=self.split2intgers(s,4)\\n                return res",
                "codeTag": "Java"
            },
            {
                "id": 3187629,
                "title": "restore-ip-addresses-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s the step by step explanation of the algorithm:\\n\\n1. We define a recursive function restore_ip that takes four arguments: the current index in the string s, the current part number part, the current IP address ip, and the list of valid IP addresses result.\\n2. If we have reached the end of the string s and we have formed four parts in ip, we append ip to result.\\n3. If we have formed less than four parts in ip and there are still characters remaining in s, we try to place a dot after the next one or two digits.\\n4. If we have formed less than four parts in ip and there are at least two digits remaining in s, we try to place a dot after the next two digits.\\n5. If the current part in ip is not valid (i.e., it contains a leading zero or is greater than 255), we stop the recursion for this path.\\n6. If the current part in ip is valid, we recursively call restore_ip with the next index in s, the next part number, and the updated ip.\\n7. After all recursive calls are done, we return the list of valid IP addresses result.\\n\\n# Complexity\\n- Time complexity:\\n86.7%\\n\\n- Space complexity:\\n98.84%\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        result = []\\n        self.restore_ip(s, 0, 0, [], result)\\n        return result\\n    \\n    def restore_ip(self, s, index, part, ip, result):\\n        if index == len(s) and part == 4:\\n            result.append(\\'.\\'.join(ip))\\n        elif part < 4 and index < len(s):\\n            # try placing a dot after the next digit\\n            ip.append(s[index])\\n            self.restore_ip(s, index + 1, part + 1, ip, result)\\n            ip.pop()\\n            \\n            # try placing a dot after the next two digits\\n            if index + 1 < len(s) and s[index] != \\'0\\':\\n                ip.append(s[index:index + 2])\\n                self.restore_ip(s, index + 2, part + 1, ip, result)\\n                ip.pop()\\n                \\n            # try placing a dot after the next three digits\\n            if index + 2 < len(s) and s[index] != \\'0\\' and int(s[index:index + 3]) <= 255:\\n                ip.append(s[index:index + 3])\\n                self.restore_ip(s, index + 3, part + 1, ip, result)\\n                ip.pop()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        result = []\\n        self.restore_ip(s, 0, 0, [], result)\\n        return result\\n    \\n    def restore_ip(self, s, index, part, ip, result):\\n        if index == len(s) and part == 4:\\n            result.append(\\'.\\'.join(ip))\\n        elif part < 4 and index < len(s):\\n            # try placing a dot after the next digit\\n            ip.append(s[index])\\n            self.restore_ip(s, index + 1, part + 1, ip, result)\\n            ip.pop()\\n            \\n            # try placing a dot after the next two digits\\n            if index + 1 < len(s) and s[index] != \\'0\\':\\n                ip.append(s[index:index + 2])\\n                self.restore_ip(s, index + 2, part + 1, ip, result)\\n                ip.pop()\\n                \\n            # try placing a dot after the next three digits\\n            if index + 2 < len(s) and s[index] != \\'0\\' and int(s[index:index + 3]) <= 255:\\n                ip.append(s[index:index + 3])\\n                self.restore_ip(s, index + 3, part + 1, ip, result)\\n                ip.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089341,
                "title": "python-simple-dfs-28-ms-faster-than-96-21",
                "content": "https://leetcode.com/submissions/detail/883564385/  \\nRuntime: **28 ms**, faster than 96.21% of Python3 online submissions for Restore IP Addresses.  \\nMemory Usage: 13.9 MB, less than 28.27% of Python3 online submissions for Restore IP Addresses.   \\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        l, lst, ips = len(s), [([], 0)], []\\n        while lst: ## dfs\\n            ip, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                segment = s[i:j]\\n                if int(segment)>255: \\n                    break\\n                if j==l: ## reach the end\\n                    if len(ip)==3:\\n                        ips.append(ip+[segment])\\n                    break\\n                lst.append((ip+[segment], j))\\n                if segment==\\'0\\': ## e.g. segment \\'01\\' is not valid\\n                    break\\n        return [\\'.\\'.join(ip) for ip in ips]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        l, lst, ips = len(s), [([], 0)], []\\n        while lst: ## dfs\\n            ip, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                segment = s[i:j]\\n                if int(segment)>255: \\n                    break\\n                if j==l: ## reach the end\\n                    if len(ip)==3:\\n                        ips.append(ip+[segment])\\n                    break\\n                lst.append((ip+[segment], j))\\n                if segment==\\'0\\': ## e.g. segment \\'01\\' is not valid\\n                    break\\n        return [\\'.\\'.join(ip) for ip in ips]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081448,
                "title": "easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<string> result;\\n    // check validity of the string i.e. str should not start with 0 and should be in range of 0-255\\n    bool isValid(string str) {\\n        if(str[0] == \\'0\\')\\n            return false;\\n            \\n        //convert string to integer\\n        int val = stoi(str);\\n        \\n        return val <= 255;\\n    }\\n    // recursive function for generating ip address\\n    void solve(string& s, int idx, int part, string curr) {\\n        //valid ip is only possible when all the char of string is consumed and it has only 4 parts\\n        if(idx == n && part == 4) {\\n            result.push_back(curr.substr(0, curr.length()-1));\\n            return;\\n        }\\n        // if we consider 1 substr then the index range must be valid\\n        if(idx+1 <= n)\\n            solve(s, idx+1, part+1, curr + s.substr(idx, 1) + \".\");\\n        // if we choose 2 or 3 substr then the index and the str must have validity check\\n        if(idx+2 <= n && isValid(s.substr(idx, 2))) {\\n            solve(s, idx+2, part+1, curr + s.substr(idx, 2) + \".\");\\n        }\\n        \\n        if(idx+3 <= n && isValid(s.substr(idx, 3))) {\\n            solve(s, idx+3, part+1, curr + s.substr(idx, 3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        result.clear();\\n        \\n        n = s.length();\\n        // we cannot divide into 4 parts in which length is greater than 12\\n        if(n > 12)\\n          return result;\\n      \\n        int part = 0;\\n        string curr = \"\";\\n        \\n        solve(s, 0, part, curr);\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<string> result;\\n    // check validity of the string i.e. str should not start with 0 and should be in range of 0-255\\n    bool isValid(string str) {\\n        if(str[0] == \\'0\\')\\n            return false;\\n            \\n        //convert string to integer\\n        int val = stoi(str);\\n        \\n        return val <= 255;\\n    }\\n    // recursive function for generating ip address\\n    void solve(string& s, int idx, int part, string curr) {\\n        //valid ip is only possible when all the char of string is consumed and it has only 4 parts\\n        if(idx == n && part == 4) {\\n            result.push_back(curr.substr(0, curr.length()-1));\\n            return;\\n        }\\n        // if we consider 1 substr then the index range must be valid\\n        if(idx+1 <= n)\\n            solve(s, idx+1, part+1, curr + s.substr(idx, 1) + \".\");\\n        // if we choose 2 or 3 substr then the index and the str must have validity check\\n        if(idx+2 <= n && isValid(s.substr(idx, 2))) {\\n            solve(s, idx+2, part+1, curr + s.substr(idx, 2) + \".\");\\n        }\\n        \\n        if(idx+3 <= n && isValid(s.substr(idx, 3))) {\\n            solve(s, idx+3, part+1, curr + s.substr(idx, 3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        result.clear();\\n        \\n        n = s.length();\\n        // we cannot divide into 4 parts in which length is greater than 12\\n        if(n > 12)\\n          return result;\\n      \\n        int part = 0;\\n        string curr = \"\";\\n        \\n        solve(s, 0, part, curr);\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081237,
                "title": "java-recursive-solution-o-m-n-n",
                "content": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        int n = s.length();\\n        if (n > 12) return res;\\n\\n        int parts = 0;\\n        String curr = \"\";\\n        f(s, 0, parts, n, curr, res);\\n        return res;\\n    }\\n\\n    private static void f(String s, int idx, int parts, int n, String curr, List<String> res) {\\n        if (idx == n && parts == 4) {\\n            res.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n\\n        if (idx + 1 <= n)\\n            f(s, idx + 1, parts + 1, n, curr + s.substring(idx, idx + 1) + \".\", res);\\n\\n        if (idx + 2 <= n && isValid(s.substring(idx, idx + 2)))\\n            f(s, idx + 2, parts + 1, n, curr + s.substring(idx, idx + 2) + \".\", res);\\n\\n        if (idx + 3 <= n && isValid(s.substring(idx, idx + 3)))\\n            f(s, idx + 3, parts + 1, n, curr + s.substring(idx, idx + 3) + \".\", res);\\n\\n    }\\n\\n    private static boolean isValid(String s) {\\n        if (s.charAt(0) == \\'0\\') return false;\\n        int val = Integer.parseInt(s);\\n        return val <= 255;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        int n = s.length();\\n        if (n > 12) return res;\\n\\n        int parts = 0;\\n        String curr = \"\";\\n        f(s, 0, parts, n, curr, res);\\n        return res;\\n    }\\n\\n    private static void f(String s, int idx, int parts, int n, String curr, List<String> res) {\\n        if (idx == n && parts == 4) {\\n            res.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n\\n        if (idx + 1 <= n)\\n            f(s, idx + 1, parts + 1, n, curr + s.substring(idx, idx + 1) + \".\", res);\\n\\n        if (idx + 2 <= n && isValid(s.substring(idx, idx + 2)))\\n            f(s, idx + 2, parts + 1, n, curr + s.substring(idx, idx + 2) + \".\", res);\\n\\n        if (idx + 3 <= n && isValid(s.substring(idx, idx + 3)))\\n            f(s, idx + 3, parts + 1, n, curr + s.substring(idx, idx + 3) + \".\", res);\\n\\n    }\\n\\n    private static boolean isValid(String s) {\\n        if (s.charAt(0) == \\'0\\') return false;\\n        int val = Integer.parseInt(s);\\n        return val <= 255;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080583,
                "title": "java-backtracking-string",
                "content": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s == null || s.length() < 4 || s.length() > 12) {\\n            // return empty list if input is null or not in the correct length range\\n            return new ArrayList<>();\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder(s);\\n        dfs(sb, 0, 3, ans);\\n\\n        return ans;\\n    }\\n\\n    \\n    private void dfs(StringBuilder sb, int index, int dotCount, List<String> ans) {\\n        if (dotCount == 0) {\\n            // base case, if all dots have been added, check if the IP address is valid\\n            if (isValid(sb)) {\\n                ans.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        if (index >= sb.length()) {\\n            return;\\n        }\\n\\n        //backtracking\\n        \\n        sb.insert(index, \".\");\\n        dfs(sb, index + 2, dotCount - 1, ans);\\n        sb.deleteCharAt(index);\\n\\n        dfs(sb, index + 1, dotCount, ans);\\n    }\\n\\n    \\n    private boolean isValid(StringBuilder sb) {\\n        String[] parts = sb.toString().split(\"\\\\\\\\.\");\\n        if (parts.length != 4) {\\n            return false;\\n        }\\n\\n        for (String part : parts) {\\n            if (part.length() == 0 || part.length() > 3) {\\n                return false;\\n            }\\n\\n            if (part.startsWith(\"0\") && part.length() > 1) {\\n                return false;\\n            }\\n\\n            int num = Integer.parseInt(part);\\n            if (num > 255) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**Do UpVote**",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s == null || s.length() < 4 || s.length() > 12) {\\n            // return empty list if input is null or not in the correct length range\\n            return new ArrayList<>();\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder(s);\\n        dfs(sb, 0, 3, ans);\\n\\n        return ans;\\n    }\\n\\n    \\n    private void dfs(StringBuilder sb, int index, int dotCount, List<String> ans) {\\n        if (dotCount == 0) {\\n            // base case, if all dots have been added, check if the IP address is valid\\n            if (isValid(sb)) {\\n                ans.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        if (index >= sb.length()) {\\n            return;\\n        }\\n\\n        //backtracking\\n        \\n        sb.insert(index, \".\");\\n        dfs(sb, index + 2, dotCount - 1, ans);\\n        sb.deleteCharAt(index);\\n\\n        dfs(sb, index + 1, dotCount, ans);\\n    }\\n\\n    \\n    private boolean isValid(StringBuilder sb) {\\n        String[] parts = sb.toString().split(\"\\\\\\\\.\");\\n        if (parts.length != 4) {\\n            return false;\\n        }\\n\\n        for (String part : parts) {\\n            if (part.length() == 0 || part.length() > 3) {\\n                return false;\\n            }\\n\\n            if (part.startsWith(\"0\") && part.length() > 1) {\\n                return false;\\n            }\\n\\n            int num = Integer.parseInt(part);\\n            if (num > 255) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080525,
                "title": "java-recursive-code-with-explanation-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/4a164322-63c2-49e7-8692-78beb8580285_1674290937.229729.png)\\n\\n\\n\\uD83D\\uDC4D\\uD83D\\uDE0A**Upvote**\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        \\n        List<String> ans = new ArrayList<String>(); // for returing the ans list\\n        List<String> ls = new ArrayList<String>(); // for calculating IP address of exactly with 4 dots\\n\\n        allValidAddress(ans, ls, s);\\n\\n        return ans;\\n\\n    }\\n\\n    public void allValidAddress(List<String> ans, List<String> ls, String s)\\n    {\\n        int n = s.length();\\n\\n        if(ls.size() >= 4 && n != 0) // if ls length is 4 but our s string length is not equal to 0 means to valid IP.\\n        {\\n            return; // returning from recurive call\\n        }\\n\\n        if(n == 0) // if n == 0 \\n        {\\n            if(ls.size() == 4) // if ls list size is 4 so we can say we genrated a valid IP address with 4 dots\\n            {\\n                StringBuilder sb = new StringBuilder();\\n\\n                for(int i = 0; i < ls.size(); i++)\\n                {\\n                    if(i == 0)\\n                    {\\n                        sb.append(ls.get(i));\\n                    }\\n                    else\\n                    {\\n                        sb.append(\".\" + ls.get(i));\\n                    }\\n                }\\n                ans.add(sb.toString()); // adding IP address in ans list\\n            }\\n            return; // returning from the recursive call\\n        }\\n\\n        for(int i = 0; i < 3 && i < n; i++) // every time taking a string less than or equal to 3 size from s string\\n        {\\n            String tem = s.substring(0, i + 1); // taking tem string from 0 to i.\\n\\n            if(tem.length() > 1 && tem.charAt(0) == \\'0\\') //cheking leading zeros if tem contains the leading zeors.\\n            {    \\n                return; // returning from recursive call\\n            }\\n\\n            int x = Integer.parseInt(tem); // converting tem to int\\n\\n            if(x <= 255) // if x <= 255\\n            {\\n                ls.add(tem); // adding tem is ls\\n\\n                allValidAddress(ans, ls, s.substring(i + 1)); // doing recursive call for next substring from i to n.\\n\\n                ls.remove(ls.size() - 1); \\n        // if any condition becomes true for not a valid IP so during backtracking we have to undo all changes we made\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        \\n        List<String> ans = new ArrayList<String>(); // for returing the ans list\\n        List<String> ls = new ArrayList<String>(); // for calculating IP address of exactly with 4 dots\\n\\n        allValidAddress(ans, ls, s);\\n\\n        return ans;\\n\\n    }\\n\\n    public void allValidAddress(List<String> ans, List<String> ls, String s)\\n    {\\n        int n = s.length();\\n\\n        if(ls.size() >= 4 && n != 0) // if ls length is 4 but our s string length is not equal to 0 means to valid IP.\\n        {\\n            return; // returning from recurive call\\n        }\\n\\n        if(n == 0) // if n == 0 \\n        {\\n            if(ls.size() == 4) // if ls list size is 4 so we can say we genrated a valid IP address with 4 dots\\n            {\\n                StringBuilder sb = new StringBuilder();\\n\\n                for(int i = 0; i < ls.size(); i++)\\n                {\\n                    if(i == 0)\\n                    {\\n                        sb.append(ls.get(i));\\n                    }\\n                    else\\n                    {\\n                        sb.append(\".\" + ls.get(i));\\n                    }\\n                }\\n                ans.add(sb.toString()); // adding IP address in ans list\\n            }\\n            return; // returning from the recursive call\\n        }\\n\\n        for(int i = 0; i < 3 && i < n; i++) // every time taking a string less than or equal to 3 size from s string\\n        {\\n            String tem = s.substring(0, i + 1); // taking tem string from 0 to i.\\n\\n            if(tem.length() > 1 && tem.charAt(0) == \\'0\\') //cheking leading zeros if tem contains the leading zeors.\\n            {    \\n                return; // returning from recursive call\\n            }\\n\\n            int x = Integer.parseInt(tem); // converting tem to int\\n\\n            if(x <= 255) // if x <= 255\\n            {\\n                ls.add(tem); // adding tem is ls\\n\\n                allValidAddress(ans, ls, s.substring(i + 1)); // doing recursive call for next substring from i to n.\\n\\n                ls.remove(ls.size() - 1); \\n        // if any condition becomes true for not a valid IP so during backtracking we have to undo all changes we made\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080389,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(string temp) {\\n        if(temp.size() > 3 or temp.size() == 0) return false;\\n        if(temp.size() > 1 and temp[0] == \\'0\\')   return false;\\n        if(temp.size() && stoi(temp) > 255) return false;\\n        return true;\\n    }\\n\\n    void solve(vector<string>& ans, string output, string s, int id, int dots) {\\n        if(dots == 3){\\n            if(valid(s.substr(id))) ans.push_back(output + s.substr(id));\\n            return;\\n        }\\n        for(int i=id; i<s.size(); i++) {\\n            if(valid(s.substr(id, i - id + 1))) {\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, s, i + 1, dots + 1);\\n                output.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(ans, \"\", s, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(string temp) {\\n        if(temp.size() > 3 or temp.size() == 0) return false;\\n        if(temp.size() > 1 and temp[0] == \\'0\\')   return false;\\n        if(temp.size() && stoi(temp) > 255) return false;\\n        return true;\\n    }\\n\\n    void solve(vector<string>& ans, string output, string s, int id, int dots) {\\n        if(dots == 3){\\n            if(valid(s.substr(id))) ans.push_back(output + s.substr(id));\\n            return;\\n        }\\n        for(int i=id; i<s.size(); i++) {\\n            if(valid(s.substr(id, i - id + 1))) {\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, s, i + 1, dots + 1);\\n                output.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(ans, \"\", s, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080342,
                "title": "100-0ms-beat-me-dfs-backtracking-beats-100-proof-concise-2ways",
                "content": "# UPVOTE PLS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/a10949e5-6062-412e-bde4-9f013bc3b35f_1674287824.969369.png)\\n\\n# Complexity\\n- Time complexity: o(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>  ans =new ArrayList<>();\\n        int L=s.length();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.toCharArray(),new StringBuilder(),0,0,ans);\\n        return ans;\\n    }\\n    private void dfs(char s[],StringBuilder sec,int level,int cnt,List<String>  ans){\\n        if(level>4) return;\\n        int num=0,L=sec.length();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==s.length+4)ans.add(sec.substring(0,L-1).toString());\\n            return;\\n        }\\n        for(int i=cnt;i<s.length && i<=cnt+2;i++){\\n            num = num*10+(int)(s[i]-\\'0\\');\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(num).append(\".\"),level+1,i+1,ans);\\n            sec.setLength(L);\\n        } }\\n```\\n```\\npublic List<String> restoreIpAddresses(String s) { //2nd \\n        List<String>  ans =new ArrayList<>();\\n         int L=s.length();\\n         if(L<4 ||L>12) return ans;\\n         dfs(s,ans,\"\",0);\\n         return ans;\\n    }\\n     private void dfs(String s,List<String>  ans, String res,int cnt){\\n         if(cnt==4){\\n             if(s.isEmpty()) ans.add(res);\\n            return;\\n         }\\n         for(int i=1;i<=Math.min(3,s.length());i++){\\n             String sec=s.substring(0,i);\\n             if(sec.length()>1 && sec.charAt(0)==\\'0\\' || Integer.parseInt(sec)>255) continue;\\n             dfs(s.substring(i),ans,res+sec+(cnt<3?\".\":\"\"),cnt+1);\\n         } }\\n```\\n\\n# c++\\n```\\nvector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        int L=s.size();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.c_str(),\"\",0,0,ans);\\n        return ans;\\n    } \\n    void dfs(const char* s,string sec,int level,int cnt,vector<string> ans){\\n        if(level>4) return;\\n        int num=0,L=sec.size();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==strlen(s)+4)ans.push_back(sec.substr(0,L-1));\\n            return;\\n        }\\n        for(int i=cnt;i<strlen(s) && i<=cnt+2;i++){\\n            num = num*10+(int(s[i]-\\'0\\'));\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(std::to_string(num)).append(\".\"),level+1,i+1,ans);\\n        } }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>  ans =new ArrayList<>();\\n        int L=s.length();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.toCharArray(),new StringBuilder(),0,0,ans);\\n        return ans;\\n    }\\n    private void dfs(char s[],StringBuilder sec,int level,int cnt,List<String>  ans){\\n        if(level>4) return;\\n        int num=0,L=sec.length();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==s.length+4)ans.add(sec.substring(0,L-1).toString());\\n            return;\\n        }\\n        for(int i=cnt;i<s.length && i<=cnt+2;i++){\\n            num = num*10+(int)(s[i]-\\'0\\');\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(num).append(\".\"),level+1,i+1,ans);\\n            sec.setLength(L);\\n        } }\\n```\n```\\npublic List<String> restoreIpAddresses(String s) { //2nd \\n        List<String>  ans =new ArrayList<>();\\n         int L=s.length();\\n         if(L<4 ||L>12) return ans;\\n         dfs(s,ans,\"\",0);\\n         return ans;\\n    }\\n     private void dfs(String s,List<String>  ans, String res,int cnt){\\n         if(cnt==4){\\n             if(s.isEmpty()) ans.add(res);\\n            return;\\n         }\\n         for(int i=1;i<=Math.min(3,s.length());i++){\\n             String sec=s.substring(0,i);\\n             if(sec.length()>1 && sec.charAt(0)==\\'0\\' || Integer.parseInt(sec)>255) continue;\\n             dfs(s.substring(i),ans,res+sec+(cnt<3?\".\":\"\"),cnt+1);\\n         } }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080071,
                "title": "the-o-1-solution-and-backtracking-detailed-explanation",
                "content": "# Intuition\\nIP addresses are in the format of four octets, where each octet is a number between 0 and 255.\\nThe task is to find all possible ways of dividing a given string into four segments, such that each segment represents a valid octet in an IP address. The algorithm checks all possible combinations of dividing the string into four segments and checks if each segment represents a valid octet, if so it constructs a valid IP address and adds it to the result list.\\n\\n# Approach\\n1. Initialize an empty list called ***result*** to store the valid IP addresses.\\n2. Check if the length of the input string is less than 4 or greater than 12. If so, return the empty ***result*** list.\\n3. Use four nested for-loops to iterate through all possible combinations of the length of each segment of the IP address.\\n4. For each iteration, create a new StringBuilder object called ***ip*** to construct the current candidate IP address.\\n5. Use the substring() method to extract the individual segments from the input string, convert them to integers using the Integer.valueOf() method.\\n6. Check if each of the segments is less than or equal to 255, which is a requirement for valid IP addresses.\\n7. If all segments are valid, append them to the ***ip*** StringBuilder object, separated by periods.\\n8. Check if the length of the constructed IP address is equal to the length of the input string plus three (to account for the three periods added), and if so, add it to the ***result*** list.\\n9. Return the ***result*** list at the end of the method.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is **O(1)**, it is a constant time complexity because the number of iterations is fixed and does not depend on the size of the input. The outer for-loop runs four times, and each inner for-loop runs three times, so the total number of iterations is  81.\\n\\n- Space complexity:\\nThe space complexity of this code is O(n), where n is the number of valid IP addresses found. This is because the algorithm creates a new StringBuilder object for each valid IP address and adds it to the result list, so the maximum space needed is proportional to the number of valid IP addresses. However, this space usage can be considered as low as the number of valid IP addresses cannot be more than 3^4 = 81.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        if(s.length() < 4 || s.length() > 12){\\n            return result;\\n        }\\n        for(int i = 1; i <= 3; i++){\\n            for(int j = 1; j <= 3; j++){\\n                for(int k = 1; k <= 3; k++){\\n                    for (int l = 1; l <= 3; l++){\\n                        if(i + j + k + l == s.length()){\\n                            StringBuilder ip = new StringBuilder();\\n                            int n1 = Integer.valueOf(s.substring(0, i));\\n                            int n2 = Integer.valueOf(s.substring(i, i + j));\\n                            int n3 = Integer.valueOf(s.substring(i + j, i + j + k));\\n                            int n4 = Integer.valueOf(s.substring(i + j + k, i + j + k + l));\\n                            if(n1 <= 255 && n2 <= 255 && n3 <= 255 && n4 <= 255){\\n                                ip.append(n1).append(\\'.\\').append(n2).append(\\'.\\').append(n3).append(\\'.\\').append(n4);\\n                            }\\n                            if(ip.toString().length() == s.length() + 3){\\n                                result.add(ip.toString());\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n## Backtracking Approach\\n1. Create a method called \"backtrack()\" which takes four parameters: the input string, the current starting index of the next segment, a list to store the current candidate IP address, and the final result list.\\n2. Inside backtrack() method, check if the current candidate IP address has four segments. If it does, check if all characters of the input string have been used.\\n3. If all characters have been used, add the candidate IP address to the result list.\\n4. If the current candidate IP address does not have four segments, use a for-loop to iterate through all possible combinations of the next segment, from the current starting index to a maximum of three characters.\\n5. For each iteration, extract the segment using substring() method and check if it is a valid segment (i.e. less than or equal to 255 and not starting with a \"0\" if its length is greater than 1).\\n6. If the segment is valid, add it to the candidate IP address and call the backtrack() method recursively with the updated parameters.\\n7. Remove the last segment from the candidate IP address and continue with the next iteration.\\n8. Return the result list at the end of the method.\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        backtrack(s, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(String s, int start, List<String> ip, List<String> result) {\\n        if (ip.size() == 4) {\\n            if (start == s.length()) {\\n                result.add(String.join(\".\", ip));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String segment = s.substring(start, i + 1);\\n            if (segment.startsWith(\"0\") && segment.length() > 1 || Integer.parseInt(segment) > 255) {\\n                continue;\\n            }\\n            ip.add(segment);\\n            backtrack(s, i + 1, ip, result);\\n            ip.remove(ip.size() - 1);\\n        }\\n    }\\n}\\n```\\n> I understand that this can be improved further, but this is my current understanding of the problem. I will work on providing a more effective solution with an explanation.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        if(s.length() < 4 || s.length() > 12){\\n            return result;\\n        }\\n        for(int i = 1; i <= 3; i++){\\n            for(int j = 1; j <= 3; j++){\\n                for(int k = 1; k <= 3; k++){\\n                    for (int l = 1; l <= 3; l++){\\n                        if(i + j + k + l == s.length()){\\n                            StringBuilder ip = new StringBuilder();\\n                            int n1 = Integer.valueOf(s.substring(0, i));\\n                            int n2 = Integer.valueOf(s.substring(i, i + j));\\n                            int n3 = Integer.valueOf(s.substring(i + j, i + j + k));\\n                            int n4 = Integer.valueOf(s.substring(i + j + k, i + j + k + l));\\n                            if(n1 <= 255 && n2 <= 255 && n3 <= 255 && n4 <= 255){\\n                                ip.append(n1).append(\\'.\\').append(n2).append(\\'.\\').append(n3).append(\\'.\\').append(n4);\\n                            }\\n                            if(ip.toString().length() == s.length() + 3){\\n                                result.add(ip.toString());\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        backtrack(s, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(String s, int start, List<String> ip, List<String> result) {\\n        if (ip.size() == 4) {\\n            if (start == s.length()) {\\n                result.add(String.join(\".\", ip));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String segment = s.substring(start, i + 1);\\n            if (segment.startsWith(\"0\") && segment.length() > 1 || Integer.parseInt(segment) > 255) {\\n                continue;\\n            }\\n            ip.add(segment);\\n            backtrack(s, i + 1, ip, result);\\n            ip.remove(ip.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080042,
                "title": "simple-java-beginners-helpful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        backtrack(s, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> temp, List<String> res) {\\n        if (temp.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(String.join(\".\", temp));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String sub = s.substring(start, i + 1);\\n            if (isValid(sub)) {\\n                temp.add(sub);\\n                backtrack(s, i + 1, temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        return num >= 0 && num <= 255;\\n    }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        backtrack(s, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> temp, List<String> res) {\\n        if (temp.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(String.join(\".\", temp));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String sub = s.substring(start, i + 1);\\n            if (isValid(sub)) {\\n                temp.add(sub);\\n                backtrack(s, i + 1, temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        return num >= 0 && num <= 255;\\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080018,
                "title": "c-easy-solution-without-recursion",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    #define ll long long int\\n    bool isValidIP(string & str)\\n    {\\n\\n        if (str.length() > 3)\\n\\n            return false;\\n\\n        if (str.front() == \\'0\\' and str.length() > 1) //leading zeros\\n\\n            return false;\\n\\n        ll val = stoll(str);\\n\\n        return val >= 0 and val <= 255;\\n    }\\n\\n    vector<string> restoreIpAddresses(string str)\\n    {\\n        vector<string> res;\\n        for (ll i = 1; i <= 3 and i < str.length(); i++)\\n\\n        {\\n\\n            string first = str.substr(0, i);\\n\\n            if (isValidIP(first))\\n\\n            {\\n\\n                for (ll j = 1; j <= 3 and i + j < str.length(); j++)\\n\\n                {\\n\\n                    string second = str.substr(i, j);\\n\\n                    if (isValidIP(second))\\n\\n                    {\\n\\n                        for (ll k = 1; k <= 3 and i + j + k < str.length(); k++)\\n\\n                        {\\n\\n                            string third = str.substr(i + j, k);\\n\\n                            string fourth = str.substr(i + j + k);\\n\\n                            if (isValidIP(third) and isValidIP(fourth))\\n\\n                            {\\n\\n                                res.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    #define ll long long int\\n    bool isValidIP(string & str)\\n    {\\n\\n        if (str.length() > 3)\\n\\n            return false;\\n\\n        if (str.front() == \\'0\\' and str.length() > 1) //leading zeros\\n\\n            return false;\\n\\n        ll val = stoll(str);\\n\\n        return val >= 0 and val <= 255;\\n    }\\n\\n    vector<string> restoreIpAddresses(string str)\\n    {\\n        vector<string> res;\\n        for (ll i = 1; i <= 3 and i < str.length(); i++)\\n\\n        {\\n\\n            string first = str.substr(0, i);\\n\\n            if (isValidIP(first))\\n\\n            {\\n\\n                for (ll j = 1; j <= 3 and i + j < str.length(); j++)\\n\\n                {\\n\\n                    string second = str.substr(i, j);\\n\\n                    if (isValidIP(second))\\n\\n                    {\\n\\n                        for (ll k = 1; k <= 3 and i + j + k < str.length(); k++)\\n\\n                        {\\n\\n                            string third = str.substr(i + j, k);\\n\\n                            string fourth = str.substr(i + j + k);\\n\\n                            if (isValidIP(third) and isValidIP(fourth))\\n\\n                            {\\n\\n                                res.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079727,
                "title": "c-100-faster-solution-dfs",
                "content": "C++ 100% faster solution \\n\\nThe code is commented and so it is self explanatory approach\\n\\nThe idea used here is to try to form all possible combinations with DFS\\n\\n```\\nclass Solution {\\n    \\n    void util(string &s,vector<string> &ans,string curr,int ind,int curr_sec_count)\\n    {\\n        if(curr_sec_count == 4 && (s.length() == ind))//if we have found all the sections and reached the end\\n        {\\n            ans.push_back(curr);//add it to result\\n            return;//ans return\\n        }   \\n        if((s.length()-ind) > 3*(4-curr_sec_count) || ind >= s.length())\\n        return; // to check if remaining can even form valid ip\\n        \\n        //explore all possible lengths of sections\\n        for(int i=1;i<=3;i++)\\n        {\\n            string curr_sec = s.substr(ind,i);//we make the partition\\n            \\n            if((curr_sec.length()>1 && curr_sec[0]==\\'0\\')|| stoi(curr_sec)>255)//if conditions of a section\\n               continue;//are not satisfied we continue\\n            \\n            //make curr section ip by adding \\'.\\' at appropriate positions\\n            string temp = curr_sec_count == 0 ? curr_sec : (curr + \".\" + curr_sec);\\n            \\n            //call to further check the results\\n            util(s,ans,temp,ind+i,curr_sec_count+1);\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;//to store the result\\n        //call utility function \\n        util(s,ans,\"\",0,0);\\n        //return the result\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void util(string &s,vector<string> &ans,string curr,int ind,int curr_sec_count)\\n    {\\n        if(curr_sec_count == 4 && (s.length() == ind))//if we have found all the sections and reached the end\\n        {\\n            ans.push_back(curr);//add it to result\\n            return;//ans return\\n        }   \\n        if((s.length()-ind) > 3*(4-curr_sec_count) || ind >= s.length())\\n        return; // to check if remaining can even form valid ip\\n        \\n        //explore all possible lengths of sections\\n        for(int i=1;i<=3;i++)\\n        {\\n            string curr_sec = s.substr(ind,i);//we make the partition\\n            \\n            if((curr_sec.length()>1 && curr_sec[0]==\\'0\\')|| stoi(curr_sec)>255)//if conditions of a section\\n               continue;//are not satisfied we continue\\n            \\n            //make curr section ip by adding \\'.\\' at appropriate positions\\n            string temp = curr_sec_count == 0 ? curr_sec : (curr + \".\" + curr_sec);\\n            \\n            //call to further check the results\\n            util(s,ans,temp,ind+i,curr_sec_count+1);\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;//to store the result\\n        //call utility function \\n        util(s,ans,\"\",0,0);\\n        //return the result\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079608,
                "title": "java-solution-beats-93-2ms-runtime-explained-with-comments-2-methods",
                "content": "#### Approach 1--> Using String and StringBuilder (6ms runtime Faster than 60%)\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>(); //result list\\n        restore(s,0,res,\"\",0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,String t,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(t); //adding restoredIp to result\\n\\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx)); \\n           //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                if(idx==s.length()-1)\\n                    restore(s,idx+1,res,t+temp.toString(),dots); //dot should not be inserted at last\\n                else\\n                    restore(s,idx+1,res,t+temp.toString()+\\'.\\',dots+1); \\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n       //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\')\\n           return false;\\n       //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;\\n    }\\n}\\n```\\n### Optimization of above code using List<String>\\n#### Approach 2--> Using StringBuilder & List<String>(Converting it to String) (2ms runtime and Faster than 93%)\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();  //result list\\n        restore(s,0,res,new ArrayList<String>(),0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,ArrayList<String> list,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(buildString(list)); //adding restoredIp to result\\n        \\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx));\\n            //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                list.add(temp.toString()); //adding valid string to list\\n                if(idx==s.length()-1) //dot should not be inserted at last\\n                    restore(s,idx+1,res,list,dots);\\n                else{\\n                    list.add(\".\"); //adding dot to list\\n                    restore(s,idx+1,res,list,dots+1);//incrementing the count of dots\\n                    list.remove(list.size()-1);  //removing dot from list\\n                }\\n                list.remove(list.size()-1); //removing valid string from list\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n        //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\') \\n           return false;\\n        //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;  //else condition\\n    }\\n    \\n    //building string from ArrayList<String> using StringBuilder\\n    private String buildString(ArrayList<String> list){\\n        StringBuilder sb = new StringBuilder();\\n        for(String s:list)\\n             sb.append(s);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>(); //result list\\n        restore(s,0,res,\"\",0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,String t,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(t); //adding restoredIp to result\\n\\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx)); \\n           //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                if(idx==s.length()-1)\\n                    restore(s,idx+1,res,t+temp.toString(),dots); //dot should not be inserted at last\\n                else\\n                    restore(s,idx+1,res,t+temp.toString()+\\'.\\',dots+1); \\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n       //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\')\\n           return false;\\n       //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();  //result list\\n        restore(s,0,res,new ArrayList<String>(),0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,ArrayList<String> list,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(buildString(list)); //adding restoredIp to result\\n        \\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx));\\n            //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                list.add(temp.toString()); //adding valid string to list\\n                if(idx==s.length()-1) //dot should not be inserted at last\\n                    restore(s,idx+1,res,list,dots);\\n                else{\\n                    list.add(\".\"); //adding dot to list\\n                    restore(s,idx+1,res,list,dots+1);//incrementing the count of dots\\n                    list.remove(list.size()-1);  //removing dot from list\\n                }\\n                list.remove(list.size()-1); //removing valid string from list\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n        //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\') \\n           return false;\\n        //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;  //else condition\\n    }\\n    \\n    //building string from ArrayList<String> using StringBuilder\\n    private String buildString(ArrayList<String> list){\\n        StringBuilder sb = new StringBuilder();\\n        for(String s:list)\\n             sb.append(s);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079562,
                "title": "c-backtracking-super-easy-code-with-comments",
                "content": "# Upvote Please!    \\n\\t// Function to check     \\n\\tint check(string &ds, int pdot){\\n\\n        string sub = string(ds.begin() + pdot,ds.end());\\n        \\n        if(sub[0] == \\'0\\' && sub.size()>1) return 0;\\n\\n        int no = stoi(sub);\\n        \\n        if(no>255) return 0;\\n        \\n        return 1;\\n    }\\n    \\n\\t// recursive function that does all the work\\n    void solve(string &s, string ds, vector<string>&ans,int i,int pdot,int dcount){\\n        \\n\\t\\t// if every thing setisfy push the ds in the answer\\n        if(i == s.size()){\\n            if(check(ds,pdot) && dcount == 3) ans.push_back(ds);\\n            return ;\\n        }\\n        \\n\\t\\t// push the string ith element in the ds.\\n        ds.push_back(s[i]); \\n        \\n\\t\\t// now check if it was a right decision pushing the element in the ds\\n\\t\\t// -> If the decision was right then lets move to the next element of the string without adding \" . \" in the ds.\\n        if(check(ds,pdot)) solve(s,ds,ans,i+1,pdot,dcount);\\n        \\n\\t\\t\\n\\t\\t// lets add \" . \" in the ds.\\n\\t\\t// min there should be 1 element to add a \" . \" \\n\\t\\t// also not more that 3 dot should be there so 2 already present and one inside the block.\\n        if(ds.size() - pdot >1 && dcount <=2)\\n        {\\n            int size = ds.size()-1;\\n            ds[size] = \\'.\\';\\n\\t\\t\\t\\n\\t\\t\\t// add \" . \" at the end of the ds and update pdot i.e position of dot.\\n\\t\\t\\t// dcount is to track how many dot have been inserted.\\n            solve(s,ds,ans,i,size+1,++dcount);\\n        }\\n\\n        \\n        \\n    }\\n\\t\\n\\t// code starts from here\\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string ds;  \\n        vector<string>ans;  // if ds is a possible answer it will be inserted here.\\n        \\n        solve(s,ds,ans,0,0,0);\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "# Upvote Please!    \\n\\t// Function to check     \\n\\tint check(string &ds, int pdot){\\n\\n        string sub = string(ds.begin() + pdot,ds.end());\\n        \\n        if(sub[0] == \\'0\\' && sub.size()>1) return 0;\\n\\n        int no = stoi(sub);\\n        \\n        if(no>255) return 0;\\n        \\n        return 1;\\n    }\\n    \\n\\t// recursive function that does all the work\\n    void solve(string &s, string ds, vector<string>&ans,int i,int pdot,int dcount){\\n        \\n\\t\\t// if every thing setisfy push the ds in the answer\\n        if(i == s.size()){\\n            if(check(ds,pdot) && dcount == 3) ans.push_back(ds);\\n            return ;\\n        }\\n        \\n\\t\\t// push the string ith element in the ds.\\n        ds.push_back(s[i]); \\n        \\n\\t\\t// now check if it was a right decision pushing the element in the ds\\n\\t\\t// -> If the decision was right then lets move to the next element of the string without adding \" . \" in the ds.\\n        if(check(ds,pdot)) solve(s,ds,ans,i+1,pdot,dcount);\\n        \\n\\t\\t\\n\\t\\t// lets add \" . \" in the ds.\\n\\t\\t// min there should be 1 element to add a \" . \" \\n\\t\\t// also not more that 3 dot should be there so 2 already present and one inside the block.\\n        if(ds.size() - pdot >1 && dcount <=2)\\n        {\\n            int size = ds.size()-1;\\n            ds[size] = \\'.\\';\\n\\t\\t\\t\\n\\t\\t\\t// add \" . \" at the end of the ds and update pdot i.e position of dot.\\n\\t\\t\\t// dcount is to track how many dot have been inserted.\\n            solve(s,ds,ans,i,size+1,++dcount);\\n        }\\n\\n        \\n        \\n    }\\n\\t\\n\\t// code starts from here\\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string ds;  \\n        vector<string>ans;  // if ds is a possible answer it will be inserted here.\\n        \\n        solve(s,ds,ans,0,0,0);\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3079520,
                "title": "python-just-dfs-and-backtracking-explained",
                "content": "This is a common DFS and backtracking problem. \\n\\nWe just need to take care of special requirements:\\n(1) the total number of fields is 4;\\n(2) no leading \\'0\\' for a number if it is not \\'0\\'\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # dfs and backtracking\\n        self.s = s\\n        self.len_s = len(s)\\n        self.ans = []\\n\\n        self.dfs(0, [])\\n\\n        return self.ans\\n\\n    def dfs(self, index, partition):\\n        if index == self.len_s:\\n            # we reached the end of the string\\n            if len(partition) == 4:\\n                self.ans.append(\".\".join(partition))\\n            return\\n        \\n        if index < self.len_s and len(partition) == 4:\\n            # we haven\\'t used all the characters to build 4 address fields\\n            return\\n\\n        if self.s[index] == \\'0\\':\\n            partition.append(\\'0\\')\\n            self.dfs(index + 1, partition)\\n            partition.pop()\\n        else:\\n            for i in range(index + 1, self.len_s + 1):\\n                if 0 <= int(self.s[index: i]) <= 255:\\n                    partition.append(self.s[index: i])\\n                    self.dfs(i, partition)\\n                    partition.pop()\\n                else:\\n                    # no need to check further as the value is not in the range of 0 ~ 255\\n                    break\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # dfs and backtracking\\n        self.s = s\\n        self.len_s = len(s)\\n        self.ans = []\\n\\n        self.dfs(0, [])\\n\\n        return self.ans\\n\\n    def dfs(self, index, partition):\\n        if index == self.len_s:\\n            # we reached the end of the string\\n            if len(partition) == 4:\\n                self.ans.append(\".\".join(partition))\\n            return\\n        \\n        if index < self.len_s and len(partition) == 4:\\n            # we haven\\'t used all the characters to build 4 address fields\\n            return\\n\\n        if self.s[index] == \\'0\\':\\n            partition.append(\\'0\\')\\n            self.dfs(index + 1, partition)\\n            partition.pop()\\n        else:\\n            for i in range(index + 1, self.len_s + 1):\\n                if 0 <= int(self.s[index: i]) <= 255:\\n                    partition.append(self.s[index: i])\\n                    self.dfs(i, partition)\\n                    partition.pop()\\n                else:\\n                    # no need to check further as the value is not in the range of 0 ~ 255\\n                    break\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079362,
                "title": "easy-to-understand-backtracking",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/backtracking/RestoreIpAddresses.kt",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3079289,
                "title": "python3-recursion",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        S = len(s)\\n        ans = set()\\n        \\n        def rec(idx, arr):\\n            if idx == len(s):\\n                if len(arr) == 4: \\n                    ans.add(\".\".join(arr))\\n                return\\n            \\n            if s[idx] == \"0\":\\n                rec(idx+1, arr+[\"0\"])\\n                return\\n            \\n            for i in range(idx, S):\\n                if int(s[idx:i+1]) < 256:\\n                    rec(i+1, arr+[s[idx:i+1]])\\n                else:\\n                    break\\n        rec(0, [])\\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        S = len(s)\\n        ans = set()\\n        \\n        def rec(idx, arr):\\n            if idx == len(s):\\n                if len(arr) == 4: \\n                    ans.add(\".\".join(arr))\\n                return\\n            \\n            if s[idx] == \"0\":\\n                rec(idx+1, arr+[\"0\"])\\n                return\\n            \\n            for i in range(idx, S):\\n                if int(s[idx:i+1]) < 256:\\n                    rec(i+1, arr+[s[idx:i+1]])\\n                else:\\n                    break\\n        rec(0, [])\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 3079241,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidNumber(string s){\\n        return stoi(s)>=0 and stoi(s)<=255 and to_string(stoi(s))==s;\\n    }\\n    bool isValidIPAddress(string s){\\n        int n=s.size();\\n        s.push_back(\\'.\\');\\n        int i=0;\\n        while(i<=n){\\n            string temp;\\n            while(s[i]!=\\'.\\'){\\n                temp.push_back(s[i++]);\\n            }\\n            i++;\\n            if(temp.size()>3 or !isValidNumber(temp)){\\n                return false;\\n            }\\n        }\\n        s.pop_back();\\n        return true;\\n    }\\n    vector<string> ans;\\n    void solve(int idx,int dot,string& ds,string& s){\\n        int n=s.size();\\n        if(idx==n){\\n            if(isValidIPAddress(ds) and dot==0){\\n                ans.push_back(ds);\\n            }\\n            return ;\\n        }\\n        ds.push_back(s[idx]);\\n        if(dot>=1 and ds.back()!=\\'.\\' and idx!=n-1){\\n            ds.push_back(\\'.\\');\\n            solve(idx+1,dot-1,ds,s);\\n            ds.pop_back();\\n        }\\n        solve(idx+1,dot,ds,s);\\n        ds.pop_back();\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        string ds=\"\";\\n        solve(0,3,ds,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidNumber(string s){\\n        return stoi(s)>=0 and stoi(s)<=255 and to_string(stoi(s))==s;\\n    }\\n    bool isValidIPAddress(string s){\\n        int n=s.size();\\n        s.push_back(\\'.\\');\\n        int i=0;\\n        while(i<=n){\\n            string temp;\\n            while(s[i]!=\\'.\\'){\\n                temp.push_back(s[i++]);\\n            }\\n            i++;\\n            if(temp.size()>3 or !isValidNumber(temp)){\\n                return false;\\n            }\\n        }\\n        s.pop_back();\\n        return true;\\n    }\\n    vector<string> ans;\\n    void solve(int idx,int dot,string& ds,string& s){\\n        int n=s.size();\\n        if(idx==n){\\n            if(isValidIPAddress(ds) and dot==0){\\n                ans.push_back(ds);\\n            }\\n            return ;\\n        }\\n        ds.push_back(s[idx]);\\n        if(dot>=1 and ds.back()!=\\'.\\' and idx!=n-1){\\n            ds.push_back(\\'.\\');\\n            solve(idx+1,dot-1,ds,s);\\n            ds.pop_back();\\n        }\\n        solve(idx+1,dot,ds,s);\\n        ds.pop_back();\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        string ds=\"\";\\n        solve(0,3,ds,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079180,
                "title": "c-backtraking-video-solution",
                "content": "# Intuition & Approach\\nhttps://youtu.be/PFb5zPn0vvY\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<string> validAddresses;\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        n = s.size();\\n        solve(0, 0, \"\", s);\\n        return validAddresses;\\n    }\\n\\n    void solve(int idx, int numOfIntegers, string curAddress, string &s) {\\n        if (numOfIntegers > 4)\\n            return;\\n        \\n        if (numOfIntegers == 4 && idx == n) {\\n            curAddress.pop_back();\\n            validAddresses.push_back(curAddress);\\n            return;\\n        }\\n\\n        for (int i = 1; i <= 3 && idx + i <= n; ++i) {\\n            string curInteger = s.substr(idx, i);\\n            \\n            if (curInteger[0] == \\'0\\' && i != 1)\\n                break;\\n            \\n            if (stoi(curInteger) <= 255)\\n                solve(idx + i, numOfIntegers + 1, curAddress + curInteger + \".\", s);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<string> validAddresses;\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        n = s.size();\\n        solve(0, 0, \"\", s);\\n        return validAddresses;\\n    }\\n\\n    void solve(int idx, int numOfIntegers, string curAddress, string &s) {\\n        if (numOfIntegers > 4)\\n            return;\\n        \\n        if (numOfIntegers == 4 && idx == n) {\\n            curAddress.pop_back();\\n            validAddresses.push_back(curAddress);\\n            return;\\n        }\\n\\n        for (int i = 1; i <= 3 && idx + i <= n; ++i) {\\n            string curInteger = s.substr(idx, i);\\n            \\n            if (curInteger[0] == \\'0\\' && i != 1)\\n                break;\\n            \\n            if (stoi(curInteger) <= 255)\\n                solve(idx + i, numOfIntegers + 1, curAddress + curInteger + \".\", s);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079173,
                "title": "clean-and-clear-the-interview-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking problem where we try to place a dot in every possible position and then check if it is valid\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n spots to choose the placement of the first dot\\n- n - 1 spots to choose placement of second dot\\n- n - 2 for third\\n- n - 3 for fourth\\nTotal = n * (n - 1) * (n - 2) * (n - 3) = $$O(n^2)$$\\n- Space complexity: $$O(n^4)$$ \\nIn the worst case we need to store every possible permutation of dots\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def isValid(sequence):\\n            if len(sequence) < 7: return False\\n            values = sequence.split(\".\")\\n            if len(values) != 4: return False\\n            for val in values:\\n                if int(val) > 255 or (len(val) >= 2 and val[0] == \\'0\\'): return False\\n            return True\\n        res = []\\n        def backtrack(i, count, sequence):\\n            # check valid:\\n            if i == len(s):\\n                if sequence[-1] != \".\" and isValid(sequence):\\n                    res.append(sequence)\\n                return\\n            sequence += s[i]\\n            # add dot\\n            sequence += \".\"\\n            backtrack(i + 1, count + 1, sequence)\\n            # remove dot\\n            sequence = sequence[:-1]\\n            backtrack(i + 1, count, sequence)\\n        backtrack(0, 0, \"\")\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def isValid(sequence):\\n            if len(sequence) < 7: return False\\n            values = sequence.split(\".\")\\n            if len(values) != 4: return False\\n            for val in values:\\n                if int(val) > 255 or (len(val) >= 2 and val[0] == \\'0\\'): return False\\n            return True\\n        res = []\\n        def backtrack(i, count, sequence):\\n            # check valid:\\n            if i == len(s):\\n                if sequence[-1] != \".\" and isValid(sequence):\\n                    res.append(sequence)\\n                return\\n            sequence += s[i]\\n            # add dot\\n            sequence += \".\"\\n            backtrack(i + 1, count + 1, sequence)\\n            # remove dot\\n            sequence = sequence[:-1]\\n            backtrack(i + 1, count, sequence)\\n        backtrack(0, 0, \"\")\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079164,
                "title": "typescript-dfs-backtracking",
                "content": "# Intuition\\nUse DFS for backtracking to generate all possible IP addresses\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n    $$O(3^n)$$ \\n\\n- Space complexity:\\n$$O(d)$$\\n> d auxiliary  call stack space \\n\\n# Code\\n```\\nfunction restoreIpAddresses(s: string): string[] {\\n    let result:string[] = [];\\n    const DFS  = (ip:string,index:number,octet:number) => {\\n        if(index >= s.length){\\n            return;\\n        }\\n        // last octet check\\n        if(octet == 3){\\n            //check if last digit is valid\\n            if(s.substring(index, index+1) != \"0\" || index+1 == s.length){\\n                if(Number(s.substring(index)) < 256){\\n                    ip += \\'.\\'\\n                    ip += s.substring(index);\\n                    result.push(ip)\\n                }\\n            }\\n            return\\n        }\\n        for(let i = 1; i <= 3 && index+i < s.length; i++){\\n            if(Number(s.substring(index, index+i)) < 256){\\n                DFS(ip + \\'.\\'+ s.substring(index, index+i),index+i, octet + 1);\\n            }\\n            //check for leading zero\\n            if(s.substring(index, index+1) == \"0\"){\\n                break;\\n            }\\n        }\\n    }\\n    for(let i = 1; i <= 3 && i < s.length ; i++){\\n        if(Number(s.substring(0, i)) < 256){\\n            DFS(s.substring(0, i), i, 1);\\n        }\\n        //check for leading zero\\n        if(s[0] == \"0\"){\\n                break;\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Backtracking"
                ],
                "code": "```\\nfunction restoreIpAddresses(s: string): string[] {\\n    let result:string[] = [];\\n    const DFS  = (ip:string,index:number,octet:number) => {\\n        if(index >= s.length){\\n            return;\\n        }\\n        // last octet check\\n        if(octet == 3){\\n            //check if last digit is valid\\n            if(s.substring(index, index+1) != \"0\" || index+1 == s.length){\\n                if(Number(s.substring(index)) < 256){\\n                    ip += \\'.\\'\\n                    ip += s.substring(index);\\n                    result.push(ip)\\n                }\\n            }\\n            return\\n        }\\n        for(let i = 1; i <= 3 && index+i < s.length; i++){\\n            if(Number(s.substring(index, index+i)) < 256){\\n                DFS(ip + \\'.\\'+ s.substring(index, index+i),index+i, octet + 1);\\n            }\\n            //check for leading zero\\n            if(s.substring(index, index+1) == \"0\"){\\n                break;\\n            }\\n        }\\n    }\\n    for(let i = 1; i <= 3 && i < s.length ; i++){\\n        if(Number(s.substring(0, i)) < 256){\\n            DFS(s.substring(0, i), i, 1);\\n        }\\n        //check for leading zero\\n        if(s[0] == \"0\"){\\n                break;\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079140,
                "title": "beats-100-c-java-using-dfs-backtracking",
                "content": "> ## ***UPVOTE if U find it useful***\\n\\n# using backtracking\\n## **complexity \\n  Time complexity : O(2^n)\\n  Space complexity: O(n)**\\n```java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# using DFS + Backtracking Beats 100%\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```\\n```java []\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```\n```java []\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079082,
                "title": "daily-leetcoding-challenge-january-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/restore-ip-addresses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/restore-ip-addresses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3065416,
                "title": "javascript-clean-backtracking-solution-with-explanation",
                "content": "# Intuition\\nThis is similar to [Word Break](https://leetcode.com/problems/word-break/) except instead of checking if a string segment exists in a dictionary, we use a helper function to validate it.\\n\\n# Approach\\n1. In the main backtracking loop, build up the IP address segment.\\n2. If the segment is invalid, don\\'t use it.  Valid segment in this context means\\na. The segment should be a value <= 255.\\nb. The segment cannot be left zero padded if its length > 1.\\nc. If we already have 3 segments in our IP address candidate, the current segment length has to be equal to the remaining length of the input string.  Remember, you have to use all the digits in the input string to form the IP address.\\n3. Otherwise,  backtrack.\\n\\n# Complexity\\n- Time complexity: -\\n\\n- Space complexity: -\\n```\\n# Code\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    solve(s, 0, [], result);\\n    return result;\\n};\\n\\nconst solve = (s, start, candidate, result) => {\\n    if (candidate.length === 4) {\\n        result.push(candidate.join(\\'.\\'));\\n        return;\\n    }\\n\\n    let segment = \\'\\';\\n    for (let i = start; i < s.length; i++) {\\n        segment += s[i];\\n        if (!isValidSegment(s, start, segment, candidate)) {\\n            continue;\\n        }\\n        candidate.push(segment);\\n        solve(s, i + 1, candidate, result);\\n        candidate.pop();\\n    }\\n}\\n\\nconst isValidSegment = (s, start, segment, candidate) => {\\n    if (Number(segment) > 255) {\\n        return false;\\n    }\\n\\n    if (segment.length > 1 && segment[0] === \\'0\\') {\\n        return false;\\n    }\\n\\n    const remainingLength = s.length - start;\\n    if (candidate.length === 3 && segment.length < remainingLength) {\\n        return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n# Code\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    solve(s, 0, [], result);\\n    return result;\\n};\\n\\nconst solve = (s, start, candidate, result) => {\\n    if (candidate.length === 4) {\\n        result.push(candidate.join(\\'.\\'));\\n        return;\\n    }\\n\\n    let segment = \\'\\';\\n    for (let i = start; i < s.length; i++) {\\n        segment += s[i];\\n        if (!isValidSegment(s, start, segment, candidate)) {\\n            continue;\\n        }\\n        candidate.push(segment);\\n        solve(s, i + 1, candidate, result);\\n        candidate.pop();\\n    }\\n}\\n\\nconst isValidSegment = (s, start, segment, candidate) => {\\n    if (Number(segment) > 255) {\\n        return false;\\n    }\\n\\n    if (segment.length > 1 && segment[0] === \\'0\\') {\\n        return false;\\n    }\\n\\n    const remainingLength = s.length - start;\\n    if (candidate.length === 3 && segment.length < remainingLength) {\\n        return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2673083,
                "title": "c-100-faster-very-simple-3-cases-explanation-recursion",
                "content": "```\\nclass Solution {\\n    vector<string> ans;\\npublic:\\n    void restoreDFS(string s, string temp, int dot, int index) {\\n        if (index == s.size() and dot == 4) {\\n            temp.pop_back();\\n            ans.push_back(move(temp));\\n            return;\\n        }\\n        if (index >= s.size() or dot >= 4) {\\n            return;\\n        }\\n\\t\\t\\n        // case 1: For first dot it doesnot matter what number it is\\n        restoreDFS(s, temp + s[index] + \\'.\\', dot + 1, index + 1);\\n\\t\\t\\n\\t\\t// case 2: For 2 numbers the first char cannot be a zero\\n        if (s[index] != \\'0\\') {\\n            restoreDFS(s, temp + s.substr(index, 2) + \\'.\\', dot + 1, index + 2);\\n        }\\n\\t\\t\\n\\t\\t// case 3: For 3 numbers whole number cannot be larger than 255 with no leading zero\\n        if (s[index] != \\'0\\' and (stoi(s.substr(index, 3)) < 256)) {\\n            restoreDFS(s, temp + s.substr(index, 3) + \\'.\\', dot + 1, index + 3);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12 or s.size() < 4) return ans;\\n        restoreDFS(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\npublic:\\n    void restoreDFS(string s, string temp, int dot, int index) {\\n        if (index == s.size() and dot == 4) {\\n            temp.pop_back();\\n            ans.push_back(move(temp));\\n            return;\\n        }\\n        if (index >= s.size() or dot >= 4) {\\n            return;\\n        }\\n\\t\\t\\n        // case 1: For first dot it doesnot matter what number it is\\n        restoreDFS(s, temp + s[index] + \\'.\\', dot + 1, index + 1);\\n\\t\\t\\n\\t\\t// case 2: For 2 numbers the first char cannot be a zero\\n        if (s[index] != \\'0\\') {\\n            restoreDFS(s, temp + s.substr(index, 2) + \\'.\\', dot + 1, index + 2);\\n        }\\n\\t\\t\\n\\t\\t// case 3: For 3 numbers whole number cannot be larger than 255 with no leading zero\\n        if (s[index] != \\'0\\' and (stoi(s.substr(index, 3)) < 256)) {\\n            restoreDFS(s, temp + s.substr(index, 3) + \\'.\\', dot + 1, index + 3);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12 or s.size() < 4) return ans;\\n        restoreDFS(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384635,
                "title": "c-backtracking-recursion",
                "content": "class Solution {\\npublic:\\n     ```\\n```\\n   void func(vector<string>& ans, string temp, int start,string s,int c)\\n        {\\n                if(c==4)\\n                {\\n                        if(start==s.size())\\n                        {\\n                                temp.pop_back();\\n                                ans.push_back(temp);\\n                        }\\n                                return;\\n                }\\n                int num=0;\\n                for(int i=start;i<s.size();i++)\\n                {\\n                        \\n                        num=num*10+(s[i]-\\'0\\');\\n                        if(num>255)\\n                        {\\n                                break;\\n                        }\\n                        if(s[i]==\\'0\\')\\n                        {\\n                                temp=temp+\"0\"+\".\";\\n                                func(ans,temp,i+1,s,c+1);\\n                                \\n//if digit is zero and the number after previous .(consider \"0.0\") is also zero then there wont be any further placing of . in this current loop so we break the for loop\\n                                if(num==0)\\n                                break;\\n                                \\n//else the number was not zero so we can make use of normal backtracking\\n                                else\\n                                        temp.pop_back();\\n                        }\\n                        \\n//Normal BackTrack for any other digit\\n                        else {\\n                                temp=temp+s[i]+\".\";\\n                                 func(ans,temp,i+1,s,c+1);\\n                                temp.pop_back();\\n                        }\\n                }\\n        }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        vector<string> ans;\\n            string temp=\"\";\\n            int c=0;\\n            func(ans,temp,0,s,c);\\n            return ans;\\n    }\\n```\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383310,
                "title": "simple-python-complex-time-complexity-code-faster-than-100",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        def isValid(st):\\n            if(len(st)!=len(str(int(st)))):\\n                return False\\n            st = int(st)\\n            if(st>255 or st<0):\\n                return False\\n            return True\\n        \\n        validIps = []\\n        for i in range(1,4):\\n            s1 = s[:i]\\n            if(not isValid(s1)):\\n                continue\\n            for j in range(i+1, min(len(s), i+4)):\\n                s2 = s[i:j]\\n                if(not isValid(s2)):\\n                    continue\\n                for k in range(j+1,min(len(s), j+4)):\\n                    s3 = s[j:k]\\n                    if(not isValid(s3)):\\n                        continue\\n                    s4 = s[k:]\\n                    if(not isValid(s4)):\\n                        continue\\n                    currentIp = s1+\".\"+s2+\".\"+s3+\".\"+s4\\n                    validIps.append(currentIp)\\n        return validIps\\n",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        def isValid(st):\\n            if(len(st)!=len(str(int(st)))):\\n                return False\\n            st = int(st)\\n            if(st>255 or st<0):\\n                return False\\n            return True\\n        \\n        validIps = []\\n        for i in range(1,4):\\n            s1 = s[:i]\\n            if(not isValid(s1)):\\n                continue\\n            for j in range(i+1, min(len(s), i+4)):\\n                s2 = s[i:j]\\n                if(not isValid(s2)):\\n                    continue\\n                for k in range(j+1,min(len(s), j+4)):\\n                    s3 = s[j:k]\\n                    if(not isValid(s3)):\\n                        continue\\n                    s4 = s[k:]\\n                    if(not isValid(s4)):\\n                        continue\\n                    currentIp = s1+\".\"+s2+\".\"+s3+\".\"+s4\\n                    validIps.append(currentIp)\\n        return validIps\\n",
                "codeTag": "Java"
            },
            {
                "id": 2336781,
                "title": "c-faster-then-100-69-less-memory-backtracking-simple",
                "content": "```\\nvoid help(int ind, string &t, vector<string> &ans,int &ct,int prev,string s)\\n    {\\n        int i,strval=0,j;\\n        if(ct==3 )\\n        {\\n            strval=0;\\n            for(i=ind;i<s.size();i++)\\n            {\\n                strval = strval*10 + s[i]-\\'0\\';\\n            }\\n            if(s[ind]==\\'0\\' && ind!= s.size()-1)\\n            {\\n                return;\\n            }\\n            if(strval<=255 )\\n            {\\n                for(i=ind;i<s.size();i++)\\n                {\\n                   t.push_back(s[i]);\\n                }\\n                ans.push_back(t);\\n                for(i=ind;i<s.size();i++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            \\n            return;\\n        }\\n        strval=0;\\n        for(i=ind;i<s.size()-1;i++)\\n        {\\n            strval= strval*10 + s[i] - 48;\\n            \\n            if(strval==0)\\n            {\\n                t.push_back(\\'0\\');\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                t.pop_back();\\n                t.pop_back();\\n                break;\\n            }\\n            if(strval>0 &&  strval<=255)\\n            {\\n                for(j=ind;j<=i;j++)\\n                {\\n                    t.push_back(s[j]);\\n                }\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                for(j=0;j<i-ind+2;j++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            else{\\n                return;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string t;\\n        int strval,ind=0,ct=0,prev=0;\\n        vector<string> ans;\\n        if(s.size()>12)\\n        {\\n            return ans;\\n        }\\n        else{\\n            help(ind,t,ans,ct,prev,s);\\n            return ans;\\n        }\\n        \\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nvoid help(int ind, string &t, vector<string> &ans,int &ct,int prev,string s)\\n    {\\n        int i,strval=0,j;\\n        if(ct==3 )\\n        {\\n            strval=0;\\n            for(i=ind;i<s.size();i++)\\n            {\\n                strval = strval*10 + s[i]-\\'0\\';\\n            }\\n            if(s[ind]==\\'0\\' && ind!= s.size()-1)\\n            {\\n                return;\\n            }\\n            if(strval<=255 )\\n            {\\n                for(i=ind;i<s.size();i++)\\n                {\\n                   t.push_back(s[i]);\\n                }\\n                ans.push_back(t);\\n                for(i=ind;i<s.size();i++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            \\n            return;\\n        }\\n        strval=0;\\n        for(i=ind;i<s.size()-1;i++)\\n        {\\n            strval= strval*10 + s[i] - 48;\\n            \\n            if(strval==0)\\n            {\\n                t.push_back(\\'0\\');\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                t.pop_back();\\n                t.pop_back();\\n                break;\\n            }\\n            if(strval>0 &&  strval<=255)\\n            {\\n                for(j=ind;j<=i;j++)\\n                {\\n                    t.push_back(s[j]);\\n                }\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                for(j=0;j<i-ind+2;j++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            else{\\n                return;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string t;\\n        int strval,ind=0,ct=0,prev=0;\\n        vector<string> ans;\\n        if(s.size()>12)\\n        {\\n            return ans;\\n        }\\n        else{\\n            help(ind,t,ans,ct,prev,s);\\n            return ans;\\n        }\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2271339,
                "title": "best-working-java-solution-3-loops-only-beats-97",
                "content": "```\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2222868,
                "title": "beginner-friendly-dfs-backtracking-solution-in-c",
                "content": "\\t\\t\\n\\t\\tvoid solve(string s, vector<string> &ans, string output, int dots){       \\n\\t\\t\\tif(dots == 0){  //4 Dots have been places. 3->2->1->0 , hence the base case                        \\n            \\n            if(s[0]==\\'0\\' and s.length()>1){  //check if the last substring doesnt start with 0\\n                return;\\n            }\\n            int num = stoll(s);\\n            if(num>=0 and num<= 255){   //check if the last substring is within limits (i.e 0 and 255)\\n                output += s;    \\n                ans.push_back(output);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){  //here we are trying all possible combi in which we can place dots\\n            string left = s.substr(0,i);\\n            if(left.length()<=0 or (left.length()>1 and left[0]==\\'0\\')){ //check for empty string and if the substr starts with 0\\n                continue;\\n            }\\n            string right = s.substr(i); //remaining string / right part of the string\\n            int num = stoll(left); \\n            if(num>=0 and num<=255){ //check if the substring is valid\\n                solve(right, ans, output + left + \".\", dots - 1);\\n            }\\n        }    \\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(s,ans,\"\",3);\\n        return ans;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\t\\t\\n\\t\\tvoid solve(string s, vector<string> &ans, string output, int dots){       \\n\\t\\t\\tif(dots == 0){  //4 Dots have been places. 3->2->1->0 , hence the base case                        \\n            \\n            if(s[0]==\\'0\\' and s.length()>1){  //check if the last substring doesnt start with 0\\n                return;\\n            }\\n            int num = stoll(s);\\n            if(num>=0 and num<= 255){   //check if the last substring is within limits (i.e 0 and 255)\\n                output += s;    \\n                ans.push_back(output);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){  //here we are trying all possible combi in which we can place dots\\n            string left = s.substr(0,i);\\n            if(left.length()<=0 or (left.length()>1 and left[0]==\\'0\\')){ //check for empty string and if the substr starts with 0\\n                continue;\\n            }\\n            string right = s.substr(i); //remaining string / right part of the string\\n            int num = stoll(left); \\n            if(num>=0 and num<=255){ //check if the substring is valid\\n                solve(right, ans, output + left + \".\", dots - 1);\\n            }\\n        }    \\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(s,ans,\"\",3);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2207698,
                "title": "javascript-simple-efficient-solution",
                "content": "```\\nvar restoreIpAddresses = function (s) {\\n\\n\\tconst isValid = str => {\\n\\t\\tif (str === \\'0\\') return true;\\n\\t\\tif (str[0] === \\'0\\') return false;\\n\\t\\treturn parseInt(str) <= 255;\\n\\t}\\n\\n\\tlet rVal = [];\\n\\tfor (let i = 1; i < 4 && i < s.length - 2; i++) {\\n\\t\\tconst fir = s.substring(0, i);\\n\\t\\tif (!isValid(fir)) continue;\\n\\n\\t\\tfor (let j = i + 1; j < i + 4 && j < s.length - 1; j++) {\\n\\t\\t\\tconst sec = s.substring(i, j);\\n\\t\\t\\tif (!isValid(sec)) continue;\\n\\n\\t\\t\\tfor (let k = j + 1; k < j + 4 && k < s.length; k++) {\\n\\t\\t\\t\\tconst thir = s.substring(j, k);\\n\\t\\t\\t\\tif (!isValid(thir)) continue;\\n\\n\\t\\t\\t\\tconst forth = s.substring(k);\\n\\t\\t\\t\\tif (forth.length > 3 || !isValid(forth)) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\trVal.push([fir, sec, thir, forth].join(\\'.\\'))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn rVal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar restoreIpAddresses = function (s) {\\n\\n\\tconst isValid = str => {\\n\\t\\tif (str === \\'0\\') return true;\\n\\t\\tif (str[0] === \\'0\\') return false;\\n\\t\\treturn parseInt(str) <= 255;\\n\\t}\\n\\n\\tlet rVal = [];\\n\\tfor (let i = 1; i < 4 && i < s.length - 2; i++) {\\n\\t\\tconst fir = s.substring(0, i);\\n\\t\\tif (!isValid(fir)) continue;\\n\\n\\t\\tfor (let j = i + 1; j < i + 4 && j < s.length - 1; j++) {\\n\\t\\t\\tconst sec = s.substring(i, j);\\n\\t\\t\\tif (!isValid(sec)) continue;\\n\\n\\t\\t\\tfor (let k = j + 1; k < j + 4 && k < s.length; k++) {\\n\\t\\t\\t\\tconst thir = s.substring(j, k);\\n\\t\\t\\t\\tif (!isValid(thir)) continue;\\n\\n\\t\\t\\t\\tconst forth = s.substring(k);\\n\\t\\t\\t\\tif (forth.length > 3 || !isValid(forth)) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\trVal.push([fir, sec, thir, forth].join(\\'.\\'))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn rVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028226,
                "title": "recursion-easy-to-understand-c",
                "content": "**APPROACH:**\\n* We know that that given string can be formed into IP address by dividing it into either 3-bit or 2-bit or 1-bit without any leading zero in first two conditions.\\n* so we have option of dividing string into 3 ways : Make group of 3-3 characters **OR** make group of 2-2 characters **OR** make group of 1 character. With checking condition of **no leading zero** and value of bits is **between 0 and 255 inclusive.**\\n* If group of 3 bit is invalid to use either of false of leading zero condition as well as overflow of value range 2- bit character condition is then followed.\\n* with every **success call** i**ncrement part by 1** and **bits value by the length of character chosen.**\\n* when bits reaches the same length as string length it means all characters are taken and ans is printed after neglecting that last dot.\\n\\n\\n**CODE:**\\n\\n```\\n  int len=0;\\n    vector<string>res;\\n    \\n    bool valid(string s)\\n    {\\n        if(s.length()>1&&s[0]==\\'0\\')\\n        {\\n            return false;\\n        }\\n        int num=0;\\n        num=stoi(s);\\n        if(num>=0&&num<=255)\\n        {\\n            return true;\\n        }\\n        return false;\\n    \\n    }\\n    void helper(string s,string ans,int parts,int idx,int bits)\\n    {\\n         //IF ALL 4 PARTS ARE FORMED AND WHOLE STRING IS COVERED\\n         if(parts==4&&bits==len)\\n        {\\n             ans[ans.length()-1]=NULL;  //FOR REMOVING THAT LAST DOT\\n             res.push_back(ans);\\n             return ;\\n        }\\n        \\n        //IF IDX GETS LARGER THAN LENGTH\\n           if(idx>=len)\\n           {\\n               return ;\\n           }\\n\\n        \\n        //FOR FORMING 3 CHARACTER IP BIT\\n        \\n        if(idx+2<s.length()&&valid(s.substr(idx,3)))\\n        {\\n            helper(s,  ans+s.substr(idx,3)+\".\",  parts+1,  idx+3,  bits+3);\\n        }\\n        \\n        \\n        //FOR FORMING 2 CHARACTER IP BIT\\n        \\n         if(idx+1<s.length()&&valid(s.substr(idx,2)))\\n        {\\n            helper(s,  ans+s.substr(idx,2)+\".\",  parts+1,  idx+2,  bits+2);\\n        }\\n        \\n        \\n        //FOR FORMING 1 CHARACTER IP BIT\\n        \\n        if(idx<s.length()&&valid(s.substr(idx,1)))\\n        {\\n            helper(s, ans+s.substr(idx,1)+\".\",  parts+1,  idx+1,  bits+1);\\n        }\\n        \\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        len=s.length();\\n    //       string  ans  parts idx  bits\\n        helper( s ,  \"\" ,  0 ,  0 ,  0 );\\n        return res;\\n    }\\n\\t\\n\\t\\n\\t```\\n\\n\\n**Not the best solution Feel free to suggest changes to make it better.**\\nENJOYING LEARNING :)\\n\\n\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n  int len=0;\\n    vector<string>res;\\n    \\n    bool valid(string s)\\n    {\\n        if(s.length()>1&&s[0]==\\'0\\')\\n        {\\n            return false;\\n        }\\n        int num=0;\\n        num=stoi(s);\\n        if(num>=0&&num<=255)\\n        {\\n            return true;\\n        }\\n        return false;\\n    \\n    }\\n    void helper(string s,string ans,int parts,int idx,int bits)\\n    {\\n         //IF ALL 4 PARTS ARE FORMED AND WHOLE STRING IS COVERED\\n         if(parts==4&&bits==len)\\n        {\\n             ans[ans.length()-1]=NULL;  //FOR REMOVING THAT LAST DOT\\n             res.push_back(ans);\\n             return ;\\n        }\\n        \\n        //IF IDX GETS LARGER THAN LENGTH\\n           if(idx>=len)\\n           {\\n               return ;\\n           }\\n\\n        \\n        //FOR FORMING 3 CHARACTER IP BIT\\n        \\n        if(idx+2<s.length()&&valid(s.substr(idx,3)))\\n        {\\n            helper(s,  ans+s.substr(idx,3)+\".\",  parts+1,  idx+3,  bits+3);\\n        }\\n        \\n        \\n        //FOR FORMING 2 CHARACTER IP BIT\\n        \\n         if(idx+1<s.length()&&valid(s.substr(idx,2)))\\n        {\\n            helper(s,  ans+s.substr(idx,2)+\".\",  parts+1,  idx+2,  bits+2);\\n        }\\n        \\n        \\n        //FOR FORMING 1 CHARACTER IP BIT\\n        \\n        if(idx<s.length()&&valid(s.substr(idx,1)))\\n        {\\n            helper(s, ans+s.substr(idx,1)+\".\",  parts+1,  idx+1,  bits+1);\\n        }\\n        \\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        len=s.length();\\n    //       string  ans  parts idx  bits\\n        helper( s ,  \"\" ,  0 ,  0 ,  0 );\\n        return res;\\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969572,
                "title": "java-code-with-easy-explaination",
                "content": "\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        //list to return and store ans\\n        List<String> ans = new ArrayList<>();\\n        \\n        //calling helper function\\n        //params(provided_string , ans_generated , dot_count , answer)\\n        solve(s , \"\" , 4, ans);\\n        return ans;\\n    }\\n    \\n    void solve(String str , String curr, int dotCount, List<String> ans){\\n        if(dotCount == 0 && str.length() == 0)\\n        {\\n            //add answer except the last \\'.\\' if we reach to end of string and dots are also exhausted \\n            ans.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n        \\n        //min_length as we can only take max of 3 nums in ip address\\n        //we check if we have the length of string more than 3 length so just skip the other char of string\\n        int minLength = Math.min(str.length() , 3);\\n        \\n        for(int i = 0; i < minLength; i++){\\n            String s = str.substring(0,i+1); // add the char to our ans one by one\\n            if(check(s)){ // check if we have the correct number within range\\n                solve(str.substring(i + 1) , curr+s+\\'.\\' , dotCount-1 , ans); // call recursive function by decresing dots count\\n            }\\n        }\\n    }\\n    \\n    boolean check(String str){\\n        //check for zero eg - \\'01\\' is not valid only \\'0.1.3\\' is accepted\\n        if(str.length() > 1 && str.charAt(0) == \\'0\\')\\n            return false;\\n        \\n        //check for range of number (0 - 255)\\n        if(Integer.parseInt(str) > 255)\\n            return false;\\n        \\n        //reached here indicates our string can be a valid answer\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        //list to return and store ans\\n        List<String> ans = new ArrayList<>();\\n        \\n        //calling helper function\\n        //params(provided_string , ans_generated , dot_count , answer)\\n        solve(s , \"\" , 4, ans);\\n        return ans;\\n    }\\n    \\n    void solve(String str , String curr, int dotCount, List<String> ans){\\n        if(dotCount == 0 && str.length() == 0)\\n        {\\n            //add answer except the last \\'.\\' if we reach to end of string and dots are also exhausted \\n            ans.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n        \\n        //min_length as we can only take max of 3 nums in ip address\\n        //we check if we have the length of string more than 3 length so just skip the other char of string\\n        int minLength = Math.min(str.length() , 3);\\n        \\n        for(int i = 0; i < minLength; i++){\\n            String s = str.substring(0,i+1); // add the char to our ans one by one\\n            if(check(s)){ // check if we have the correct number within range\\n                solve(str.substring(i + 1) , curr+s+\\'.\\' , dotCount-1 , ans); // call recursive function by decresing dots count\\n            }\\n        }\\n    }\\n    \\n    boolean check(String str){\\n        //check for zero eg - \\'01\\' is not valid only \\'0.1.3\\' is accepted\\n        if(str.length() > 1 && str.charAt(0) == \\'0\\')\\n            return false;\\n        \\n        //check for range of number (0 - 255)\\n        if(Integer.parseInt(str) > 255)\\n            return false;\\n        \\n        //reached here indicates our string can be a valid answer\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874942,
                "title": "easy-java-backtracking-with-comments-beats-99-97",
                "content": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        List<String> curr = new ArrayList<>();\\n        findValid(s, curr, result);\\n        return result;\\n    }\\n    \\n    private void findValid(String s, List<String> curr, List<String> result) {\\n\\t\\t// Empty String can\\'t be valid\\n        if (s.equals(\"\")) {\\n            return;\\n        }\\n\\t\\t// If we already have three valid IP numbers, the remaining string passed into the method should constitute \\n\\t\\t// the 4th IP number. If it is valid, we add that set of 4 IP numbers to our valid IP address list\\n        if (curr.size() == 3) {\\n            if (checkValidNum(s)) {\\n                StringBuilder sb = new StringBuilder(curr.get(0));\\n                sb.append(\".\").append(curr.get(1)).append(\".\").append(curr.get(2)).append(\".\").append(s);\\n                result.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\t\\t// We can have IP address numbers of one, two, and three digits, so we try each of these options. \\n\\t\\t// For example, if we have the string 123456, we can pick:\\n\\t\\t// 1, and then find remaining valid IP numbers out of 23456, or\\n\\t\\t// 12, and then find remaining valid IP numbers out of 3456, or\\n\\t\\t// 123, and then find remaining valid IP numbers out of 456.\\n\\t\\t//\\n\\t\\t// The Math.min ensures we don\\'t try to take a IP number greater than our remaining\\n\\t\\t// IP string.\\n        for (int i = 1; i < Math.min(s.length(), 4); i++) {\\n            if (checkValidNum(s.substring(0, i))) {\\n                curr.add(s.substring(0, i));\\n                findValid(s.substring(i), curr, result);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n\\t// Checks if a string is a valid IP number\\n    private boolean checkValidNum(String s) {\\n        if (s.length() > 3 || (s.length() > 1 && s.charAt(0) == \\'0\\')) {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        if (num < 0 || num > 255) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nThe idea here is we take the start of the IP string, and try the three possible IP numbers. With each possibility, we remove the first IP number from the string, and then recurse with the new string. We use classic backtracking to explore all possible combinations of IP numbers to create an address.\\n\\nHope this helps, let me know if I missed anything.",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        List<String> curr = new ArrayList<>();\\n        findValid(s, curr, result);\\n        return result;\\n    }\\n    \\n    private void findValid(String s, List<String> curr, List<String> result) {\\n\\t\\t// Empty String can\\'t be valid\\n        if (s.equals(\"\")) {\\n            return;\\n        }\\n\\t\\t// If we already have three valid IP numbers, the remaining string passed into the method should constitute \\n\\t\\t// the 4th IP number. If it is valid, we add that set of 4 IP numbers to our valid IP address list\\n        if (curr.size() == 3) {\\n            if (checkValidNum(s)) {\\n                StringBuilder sb = new StringBuilder(curr.get(0));\\n                sb.append(\".\").append(curr.get(1)).append(\".\").append(curr.get(2)).append(\".\").append(s);\\n                result.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\t\\t// We can have IP address numbers of one, two, and three digits, so we try each of these options. \\n\\t\\t// For example, if we have the string 123456, we can pick:\\n\\t\\t// 1, and then find remaining valid IP numbers out of 23456, or\\n\\t\\t// 12, and then find remaining valid IP numbers out of 3456, or\\n\\t\\t// 123, and then find remaining valid IP numbers out of 456.\\n\\t\\t//\\n\\t\\t// The Math.min ensures we don\\'t try to take a IP number greater than our remaining\\n\\t\\t// IP string.\\n        for (int i = 1; i < Math.min(s.length(), 4); i++) {\\n            if (checkValidNum(s.substring(0, i))) {\\n                curr.add(s.substring(0, i));\\n                findValid(s.substring(i), curr, result);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n\\t// Checks if a string is a valid IP number\\n    private boolean checkValidNum(String s) {\\n        if (s.length() > 3 || (s.length() > 1 && s.charAt(0) == \\'0\\')) {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        if (num < 0 || num > 255) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872914,
                "title": "c-backtrcking-easy-to-understand-clean-code",
                "content": "# Approach 1\\nBy passing string as parameter\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void restore(string &s,int n,int i,int dots,string t)\\n    {\\n        if(i==n)\\n        {\\n            if(dots==4)\\n            {\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            \\n            return;\\n        }\\n\\n        if(dots>3)\\n        return;\\n        \\n        if(s[i]==\\'0\\')\\n        {\\n            restore(s,n,i+1,dots+1,t+s[i]+\".\");\\n            return;\\n        }\\n        \\n        string x=\"\";\\n        for(int j=0;j<3 && i+j<n;j++)\\n        {\\n            x+=s[i+j];\\n\\n            if(stoi(x)>255)\\n            return;\\n\\n            restore(s,n,i+j+1,dots+1,t+x+\".\");\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        restore(s,s.length(),0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing common string \\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string t;\\n    \\n    void restore(int in,string s,int n,int dots)\\n    {\\n        if(in==n)\\n        {\\n            t.pop_back();\\n            \\n            if(dots==4)\\n                ans.push_back(t);\\n            \\n            return;\\n        }\\n        \\n        if(dots>3)\\n            return;\\n        \\n        string num=\"\";\\n        string x=t;\\n        \\n        if(s[in]==\\'0\\')\\n        {\\n            t+=s[in];\\n            t+=\\'.\\';\\n            restore(in+1,s,n,dots+1);\\n            t=x;\\n            return;\\n        }\\n        \\n        int i;        \\n        for(i=in;i<n && i<in+3;i++)\\n        {\\n            num+=s[i];\\n            \\n            if(stoi(num)>255)\\n            return;\\n            \\n            t+=num;\\n            t+=\\'.\\';\\n            restore(i+1,s,n,dots+1);\\n            t=x;\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.length();\\n        if(n>12)\\n            return ans;\\n        \\n        restore(0,s,n,0);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do share your suggestions & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void restore(string &s,int n,int i,int dots,string t)\\n    {\\n        if(i==n)\\n        {\\n            if(dots==4)\\n            {\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            \\n            return;\\n        }\\n\\n        if(dots>3)\\n        return;\\n        \\n        if(s[i]==\\'0\\')\\n        {\\n            restore(s,n,i+1,dots+1,t+s[i]+\".\");\\n            return;\\n        }\\n        \\n        string x=\"\";\\n        for(int j=0;j<3 && i+j<n;j++)\\n        {\\n            x+=s[i+j];\\n\\n            if(stoi(x)>255)\\n            return;\\n\\n            restore(s,n,i+j+1,dots+1,t+x+\".\");\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        restore(s,s.length(),0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string t;\\n    \\n    void restore(int in,string s,int n,int dots)\\n    {\\n        if(in==n)\\n        {\\n            t.pop_back();\\n            \\n            if(dots==4)\\n                ans.push_back(t);\\n            \\n            return;\\n        }\\n        \\n        if(dots>3)\\n            return;\\n        \\n        string num=\"\";\\n        string x=t;\\n        \\n        if(s[in]==\\'0\\')\\n        {\\n            t+=s[in];\\n            t+=\\'.\\';\\n            restore(in+1,s,n,dots+1);\\n            t=x;\\n            return;\\n        }\\n        \\n        int i;        \\n        for(i=in;i<n && i<in+3;i++)\\n        {\\n            num+=s[i];\\n            \\n            if(stoi(num)>255)\\n            return;\\n            \\n            t+=num;\\n            t+=\\'.\\';\\n            restore(i+1,s,n,dots+1);\\n            t=x;\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.length();\\n        if(n>12)\\n            return ans;\\n        \\n        restore(0,s,n,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868182,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def check(self,ip):\\n        temp=ip.split(\\'.\\')\\n        # print(temp)\\n        for i in temp:\\n            if(len(i)!=1):\\n                if(len(i)==2):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                elif(len(i)==3):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                    elif(int(i)>255):\\n                        # print(i)\\n                        return False\\n                else:\\n                    return False\\n        return True\\n    \\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n\\t#length should be less than 12 because 255.255.255.255 is the largest combination possible\\n        if(len(s)>12):\\n            return[]\\n        else:\\n            i=0\\n            ans=[]\\n            while(i<=3 and i<len(s)):\\n                j=1\\n                while(j<=3 and i+j<len(s)):\\n                    k=1\\n                    while(k<=3 and i+j+k<len(s)):\\n                        temp=s[:i+1]+\\'.\\'+s[i+1:i+j+1]+\\'.\\'+s[i+j+1:i+j+k+1]+\\'.\\'+s[i+j+k+1:]\\n                        # print(temp)\\n                        if(self.check(temp)==True):\\n                            ans.append(temp)\\n                        k+=1\\n                    j+=1\\n                i+=1\\n            return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def check(self,ip):\\n        temp=ip.split(\\'.\\')\\n        # print(temp)\\n        for i in temp:\\n            if(len(i)!=1):\\n                if(len(i)==2):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                elif(len(i)==3):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                    elif(int(i)>255):\\n                        # print(i)\\n                        return False\\n                else:\\n                    return False\\n        return True\\n    \\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n\\t#length should be less than 12 because 255.255.255.255 is the largest combination possible\\n        if(len(s)>12):\\n            return[]\\n        else:\\n            i=0\\n            ans=[]\\n            while(i<=3 and i<len(s)):\\n                j=1\\n                while(j<=3 and i+j<len(s)):\\n                    k=1\\n                    while(k<=3 and i+j+k<len(s)):\\n                        temp=s[:i+1]+\\'.\\'+s[i+1:i+j+1]+\\'.\\'+s[i+j+1:i+j+k+1]+\\'.\\'+s[i+j+k+1:]\\n                        # print(temp)\\n                        if(self.check(temp)==True):\\n                            ans.append(temp)\\n                        k+=1\\n                    j+=1\\n                i+=1\\n            return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1707782,
                "title": "c-backtracking-dfs-solution-explained-100-time-70-space",
                "content": "Nice problem which is a variant of more common combinatorics problems, but, as such, offers room for the same kind of approach to tackle it: a good old backtracking DFS across all the branches of our decision tree.\\n\\nIt would be tempting to try and move the `3` dots we have to consider creating a lot of substrings here and there, but that would not be too convenient, considering how many times we might be doing the same work over and over again, while progressing with partial strings we have already validated (and only once) is probably a much better approach.\\n\\nAnd to do so, we will need a few variables, all at class level:\\n* `res` will be our accumulator variable, storing the valid permutations we will find for the provided digits;\\n* `s` will store our initial string at class level, `tmp` our temporary one (as mentioned above to proceed incrementally with already validated string chunks);\\n* `len` will store the length of our initial input;\\n* `digitsLeft` will keep track of how many digits we still need to add in our current `tmp` iteration, initially set to `4`.\\n\\nIn our main function, we will first of all give a proper value to `len`, then check if it is a value worth checking: any string outside of the `4 - 12` range would of course not work for us, providing either too few or too many digits for us to parse.\\n\\nIf we are still in, then we can assign a proper value to `s` and launch our `dfs` helper to compute all the possible permutations.\\n\\nThis helper function will take only one parameter (since I prefer keep as much as possible at class level, instead of passing copies or references of any information at class level), `start`, telling us from which character in `s` we start parsing; we will then:\\n* check if we reached an end case - ie: we are done adding digits to `tmp` (`digitsLeft == 0`), in which case:\\n\\t* if we know we exactly finished parsing the string (`start == len`) we also know we are checking a valid string, so we can append it to `res`;\\n\\t* in any case, we stop recursing with a `return` statement;\\n* if we are in the general case, we need to then consider three possible scenarios:\\n\\t* we can add `1` digit to `tmp`, which is always a valid scenario (I still left a conditional as a placeholder, in order to further optimise that on later iterations and, in any case, more easily tell the decision block apart):\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 1`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`;\\n\\t* we can add `2` digits to `tmp`, provided we have enough characters left and the first one is not `\\'0\\'` (no leading zeroes allowed!):\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `s[start + 1]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 2`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`;\\n\\t* we can add `3` digits to `tmp`, provided we have enough characters left and the first one is `\\'1\\'` followed by any number of `\\'2\\'` followed by any number `< \\'4\\'` or followed by `\\'5\\'` in turn: by any third digits `< \\'6\\'`:\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `s[start + 1]` to `tmp`;\\n\\t\\t* add `s[start + 2]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 2`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`.\\n\\nOnce done, we can just `return` `res` and be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // general case\\n        // 1 digit addition\\n        if (true) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 1 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 2 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 3 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nHey, we are adding and removing a lot of characters in our three cases, arent\\'t we? Well, it turns out that the third case will be valid only if the first two digits are in the valid range and the first to digits are in the valid range when the first one is (which happens always), so we can avoid a bit of repeated code, manage `digitsLeft` only once and streamline our construction of `tmp` a bit more efficiently and in a DRYer fashion, like this:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size();\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (true) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating tmp and recursing\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating tmp and recursing\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nNow, remember that placeholder conditional I put before the first block for adding one digit to `tmp`?\\n\\nI wanted to optimise it so that it would give us only calls when we have enough characters left to recurse; for example, if our initial string is `\"255255255255\"`, there is clearly no point in taking only `\\'2`\\', since we cannot make `3` other valid digits with the left over (`\"55255255255\"`); it turns out it works wonders, since I tried for example without these conditionals the previous code for `\"25525511135\"` would have `71` recursive calls; with my code, it is now only `9`\\uD83D\\uDE0E!\\n\\nWe will also need to update `tmp` regardless at each step, since we might have some cases in which the second digit is not enough, but the third is okay or the like; but it works wonders in this new version:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nThe last tiny bit of optimisation, to avoid reallocations, will be to set `res` initially always to get the maximum capacity of `19` (the longest possible series of permutations we might have for a string like `\"11111111\"`) and then resize accordingly, to avoid reallocations - it saves a bit of memory, it seems, but not as much as cutting on the needless recursions:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4, w = 0;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res[w++] = tmp;\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        res.resize(19);\\n        dfs();\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // general case\\n        // 1 digit addition\\n        if (true) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 1 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 2 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 3 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size();\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (true) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating tmp and recursing\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating tmp and recursing\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4, w = 0;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res[w++] = tmp;\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        res.resize(19);\\n        dfs();\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662631,
                "title": "intuitive-easy-to-understand-c-code",
                "content": "```\\nbool isValidPart(const string &s) {\\n        // \"00\", \"000\", \"01\", etc are not valid, but \"0\" is valid\\n        if(s.size() > 3 || s.front() == \\'0\\' && s.size() > 1) return false;\\n\\n        int val = stoi(s);\\n        return val <= 255 && val >= 0;\\n    }\\n\\n    vector<string> restoreIpAddresses(const string &s) {\\n        vector<string> result;\\n        for(size_t i = 1; i < 4 && i < s.size(); ++i) {\\n            const string first = s.substr(0, i);\\n            if(isValidPart(first)) {\\n                for(size_t j = 1; i + j < s.size() && j < 4; ++j) {\\n                    const string second = s.substr(i, j);\\n                    if(isValidPart(second)) {\\n                        for(size_t k = 1; i + j + k < s.size() && k < 4; ++k) {\\n                            const string third = s.substr(i + j, k), fourth = s.substr(i + j + k);\\n                            if(isValidPart(third) && isValidPart(fourth)) {\\n                                result.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\nAn upvote would be appreciated. ^_^",
                "solutionTags": [],
                "code": "```\\nbool isValidPart(const string &s) {\\n        // \"00\", \"000\", \"01\", etc are not valid, but \"0\" is valid\\n        if(s.size() > 3 || s.front() == \\'0\\' && s.size() > 1) return false;\\n\\n        int val = stoi(s);\\n        return val <= 255 && val >= 0;\\n    }\\n\\n    vector<string> restoreIpAddresses(const string &s) {\\n        vector<string> result;\\n        for(size_t i = 1; i < 4 && i < s.size(); ++i) {\\n            const string first = s.substr(0, i);\\n            if(isValidPart(first)) {\\n                for(size_t j = 1; i + j < s.size() && j < 4; ++j) {\\n                    const string second = s.substr(i, j);\\n                    if(isValidPart(second)) {\\n                        for(size_t k = 1; i + j + k < s.size() && k < 4; ++k) {\\n                            const string third = s.substr(i + j, k), fourth = s.substr(i + j + k);\\n                            if(isValidPart(third) && isValidPart(fourth)) {\\n                                result.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1433047,
                "title": "c-bracktracking-solution",
                "content": "```\\nclass Solution {\\n    \\n    bool isValid(const string& part){\\n        if((part[0] == \\'0\\' && part.size() != 1) || part.size() > 3 || stoi(part) > 255)\\n            return false;\\n        return true;\\n    }\\n    \\n    void util(const string& str, int s, string formedString, string subres, vector<string>& result, int count){\\n        if(formedString!= \"\" && (!isValid(formedString) || count > 4)){\\n            return;\\n        }\\n        subres += formedString == \"\" ? \"\" : formedString + \".\";\\n        if(subres.size()-4 == str.size()){\\n            subres.pop_back();\\n            result.push_back(subres);\\n            return;\\n        }\\n        formedString = \"\";\\n        for(int i = s; i < s+3 && i < str.size(); i++){\\n            formedString.append(1, str[i]);\\n            util(str, i+1, formedString, subres, result, count+1);\\n        }\\n    }\\n    \\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        util(s, 0, \"\", \"\", result, 0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    bool isValid(const string& part){\\n        if((part[0] == \\'0\\' && part.size() != 1) || part.size() > 3 || stoi(part) > 255)\\n            return false;\\n        return true;\\n    }\\n    \\n    void util(const string& str, int s, string formedString, string subres, vector<string>& result, int count){\\n        if(formedString!= \"\" && (!isValid(formedString) || count > 4)){\\n            return;\\n        }\\n        subres += formedString == \"\" ? \"\" : formedString + \".\";\\n        if(subres.size()-4 == str.size()){\\n            subres.pop_back();\\n            result.push_back(subres);\\n            return;\\n        }\\n        formedString = \"\";\\n        for(int i = s; i < s+3 && i < str.size(); i++){\\n            formedString.append(1, str[i]);\\n            util(str, i+1, formedString, subres, result, count+1);\\n        }\\n    }\\n    \\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        util(s, 0, \"\", \"\", result, 0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381550,
                "title": "swift-restore-ip-addresses-test-cases",
                "content": "```swift\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var result: [String] = []\\n        func helper(_ i: Int, _ arr: inout [String]) {\\n            guard i != s.count else {\\n                if arr.count == 4 { result.append(arr.joined(separator: \".\")) }\\n                return\\n            }\\n            if arr.count >= 4 { return }\\n            for end in i ..< min(s.count, i + 3) {\\n                let text = String(s[i ... end])\\n                if let num = Int(text), num >= 0, num < 256, \"\\\\(num)\" == text {\\n                    arr.append(text)\\n                    helper(end + 1, &arr)\\n                    arr.removeLast()\\n                }\\n            }\\n        }\\n        var array: [String] = []\\n        helper(0, &array)\\n        return result\\n    }\\n}\\n```\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.074 (0.077) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.restoreIpAddresses(\"25525511135\")\\n        XCTAssertEqual(res, [\"255.255.11.135\",\"255.255.111.35\"])\\n    }\\n    func test1() {\\n        let res = s.restoreIpAddresses(\"0000\")\\n        XCTAssertEqual(res, [\"0.0.0.0\"])\\n    }\\n    func test2() {\\n        let res = s.restoreIpAddresses(\"1111\")\\n        XCTAssertEqual(res, [\"1.1.1.1\"])\\n    }\\n    func test3() {\\n        let res = s.restoreIpAddresses(\"010010\")\\n        XCTAssertEqual(res, [\"0.10.0.10\",\"0.100.1.0\"])\\n    }\\n    func test4() {\\n        let res = s.restoreIpAddresses(\"101023\")\\n        XCTAssertEqual(res, [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var result: [String] = []\\n        func helper(_ i: Int, _ arr: inout [String]) {\\n            guard i != s.count else {\\n                if arr.count == 4 { result.append(arr.joined(separator: \".\")) }\\n                return\\n            }\\n            if arr.count >= 4 { return }\\n            for end in i ..< min(s.count, i + 3) {\\n                let text = String(s[i ... end])\\n                if let num = Int(text), num >= 0, num < 256, \"\\\\(num)\" == text {\\n                    arr.append(text)\\n                    helper(end + 1, &arr)\\n                    arr.removeLast()\\n                }\\n            }\\n        }\\n        var array: [String] = []\\n        helper(0, &array)\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.074 (0.077) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.restoreIpAddresses(\"25525511135\")\\n        XCTAssertEqual(res, [\"255.255.11.135\",\"255.255.111.35\"])\\n    }\\n    func test1() {\\n        let res = s.restoreIpAddresses(\"0000\")\\n        XCTAssertEqual(res, [\"0.0.0.0\"])\\n    }\\n    func test2() {\\n        let res = s.restoreIpAddresses(\"1111\")\\n        XCTAssertEqual(res, [\"1.1.1.1\"])\\n    }\\n    func test3() {\\n        let res = s.restoreIpAddresses(\"010010\")\\n        XCTAssertEqual(res, [\"0.10.0.10\",\"0.100.1.0\"])\\n    }\\n    func test4() {\\n        let res = s.restoreIpAddresses(\"101023\")\\n        XCTAssertEqual(res, [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340970,
                "title": "java-easy-accepted-solution",
                "content": "\\' \\' \\'\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n\\n\\t\\tint n = s.length();\\n\\n\\t\\tfor (int i = 0; i < 4 && i <= n - 3; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < i + 4 && j <= n - 2; j++) {\\n\\t\\t\\t\\tfor (int k = j + 1; k < j + 4 && k <= n - 1; k++) {\\n\\n\\t\\t\\t\\t\\tString s1 = s.substring(0, i), \\n                      s2 = s.substring(i, j), \\n                      s3 = s.substring(j, k), \\n                      s4 = s.substring(k, n);\\n                    \\n\\t\\t\\t\\t\\tif (check(s1) && check(s2) && check(s3) && check(s4)) {\\n\\t\\t\\t\\t\\t\\tresult.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n    \\n    public boolean check(String s) {\\n\\n\\t\\tif (s.length() > 3 || \\n            s.length() == 0 || \\n            s.charAt(0) == \\'0\\' && s.length() > 1 || \\n            Integer.parseInt(s) > 255) \\n         {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n\\n\\t\\tint n = s.length();\\n\\n\\t\\tfor (int i = 0; i < 4 && i <= n - 3; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < i + 4 && j <= n - 2; j++) {\\n\\t\\t\\t\\tfor (int k = j + 1; k < j + 4 && k <= n - 1; k++) {\\n\\n\\t\\t\\t\\t\\tString s1 = s.substring(0, i), \\n                      s2 = s.substring(i, j), \\n                      s3 = s.substring(j, k), \\n                      s4 = s.substring(k, n);\\n                    \\n\\t\\t\\t\\t\\tif (check(s1) && check(s2) && check(s3) && check(s4)) {\\n\\t\\t\\t\\t\\t\\tresult.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1323898,
                "title": "what-if-the-length-of-string-is-greater-than-12-java-solution-1ms",
                "content": "\\tclass Solution {\\n\\t\\n\\t// Ip address can have max 12 numeric digits, Right? So no need to do anything for test case with length of string is greater than 12.\\n\\t\\tList<String> res;\\n\\t\\tpublic void restoreIp(String s, int idx, int state, StringBuilder cans) {\\n\\t\\t\\tif(idx == s.length()) {\\n\\t\\t\\t\\tif(state == 5) {\\n\\t\\t\\t\\t\\tres.add(cans.substring(1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(state == 5) return;\\n\\t\\t\\tfor(int i=1; i+idx <= s.length() && i <= 3; i++) {\\n\\t\\t\\t\\tString currStr = s.substring(idx, idx+i);\\n\\t\\t\\t\\tif(currStr.length() >= 2 && currStr.charAt(0) == \\'0\\') return;\\n\\t\\t\\t\\tint value = Integer.parseInt(currStr);\\n\\t\\t\\t\\tif(value >= 0 && value <= 255) {\\n\\t\\t\\t\\t\\tcans.append(\\'.\\').append(currStr);\\n\\t\\t\\t\\t\\trestoreIp(s, i+idx, state+1, cans);\\n\\t\\t\\t\\t\\tcans.delete(cans.length() - currStr.length() - 1, cans.length());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\t\\tres = new ArrayList<>();\\n\\t\\t\\tif(s.length() > 12) return res;\\n\\t\\t\\trestoreIp(s, 0, 1, new StringBuilder());\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\n\\t// Ip address can have max 12 numeric digits, Right? So no need to do anything for test case with length of string is greater than 12.\\n\\t\\tList<String> res;\\n\\t\\tpublic void restoreIp(String s, int idx, int state, StringBuilder cans) {\\n\\t\\t\\tif(idx == s.length()) {\\n\\t\\t\\t\\tif(state == 5) {\\n\\t\\t\\t\\t\\tres.add(cans.substring(1));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1231786,
                "title": "c-backtracking",
                "content": "simple backtracking algorithm checking every condition\\nhere \\n\\ti=next index to be considered of string s\\n\\tcnt=number of elements\\n```\\nclass Solution {\\npublic:\\n    void bt(string s,string x,int i,int cnt,vector<string> &ans)\\n    {\\n\\t\\tif(cnt>4)\\n        {\\n            return;\\n        }\\n        if(i==s.size() && cnt==4)\\n        {\\n            x=x.substr(0,x.size()-1);\\n            ans.push_back(x);\\n            return;\\n        }\\n        int p=0;\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(j!=i && p==0) //to check of recuring zeros\\n            {\\n                break;\\n            }\\n            p*=10;\\n            p+=s[j]-\\'0\\';\\n            if(p>=0 && p<=255)\\n            {\\n                string y=x;\\n                x+=to_string(p);\\n                x+=\\'.\\';\\n                bt(s,x,j+1,cnt+1,ans);\\n                x=y;\\n            }\\n            if(p>255)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n       vector<string> ans;\\n        if(s.length()>12) //length must be less than 12\\n        {\\n            return ans;\\n        }\\n        string x;\\n        bt(s,x,0,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void bt(string s,string x,int i,int cnt,vector<string> &ans)\\n    {\\n\\t\\tif(cnt>4)\\n        {\\n            return;\\n        }\\n        if(i==s.size() && cnt==4)\\n        {\\n            x=x.substr(0,x.size()-1);\\n            ans.push_back(x);\\n            return;\\n        }\\n        int p=0;\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(j!=i && p==0) //to check of recuring zeros\\n            {\\n                break;\\n            }\\n            p*=10;\\n            p+=s[j]-\\'0\\';\\n            if(p>=0 && p<=255)\\n            {\\n                string y=x;\\n                x+=to_string(p);\\n                x+=\\'.\\';\\n                bt(s,x,j+1,cnt+1,ans);\\n                x=y;\\n            }\\n            if(p>255)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n       vector<string> ans;\\n        if(s.length()>12) //length must be less than 12\\n        {\\n            return ans;\\n        }\\n        string x;\\n        bt(s,x,0,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215702,
                "title": "python-recursion-no-backtracking",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = set()\\n        if len(s) < 4 or len(s) > 12:\\n            return ans\\n        \\n        def isValid(num):\\n            if not num:\\n                return False\\n            if len(num) == 1:\\n                return True\\n            if len(num) > 3:\\n                return False\\n            if num.startswith(\\'0\\'):\\n                return False\\n            if int(num) > 255:\\n                return False\\n            return True\\n        \\n        def dfs(curr_index, address_till_now, number_of_points):\\n            if number_of_points == 3:\\n                if isValid(s[curr_index: ]):\\n                    new_address = address_till_now + \\'.\\'+ s[curr_index: ]\\n                    ans.add(new_address[1:])\\n                return \\n            for next_index in [curr_index + 1, curr_index + 2, curr_index + 3]:\\n                if isValid(s[curr_index: next_index]):\\n                    dfs(next_index, address_till_now + \\'.\\' + s[curr_index: next_index], number_of_points + 1)\\n                    \\n        dfs(0, \\'\\', 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = set()\\n        if len(s) < 4 or len(s) > 12:\\n            return ans\\n        \\n        def isValid(num):\\n            if not num:\\n                return False\\n            if len(num) == 1:\\n                return True\\n            if len(num) > 3:\\n                return False\\n            if num.startswith(\\'0\\'):\\n                return False\\n            if int(num) > 255:\\n                return False\\n            return True\\n        \\n        def dfs(curr_index, address_till_now, number_of_points):\\n            if number_of_points == 3:\\n                if isValid(s[curr_index: ]):\\n                    new_address = address_till_now + \\'.\\'+ s[curr_index: ]\\n                    ans.add(new_address[1:])\\n                return \\n            for next_index in [curr_index + 1, curr_index + 2, curr_index + 3]:\\n                if isValid(s[curr_index: next_index]):\\n                    dfs(next_index, address_till_now + \\'.\\' + s[curr_index: next_index], number_of_points + 1)\\n                    \\n        dfs(0, \\'\\', 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944975,
                "title": "java-backtrack-solution-with-complexity-explanation",
                "content": "Let\\'s define general problem: given string `s`, find all possible groups of `M` numbers with each number at most `K` digit length. The time complexity of this code will be `O(MK\\xB2 K^M)`. Here is the code with comments.\\nIn reality a lot of  unnecessary branches are deleted, so this complexity is upper bound. Also, we can improve complexity to `O(MK K^M)`\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        backtrack(s, result, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(String s, List<String> result, List<String> cur, int index) { // O(MK\\xB2) per node, at most K^M nodes\\n        if (index >= s.length()) {\\n            if (cur.size() == 4) {\\n                result.add(String.join(\".\", cur)); // O(M)\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (cur.size() == 4) {\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) { // O(K)\\n            int value = Integer.parseInt(s.substring(index, index + i)); // O(K)\\n            \\n            if (value >= 0 && value <= 255 && Integer.toString(value).length() == i) {\\n                cur.add(Integer.toString(value));\\n                backtrack(s, result, cur, index + i);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        backtrack(s, result, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(String s, List<String> result, List<String> cur, int index) { // O(MK\\xB2) per node, at most K^M nodes\\n        if (index >= s.length()) {\\n            if (cur.size() == 4) {\\n                result.add(String.join(\".\", cur)); // O(M)\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (cur.size() == 4) {\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) { // O(K)\\n            int value = Integer.parseInt(s.substring(index, index + i)); // O(K)\\n            \\n            if (value >= 0 && value <= 255 && Integer.toString(value).length() == i) {\\n                cur.add(Integer.toString(value));\\n                backtrack(s, result, cur, index + i);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838805,
                "title": "simple-js-backtrack-solution-with-comments-beat-97",
                "content": "```\\n// for every ip field, it can be 1 to 3 digits slice the current s and pass the remain s to next recursive\\n// the backtrack is if the sliced ip field is valid then go to next recursive\\n\\nvar restoreIpAddresses = function(s) {\\n  const res = [];\\n  if(s.length < 4) return res;\\n  dfs([], s, res);\\n  return res;\\n};\\n\\n\\nfunction dfs(tmp, s, res) {\\n  if(tmp.length === 4) {\\n    if(s === \\'\\') res.push(tmp.join(\\'.\\'));\\n    return;\\n  }\\n  \\n  for(let i = 1; i <= 3; i++) {\\n    if(s.length >= i) {\\n      const ipItem = s.slice(0, i);\\n      const ipItemVal = parseInt(ipItem);\\n      if(ipItemVal >= 0 && ipItemVal <= 255 && ipItem === ipItemVal.toString()) {\\n        dfs([...tmp, ipItem], s.slice(i), res);\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// for every ip field, it can be 1 to 3 digits slice the current s and pass the remain s to next recursive\\n// the backtrack is if the sliced ip field is valid then go to next recursive\\n\\nvar restoreIpAddresses = function(s) {\\n  const res = [];\\n  if(s.length < 4) return res;\\n  dfs([], s, res);\\n  return res;\\n};\\n\\n\\nfunction dfs(tmp, s, res) {\\n  if(tmp.length === 4) {\\n    if(s === \\'\\') res.push(tmp.join(\\'.\\'));\\n    return;\\n  }\\n  \\n  for(let i = 1; i <= 3; i++) {\\n    if(s.length >= i) {\\n      const ipItem = s.slice(0, i);\\n      const ipItemVal = parseInt(ipItem);\\n      if(ipItemVal >= 0 && ipItemVal <= 255 && ipItem === ipItemVal.toString()) {\\n        dfs([...tmp, ipItem], s.slice(i), res);\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817580,
                "title": "my-simple-dfs-python-solution-beat-99-14",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        ret = []\\n        self.dfs(ret, s, [])\\n        return ret\\n\\n    def dfs(self, ret, s, path_list):\\n        if len(path_list) == 4:\\n            if s == \\'\\':\\n                ret.append(\\'.\\'.join(path_list))\\n            return\\n        if not s:\\n            return\\n        if s[0] == \\'0\\':\\n            temp_path_list = path_list[::]\\n            temp_path_list.append(\\'0\\')\\n            self.dfs(ret, s[1:], temp_path_list)\\n            return\\n        for i in range(len(s)):\\n            if i >= 3:\\n                break\\n            if int(s[:i + 1]) <= 255:\\n                temp_path_list = path_list[::]\\n                temp_path_list.append(s[:i + 1])\\n                self.dfs(ret, s[i + 1:], temp_path_list)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        ret = []\\n        self.dfs(ret, s, [])\\n        return ret\\n\\n    def dfs(self, ret, s, path_list):\\n        if len(path_list) == 4:\\n            if s == \\'\\':\\n                ret.append(\\'.\\'.join(path_list))\\n            return\\n        if not s:\\n            return\\n        if s[0] == \\'0\\':\\n            temp_path_list = path_list[::]\\n            temp_path_list.append(\\'0\\')\\n            self.dfs(ret, s[1:], temp_path_list)\\n            return\\n        for i in range(len(s)):\\n            if i >= 3:\\n                break\\n            if int(s[:i + 1]) <= 255:\\n                temp_path_list = path_list[::]\\n                temp_path_list.append(s[:i + 1])\\n                self.dfs(ret, s[i + 1:], temp_path_list)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1767147,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1564690,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1696219,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767384,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567853,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1565487,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1566476,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567190,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1573001,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767612,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767147,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1564690,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1696219,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767384,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567853,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1565487,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1566476,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567190,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1573001,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767612,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767434,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767409,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767087,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767819,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767353,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767299,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1985960,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1973018,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1969609,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1853189,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1809457,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1798472,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1769855,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768530,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768193,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768189,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768071,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768051,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768005,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1767964,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1767956,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767955,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767915,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767914,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767893,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767864,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767847,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767837,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767815,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767610,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767556,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767398,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767396,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767395,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767357,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767354,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767352,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767348,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767347,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767346,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Valid Phone Numbers",
        "question_content": "<p>Given a text file <code>file.txt</code> that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.</p>\n\n<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>\n\n<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>file.txt</code> has the following content:</p>\n\n<pre>\n987-123-4567\n123 456 7890\n(123) 456-7890\n</pre>\n\n<p>Your script should output the following valid phone numbers:</p>\n\n<pre>\n987-123-4567\n(123) 456-7890\n</pre>\n",
        "solutions": [
            {
                "id": 2254239,
                "title": "bash-simple-regular-expression-with-explanation",
                "content": "\\n```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```\\nthis is a grep command accepting two regular expressions\\n1 .```^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\\n2 .```^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\\n\\nThe construction is as follows \\n* ^: indicates the starting of the string\\n* $: indicates the end of the string\\n* [0-9]\\\\\\\\{3\\\\\\\\} : represent 3 numbers (\\\\\\\\{3\\\\\\\\})  between the range 0-9 ([0-9] a digit in the range) \\n* \\\\\\\\: suppresses the specialness of the character\\n* -e: to include multiple regex",
                "solutionTags": [],
                "code": "```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```\n```^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\n```^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```",
                "codeTag": "Unknown"
            },
            {
                "id": 2206032,
                "title": "simple-bash-solutions-explained-grep-awk",
                "content": "I have compiled a list of possible solutions using grep or awk as well as explaining the tools/syntax used. Hope it helps!\\n\\n**Common syntax explained:**\\n* `^` Start of a line (not just within a line, ex `112-122-2313` **not** `022121-112-2313`)\\n* `[0-9]` regex expression to represent any digit between 0 and 9.\\n* `\\\\d` any digit (Perl-flavoured regular expression) *Note the compiler uses GNU/Linux so to use \\\\d use the `-P` tag*\\n* `{3}` repeated exactly 3 times, `{4}` repeated 4 times ect, hence `[0-9]{3}` means three numbers from 0-9.\\n* `$` end of a line\\n* `|` or expression\\n* `()` used to group expressions\\n* `\\\\(` or`\\\\)` used for literal parentheses \\n\\n\\n##### 1. Using a `grep` search with the extended regular expressions.\\n`-E` Extended regular expressions same as `egrep`\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\\nor\\n```\\negrep \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\\n\\n\\n##### 2. Using `grep` with Perl-flavoured regular expression\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n\\n##### 3. Using an `awk` search with regex values\\n```\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\n```\\negrep \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492218,
                "title": "small-regex-100-faster",
                "content": "```\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 661297,
                "title": "valid-numbers",
                "content": "```\\nPlease find the solution : \\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n\\nExplaination : \\ngrep -P \\u2018^()\\n\\nWhat in these parentheses should come in the beginning.\\ngrep -P \\u2018^(\\\\d{3}-\\n\\\\d{3}  - means 3 digits should come in these parenthesis.\\nGrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\u2019\\n| = Means Or\\n\\\\(\\\\d{3}\\\\) )\\u2019 = \\\\d{3}\\\\ means it should contain 3 digit  and a space\\n\\ngrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\u2019\\n\\\\d{3}-\\\\d{4} = means 3 digits and 4 digits\\n\\n\\nReference : https://www.***.org/regular-expression-grep/",
                "solutionTags": [],
                "code": "```\\nPlease find the solution : \\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n\\nExplaination : \\ngrep -P \\u2018^()\\n\\nWhat in these parentheses should come in the beginning.\\ngrep -P \\u2018^(\\\\d{3}-\\n\\\\d{3}  - means 3 digits should come in these parenthesis.\\nGrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\u2019\\n| = Means Or\\n\\\\(\\\\d{3}\\\\) )\\u2019 = \\\\d{3}\\\\ means it should contain 3 digit  and a space\\n\\ngrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\u2019\\n\\\\d{3}-\\\\d{4} = means 3 digits and 4 digits\\n\\n\\nReference : https://www.***.org/regular-expression-grep/",
                "codeTag": "Unknown"
            },
            {
                "id": 843424,
                "title": "bash-easy-one-liner",
                "content": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558581,
                "title": "bash-grep-bre-ere-pcre",
                "content": "Regular exrepssion (regex) has at least 3 official flavors: \\n1) basic regex (BRE)\\n2) extended regex (ERE)\\n3) perl-compatible regex (PCRE)\\n\\nThey share great resemblance and yet differ in details. Below implementation uses `grep` as an example which by default applies BRE. `-E` turns on ERE and `-P` turns on PCRE. \\n\\n```\\ngrep \"^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt # BRE\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |^[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"      file.txt # ERE\\ngrep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\"                   file.txt #PCRE\\n```",
                "solutionTags": [],
                "code": "```\\ngrep \"^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt # BRE\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |^[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"      file.txt # ERE\\ngrep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\"                   file.txt #PCRE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474498,
                "title": "this-solution-is-faster-than-100-00-of-bash-online-submissions-for-valid-phone-numbers",
                "content": "```\\negrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\negrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362277,
                "title": "simple-the-interviewer-who-asked-this-question-should-be-disqualified-from-interview-panel",
                "content": "Simple: the interviewer who asked this question should be disqualified from interview panel.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1477728,
                "title": "two-one-line-solution-grep-or-sed-unix-solution",
                "content": "grep (find the numbers which are matched, which is straight-forward):\\n```\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\\nsed (delete the numbers which are mismatched):\\n```\\nsed \\'/^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/!d\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\n```\\nsed \\'/^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/!d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 380998,
                "title": "why-is-this-failing-when-it-works-locally",
                "content": "```\\ngrep -E -o \"\\\\((\\\\d{3})) \\\\d{3}-\\\\d{4}|\\\\d{3}-\\\\d{3}-\\\\d{4}\" file.txt\\n```\\n\\npasses 21/26 test cases but not \\n123-456-7891 ?",
                "solutionTags": [],
                "code": "```\\ngrep -E -o \"\\\\((\\\\d{3})) \\\\d{3}-\\\\d{4}|\\\\d{3}-\\\\d{3}-\\\\d{4}\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733675,
                "title": "grep-easy-pattern-matching",
                "content": "```\\n# GREP stands for Global search for Regular Expression and Print out\\n# grep [options] pattern [files]\\n# This is the syntax.\\n\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\nPlease **UpVote**, if you understood the code.",
                "solutionTags": [],
                "code": "```\\n# GREP stands for Global search for Regular Expression and Print out\\n# grep [options] pattern [files]\\n# This is the syntax.\\n\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468126,
                "title": "simplest-regex",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n#   ^ -> Start of the Line.\\n#   $ -> End of the Line.\\n#   ([0-9]) -> Value Range can be between 0 to 9.\\n#   ([0-9]{3}) -> Value Range can be between 0 to 9 and repeats three times.\\n#   (a | b) -> Possible values are a or b.\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n#   ^ -> Start of the Line.\\n#   $ -> End of the Line.\\n#   ([0-9]) -> Value Range can be between 0 to 9.\\n#   ([0-9]{3}) -> Value Range can be between 0 to 9 and repeats three times.\\n#   (a | b) -> Possible values are a or b.\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 834603,
                "title": "solution-0ms-100-3-1mb",
                "content": "```bash\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 87.19% of Bash online submissions for Valid Phone Numbers.\\negrep \"^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 87.19% of Bash online submissions for Valid Phone Numbers.\\negrep \"^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218882,
                "title": "193-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\n- grep command is used to search for a pattern in a file or files.\\n- -E option is used to enable extended regular expressions.\\n```\\n\\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' \\n``` \\nis the regular expression pattern that we want to match against each line in the file.\\n- ^ and $ are used to specify the beginning and end of the line respectively, to ensure that the entire line matches the pattern.\\n- \\\\( and \\\\) are used to match parentheses, which are escaped with backslashes because they have special meaning in regular expressions.\\n- [0-9]{3} is used to match exactly three digits.\\n- | is used to specify an alternative match, either a group of three digits surrounded by parentheses, followed by a space, or a group of three digits separated by a hyphen.\\n- file.txt is the name of the file that we want to search.\\n\\nThis regular expression matches phone numbers in the format (xxx) xxx-xxxx or xxx-xxx-xxxx.\\n\\nThe output of this one-liner bash script will be the list of valid phone numbers in the file.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n\\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' \\n```\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1154012,
                "title": "grep-p-solution",
                "content": "## Intro\\n\\nThis is a simple Perl RegEx solution. It requires no other commands. If additional challenges were added, this may become a bit too noisy as a one liner.\\n\\n## Solution\\n\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4}$\\' file.txt \\n```\\n\\n## Breakdown\\n\\nWe start off with the start of line (`^`) check. Without this, we could hit invalid entries that say start with other characters.\\n\\n`(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)` - This is a group selector inside the outer parentheses (`()`), which is primarily for the usage of the pipe (`|`) which is used as an or. So to break it down further:\\n\\n```\\n(\\n\\t\\\\(\\\\d{3}\\\\) \\n|\\n\\t\\\\d{3}-\\n)\\n```\\n\\nSo we have two different start of line options, only matching the two possibilities we have. The top one is selecting a literal open parantheses, 3 digits, and a literal closing parantheses, followed by a space. Using curly braces with a number inside can be used to represent how many of a given character prior should exist. So this says 3 `\\\\d` should exist. `\\\\d` is any digit, same as `[0-9]`.\\n\\nThe bottom searchers for 3 digits followed by a hyphen.\\n\\n```\\n\\\\d{3}\\\\-\\\\d{4}$\\n```\\n\\nWhat remains is 3 digits, a literal hyphen, and 4 digits, then end of line. We must anchor to the end of line using `$`, as sometimes there may be trailing whitespace or other characters.",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4}$\\' file.txt \\n```\n```\\n(\\n\\t\\\\(\\\\d{3}\\\\) \\n|\\n\\t\\\\d{3}-\\n)\\n```\n```\\n\\\\d{3}\\\\-\\\\d{4}$\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122020,
                "title": "short-solution-using-grep-with-explanation",
                "content": "**One-liner solution**\\n```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\\n\\n**^ symbol for must begin with, xxx- OR \\'(xxx) \\' quoted for space.**\\n```\\n^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)\\n```\\n\\n**$ symbol for must end with xxx-xxxx**\\n```\\n[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\n```\\n\\n**where x\\'s are digits**",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\n```\\n^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)\\n```\n```\\n[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413833,
                "title": "grep-only-0ms-extended-regex-and-regex",
                "content": "```BASH\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 4 ms, faster than 55.11% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\|[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\)$\\' file.txt\\n```\\n\\n- https://www.gnu.org/software/grep/manual/grep.html\\n**-E**\\n**--extended-regexp**\\nInterpret patterns as extended regular expressions (EREs). (-E is specified by POSIX.)\\n\\n- https://www.zyxware.com/articles/4627/difference-between-grep-and-egrep\\n In egrep, +, ?, |, (, and ),  treated as meta characters. Where as in grep, they are rather treated as pattern instead of meta characters. By including \\'backslash\\' followed by meta character can let the grep to treat it as meta characters like \\\\?, \\\\+, \\\\{, \\\\|, \\\\(, and \\\\). \\n",
                "solutionTags": [],
                "code": "```BASH\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 4 ms, faster than 55.11% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\|[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\)$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55474,
                "title": "simple-solution-using-awk",
                "content": "```\\nawk '/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk '/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2722034,
                "title": "one-line-bash-solution",
                "content": "`grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt`",
                "solutionTags": [],
                "code": "`grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 1290845,
                "title": "awk-and-regex",
                "content": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4}|\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4}|\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038346,
                "title": "grep-regex",
                "content": "```\\ngrep -o \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -o \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276464,
                "title": "grep-solution-beats-100",
                "content": "A easy way to get it by using grep\\n\\n-E means use regular expression\\n\\n```\\ncat file.txt | grep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199579,
                "title": "one-line-grep-e",
                "content": "```\\ngrep -E  -e \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E  -e \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55492,
                "title": "my-grep-e-solution",
                "content": "    # Read from the file file.txt and output all valid phone numbers to stdout.\\n    \\n    # use grep -P\\n    grep -P '^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and output all valid phone numbers to stdout.\\n    \\n    # use grep -P\\n    grep -P '^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2562390,
                "title": "simple-sol-using-grep",
                "content": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259212,
                "title": "proper-grep-solution-with-standard-pcre-regex",
                "content": "Easy to understand what is going on.\\n\\nGrep flags used:\\n* \\t```-o``` for printing results in newline\\n* \\t```-P``` to enable standard PCRE regex matching followed by the regex expression.\\n\\n```\\ngrep -o -P \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```-o```\n```-P```\n```\\ngrep -o -P \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035332,
                "title": "grep-e",
                "content": "here is my code.\\nI use grep with extended RE.\\n`[0-9]{3}` means digit exactly 3 times\\n`^` is start of line\\n`$` is end of line\\n`|` is alternative\\n`()` are for grouping\\n`\\\\(` `\\\\)` are literally parentasis (not interpered as grouping)\\n```bash\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4}$)|^(\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4}$)|^(\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903384,
                "title": "grep-e-solution-with-regex",
                "content": "## grep -E Solution with regex\\n--- \\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604453,
                "title": "0ms-solution-100-faster",
                "content": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196980,
                "title": "sed-regex-1-liner-explanation",
                "content": "## Explanation\\nThe idea is to local certain pattern and print them out. `regex` is the perfect choice to locate the pattern. `sed` can be a easy to use helper here.\\n\\nThere are 2 patterns needed:\\n- For `123-456-7890`, we can use pattern like this\\n\\t- `^[0-9]{3}-[0-9]{3}-[0-9]{4}$`\\n\\t- Meaning starting with 3 digits (`^[0-9]{3}`), then a dash `-`, another 3 digits (`[0-9]{3}`) with a dash `-`, then ending with 4 digits (`[0-9]{4}$`)\\n- For `(123) 456-7890`, pattern will be like\\n\\t- `^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$`\\n\\t- Meaning starting with a open parenthesis `\\\\(` need to use back slash to escape, then 3 digits (`[0-9]{3}`) and a ending parenthesis `\\\\)`, then a space ` `, the rest will be similar to the first pattern\\n\\nIn `sed`:\\n- `-n`: is to silence the auto printout (default by `sed`)\\n- `-r`: is to use extended regex \\n\\n## Implementation\\n```bash\\n# Implementation with 2 patterns\\nsed -nr \\'/^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/p\\' file.txt\\n\\n# If we merge the similar part, the regex will be like\\nsed -nr \\'/(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\n# Implementation with 2 patterns\\nsed -nr \\'/^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/p\\' file.txt\\n\\n# If we merge the similar part, the regex will be like\\nsed -nr \\'/(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989190,
                "title": "grep-extended-regex",
                "content": "```\\ngrep -E \"^[0-9]{3}[-]{1}[0-9]{3}[-]{1}[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ {1}[0-9]{3}[-]{1}[0-9]{4}$\" file.txt",
                "solutionTags": [],
                "code": "```\\ngrep -E \"^[0-9]{3}[-]{1}[0-9]{3}[-]{1}[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ {1}[0-9]{3}[-]{1}[0-9]{4}$\" file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2953181,
                "title": "just-bash-regex",
                "content": "Using bash regex only.\\nRead a file line by line, first check the simple expression in case most of the phone numbers will be in a simpler format.\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nwhile read line; do if [[ $line =~ (^[0-9]{3}-[0-9]{3}-[0-9]{4}$) || $line =~ (^\\\\([0-9]{3}\\\\)[ ]{1}[0-9]{3}-[0-9]{4}$) ]]; then echo $line; fi; done < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nwhile read line; do if [[ $line =~ (^[0-9]{3}-[0-9]{3}-[0-9]{4}$) || $line =~ (^\\\\([0-9]{3}\\\\)[ ]{1}[0-9]{3}-[0-9]{4}$) ]]; then echo $line; fi; done < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709293,
                "title": "bash-one-liner",
                "content": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310460,
                "title": "bash-cat-grep",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"(^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3,3}\\\\) [0-9]{3}-[0-9]{4}$)\"\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"(^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3,3}\\\\) [0-9]{3}-[0-9]{4}$)\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950357,
                "title": "this-solution-can-not-be-more-uglier-but-hey-at-least-it-works-d",
                "content": "\\tpublic static boolean isValid(String num){\\n\\t\\t\\tnum.trim();\\n\\t\\t\\tString[] tokens0 = num.split(\" +\");\\n\\t\\t\\tif (tokens0.length == 3) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tString[] tokens = num.split(\"\\\\\\\\-\" );\\n\\t\\t\\tif (tokens.length == 3) {\\n\\t\\t\\t\\tif (tokens[0].length() == 3 && tokens[1].length() == 3 && tokens[2].length() == 4 && onlyDigits(tokens[0]) && onlyDigits(tokens[1]) && onlyDigits(tokens[2])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return false;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (tokens.length == 2) {\\n\\t\\t\\t\\tif (tokens[0].charAt(0) == \\'(\\' && tokens[0].charAt(4) == \\')\\'  && onlyDigits(tokens[0].substring(1 , 4)) && onlyDigits(tokens[0].substring(6)) && onlyDigits(tokens[1])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0 ; i < tokens.length ; i++) {\\n\\t\\t\\t\\tSystem.out.println(tokens[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic static boolean onlyDigits(String str) {\\n\\t\\t\\tfor (int i = 0; i < str.length(); i++) {\\n\\t\\t\\t\\tif (str.charAt(i) >= \\'0\\'\\n\\t\\t\\t\\t\\t\\t&& str.charAt(i) <= \\'9\\') return true;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic static boolean isValid(String num){\\n\\t\\t\\tnum.trim();\\n\\t\\t\\tString[] tokens0 = num.split(\" +\");\\n\\t\\t\\tif (tokens0.length == 3) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tString[] tokens = num.split(\"\\\\\\\\-\" );\\n\\t\\t\\tif (tokens.length == 3) {\\n\\t\\t\\t\\tif (tokens[0].length() == 3 && tokens[1].length() == 3 && tokens[2].length() == 4 && onlyDigits(tokens[0]) && onlyDigits(tokens[1]) && onlyDigits(tokens[2])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return false;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (tokens.length == 2) {\\n\\t\\t\\t\\tif (tokens[0].charAt(0) == \\'(\\' && tokens[0].charAt(4) == \\')\\'  && onlyDigits(tokens[0].substring(1 , 4)) && onlyDigits(tokens[0].substring(6)) && onlyDigits(tokens[1])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0 ; i < tokens.length ; i++) {\\n\\t\\t\\t\\tSystem.out.println(tokens[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic static boolean onlyDigits(String str) {\\n\\t\\t\\tfor (int i = 0; i < str.length(); i++) {\\n\\t\\t\\t\\tif (str.charAt(i) >= \\'0\\'\\n\\t\\t\\t\\t\\t\\t&& str.charAt(i) <= \\'9\\') return true;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 619864,
                "title": "grep-e-approach-simplified",
                "content": "```\\ngrep -E \\'^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345439,
                "title": "grep-e-solution-is-pretty-straightforward-to-me-why-doesn-t-this-work-any-ideas",
                "content": "```\\ngrep -e \"\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\" -e \"(\\\\d\\\\d\\\\d) \\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\"\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep -e \"\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\" -e \"(\\\\d\\\\d\\\\d) \\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315493,
                "title": "grep-e-solution",
                "content": "```grep -e \\'^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' -e \\'^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt```",
                "solutionTags": [],
                "code": "```grep -e \\'^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' -e \\'^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 307062,
                "title": "using-bash-regex",
                "content": "```\\n#!/usr/bin/env bash\\n\\nwhile read line; do\\n    if [[ \"$line\" =~ ^((\\\\([0-9]{3}\\\\) )|[0-9]{3}-)[0-9]{3}-[0-9]{4}$ ]]; then\\n        echo $line\\n    fi\\ndone < \"file.txt\"\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/env bash\\n\\nwhile read line; do\\n    if [[ \"$line\" =~ ^((\\\\([0-9]{3}\\\\) )|[0-9]{3}-)[0-9]{3}-[0-9]{4}$ ]]; then\\n        echo $line\\n    fi\\ndone < \"file.txt\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134523,
                "title": "why-is-grep-e-d-3-d-3-d-4-d-3-d-3-d-4-file-txt-wrong",
                "content": "```\\ngrep -E \\'^\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}$|^\\\\d{3}-\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\nError message:\\n\\n```\\nInput:\\n123-456-7891\\nExpected:\\n123-456-7891\\n```\\n\\n\\nHowever, the following works:\\n\\n```\\ngrep -E \\'^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nThe only difference is `[0-9]` instead of `\\\\d`.\\n\\nOn my laptop (macOS), both work.",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}$|^\\\\d{3}-\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\nInput:\\n123-456-7891\\nExpected:\\n123-456-7891\\n```\n```\\ngrep -E \\'^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519756,
                "title": "easy-and-simple-0-wow-0-0",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```\\nThis script uses grep command with extended regular expressions (-E) to match the pattern of valid phone numbers. The pattern matches either (xxx) xxx-xxxx or xxx-xxx-xxxx format. The ^ and $ characters are used to match the beginning and end of each line respectively13",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524504,
                "title": "simple-solution-with-grep-e-with-or-detail-explanation",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nFor detail explnation please refer:\\nhttps://leet-codes.blogspot.com/2022/09/193-valid-phone-numbers.html\\n",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400775,
                "title": "one-line-grep-command",
                "content": "`grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt`",
                "solutionTags": [],
                "code": "`grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 2297326,
                "title": "regex-runtime-649-ms-faster-than-5-46-of-go-submissions",
                "content": "**Complexity Analysis**\\n* Time: O(N), where N is the number of lines within the file.txt.\\n* Space: O(1), constant number of variables used.\\n\\n```sh\\nfunction isValid()\\n{\\n  if [[ $1 =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  if [[ $1 =~ ^[(][0-9]{3}[)][[:space:]][0-9]{3}[-][0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  return $(false)\\n}\\n\\nIFS=$\\'\\\\n\\'\\nfor i in $(cat file.txt); do\\n  if isValid $i; then\\n    echo $i\\n  fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```sh\\nfunction isValid()\\n{\\n  if [[ $1 =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  if [[ $1 =~ ^[(][0-9]{3}[)][[:space:]][0-9]{3}[-][0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  return $(false)\\n}\\n\\nIFS=$\\'\\\\n\\'\\nfor i in $(cat file.txt); do\\n  if isValid $i; then\\n    echo $i\\n  fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2241958,
                "title": "one-line-solution-with-regex",
                "content": "Here is my solution:\\n\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nor \\n\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112639,
                "title": "bash-easy-one-liner",
                "content": "https://leetcode.com/problems/valid-phone-numbers/discuss/843424/BASH-Easy-One-Liner\\n\\n```\\n1) grep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```\\n\\n```\\n2) grep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n```\\n3) egrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n1) grep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```\n```\\n2) grep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\n3) egrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713083,
                "title": "grep-runtime-4-ms-memory-usage-3-1-mb",
                "content": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1413815,
                "title": "0ms-solution-100-faster",
                "content": "```grep -P \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" file.txt```",
                "solutionTags": [],
                "code": "```grep -P \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349446,
                "title": "egrep-solution-with-cat",
                "content": "```\\ncat file.txt | egrep  \"^((\\\\([0-9]{3}\\\\) )|([0-9]{3}-))[0-9]{3}-{0,1}[0-9]{4}$\"\\n```\\n",
                "solutionTags": [],
                "code": "```\\ncat file.txt | egrep  \"^((\\\\([0-9]{3}\\\\) )|([0-9]{3}-))[0-9]{3}-{0,1}[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239047,
                "title": "no-grep-solution-actually-works",
                "content": "It took me a while, as some attempts \"work on my machine\" but not here lol. I\\'m sure this can be simplified, but it took me a few hours to get this to work, so will stop here and see if anyone out there improves upon it. Using a slightly shorter regex, and even looking at SO examples, people seem to not care about a number formatted like so `(123 456-7890` where one of the parentheses was missing. It wasn\\'t part of the tested inputs, but I wanted to account for it as an exercise.\\n\\nSo, I just resorted to using the `|` (or) operator to check both formats. It was key to include `^$` both times as without it, the regex would match the number \"0(001...\".\\n\\n\\n```\\n#!/bin/bash\\n\\ncat file.txt | while read line\\ndo\\n  if [[ \"$line\" =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ [0-9]{3}-[0-9]{4}$ ]]; then\\n    echo $line\\n  fi  \\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ncat file.txt | while read line\\ndo\\n  if [[ \"$line\" =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ [0-9]{3}-[0-9]{4}$ ]]; then\\n    echo $line\\n  fi  \\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027254,
                "title": "grep-p",
                "content": "```grep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\" file.txt```",
                "solutionTags": [],
                "code": "```grep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\" file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 703796,
                "title": "query-related-to-input",
                "content": "Can anyone tell me why this input is not valid \\n```(001)-345-0000```\\n\\nthis is my bash one liner\\n```grep -P \\'^(\\\\(?\\\\d{3}|\\\\d{3})\\\\)?[\\\\s|-]\\\\d{3}-\\\\d{4}$\\' file.txt```\\n\\nit also accepts the above number but gets an error saying it should not get accepted\\n",
                "solutionTags": [],
                "code": "```(001)-345-0000```\n```grep -P \\'^(\\\\(?\\\\d{3}|\\\\d{3})\\\\)?[\\\\s|-]\\\\d{3}-\\\\d{4}$\\' file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 576595,
                "title": "grep-e",
                "content": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n\\n",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 553002,
                "title": "mac-bash-or-linux-bash",
                "content": "At first, I use this code:\\n```\\ncat file.txt | grep -E \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\)\\\\ )\\\\d{3}-\\\\d{4}$\"\\n```\\nIt works in my mac bash shell, but failed for the submission.\\nThen I changed my code to below:\\n```\\ncat file.txt | grep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\)\\\\ )[0-9]{3}-[0-9]{4}$\"\\n```\\nThen passed...",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\)\\\\ )\\\\d{3}-\\\\d{4}$\"\\n```\n```\\ncat file.txt | grep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\)\\\\ )[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434768,
                "title": "solution-without-grep-awk-sed",
                "content": "```\\nwhile read LINE; do if [[ $LINE =~ (^\\\\([0-9]{3}\\\\)[[:blank:]][0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$) ]]; then echo $LINE; fi; done < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nwhile read LINE; do if [[ $LINE =~ (^\\\\([0-9]{3}\\\\)[[:blank:]][0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$) ]]; then echo $LINE; fi; done < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429265,
                "title": "trivial-awk-solution-probably-been-posted-before",
                "content": "```\\nawk -e \\'/^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/{ print; }\\' file.txt;\\n```",
                "solutionTags": [],
                "code": "```\\nawk -e \\'/^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/{ print; }\\' file.txt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399441,
                "title": "time-0ms-beats-100-with-memory-3-1-mb-simple-using-regex-grep",
                "content": "```\\ncat file.txt | grep -E \"(^[0-9]{3}-|^\\\\([0-9]{3}\\\\)\\\\s)[0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"(^[0-9]{3}-|^\\\\([0-9]{3}\\\\)\\\\s)[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331165,
                "title": "grep-p-solution-using-conditional-regex-with-explanation",
                "content": "Conditional regular expressions are not always the most efficient solution. However, they _can_ be really useful in reducing the length of the regular expression by removing a long \"or\" statement with repeating elements. This is not one of those cases, but it\\'s a fun solution. The downside is that they are harder to read.\\n\\n```bash\\ngrep -xP \\'(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\\n\\n`(\\\\()?` - capture opening parenthesis at start as group 1, if it exists\\n`\\\\d{3}` - 3 digit area code\\n`(?(1)\\\\) |-)` - If an opening parenthesis was captured as group 1, grab a closing parenthesis followed by a space. Otherwise, look for a dash.\\n`\\\\d{3}-\\\\d{4}` - get the rest of the number.\\n\\nThis is effectively equivalent to \\n```bash\\ngrep -xP \\'(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```bash\\ngrep -xP \\'(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\n```bash\\ngrep -xP \\'(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319401,
                "title": "egrep-solution",
                "content": "```\\ncat file.txt | egrep \\'^(\\\\([[:digit:]]{3}\\\\) |[[:digit:]]{3}-)[[:digit:]]{3}-[[:digit:]]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | egrep \\'^(\\\\([[:digit:]]{3}\\\\) |[[:digit:]]{3}-)[[:digit:]]{3}-[[:digit:]]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274502,
                "title": "egrep-solution",
                "content": "```bash\\ncat file.txt | egrep \\'^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```bash\\ncat file.txt | egrep \\'^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261478,
                "title": "fastest-awk-solution-8ms",
                "content": "```awk\\nawk \\'{if($0 ~ /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/ || $0 ~ /^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/){printf $0\"\\\\n\"}}\\' file.txt\\n```\\n\\nSimply processes each line and checks if the entire record (default newline separated) has exactly the needed formats specified and prints each line that does.",
                "solutionTags": [],
                "code": "```awk\\nawk \\'{if($0 ~ /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/ || $0 ~ /^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/){printf $0\"\\\\n\"}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182286,
                "title": "grep",
                "content": "Never use solutions like these.\nDebugging this would be hell.\n```\ngrep \"^\\(\\([0-9]\\{3\\}-\\)\\|\\(([0-9]\\{3\\})\\s\\)\\)[0-9]\\{3\\}-[0-9]\\{4\\}$\" file.txt\n```",
                "solutionTags": [],
                "code": "```\ngrep \"^\\(\\([0-9]\\{3\\}-\\)\\|\\(([0-9]\\{3\\})\\s\\)\\)[0-9]\\{3\\}-[0-9]\\{4\\}$\" file.txt\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55477,
                "title": "whereis-wrong-with-my-pattern-ask-for-help",
                "content": "my grep solution, the code is like:\\n```\\ngrep \"\\\\(?\\\\d{3}\\\\)?[- ]\\\\d{3}-\\\\d{4}\" file.txt\\n```\\nbut when it came across test case \"123-456-7891\", it didn't print out anything. could someone tell me why please?\\nYet I put test case \"123-456-7891\" into a file, and open it with notepad++ on windows, using the same pattern to find matched lines, and it worked! That really makes me confused",
                "solutionTags": [],
                "code": "```\\ngrep \"\\\\(?\\\\d{3}\\\\)?[- ]\\\\d{3}-\\\\d{4}\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55498,
                "title": "wrong-output-of-shell-question-valid-phone-number",
                "content": "For Shell Question \"valid phone number\", I submitted the below code: \\n\\n     while read LINE\\n     do\\n         if [[ $LINE =~ \"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" ]] || [[ $LINE =~ \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\" ]]; then\\n             echo $LINE\\n         fi\\n     done < 'file.txt'\\n\\nFinally, Leetcode judge my code to wrong output by one input \"123-456-7891\".\\nHowever, such input can be pass from my own test.\\n\\n    ytjiang@xxxxx:~/code_practice % sh ValidPhoneNumber.sh\\n    123-456-7891\\n\\nReally wired me....\\n\\nThanks in advance!",
                "solutionTags": [],
                "code": "For Shell Question \"valid phone number\", I submitted the below code: \\n\\n     while read LINE\\n     do\\n         if [[ $LINE =~ \"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" ]] || [[ $LINE =~ \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\" ]]; then\\n             echo $LINE\\n         fi\\n     done < 'file.txt'\\n\\nFinally, Leetcode judge my code to wrong output by one input \"123-456-7891\".\\nHowever, such input can be pass from my own test.\\n\\n    ytjiang@xxxxx:~/code_practice % sh ValidPhoneNumber.sh\\n    123-456-7891\\n\\nReally wired me....\\n\\nThanks in advance!",
                "codeTag": "Unknown"
            },
            {
                "id": 4077522,
                "title": "it-was-easy",
                "content": "\\u0628\\u0633\\u0645 \\u0627\\u0644\\u0644\\u0647 \\u0627\\u0644\\u0631\\u062D\\u0645\\u0646 \\u0627\\u0644\\u0631\\u062D\\u06CC\\u0645\\n## hello guys!\\nIt was really easy :) . am I rigth?\\nIt was only necessary to use the **`grep`** command and to know **Regex**.\\nu should have written something like this command :\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\nGod bless you and have nice time my friend !!",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076529,
                "title": "bash-script-to-extract-and-print-valid-phone-numbers-from-a-text-file",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find and print valid phone numbers from a text file. We need to define the patterns for valid phone numbers and extract them from the file.\\n\\n\\n# ApproachSpace complexity: The space complexity is constant, as it does not depend on the size of the input file. Therefore, the space complexity is O(1).\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use the grep command with regular expressions to match and extract valid phone numbers from the text file.\\nWe define two regular expressions to match two formats: (xxx) xxx-xxxx and xxx-xxx-xxxx.\\nThe -E option enables extended regular expressions.\\nWe use ^ to match the start of the line and $ to match the end of the line to ensure that we capture complete phone numbers.\\nWe use \\\\( and \\\\) to match parentheses and [0-9]{3} to match exactly three digits.\\nWe use [0-9]{4} to match exactly four digits.\\nThe | character is used to match either of the two formats.\\nFinally, we specify the input file as file.txt to search for valid phone numbers in it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n The grep command operates in linear time based on the size of the input file, making it efficient for large files. So, the time complexity is O(n), where n is the size of the input file.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is constant, as it does not depend on the size of the input file. Therefore, the space complexity is O(1).\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024485,
                "title": "one-line-solution-with-grep-99-5-performance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCommand checks two pattern in regex\\n1. `xxx-xxx-xxxx`\\n2. `(xxx) xxx-xxxx`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023972,
                "title": "simple-grep-and-regex-with-explanation-95-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe most straight forward approach would be to use grep. grep already knows how to handle multilines so no special treatment required. Next is to just figure out a pattern.\\n\\nThe latter half of the number format share a common pattern, so it should allow me to combine the patterns into a single pattern with a `|` \\'or\\' operator\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first iteration omitted the line beginning/ending, which caught me off guard when the number is invalid when there are more numbers at the ends of it.\\n\\nSome considerations involve which flavor of grep do we want to use?\\nHow complex do we want our code?\\nDo we want to try fix broken formatted numbers?\\n\\nin the end, KISS applies\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ as each line is evaluated just once\\n\\n- Space complexity: $$O(1)$$ you only store matches, at most you\\'d store two copy of the same file in memory\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```\\n`-o` returns only pattern without the full line. It\\'s moot here since the whole line is to be matched, but would be handy if the phone number is hidden between other text.\\n\\n`-E` just enables the extended regex (ERE). See [difference](https://www.gnu.org/software/sed/manual/html_node/BRE-vs-ERE.html) of Basic Regular Expressions (BRE) vs Extended Regular Expressions (ERE). **TL;DR** ERE is more readable and you end up with less `\\\\`.\\n\\n# [Regex Explanation](regexr.com/7jt1e)",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004162,
                "title": "bash-simple-solution-grep",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\n",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962899,
                "title": "one-liner-bash-command-to-get-valid-phone-numbers-with-minimum-complexity",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis script uses grep with the -E flag to enable extended regular expressions. The regular expression used in the script matches either of the valid phone number formats you mentioned. It uses the ^ and $ anchors to match the entire line, ensuring that there are no leading or trailing characters. \\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n\\n```\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938487,
                "title": "using-bash-pattern-matching",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\nIFS=\\'\\n\\'\\nwhile read -r phone; do\\n\\tcase \"$phone\" in\\n\\t\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n\\t\\t\\tprintf \\'%s\\\\n\\' \"$phone\"\\n\\t\\t\\t;;\\n\\tesac\\ndone < file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\nIFS=\\'\\n\\'\\nwhile read -r phone; do\\n\\tcase \"$phone\" in\\n\\t\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n\\t\\t\\tprintf \\'%s\\\\n\\' \"$phone\"\\n\\t\\t\\t;;\\n\\tesac\\ndone < file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926378,
                "title": "simple-shell-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n    \\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n    \\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926363,
                "title": "simple-shell-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]) echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]) echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919277,
                "title": "using-awk-command",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nawk \\'/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nawk \\'/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900004,
                "title": "bash",
                "content": "`grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4} file.txt`",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "`grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4} file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 3892269,
                "title": "bash-with-regular-expression-and-grep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n#!/bin/bash\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n#!/bin/bash\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881004,
                "title": "faster-than-99-54",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855494,
                "title": "bash-expected-solution-grep-and-regex",
                "content": "# Solution\\n```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833012,
                "title": "grep-regex-full-regex-step-by-step-explanation",
                "content": "# Approach\\n`grep` is a CLI tool that can be used to extract text from a file (among other things) that matches a regular expression (RegEx).\\n\\nFirst, `grep` can be used like `grep -E \\'\\' file.txt` where the regular expression goes inside the `\\'\\'`.\\n\\nTo denote that the full string is matched, `^` and `$` is used to denote start of the string and end of the string respectively. So regex is now `^$`.\\n\\nEach `x` represents a digit, which is `[0-9]` in RegEx. `xxx` denotes exactly 3 digits, which can be represented as `[0-9]{3}` in Regex, while `-` and ` ` can be matched by `-` and ` ` respectively. Also `(` and `)` can be matched by `\\\\(` and `\\\\)` (`(` and `)` need to be escaped using the `\\\\` as without escaping, they represent a group in RegEx).\\n\\nSo `xxx-xxx-xxxx` can be matched by `^[0-9]{3}-[0-9]{3}-[0-9]{4}$` and `(xxx) xxx-xxxx` can be matched by `^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$`.\\n\\nCombining these with an OR gives the final regex as:\\n`^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$`\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807278,
                "title": "bash-egrep",
                "content": "```\\n#!/bin/bash\\n\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/bash\\n\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3792036,
                "title": "simple-solution-using-grep-extended-and-regex",
                "content": "# Intuition\\nTo output patterns that matches either of the two cases, we can use regex for pattern matching and grep.\\n\\n# Aproach\\nIn both the cases, the last part of the pattern matching requires \\n1. number `0-9` 3 times - `[0-9]{3}`\\n2. then a `-` \\n3. and then `0-9` 4 times - `[0-9]{4}`\\n4. followed by the end of the line - `dollar sign`.\\n\\nRegex for this would be `[0-9]{3}-[0-9]{4}$`.\\n\\nFor the first part of the pattern, the pattern is either - `\\\\([0-9]{3}\\\\) ` or `[0-9]{3}-`. Start of the line is denoted by `^`\\n\\nThis can be expressed in regex as  `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`\\n\\n\\n# Code\\nFinal regex is the combination of the two regex. We will be using extended grep (by using -E) as the normal grep command does not support some of the regex used here.\\n\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791792,
                "title": "one-line-solution-using-grep-command",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\nin this script uses grep command with (-E) treats as an extended regular expression. it is used for matching the pattern of valid phone numbers.So by this the pattern matches to the (123) 456_7890 or 987-123-4567 format. ^ used for match the beginning and $ used for end of line respectively. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740773,
                "title": "beats-70-online-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706732,
                "title": "valid-phone-numbers-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep -o \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep -o \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3701455,
                "title": "using-grep-p",
                "content": "# Code\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691134,
                "title": "beats-100-and-detailed-explanation",
                "content": "# Intuition\\nThe one-liner bash script aims to extract and print all valid phone numbers from a given text file.\\n\\n# Approach\\nThe one-liner script utilizes the `grep` command with extended regular expression support to extract valid phone numbers from a text file.\\n\\n- `grep -E`: Invokes `grep` with extended regular expression support.\\n- `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`: This part of the pattern matches either \"(xxx) \" or \"xxx-\" at the beginning of a line.\\n- `[0-9]{3}-[0-9]{4}$`: This part matches \"xxx-xxxx\" at the end of a line.\\n- `file.txt`: Represents the input file from which valid phone numbers will be extracted.\\n\\nBy running this one-liner script, it will print all valid phone numbers that match the specified formats from the `file.txt` input file.\\n\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of lines in the input file.\\n- Space complexity: O(1), as the script uses a constant amount of additional space.\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "# Intuition\\nThe one-liner bash script aims to extract and print all valid phone numbers from a given text file.\\n\\n# Approach\\nThe one-liner script utilizes the `grep` command with extended regular expression support to extract valid phone numbers from a text file.\\n\\n- `grep -E`: Invokes `grep` with extended regular expression support.\\n- `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`: This part of the pattern matches either \"(xxx) \" or \"xxx-\" at the beginning of a line.\\n- `[0-9]{3}-[0-9]{4}$`: This part matches \"xxx-xxxx\" at the end of a line.\\n- `file.txt`: Represents the input file from which valid phone numbers will be extracted.\\n\\nBy running this one-liner script, it will print all valid phone numbers that match the specified formats from the `file.txt` input file.\\n\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of lines in the input file.\\n- Space complexity: O(1), as the script uses a constant amount of additional space.\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3675921,
                "title": "bash",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})\\n``` ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669706,
                "title": "two-short-accepted-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` bash []\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n# grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```\\n\\n``` bash []\\n# grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "``` bash []\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n# grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```\n``` bash []\\n# grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660167,
                "title": "mine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659229,
                "title": "use-sed",
                "content": "# Intuition\\nUse `sed`\\n\\n# Approach\\n`BSD sed` accepts a `-E` option for specifying extended (modern) regular expressions.\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(mn)$ - $m, n$ are the maxlength of lines in the file, and number of lines in the file\\n\\n- Space complexity:\\n$O(m)$ - `sed` processes a line of input file at a time held within its memory\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n -E \\'/^(([0-9]{3}-[0-9]{3}-[0-9]{4})|([(][0-9]{3}[)] [0-9]{3}-[0-9]{4}))$/p\\' file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n -E \\'/^(([0-9]{3}-[0-9]{3}-[0-9]{4})|([(][0-9]{3}[)] [0-9]{3}-[0-9]{4}))$/p\\' file.txt\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615463,
                "title": "valid-phone-numbers-intuition-with-image",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![2023-06-09_03-41-45.png](https://assets.leetcode.com/users/images/f47f81e2-c687-4d76-83a2-687590a0cc53_1686262419.4819312.png)\\n\\n\\n# Code\\n```\\ngrep -P \\'^(\\\\([\\\\d]{3}\\\\) |[\\\\d]{3}-)[\\\\d]{3}-[\\\\d]{4} file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\([\\\\d]{3}\\\\) |[\\\\d]{3}-)[\\\\d]{3}-[\\\\d]{4} file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612561,
                "title": "bash-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596986,
                "title": "using-regular-expression-matching-operator-bash-hyder-nabi",
                "content": "# Steps: \\n1. Read the input file line by line.\\n2. For each line X\\n    a. Match the line againest the pattern using =~ operator\\n    b. Print the line if match was successful\\n    c. Skip otherwise.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NoOfLines))$$\\n- Assuming the comparison takes $$O(1)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\nwhile read line; do\\n\\tif [[ $line =~ $pattern ]]\\n\\tthen\\n\\t\\techo $line;\\n\\tfi\\ndone < $file;\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\nwhile read line; do\\n\\tif [[ $line =~ $pattern ]]\\n\\tthen\\n\\t\\techo $line;\\n\\tfi\\ndone < $file;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544077,
                "title": "egrep-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529042,
                "title": "valid-phone-number-with-grep-and-regex-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI wanted to read the file line by line but then I realised that this could be solved more easily through regex.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt was a lot of trial and errors because I could not see the tests to prepare my regex for it, after strugling for a while I took a look at some solutions and it helped me compose mine a lot better, for some reason using -P the Perl regex parsing method worked better than the -E Extended regex mode.\\n\\n# Explanation\\n\\nREGEX `^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$`\\n\\nThe first part `^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$` to catch `987-123-4567`\\n\\n- `^` it must begin with what comes after this sign\\n- `[\\\\d]{3}` grabs the first 3 digits\\n- `-[\\\\d]{3}` grabs 3 more digits, with a -\\n- `-[\\\\d]{4}` grabs the last 4 digits with a -\\n- `DOLLAR SIGN` it must end with what came before this sign\\n\\nThe second part `^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}DOLLAR SIGN` to catch `(123) 456-7890`\\n\\n- `^` it must begin with what comes after this sign\\n- `\\\\(\\\\d{3}\\\\)` grabs the first 3 digits in between `(`, `)`\\n- `\\\\s` adds a white space\\n- `[\\\\d]{3}` grabs 3 more digits\\n- `-[\\\\d]{4}` grabs the last 4 digits with a -\\n- `DOLLAR SIGN` it must end with what came before this sign\\n\\n\\n# Code\\n```sh\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \"^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$\" file.txt \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```sh\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \"^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$\" file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516737,
                "title": "a-simple-grep-approch-with-regexp",
                "content": "# Intuition\\nUsing a simple grep with regexp\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3511116,
                "title": "grep-one-liner-for-personal-note",
                "content": "- `.` - matches any single character except a newline.\\n- `^` - matches the start of a line.\\n- `$` - matches the end of a line.\\n- `*` - matches zero or more occurrences of the previous character or pattern.\\n- `+` - matches one or more occurrences of the previous character or pattern.\\n- `?` - matches zero or one occurrence of the previous character or pattern.\\n- `{m}` - matches exactly `m` occurrences of the previous character or pattern.\\n- `{m,n}` - matches between `m` and `n` occurrences of the previous character or pattern.\\n- `[abc]` - matches any of the characters `a`, `b`, or `c`.\\n- `[^abc]` - matches any character except `a`, `b`, or `c`.\\n- `[a-z]` - matches any character between `a` and `z`.\\n- `(` and `)` - used for grouping patterns together.\\n- `|` - used to specify alternatives between patterns.\\n- `\\\\` - used to escape a special character or to give special meaning to a character.\\n\\n# Code\\n```bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505123,
                "title": "bash-grep-regex",
                "content": "# Intuition\\nUse grep with a regular expression.\\n\\n# Approach\\nUse grep with a regular expression.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\ngrep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490365,
                "title": "unique-solution-with-while-loop",
                "content": "##### Complexity \\nSee this image for reference\\n\\n![Uq.jpg](https://assets.leetcode.com/users/images/79b2042e-1ec6-4052-b802-b48d25982efd_1683309341.9463682.jpeg)\\n\\n\\n# Code\\n```Bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```Bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474368,
                "title": "solution",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}) file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}) file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473779,
                "title": "your-mother",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI sucked monkey. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBecome a monkey. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n) runtime because it\\'s too big brain for you clowns.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nNo space complexity because it\\'s too complex for your tiny brains.\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngrep -Po \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngrep -Po \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3460156,
                "title": "laconic-solution-of-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUtilize RegExp\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRegular expression\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n90ns\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n3.0 mb\\n# Code\\n```\\ngrep -Po \"^(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\\\b\" ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -Po \"^(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\\\b\" ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453539,
                "title": "one-line-bash-command",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3451451,
                "title": "with-explanation",
                "content": "https://leetcode.com/problems/valid-phone-numbers/solutions/3218882/193-solution-step-by-step-explanation/ \\n\\nplease check for more explanation\\n\\n# Approach\\n^ and $ are used to specify the beginning and end of the line respectively, to ensure that the entire line matches the pattern. - ( and ) are used to match parentheses, which are escaped with backslashes because they have special meaning in regular expressions. - [0-9]{3} is used to match exactly three digits. - | is used to specify an alternative match, either a group of three digits surrounded by parentheses, followed by a space, or a group of three digits separated by a hyphen. - file.txt is the name of the file that we want to search. This regular expression matches phone numbers in the format (xxx) xxx-xxxx or xxx-xxx-xxxx. The output of this one-liner bash script will be the list of valid phone numbers in the file.\\n\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3402595,
                "title": "oneline-bash-command",
                "content": "\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3396239,
                "title": "bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389178,
                "title": "valid-phone-num-bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370702,
                "title": "193-valid-phone-numbers",
                "content": "# Intuition\\nThe problem requires us to extract all valid phone numbers from a text file, where a valid phone number is defined as a number in either (xxx) xxx-xxxx or xxx-xxx-xxxx format. The task is to write a one-liner bash script that can extract all valid phone numbers from the file.\\n\\n# Approach\\nThe approach involves using the grep command with extended regular expression syntax (-E option) to match lines that start with either (xxx) or xxx-, followed by three digits, a hyphen, and then four digits. The ^ and $ characters anchor the expression to the beginning and end of each line. The | character inside the parentheses matches either (xxx) or xxx-.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the program is O(n), where n is the total number of characters in the input file. This is because grep processes each line of the file only once, and its time complexity is proportional to the number of characters in the line.\\n\\n- Space complexity:\\nThe space complexity of the program is O(1), because it doesn\\'t require any extra space beyond the input file and the memory used by the grep command. The grep command works on a line-by-line basis and doesn\\'t store the entire input file in memory at once.\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368147,
                "title": "single-line-use-grep",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364420,
                "title": "code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341072,
                "title": "simple-regex-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Just simple Regex \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> -\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> - \\n \\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336424,
                "title": "grep-p-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nm)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326851,
                "title": "using-gawk-to-solve-this-problem-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$0 prints the entire input if it pass the testcase.\\ninput is each new line from the file.\\n\\nTips:\\nYou have to escape parenthesis using backslash \\\\\\n{3} means 3 occurence.\\n[0-9] is the range\\nand (apple|mango) means either apple or mango.\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngawk --re-interval \\'/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/{print $0}\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngawk --re-interval \\'/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/{print $0}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3310752,
                "title": "one-line",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285570,
                "title": "sed-easy-solution-1-line-solution-easy-explanation",
                "content": "\\n# Code\\n```\\n sed -n \\'/^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)[[:digit:]]\\\\{3\\\\}-[[:digit:]]\\\\{4\\\\}$/p\\' file.txt\\n```\\n# Explanation\\n- ```-n``` supress the default printing behaviour of sed.\\n\\n- ```^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)``` \\'XXX \\' or \\'(XXX)\\'\\n     - ```^\\\\(<pattern 1>\\\\|\\\\(<pattern 2>\\\\)\\\\)``` should start with this pattern.\\n- ```\\\\([[:digit:]]\\\\)\\\\{3\\\\}-``` \\'XXX-\\'\\n- ```[[:digit:]]\\\\{4\\\\}``` \\'XXX\\'\\n- ```$``` represents the End of the Line\\n- ```(/<Regular expression pattern>/p)``` syntax for sed command to print the matched RE.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n sed -n \\'/^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)[[:digit:]]\\\\{3\\\\}-[[:digit:]]\\\\{4\\\\}$/p\\' file.txt\\n```\n```-n```\n```^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)```\n```^\\\\(<pattern 1>\\\\|\\\\(<pattern 2>\\\\)\\\\)```\n```\\\\([[:digit:]]\\\\)\\\\{3\\\\}-```\n```[[:digit:]]\\\\{4\\\\}```\n```$```\n```(/<Regular expression pattern>/p)```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276839,
                "title": "193-valid-phone-numbers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3244342,
                "title": "one-liner-with-explanation",
                "content": "# How it\\'s works\\n\\n- The grep command is used to search for lines in `file.txt` that match a regular expression.\\n\\n- The regular expression used in the command matches two possible formats for a valid phone number:\\n\\n- The phone number starts with an opening parenthesis, followed by three digits, a closing parenthesis, a space, three digits, a dash, and four digits.\\n\\n- The phone number starts with three digits, a dash, three digits, a dash, and four digits.\\nThe `-E` option is used to enable extended regular expressions.\\n\\n- The `^` and `$` symbols are used to ensure that the regular expression matches the entire line (i.e., the phone number must be the only thing on the line).\\n\\n- The | symbol is used to allow either the (xxx) xxx-xxxx or xxx-xxx-xxxx format to match.\\n\\n\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3219386,
                "title": "some-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"(^\\\\([0-9]{3}\\\\) |^[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"(^\\\\([0-9]{3}\\\\) |^[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209903,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169534,
                "title": "sed-regex",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n \\'/^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\|^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n \\'/^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\|^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162746,
                "title": "easy-method-100-faster-one-linear",
                "content": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3157858,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -o \\'\\\\(^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\\\|\\\\(^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -o \\'\\\\(^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\\\|\\\\(^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133940,
                "title": "very-easy-soln",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132608,
                "title": "easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125290,
                "title": "clean-code-high-speed-beats-98-9",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3121902,
                "title": "accepted-bash",
                "content": "```\\ncat file.txt | grep -E \"^[[:digit:]]{3}-[[:digit:]]{3}-[[:digit:]]{4}$|^\\\\([[:digit:]]{3}\\\\) [[:digit:]]{3}-[[:digit:]]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | grep -E \"^[[:digit:]]{3}-[[:digit:]]{3}-[[:digit:]]{4}$|^\\\\([[:digit:]]{3}\\\\) [[:digit:]]{3}-[[:digit:]]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107103,
                "title": "readable-bash-solution-with-an-explanation",
                "content": "# Intuition\\nWe need a way to read out a file\\'s contents with applied filtering on a line basis. \\n\\n * *cat* short for concatenate (verb, to join or link together, as though in a chain) is a program to read one or multiple files and print them on the standard output of the terminal.\\n example:\\n ```\\n $ cat file.txt\\n987-123-4567\\n123 456 7890\\n(123) 456-7890\\n```\\n * *grep* is the second piece of the puzzle. It is a program that takes whatever is passed to it and applies user supplied filtering in the form of *regular expressions* to each line.\\n ```\\n$ grep \\'foobar\\'\\nfoobarbaz # user input, must finish with a new line, Enter key\\nfoobarbaz # grep says it is a match\\nnotfoo # user input and no match (does not get printed twice)\\nnotbar # user input, no match\\nnotfoobar # user input\\nnotfoobar # grep matches it\\n# hit Ctrl+D to exit from grep\\n$ \\n```\\nNow let\\'s filter based on the formats in the problem description.\\n\\nThe first  pattern is `xxx-xxx-xxxx`, where `x` is any digit from 0 to 9. By default, grep understands only basic regular expressions, you can read up on what exactly that is by typing `man grep` inside a terminal. If we want the full regex experience we have to supply the `-P` flag, denoting that we want to use Perl flavoured regular expressions. We do this so we can use `\\\\d` to denote a digit, which grep wouldn\\'t understand otherwise.\\n\\nSo our first pattern would be \\n`^\\\\d{3}-\\\\d{3}-\\\\d{4}$`<br><br>\\n\\nIt reads as the following - 3 digits, followed by a hyphen `-` and 3 more digits, followed by a hyphen `-` and 4 more digits. The caret symbol `^` and the dollar `$` denote that we want that to be the full line. Caret means match the match has to begin from the first symbol on the line, and dollar means that it should be the last as well. In other words nothing should follow or preceed it.\\n\\nOur second pattern should match `(xxx) xxx-xxxx`, so the regex would look something like this:\\n`\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}`\\n\\nNote the escaping of the brackets with `\\\\(`, we do this because `(` is a special symbol for grouping things, so we have to escape it.\\n\\nThe last problem that we have to solve is to write a single regular expression that matches our first pattern *OR* our second one. we can do this like so - `(foo|bar)` this would either foo or bar.\\n\\nSo our final expression would look like this:\\n\\n`grep -P \"(\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})|\\\\d{3}-\\\\d{3}-\\\\d{4}\"`\\n\\n\\n\\nNow we need a way to combine *cat* and *grep*. In the terminal world, we use *pipes*, denoted by the `|` symbol. What piping does is that it feeds the output of one command to the next, like making a real pipe. We want to feed *grep* the output of `cat file.txt`:\\n`cat file.txt | grep -P \"(\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})|\\\\d{3}-\\\\d{3}-\\\\d{4}\"`\\n\\nTo make things more readable I like to extract the simple subpatterns inside bash variables, and so we come to our\\n\\n# Final Solution\\n```\\npattern_one=\\'\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}\\'\\npattern_two=\\'\\\\d{3}-\\\\d{3}-\\\\d{4}\\'\\ncat file.txt | grep -P \"^($pattern_one|$pattern_two)$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n $ cat file.txt\\n987-123-4567\\n123 456 7890\\n(123) 456-7890\\n```\n```\\n$ grep \\'foobar\\'\\nfoobarbaz # user input, must finish with a new line, Enter key\\nfoobarbaz # grep says it is a match\\nnotfoo # user input and no match (does not get printed twice)\\nnotbar # user input, no match\\nnotfoobar # user input\\nnotfoobar # grep matches it\\n# hit Ctrl+D to exit from grep\\n$ \\n```\n```\\npattern_one=\\'\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}\\'\\npattern_two=\\'\\\\d{3}-\\\\d{3}-\\\\d{4}\\'\\ncat file.txt | grep -P \"^($pattern_one|$pattern_two)$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095416,
                "title": "worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090510,
                "title": "80-beat-simple-validation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069619,
                "title": "trivial-beats-100",
                "content": "\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068129,
                "title": "valid-phone-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\nfile=\"file.txt\"\\n\\nwhile read -r line; do\\n    format1=\\'(^([0-9]{3})[-][0-9]{3}[-]([0-9]{4})$)\\'\\n    format2=\\'^(\\\\([0-9]{3}\\\\)[ ][0-9]{3}[-]([0-9]{4})$)\\'\\n    if [[ $line =~ $format1 || $line =~ $format2 ]];then\\n        echo $line\\n    fi\\ndone <$file\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\nfile=\"file.txt\"\\n\\nwhile read -r line; do\\n    format1=\\'(^([0-9]{3})[-][0-9]{3}[-]([0-9]{4})$)\\'\\n    format2=\\'^(\\\\([0-9]{3}\\\\)[ ][0-9]{3}[-]([0-9]{4})$)\\'\\n    if [[ $line =~ $format1 || $line =~ $format2 ]];then\\n        echo $line\\n    fi\\ndone <$file\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056937,
                "title": "valid-phone-numbers-bash-solution",
                "content": "One Liner Bash Solution\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042657,
                "title": "grep-p-d-3-d-3-d-3-d-4-file-txt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe grep code has four parts in it as the valid phone number can be constructed using the possible combiantion of any three from the below four parts.\\n\\n1. ^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) ) ---> valid phone number can start ^(... either with \\n\\\\d{3}- --> 3 digits and - or (|) #2\\n2.  \\\\(\\\\d{3}\\\\) ) --> (3 digits and one space)\\n3. d{3}- --> 3 digits and a dash\\n4. d{4} --> 4 digits \\n\\nAny combination of above 1,3,4 or 1,2,4 is a valid phone number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011494,
                "title": "one-line-grep-with-shortest-regex",
                "content": "# Code\\n```\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n## Regex explain\\n\\nStart with `999-` or `(999) ` followed by `999-9999` then end line. Where `9` means numbers from `0` to `9`.\\n\\n`^` - Start line\\n`()` - Group expression\\n`\\\\d` - any number 0 to 9\\n`{n}` - repeat expression n times\\n`|` - or operator\\n`$` - Finish line",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3006820,
                "title": "grep-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by using a regular expression to match valid phone numbers in a file.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach to this problem is to use the grep command and a regular expression to search for valid phone numbers in the file.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis will depend on the implementation of grep and the size of the file. In general, the time complexity of grep is linear with respect to the size of the input.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis will also depend on the implementation of grep and the size of the file. In general, the space complexity of grep is linear with respect to the size of the input.\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2988675,
                "title": "bash-valid-phone-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use `grep` to search the a particular pattern of characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermined the regex of the valid phone numbers then use the `grep` to filter them\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981642,
                "title": "pure-posix-compliant-shell-solution-without-external-commands-beats-99-89",
                "content": "# Approach\\n\\nPure POSIX shell without calls to external commands. This will work not only on Bash, but virtually any POSIX-compliant shell going back to the 80s.\\n\\nIn addition, despite being marginally slower (beats 99.89%) than what some other users have reported out of grep solutions, this is actually significantly faster than any of those solutions due to the fact that calls to external commands require the shell to fork.\\n\\nAs such, this can be as much as ~50x faster than grep.\\n\\n# Code\\n```\\n#!/bin/sh\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n\\n```\\n\\n# Benchmarks\\n\\n* zsh = Homebrew zsh 5.9.0.1-dev\\n* bash5 = Homebrew Bash 5.2.2\\n* bash3 = Apple\\'s Bash 3.2.57\\n* dash = pkgsrc Debian Almquist shell\\n* yash = pkgsrc yash\\n* bosh = pkgsrc Schily bosh\\n* pbosh = pkgsrc Schily pbosh\\n* mksh = pkgsrc MirBSD Korn Shell\\n* oksh = pkgsrc OpenBSD Korn Shell\\n* pdksh = pkgsrc Public Domain Korn Shell\\n* ksh93 = pkgsrc AT&T Ksh93 Korn Shell (93u+m/1.0.4+f7ce04bb)\\n* ksh93u_plus = Apple\\'s AT&T Ksh93 Korn Shell (93u+ 2012-08-01)\\n* awk = pkgsrc awk (OneTrueAwk 20211208)\\n* nawk = pkgsrc nawk (OneTrueAwk 20121220)\\n* mawk = Homebrew mawk (1.3.4 20200120)\\n* bgrep = Apple\\'s FreeBSD grep (2.6.0-FreeBSD)\\n* ggrep = Homebrew GNU grep (3.8)\\n\\n```shell\\n./shellbench -s zsh,bash5,bash3,dash,yash,bosh,pbosh,mksh,oksh,pdksh,ksh93,ksh93u_plus sample/leetcode/193/193.sh\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\nname                                  zsh      bash5      bash3       dash       yash       bosh      pbosh       mksh       oksh      pdksh      ksh93 ksh93u_plus\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n193.sh: builtins                   23,339     32,790     23,939     26,722     17,472     24,304     24,949     26,239     49,134     51,275     55,179     51,648 \\n193.sh: awk                           614        621        624        645        619        610        614        621        620        619        826        381 \\n193.sh: mawk                          620        614        618        640        618        624        619        625        619        629        842        380 \\n193.sh: nawk                          698        708        713        746        716        694        691        719        720        728        976        433 \\n193.sh: gawk                          694        611        719        734        706        589        672        719        718        675        985        424 \\n193.sh: bgrep -E                      723        743        765        782        737        742        757        752        726        733      1,062        379 \\n193.sh: ggrep -E                      542        540        539        563        541        522        538        552        547        531        698        347 \\n193.sh: ggrep -P                      543        557        560        573        557        554        549        555        552        553        696        350 \\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n* count: number of executions per second\\n```\\n\\n```shell\\n#!/bin/sh\\n#bench \"builtins\"\\n@begin\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n@end\\n\\n#bench \"awk\"\\n@begin\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"mawk\"\\n@begin\\nmawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"nawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"gawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"bgrep -E\"\\n@begin\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -E\"\\n@begin\\nggrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -P\"\\n@begin\\nggrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n@end\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/sh\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n\\n```\n```shell\\n./shellbench -s zsh,bash5,bash3,dash,yash,bosh,pbosh,mksh,oksh,pdksh,ksh93,ksh93u_plus sample/leetcode/193/193.sh\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\nname                                  zsh      bash5      bash3       dash       yash       bosh      pbosh       mksh       oksh      pdksh      ksh93 ksh93u_plus\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n193.sh: builtins                   23,339     32,790     23,939     26,722     17,472     24,304     24,949     26,239     49,134     51,275     55,179     51,648 \\n193.sh: awk                           614        621        624        645        619        610        614        621        620        619        826        381 \\n193.sh: mawk                          620        614        618        640        618        624        619        625        619        629        842        380 \\n193.sh: nawk                          698        708        713        746        716        694        691        719        720        728        976        433 \\n193.sh: gawk                          694        611        719        734        706        589        672        719        718        675        985        424 \\n193.sh: bgrep -E                      723        743        765        782        737        742        757        752        726        733      1,062        379 \\n193.sh: ggrep -E                      542        540        539        563        541        522        538        552        547        531        698        347 \\n193.sh: ggrep -P                      543        557        560        573        557        554        549        555        552        553        696        350 \\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n* count: number of executions per second\\n```\n```shell\\n#!/bin/sh\\n#bench \"builtins\"\\n@begin\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n@end\\n\\n#bench \"awk\"\\n@begin\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"mawk\"\\n@begin\\nmawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"nawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"gawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"bgrep -E\"\\n@begin\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -E\"\\n@begin\\nggrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -P\"\\n@begin\\nggrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n@end\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967963,
                "title": "grep-short-and-fast-explanation",
                "content": "```\\ngrep -E \\'^([[:digit:]]{3}-|^\\\\([[:digit:]]{3}\\\\) )[[:digit:]]{3}-[[:digit:]]{4}$\\' file.txt\\n```\\nOr just this. Where [0-9] instead of [:digit:].\\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```\\n\\n# Idea\\nWe need to check for one of this formats\\n(xxx) xxx-xxxx\\nxxx-xxx-xxxx\\n\\nAt the beginning we want one of the following:\\na) \"(xxx) \" ```\\\\([0-9]{3}\\\\) ```\\nb) \"xxx-\" ```[0-9]{3}\\\\-```\\nRest is same for both:\\n\"xxx-xxxx\" ```[0-9]{3}\\\\-[0-9]{4}```\\n\\n# Symbols meaning\\n**a|b** - Regex matches any string matching one of them.\\n**(a|b)** - To make subexpression\\n**\\\\\\\\** - Disabling/enabling meta-character\\n**{m}** - The preceding item is matched exactly m times. We can also use **{m,n}** or **{m,}** (m and more times), **{,n}** (at most n times).\\n**^** - The begin of a line\\n**$** - The end of a line.\\n**[:digit:] [:upper:] [:alpha:] [:alnum:]** - Character classes. Better not to use [a-z] to avoid dependence on language settings, as some languages have \\xE0,\\u010D,\\u017E ...\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^([[:digit:]]{3}-|^\\\\([[:digit:]]{3}\\\\) )[[:digit:]]{3}-[[:digit:]]{4}$\\' file.txt\\n```\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```\n```\\\\([0-9]{3}\\\\) ```\n```[0-9]{3}\\\\-```\n```[0-9]{3}\\\\-[0-9]{4}```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957212,
                "title": "simple-grep-solution",
                "content": "# Approach\\nUse the `grep` command with [this regex pattern](https://regex101.com/r/Z7q2pZ/1) to show the valid phone numbers.\\n\\n# Code\\n```sh\\n#!/bin/sh\\n\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3,3}\\\\) |[0-9]{3,3}-){1,1}[0-9]{3,3}-[0-9]{4,4}$\"\\n\\ngrep -Ei \"$pattern\" $file\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```sh\\n#!/bin/sh\\n\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3,3}\\\\) |[0-9]{3,3}-){1,1}[0-9]{3,3}-[0-9]{4,4}$\"\\n\\ngrep -Ei \"$pattern\" $file\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937314,
                "title": "simple-one-line-100ms-beats-79-20",
                "content": "# Code\\n```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2934322,
                "title": "bash-grep-e",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2883195,
                "title": "one-line-shell-command-vs-bash-script-grep-e-matching-regular-expression-re",
                "content": "# Intuition\\nMy first thoughts focused on UNIX/Linux filter. It is a command that:\\n- Takes its input from standard inputs\\n- Precesses it according to some parameters and options\\n- Prodices its output on standard output\\n\\nIn general, filters are useful tool for text file processing.\\nIn addition, since the text requires yoo to serach the input file for lines containing a match to the given pattern, I select **grep -E** or **egrep** command beacuse it uses extended **Regular Expression** for matching the pattern.\\n**grep format: grep [options] pattern [file]**\\n\\n# Approach\\nThe text asks for two REs.\\nTherefore, the RE must have two expressions connected by an OR -> |.\\nThe character \\'\\\\\\' is used for special characters, such as \\'(\\' or \\')\\'.\\nThe \\'\\\\s\\' character is used for space or tab.\\nThe \\'\\\\s\\' character is used for space or tab\\nThe \\'^\\' character is used for the beginning of the line\\nthe \\'$\\' character is used for the end of the line\\nThe expression \\'[0-9]{3}\\' is used to identify a set of three digits.\\n\\nIn addition to the shell command version, I also added the bash script version.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n\\nshell command:\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n```\\n\\nBash script:\\n```\\n#!/bin/bash\\n\\nif [ $# -ne 1]\\nthen\\n    echo \"Run as $0 file.txt\"\\n    exit 1\\nfi\\n\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n```\n```\\n#!/bin/bash\\n\\nif [ $# -ne 1]\\nthen\\n    echo \"Run as $0 file.txt\"\\n    exit 1\\nfi\\n\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2881574,
                "title": "bash-script-regex-awk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n awk \\'/^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2878947,
                "title": "bash-beats-100-easy-to-understand",
                "content": "# Intuition\\nCheck each number line by line.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead the file line by line and then use regular expression to verify the valid phone number.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read line\\ndo\\n    if [[ $line == [0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\n    if [[ $line == [\\'(\\'][0-9][0-9][0-9][\\')\\'][[:space:]][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read line\\ndo\\n    if [[ $line == [0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\n    if [[ $line == [\\'(\\'][0-9][0-9][0-9][\\')\\'][[:space:]][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868701,
                "title": "valid-phone-numbers",
                "content": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2863876,
                "title": "bash-using-while-and-if-statements",
                "content": "```\\n#!/bin/bash\\nfile_name=\"file.txt\"\\nphone_number_regx=\\'(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)|(^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$)\\'\\n\\nwhile read line;\\ndo\\n\\tif [[ \"$line\" =~ $phone_number_regx ]]; then\\n\\t\\techo $line\\n\\tfi\\ndone<$file_name\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\nfile_name=\"file.txt\"\\nphone_number_regx=\\'(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)|(^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$)\\'\\n\\nwhile read line;\\ndo\\n\\tif [[ \"$line\" =~ $phone_number_regx ]]; then\\n\\t\\techo $line\\n\\tfi\\ndone<$file_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848522,
                "title": "1-line-using-grep-regex",
                "content": "\\tgrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n\\ti",
                "solutionTags": [],
                "code": "\\tgrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n\\ti",
                "codeTag": "Unknown"
            },
            {
                "id": 2810953,
                "title": "o-n-83ms-grep-regex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse regEx in grep\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngrep -E \\'regEx\\' file.txt\\n^([0-9]{3}-[0-9]{3}-[0-9]{4})\\\\$\\n^(\\\\\\\\([0-9]{3}\\\\\\\\) [0-9]{3}-[0-9]{4})\\\\$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) traverse of the file.txt\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if grep just gets lines not the whole file\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$\\' ./file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "String Matching"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$\\' ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807343,
                "title": "solution-using-awk-pattern",
                "content": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728317,
                "title": "one-liner-using-grep-regex",
                "content": "```bash\\ngrep -P \\'(^\\\\d{3}-|^\\\\(\\\\d{3}\\\\)\\\\s)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\ngrep -P \\'(^\\\\d{3}-|^\\\\(\\\\d{3}\\\\)\\\\s)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564611,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564656,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570699,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570151,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572572,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1566622,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569013,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1567736,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569012,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1568421,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564611,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564656,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570699,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570151,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572572,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1566622,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569013,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1567736,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569012,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1568421,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572907,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571409,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571410,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571411,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 2051023,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1963994,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1928438,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1928138,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1728427,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1712426,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flip Game",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568287,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            },
            {
                "id": 1572561,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            },
            {
                "id": 1571854,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            },
            {
                "id": 1879804,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            },
            {
                "id": 1753909,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            }
        ]
    },
    {
        "title": "UTF-8 Validation",
        "question_content": "<p>Given an integer array <code>data</code> representing the data, return whether it is a valid <strong>UTF-8</strong> encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).</p>\n\n<p>A character in <strong>UTF8</strong> can be from <strong>1 to 4 bytes</strong> long, subjected to the following rules:</p>\n\n<ol>\n\t<li>For a <strong>1-byte</strong> character, the first bit is a <code>0</code>, followed by its Unicode code.</li>\n\t<li>For an <strong>n-bytes</strong> character, the first <code>n</code> bits are all one&#39;s, the <code>n + 1</code> bit is <code>0</code>, followed by <code>n - 1</code> bytes with the most significant <code>2</code> bits being <code>10</code>.</li>\n</ol>\n\n<p>This is how the UTF-8 encoding would work:</p>\n\n<pre>\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n</pre>\n\n<p><code>x</code> denotes a bit in the binary form of a byte that may be either <code>0</code> or <code>1</code>.</p>\n\n<p><strong>Note: </strong>The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> data = [197,130,1]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> data = [235,140,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one&#39;s and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that&#39;s correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= data.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= data[i] &lt;= 255</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 87462,
                "title": "concise-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int count = 0;\\n        for (auto c : data) {\\n            if (count == 0) {\\n                if ((c >> 5) == 0b110) count = 1;\\n                else if ((c >> 4) == 0b1110) count = 2;\\n                else if ((c >> 3) == 0b11110) count = 3;\\n                else if ((c >> 7)) return false;\\n            } else {\\n                if ((c >> 6) != 0b10) return false;\\n                count--;\\n            }\\n        }\\n        return count == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int count = 0;\\n        for (auto c : data) {\\n            if (count == 0) {\\n                if ((c >> 5) == 0b110) count = 1;\\n                else if ((c >> 4) == 0b1110) count = 2;\\n                else if ((c >> 3) == 0b11110) count = 3;\\n                else if ((c >> 7)) return false;\\n            } else {\\n                if ((c >> 6) != 0b10) return false;\\n                count--;\\n            }\\n        }\\n        return count == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568917,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity : O(N) where N is the number of elements in data\\n// Space Complexity: O(1) \\nclass Solution {\\npublic:\\n    // the idea is to keep track the number of segments of utf-8 octet sequence left\\n    // we increase / decrease the count based on some cases\\n    // first you need to know that `x >> n` means shift the number `x` `n` bits to the right\\n    // e.g. shift 110xxxxx 5 bits to the right becomes 110 (in binary format)\\n    // e.g. shift 11110xxx 4 bits to the right becomes 1111 (in binary format)\\n    // second, 0bxxxx is a binary literal which means xxxx is a binary number\\n    // alternatively, you can use decimal format but it\\'s not that convenient in this problem\\n    // e.g. 0b1110 -> 14\\n    // e.g. 0b11000000 -> 192\\n    bool validUtf8(vector<int>& data) {\\n        // used to track the remaining number of segments\\n        int remaining = 0;\\n        // iterate each data and perform the following logic\\n        for (auto& x : data) {\\n            // case 1: there is no remaining segement left, \\n            // then it means we should check the first segement of UTF-8 octet sequence\\n            // i.e. 0xxxxxxx (for no of. bytes = 1)\\n            // i.e. 110xxxxx (for no of. bytes = 2)\\n            // i.e. 1110xxxx (for no of. bytes = 3)\\n            // i.e. 11110xxx (for no of. bytes = 4)\\n            if (remaining == 0) {\\n                if ((x >> 5) == 0b110) {\\n                    // case 1.1 - shift `x` 5 bits to the right\\n                    // i.e making the first (8 - 5) = 3 bits left\\n                    // e.g (110xxxxx >> 5) becomes 110 (in binary format)\\n                    // if it is 0b110, \\n                    // then it is only possible to form `110xxxxx 10xxxxxx` \\n                    // so we set remaining to 1 to look for `10xxxxxx` later\\n                    remaining = 1;\\n                } else if ((x >> 4) == 0b1110) {\\n                    // case 1.2 -  shift `x` 4 bits to the right\\n                    // i.e making the first (8 - 4) = 4 bits left\\n                    // e.g (1110xxxx >> 4) becomes 1110 (in binary format)\\n                    // if it is 0b1110, \\n                    // then it is only possible to form `1110xxxx 10xxxxxx 10xxxxxx`\\n                    // so we set remaining to 2 to look for `10xxxxxx 10xxxxxx` later\\n                     remaining = 2;\\n                } else if ((x >> 3) == 0b11110) {\\n                    // case 1.3 -  shift `x` 3 bits to the right\\n                    // i.e making the first (8 - 3) = 5 bits left\\n                    // e.g (11110xxx >> 5) becomes 11110 (in binary format)\\n                    // if it is 0b11110, \\n                    // then it is only possible to form `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`\\n                    // so we set remaining to 3 to look for `10xxxxxx 10xxxxxx 10xxxxxx` later\\n                    remaining = 3;\\n                } else if ((x >> 7) != 0) {\\n                     // case 1.4 -  shift `x` 7 bits to the right\\n                    // i.e making the first (8 - 7) = 1 bit left\\n                    // e.g (0xxxxxxx >> 7) becomes 0 (in binary format)\\n                    // here we cover the last case which is when Number of Bytes = 1\\n                    // we need to make sure the first bit is 0\\n                    // otherwise, it is not valid\\n                    return false;\\n                }\\n            } else {\\n                // case 2: check 10xxxxxx\\n                // if we enter this part, that means it may be number of bytes 2, 3, or 4.\\n                // based on the table in problem statement, we know what\\'s left is just `10xxxxxx`\\n                // therefore, we shift `x` 6 bits to the right\\n                // i.e making the first (8 - 6) = 2 bits left\\n                // e.g (10xxxxxx >> 6) becomes 10 (in binary format)\\n                // if the first 2 bits are not 10 (in binary format), then it is not valid\\n                if ((x >> 6) != 0b10) return false;\\n                // otherwise, this segement is ok so we decrease `remaining` by 1\\n                else remaining--;\\n            }\\n        }\\n        // at the end, remaining will be 0 if data can represent the octet sequence \\n        return remaining == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n// Time Complexity : O(N) where N is the number of elements in data\\n// Space Complexity: O(1) \\nclass Solution {\\npublic:\\n    // the idea is to keep track the number of segments of utf-8 octet sequence left\\n    // we increase / decrease the count based on some cases\\n    // first you need to know that `x >> n` means shift the number `x` `n` bits to the right\\n    // e.g. shift 110xxxxx 5 bits to the right becomes 110 (in binary format)\\n    // e.g. shift 11110xxx 4 bits to the right becomes 1111 (in binary format)\\n    // second, 0bxxxx is a binary literal which means xxxx is a binary number\\n    // alternatively, you can use decimal format but it\\'s not that convenient in this problem\\n    // e.g. 0b1110 -> 14\\n    // e.g. 0b11000000 -> 192\\n    bool validUtf8(vector<int>& data) {\\n        // used to track the remaining number of segments\\n        int remaining = 0;\\n        // iterate each data and perform the following logic\\n        for (auto& x : data) {\\n            // case 1: there is no remaining segement left, \\n            // then it means we should check the first segement of UTF-8 octet sequence\\n            // i.e. 0xxxxxxx (for no of. bytes = 1)\\n            // i.e. 110xxxxx (for no of. bytes = 2)\\n            // i.e. 1110xxxx (for no of. bytes = 3)\\n            // i.e. 11110xxx (for no of. bytes = 4)\\n            if (remaining == 0) {\\n                if ((x >> 5) == 0b110) {\\n                    // case 1.1 - shift `x` 5 bits to the right\\n                    // i.e making the first (8 - 5) = 3 bits left\\n                    // e.g (110xxxxx >> 5) becomes 110 (in binary format)\\n                    // if it is 0b110, \\n                    // then it is only possible to form `110xxxxx 10xxxxxx` \\n                    // so we set remaining to 1 to look for `10xxxxxx` later\\n                    remaining = 1;\\n                } else if ((x >> 4) == 0b1110) {\\n                    // case 1.2 -  shift `x` 4 bits to the right\\n                    // i.e making the first (8 - 4) = 4 bits left\\n                    // e.g (1110xxxx >> 4) becomes 1110 (in binary format)\\n                    // if it is 0b1110, \\n                    // then it is only possible to form `1110xxxx 10xxxxxx 10xxxxxx`\\n                    // so we set remaining to 2 to look for `10xxxxxx 10xxxxxx` later\\n                     remaining = 2;\\n                } else if ((x >> 3) == 0b11110) {\\n                    // case 1.3 -  shift `x` 3 bits to the right\\n                    // i.e making the first (8 - 3) = 5 bits left\\n                    // e.g (11110xxx >> 5) becomes 11110 (in binary format)\\n                    // if it is 0b11110, \\n                    // then it is only possible to form `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`\\n                    // so we set remaining to 3 to look for `10xxxxxx 10xxxxxx 10xxxxxx` later\\n                    remaining = 3;\\n                } else if ((x >> 7) != 0) {\\n                     // case 1.4 -  shift `x` 7 bits to the right\\n                    // i.e making the first (8 - 7) = 1 bit left\\n                    // e.g (0xxxxxxx >> 7) becomes 0 (in binary format)\\n                    // here we cover the last case which is when Number of Bytes = 1\\n                    // we need to make sure the first bit is 0\\n                    // otherwise, it is not valid\\n                    return false;\\n                }\\n            } else {\\n                // case 2: check 10xxxxxx\\n                // if we enter this part, that means it may be number of bytes 2, 3, or 4.\\n                // based on the table in problem statement, we know what\\'s left is just `10xxxxxx`\\n                // therefore, we shift `x` 6 bits to the right\\n                // i.e making the first (8 - 6) = 2 bits left\\n                // e.g (10xxxxxx >> 6) becomes 10 (in binary format)\\n                // if the first 2 bits are not 10 (in binary format), then it is not valid\\n                if ((x >> 6) != 0b10) return false;\\n                // otherwise, this segement is ok so we decrease `remaining` by 1\\n                else remaining--;\\n            }\\n        }\\n        // at the end, remaining will be 0 if data can represent the octet sequence \\n        return remaining == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87464,
                "title": "bit-manipulation-java-6ms",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n\\tif(data==null || data.length==0) return false;\\n\\tboolean isValid = true;\\n\\tfor(int i=0;i<data.length;i++) {\\n\\t\\tif(data[i]>255) return false; // 1 after 8th digit, 100000000\\n\\t\\tint numberOfBytes = 0;\\n\\t\\tif((data[i] & 128) == 0) { // 0xxxxxxx, 1 byte, 128(10000000)\\n\\t\\t\\tnumberOfBytes = 1;\\n\\t\\t} else if((data[i] & 224) == 192) { // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\\n\\t\\t\\tnumberOfBytes = 2;\\n\\t\\t} else if((data[i] & 240) == 224) { // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\\n\\t\\t\\tnumberOfBytes = 3;\\n\\t\\t} else if((data[i] & 248) == 240) { // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\\n\\t\\t\\tnumberOfBytes = 4;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int j=1;j<numberOfBytes;j++) { // check that the next n bytes start with 10xxxxxx\\n\\t\\t\\tif(i+j>=data.length) return false;\\n\\t\\t\\tif((data[i+j] & 192) != 128) return false; // 192(11000000), 128(10000000)\\n\\t\\t}\\n\\t\\ti=i+numberOfBytes-1;\\n\\t}\\n\\treturn isValid;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n\\tif(data==null || data.length==0) return false;\\n\\tboolean isValid = true;\\n\\tfor(int i=0;i<data.length;i++) {\\n\\t\\tif(data[i]>255) return false; // 1 after 8th digit, 100000000\\n\\t\\tint numberOfBytes = 0;\\n\\t\\tif((data[i] & 128) == 0) { // 0xxxxxxx, 1 byte, 128(10000000)\\n\\t\\t\\tnumberOfBytes = 1;\\n\\t\\t} else if((data[i] & 224) == 192) { // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\\n\\t\\t\\tnumberOfBytes = 2;\\n\\t\\t} else if((data[i] & 240) == 224) { // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\\n\\t\\t\\tnumberOfBytes = 3;\\n\\t\\t} else if((data[i] & 248) == 240) { // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\\n\\t\\t\\tnumberOfBytes = 4;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int j=1;j<numberOfBytes;j++) { // check that the next n bytes start with 10xxxxxx\\n\\t\\t\\tif(i+j>=data.length) return false;\\n\\t\\t\\tif((data[i+j] & 192) != 128) return false; // 192(11000000), 128(10000000)\\n\\t\\t}\\n\\t\\ti=i+numberOfBytes-1;\\n\\t}\\n\\treturn isValid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568936,
                "title": "c-bit-manipulation-approach",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Intuition:**\\nSince we need to translate the provided data array into a `sequence` of valid `UTF-8 encoded characters` there is definitely an underlying concept of `bit manipulation` to be used, let\\'s see how we can achieve this.\\n\\n**Approach:**\\n* We will initially take a **count** variable initialized to 0;\\n* Then we will iterate over the given array and will store the value from data array in ele = data[i]\\n* If **count** is still 0 then below are the things that we need to take care of:\\n1. * **If x/32 = 110**, then set count as 1. `(x/32 is same as doing x >> 5 as 2^5 = 32)`\\n2. * **Else if x/16 = 1110**, then count = 2 `(x/16 is same as doing x >> 4 as 2^4 = 16)`\\n3. * **Else If x/8 = 11110**, then count = 3. `(x/8 is same as doing x >> 3 as 2^3 = 8)`\\n4. * **Else if x/128 is 0**, then return false. `(x/128 is same as doing x >> 7 as 2^7 = 128)`\\n5. * **Else if x/64 is not 10**, then decrease the **count** and return **false**.\\n* Finally if **count** is 0 return true;\\n\\n**C++:**\\n```\\nclass Solution{\\npublic:\\n  bool validUtf8(vector<int> &data){\\n    int n = data.size(); \\n    int count = 0;       \\n    for (int i = 0; i < n; i++){    \\n      int ele = data[i]; \\n      if (!count){ \\n\\t   // if the first 3 bits are 110, then the next byte is part of the current UTF-8 character\\n        if ((ele >> 5) == 0b110) \\n          count = 1; \\n\\t\\t// if the first 4 bits are 1110, then the next 2 bytes are part of the current UTF-8 character  \\n        else if ((ele >> 4) == 0b1110)\\n          count = 2; \\n\\t\\t // if the first 5 bits are 11110, then the next 3 bytes are part of the current UTF-8 character\\n        else if ((ele >> 3) == 0b11110)\\n          count = 3; \\n\\t\\t // if the first bit is 1, then return false\\n        else if ((ele >> 7))\\n          return false; \\n      }\\n      else{\\n\\t   // if the first 2 bits are not 10, then return false\\n        if ((ele >> 6) != 0b10)\\n          return false; \\n        count--;        \\n      }\\n    }\\n    return (count == 0); \\n  }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**\\n**Space Complexity:** **O(1)**\\n****",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n  bool validUtf8(vector<int> &data){\\n    int n = data.size(); \\n    int count = 0;       \\n    for (int i = 0; i < n; i++){    \\n      int ele = data[i]; \\n      if (!count){ \\n\\t   // if the first 3 bits are 110, then the next byte is part of the current UTF-8 character\\n        if ((ele >> 5) == 0b110) \\n          count = 1; \\n\\t\\t// if the first 4 bits are 1110, then the next 2 bytes are part of the current UTF-8 character  \\n        else if ((ele >> 4) == 0b1110)\\n          count = 2; \\n\\t\\t // if the first 5 bits are 11110, then the next 3 bytes are part of the current UTF-8 character\\n        else if ((ele >> 3) == 0b11110)\\n          count = 3; \\n\\t\\t // if the first bit is 1, then return false\\n        else if ((ele >> 7))\\n          return false; \\n      }\\n      else{\\n\\t   // if the first 2 bits are not 10, then return false\\n        if ((ele >> 6) != 0b10)\\n          return false; \\n        count--;        \\n      }\\n    }\\n    return (count == 0); \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87485,
                "title": "o-n-java-solution-with-detailed-explaination",
                "content": "```\\npublic class Solution {\\n    /*\\n     * Thought-way: \\n     * As long as every byte in the array is of right type, it is a valid UTF-8 encoding.\\n     * \\n     * Method: \\n     * Start from index 0, determine each byte's type and check its validity.\\n     *\\n     * There are five kinds of valid byte type: 0**, 10**, 110**,1110** and 11110**\\n     * Give them type numbers, 0, 1, 2, 3, 4 which are the index of the first 0 from left. \\n     * So, the index of the first 0 determines the byte type.\\n     *\\n     * if a byte belongs to one of them:\\n        1 : if it is type 0, continue\\n        2 : if it is type 2 or 3 or 4, check whether the following 1, 2, and 3 byte(s) are of type 1 or not\\n                if not, return false;\\n     * else if a byte is type 1 or not of valid type, return false\\n     *\\n     * Analysis :\\n     * The faster you can determine the type, the quicker you can get. \\n     * Time O(n), space O(1)\\n     * real performance: 7ms\\n     */\\n     \\n    // Hard code \"masks\" array to find the index of the first appearance of 0 in the lower 8 bits of each integer.\\n    private int[] masks = {128, 64, 32, 16, 8};\\n    public boolean validUtf8(int[] data) {\\n        int len = data.length;\\n        for (int i = 0; i < len; i ++) {\\n            int curr = data[i];\\n            int type = getType(curr);\\n            if (type == 0) {\\n                continue;\\n            } else if (type > 1 && i + type <= len) {\\n                while (type-- > 1) {\\n                    if (getType(data[++i]) != 1) {\\n                        return false;\\n                    }\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int getType(int num) {\\n        for (int i = 0; i < 5; i ++) {\\n            if ((masks[i] & num) == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /*\\n     * Thought-way: \\n     * As long as every byte in the array is of right type, it is a valid UTF-8 encoding.\\n     * \\n     * Method: \\n     * Start from index 0, determine each byte's type and check its validity.\\n     *\\n     * There are five kinds of valid byte type: 0**, 10**, 110**,1110** and 11110**\\n     * Give them type numbers, 0, 1, 2, 3, 4 which are the index of the first 0 from left. \\n     * So, the index of the first 0 determines the byte type.\\n     *\\n     * if a byte belongs to one of them:\\n        1 : if it is type 0, continue\\n        2 : if it is type 2 or 3 or 4, check whether the following 1, 2, and 3 byte(s) are of type 1 or not\\n                if not, return false;\\n     * else if a byte is type 1 or not of valid type, return false\\n     *\\n     * Analysis :\\n     * The faster you can determine the type, the quicker you can get. \\n     * Time O(n), space O(1)\\n     * real performance: 7ms\\n     */\\n     \\n    // Hard code \"masks\" array to find the index of the first appearance of 0 in the lower 8 bits of each integer.\\n    private int[] masks = {128, 64, 32, 16, 8};\\n    public boolean validUtf8(int[] data) {\\n        int len = data.length;\\n        for (int i = 0; i < len; i ++) {\\n            int curr = data[i];\\n            int type = getType(curr);\\n            if (type == 0) {\\n                continue;\\n            } else if (type > 1 && i + type <= len) {\\n                while (type-- > 1) {\\n                    if (getType(data[++i]) != 1) {\\n                        return false;\\n                    }\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int getType(int num) {\\n        for (int i = 0; i < 5; i ++) {\\n            if ((masks[i] & num) == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145982,
                "title": "java-code-one-loop-and-bit-shift",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n         int cnt = 0;\\n        for(int d : data){\\n            if(cnt == 0){\\n                if((d>>5) == 0b110) cnt = 1;\\n               else if((d>>4) == 0b1110) cnt=2;\\n               else if((d>>3) == 0b11110) cnt=3;\\n               else if((d>>7) != 0) return false;\\n            }else{\\n                if((d>>6) != 0b10) return false;\\n                cnt--;\\n            }\\n        }\\n        return cnt == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n         int cnt = 0;\\n        for(int d : data){\\n            if(cnt == 0){\\n                if((d>>5) == 0b110) cnt = 1;\\n               else if((d>>4) == 0b1110) cnt=2;\\n               else if((d>>3) == 0b11110) cnt=3;\\n               else if((d>>7) != 0) return false;\\n            }else{\\n                if((d>>6) != 0b10) return false;\\n                cnt--;\\n            }\\n        }\\n        return cnt == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87494,
                "title": "short-n-clean-12-lines-python-solution",
                "content": "```\\ndef check(nums, start, size):\\n    for i in range(start + 1, start + size + 1):\\n        if i >= len(nums) or (nums[i] >> 6) != 0b10: return False\\n    return True\\n\\nclass Solution(object):\\n    def validUtf8(self, nums, start=0):\\n        while start < len(nums):\\n            first = nums[start]\\n            if   (first >> 3) == 0b11110 and check(nums, start, 3): start += 4\\n            elif (first >> 4) == 0b1110  and check(nums, start, 2): start += 3\\n            elif (first >> 5) == 0b110   and check(nums, start, 1): start += 2\\n            elif (first >> 7) == 0:                                 start += 1\\n            else:                                                   return False\\n        return True\\n\\n# 45 / 45 test cases passed.\\n# Status: Accepted\\n# Runtime: 89 ms\\n```",
                "solutionTags": [],
                "code": "```\\ndef check(nums, start, size):\\n    for i in range(start + 1, start + size + 1):\\n        if i >= len(nums) or (nums[i] >> 6) != 0b10: return False\\n    return True\\n\\nclass Solution(object):\\n    def validUtf8(self, nums, start=0):\\n        while start < len(nums):\\n            first = nums[start]\\n            if   (first >> 3) == 0b11110 and check(nums, start, 3): start += 4\\n            elif (first >> 4) == 0b1110  and check(nums, start, 2): start += 3\\n            elif (first >> 5) == 0b110   and check(nums, start, 1): start += 2\\n            elif (first >> 7) == 0:                                 start += 1\\n            else:                                                   return False\\n        return True\\n\\n# 45 / 45 test cases passed.\\n# Status: Accepted\\n# Runtime: 89 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87478,
                "title": "simplest-python-solution",
                "content": "This is a simple implementation using a marker to count bytes.\\n\\n```\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        count = 0\\n        \\n        for byte in data:\\n            if byte >= 128 and byte <= 191:\\n                if not count:\\n                    return False\\n                count -= 1\\n            else:\\n                if count:\\n                    return False\\n                if byte < 128:\\n                    continue\\n                elif byte < 224:\\n                    count = 1\\n                elif byte < 240:\\n                    count = 2\\n                elif byte < 248:\\n                    count = 3\\n                else:\\n                    return False\\n                    \\n        return count == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        count = 0\\n        \\n        for byte in data:\\n            if byte >= 128 and byte <= 191:\\n                if not count:\\n                    return False\\n                count -= 1\\n            else:\\n                if count:\\n                    return False\\n                if byte < 128:\\n                    continue\\n                elif byte < 224:\\n                    count = 1\\n                elif byte < 240:\\n                    count = 2\\n                elif byte < 248:\\n                    count = 3\\n                else:\\n                    return False\\n                    \\n        return count == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569031,
                "title": "java-solution-and-explanation-bit-manipulation",
                "content": "**PLEASE UPVOTE IF YOU LIKE :)** \\n\\nThe bit manipulation method involves shifting the bits to get only the bit value of importance:\\n- 1 byte = 0xxxxxxx\\n- 2 bytes = 110xxxxx 10xxxxxx\\n- 3 bytes = 1110xxxx 10xxxxxx 10xxxxxx\\n- 4 bytes = 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n\\nWe can then use a counter to keep track, if we are in the case for 2, 3 or 4 bytes.\\n```\\n    public boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for (int value : data) {\\n            if (count == 0) {\\n                if (value >> 3 == 0b11110) {\\n                    count = 3;\\n                } else if (value >> 4 == 0b1110) {\\n                    count = 2;\\n                } else if (value >> 5 == 0b110) {\\n                    count = 1;\\n                } else if (value >> 7 == 0b0) {\\n                    count = 0;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if (value >> 6 == 0b10) {\\n                    count--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n```\\n\\nIf you are unfamiliar with bit manipulation, here is a solution that check for the value of the integers:\\n- 0xxxxxxx\\n\\t- `<= 127`\\n- 10xxxxxx \\n\\t- `>= 128 && <= 191`\\n- 110xxxxx\\n\\t- `>= 192 && <= 223`\\n- 1110xxxx\\n\\t- `>= 224 && <= 239`\\n- 11110xxx\\n\\t- `>= 240 && <= 247`\\n```\\npublic boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for (int integer : data) {\\n            if (integer > 247) {\\n                return false;\\n            }\\n            if (count == 0) {\\n                if (integer >= 240) {\\n                    count = 3;\\n                } else if (integer >= 224) {\\n                    count = 2;\\n                } else if (integer >= 192) {\\n                    count = 1;\\n                } else if (integer >= 128) {\\n                    return false;\\n                }\\n            } else {\\n                if (integer >= 128 && integer <= 191) {\\n                    count--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n```\\n\\nThank you for reading~",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for (int value : data) {\\n            if (count == 0) {\\n                if (value >> 3 == 0b11110) {\\n                    count = 3;\\n                } else if (value >> 4 == 0b1110) {\\n                    count = 2;\\n                } else if (value >> 5 == 0b110) {\\n                    count = 1;\\n                } else if (value >> 7 == 0b0) {\\n                    count = 0;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if (value >> 6 == 0b10) {\\n                    count--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n```\n```\\npublic boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for (int integer : data) {\\n            if (integer > 247) {\\n                return false;\\n            }\\n            if (count == 0) {\\n                if (integer >= 240) {\\n                    count = 3;\\n                } else if (integer >= 224) {\\n                    count = 2;\\n                } else if (integer >= 192) {\\n                    count = 1;\\n                } else if (integer >= 128) {\\n                    return false;\\n                }\\n            } else {\\n                if (integer >= 128 && integer <= 191) {\\n                    count--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87470,
                "title": "one-pass-simple-solution",
                "content": "public class Solution {\\n\\n    public bool ValidUtf8(int[] data) {\\n        int bitCount = 0;\\n        \\n        foreach(int n in data){\\n            \\n            if(n >= 192){\\n                if(bitCount != 0)\\n                    return false;\\n                else if(n >= 240)\\n                    bitCount = 3;\\n                else if(n >= 224)\\n                    bitCount = 2;\\n                else\\n                    bitCount = 1;\\n            }else if(n >= 128){\\n                bitCount--;\\n                if(bitCount < 0)\\n                    return false;\\n            }else if(bitCount > 0){\\n                return false;\\n            }\\n        }\\n        \\n        return bitCount == 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public bool ValidUtf8(int[] data) {\\n        int bitCount = 0;\\n        \\n        foreach(int n in data){\\n            \\n            if(n >= 192){\\n                if(bitCount != 0)\\n                    return false;\\n                else if(n >= 240)\\n                    bitCount = 3;\\n                else if(n >= 224)\\n                    bitCount = 2;\\n                else\\n                    bitCount = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2568814,
                "title": "clean-concise-c-java-code",
                "content": "# Our objective\\nTo translate the provided data array into a sequence of valid UTF-8 encoded characters\\n\\n--------------------\\n\\n# Approach\\n\\n**To solve this, we will follow these steps:**\\n\\n> **Step 1:** Start with count = 0.\\n\\n> **Step 2:** for i ranging from 0 to the size of the data array.\\n\\n>> **Step 2.1:** Take the value from data arra and store it in x \\xA0= data[i]\\n\\n>> **Step 2.2:** If the count is 0, then\\n\\n>>> If x/32 = 110, then set count as 1.   ***(x/32 is same as doing x >> 5 as 2^5 = 32)***\\n\\n>>> Else if x/16 = 1110, then count = 2   ***(x/16 is same as doing x >> 4 as 2^4 = 16)***\\n\\n>>> Else If x/8 = 11110, then count = 3.   ***(x/8 is same as doing x >> 3 as 2^3 = 8)***\\n\\n>>> Else if x/128 is 0, then return false.    ***(x/128 is same as doing x >> 7 as 2^7 = 128)***\\n\\n>>**Step 2.3:** Else If x/64 is not 10, then return false and decrease the count by 1.\\n\\n> **Step 3:** When the count is 0, return true.\\n\\n------------------------------------------\\n\\n# Complexity\\n\\n\\n```\\nComplexity: \\n* TC: O(N)\\n* SC: O(1)\\n```\\n\\n-------------------------------\\n\\n# Code:\\n\\n<iframe src=\"https://leetcode.com/playground/C8dd2Bwf/shared\" frameBorder=\"0\" width=\"800\" height=\"480\"></iframe>\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nComplexity: \\n* TC: O(N)\\n* SC: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156588,
                "title": "my-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data):\\n        \\n        def rest(i):\\n            if len(data) < i: return False\\n            for _ in range(i):\\n                if not data.pop().startswith(\"10\"): return False\\n            return True\\n        \\n        data = [str(bin(seq)[2:].zfill(8)) for seq in data[::-1]]\\n        while data:\\n            seq = data.pop()\\n            if seq.startswith(\"0\"): continue\\n            if seq.startswith(\"110\"):\\n                if not rest(1): return False\\n            elif seq.startswith(\"1110\"):\\n                if not rest(2): return False\\n            elif seq.startswith(\"11110\"):\\n                if not rest(3): return False\\n            else: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data):\\n        \\n        def rest(i):\\n            if len(data) < i: return False\\n            for _ in range(i):\\n                if not data.pop().startswith(\"10\"): return False\\n            return True\\n        \\n        data = [str(bin(seq)[2:].zfill(8)) for seq in data[::-1]]\\n        while data:\\n            seq = data.pop()\\n            if seq.startswith(\"0\"): continue\\n            if seq.startswith(\"110\"):\\n                if not rest(1): return False\\n            elif seq.startswith(\"1110\"):\\n                if not rest(2): return False\\n            elif seq.startswith(\"11110\"):\\n                if not rest(3): return False\\n            else: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569284,
                "title": "short-java-solution",
                "content": "**Code:**\\n\\n    public boolean validUtf8(int[] data) {\\n        int mask = 128, n = 0;\\n        for(int i=0; i<data.length; i++){\\n            if(n!=0){\\n                if(calc(data[i])!=-1) return false;\\n                n--; continue;\\n            }\\n            n = (mask&data[i])==0 ? 0 : calc(data[i])-1; \\n            if(n<0 || i+n>=data.length) return false;\\n            if(n>0 && ((mask>>n+1)&data[i])!=0) return false;\\n        }\\n        return n==0;\\n    }\\n    \\n    int calc(int val){\\n        int n = 0;\\n        for(int mask = 128; (mask&val)!=0 && n!=4; n++)\\n            val = val<<1;\\n        return n==1 ? -1 : n;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n\\n    public boolean validUtf8(int[] data) {\\n        int mask = 128, n = 0;\\n        for(int i=0; i<data.length; i++){\\n            if(n!=0){\\n                if(calc(data[i])!=-1) return false;\\n                n--; continue;\\n            }\\n            n = (mask&data[i])==0 ? 0 : calc(data[i])-1; \\n            if(n<0 || i+n>=data.length) return false;\\n            if(n>0 && ((mask>>n+1)&data[i])!=0) return false;\\n        }\\n        return n==0;\\n    }\\n    \\n    int calc(int val){\\n        int n = 0;\\n        for(int mask = 128; (mask&val)!=0 && n!=4; n++)\\n            val = val<<1;\\n        return n==1 ? -1 : n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2570835,
                "title": "solution-explained-language-independent",
                "content": "After reading this solution, many of you might tag this problem as easy and not medium\\nDo let me know in comments if you guys find it difficult to understand some point, will keep those points in mind for future posts\\n\\nLet me first repost the desired part of question here :)\\n\\nThis is how the UTF-8 encoding would work:\\n\\n```\\n Number of Bytes   |        UTF-8 Octet Sequence\\n                       |              (binary)\\n   --------------------+-----------------------------------------\\n            1          |   0xxxxxxx\\n            2          |   110xxxxx 10xxxxxx\\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n```\\n\\nSo, a UTF-8 can have 1 to 4 byes\\n\\nLets break down the problem\\n0. We cannot have more than 4 bytes in UTF-8\\n1. To check the number of bytes i.e. 1,2,3,4 or something else\\n2. Now the next n-1 numbers should have 10 in their most significant bit\\n3. One more point, will cover later ;)\\n4. Lets bring it all togeather\\n\\nLet me take both parts one by one\\n\\n**1. To check the number of bytes i.e. 1,2,3,4 or something else**\\n\\nLet me create a method getNumberOfBytes, which takes an integer number as input and tell me the number of bytes in this sequence\\n\\n```\\n public int getNumberOfBytes(int data){\\n        //If it starts with 0 then, right shifting it by 7 times gives 0\\n        if((data>>7)==0) return 1;\\n        //If it starts with 110, then right shifting by 5 times gives 110 i.e. 6\\n        if((data>>5)==6) return 2;\\n        //If it starts with 1110, then right shifting by 4 times gives 1110 i.e. 14\\n        if((data>>4)==14) return 3;\\n        //If it starts with 11110, then right shifting by 3 times gives 11110 i.e. 30\\n        if((data>>3)==30) return 4;\\n        else return -1;\\n    }\\n```\\n\\n**2. Now the next n-1 numbers should have 10 in their most significant bit**\\nThis will check, if the number actually has 10 in its MSB.\\nThis will be called for the next n-1 numbers\\'\\n```\\n//To check if number actually starts with 10\\n    public boolean isTrailingNumber(int data){\\n        //If it starts with 10, then right shifting by 6 times gives 10 i.e. 2\\n        return ((data>>6)==2);\\n    }\\n```\\n\\n**3. One more point, will cover later ;)**\\nNow, we find out the number of bits in point 1, and for remaining n-1 elements we checked if they are having 10 in their MSB.\\nWhat if we get number of bytes as n, but we dont have n numbes after that ?\\nSo, its better if after getting the number of bytes we also check if we have n-1 numbers after it. This will save our bit operation for trailing numbers\\n\\n**4. Lets bring it all togeather**\\nNow, lets write our parent code which uses the code written in 1 & 2 plus some more logic :)\\n\\nI will be using a pointer technique here to iterate over array.\\n\\n```\\npublic boolean validUtf8(int[] data) {\\n        //Initialize pointer to 0\\n        int p=0;\\n        //Run a loop till pointer reaches the end\\n        while(p<data.length){\\n            //Get the number of bytes for the data\\n            int numberOfBytes = getNumberOfBytes(data[p]);\\n            //If number of bytes is not 1,2,3 or 4 or something else, we will return false\\n            if(numberOfBytes==-1) return false;\\n            //To check if we have n-1 number after this point\\n            if(numberOfBytes>data.length-p) return false;\\n            //Increment the pointer for next iteration\\n            p++;\\n            //Now if we have numberOfBytes more than 1, we need to check that next n-1 numbers should start with 10 in MSB\\n            while (numberOfBytes>1){\\n                //Using the numberOfBytes as the counter itself\\n                numberOfBytes--;\\n                //If this number doesn\\'t starts with 10, we can return false from here\\n                if(!isTrailingNumber(data[p]))\\n                    return false;\\n                //Increment the main pointer so we dont process this entry again :)\\n                p++;\\n            }\\n        }\\n        //If everything goes right, we will land here :)\\n        return true;\\n    }\\n\\n```\\nPlease comment and upvote guys if you like this solution",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n Number of Bytes   |        UTF-8 Octet Sequence\\n                       |              (binary)\\n   --------------------+-----------------------------------------\\n            1          |   0xxxxxxx\\n            2          |   110xxxxx 10xxxxxx\\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n```\n```\\n public int getNumberOfBytes(int data){\\n        //If it starts with 0 then, right shifting it by 7 times gives 0\\n        if((data>>7)==0) return 1;\\n        //If it starts with 110, then right shifting by 5 times gives 110 i.e. 6\\n        if((data>>5)==6) return 2;\\n        //If it starts with 1110, then right shifting by 4 times gives 1110 i.e. 14\\n        if((data>>4)==14) return 3;\\n        //If it starts with 11110, then right shifting by 3 times gives 11110 i.e. 30\\n        if((data>>3)==30) return 4;\\n        else return -1;\\n    }\\n```\n```\\n//To check if number actually starts with 10\\n    public boolean isTrailingNumber(int data){\\n        //If it starts with 10, then right shifting by 6 times gives 10 i.e. 2\\n        return ((data>>6)==2);\\n    }\\n```\n```\\npublic boolean validUtf8(int[] data) {\\n        //Initialize pointer to 0\\n        int p=0;\\n        //Run a loop till pointer reaches the end\\n        while(p<data.length){\\n            //Get the number of bytes for the data\\n            int numberOfBytes = getNumberOfBytes(data[p]);\\n            //If number of bytes is not 1,2,3 or 4 or something else, we will return false\\n            if(numberOfBytes==-1) return false;\\n            //To check if we have n-1 number after this point\\n            if(numberOfBytes>data.length-p) return false;\\n            //Increment the pointer for next iteration\\n            p++;\\n            //Now if we have numberOfBytes more than 1, we need to check that next n-1 numbers should start with 10 in MSB\\n            while (numberOfBytes>1){\\n                //Using the numberOfBytes as the counter itself\\n                numberOfBytes--;\\n                //If this number doesn\\'t starts with 10, we can return false from here\\n                if(!isTrailingNumber(data[p]))\\n                    return false;\\n                //Increment the main pointer so we dont process this entry again :)\\n                p++;\\n            }\\n        }\\n        //If everything goes right, we will land here :)\\n        return true;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569230,
                "title": "python-bit-manipulation-explained-and-commented",
                "content": "# Logic explanation\\n1. We need to check for UTF-8 validity, the rules:\\n* Either the character is encoded on the first byte, which starts with 0xxxxxxx\\n* Or the character is encoded on `2<=n<=4` bytes, where the first byte starts with `n` set bits, followed by 1 unset bit, and the rest of the n-1 bytes should start with 10xxxxxx\\n\\n2. We are given an array of data integers, we care only about the least significant byte (last 8 bits)\\n\\n3. Simulate that logic\\n\\nThe code is heavily commented, go through it.\\n\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        i = 0\\n        \\n        while i < n:\\n            valid_encoding = False\\n            if self.one_byte_encoding(data[i]):\\n                i += 1\\n                valid_encoding = True\\n            \\n            for byte_len in range(2, 4 + 1):\\n                if self.byte_encoding(byte_len, data, i):\\n                    i += byte_len\\n                    valid_encoding = True\\n                    break\\n            \\n            if not valid_encoding:\\n                return False\\n        return True\\n    \\n    def one_byte_encoding(self, number: int):\\n\\t\\t# check if 8th bit is set\\n        if number & 1 << 7 == 0:\\n            return True\\n        return False\\n\\n    def byte_encoding(self, byte_len, data, i):\\n        # out of bound check\\n        if i + byte_len > len(data):\\n            return False\\n\\n        # first byte should be byte_len 1\\'s followed by 0\\n        first_byte = data[i]\\n        for j in range(byte_len):\\n            if first_byte & 1<<(7-j) == 0:\\n                return False\\n\\n        # check n+1 bit to be 0\\n        if first_byte & 1 << 7 - byte_len != 0:\\n            return False\\n\\n\\t\\t# the rest n-1 bytes should be 10xxxxxx\\n        for j in range(i+1, i + 1 + (byte_len - 1)):\\n            # check 10xxxxxx\\n            if data[j] & 1<<7 == 0:\\n                return False\\n            if data[j] & 1<< 6 != 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        i = 0\\n        \\n        while i < n:\\n            valid_encoding = False\\n            if self.one_byte_encoding(data[i]):\\n                i += 1\\n                valid_encoding = True\\n            \\n            for byte_len in range(2, 4 + 1):\\n                if self.byte_encoding(byte_len, data, i):\\n                    i += byte_len\\n                    valid_encoding = True\\n                    break\\n            \\n            if not valid_encoding:\\n                return False\\n        return True\\n    \\n    def one_byte_encoding(self, number: int):\\n\\t\\t# check if 8th bit is set\\n        if number & 1 << 7 == 0:\\n            return True\\n        return False\\n\\n    def byte_encoding(self, byte_len, data, i):\\n        # out of bound check\\n        if i + byte_len > len(data):\\n            return False\\n\\n        # first byte should be byte_len 1\\'s followed by 0\\n        first_byte = data[i]\\n        for j in range(byte_len):\\n            if first_byte & 1<<(7-j) == 0:\\n                return False\\n\\n        # check n+1 bit to be 0\\n        if first_byte & 1 << 7 - byte_len != 0:\\n            return False\\n\\n\\t\\t# the rest n-1 bytes should be 10xxxxxx\\n        for j in range(i+1, i + 1 + (byte_len - 1)):\\n            # check 10xxxxxx\\n            if data[j] & 1<<7 == 0:\\n                return False\\n            if data[j] & 1<< 6 != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458797,
                "title": "javascript-solution-string-bit-manipulation",
                "content": "### The idea - String Manipulation\\n1. Convert into binary strings\\n2. Find the lengh of leading `1` using `indexOf(0)`\\n3. Use `current` as a counter for the on-going UTF8 length\\n4. A length of `1` or `>4`  is considered invalid\\n```\\nvar validUtf8 = function(data) {\\n    let binary = data.map((i)=>{\\n        let b = \"00000000\" + i.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n    let current = 0; // current UTF8 length\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            if (bytes==0) continue; // skip single byte character\\n            if (bytes > 4 || bytes < 2) return false; // length thats > 4 or < 2 is an invalid utf encoding\\n            current = bytes; // set the remaining length\\n        } else {\\n            if (bytes != 1) return false\\n        }\\n        current--;\\n    }\\n    return current==0;\\n};\\n```\\n### The idea - Bit Manipulation\\n1. Exactly the same, but using bit masks.\\n``` javascript \\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    let mostSig = 1<<7;\\n    let secSig = 1<<6\\n    for (let n of data) {\\n        if (count == 0) {\\n            let mask = 1<<7;\\n            while (n & mask) {\\n                mask = mask>>1;\\n                count++;\\n            }\\n            if (count == 0) continue;\\n            if (count == 1 || count > 4) return false;\\n        } else {\\n            if (!(n&mostSig && !(n&secSig))) return false;\\n        }\\n        count--;\\n    }\\n    return count == 0;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar validUtf8 = function(data) {\\n    let binary = data.map((i)=>{\\n        let b = \"00000000\" + i.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n    let current = 0; // current UTF8 length\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            if (bytes==0) continue; // skip single byte character\\n            if (bytes > 4 || bytes < 2) return false; // length thats > 4 or < 2 is an invalid utf encoding\\n            current = bytes; // set the remaining length\\n        } else {\\n            if (bytes != 1) return false\\n        }\\n        current--;\\n    }\\n    return current==0;\\n};\\n```\n``` javascript \\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    let mostSig = 1<<7;\\n    let secSig = 1<<6\\n    for (let n of data) {\\n        if (count == 0) {\\n            let mask = 1<<7;\\n            while (n & mask) {\\n                mask = mask>>1;\\n                count++;\\n            }\\n            if (count == 0) continue;\\n            if (count == 1 || count > 4) return false;\\n        } else {\\n            if (!(n&mostSig && !(n&secSig))) return false;\\n        }\\n        count--;\\n    }\\n    return count == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569878,
                "title": "short-and-easy-solution",
                "content": "Credits to @fight.for.dream!\\n\\n```csharp\\npublic bool ValidUtf8(int[] bytes)\\n{\\n\\tint n = 0;\\n\\n\\tforeach (int b in bytes)\\n\\t{\\n\\t\\tif (n == 0)\\n\\t\\t{\\n\\t\\t\\tif (b >> 5 == 0b110) { n = 1; continue; }\\n\\t\\t\\tif (b >> 4 == 0b1110) { n = 2; continue; }\\n\\t\\t\\tif (b >> 3 == 0b11110) { n = 3; continue; }\\n\\n\\t\\t\\tif (b >> 7 != 0) return false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (b >> 6 != 0b10) return false;\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn n == 0;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic bool ValidUtf8(int[] bytes)\\n{\\n\\tint n = 0;\\n\\n\\tforeach (int b in bytes)\\n\\t{\\n\\t\\tif (n == 0)\\n\\t\\t{\\n\\t\\t\\tif (b >> 5 == 0b110) { n = 1; continue; }\\n\\t\\t\\tif (b >> 4 == 0b1110) { n = 2; continue; }\\n\\t\\t\\tif (b >> 3 == 0b11110) { n = 3; continue; }\\n\\n\\t\\t\\tif (b >> 7 != 0) return false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (b >> 6 != 0b10) return false;\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn n == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569516,
                "title": "java-easy-fast-bit-manipulations",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for UTF-8 Validation.\\nMemory Usage: 42.9 MB, less than 93.01% of Java online submissions for UTF-8 Validation.\\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if     ((data[i]>>7) == 0) i++;\\n      else if((data[i]>>5) == 6  && i+1 < data.length && (data[i+1]>>6) == 2) i += 2;\\n      else if((data[i]>>4) == 14 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if((data[i]>>3) == 30 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }\\n}\\n```\\n\\n**less eficient version:**\\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if((data[i]>>7) == 0) i++;\\n      else if(i+1 < data.length && (data[i]>>5) == 6  && (data[i+1]>>6) == 2) i += 2;\\n      else if(i+2 < data.length && (data[i]>>4) == 14 && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if(i+2 < data.length && (data[i]>>3) == 30 && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if     ((data[i]>>7) == 0) i++;\\n      else if((data[i]>>5) == 6  && i+1 < data.length && (data[i+1]>>6) == 2) i += 2;\\n      else if((data[i]>>4) == 14 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if((data[i]>>3) == 30 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }\\n}\\n```\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if((data[i]>>7) == 0) i++;\\n      else if(i+1 < data.length && (data[i]>>5) == 6  && (data[i+1]>>6) == 2) i += 2;\\n      else if(i+2 < data.length && (data[i]>>4) == 14 && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if(i+2 < data.length && (data[i]>>3) == 30 && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569103,
                "title": "c-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        for(int i=0;i<data.size();i++){\\n            int x=0,y=data[i];\\n            for(int j=7;j>=0;j--){\\n                if(!(y&(1<<j)))break;\\n                x++;\\n            }\\n            int t=x-1,j=i+1;\\n            if(x==1||x>4)return false;\\n            while(t>0 && j<data.size()){\\n               y=data[j];\\n               int b1=(1<<7),b2=(1<<6); \\n               if(!((y&b1) && !(y&b2))){\\n                   return false;\\n               } \\n               j++;t--; \\n            }\\n            if(t>0)return false;\\n            i=j-1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        for(int i=0;i<data.size();i++){\\n            int x=0,y=data[i];\\n            for(int j=7;j>=0;j--){\\n                if(!(y&(1<<j)))break;\\n                x++;\\n            }\\n            int t=x-1,j=i+1;\\n            if(x==1||x>4)return false;\\n            while(t>0 && j<data.size()){\\n               y=data[j];\\n               int b1=(1<<7),b2=(1<<6); \\n               if(!((y&b1) && !(y&b2))){\\n                   return false;\\n               } \\n               j++;t--; \\n            }\\n            if(t>0)return false;\\n            i=j-1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569000,
                "title": "java-easy-solution-bit-manipulation-97-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    private static final int bit_7_mask = 1 << 7;\\n    private static final int bit_6_mask = 1 << 6;\\n    private static final int bit_5_mask = 1 << 5;\\n    private static final int bit_4_mask = 1 << 4;\\n    private static final int bit_3_mask = 1 << 3;\\n    \\n    public boolean validUtf8(int[] data) {\\n        int size = data.length;\\n        \\n        int i = 0, count = 1;\\n        int first, byteZ;\\n        \\n        while( i < size) {\\n            first = data[i++];\\n            byteZ = getBytes(first);\\n            \\n            if(byteZ == -1)\\n                return false;\\n            \\n            while(count < byteZ) {\\n                count++;\\n                if ((i == size) || (data[i++] < bit_7_mask))\\n                    return false;\\n            }\\n            count = 1;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int getBytes(int first) {\\n        int i = 0;\\n\\n        if((first & bit_7_mask) == 0)\\n            return 1;\\n        \\n        else if((first & bit_6_mask) == 0)\\n            return -1;\\n        \\n        else if((first & bit_5_mask) == 0)\\n            return 2;\\n        \\n        else if((first & bit_4_mask) == 0)\\n            return 3;\\n        \\n        else if((first & bit_3_mask) == 0)\\n            return 4;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    private static final int bit_7_mask = 1 << 7;\\n    private static final int bit_6_mask = 1 << 6;\\n    private static final int bit_5_mask = 1 << 5;\\n    private static final int bit_4_mask = 1 << 4;\\n    private static final int bit_3_mask = 1 << 3;\\n    \\n    public boolean validUtf8(int[] data) {\\n        int size = data.length;\\n        \\n        int i = 0, count = 1;\\n        int first, byteZ;\\n        \\n        while( i < size) {\\n            first = data[i++];\\n            byteZ = getBytes(first);\\n            \\n            if(byteZ == -1)\\n                return false;\\n            \\n            while(count < byteZ) {\\n                count++;\\n                if ((i == size) || (data[i++] < bit_7_mask))\\n                    return false;\\n            }\\n            count = 1;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int getBytes(int first) {\\n        int i = 0;\\n\\n        if((first & bit_7_mask) == 0)\\n            return 1;\\n        \\n        else if((first & bit_6_mask) == 0)\\n            return -1;\\n        \\n        else if((first & bit_5_mask) == 0)\\n            return 2;\\n        \\n        else if((first & bit_4_mask) == 0)\\n            return 3;\\n        \\n        else if((first & bit_3_mask) == 0)\\n            return 4;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387751,
                "title": "easy-c-solution-using-bitmasking-beats-69",
                "content": "\\n```\\nint rb=0;\\n        for(auto i:data){\\n            if(rb==0){\\n                \\n                if((i>>7)==0){\\n                    rb=0;\\n                }else if((i>>5)==0b110){\\n                    rb=1;\\n                }else if((i>>4)==0b1110){\\n                    rb=2;\\n                }else if((i>>3)==0b11110){\\n                    rb=3;\\n                }else return false;\\n                \\n            }else{\\n                if((i>>6)==0b10) rb--;\\n                else return false;\\n            }\\n        }\\n        if(rb==0) return true;\\n        else return false;\\n```",
                "solutionTags": [],
                "code": "```\\nint rb=0;\\n        for(auto i:data){\\n            if(rb==0){\\n                \\n                if((i>>7)==0){\\n                    rb=0;\\n                }else if((i>>5)==0b110){\\n                    rb=1;\\n                }else if((i>>4)==0b1110){\\n                    rb=2;\\n                }else if((i>>3)==0b11110){\\n                    rb=3;\\n                }else return false;\\n                \\n            }else{\\n                if((i>>6)==0b10) rb--;\\n                else return false;\\n            }\\n        }\\n        if(rb==0) return true;\\n        else return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493355,
                "title": "java-dfa-solution-with-explanation",
                "content": "**Intuition**\\nIt\\'s obviously a bit manipulation problem. But also there are lots of states need to be considered. An encoded UTF-8 character is possiblely represented by 1 to 4 bytes, which actually depends on the first byte. So after we have encountered the first byte, the next following 0 ~ 3 byte(s) must satisfy some constraints. Isn\\'t it like a state machine? Namely, DFA (Deterministic Finite Automaton).\\n**Algorithm**\\nFollow me up to build the DFA. Input is a byte represented by an integer and initial state is `0` (clear, all previous bytes are handled). Then all the valid inputs are `0xxxxxxx`, `110xxxxx`, `1110xxxxx`, `11110xxx`. So state `0` can transfer to four states. Wait, just think of the input `0xxxxxxx`: it means a single byte UTF-8 character, so all the previous byte are cleared again. Here I directly give the DFA. Any question is welcome.\\n![image](https://assets.leetcode.com/users/zdxiq125/image_1580299754.png)\\nWe take  a quick glance of the longest path `0` -> `3` -> `5` -> `6` -> `0`, which is relate to a 4-byte UTF-8 character. After encounters four bytes (`11110xxx`, `10xxxxxx`, `10xxxxxx`, `10xxxxxx` in order), the state return to `0` again. Any other inputs are illegal and will result validation failure. State `0` is the initial state and the final state.\\n**Code**\\n```java\\nclass Solution {\\n    // input types: determined by most significant 1 ~ 5 bits\\n    static final int TYPE_0 = 0b00000000;\\n    static final int TYPE_1 = 0b10000000;\\n    static final int TYPE_2 = 0b11000000;\\n    static final int TYPE_3 = 0b11100000;\\n    static final int TYPE_4 = 0b11110000;\\n    // masks for most significant 1 to 5 bis\\n    static final int[] MASKS = new int[]{0b10000000, 0b11000000, 0b11100000, 0b11110000, 0b11111000};\\n    // input type enumation\\n    static final int[] TYPES = new int[]{TYPE_0, TYPE_1, TYPE_2, TYPE_3, TYPE_4};\\n    // map of cur_stat : (input_type : next_stat)\\n    static final Map<Integer, Map<Integer, Integer>> DFA = new HashMap<>();\\n\\t\\n\\tprivate static int getType(int in) {\\n        // type 0: 0xxxxxxx\\n        // type 1: 10xxxxxx\\n        // type 2: 110xxxxx\\n        // type 3: 1110xxxx\\n        // type 4: 11110xxx\\n        for (int i = 0; i < TYPES.length; i++) {\\n            if ((MASKS[i] & in) == TYPES[i]) {\\n                return TYPES[i];\\n            }\\n        }\\n\\t\\t// unreachable. unless input is \"11111xxx\" which is not a valid utf-8 character.\\n        return -1;\\n    }\\n    // build the dfa\\n    static {\\n        DFA.put(0, Map.of(TYPE_0, 0, TYPE_2, 1, TYPE_3, 2, TYPE_4, 3));\\n        DFA.put(1, Map.of(TYPE_1, 0));\\n        DFA.put(2, Map.of(TYPE_1, 4));\\n        DFA.put(4, Map.of(TYPE_1, 0));\\n        DFA.put(3, Map.of(TYPE_1, 5));\\n        DFA.put(5, Map.of(TYPE_1, 6));\\n        DFA.put(6, Map.of(TYPE_1, 0));\\n    }\\n    \\n    public boolean validUtf8(int[] data) {\\n        int cur = 0;\\n        for (int input : data) {\\n            Integer next = getNext(cur, input);\\n            if (next == null) {\\n                return false;\\n            }\\n            cur = next;\\n        }\\n        return cur == 0;\\n    }\\n    \\n    private static Integer getNext(int cur, int input) {\\n        int type = getType(input);\\n        if (type == -1) return null;\\n        return DFA.get(cur).get(type);\\n    }\\n}\\n```\\n**Complexity**\\nTime: O(n)\\nSpace: O(1)",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    // input types: determined by most significant 1 ~ 5 bits\\n    static final int TYPE_0 = 0b00000000;\\n    static final int TYPE_1 = 0b10000000;\\n    static final int TYPE_2 = 0b11000000;\\n    static final int TYPE_3 = 0b11100000;\\n    static final int TYPE_4 = 0b11110000;\\n    // masks for most significant 1 to 5 bis\\n    static final int[] MASKS = new int[]{0b10000000, 0b11000000, 0b11100000, 0b11110000, 0b11111000};\\n    // input type enumation\\n    static final int[] TYPES = new int[]{TYPE_0, TYPE_1, TYPE_2, TYPE_3, TYPE_4};\\n    // map of cur_stat : (input_type : next_stat)\\n    static final Map<Integer, Map<Integer, Integer>> DFA = new HashMap<>();\\n\\t\\n\\tprivate static int getType(int in) {\\n        // type 0: 0xxxxxxx\\n        // type 1: 10xxxxxx\\n        // type 2: 110xxxxx\\n        // type 3: 1110xxxx\\n        // type 4: 11110xxx\\n        for (int i = 0; i < TYPES.length; i++) {\\n            if ((MASKS[i] & in) == TYPES[i]) {\\n                return TYPES[i];\\n            }\\n        }\\n\\t\\t// unreachable. unless input is \"11111xxx\" which is not a valid utf-8 character.\\n        return -1;\\n    }\\n    // build the dfa\\n    static {\\n        DFA.put(0, Map.of(TYPE_0, 0, TYPE_2, 1, TYPE_3, 2, TYPE_4, 3));\\n        DFA.put(1, Map.of(TYPE_1, 0));\\n        DFA.put(2, Map.of(TYPE_1, 4));\\n        DFA.put(4, Map.of(TYPE_1, 0));\\n        DFA.put(3, Map.of(TYPE_1, 5));\\n        DFA.put(5, Map.of(TYPE_1, 6));\\n        DFA.put(6, Map.of(TYPE_1, 0));\\n    }\\n    \\n    public boolean validUtf8(int[] data) {\\n        int cur = 0;\\n        for (int input : data) {\\n            Integer next = getNext(cur, input);\\n            if (next == null) {\\n                return false;\\n            }\\n            cur = next;\\n        }\\n        return cur == 0;\\n    }\\n    \\n    private static Integer getNext(int cur, int input) {\\n        int type = getType(input);\\n        if (type == -1) return null;\\n        return DFA.get(cur).get(type);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257077,
                "title": "393-time-93-77-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a counter variable count to keep track of how many continuation bytes are expected.\\n```\\ncount = 0\\n```\\n2. Iterate through each integer in the input data list data.\\n```\\nfor num in data:\\n```\\n3. If the count is 0, check how many leading 1\\'s there are in the current integer to determine how many bytes are expected for the current character. If the first few bits of the current integer do not match any valid UTF-8 patterns or if the first bit of the current integer is a 1 (indicating that it is not the start of a character), return False.\\n```\\nif count == 0:\\n    if (num >> 5) == 0b110:\\n        count = 1\\n    elif (num >> 4) == 0b1110:\\n        count = 2\\n    elif (num >> 3) == 0b11110:\\n        count = 3\\n    elif (num >> 7) != 0:\\n        return False\\n```\\n4. If the count is not 0, check if the current integer is a continuation byte (i.e. the first two bits are 10). If not, return False. Subtract 1 from the count since a continuation byte has been encountered.\\n```\\nelse:\\n    if (num >> 6) != 0b10:\\n        return False\\n    count -= 1\\n```\\n5. After iterating through all the integers, if the count is still not 0, it is invalid. Return False.\\n```\\nreturn count == 0\\n```\\nOverall, the solution works by iterating through each integer in the input data list and checking if it is a valid start byte or continuation byte for a UTF-8 character. The count variable is used to keep track of how many continuation bytes are expected for the current character. If the input data list contains a valid sequence of bytes for a UTF-8 character, the count variable should end up at 0 after all the integers have been processed.\\n\\n# Complexity\\n- Time complexity:\\nThe solution involves iterating through each integer in the input data list exactly once. Within the iteration, the bitwise operations used to check the number of leading 1\\'s and the continuation bytes take constant time. Therefore, the time complexity of the solution is O(n), where n is the length of the input data list.\\n\\n- Space complexity:\\nThe solution uses a constant amount of extra space to store the counter variable. Therefore, the space complexity of the solution is O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        # Initialize a counter variable\\n        count = 0\\n        \\n        # Iterate through each integer in the input data list\\n        for num in data:\\n            # If the count is 0, check how many leading 1\\'s there are in the current integer\\n            if count == 0:\\n                if (num >> 5) == 0b110:\\n                    count = 1\\n                elif (num >> 4) == 0b1110:\\n                    count = 2\\n                elif (num >> 3) == 0b11110:\\n                    count = 3\\n                elif (num >> 7) != 0:\\n                    return False\\n            # If the count is not 0, check if the current integer is a continuation byte\\n            else:\\n                if (num >> 6) != 0b10:\\n                    return False\\n                count -= 1\\n        \\n        # If the count is still not 0 after iterating through all the integers, it is invalid\\n        return count == 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\ncount = 0\\n```\n```\\nfor num in data:\\n```\n```\\nif count == 0:\\n    if (num >> 5) == 0b110:\\n        count = 1\\n    elif (num >> 4) == 0b1110:\\n        count = 2\\n    elif (num >> 3) == 0b11110:\\n        count = 3\\n    elif (num >> 7) != 0:\\n        return False\\n```\n```\\nelse:\\n    if (num >> 6) != 0b10:\\n        return False\\n    count -= 1\\n```\n```\\nreturn count == 0\\n```\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        # Initialize a counter variable\\n        count = 0\\n        \\n        # Iterate through each integer in the input data list\\n        for num in data:\\n            # If the count is 0, check how many leading 1\\'s there are in the current integer\\n            if count == 0:\\n                if (num >> 5) == 0b110:\\n                    count = 1\\n                elif (num >> 4) == 0b1110:\\n                    count = 2\\n                elif (num >> 3) == 0b11110:\\n                    count = 3\\n                elif (num >> 7) != 0:\\n                    return False\\n            # If the count is not 0, check if the current integer is a continuation byte\\n            else:\\n                if (num >> 6) != 0b10:\\n                    return False\\n                count -= 1\\n        \\n        # If the count is still not 0 after iterating through all the integers, it is invalid\\n        return count == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568921,
                "title": "o-n-o-n-na-ve-solution-no-bit-manipulation",
                "content": "A very simple solution with both time and space complexity being `O(N)`.\\n\\n**Approach**\\n* The basic idea is that we need a binary representation of the integers so create a list of binary representations.\\n* Next, we iterate through this list and check if the current binary string represents a 1-byte or a 2-byte or a 3-byte or a 4-byte data.\\n* If the current string represents a `1`-byte data we move to the next string\\n* If the current string represents a `k`-byte data where we `k=2,3,4`, we also check if we have at least `1,2,3` additional bytes next to it respectively. If it does, we check these bytes first two characters to be `10` and increment the loop variable `i` accordingly.\\n* If none of the above checks is true for the current string, the `else` case, it is an invalid UTF-8 representation and we return `False`.\\n* At the end of the loop we return True since it has gone through all the numbers at this point which verifies the array to be a valid UTF-8 encoding.\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n\\t    # a list to store binary representation of the numbers\\n        sequence = []\\n\\t\\t# get binary representation of all the numbers\\n        for d in data:\\n            sequence.append(\"{0:08b}\".format(d))\\n        \\n        i = 0\\n        n = len(sequence)\\n        while i < n:\\n            if sequence[i][0] == \\'0\\': # 1-byte check\\n                i += 1\\n                continue\\n            if sequence[i][:3] == \\'110\\' and n-i>=1: # 2-byte check\\n                if sequence[i+1][:2] == \\'10\\':\\n                    i += 2\\n                    continue\\n            if sequence[i][:4] == \\'1110\\' and n-i>=2: # 3-byte check\\n                if sequence[i+1][:2] == \\'10\\' and sequence[i+2][:2] == \\'10\\':\\n                    i += 3\\n                    continue\\n            if sequence[i][:5] == \\'11110\\' and n-i>=3: # 4-byte check\\n                if sequence[i+1][:2] == \\'10\\' and sequence[i+2][:2] == \\'10\\' and sequence[i+3][:2] == \\'10\\':\\n                    i += 4\\n                    continue\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n\\t    # a list to store binary representation of the numbers\\n        sequence = []\\n\\t\\t# get binary representation of all the numbers\\n        for d in data:\\n            sequence.append(\"{0:08b}\".format(d))\\n        \\n        i = 0\\n        n = len(sequence)\\n        while i < n:\\n            if sequence[i][0] == \\'0\\': # 1-byte check\\n                i += 1\\n                continue\\n            if sequence[i][:3] == \\'110\\' and n-i>=1: # 2-byte check\\n                if sequence[i+1][:2] == \\'10\\':\\n                    i += 2\\n                    continue\\n            if sequence[i][:4] == \\'1110\\' and n-i>=2: # 3-byte check\\n                if sequence[i+1][:2] == \\'10\\' and sequence[i+2][:2] == \\'10\\':\\n                    i += 3\\n                    continue\\n            if sequence[i][:5] == \\'11110\\' and n-i>=3: # 4-byte check\\n                if sequence[i+1][:2] == \\'10\\' and sequence[i+2][:2] == \\'10\\' and sequence[i+3][:2] == \\'10\\':\\n                    i += 4\\n                    continue\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568848,
                "title": "python3-dp-memoization-neat-solution-o-n",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        l = [2**i for i in range(7, -1, -1)]\\n        \\n        def isXByteSeq(pos, X):\\n            f = data[pos]\\n            rem = data[pos+1:pos+X]\\n            ret = (f&l[X]) == 0\\n            for i in range(X):\\n                ret &= (f&l[i]) != 0\\n            for num in rem:\\n                ret &= (num&l[0]) != 0\\n                ret &= (num&l[1]) == 0\\n            return ret\\n            \\n        @cache\\n        def res(pos = 0):\\n            ret = False\\n            if pos == n:\\n                ret = True\\n            if pos + 3 < n:\\n                ret |= isXByteSeq(pos, 4) and res(pos + 4)\\n            if pos + 2 < n:\\n                ret |= isXByteSeq(pos, 3) and res(pos + 3)\\n            if pos + 1 < n:\\n                ret |= isXByteSeq(pos, 2) and res(pos + 2)\\n            if pos < n:\\n                ret |= isXByteSeq(pos, 0) and res(pos + 1)\\n            return ret\\n        \\n        return res()\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        l = [2**i for i in range(7, -1, -1)]\\n        \\n        def isXByteSeq(pos, X):\\n            f = data[pos]\\n            rem = data[pos+1:pos+X]\\n            ret = (f&l[X]) == 0\\n            for i in range(X):\\n                ret &= (f&l[i]) != 0\\n            for num in rem:\\n                ret &= (num&l[0]) != 0\\n                ret &= (num&l[1]) == 0\\n            return ret\\n            \\n        @cache\\n        def res(pos = 0):\\n            ret = False\\n            if pos == n:\\n                ret = True\\n            if pos + 3 < n:\\n                ret |= isXByteSeq(pos, 4) and res(pos + 4)\\n            if pos + 2 < n:\\n                ret |= isXByteSeq(pos, 3) and res(pos + 3)\\n            if pos + 1 < n:\\n                ret |= isXByteSeq(pos, 2) and res(pos + 2)\\n            if pos < n:\\n                ret |= isXByteSeq(pos, 0) and res(pos + 1)\\n            return ret\\n        \\n        return res()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568689,
                "title": "daily-leetcoding-challenge-september-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/utf-8-validation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** String Manipulation.\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/utf-8-validation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 87452,
                "title": "27-49-pass-python-easy-to-understand-don-t-understand-why-case-250-145-145-145-145-need-return-false",
                "content": "Failed for case [250, 145, 145, 145, 145], expect false, my code return true.\\n\\nDon't understand why this case is false.\\n-----------------------------------------------------------\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        print \"inputed data = \", data\\n        numData = len(data)\\n        print \"numData = \", numData\\n\\n        if numData < 1:\\n            return False\\n\\n        binData = []\\n        for d in data:\\n            binData.append(str('{:08b}'.format(d)))\\n        # binData = bin(data)\\n        #\\n        print \"binData = \", binData\\n\\n        def detectOnes(string):\\n            #print \"detectOnes string = \", string\\n\\n            try:\\n                firstZero = string.index('0')\\n            except:\\n                firstZero = 8\\n            #print \"firstZero = \", firstZero\\n\\n            numStartOnes = firstZero\\n            #print \"numStartOnes = \", numStartOnes\\n\\n            return numStartOnes\\n\\n        flagValid = True\\n        while len(binData) > 0 and flagValid == True:\\n            curBinData = binData.pop(0)\\n            print \"curBinData = \", curBinData\\n\\n            curFirstZero = detectOnes(curBinData)\\n            print \"curFirstZero = \", curFirstZero\\n\\n            if curFirstZero == 0:\\n                print \"start with 0, must be a unicode code\"\\n            elif curFirstZero == 1:\\n                print \"one 1 in beginning of string\"\\n                flagValid = False\\n                break\\n            elif curFirstZero == 8:\\n                print \"something is wrong, not valid\"\\n                flagValid = False\\n                break\\n            else:\\n                print \"need more check\"\\n                for i in range(1, curFirstZero):\\n                    if len(binData) < 1:\\n                        flagValid = False\\n                        break\\n\\n                    newCurBinData = binData.pop(0)\\n                    print \"newCurBinData = \", newCurBinData\\n                    if detectOnes(newCurBinData) != 1:\\n                        flagValid = False\\n                        break\\n\\n\\n        print \"return flagValid = \", flagValid\\n        return flagValid",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        print \"inputed data = \", data\\n        numData = len(data)\\n        print \"numData = \", numData\\n\\n        if numData < 1:\\n            return False\\n\\n        binData = []\\n        for d in data:\\n            binData.append(str('{:08b}",
                "codeTag": "Java"
            },
            {
                "id": 87489,
                "title": "o-n-solution-using-java",
                "content": "\\n```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int n = data.length;\\n        if (n == 0) return true;\\n        int skip = 0b10000000;\\n        int check = 0;\\n        for (int i = 0; i < data.length; i++) {\\n            if (check > 0) {\\n                if ((data[i] & skip) == skip) check--;\\n                else return false;\\n            } else {\\n                check = getOneBitCountFromHead(data[i]);\\n                if (check < 0) return false;\\n            }\\n        }\\n        return check == 0;\\n    }\\n    private int getOneBitCountFromHead(int num) {\\n        if ((num & 0b11110000) == 0b11110000) return 3;\\n        if ((num & 0b11100000) == 0b11100000) return 2;\\n        if ((num & 0b11000000) == 0b11000000) return 1;\\n        if ((num & 0b10000000) == 0b10000000) return -1; //error\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int n = data.length;\\n        if (n == 0) return true;\\n        int skip = 0b10000000;\\n        int check = 0;\\n        for (int i = 0; i < data.length; i++) {\\n            if (check > 0) {\\n                if ((data[i] & skip) == skip) check--;\\n                else return false;\\n            } else {\\n                check = getOneBitCountFromHead(data[i]);\\n                if (check < 0) return false;\\n            }\\n        }\\n        return check == 0;\\n    }\\n    private int getOneBitCountFromHead(int num) {\\n        if ((num & 0b11110000) == 0b11110000) return 3;\\n        if ((num & 0b11100000) == 0b11100000) return 2;\\n        if ((num & 0b11000000) == 0b11000000) return 1;\\n        if ((num & 0b10000000) == 0b10000000) return -1; //error\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577038,
                "title": "python3-10-lines-binary-pad-w-explanation-t-m-95-97",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        \\n        count = 0                                   # Keep a tally of non-first bytes required\\n        \\n        for byte in data:                           # Pad out bytes to nine digits and ignore the 1st 1\\n            byte|= 256                                  # Ex: 35 = 0b100101 --> 35|256 = 0b1_00100101\\n\\t\\t\\t\\n                                                    # Check for bad bytes.\\n            if (byte >> 3 == 0b1_11111 or               # One of first five digits must be a 1\\n                (byte >> 6 == 0b1_10)^(count>0)):       # Non-first byte can happen if and only if the current count !=0.\\n                return False\\n                                                    # Update counts after new byte. (1-byte -> no change\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# to count required because count == 0.)\\n            if   byte >> 5 == 0b1_110 : count = 1       # 2-byte first byte\\n            elif byte >> 4 == 0b1_1110: count = 2       # 3-byte first byte\\n            elif byte >> 4 == 0b1_1111: count = 3       # 4-byte first byte\\n            elif byte >> 6 == 0b1_10  : count-= 1       # non-first bytes\\n\\n        return not count                            # Check for zero-count at EOL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        \\n        count = 0                                   # Keep a tally of non-first bytes required\\n        \\n        for byte in data:                           # Pad out bytes to nine digits and ignore the 1st 1\\n            byte|= 256                                  # Ex: 35 = 0b100101 --> 35|256 = 0b1_00100101\\n\\t\\t\\t\\n                                                    # Check for bad bytes.\\n            if (byte >> 3 == 0b1_11111 or               # One of first five digits must be a 1\\n                (byte >> 6 == 0b1_10)^(count>0)):       # Non-first byte can happen if and only if the current count !=0.\\n                return False\\n                                                    # Update counts after new byte. (1-byte -> no change\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# to count required because count == 0.)\\n            if   byte >> 5 == 0b1_110 : count = 1       # 2-byte first byte\\n            elif byte >> 4 == 0b1_1110: count = 2       # 3-byte first byte\\n            elif byte >> 4 == 0b1_1111: count = 3       # 4-byte first byte\\n            elif byte >> 6 == 0b1_10  : count-= 1       # non-first bytes\\n\\n        return not count                            # Check for zero-count at EOL",
                "codeTag": "Java"
            },
            {
                "id": 2572762,
                "title": "c-easy-recursion-solution",
                "content": "//Consider all four cases and iterate the index based on which case you have encounter//\\n//if it reaches the last index without any problem, that means its the correct UTF-8 code//\\n\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> &data, int i,int n){\\n        if(i == n){\\n            return true;\\n        }\\n        if((data[i]&(1<<7)) == 0){\\n            return solve(data,i+1,n);\\n        }\\n        else if(i<(n-1) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0) return solve(data,i+2,n);\\n        }\\n        else if(i<(n-2) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) != 0 && (data[i]&(1<<4)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0 && (data[i+2]&(1<<7)) != 0 && (data[i+2]&(1<<6)) == 0) return solve(data,i+3,n);\\n        }\\n        else if(i<(n-3) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) != 0 && (data[i]&(1<<4)) != 0 && (data[i]&(1<<3)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0 && (data[i+2]&(1<<7)) != 0 && (data[i+2]&(1<<6)) == 0 && (data[i+3]&(1<<7)) != 0 && (data[i+3]&(1<<6)) == 0) return solve(data,i+4,n);\\n        }\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        return solve(data,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> &data, int i,int n){\\n        if(i == n){\\n            return true;\\n        }\\n        if((data[i]&(1<<7)) == 0){\\n            return solve(data,i+1,n);\\n        }\\n        else if(i<(n-1) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0) return solve(data,i+2,n);\\n        }\\n        else if(i<(n-2) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) != 0 && (data[i]&(1<<4)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0 && (data[i+2]&(1<<7)) != 0 && (data[i+2]&(1<<6)) == 0) return solve(data,i+3,n);\\n        }\\n        else if(i<(n-3) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) != 0 && (data[i]&(1<<4)) != 0 && (data[i]&(1<<3)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0 && (data[i+2]&(1<<7)) != 0 && (data[i+2]&(1<<6)) == 0 && (data[i+3]&(1<<7)) != 0 && (data[i+3]&(1<<6)) == 0) return solve(data,i+4,n);\\n        }\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        return solve(data,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570991,
                "title": "c-implementation-easiest-solution",
                "content": "class Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int cnt = 0;\\n        for (auto i : data) {\\n            if (cnt == 0) {\\n                if ((i >> 5) == 0b110) \\n                    cnt = 1;\\n                else if ((i >> 4) == 0b1110) \\n                    cnt = 2;\\n                else if ((i >> 3) == 0b11110)\\n                    cnt = 3;\\n                else if ((i >> 7)) \\n                    return false;\\n                \\n            } \\n            else {\\n                if ((i >> 6) != 0b10)\\n                    return false;\\n                cnt--;\\n            }\\n        }\\n        return cnt==0;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int cnt = 0;\\n        for (auto i : data) {\\n            if (cnt == 0) {\\n                if ((i >> 5) == 0b110) \\n                    cnt = 1;\\n                else if ((i >> 4) == 0b1110) \\n                    cnt = 2;\\n                else if ((i >> 3) == 0b11110)\\n                    cnt = 3;\\n                else if ((i >> 7)) \\n                    return false;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2570058,
                "title": "c-use-bit-manipulation",
                "content": "**Code:**\\n```\\nclass Solution \\n{\\npublic:\\n    bool validUtf8(vector<int>& data) \\n    {\\n        int cnt=0;\\n        for(auto it : data)\\n        {\\n            if(cnt==0) //for 1st 1 byte of data or first number, Eg-1: 197\\n            {\\n                //0b used for binary number\\n                if((it>>5) == 0b110) cnt=1; //check first 3 bit of it is equal to 110\\n                else if((it>>4) == 0b1110) cnt=2; //check first 4 bit of it is equal to 1110\\n                else if((it>>3) == 0b11110) cnt=3; //check first 5 bit of it is equal to 11110\\n                else if((it>>7)) return false;\\n            }\\n            \\n            else //for next bytes of data or remaining number,Eg-2: 130, 1\\n            {\\n                if(it>>6 != 0b10) return false; //check n-1 bytes equal to 10 or not\\n                cnt--;\\n            }\\n            \\n        }\\n        return cnt==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool validUtf8(vector<int>& data) \\n    {\\n        int cnt=0;\\n        for(auto it : data)\\n        {\\n            if(cnt==0) //for 1st 1 byte of data or first number, Eg-1: 197\\n            {\\n                //0b used for binary number\\n                if((it>>5) == 0b110) cnt=1; //check first 3 bit of it is equal to 110\\n                else if((it>>4) == 0b1110) cnt=2; //check first 4 bit of it is equal to 1110\\n                else if((it>>3) == 0b11110) cnt=3; //check first 5 bit of it is equal to 11110\\n                else if((it>>7)) return false;\\n            }\\n            \\n            else //for next bytes of data or remaining number,Eg-2: 130, 1\\n            {\\n                if(it>>6 != 0b10) return false; //check n-1 bytes equal to 10 or not\\n                cnt--;\\n            }\\n            \\n        }\\n        return cnt==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569537,
                "title": "python-very-simple-bit-shift",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        i = 0\\n        while i < len(data):\\n            if data[i] >> 7 == 0:\\n                i += 1\\n            elif data[i] >> 5 == 0b110:\\n                if i+1 == len(data) or data[i+1] >> 6 != 0b10:\\n                    return False\\n                i += 2\\n            elif data[i] >> 4 == 0b1110:\\n                if i+2 >= len(data) or data[i+1] >> 6 != 0b10 or data[i+2] >> 6 != 0b10:\\n                    return False\\n                i += 3\\n            elif data[i] >> 3 == 0b11110:\\n                if i+3 >= len(data) or data[i+1] >> 6 != 0b10 or data[i+2] >> 6 != 0b10 or data[i+3] >> 6 != 0b10:\\n                    return False\\n                i += 4\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        i = 0\\n        while i < len(data):\\n            if data[i] >> 7 == 0:\\n                i += 1\\n            elif data[i] >> 5 == 0b110:\\n                if i+1 == len(data) or data[i+1] >> 6 != 0b10:\\n                    return False\\n                i += 2\\n            elif data[i] >> 4 == 0b1110:\\n                if i+2 >= len(data) or data[i+1] >> 6 != 0b10 or data[i+2] >> 6 != 0b10:\\n                    return False\\n                i += 3\\n            elif data[i] >> 3 == 0b11110:\\n                if i+3 >= len(data) or data[i+1] >> 6 != 0b10 or data[i+2] >> 6 != 0b10 or data[i+3] >> 6 != 0b10:\\n                    return False\\n                i += 4\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569021,
                "title": "js-javascript-nubby-s-solution",
                "content": "# Any feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nconst validUtf8 = function(data) {\\n  let next;\\n  let arr = data.map((num) => num.toString(2).padStart(8, \"0\"));\\n  let len = arr.length;\\n  \\n  for (let i = 0; i < len; i++) {\\n    if (arr[i][0] === \\'0\\') continue;\\n    else {\\n      if (arr[i].slice(0,3) === \\'110\\') {\\n        next = 1;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else if (arr[i].slice(0, 4) === \\'1110\\') {\\n        next = 2;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else if (arr[i].slice(0,5) === \\'11110\\') {\\n        next = 3;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else return false;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst validUtf8 = function(data) {\\n  let next;\\n  let arr = data.map((num) => num.toString(2).padStart(8, \"0\"));\\n  let len = arr.length;\\n  \\n  for (let i = 0; i < len; i++) {\\n    if (arr[i][0] === \\'0\\') continue;\\n    else {\\n      if (arr[i].slice(0,3) === \\'110\\') {\\n        next = 1;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else if (arr[i].slice(0, 4) === \\'1110\\') {\\n        next = 2;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else if (arr[i].slice(0,5) === \\'11110\\') {\\n        next = 3;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else return false;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568826,
                "title": "java-bit-manipulation-easy-playground-solution",
                "content": "***plz... upvote! if you find my solution helpful.*** \\n\\nStatus: **Accepted***\\nRuntime: 1 ms\\nMemory Usage: 47.5 MB\\nAll test cases passed.\\n\\n<iframe src=\"https://leetcode.com/playground/WwrAMyK4/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "***plz... upvote! if you find my solution helpful.*** \\n\\nStatus: **Accepted***\\nRuntime: 1 ms\\nMemory Usage: 47.5 MB\\nAll test cases passed.\\n\\n<iframe src=\"https://leetcode.com/playground/WwrAMyK4/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2568798,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let binary = data.map(d => {\\n        let b = \"00000000\" + d.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n// current UTF8 length\\nlet current = 0; \\n\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            // skip the single byte char\\n            if (bytes==0) {\\n                continue;\\n            }  \\n            if (bytes > 4 || bytes < 2) {\\n              return false;  \\n            }\\n            // set the remaining length\\n            current = bytes;\\n        } else {\\n            if (bytes != 1) {\\n                return false\\n            } \\n        }\\n        current--;\\n    }\\n    return current==0;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let binary = data.map(d => {\\n        let b = \"00000000\" + d.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n// current UTF8 length\\nlet current = 0; \\n\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            // skip the single byte char\\n            if (bytes==0) {\\n                continue;\\n            }  \\n            if (bytes > 4 || bytes < 2) {\\n              return false;  \\n            }\\n            // set the remaining length\\n            current = bytes;\\n        } else {\\n            if (bytes != 1) {\\n                return false\\n            } \\n        }\\n        current--;\\n    }\\n    return current==0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1380903,
                "title": "python-faster-100",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        eighth_bit = 1 << 7\\n        seventh_bit = 1 << 6\\n        sixth_bit = 1 << 5\\n        fifth_bit = 1 << 4\\n        fourth_bit = 1 << 3\\n        \\n        trailing_byte_count = 0\\n        for byte in data:\\n            if trailing_byte_count > 0:\\n                if (byte & eighth_bit) and not (byte & seventh_bit): #10xx_xxxx\\n                    trailing_byte_count -= 1\\n                    if trailing_byte_count < 0:\\n                        return False\\n                    continue\\n                else:\\n                    return False\\n            else:\\n                if not (byte & eighth_bit): # 0xxx_xxxx\\n                    continue\\n                else: # 1xxx_xxxx\\n                    if not (byte & seventh_bit): #10xx_xxxx\\n                        return False\\n                    # 11xx_xxxx\\n                    if not (byte & sixth_bit): # 110x_xxxx\\n                        trailing_byte_count = 1\\n                        continue\\n                    # 111x_xxxx\\n                    if not (byte & fifth_bit): # 1110_xxxx\\n                        trailing_byte_count = 2\\n                        continue\\n                    # 1111_xxxx\\n                    if not (byte & fourth_bit): # 1111_0xxx\\n                        trailing_byte_count = 3\\n                        continue\\n                    return False\\n        if trailing_byte_count != 0:\\n            return False\\n        return True\\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        eighth_bit = 1 << 7\\n        seventh_bit = 1 << 6\\n        sixth_bit = 1 << 5\\n        fifth_bit = 1 << 4\\n        fourth_bit = 1 << 3\\n        \\n        trailing_byte_count = 0\\n        for byte in data:\\n            if trailing_byte_count > 0:\\n                if (byte & eighth_bit) and not (byte & seventh_bit): #10xx_xxxx\\n                    trailing_byte_count -= 1\\n                    if trailing_byte_count < 0:\\n                        return False\\n                    continue\\n                else:\\n                    return False\\n            else:\\n                if not (byte & eighth_bit): # 0xxx_xxxx\\n                    continue\\n                else: # 1xxx_xxxx\\n                    if not (byte & seventh_bit): #10xx_xxxx\\n                        return False\\n                    # 11xx_xxxx\\n                    if not (byte & sixth_bit): # 110x_xxxx\\n                        trailing_byte_count = 1\\n                        continue\\n                    # 111x_xxxx\\n                    if not (byte & fifth_bit): # 1110_xxxx\\n                        trailing_byte_count = 2\\n                        continue\\n                    # 1111_xxxx\\n                    if not (byte & fourth_bit): # 1111_0xxx\\n                        trailing_byte_count = 3\\n                        continue\\n                    return False\\n        if trailing_byte_count != 0:\\n            return False\\n        return True\\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019254,
                "title": "easy-c-solution-bit-manipulation",
                "content": "```\\npublic class Solution {\\n    public bool ValidUtf8(int[] data) {\\n        int bytesLeft = 0;\\n        foreach (int num in data) {\\n            if (bytesLeft == 0) {\\n                if (num >> 7 == 0b0)\\n                    bytesLeft = 0;\\n                else if (num >> 5 == 0b110)\\n                    bytesLeft = 1;\\n                else if (num >> 4 == 0b1110)\\n                    bytesLeft = 2;\\n                else if (num >> 3 == 0b11110)\\n                    bytesLeft = 3;\\n                else\\n                    return false;\\n            }\\n            else {\\n                if (num >> 6 == 0b10)\\n                    bytesLeft--;\\n                else return false;\\n            }\\n        }\\n        \\n        return bytesLeft == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ValidUtf8(int[] data) {\\n        int bytesLeft = 0;\\n        foreach (int num in data) {\\n            if (bytesLeft == 0) {\\n                if (num >> 7 == 0b0)\\n                    bytesLeft = 0;\\n                else if (num >> 5 == 0b110)\\n                    bytesLeft = 1;\\n                else if (num >> 4 == 0b1110)\\n                    bytesLeft = 2;\\n                else if (num >> 3 == 0b11110)\\n                    bytesLeft = 3;\\n                else\\n                    return false;\\n            }\\n            else {\\n                if (num >> 6 == 0b10)\\n                    bytesLeft--;\\n                else return false;\\n            }\\n        }\\n        \\n        return bytesLeft == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825305,
                "title": "python3-straightforward-solution",
                "content": "While scanning the array, two cases pop up. \\n1) in the middle of a multi-byte \\n2) at the beginning \\n\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        cnt = 0 \\n        for x in data:\\n            x = bin(x)[2:].zfill(8)\\n            if cnt: # in the middle of multi-byte \\n                if x.startswith(\"10\"): cnt -= 1\\n                else: return False \\n            else: # beginning \\n                cnt = x.find(\"0\")\\n                if cnt == -1 or cnt == 1 or cnt > 4: return False \\n                if cnt: cnt -= 1\\n        return cnt == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        cnt = 0 \\n        for x in data:\\n            x = bin(x)[2:].zfill(8)\\n            if cnt: # in the middle of multi-byte \\n                if x.startswith(\"10\"): cnt -= 1\\n                else: return False \\n            else: # beginning \\n                cnt = x.find(\"0\")\\n                if cnt == -1 or cnt == 1 or cnt > 4: return False \\n                if cnt: cnt -= 1\\n        return cnt == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318398,
                "title": "c-concise-solution",
                "content": "```\\nbool validUtf8(vector<int>& data) {\\n\\tint conts = 0;\\n\\tfor(int i = 0; i < data.size(); i++) {\\n\\t\\tif(conts--) { if ((data[i] & 0xC0) != 0x80) return false; }\\n\\t\\telse if((data[i] & 0xF8) == 0xF0) conts = 3;\\n\\t\\telse if((data[i] & 0xF0) == 0xE0) conts = 2;\\n\\t\\telse if((data[i] & 0xE0) == 0xC0) conts = 1;\\n\\t\\telse if((data[i] & 0x80) == 0x00) conts = 0;\\n\\t\\telse return false;\\n\\t}\\n\\treturn !conts;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool validUtf8(vector<int>& data) {\\n\\tint conts = 0;\\n\\tfor(int i = 0; i < data.size(); i++) {\\n\\t\\tif(conts--) { if ((data[i] & 0xC0) != 0x80) return false; }\\n\\t\\telse if((data[i] & 0xF8) == 0xF0) conts = 3;\\n\\t\\telse if((data[i] & 0xF0) == 0xE0) conts = 2;\\n\\t\\telse if((data[i] & 0xE0) == 0xC0) conts = 1;\\n\\t\\telse if((data[i] & 0x80) == 0x00) conts = 0;\\n\\t\\telse return false;\\n\\t}\\n\\treturn !conts;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87445,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var count = 0\\n        \\n        for byte in data {\\n            if count == 0 {\\n                if byte >> 5 == 0b110 {\\n                    count = 1\\n                } else if byte >> 4 == 0b1110 {\\n                    count = 2\\n                } else if byte >> 3 == 0b11110 {\\n                    count = 3\\n                } else if byte >> 7 != 0 {\\n                    return false\\n                }\\n            } else {\\n                if byte >> 6 != 0b10 {\\n                    return false\\n                }\\n                count -= 1\\n            }\\n        }\\n        \\n        return count == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var count = 0\\n        \\n        for byte in data {\\n            if count == 0 {\\n                if byte >> 5 == 0b110 {\\n                    count = 1\\n                } else if byte >> 4 == 0b1110 {\\n                    count = 2\\n                } else if byte >> 3 == 0b11110 {\\n                    count = 3\\n                } else if byte >> 7 != 0 {\\n                    return false\\n                }\\n            } else {\\n                if byte >> 6 != 0b10 {\\n                    return false\\n                }\\n                count -= 1\\n            }\\n        }\\n        \\n        return count == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87520,
                "title": "short-o-n-java-solution-scan-only-once",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n  int idx = 0;\\n  while(idx < data.length) {\\n    int utfIdx = idx++;\\n    if ((data[utfIdx] & (1<<7)) == 0) continue; //single byte\\n    for(int i = 6; i>=0; i--) {\\n      if ((data[utfIdx] & (1<<i)) > 0) { //find one more byte in multiple bytes\\n        if (idx >= data.length) return false; //not enough bytes\\n        if (((data[idx] & (1<<7)) == 0) || ((data[idx] & (1<<6))>0)) return false; //not starting with 10xxxxxx\\n        idx++;\\n      } else if (i==6) return false;  //for fist byte in multiple bytes is 10xxxxxx, at least 110xxxxx\\n      else break; //meet 0, remaining as utf content\\n    }\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n  int idx = 0;\\n  while(idx < data.length) {\\n    int utfIdx = idx++;\\n    if ((data[utfIdx] & (1<<7)) == 0) continue; //single byte\\n    for(int i = 6; i>=0; i--) {\\n      if ((data[utfIdx] & (1<<i)) > 0) { //find one more byte in multiple bytes\\n        if (idx >= data.length) return false; //not enough bytes\\n        if (((data[idx] & (1<<7)) == 0) || ((data[idx] & (1<<6))>0)) return false; //not starting with 10xxxxxx\\n        idx++;\\n      } else if (i==6) return false;  //for fist byte in multiple bytes is 10xxxxxx, at least 110xxxxx\\n      else break; //meet 0, remaining as utf content\\n    }\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2572697,
                "title": "clear-cpp-solution-with-separate-functions-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    //function to check whether an integer is a continuation integer or not.\\n    bool cont(int x){\\n        int mask1= (1<<7),mask2=(1<<6);\\n        if((x&mask1)!=0 && (x&mask2)==0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n    // function to calculate character classification (1-4).\\n    int byte(int x){\\n        if((x&(1<<7))==0){\\n            return 1;\\n        }\\n        int mask=(1<<8)-1,temp;\\n        x=(x^mask);\\n        for(int i=7;i>=0;i--){\\n            temp=(1<<i);\\n            if((temp&x)!=0){\\n                temp=i;\\n                break;\\n            }\\n        }\\n        if(7-temp>=2 && 7-temp<=4){\\n            return 7-temp;\\n        }\\n        else return -1;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int bytes,idx=0,n=data.size(),contInt=0;\\n        bool shCont=false;\\n        while(idx<n){\\n            if(shCont){\\n                if(cont(data[idx])==false){return false;}\\n                if(idx==contInt){\\n                    shCont=false;\\n                }\\n            }\\n            else{\\n            int ele = data[idx];\\n            bytes=byte(ele);\\n            if(bytes==-1){return false;}// A number is completely invalid,like 255 or 15 -> (2**k-1).\\n            if(bytes>1){\\n            contInt=idx+bytes-1;\\n            shCont=true;\\n                }\\n            }\\n            idx+=1;\\n        }\\n        return !shCont; //if program tells us that the loop should have continued, we return false.\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //function to check whether an integer is a continuation integer or not.\\n    bool cont(int x){\\n        int mask1= (1<<7),mask2=(1<<6);\\n        if((x&mask1)!=0 && (x&mask2)==0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n    // function to calculate character classification (1-4).\\n    int byte(int x){\\n        if((x&(1<<7))==0){\\n            return 1;\\n        }\\n        int mask=(1<<8)-1,temp;\\n        x=(x^mask);\\n        for(int i=7;i>=0;i--){\\n            temp=(1<<i);\\n            if((temp&x)!=0){\\n                temp=i;\\n                break;\\n            }\\n        }\\n        if(7-temp>=2 && 7-temp<=4){\\n            return 7-temp;\\n        }\\n        else return -1;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int bytes,idx=0,n=data.size(),contInt=0;\\n        bool shCont=false;\\n        while(idx<n){\\n            if(shCont){\\n                if(cont(data[idx])==false){return false;}\\n                if(idx==contInt){\\n                    shCont=false;\\n                }\\n            }\\n            else{\\n            int ele = data[idx];\\n            bytes=byte(ele);\\n            if(bytes==-1){return false;}// A number is completely invalid,like 255 or 15 -> (2**k-1).\\n            if(bytes>1){\\n            contInt=idx+bytes-1;\\n            shCont=true;\\n                }\\n            }\\n            idx+=1;\\n        }\\n        return !shCont; //if program tells us that the loop should have continued, we return false.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571800,
                "title": "java-soln-easiest-way",
                "content": "```\\nclass Solution {\\n    \\n    // return byte - 1\\n    public int Get_Bytes(int val){\\n\\n        int pos = 1;\\n        int res = 0;\\n        \\n        while(val > 0){\\n            if((val & 1) == 0){\\n                res = pos;\\n            }\\n            val >>= 1;\\n            pos++;\\n        }\\n        \\n        return 7 - res;\\n    }\\n    \\n    public boolean validUtf8(int[] data) {\\n        \\n        int byt = 0;\\n        \\n        for(int i = 0; i < data.length; i++){\\n            if(byt == 0){\\n                // if one byte number continue\\n                if(((data[i] >> 7) & 1) == 0)     continue;\\n                \\n                byt = Get_Bytes(data[i]);\\n\\n                 if(byt >= 4)  return false;\\n                \\n                // invaild no return false(10xxxxxx can\\'t be start of any sequence)\\n                if(byt == 0)    return false;\\n            }\\n            else{\\n                int x = data[i] >> 6;\\n                \\n                // if(first two bits are not 10)\\n                if(x != 2)  return false;\\n                byt--;\\n            }\\n        }\\n        \\n        return byt == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // return byte - 1\\n    public int Get_Bytes(int val){\\n\\n        int pos = 1;\\n        int res = 0;\\n        \\n        while(val > 0){\\n            if((val & 1) == 0){\\n                res = pos;\\n            }\\n            val >>= 1;\\n            pos++;\\n        }\\n        \\n        return 7 - res;\\n    }\\n    \\n    public boolean validUtf8(int[] data) {\\n        \\n        int byt = 0;\\n        \\n        for(int i = 0; i < data.length; i++){\\n            if(byt == 0){\\n                // if one byte number continue\\n                if(((data[i] >> 7) & 1) == 0)     continue;\\n                \\n                byt = Get_Bytes(data[i]);\\n\\n                 if(byt >= 4)  return false;\\n                \\n                // invaild no return false(10xxxxxx can\\'t be start of any sequence)\\n                if(byt == 0)    return false;\\n            }\\n            else{\\n                int x = data[i] >> 6;\\n                \\n                // if(first two bits are not 10)\\n                if(x != 2)  return false;\\n                byt--;\\n            }\\n        }\\n        \\n        return byt == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571743,
                "title": "question-explained-clearly-easy-solution-without-bit-manipulation-string-python",
                "content": "Hi All,\\n\\nThis question is vague and tricky, But let me explain question clearly and derive the problem statement conditions\\n\\nQuestion:\\n\\nGiven an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\\n\\nA character in UTF8 can be from 1 to 4 bytes long `[Explanation: Any UTF8 encoding should only contain at max 4 bytes]`, \\n\\nFor a 1-byte character, the first bit is a 0, followed by its Unicode code. `[Explanation: Looking at the below table, it mentions that it is valid to have a most significant bit as 0 if that is the starting byte]`\\nFor an n-bytes character, the first n bits are all one\\'s, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10. \\n```\\nExplanation: In the first sentence as mentioned, we can have at max 4 bytes, Based on the below table \\n1. 1 byte UTF8 encoding should start with 0 as most significant\\n2. 2 Bytes UTF8  encoding should start with 110XXX.. and 10XXX .. Example: Given a data [197,130,1] , here 197 after converting to binary will become 11000101, here we can see clearly its a 2 byte UTF8 encoding which means we need to check one more number after 197 that i.e, 130 in this example is having a binary value starting with 10XX.. or not, if it does not start with that value we can return. Once we have completed checking 130 number as well then we can once again check for next digit i.e., 1 in this example to find the how many byte encoding this number in UTF8\\n3. 3 Bytes UTF8 encoding will start with 1110XX.. , 10XX.. and 10XXX.. as mentioned in the table. In this case if the first number is belonging to 3 byte UTF8 encoding then we need to check the next two numbers are having 10 in their binary representation. after that we can process the next element\\n4. Same for the 4 byte encoding\\n\\nNote: we don\\'t have a UTF8 encoding starting byte with 10XX.. \\n```\\n\\n\\n\\nThis is how the UTF-8 encoding would work:\\n\\n ```\\nNumber of Bytes   |        UTF-8 Octet Sequence\\n\\t\\t\\t\\t   |              (binary)\\n--------------------+-----------------------------------------\\n\\t\\t1          |   0xxxxxxx\\n\\t\\t2          |   110xxxxx 10xxxxxx\\n\\t\\t3          |   1110xxxx 10xxxxxx 10xxxxxx\\n\\t\\t4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n```\\nx denotes a bit in the binary form of a byte that may be either 0 or 1.\\n\\nNote: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\\n\\n-------------\\n\\n\\nSummarizing all the things we understood till now:\\n1. UTF8 can be 1 to 4 bytes long [Return False if any starting byte with more than 4 most significant bits as 1]\\n2. For a one byte, first character can be zero\\n3. For 2,3,4 bytes most significant 1\\'s should be 2,3,4 count as show in the table\\n4. if the first byte starts with \\'10\\' return False\\n\\nUsing the above conditions, we can formulate the following algorithm\\n1. Iterate over the nums\\n2. For each num calculate the binary representation and calculate the number of most significant bits as 1\\n3. check if the next n-1 nums has the first two most significant bits as \\'10\\' else return False\\n4. Update the i from the nth num\\n\\nPython Solution:\\n\\n```\\ndef validUtf8(self, data: List[int]) -> bool:\\n        data_len = len(data)\\n        i = 0\\n        while i < data_len:\\n            num = data[i]\\n            num_binary = \\'{0:08b}\\'.format(num)\\n            \\n\\t\\t\\t# calculate the number of 1\\'s\\n            num_chars = 0\\n            for char in num_binary:\\n                if char == \\'1\\':\\n                    num_chars += 1\\n                    continue\\n                break\\n            \\n            if num_chars == 1 or num_chars > 4:\\n                # 10XXX condition doesn\\'t exist\\n                # only 1 to 4 bytes long\\n                return False\\n            \\n\\t\\t\\t# for 1 byte, num chars can be zero\\n            num_chars = num_chars - 1 if num_chars > 1 else 0\\n            \\n            check_till = i + num_chars\\n            if check_till >= data_len:\\n\\t\\t\\t\\t# if there are not many required elements to check\\n                return False\\n            \\n            for j in range(i + 1, check_till + 1):\\n                curr_num = data[j]\\n                curr_num_binary = \\'{0:08b}\\'.format(curr_num)\\n                if curr_num_binary[:2] != \\'10\\':\\n                    return False\\n            \\n            i = check_till + 1\\n            \\n        return True\\n```\\n\\nPlease upvote if you like the explanations and comment if there are any queries. Cheers!!",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nExplanation: In the first sentence as mentioned, we can have at max 4 bytes, Based on the below table \\n1. 1 byte UTF8 encoding should start with 0 as most significant\\n2. 2 Bytes UTF8  encoding should start with 110XXX.. and 10XXX .. Example: Given a data [197,130,1] , here 197 after converting to binary will become 11000101, here we can see clearly its a 2 byte UTF8 encoding which means we need to check one more number after 197 that i.e, 130 in this example is having a binary value starting with 10XX.. or not, if it does not start with that value we can return. Once we have completed checking 130 number as well then we can once again check for next digit i.e., 1 in this example to find the how many byte encoding this number in UTF8\\n3. 3 Bytes UTF8 encoding will start with 1110XX.. , 10XX.. and 10XXX.. as mentioned in the table. In this case if the first number is belonging to 3 byte UTF8 encoding then we need to check the next two numbers are having 10 in their binary representation. after that we can process the next element\\n4. Same for the 4 byte encoding\\n\\nNote: we don\\'t have a UTF8 encoding starting byte with 10XX.. \\n```\n```\\nNumber of Bytes   |        UTF-8 Octet Sequence\\n\\t\\t\\t\\t   |              (binary)\\n--------------------+-----------------------------------------\\n\\t\\t1          |   0xxxxxxx\\n\\t\\t2          |   110xxxxx 10xxxxxx\\n\\t\\t3          |   1110xxxx 10xxxxxx 10xxxxxx\\n\\t\\t4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n```\n```\\ndef validUtf8(self, data: List[int]) -> bool:\\n        data_len = len(data)\\n        i = 0\\n        while i < data_len:\\n            num = data[i]\\n            num_binary = \\'{0:08b}\\'.format(num)\\n            \\n\\t\\t\\t# calculate the number of 1\\'s\\n            num_chars = 0\\n            for char in num_binary:\\n                if char == \\'1\\':\\n                    num_chars += 1\\n                    continue\\n                break\\n            \\n            if num_chars == 1 or num_chars > 4:\\n                # 10XXX condition doesn\\'t exist\\n                # only 1 to 4 bytes long\\n                return False\\n            \\n\\t\\t\\t# for 1 byte, num chars can be zero\\n            num_chars = num_chars - 1 if num_chars > 1 else 0\\n            \\n            check_till = i + num_chars\\n            if check_till >= data_len:\\n\\t\\t\\t\\t# if there are not many required elements to check\\n                return False\\n            \\n            for j in range(i + 1, check_till + 1):\\n                curr_num = data[j]\\n                curr_num_binary = \\'{0:08b}\\'.format(curr_num)\\n                if curr_num_binary[:2] != \\'10\\':\\n                    return False\\n            \\n            i = check_till + 1\\n            \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2571241,
                "title": "java-soln",
                "content": "class Solution {\\n\\t public boolean validUtf8(int[] data) {\\n     int rem=0;\\n        for(int i :data)\\n            if(rem==0)\\n                if(i>>7 == 0b0)\\n                    rem =0;\\n                else if(i>>5 ==0b110)\\n                    rem=1;\\n                else if(i>>4 == 0b1110)\\n                    rem=2;\\n                else if(i>>3 == 0b11110)\\n                    rem=3;\\n                else\\n                    return false;\\n            else\\n                if(i>>6==0b10)\\n                    rem--;\\n                else\\n                    return false;\\n            if(rem==0)\\n                return true;\\n            else\\n                return false;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t public boolean validUtf8(int[] data) {\\n     int rem=0;\\n        for(int i :data)\\n            if(rem==0)\\n                if(i>>7 == 0b0)\\n                    rem =0;\\n                else if(i>>5 ==0b110)\\n                    rem=1;\\n                else if(i>>4 == 0b1110)\\n                    rem=2;\\n                else if(i>>3 == 0b11110)\\n                    rem=3;\\n                else\\n                    return false;\\n            else\\n                if(i>>6==0b10)\\n                    rem--;\\n                else\\n                    return false;\\n            if(rem==0)\\n                return true;\\n            else\\n                return false;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2571208,
                "title": "super-duper-easy-peasy-lemon-squeezy-solution",
                "content": "```\\n#include<bits/stdc++.h>\\n#define PB push_back\\n#define ll long long int\\n#define MP make_pair\\n#define loop(i, a, b) for (int i = a; i < b; i++)\\nusing namespace std;\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& d) \\n    {\\n        int n=d.size();\\n        int a[n];\\n        loop(i,0,n)\\n        {\\n            int x=0;\\n            int j=7;\\n            while(j>-1&&d[i]>=pow(2,j))\\n            {\\n                d[i]-=pow(2,j);\\n                j--;\\n                x++;\\n            }\\n            a[i]=x;\\n        }\\n        // loop(i,0,n)\\n        //     cout<<a[i]<<endl;\\n        //int d=1;\\n        loop(i,0,n)\\n        {\\n            if(a[i]>4)\\n            {\\n                return false;\\n            }\\n            else if(a[i]==4)\\n            {\\n                if(i+3>=n||(a[i+1]!=1||a[i+2]!=1||a[i+3]!=1))\\n                    return false;\\n                else\\n                    i+=3;\\n            }\\n            else if(a[i]==3)\\n            {\\n                if((i+2>=n)||(a[i+1]!=1||a[i+2]!=1))\\n                    return false;\\n                else\\n                    i+=2;\\n            }\\n            else if(a[i]==2)\\n            {\\n                if(i+1>=n||(a[i+1]!=1))\\n                    return false;\\n                else\\n                    i+=1;\\n            }\\n            else if(a[i]==1)\\n                return false;\\n            // else\\n            //     return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n#define PB push_back\\n#define ll long long int\\n#define MP make_pair\\n#define loop(i, a, b) for (int i = a; i < b; i++)\\nusing namespace std;\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& d) \\n    {\\n        int n=d.size();\\n        int a[n];\\n        loop(i,0,n)\\n        {\\n            int x=0;\\n            int j=7;\\n            while(j>-1&&d[i]>=pow(2,j))\\n            {\\n                d[i]-=pow(2,j);\\n                j--;\\n                x++;\\n            }\\n            a[i]=x;\\n        }\\n        // loop(i,0,n)\\n        //     cout<<a[i]<<endl;\\n        //int d=1;\\n        loop(i,0,n)\\n        {\\n            if(a[i]>4)\\n            {\\n                return false;\\n            }\\n            else if(a[i]==4)\\n            {\\n                if(i+3>=n||(a[i+1]!=1||a[i+2]!=1||a[i+3]!=1))\\n                    return false;\\n                else\\n                    i+=3;\\n            }\\n            else if(a[i]==3)\\n            {\\n                if((i+2>=n)||(a[i+1]!=1||a[i+2]!=1))\\n                    return false;\\n                else\\n                    i+=2;\\n            }\\n            else if(a[i]==2)\\n            {\\n                if(i+1>=n||(a[i+1]!=1))\\n                    return false;\\n                else\\n                    i+=1;\\n            }\\n            else if(a[i]==1)\\n                return false;\\n            // else\\n            //     return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2571114,
                "title": "i-am-not-crazy-right",
                "content": "#### The characters can be interpreted in decimal as:\\n* **1 byte** characters are:  **0xxxxxxx** -> ***00000000-01111111*** -> **[0,127]**\\n* **2 bytes** characters are: **110xxxxx** -> ***11000000-11011111*** -> **[192,223]**\\n* **3 bytes** characters are: **1110xxxx** -> ***11100000-11101111*** -> **[224,239]**\\n* **4 bytes** characters are: **11110xxx** -> ***11110000-11110111*** -> **[240,247]**\\n\\nThe **n bytes** characters are followed by **n-1 characters** of form : \\n**10xxxxxx** -> ***10000000-10111111*** -> **[128,191]**\\n\\n***C++ Code:***\\n```\\nbool validUtf8(vector<int>& data) {\\n        int len = data.size();\\n        int cur = -1,i=0;\\n        for(;i<len;i++){\\n            if (data[i]<=127&&data[i]>=0)continue; // if data[i] is 1 byte\\n            else if(data[i]<=223&&data[i]>=192)cur=1; // if data[i] is 2 bytes\\n            else if(data[i]<=239&&data[i]>=224)cur=2; // if data[i] is 3 bytes\\n            else if(data[i]<=247&&data[i]>=240)cur=3; // if data[i] is 4 bytes\\n            else return 0; \\n            if(i+cur>=len)return 0; // checking if n-1 characters exist\\n\\t\\t\\t// checking n-1 characters\\n            while(cur--){ \\n                i++;\\n\\t\\t\\t\\t // checking in [128,191]\\n                if(data[i]<128||data[i]>191)return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n```\\n***Time Complexity:*** `O(n)`\\n***Space Complexity:*** `O(1)`\\n\\n**Do tell me what you think of this approach and how can it be improved?**\\n***Writing this code doesn\\'t make me crazy, right?!***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool validUtf8(vector<int>& data) {\\n        int len = data.size();\\n        int cur = -1,i=0;\\n        for(;i<len;i++){\\n            if (data[i]<=127&&data[i]>=0)continue; // if data[i] is 1 byte\\n            else if(data[i]<=223&&data[i]>=192)cur=1; // if data[i] is 2 bytes\\n            else if(data[i]<=239&&data[i]>=224)cur=2; // if data[i] is 3 bytes\\n            else if(data[i]<=247&&data[i]>=240)cur=3; // if data[i] is 4 bytes\\n            else return 0; \\n            if(i+cur>=len)return 0; // checking if n-1 characters exist\\n\\t\\t\\t// checking n-1 characters\\n            while(cur--){ \\n                i++;\\n\\t\\t\\t\\t // checking in [128,191]\\n                if(data[i]<128||data[i]>191)return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570982,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        \\n        int n = data.size();\\n        vector<int> vec = {127, 191, 223, 239, 247};\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int pos = lower_bound(vec.begin(), vec.end(), data[i]) - vec.begin();        \\n            if(pos==5 || pos==1)\\n                return 0;\\n            \\n            if(pos==0)\\n                continue;\\n            \\n            pos--;\\n            i++;\\n            while(pos--)\\n            {\\n                if(i>=n)\\n                    return 0;\\n                \\n                int tmp = lower_bound(vec.begin(), vec.end(), data[i]) - vec.begin();\\n                \\n                if(tmp!=1)\\n                    return 0;\\n                \\n                i++;\\n            }\\n            i--;\\n        }\\n        \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        \\n        int n = data.size();\\n        vector<int> vec = {127, 191, 223, 239, 247};\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int pos = lower_bound(vec.begin(), vec.end(), data[i]) - vec.begin();        \\n            if(pos==5 || pos==1)\\n                return 0;\\n            \\n            if(pos==0)\\n                continue;\\n            \\n            pos--;\\n            i++;\\n            while(pos--)\\n            {\\n                if(i>=n)\\n                    return 0;\\n                \\n                int tmp = lower_bound(vec.begin(), vec.end(), data[i]) - vec.begin();\\n                \\n                if(tmp!=1)\\n                    return 0;\\n                \\n                i++;\\n            }\\n            i--;\\n        }\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570191,
                "title": "rust-functional-state-machine-with-comments",
                "content": "I use a functional state machine approach to scan the input. I map the input bytes to their number of leading bits set (`leading_ones`) and use `scan` to hold the state `(ok, n)`, where `ok` is true if the state machine is in a valid state, and `n` is the number of \"tail bytes\" with leading b10, i.e. one leading bit set, that we expect. The output of `scan` is wether `data` is valid UTF-8 if it would end at the current byte, i.e. if we are not expecting any tail bytes. Going through the match arms:\\n\\n1. If the state machine is in an invalid state, we signal that we are done by yielding `None`. We get here if the previous byte hit the sixth match arm, and we have signalled that it is bad UTF-8.\\n2. The state machine is in a valid state, we expect a header byte (`n == 0`), and the header byte has no leading bits set. This is a one-byte character, so we don\\'t expect any tail bytes, and up until the current byte, we have valid UTF-8.\\n3. The state machine is in a valid state, we expect a header byte (`n == 0`), and the current byte is a header byte with 2, 3 or 4 leading bits set. We expect 1, 2 and 3 tail bytes, respectively, and we don\\'t have valid UTF-8 if input would end here.\\n4. The state machine is in a valid state, we expect one tail byte, and the current byte is a tail byte (one leading bit set). We do not expect any more tail bytes, and we have valid UTF-8 if input would end here.\\n5. The state machine is in a valid state, we expect more than one tail byte, and the current byte is a tail byte (one leading bit set). We decrement the number of tail bytes that we expect. We do not have valid UTF-8 if input would end here.\\n6. Anything else violates the rules of valid UTF-8 input. We signal that the input is invalid.\\n\\n```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        data.into_iter().map(|i| (i as u8).leading_ones()).scan((true, 0), |(ok, n), lo| \\n            match (*ok, *n, lo) {\\n                (false, _, _) => None,\\n                (_, 0, 0) => Some(true),\\n                (_, 0, 2 | 3 | 4) => { *n = lo - 1; Some(false) },\\n                (_, 1, 1) => { *n = 0; Some(true) },\\n                (_, _, 1) => { *n -= 1; Some(false) },\\n                _ => {*ok = false; Some(false)},\\n            }\\n        ).last().unwrap()\\n    }\\n}\\n```\\n\\nI also made a less compact but more readable implementation of the state machine:\\n\\n```\\n#[derive(Clone, Copy, PartialEq)]\\nenum State {\\n    ExpectingHeader,\\n    ExpectingOne,\\n    ExpectingTwo,\\n    ExpectingThree,\\n    Error,\\n    Invalid,\\n}\\n\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        data.into_iter().map(|i| (i as u8).leading_ones()).scan(State::ExpectingHeader, |state, lo| {\\n            *state = match (*state, lo) {\\n                (State::ExpectingHeader, 0) => State::ExpectingHeader,\\n                (State::ExpectingHeader, 2) => State::ExpectingOne,\\n                (State::ExpectingHeader, 3) => State::ExpectingTwo,\\n                (State::ExpectingHeader, 4) => State::ExpectingThree,\\n                (State::ExpectingOne, 1) => State::ExpectingHeader,\\n                (State::ExpectingTwo, 1) => State::ExpectingOne,\\n                (State::ExpectingThree, 1) => State::ExpectingTwo,\\n                (State::Error, _) => State::Invalid,\\n                _ => State::Error,\\n\\n            };\\n            if *state == State::Invalid { None } else { Some(*state) }\\n        }).map(|state| state == State::ExpectingHeader).last().unwrap_or(true)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        data.into_iter().map(|i| (i as u8).leading_ones()).scan((true, 0), |(ok, n), lo| \\n            match (*ok, *n, lo) {\\n                (false, _, _) => None,\\n                (_, 0, 0) => Some(true),\\n                (_, 0, 2 | 3 | 4) => { *n = lo - 1; Some(false) },\\n                (_, 1, 1) => { *n = 0; Some(true) },\\n                (_, _, 1) => { *n -= 1; Some(false) },\\n                _ => {*ok = false; Some(false)},\\n            }\\n        ).last().unwrap()\\n    }\\n}\\n```\n```\\n#[derive(Clone, Copy, PartialEq)]\\nenum State {\\n    ExpectingHeader,\\n    ExpectingOne,\\n    ExpectingTwo,\\n    ExpectingThree,\\n    Error,\\n    Invalid,\\n}\\n\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        data.into_iter().map(|i| (i as u8).leading_ones()).scan(State::ExpectingHeader, |state, lo| {\\n            *state = match (*state, lo) {\\n                (State::ExpectingHeader, 0) => State::ExpectingHeader,\\n                (State::ExpectingHeader, 2) => State::ExpectingOne,\\n                (State::ExpectingHeader, 3) => State::ExpectingTwo,\\n                (State::ExpectingHeader, 4) => State::ExpectingThree,\\n                (State::ExpectingOne, 1) => State::ExpectingHeader,\\n                (State::ExpectingTwo, 1) => State::ExpectingOne,\\n                (State::ExpectingThree, 1) => State::ExpectingTwo,\\n                (State::Error, _) => State::Invalid,\\n                _ => State::Error,\\n\\n            };\\n            if *state == State::Invalid { None } else { Some(*state) }\\n        }).map(|state| state == State::ExpectingHeader).last().unwrap_or(true)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569826,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let mut next_bytes = 0;\\n        for ones in data.iter().map(|&x| (x as u8).leading_ones()) {\\n            match (next_bytes == 0, ones) {\\n                (false, 1) => next_bytes -= 1,\\n                (true, 0 | 2 | 3 | 4) => next_bytes = ones.saturating_sub(1),\\n                _ => return false,\\n            }\\n        }\\n        next_bytes == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let mut next_bytes = 0;\\n        for ones in data.iter().map(|&x| (x as u8).leading_ones()) {\\n            match (next_bytes == 0, ones) {\\n                (false, 1) => next_bytes -= 1,\\n                (true, 0 | 2 | 3 | 4) => next_bytes = ones.saturating_sub(1),\\n                _ => return false,\\n            }\\n        }\\n        next_bytes == 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569599,
                "title": "c-simple-short-easy-to-understand",
                "content": "We first iterate through the vector \\'data\\' and convert it to binary representations (8 least significant bits). Afterwards, we take a count variable to check for remaining integers for that byte encoding. For example: if we got an integer with 110xxxxx then, we need to have another integer with 10xxxxxx for the 2 byte encoding and so on. \\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        vector<string> v;\\n        for(int i=0;i<data.size();i++) {\\n            string s = bitset<8> (data[i]).to_string();\\n            v.push_back(s ); //binary representation\\n        }\\n        int count = 0;\\n        for(auto s: v) {\\n            if(count==0) {\\n                if( s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'0\\') count =1; // 2 byte encoding\\n                else if(s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'1\\' && s[3]==\\'0\\') count=2; //3 byte encoding\\n                else if(s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'1\\' && s[3]==\\'1\\' && s[4]==\\'0\\') count=3; // 4 byte encoding\\n                else if( s[0]!=\\'0\\') return false; //0 byte encoding\\n            } else {\\n                if(s[0]==\\'1\\' && s[1]==\\'0\\') count--;\\n                else return false;\\n            }\\n        }\\n        return count==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        vector<string> v;\\n        for(int i=0;i<data.size();i++) {\\n            string s = bitset<8> (data[i]).to_string();\\n            v.push_back(s ); //binary representation\\n        }\\n        int count = 0;\\n        for(auto s: v) {\\n            if(count==0) {\\n                if( s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'0\\') count =1; // 2 byte encoding\\n                else if(s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'1\\' && s[3]==\\'0\\') count=2; //3 byte encoding\\n                else if(s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'1\\' && s[3]==\\'1\\' && s[4]==\\'0\\') count=3; // 4 byte encoding\\n                else if( s[0]!=\\'0\\') return false; //0 byte encoding\\n            } else {\\n                if(s[0]==\\'1\\' && s[1]==\\'0\\') count--;\\n                else return false;\\n            }\\n        }\\n        return count==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569173,
                "title": "javascript-solution-binary-two-approaches",
                "content": "**Approach 1)**\\n\\n```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    \\n    let binary = data.map(d => { // data to binary\\n        let b = \"00000000\" + d.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n    // current UTF8 length\\n    let current = 0; \\n\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            // skip the single byte char\\n            if (bytes==0) {\\n                continue;\\n            }  \\n            if (bytes > 4 || bytes < 2) {\\n              return false;  \\n            }\\n            // set the remaining length\\n            current = bytes;\\n        } else {\\n            if (bytes != 1) {\\n                return false\\n            } \\n        }\\n        current--;\\n    }\\n    return current==0;\\n};\\n```\\n\\n```\\nRuntime: 134 ms, faster than 27.78% of JavaScript online submissions for UTF-8 Validation.\\nMemory Usage: 48.3 MB, less than 25.00% of JavaScript online submissions for UTF-8 Validation.\\n```\\n\\n**Approach 2)**\\n\\n```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    for (let i = 0; i < data.length; i++) {\\n        if (count == 0) {\\n            if (data[i]>>>5 == 0b110) {\\n                count = 1;\\n            }\\n            else if (data[i]>>>4 == 0b1110) {\\n                count = 2;\\n            }\\n            else if (data[i]>>>3 == 0b11110) {\\n                count = 3;\\n            }\\n            else if (data[i]>>>7 == 1) {\\n                return false;\\n            }\\n        }\\n        else {\\n            if (data[i]>>>6 != 2) {\\n                return false;\\n            }\\n            count --;\\n        }\\n    }\\n    return count == 0;\\n};\\n```\\n\\n```\\nRuntime: 133 ms, faster than 27.78% of JavaScript online submissions for UTF-8 Validation.\\nMemory Usage: 42.2 MB, less than 97.22% of JavaScript online submissions for UTF-8 Validation.\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    \\n    let binary = data.map(d => { // data to binary\\n        let b = \"00000000\" + d.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n    // current UTF8 length\\n    let current = 0; \\n\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            // skip the single byte char\\n            if (bytes==0) {\\n                continue;\\n            }  \\n            if (bytes > 4 || bytes < 2) {\\n              return false;  \\n            }\\n            // set the remaining length\\n            current = bytes;\\n        } else {\\n            if (bytes != 1) {\\n                return false\\n            } \\n        }\\n        current--;\\n    }\\n    return current==0;\\n};\\n```\n```\\nRuntime: 134 ms, faster than 27.78% of JavaScript online submissions for UTF-8 Validation.\\nMemory Usage: 48.3 MB, less than 25.00% of JavaScript online submissions for UTF-8 Validation.\\n```\n```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    for (let i = 0; i < data.length; i++) {\\n        if (count == 0) {\\n            if (data[i]>>>5 == 0b110) {\\n                count = 1;\\n            }\\n            else if (data[i]>>>4 == 0b1110) {\\n                count = 2;\\n            }\\n            else if (data[i]>>>3 == 0b11110) {\\n                count = 3;\\n            }\\n            else if (data[i]>>>7 == 1) {\\n                return false;\\n            }\\n        }\\n        else {\\n            if (data[i]>>>6 != 2) {\\n                return false;\\n            }\\n            count --;\\n        }\\n    }\\n    return count == 0;\\n};\\n```\n```\\nRuntime: 133 ms, faster than 27.78% of JavaScript online submissions for UTF-8 Validation.\\nMemory Usage: 42.2 MB, less than 97.22% of JavaScript online submissions for UTF-8 Validation.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569016,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string byte(int n){\\n        string s=\"\";\\n        \\n        for(int i=0;i<8;i++){\\n            s+=to_string(n%2);\\n            n=n>>1;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        \\n        return s;\\n    }\\n    \\n    int count(string s){\\n        int ct=0;\\n        for(int i=0;i<8;i++){\\n            if(s[i]==\\'0\\')break;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        \\n        for(int i=0;i<data.size();i++){\\n            int n=data[i];\\n            string s=byte(n);\\n            \\n            int ct=count(s);\\n           \\n            if(ct>4 || ct==1)return false;\\n            \\n            for(int j=0;j<ct-1;j++){\\n                if(i+j+1>=data.size())return false;\\n                \\n                string d=byte(data[i+j+1]);\\n                int ct1=count(d);\\n                if(ct1!=1)return false;\\n            }\\n            \\n            if(ct!=0)i+=ct-1;\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string byte(int n){\\n        string s=\"\";\\n        \\n        for(int i=0;i<8;i++){\\n            s+=to_string(n%2);\\n            n=n>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2568850,
                "title": "scala-with-readability-tricks",
                "content": "```scala\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  def validUtf8(data: Array[Int]): Boolean = validUtf8(data.toList)\\n\\n  @tailrec\\n  def validUtf8(data: List[Int]): Boolean = data match {\\n    case Nil => true\\n    case n1 :: ns                   if ASCII_SEQ(n1) =>             validUtf8(ns)\\n    case n1 :: n2 :: ns             if TWO_BYTE(n1, n2) =>          validUtf8(ns)\\n    case n1 :: n2 :: n3 :: ns       if THREE_BYTE(n1, n2, n3) =>    validUtf8(ns)\\n    case n1 :: n2 :: n3 :: n4 :: ns if FOUR_BYTE(n1, n2, n3, n4) => validUtf8(ns)\\n    case _ => false\\n  }\\n\\n  case class Pattern(p: String) {\\n    val mask = Integer.parseInt(p.replace(\\'0\\', \\'1\\').replace(\\'X\\', \\'0\\'), 2)\\n    val maskTarget = Integer.parseInt(p.replace(\\'X\\', \\'0\\'), 2)\\n\\n    def ~~(i: Int): Boolean = (mask & i) == maskTarget\\n  }\\n\\n  val ASCII_PATTERN  = Pattern(\"0XXXXXXX\")\\n  val TRAILING       = Pattern(\"10XXXXXX\")\\n  val FIRST_OF_TWO   = Pattern(\"110XXXXX\")\\n  val FIRST_OF_THREE = Pattern(\"1110XXXX\")\\n  val FIRST_OF_FOUR  = Pattern(\"11110XXX\")\\n\\n  class Sequence(patterns: Pattern*) {\\n    def apply(ns: Int*): Boolean = patterns zip ns forall { _ ~~ _ }\\n  }\\n\\n  val ASCII_SEQ  = Sequence(ASCII_PATTERN)\\n  val TWO_BYTE   = Sequence(FIRST_OF_TWO, TRAILING)\\n  val THREE_BYTE = Sequence(FIRST_OF_THREE, TRAILING, TRAILING)\\n  val FOUR_BYTE  = Sequence(FIRST_OF_FOUR, TRAILING, TRAILING, TRAILING)\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```scala\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  def validUtf8(data: Array[Int]): Boolean = validUtf8(data.toList)\\n\\n  @tailrec\\n  def validUtf8(data: List[Int]): Boolean = data match {\\n    case Nil => true\\n    case n1 :: ns                   if ASCII_SEQ(n1) =>             validUtf8(ns)\\n    case n1 :: n2 :: ns             if TWO_BYTE(n1, n2) =>          validUtf8(ns)\\n    case n1 :: n2 :: n3 :: ns       if THREE_BYTE(n1, n2, n3) =>    validUtf8(ns)\\n    case n1 :: n2 :: n3 :: n4 :: ns if FOUR_BYTE(n1, n2, n3, n4) => validUtf8(ns)\\n    case _ => false\\n  }\\n\\n  case class Pattern(p: String) {\\n    val mask = Integer.parseInt(p.replace(\\'0\\', \\'1\\').replace(\\'X\\', \\'0\\'), 2)\\n    val maskTarget = Integer.parseInt(p.replace(\\'X\\', \\'0\\'), 2)\\n\\n    def ~~(i: Int): Boolean = (mask & i) == maskTarget\\n  }\\n\\n  val ASCII_PATTERN  = Pattern(\"0XXXXXXX\")\\n  val TRAILING       = Pattern(\"10XXXXXX\")\\n  val FIRST_OF_TWO   = Pattern(\"110XXXXX\")\\n  val FIRST_OF_THREE = Pattern(\"1110XXXX\")\\n  val FIRST_OF_FOUR  = Pattern(\"11110XXX\")\\n\\n  class Sequence(patterns: Pattern*) {\\n    def apply(ns: Int*): Boolean = patterns zip ns forall { _ ~~ _ }\\n  }\\n\\n  val ASCII_SEQ  = Sequence(ASCII_PATTERN)\\n  val TWO_BYTE   = Sequence(FIRST_OF_TWO, TRAILING)\\n  val THREE_BYTE = Sequence(FIRST_OF_THREE, TRAILING, TRAILING)\\n  val FOUR_BYTE  = Sequence(FIRST_OF_FOUR, TRAILING, TRAILING, TRAILING)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568753,
                "title": "c-99-4ms-but-varies-95-memory-while-loop-bit-manipulation",
                "content": "My initial answer ran in 250ms time 5% . With bit manipulation you can reduce this quite alot. \\n\\nSo your number is a binary number with 8 bits. You want to record the number of ones from the left side without break\\n\\nThat is for example   111110000 has value 5.\\n\\nStep 1: Convert your array of integers call them D in this manner.\\n\\nNow you just need to follolw [the rather annoying in my opinion] rules of UT8C charachters\\n\\n1: If ANY value in D is GREATER than 4 you are automatically false.\\n2. If you are at the beginning of a NEW UT8C charachter you CANNOT be 1 [by the rules] so return false if this is so.\\n3. If your value is say x at position i in your array D, then the UT8C charachter at position i has x bytes in it. So you need to move ahead x bytes in your array D. ALSO by the RULES of UT8C [which again I think are annoying] each one of the values in D along these x positions must be equal to ONE. So return false if this is not so.\\n4. Finally the last condtion is that if you get EXACTLY to the end of the array following steps ONE through THREE then you return TRUE. If you go out of bounds by following steps ONE through THREE return FALSE.\\n\\nAnd so this is it.\\n\\nThe time constraints are simply linnear.  \\n\\nThe Code is Below:                  Thank You    =]\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int Make(int N)\\n    {\\n        int ret=0;    \\n        for(int i=7;i>=2;i--)\\n        {\\n            if(N>>i==1) \\n            {\\n                ret++;\\n                N-=1<<i;\\n            }\\n            else \\n            {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n        string s; char c;\\n        int i=0;\\n        int ret=0;\\n        for(;i<8;i++)\\n        {\\n            c=\\'0\\'+N%2;\\n            s=s+c;\\n            N=N/2;\\n        }\\n        \\n        for(int i=7;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\') ret++; else break;\\n        }*/\\n        \\n        return(ret);\\n    }\\n    \\n    bool validUtf8(vector<int>& D) {\\n        \\n        int n=D.size();\\n        \\n        for(int i=0;i<D.size();i++)\\n        {\\n            D[i]=Make(D[i]);\\n        }\\n        \\n        //for(int v:D) cout<<v<<\"::\";\\n        \\n        int i=0, cur;\\n        \\n        while(i<n)\\n        {\\n            cur=D[i];\\n            \\n            if(cur>4 || cur==1) return(false);\\n            \\n            i++; cur--;\\n            \\n            while(cur>0)\\n            {\\n                if(i>=n) return(false);\\n                if(D[i]!=1) return(false);\\n                i++;\\n                cur--;\\n            }\\n        }\\n        \\n        return(true);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int Make(int N)\\n    {\\n        int ret=0;    \\n        for(int i=7;i>=2;i--)\\n        {\\n            if(N>>i==1) \\n            {\\n                ret++;\\n                N-=1<<i;\\n            }\\n            else \\n            {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n        string s; char c;\\n        int i=0;\\n        int ret=0;\\n        for(;i<8;i++)\\n        {\\n            c=\\'0\\'+N%2;\\n            s=s+c;\\n            N=N/2;\\n        }\\n        \\n        for(int i=7;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\') ret++; else break;\\n        }*/\\n        \\n        return(ret);\\n    }\\n    \\n    bool validUtf8(vector<int>& D) {\\n        \\n        int n=D.size();\\n        \\n        for(int i=0;i<D.size();i++)\\n        {\\n            D[i]=Make(D[i]);\\n        }\\n        \\n        //for(int v:D) cout<<v<<\"::\";\\n        \\n        int i=0, cur;\\n        \\n        while(i<n)\\n        {\\n            cur=D[i];\\n            \\n            if(cur>4 || cur==1) return(false);\\n            \\n            i++; cur--;\\n            \\n            while(cur>0)\\n            {\\n                if(i>=n) return(false);\\n                if(D[i]!=1) return(false);\\n                i++;\\n                cur--;\\n            }\\n        }\\n        \\n        return(true);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2359170,
                "title": "cute-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int i=0;\\n        while (i<data.size()) {\\n            int n=0;\\n            if ((data[i]>>7)==0) n=1;\\n            else if ((data[i]>>5)==6) n=2;\\n            else if ((data[i]>>4)==14) n=3;\\n            else if ((data[i]>>3)==30) n=4;\\n            else return false;\\n            for (int j=i+1; j<i+n; j++)\\n                if (j>=data.size() || data[j]>>6!=2)\\n                    return false;\\n           i += n;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int i=0;\\n        while (i<data.size()) {\\n            int n=0;\\n            if ((data[i]>>7)==0) n=1;\\n            else if ((data[i]>>5)==6) n=2;\\n            else if ((data[i]>>4)==14) n=3;\\n            else if ((data[i]>>3)==30) n=4;\\n            else return false;\\n            for (int j=i+1; j<i+n; j++)\\n                if (j>=data.size() || data[j]>>6!=2)\\n                    return false;\\n           i += n;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204811,
                "title": "why-is-250-145-145-145-145-not-a-valid-utf-8-string",
                "content": "[250,145,145,145,145]\\n\\nfirst byte: 11111010\\nFound 5-byte character at index 0\\ncbecking at index 1\\nfollowing byte: 10010001\\nnext one\\ncbecking at index 2\\nfollowing byte: 10010001\\nnext one\\ncbecking at index 3\\nfollowing byte: 10010001\\nnext one\\ncbecking at index 4\\nfollowing byte: 10010001\\nnext one\\n\\nIt seems like a valid encoding to me, but the test case said it\\'s meant to be false. Can anyone help me understand why?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1330386,
                "title": "java-bit-manipulation-clear-easy-to-understand-with-comments-explained",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int prevN = 0;\\n        for (int i : data) {\\n            int n = getN(i);\\n            if (n > 4) return false;\\n\\n            //An integer can either represent the start of a UTF-8 character, or a part of an existing UTF-8 character.\\n            // There are two separate rules for these two scenarios in the problem.\\n            if (n == 1) {\\n                //scenario 1: If an integer is a part of an existing UTF-8 character, simply check the 2 most significant bits of in the binary representation string.\\n                // They should be 10.  ie. n==1\\n                if (prevN <= 0) return false;\\n            } else {\\n                //scenario 2: If the integer represents the start of a UTF-8 character,\\n                // then the first few bits would be 1 followed by a 0. The number of initial bits\\n                // (most significant) bits determines the length of the UTF-8 character. ie length  = n\\n                if (prevN > 0) return false;\\n                // The array can contain multiple valid UTF-8 characters. ie. start of new UTF-8 character\\n                prevN = n;\\n            }\\n            prevN--;\\n\\n        }\\n        if (prevN > 0) return false;\\n        return true;\\n    }\\n\\n    public static int getN(int num) {\\n        //We can use bit masking to check how many initial bits are set for a given number. \\n        // We only need to work with the 8 least significant bits as mentioned in the problem.\\n        int mask = 1 << 7;\\n        int count = 0;\\n        while ((mask & num) != 0) {\\n            count++;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nSame code without comments:\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int prevN = 0;\\n        for (int i : data) {\\n            int n = getN(i);\\n            if (n > 4) {\\n                return false;\\n            } else if (n == 1) {\\n                if (prevN <= 0) return false;\\n            } else {\\n                if (prevN > 0) return false;\\n                prevN = n;\\n            }\\n            prevN--;\\n\\n        }\\n        if (prevN > 0) return false;\\n        return true;\\n    }\\n\\n    public static int getN(int num) {\\n        int mask = 1 << 7;\\n        int count = 0;\\n        while ((mask & num) != 0) {\\n            count++;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int prevN = 0;\\n        for (int i : data) {\\n            int n = getN(i);\\n            if (n > 4) return false;\\n\\n            //An integer can either represent the start of a UTF-8 character, or a part of an existing UTF-8 character.\\n            // There are two separate rules for these two scenarios in the problem.\\n            if (n == 1) {\\n                //scenario 1: If an integer is a part of an existing UTF-8 character, simply check the 2 most significant bits of in the binary representation string.\\n                // They should be 10.  ie. n==1\\n                if (prevN <= 0) return false;\\n            } else {\\n                //scenario 2: If the integer represents the start of a UTF-8 character,\\n                // then the first few bits would be 1 followed by a 0. The number of initial bits\\n                // (most significant) bits determines the length of the UTF-8 character. ie length  = n\\n                if (prevN > 0) return false;\\n                // The array can contain multiple valid UTF-8 characters. ie. start of new UTF-8 character\\n                prevN = n;\\n            }\\n            prevN--;\\n\\n        }\\n        if (prevN > 0) return false;\\n        return true;\\n    }\\n\\n    public static int getN(int num) {\\n        //We can use bit masking to check how many initial bits are set for a given number. \\n        // We only need to work with the 8 least significant bits as mentioned in the problem.\\n        int mask = 1 << 7;\\n        int count = 0;\\n        while ((mask & num) != 0) {\\n            count++;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int prevN = 0;\\n        for (int i : data) {\\n            int n = getN(i);\\n            if (n > 4) {\\n                return false;\\n            } else if (n == 1) {\\n                if (prevN <= 0) return false;\\n            } else {\\n                if (prevN > 0) return false;\\n                prevN = n;\\n            }\\n            prevN--;\\n\\n        }\\n        if (prevN > 0) return false;\\n        return true;\\n    }\\n\\n    public static int getN(int num) {\\n        int mask = 1 << 7;\\n        int count = 0;\\n        while ((mask & num) != 0) {\\n            count++;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976447,
                "title": "c-solution-with-explanation-in-comments-o-n-time-o-1-space",
                "content": "```cpp\\n  // Returs the expected number of bytes in the UTF8 character.\\n    int get_num_bytes(int data) {\\n        if (data >> 7 == 0) { // 0xxxxxxx >> 7 == 0\\n            return 1;\\n        }\\n        if (data >> 5 == 6) { // 110xxxxx >> 5 == 6\\n            return 2;\\n        }\\n        if (data >> 4 == 14) { // 1110xxxx >> 4 == 14\\n            return 3;\\n        }\\n        if (data >> 3 == 30) { // 11110xxx >> 3 == 30\\n            return 4;\\n        }\\n        return 0;\\n    }\\n    \\n    // Returns whether the following byte sequence is valid.\\n    bool is_valid_multibyte(int data) {\\n       return (data >> 6 == 2); // 10xxxxxx >> 6 == 2\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        for (int byte_index = 0; byte_index < data.size(); ++byte_index) {\\n            auto num_bytes = get_num_bytes(data[byte_index]);\\n            if (num_bytes == 0) {\\n                return false;\\n            }\\n            if (num_bytes == 1) { \\n                // We are not expecting any following bytes for single byte\\n                // UTF8 character.\\n                continue;\\n            }\\n            if (data.size() < num_bytes + byte_index) {\\n                // Make sure we have the expected number of bytes in the\\n                // data vector for this UTF8 character.\\n                return false;\\n            }\\n            // Make sure that all the byte sequences are valid.\\n            while(--num_bytes > 0) {\\n                ++byte_index;\\n                if (!is_valid_multibyte(data[byte_index])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```cpp\\n  // Returs the expected number of bytes in the UTF8 character.\\n    int get_num_bytes(int data) {\\n        if (data >> 7 == 0) { // 0xxxxxxx >> 7 == 0\\n            return 1;\\n        }\\n        if (data >> 5 == 6) { // 110xxxxx >> 5 == 6\\n            return 2;\\n        }\\n        if (data >> 4 == 14) { // 1110xxxx >> 4 == 14\\n            return 3;\\n        }\\n        if (data >> 3 == 30) { // 11110xxx >> 3 == 30\\n            return 4;\\n        }\\n        return 0;\\n    }\\n    \\n    // Returns whether the following byte sequence is valid.\\n    bool is_valid_multibyte(int data) {\\n       return (data >> 6 == 2); // 10xxxxxx >> 6 == 2\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        for (int byte_index = 0; byte_index < data.size(); ++byte_index) {\\n            auto num_bytes = get_num_bytes(data[byte_index]);\\n            if (num_bytes == 0) {\\n                return false;\\n            }\\n            if (num_bytes == 1) { \\n                // We are not expecting any following bytes for single byte\\n                // UTF8 character.\\n                continue;\\n            }\\n            if (data.size() < num_bytes + byte_index) {\\n                // Make sure we have the expected number of bytes in the\\n                // data vector for this UTF8 character.\\n                return false;\\n            }\\n            // Make sure that all the byte sequences are valid.\\n            while(--num_bytes > 0) {\\n                ++byte_index;\\n                if (!is_valid_multibyte(data[byte_index])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 644907,
                "title": "rust-12-lines-short-solution-0ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let mut left = 0; \\n        for d in data.iter() {\\n            if left == 0 {\\n                if d >> 3 == 0b11110 { left = 3 }\\n                else if d >> 4 == 0b1110 { left = 2 }\\n                else if d >> 5 == 0b110 { left = 1 }\\n                else if d >> 7 == 0b0 { left = 0 }\\n                else { return false }\\n            } else {\\n                if d >> 6 != 0b10 { return false }\\n                left -= 1;\\n            }\\n        }\\n        left == 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let mut left = 0; \\n        for d in data.iter() {\\n            if left == 0 {\\n                if d >> 3 == 0b11110 { left = 3 }\\n                else if d >> 4 == 0b1110 { left = 2 }\\n                else if d >> 5 == 0b110 { left = 1 }\\n                else if d >> 7 == 0b0 { left = 0 }\\n                else { return false }\\n            } else {\\n                if d >> 6 != 0b10 { return false }\\n                left -= 1;\\n            }\\n        }\\n        left == 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311973,
                "title": "3ms-straightforward-java-solution-with-customized-to-binary-string-method",
                "content": "The idea is:\\n1. Loop through the int array.\\n2. For current int, convert to 8 digits string with \\'0\\' prefix padding\\n3. If it starts with \\'0\\', continue;\\n4. If it starts with known patterns, setup the number of digits\\n5. Otherwise, return false since unknown pattern encountered.\\n6. Check following number of ints to see if they all are starts with \"10\", if not, return false;\\n\\npublic boolean validUtf8(int[] data) {\\n        if (data == null || data.length == 0) return false;\\n        \\n        int i = 0;\\n        while (i < data.length) {\\n            String strBinary = toBinaryString(data[i++]);\\n            \\n            if (strBinary.startsWith(\"0\")) {\\n                continue;\\n            }\\n            \\n            int numLeft = 0;\\n            \\n            if (strBinary.startsWith(\"110\")) {\\n                numLeft = 1;\\n            } else if (strBinary.startsWith(\"1110\")) {\\n                numLeft = 2;\\n            } else if (strBinary.startsWith(\"11110\")) {\\n                numLeft = 3;\\n            } else {\\n                return false;\\n            }\\n            \\n            if (i + numLeft > data.length) {\\n                return false;\\n            }\\n            \\n            while (numLeft > 0) {\\n                strBinary = toBinaryString(data[i++]);\\n                if (!strBinary.startsWith(\"10\")) {\\n                    return false;\\n                }\\n                numLeft--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private String toBinaryString(int input) {\\n        char[] out = new char[8];\\n        \\n        for (int j = 0; j < 8; j++) out[j] = \\'0\\';\\n        \\n        int i = 7;\\n        while(input > 0 && i >= 0) {\\n            out[i--] += input % 2;\\n            input /= 2;\\n        }\\n        \\n        return new String(out);\\n    }",
                "solutionTags": [],
                "code": "The idea is:\\n1. Loop through the int array.\\n2. For current int, convert to 8 digits string with \\'0\\' prefix padding\\n3. If it starts with \\'0\\', continue;\\n4. If it starts with known patterns, setup the number of digits\\n5. Otherwise, return false since unknown pattern encountered.\\n6. Check following number of ints to see if they all are starts with \"10\", if not, return false;\\n\\npublic boolean validUtf8(int[] data) {\\n        if (data == null || data.length == 0) return false;\\n        \\n        int i = 0;\\n        while (i < data.length) {\\n            String strBinary = toBinaryString(data[i++]);\\n            \\n            if (strBinary.startsWith(\"0\")) {\\n                continue;\\n            }\\n            \\n            int numLeft = 0;\\n            \\n            if (strBinary.startsWith(\"110\")) {\\n                numLeft = 1;\\n            } else if (strBinary.startsWith(\"1110\")) {\\n                numLeft = 2;\\n            } else if (strBinary.startsWith(\"11110\")) {\\n                numLeft = 3;\\n            } else {\\n                return false;\\n            }\\n            \\n            if (i + numLeft > data.length) {\\n                return false;\\n            }\\n            \\n            while (numLeft > 0) {\\n                strBinary = toBinaryString(data[i++]);\\n                if (!strBinary.startsWith(\"10\")) {\\n                    return false;\\n                }\\n                numLeft--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private String toBinaryString(int input) {\\n        char[] out = new char[8];\\n        \\n        for (int j = 0; j < 8; j++) out[j] = \\'0\\';\\n        \\n        int i = 7;\\n        while(input > 0 && i >= 0) {\\n            out[i--] += input % 2;\\n            input /= 2;\\n        }\\n        \\n        return new String(out);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 251054,
                "title": "easiest-java-solution-4ms",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for(int value : data) {\\n            if(count == 0) {\\n                if(value >> 5 == 0b110)\\n                    count = 1; //more 1 byte\\n                else if(value >> 4 == 0b1110)\\n                    count = 2; //more 2 bytes\\n                else if(value >> 3 == 0b11110)\\n                    count = 3; //more 3 bytes\\n                else if(value >> 7 != 0)\\n                    return false; //means just 1 byte data\\n            }\\n            else {\\n                if(value >> 6 != 0b10) //all bytes should start with 10\\n                    return false;\\n                count--;\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for(int value : data) {\\n            if(count == 0) {\\n                if(value >> 5 == 0b110)\\n                    count = 1; //more 1 byte\\n                else if(value >> 4 == 0b1110)\\n                    count = 2; //more 2 bytes\\n                else if(value >> 3 == 0b11110)\\n                    count = 3; //more 3 bytes\\n                else if(value >> 7 != 0)\\n                    return false; //means just 1 byte data\\n            }\\n            else {\\n                if(value >> 6 != 0b10) //all bytes should start with 10\\n                    return false;\\n                count--;\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87496,
                "title": "simple-one-pass-concise-java-solution-beating-99",
                "content": "So, I wrote a literal translation of the problem statement in Java. This works in O(n), obviously.\\n\\n```\\npublic class Solution {\\n\\tpublic boolean validUtf8(int[] data) {\\n\\t\\tint varCharLeft = 0;\\n\\t\\tfor (int b: data) {\\n\\t\\t\\tif (varCharLeft == 0) {\\n\\t\\t\\t\\tif ((b & 0b010000000) == 0)  varCharLeft = 0;\\n\\t\\t\\t\\telse if ((b & 0b011100000) == 0b11000000)  varCharLeft = 1;\\n\\t\\t\\t\\telse if ((b & 0b011110000) == 0b11100000)  varCharLeft = 2;\\n\\t\\t\\t\\telse if ((b & 0b011111000) == 0b11110000)  varCharLeft = 3;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ((b & 0b011000000) != 0b10000000)  return false;\\n\\t\\t\\t\\tvarCharLeft--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn varCharLeft==0;\\n\\t}\\n}\\n```\\n\\nJust bragging, this beats 99.86% submissions. But, seems like in leetcode, timing is very inconsistent nowadays. \\n![0_1475701198342_Capture.PNG](/uploads/files/1475701270757-capture.png)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic boolean validUtf8(int[] data) {\\n\\t\\tint varCharLeft = 0;\\n\\t\\tfor (int b: data) {\\n\\t\\t\\tif (varCharLeft == 0) {\\n\\t\\t\\t\\tif ((b & 0b010000000) == 0)  varCharLeft = 0;\\n\\t\\t\\t\\telse if ((b & 0b011100000) == 0b11000000)  varCharLeft = 1;\\n\\t\\t\\t\\telse if ((b & 0b011110000) == 0b11100000)  varCharLeft = 2;\\n\\t\\t\\t\\telse if ((b & 0b011111000) == 0b11110000)  varCharLeft = 3;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ((b & 0b011000000) != 0b10000000)  return false;\\n\\t\\t\\t\\tvarCharLeft--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn varCharLeft==0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87533,
                "title": "python-o-n-scan",
                "content": "```\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(data) == 0:\\n            return True \\n        i = 0\\n        while i < len(data):\\n            if data[i] < 128:\\n                i += 1\\n            elif data[i] >= 192 and data[i] < 224 and len(data)-i>=2:\\n                if data[i+1] >= 128 and data[i+1] < 192:\\n                    i += 2\\n                else:\\n                    return False \\n            elif data[i] >= 224 and data[i] < 240 and len(data)-i>=3:\\n                if data[i+1] >= 128 and data[i+1] < 192 and data[i+2] >= 128 and data[i+2] < 192:\\n                    i += 3\\n                else:\\n                    return False  \\n            elif data[i] >= 240 and data[i] < 248 and len(data)-i>=4:\\n                if data[i+1] >= 128 and data[i+1] < 192 and data[i+2] >= 128 and data[i+2] < 192 and data[i+3] >= 128 and data[i+3] < 192:\\n                    i += 4\\n                else:\\n                    return False        \\n            else:\\n                return False\\n        return True \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(data) == 0:\\n            return True \\n        i = 0\\n        while i < len(data):\\n            if data[i] < 128:\\n                i += 1\\n            elif data[i] >= 192 and data[i] < 224 and len(data)-i>=2:\\n                if data[i+1] >= 128 and data[i+1] < 192:\\n                    i += 2\\n                else:\\n                    return False \\n            elif data[i] >= 224 and data[i] < 240 and len(data)-i>=3:\\n                if data[i+1] >= 128 and data[i+1] < 192 and data[i+2] >= 128 and data[i+2] < 192:\\n                    i += 3\\n                else:\\n                    return False  \\n            elif data[i] >= 240 and data[i] < 248 and len(data)-i>=4:\\n                if data[i+1] >= 128 and data[i+1] < 192 and data[i+2] >= 128 and data[i+2] < 192 and data[i+3] >= 128 and data[i+3] < 192:\\n                    i += 4\\n                else:\\n                    return False        \\n            else:\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726810,
                "title": "c-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// We will iterate through array. Let, we are at data[i]. So,count no. of 1 bits in its MSB position. For this, I have used count1Bits() function\\n// If no. of 1 bits in leftmost position=0 then it is 1 Byte character (& it should start from zero which it is starting as its leftmost position=0), so simply do i++.\\n// If no. of 1 bits in leftmost position=1 then it is not valid. Bcoz, leftmost 1\\'s should be zero or >=2 & <4\\n\\n//Once, we get count of 1\\'s in leftmost position at data[i], let these are 4, so next 3 numbers should start with 10. Now, to check if next 3 numbers are starting with 10 or not, I have called isCorrect() function\\n\\n    int count1Bits(int n){\\n        if(((1<<7)&n)==0)\\n            return 1;\\n        int x=7, count=0;\\n        while(x>=0){\\n            if(((1<<x)&n)>0){\\n                count++;\\n                x--;\\n            }\\n            else\\n                return count;\\n        }\\n        return count;\\n    }\\n    \\n    bool isCorrect(int n){\\n        if(((1<<7)&n)==0)\\n            return false;\\n        if(((1<<6)&n)==0)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int sz=data.size();\\n        int i=0;\\n        \\n        while(i<sz){\\n            int n=count1Bits(data[i]);\\n            cout<<n<<\" \";\\n            \\n            if(n==1){\\n                if(((1<<7)&data[i])==0)\\n                i++;\\n                else   //if no. of 1 in leftmost position=1, then it is invalid\\n                return false;\\n            }\\n            \\n        //since, a character in utf-8 can be from 1 to 4 bytes long. So, if n>4, return false\\n            else if(n>4)  \\n            return false;\\n\\n            else{\\n                int j=0;\\n\\n// If no. of 1\\'s in leftmost position=4 then we need to check next 3 numbers. So, that\\'s why I have done n--\\n                n--;  \\n            \\n                \\n                while((i+1)<sz && j<n){\\n                    if(isCorrect(data[i+1])==false)\\n                        return false;\\n                    i++;\\n                    j++;\\n                }\\n                if(j!=n)\\n                    return false;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// We will iterate through array. Let, we are at data[i]. So,count no. of 1 bits in its MSB position. For this, I have used count1Bits() function\\n// If no. of 1 bits in leftmost position=0 then it is 1 Byte character (& it should start from zero which it is starting as its leftmost position=0), so simply do i++.\\n// If no. of 1 bits in leftmost position=1 then it is not valid. Bcoz, leftmost 1\\'s should be zero or >=2 & <4\\n\\n//Once, we get count of 1\\'s in leftmost position at data[i], let these are 4, so next 3 numbers should start with 10. Now, to check if next 3 numbers are starting with 10 or not, I have called isCorrect() function\\n\\n    int count1Bits(int n){\\n        if(((1<<7)&n)==0)\\n            return 1;\\n        int x=7, count=0;\\n        while(x>=0){\\n            if(((1<<x)&n)>0){\\n                count++;\\n                x--;\\n            }\\n            else\\n                return count;\\n        }\\n        return count;\\n    }\\n    \\n    bool isCorrect(int n){\\n        if(((1<<7)&n)==0)\\n            return false;\\n        if(((1<<6)&n)==0)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int sz=data.size();\\n        int i=0;\\n        \\n        while(i<sz){\\n            int n=count1Bits(data[i]);\\n            cout<<n<<\" \";\\n            \\n            if(n==1){\\n                if(((1<<7)&data[i])==0)\\n                i++;\\n                else   //if no. of 1 in leftmost position=1, then it is invalid\\n                return false;\\n            }\\n            \\n        //since, a character in utf-8 can be from 1 to 4 bytes long. So, if n>4, return false\\n            else if(n>4)  \\n            return false;\\n\\n            else{\\n                int j=0;\\n\\n// If no. of 1\\'s in leftmost position=4 then we need to check next 3 numbers. So, that\\'s why I have done n--\\n                n--;  \\n            \\n                \\n                while((i+1)<sz && j<n){\\n                    if(isCorrect(data[i+1])==false)\\n                        return false;\\n                    i++;\\n                    j++;\\n                }\\n                if(j!=n)\\n                    return false;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2848437,
                "title": "java-simple-solution",
                "content": "This is simple and intuitive Java solution\\n\\n```\\npublic boolean validUtf8(int[] data) {\\n        int size = data.length;\\n        if (size == 0) {\\n            return false;\\n        }\\n\\n        for (int index = 0; index < size; index++) {\\n            int bitCount = getUnicodeBytesCount(data[index]);\\n            if (bitCount == -1 || size - index < bitCount) {\\n                return false;\\n            }\\n            \\n            for (int subIndex = 1; subIndex < bitCount; subIndex++) {\\n                if (getLastNBits(data[++index], 2) != 0b10) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public int getUnicodeBytesCount(int firstByte) {\\n        if (getLastNBits(firstByte, 1) == 0b0) {\\n            return 1;\\n        } else if (getLastNBits(firstByte, 3) == 0b110) {\\n            return 2;\\n        } else if (getLastNBits(firstByte, 4) == 0b1110) {\\n            return 3;\\n        } else if (getLastNBits(firstByte, 5) == 0b11110) {\\n            return 4;\\n        } else {\\n            return -1;\\n        }\\n    }\\n\\n    public int getLastNBits(int digit, int n) {\\n        int shift = 8 - (Math.max(n, 0));\\n\\n        return ((digit >> shift) & (0b11111111 >> shift));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n        int size = data.length;\\n        if (size == 0) {\\n            return false;\\n        }\\n\\n        for (int index = 0; index < size; index++) {\\n            int bitCount = getUnicodeBytesCount(data[index]);\\n            if (bitCount == -1 || size - index < bitCount) {\\n                return false;\\n            }\\n            \\n            for (int subIndex = 1; subIndex < bitCount; subIndex++) {\\n                if (getLastNBits(data[++index], 2) != 0b10) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public int getUnicodeBytesCount(int firstByte) {\\n        if (getLastNBits(firstByte, 1) == 0b0) {\\n            return 1;\\n        } else if (getLastNBits(firstByte, 3) == 0b110) {\\n            return 2;\\n        } else if (getLastNBits(firstByte, 4) == 0b1110) {\\n            return 3;\\n        } else if (getLastNBits(firstByte, 5) == 0b11110) {\\n            return 4;\\n        } else {\\n            return -1;\\n        }\\n    }\\n\\n    public int getLastNBits(int digit, int n) {\\n        int shift = 8 - (Math.max(n, 0));\\n\\n        return ((digit >> shift) & (0b11111111 >> shift));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582055,
                "title": "java-simplest-o-n-no-bit-manipulation",
                "content": "Using some knowledge about Binary numbers we can find that:\\n0xxxxxxx  can have min value of 0 and max value of127 to represent that i am using a simple mathematical notation [i,j]= interval including i and j where i is lower bound and j is upper bound.\\n\\nSo, we can modify our representation as:\\n0xxxxxxx[0,127]\\n110xxxxx[192,223] 10xxxxxx[128,191]\\n1110xxxx[224,239] 10xxxxxx[128,191] 10xxxxxx[128,191]\\n11110xxx[240,247] 10xxxxxx[128,191] 10xxxxxx[128,191] 10xxxxxx[128,191]\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int nextToCheck=0;\\n        for(int i=0;i<data.length;i++)\\n            if( nextToCheck>0 )\\n                if( data[i]>127 && data[i]<192 ) nextToCheck--;\\n                else return false;\\n            else\\n                if( data[i]<128 );\\n                else if( data[i]>191 && data[i]<224 ) nextToCheck=1;\\n                else if( data[i]>223 && data[i]<240 ) nextToCheck=2;\\n                else if( data[i]>239 && data[i]<248 ) nextToCheck=3;\\n                else return false;\\n        if(nextToCheck>0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int nextToCheck=0;\\n        for(int i=0;i<data.length;i++)\\n            if( nextToCheck>0 )\\n                if( data[i]>127 && data[i]<192 ) nextToCheck--;\\n                else return false;\\n            else\\n                if( data[i]<128 );\\n                else if( data[i]>191 && data[i]<224 ) nextToCheck=1;\\n                else if( data[i]>223 && data[i]<240 ) nextToCheck=2;\\n                else if( data[i]>239 && data[i]<248 ) nextToCheck=3;\\n                else return false;\\n        if(nextToCheck>0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575460,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        next = 0\\n        for i in data:\\n            if next == 0:\\n                if (i>>5)==0b110:#for 2 bytes\\n                    next = 1\\n                elif (i>>4)==0b1110:#for 3 bytes\\n                    next = 2\\n                elif (i>>3)==0b11110:#for 4 bytes\\n                    next = 3\\n                elif (i>>7)!= 0b0:\\n                    return False\\n            else:\\n                if (i>>6)!= 0b10:#checking next occurence\\n                    return False\\n                next -= 1\\n        if next == 0:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        next = 0\\n        for i in data:\\n            if next == 0:\\n                if (i>>5)==0b110:#for 2 bytes\\n                    next = 1\\n                elif (i>>4)==0b1110:#for 3 bytes\\n                    next = 2\\n                elif (i>>3)==0b11110:#for 4 bytes\\n                    next = 3\\n                elif (i>>7)!= 0b0:\\n                    return False\\n            else:\\n                if (i>>6)!= 0b10:#checking next occurence\\n                    return False\\n                next -= 1\\n        if next == 0:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572751,
                "title": "java-solution-right-shift-operator",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int bytesRemain = 0;\\n        for (int val : data)\\n        {\\n            if (bytesRemain==0)\\n            {\\n                if (val>>7 == 0b0)\\n                  bytesRemain = 0;\\n                else if (val>>5 == 0b110)\\n                    bytesRemain = 1;\\n                else if (val>>4 == 0b1110)\\n                  bytesRemain = 2;\\n                else if (val>>3 == 0b11110)\\n                    bytesRemain = 3;\\n                else \\n                    return false; // for TestCase [255] \\n            }\\n            else \\n            {\\n                if (val >> 6 == 0b10)\\n                    bytesRemain--;\\n                else \\n                    return false;\\n            }    \\n        }\\n        return bytesRemain == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int bytesRemain = 0;\\n        for (int val : data)\\n        {\\n            if (bytesRemain==0)\\n            {\\n                if (val>>7 == 0b0)\\n                  bytesRemain = 0;\\n                else if (val>>5 == 0b110)\\n                    bytesRemain = 1;\\n                else if (val>>4 == 0b1110)\\n                  bytesRemain = 2;\\n                else if (val>>3 == 0b11110)\\n                    bytesRemain = 3;\\n                else \\n                    return false; // for TestCase [255] \\n            }\\n            else \\n            {\\n                if (val >> 6 == 0b10)\\n                    bytesRemain--;\\n                else \\n                    return false;\\n            }    \\n        }\\n        return bytesRemain == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572673,
                "title": "c-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int val) {\\n        int res = 0, len = 8;\\n        while(val and len) {\\n            if(val&1) res++;\\n            else res = 0;\\n            val>>=1, len--;\\n        }\\n        if(len) return 0;\\n        return res;\\n    }\\n    bool notPossible(vector<int>& data, int idx, int ones, int n) {\\n        idx++, ones--;\\n        while(idx < n and ones and find(data[idx]) == 1) idx++, ones--;\\n        return ones;\\n        \\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int idx = 0, n = data.size();\\n        while(idx < n) {\\n            int val = find(data[idx]);\\n            if(val == 1 or val > 4) return 0;\\n            if(val) {\\n                if(notPossible(data, idx, val, n)) return 0;\\n                idx += val;\\n            }\\n            else idx++;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int val) {\\n        int res = 0, len = 8;\\n        while(val and len) {\\n            if(val&1) res++;\\n            else res = 0;\\n            val>>=1, len--;\\n        }\\n        if(len) return 0;\\n        return res;\\n    }\\n    bool notPossible(vector<int>& data, int idx, int ones, int n) {\\n        idx++, ones--;\\n        while(idx < n and ones and find(data[idx]) == 1) idx++, ones--;\\n        return ones;\\n        \\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int idx = 0, n = data.size();\\n        while(idx < n) {\\n            int val = find(data[idx]);\\n            if(val == 1 or val > 4) return 0;\\n            if(val) {\\n                if(notPossible(data, idx, val, n)) return 0;\\n                idx += val;\\n            }\\n            else idx++;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572204,
                "title": "golang-with-examples-and-cases-explanation",
                "content": "Test cases below the code.\\n\\n```go\\nfunc validUtf8(data []int) bool {\\n\\t\\t// represents how many bytes to be read for the character\\n        numberOfBytes := 0\\n        for i := 0; i < len(data); i++ {\\n                // expect starting of the new character\\n                if numberOfBytes == 0 {\\n                        switch {\\n\\t\\t\\t\\t\\t\\t// single byte character\\n                        case data[i]&0x80 == 0:\\n                                continue\\n\\t\\t\\t\\t\\t\\t// two bytes character\\n                        case (data[i]&0xC0 == 0xC0) && (data[i]&0x20 == 0):\\n                                numberOfBytes = 1\\n\\t\\t\\t\\t\\t\\t// three bytes character\\n                        case (data[i]&0xE0 == 0xE0) && (data[i]&0x10 == 0):\\n                                numberOfBytes = 2\\n\\t\\t\\t\\t\\t\\t// four bytes character\\n                        case (data[i]&0xF0 == 0xF0) && (data[i]&0x08 == 0):\\n                                numberOfBytes = 3\\n\\t\\t\\t\\t\\t\\t// if no match - invalid\\n                        default:\\n                                return false\\n                        }\\n                } else {\\n\\t\\t\\t\\t\\t\\t// if the first bit is not set or second bit is not zero\\n                        if !((data[i]&0x80 == 0x80) && (data[i]&0x40 == 0)) {\\n                                return false\\n                        }\\n                        numberOfBytes--\\n                }\\n        }\\n\\t\\t// there could be a case when not enough bytes existed in `data` for multibytes character\\n        return numberOfBytes == 0\\n}\\n```\\n\\nTests:\\n```go\\ntype test struct {\\n\\t\\tdata   []int\\n\\t\\texpect bool\\n}\\n\\ntests := []test{\\n\\t\\t{[]int{127}, true},                // 0b01111111 - single byte character\\n\\t\\t{[]int{128}, false},               // 0b10000000 - invalid, first bit is set\\n\\t\\t{[]int{170}, false},               // 0b10101010 - invalid, first bit is set\\n\\t\\t{[]int{200, 128}, true},           // 0b11001000 0b10000000 - two bytes\\n\\t\\t{[]int{200, 192}, false},          // 0b11001000 0b11000000 - invalid, second byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160, 127}, false},     // 0b11100000 0b10100000 0b01111111 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160}, false},          // 0b11100000 0b10100000 - invalid, expect one more byte for three bytes character\\n\\t\\t{[]int{224, 160, 192}, false},     // 0b11100000 0b10100000 0b11000000 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160, 191}, true},      // 0b11100000 0b10100000 0b10111111 - three bytes character\\n\\t\\t{[]int{248}, false},               // 0b11111000 - invalid, expect maximum 4 bits set, got 5\\n\\t\\t{[]int{224, 160, 193}, false},     // 0b11100000 0b10100000 0b11000001 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{244, 160, 191}, false},     // 0b11100000 0b10100000 0b10111111 - invalid, ecpect one more byte for four bytes character\\n\\t\\t{[]int{244, 160, 191, 178}, true}, // 0b11100000 0b10100000 0b10111111 0b10110010 - four bytes character\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc validUtf8(data []int) bool {\\n\\t\\t// represents how many bytes to be read for the character\\n        numberOfBytes := 0\\n        for i := 0; i < len(data); i++ {\\n                // expect starting of the new character\\n                if numberOfBytes == 0 {\\n                        switch {\\n\\t\\t\\t\\t\\t\\t// single byte character\\n                        case data[i]&0x80 == 0:\\n                                continue\\n\\t\\t\\t\\t\\t\\t// two bytes character\\n                        case (data[i]&0xC0 == 0xC0) && (data[i]&0x20 == 0):\\n                                numberOfBytes = 1\\n\\t\\t\\t\\t\\t\\t// three bytes character\\n                        case (data[i]&0xE0 == 0xE0) && (data[i]&0x10 == 0):\\n                                numberOfBytes = 2\\n\\t\\t\\t\\t\\t\\t// four bytes character\\n                        case (data[i]&0xF0 == 0xF0) && (data[i]&0x08 == 0):\\n                                numberOfBytes = 3\\n\\t\\t\\t\\t\\t\\t// if no match - invalid\\n                        default:\\n                                return false\\n                        }\\n                } else {\\n\\t\\t\\t\\t\\t\\t// if the first bit is not set or second bit is not zero\\n                        if !((data[i]&0x80 == 0x80) && (data[i]&0x40 == 0)) {\\n                                return false\\n                        }\\n                        numberOfBytes--\\n                }\\n        }\\n\\t\\t// there could be a case when not enough bytes existed in `data` for multibytes character\\n        return numberOfBytes == 0\\n}\\n```\n```go\\ntype test struct {\\n\\t\\tdata   []int\\n\\t\\texpect bool\\n}\\n\\ntests := []test{\\n\\t\\t{[]int{127}, true},                // 0b01111111 - single byte character\\n\\t\\t{[]int{128}, false},               // 0b10000000 - invalid, first bit is set\\n\\t\\t{[]int{170}, false},               // 0b10101010 - invalid, first bit is set\\n\\t\\t{[]int{200, 128}, true},           // 0b11001000 0b10000000 - two bytes\\n\\t\\t{[]int{200, 192}, false},          // 0b11001000 0b11000000 - invalid, second byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160, 127}, false},     // 0b11100000 0b10100000 0b01111111 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160}, false},          // 0b11100000 0b10100000 - invalid, expect one more byte for three bytes character\\n\\t\\t{[]int{224, 160, 192}, false},     // 0b11100000 0b10100000 0b11000000 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160, 191}, true},      // 0b11100000 0b10100000 0b10111111 - three bytes character\\n\\t\\t{[]int{248}, false},               // 0b11111000 - invalid, expect maximum 4 bits set, got 5\\n\\t\\t{[]int{224, 160, 193}, false},     // 0b11100000 0b10100000 0b11000001 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{244, 160, 191}, false},     // 0b11100000 0b10100000 0b10111111 - invalid, ecpect one more byte for four bytes character\\n\\t\\t{[]int{244, 160, 191, 178}, true}, // 0b11100000 0b10100000 0b10111111 0b10110010 - four bytes character\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571823,
                "title": "runtime-30-ms-memory-usage-6-8-mb-implemented-in-c",
                "content": "Runtime: 30 ms, Memory Usage: 6.8 MB implemented in C.\\n\\n```c\\nbool validUtf8(const int* data, const int len){\\n    unsigned char match;\\n    for(int i = 0; i < len; i += 1)\\n    {\\n        if((0x80 & data[i]) == 0x00)\\n            continue;\\n        else if((0xE0 & data[i]) == 0xC0)\\n            match = 1;\\n        else if((0xF0 & data[i]) == 0xE0)\\n            match = 2;\\n        else if((0xF8 & data[i]) == 0xF0)\\n            match = 3;\\n        else\\n            return false;\\n\\n        if(i + match >= len)\\n            return 0;\\n        for(; match > 0; match -= 1)\\n            if((0xC0 & data[++i]) != 0x80)\\n                return false;\\n    }\\n    \\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```c\\nbool validUtf8(const int* data, const int len){\\n    unsigned char match;\\n    for(int i = 0; i < len; i += 1)\\n    {\\n        if((0x80 & data[i]) == 0x00)\\n            continue;\\n        else if((0xE0 & data[i]) == 0xC0)\\n            match = 1;\\n        else if((0xF0 & data[i]) == 0xE0)\\n            match = 2;\\n        else if((0xF8 & data[i]) == 0xF0)\\n            match = 3;\\n        else\\n            return false;\\n\\n        if(i + match >= len)\\n            return 0;\\n        for(; match > 0; match -= 1)\\n            if((0xC0 & data[++i]) != 0x80)\\n                return false;\\n    }\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571819,
                "title": "o-n-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        \\n        int n = data.length, byt = 0;\\n        for( int i=0; i<n; i++ ){\\n            \\n            if( byt==0 ) {\\n\\t\\t\\t\\t// to check how many bytes number we currently have\\n\\t\\t\\t\\t// when the number is one byte -> directly checking left most bit\\n                if( ((data[i]>>7)&1)==0 ) continue;\\n\\t\\t\\t\\t// to get the number of left most 1\\'s -> n 1 -> leading to (n-1) terms starting with \"10\"\\n                else {\\n                    byt = encoding(data[i]);\\n\\t\\t\\t\\t\\t// if byt is 0 , it means number only has 1 left most bit which is not valid\\n                    if( byt==0 ) return false;\\n                }\\n            }\\n            else{\\n                int num = data[i];\\n                num = num>>6;\\n\\t\\t\\t\\t// to check whether the number starts with 10 or not \\n                if( num!=2 ) return false;\\n                byt--;\\n            }\\n            // the number of terms after the main byte cannot be greater than or equal to 4\\n            if( byt>=4 ) return false;\\n        }\\n        if( byt!=0 ) return false;\\n        return true;\\n    }\\n    \\n\\t// function to return left most 1\\'s of a number\\n    public int encoding( int num ){\\n        int pos = 1, res = 0;\\n        while( num>0 ){\\n            if( (num&1)==0 ) res = pos;\\n            pos++;\\n            num = num>>1;\\n        }\\n        \\n        return (8-res-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        \\n        int n = data.length, byt = 0;\\n        for( int i=0; i<n; i++ ){\\n            \\n            if( byt==0 ) {\\n\\t\\t\\t\\t// to check how many bytes number we currently have\\n\\t\\t\\t\\t// when the number is one byte -> directly checking left most bit\\n                if( ((data[i]>>7)&1)==0 ) continue;\\n\\t\\t\\t\\t// to get the number of left most 1\\'s -> n 1 -> leading to (n-1) terms starting with \"10\"\\n                else {\\n                    byt = encoding(data[i]);\\n\\t\\t\\t\\t\\t// if byt is 0 , it means number only has 1 left most bit which is not valid\\n                    if( byt==0 ) return false;\\n                }\\n            }\\n            else{\\n                int num = data[i];\\n                num = num>>6;\\n\\t\\t\\t\\t// to check whether the number starts with 10 or not \\n                if( num!=2 ) return false;\\n                byt--;\\n            }\\n            // the number of terms after the main byte cannot be greater than or equal to 4\\n            if( byt>=4 ) return false;\\n        }\\n        if( byt!=0 ) return false;\\n        return true;\\n    }\\n    \\n\\t// function to return left most 1\\'s of a number\\n    public int encoding( int num ){\\n        int pos = 1, res = 0;\\n        while( num>0 ){\\n            if( (num&1)==0 ) res = pos;\\n            pos++;\\n            num = num>>1;\\n        }\\n        \\n        return (8-res-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571588,
                "title": "python-bit-manipulation-with-state-machine",
                "content": "In embedded system\\n, we use state machine a lot since it would not \"hold\" the mcu compuation source too long\\nthat make the system stall in the for-loop or while-loop.\\n\\nMost commonly,  if there are some data protocol we need to parse, \\nstate machine is the first choice since we are not sure when the next data will received.\\nWe can polling the reciever to see whether the data goes in, but it\\'s not very source efficient.\\n\\n**For this problem, we can simplfy the state machine to Two-Step.**\\n1. Check if the data fit the first-byte of UTF-8 (start with 0, 110, 1110, 11110)\\n\\t, we set the count to how many 10-start byte we need to check(ex. 1110 means there should be two 10-start bytes follow up)\\n\\t, and go to state-1\\n2. Check if data start with 10 and minus the count.\\n   if count is 0, go back to state-0.\\n   \\n```\\nclass Solution:\\n\\tdef validUtf8(self, data: List[int]) -> bool:\\n\\t\\tindex = 0\\n\\t\\tstate = 0 #this is for state-machine\\n\\t\\tcount = 0 #this is counter for checking 10-start data\\n\\t\\t\\n\\t\\twhile index<len(data):\\n\\t\\t\\tmatch(state):\\n\\t\\t\\t\\tcase 0: #state-0 check leading byte\\n\\t\\t\\t\\t\\tif data[index]>>3==0x1E: #if data start with 11110\\n\\t\\t\\t\\t\\t\\tcount = 3\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>4==0x0E: #if data start with 1110\\n\\t\\t\\t\\t\\t\\tcount = 2\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>5==0x06: #if data start with 110\\n\\t\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>7==0x00: #if data start with 0\\n\\t\\t\\t\\t\\t\\tindex+=1 #no need to go to state-1 since there is no 10-start byte followed by\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False #data invalid\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase 1: #state-1 check 10-start byte\\n\\t\\t\\t\\t\\tif data[index]>>6==0x02:\\n\\t\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\t\\t\\tstate = 0 #there is no 10-start byte followed by, go back to state-0\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\n\\t\\t#data runs out\\n\\t\\tif state==0:\\n\\t\\t\\treturn True #if state back to 0, means data is complete\\n\\t\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n\\tdef validUtf8(self, data: List[int]) -> bool:\\n\\t\\tindex = 0\\n\\t\\tstate = 0 #this is for state-machine\\n\\t\\tcount = 0 #this is counter for checking 10-start data\\n\\t\\t\\n\\t\\twhile index<len(data):\\n\\t\\t\\tmatch(state):\\n\\t\\t\\t\\tcase 0: #state-0 check leading byte\\n\\t\\t\\t\\t\\tif data[index]>>3==0x1E: #if data start with 11110\\n\\t\\t\\t\\t\\t\\tcount = 3\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>4==0x0E: #if data start with 1110\\n\\t\\t\\t\\t\\t\\tcount = 2\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>5==0x06: #if data start with 110\\n\\t\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>7==0x00: #if data start with 0\\n\\t\\t\\t\\t\\t\\tindex+=1 #no need to go to state-1 since there is no 10-start byte followed by\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False #data invalid\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase 1: #state-1 check 10-start byte\\n\\t\\t\\t\\t\\tif data[index]>>6==0x02:\\n\\t\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\t\\t\\tstate = 0 #there is no 10-start byte followed by, go back to state-0\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\n\\t\\t#data runs out\\n\\t\\tif state==0:\\n\\t\\t\\treturn True #if state back to 0, means data is complete\\n\\t\\treturn False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571448,
                "title": "easiest-explanation-nothing-complex-c",
                "content": "```\\n string binary(int data)\\n    {\\n        string ans=\"\";\\n        while(data>0)\\n        {\\n            ans=to_string(data%2)+ans;\\n            data/=2;\\n        }\\n        \\n        for(int i=ans.size();i<8;i++)\\n            ans=to_string(0)+ans;\\n        \\n        return ans;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        \\n        vector<string> arr;\\n        for(auto i:data)\\n            arr.push_back(binary(i));  //convert number into its binary string\\n        \\n        int i=0;\\n        while(i<arr.size())\\n        {\\n            if(arr[i].substr(0,1)==\"0\")  //1 byte\\n             i++;\\n            \\n            else if(arr[i].substr(0,3)==\"110\")  //2 byte\\n            {\\n                i++;\\n                int count=0;\\n                while(count<1)  //1  \\'10\\' aane chiye agar 2-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++; count++;\\n                }\\n                \\n            }\\n            \\n            else if(arr[i].substr(0,4)==\"1110\")  //3 byte\\n            {\\n                i++;\\n                int count=0;\\n                while(count<2) //2  \\'10\\' aane chiye agar 3-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++; count++;\\n                } \\n            }\\n            \\n            else if(arr[i].substr(0,5)==\"11110\") //4 byte \\n            {\\n                i++;\\n                int count=0;\\n                while(count<3)  //3  \\'10\\' aane chiye agar 4-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++;  count++;\\n                }  \\n            }\\n            else  //charo me se kisi se b match nahi kr rha fir to pkka se false hai\\n                return false;\\n        }\\n        return true;  //agar till now false nahi aya to true. We can represent array in UTF-8\\n    }",
                "solutionTags": [],
                "code": "```\\n string binary(int data)\\n    {\\n        string ans=\"\";\\n        while(data>0)\\n        {\\n            ans=to_string(data%2)+ans;\\n            data/=2;\\n        }\\n        \\n        for(int i=ans.size();i<8;i++)\\n            ans=to_string(0)+ans;\\n        \\n        return ans;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        \\n        vector<string> arr;\\n        for(auto i:data)\\n            arr.push_back(binary(i));  //convert number into its binary string\\n        \\n        int i=0;\\n        while(i<arr.size())\\n        {\\n            if(arr[i].substr(0,1)==\"0\")  //1 byte\\n             i++;\\n            \\n            else if(arr[i].substr(0,3)==\"110\")  //2 byte\\n            {\\n                i++;\\n                int count=0;\\n                while(count<1)  //1  \\'10\\' aane chiye agar 2-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++; count++;\\n                }\\n                \\n            }\\n            \\n            else if(arr[i].substr(0,4)==\"1110\")  //3 byte\\n            {\\n                i++;\\n                int count=0;\\n                while(count<2) //2  \\'10\\' aane chiye agar 3-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++; count++;\\n                } \\n            }\\n            \\n            else if(arr[i].substr(0,5)==\"11110\") //4 byte \\n            {\\n                i++;\\n                int count=0;\\n                while(count<3)  //3  \\'10\\' aane chiye agar 4-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++;  count++;\\n                }  \\n            }\\n            else  //charo me se kisi se b match nahi kr rha fir to pkka se false hai\\n                return false;\\n        }\\n        return true;  //agar till now false nahi aya to true. We can represent array in UTF-8\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2571352,
                "title": "javascript-string-manipulation",
                "content": "```\\nconst myObj = {\\n    \"0\" : 1,\\n    \"110\" : 2,\\n    \"1110\" : 3,\\n    \"11110\" : 4,\\n    \"111110\" : 5,\\n    \"1111110\" : 6,\\n    \"11111110\" : 7,\\n    \"11111111\" : 8\\n}\\nvar validUtf8 = function(data) {\\n    let j = 0, count = 0;\\n    \\n    while(j < data.length){\\n        let ele = data[j].toString(2);\\n        ele = \"00000000\".substring(ele.length) + ele;\\n        if(ele.substring(0,2) === \"10\")\\n            return false;\\n    \\n        for(key in myObj){\\n            if(ele.startsWith(key))\\n                count = myObj[key];\\n        }\\n        if(count > 4)\\n            return false;\\n        \\n        for(var i = j+1;i<j+count;i++){\\n            let elem = data[i];\\n            if(elem === undefined) return false;\\n            let val = elem.toString(2);\\n            val = \"00000000\".substring(val.length) + val;\\n            if(val.substring(0,2) !== \"10\") return false;\\n        }\\n        j  =  i;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst myObj = {\\n    \"0\" : 1,\\n    \"110\" : 2,\\n    \"1110\" : 3,\\n    \"11110\" : 4,\\n    \"111110\" : 5,\\n    \"1111110\" : 6,\\n    \"11111110\" : 7,\\n    \"11111111\" : 8\\n}\\nvar validUtf8 = function(data) {\\n    let j = 0, count = 0;\\n    \\n    while(j < data.length){\\n        let ele = data[j].toString(2);\\n        ele = \"00000000\".substring(ele.length) + ele;\\n        if(ele.substring(0,2) === \"10\")\\n            return false;\\n    \\n        for(key in myObj){\\n            if(ele.startsWith(key))\\n                count = myObj[key];\\n        }\\n        if(count > 4)\\n            return false;\\n        \\n        for(var i = j+1;i<j+count;i++){\\n            let elem = data[i];\\n            if(elem === undefined) return false;\\n            let val = elem.toString(2);\\n            val = \"00000000\".substring(val.length) + val;\\n            if(val.substring(0,2) !== \"10\") return false;\\n        }\\n        j  =  i;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571260,
                "title": "easiest-explanation-without-bit-manipulation-in-o-n-time-and-o-1-space",
                "content": "First we have to Think about the range and Preprocess the data ,\\n Suppose If any number in the array is greater than 247 ,then it can never have its 4byte UTF-8\\n\\nSo lets find range ,So if first four bit is set ,then that number must be greater than or equal to 240.\\n If first three bits get set ,then that number must be greater than or equal to 224.\\nIf first two bits are set then the number must be greater than or equal to 192.\\nIf first one digit gets set ,then the number must be greater than 128 and these number must get followed by any of the above number ,otherwise we have to return false.\\nif number is less than 128 ,then it will be 1 byte number.\\nSo ,what we have to do ,if we encounter any number ,first we find range ,and then we take consceutive array elements and check whether it is greater than 128 and less than 192 or not ,if it is then we go in a loop ,otherwise we return false.\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {        \\n        for(int i = 0 ; i < data.length ; i++){\\n            if(data[i] > 247){\\n                return false;\\n            }\\n            int tillThisIndex = range(data[i]);\\n            if(tillThisIndex == -1){\\n                continue;\\n            }else if(tillThisIndex == 0){\\n                return false;\\n            }else if(tillThisIndex > 0){\\n                i++;\\n                int h = i+tillThisIndex;\\n                while(i<data.length && i<h){\\n                    if(range(data[i]) == 0){\\n                        i++;\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n                if(i < h){\\n                    return false;\\n                }\\n                i--;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public int range(int number){\\n        if(number >= 240){\\n            return 3;\\n        }else if(number >= 224){\\n            return 2;\\n        }else if(number >= 192){\\n            return 1;\\n        }else if(number >= 128){\\n            return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {        \\n        for(int i = 0 ; i < data.length ; i++){\\n            if(data[i] > 247){\\n                return false;\\n            }\\n            int tillThisIndex = range(data[i]);\\n            if(tillThisIndex == -1){\\n                continue;\\n            }else if(tillThisIndex == 0){\\n                return false;\\n            }else if(tillThisIndex > 0){\\n                i++;\\n                int h = i+tillThisIndex;\\n                while(i<data.length && i<h){\\n                    if(range(data[i]) == 0){\\n                        i++;\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n                if(i < h){\\n                    return false;\\n                }\\n                i--;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public int range(int number){\\n        if(number >= 240){\\n            return 3;\\n        }else if(number >= 224){\\n            return 2;\\n        }else if(number >= 192){\\n            return 1;\\n        }else if(number >= 128){\\n            return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571157,
                "title": "c-100-simple-solution",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n    bool validUtf8(vector<int>& data) {\\n         int rbytes = 0;\\n       for(int num : data)\\n       {\\n           if(rbytes==0){\\n                if(num>>7 == 0)\\n                rbytes = 0;\\n               else if(num >> 5 == 6)\\n                   rbytes = 1;\\n               else if(num >> 4 == 14)\\n                   rbytes = 2;\\n               else if(num >> 3 == 30)\\n                   rbytes = 3;\\n               else\\n                   return false;\\n                   \\n           }\\n           else{\\n               // cout<<num << \" \"<<(num&197)<<\" \";\\n               if(num >> 6 == 2)\\n                   rbytes-=1;\\n               else \\n                   return false;\\n           }\\n       \\n           \\n       }\\n        return rbytes == 0;\\n    }\\n    int bitCounter(int num)\\n    {\\n           int bitSize = 0;\\n           int diviser = 128;\\n           while(num&diviser){\\n               bitSize+=1;\\n               diviser=(diviser>>1);\\n           }\\n        return bitSize;\\n    }\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool validUtf8(vector<int>& data) {\\n         int rbytes = 0;\\n       for(int num : data)\\n       {\\n           if(rbytes==0){\\n                if(num>>7 == 0)\\n                rbytes = 0;\\n               else if(num >> 5 == 6)\\n                   rbytes = 1;\\n               else if(num >> 4 == 14)\\n                   rbytes = 2;\\n               else if(num >> 3 == 30)\\n                   rbytes = 3;\\n               else\\n                   return false;\\n                   \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2571105,
                "title": "without-using-bit-manipulation-c",
                "content": "It can be very easy , if we start thining from end.\\n\\n```\\nbool validUtf8(vector<int>& data) {\\n        \\n        int byte = 1;\\n        \\n        for(int i=data.size()-1;i>=0;i--){\\n            if(data[i]<128){\\n                \\n                if(byte!=1) return false;\\n                \\n            }else if(128<=data[i] && data[i]<=191){\\n                \\n                byte++;\\n                if(byte>4) return false;\\n                \\n            }else{\\n                string s = bitset<8> (data[i]).to_string();\\n            \\n                for(int b=0;b<byte;b++) if(s[b] != \\'1\\') return false;\\n                if(s[byte] != \\'0\\') return false;\\n                \\n                byte=1;\\n            }\\n        }\\n        if(byte==1) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool validUtf8(vector<int>& data) {\\n        \\n        int byte = 1;\\n        \\n        for(int i=data.size()-1;i>=0;i--){\\n            if(data[i]<128){\\n                \\n                if(byte!=1) return false;\\n                \\n            }else if(128<=data[i] && data[i]<=191){\\n                \\n                byte++;\\n                if(byte>4) return false;\\n                \\n            }else{\\n                string s = bitset<8> (data[i]).to_string();\\n            \\n                for(int b=0;b<byte;b++) if(s[b] != \\'1\\') return false;\\n                if(s[byte] != \\'0\\') return false;\\n                \\n                byte=1;\\n            }\\n        }\\n        if(byte==1) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571004,
                "title": "faster-than-98-c-very-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/7f508077-3517-4afc-b657-6bd518f4fce6_1663075059.7093277.png)\\n\\n# ***Code :***\\n\\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& arr) {\\n        \\n        int n = arr.size ();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if ((arr [i] >> 7) == 0) continue;\\n            else if ((arr [i] >> 5) == 6 and i + 1 < n and (arr [i + 1] >> 6) == 2) i++;\\n            else if ((arr [i] >> 4) == 14 and i + 2 < n and (arr [i + 1] >> 6) == 2 and (arr [i + 2] >> 6) == 2) i += 2;\\n            else if ((arr [i] >> 3) == 30 and i + 3 < n and (arr [i + 1] >> 6) == 2 and (arr [i + 2] >> 6) == 2 and (arr [i + 3] >> 6) == 2) i += 3;\\n            else return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& arr) {\\n        \\n        int n = arr.size ();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if ((arr [i] >> 7) == 0) continue;\\n            else if ((arr [i] >> 5) == 6 and i + 1 < n and (arr [i + 1] >> 6) == 2) i++;\\n            else if ((arr [i] >> 4) == 14 and i + 2 < n and (arr [i + 1] >> 6) == 2 and (arr [i + 2] >> 6) == 2) i += 2;\\n            else if ((arr [i] >> 3) == 30 and i + 3 < n and (arr [i + 1] >> 6) == 2 and (arr [i + 2] >> 6) == 2 and (arr [i + 3] >> 6) == 2) i += 3;\\n            else return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570682,
                "title": "utf-8-validation-bit-manipulation-java-solution",
                "content": "* Time Complexity: O(n)\\n* Space Complexity: O(1)\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int remainingBytes = 0;\\n        \\n        for(int val : data) {\\n            if(remainingBytes == 0) {\\n                if((val >> 7) == 0b0) {\\n                    remainingBytes = 0;    \\n                } else if((val >> 5) == 0b110) {\\n                    remainingBytes = 1;       \\n                } else if((val >> 4) == 0b1110) {\\n                    remainingBytes = 2;\\n                } else if((val >> 3) == 0b11110) {\\n                    remainingBytes = 3;   \\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if((val >> 6) == 0b10) {\\n                    remainingBytes--;    \\n                } else {\\n                    return false;\\n                }\\n            }\\n        }     \\n        \\n        if(remainingBytes != 0) {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int remainingBytes = 0;\\n        \\n        for(int val : data) {\\n            if(remainingBytes == 0) {\\n                if((val >> 7) == 0b0) {\\n                    remainingBytes = 0;    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2570651,
                "title": "c-easy-solution",
                "content": "**C++ Code:**\\n\\n```\\n bool validUtf8(vector<int>& data) {\\n        int rbytes = 0;\\n        for(int i=0;i<data.size();i++){\\n            if(rbytes==0){\\n            if((data[i]>>5)==0b110) rbytes=1; // for 2 no of Bytes\\n            else if((data[i]>>4)==0b1110) rbytes=2; // For 3 no of Bytes\\n            else if((data[i]>>3)==0b11110) rbytes=3; // for 4 no of Bytes\\n            else if((data[i]>>7)) return false;      // for 1 no of Bytes\\n           }\\n           else{\\n              if((data[i]>>6)!=0b10) return false;\\n                  rbytes--;\\n           }\\n        }\\n     return rbytes==0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n bool validUtf8(vector<int>& data) {\\n        int rbytes = 0;\\n        for(int i=0;i<data.size();i++){\\n            if(rbytes==0){\\n            if((data[i]>>5)==0b110) rbytes=1; // for 2 no of Bytes\\n            else if((data[i]>>4)==0b1110) rbytes=2; // For 3 no of Bytes\\n            else if((data[i]>>3)==0b11110) rbytes=3; // for 4 no of Bytes\\n            else if((data[i]>>7)) return false;      // for 1 no of Bytes\\n           }\\n           else{\\n              if((data[i]>>6)!=0b10) return false;\\n                  rbytes--;\\n           }\\n        }\\n     return rbytes==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570596,
                "title": "c-use-bit-manipulation",
                "content": "class Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n     int rbyte=0;\\n    for(int val:data){\\n        if(rbyte==0) {\\n            if((val>>7)==0b0){rbyte=0; }\\n            else if((val>>5)==0b110) { rbyte=1;}\\n            else if((val>>4)==0b1110){ rbyte=2; }\\n            else if((val>>3)==0b11110){rbyte=3;}\\n            else {return false; }\\n        }\\n        else\\n        {\\n            if((val>>6)==0b10) {rbyte--;}\\n            else{  return false; }\\n        }\\n    }\\n       \\n       if(rbyte==0) {return true;}\\n        else { return false;}\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n     int rbyte=0;\\n    for(int val:data){\\n        if(rbyte==0) {\\n            if((val>>7)==0b0){rbyte=0; }",
                "codeTag": "Java"
            },
            {
                "id": 2570345,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\n\\n    bool validUtf8(vector<int>& data) { \\n        int i=0;\\n        int n= data.size();\\n        while (i<n){\\n            if (data[i] >=248) return false;\\n            if ( data[i]>=240 &&data[i]<=247 ) {\\n                if (i+3>n) return false;\\n                if ((data[i+1] <128 || data[i+1] >191)|| (data[i+2] <128 || data[i+2] >191)||(data[i+3] <128 || data[i+3] >191)) return false;\\n              i+=4;  \\n            }\\n            else if ( data[i]>=224 &&data[i]<=239 ) {\\n\\n                if (i+2>n) return false ;\\n                if ((data[i+1] <128 || data[i+1] >191)||(data[i+2] <128 || data[i+2] >191)) return false;\\n\\n              i+=3;  \\n\\n            }\\n            else if (( data[i]>=192 &&data[i]<=233 )) {\\n\\n                if (i+1>n) return false;\\n                if ((data[i+1] <128  || data[i+1] >191)) return false;\\n\\n              i+=2;  \\n\\n            }\\n           else if ( data[i]<=127 ) {\\n\\n                \\n\\n              i+=1;  \\n\\n            }\\n            else return false;\\n        \\n        }\\n\\n \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n\\n    bool validUtf8(vector<int>& data) { \\n        int i=0;\\n        int n= data.size();\\n        while (i<n){\\n            if (data[i] >=248) return false;\\n            if ( data[i]>=240 &&data[i]<=247 ) {\\n                if (i+3>n) return false;\\n                if ((data[i+1] <128 || data[i+1] >191)|| (data[i+2] <128 || data[i+2] >191)||(data[i+3] <128 || data[i+3] >191)) return false;\\n              i+=4;  \\n            }\\n            else if ( data[i]>=224 &&data[i]<=239 ) {\\n\\n                if (i+2>n) return false ;\\n                if ((data[i+1] <128 || data[i+1] >191)||(data[i+2] <128 || data[i+2] >191)) return false;\\n\\n              i+=3;  \\n\\n            }\\n            else if (( data[i]>=192 &&data[i]<=233 )) {\\n\\n                if (i+1>n) return false;\\n                if ((data[i+1] <128  || data[i+1] >191)) return false;\\n\\n              i+=2;  \\n\\n            }\\n           else if ( data[i]<=127 ) {\\n\\n                \\n\\n              i+=1;  \\n\\n            }\\n            else return false;\\n        \\n        }\\n\\n \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570329,
                "title": "cool-walkthrough-of-the-question-with-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findOnes(string &t){//1\\n        int cnt=0;\\n        for(int i=0;i<8 and t[i]!=\\'0\\';i++){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        vector<string> check; \\n        for(auto v: data){  //4\\n            string temp=\"\";\\n            for(int i=0;i<8;i++){\\n                if(v&(1<<i)){\\n                    temp.push_back(\\'1\\');\\n                }\\n                else temp.push_back(\\'0\\');\\n            }\\n            reverse(temp.begin(),temp.end());\\n            check.push_back(temp);\\n        }\\n        \\n        // for(auto v:  check) cout<<v<<\" \";\\n        //encoding done of 8-LSB\\n        \\n        int i=0, sz=check.size();\\n        while(i<sz){\\n            int cnt = findOnes(check[i]);\\n            if(cnt>=2 and cnt<=4){ //5\\n                int j=cnt-1;\\n                if(i+j>=sz) return false;  //6\\n                int k=1;\\n                while(k<=j){//8\\n                    int ones=findOnes(check[i+k]);\\n                    if(ones!=1) return false; //7\\n                    k++;\\n                }\\n                i+=cnt;\\n            }\\n            else if(cnt!=0) return false;  //2\\n            else i++; //3\\n        }\\n        \\n        return true;\\n    }\\n};\\n/*\\n\\na/q:- \\n\\nwe need to consider only the least significant 8 bits of each number. (8-LSB) (UTF-8 encoding)\\n\\nthere must be atmost 4 bytes numbers. \\n\\nno. of continous 1(s) from MSB in its UTF-8 encoding is the no. of bytes.\\n\\nso if cnt=2, its a 2 byte number. if cnt=3, its a 3 byte number and so on.\\n\\nfor cnt=0, its a 1 byte numbers a/q.\\n\\nif more than 4bytes then its not a valid encoding. \\n\\n\\nfor 1 byte: cnt will be 0. \\nfor 2 byte: cnt=2, and next numbers should be only containing cnt as 1.\\nfor 3 byte: cnt=3, and next 2 numbers should be only containing cnt as 1.\\nfor 4 byte: cnt=4, and next 3 numbers should be only containing cnt as 1.\\n\\n\\n//1: returns the cnt of continuous 1(s) starting from the MSB of the number.\\n\\n//2: for numbers > 4 bytes like: (255: 11111111 or any number with form as 11111000 or more value of cnt), we straight away return false.\\n\\n//3: when its a 1 byte no. we just do i++, and go to the next number. (cnt=0)\\n\\n//4: we make the 8-LSB of each number. On these numbers validation would be done.\\n\\n//5: for 2,3 and 4 bytes numbers. for 2 bytes number we check for the next 1 number (it should be 10xxxxxx (cnt=1) format). for 3 bytes number(cnt=3) , next 2 numbers must be of the 10xxxxxx (cnt=1) format. and for 4 bytes number (cnt=4) , next 3 numbers must be of the 10xxxxxx (cnt=1) format.\\n\\n//7: there isnt a number of the format 10xxxxxx after n-byte number.\\n\\n//8: checking next cnt-1 numbers. they must be of the form : 10xxxxxx (cnt=1)\\n\\n//6: there are not enough 10xxxxxx numbers after the n-byte number. so we return false.\\n\\n\\n*/\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findOnes(string &t){//1\\n        int cnt=0;\\n        for(int i=0;i<8 and t[i]!=\\'0\\';i++){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        vector<string> check; \\n        for(auto v: data){  //4\\n            string temp=\"\";\\n            for(int i=0;i<8;i++){\\n                if(v&(1<<i)){\\n                    temp.push_back(\\'1\\');\\n                }\\n                else temp.push_back(\\'0\\');\\n            }\\n            reverse(temp.begin(),temp.end());\\n            check.push_back(temp);\\n        }\\n        \\n        // for(auto v:  check) cout<<v<<\" \";\\n        //encoding done of 8-LSB\\n        \\n        int i=0, sz=check.size();\\n        while(i<sz){\\n            int cnt = findOnes(check[i]);\\n            if(cnt>=2 and cnt<=4){ //5\\n                int j=cnt-1;\\n                if(i+j>=sz) return false;  //6\\n                int k=1;\\n                while(k<=j){//8\\n                    int ones=findOnes(check[i+k]);\\n                    if(ones!=1) return false; //7\\n                    k++;\\n                }\\n                i+=cnt;\\n            }\\n            else if(cnt!=0) return false;  //2\\n            else i++; //3\\n        }\\n        \\n        return true;\\n    }\\n};\\n/*\\n\\na/q:- \\n\\nwe need to consider only the least significant 8 bits of each number. (8-LSB) (UTF-8 encoding)\\n\\nthere must be atmost 4 bytes numbers. \\n\\nno. of continous 1(s) from MSB in its UTF-8 encoding is the no. of bytes.\\n\\nso if cnt=2, its a 2 byte number. if cnt=3, its a 3 byte number and so on.\\n\\nfor cnt=0, its a 1 byte numbers a/q.\\n\\nif more than 4bytes then its not a valid encoding. \\n\\n\\nfor 1 byte: cnt will be 0. \\nfor 2 byte: cnt=2, and next numbers should be only containing cnt as 1.\\nfor 3 byte: cnt=3, and next 2 numbers should be only containing cnt as 1.\\nfor 4 byte: cnt=4, and next 3 numbers should be only containing cnt as 1.\\n\\n\\n//1: returns the cnt of continuous 1(s) starting from the MSB of the number.\\n\\n//2: for numbers > 4 bytes like: (255: 11111111 or any number with form as 11111000 or more value of cnt), we straight away return false.\\n\\n//3: when its a 1 byte no. we just do i++, and go to the next number. (cnt=0)\\n\\n//4: we make the 8-LSB of each number. On these numbers validation would be done.\\n\\n//5: for 2,3 and 4 bytes numbers. for 2 bytes number we check for the next 1 number (it should be 10xxxxxx (cnt=1) format). for 3 bytes number(cnt=3) , next 2 numbers must be of the 10xxxxxx (cnt=1) format. and for 4 bytes number (cnt=4) , next 3 numbers must be of the 10xxxxxx (cnt=1) format.\\n\\n//7: there isnt a number of the format 10xxxxxx after n-byte number.\\n\\n//8: checking next cnt-1 numbers. they must be of the form : 10xxxxxx (cnt=1)\\n\\n//6: there are not enough 10xxxxxx numbers after the n-byte number. so we return false.\\n\\n\\n*/\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2570318,
                "title": "javascript-dfs",
                "content": "```\\nvar validUtf8 = function(data) {\\n    const n = data.length;\\n\\n    const calculateSetMsbs = (num) => {\\n        let i = 7;\\n        let setMsbs = 0;\\n\\n        while(i >= 0) {\\n            if(((1 << i) & num) === 0) break;\\n            setMsbs += 1;\\n            i -= 1;\\n        }\\n\\n        return setMsbs;\\n    }\\n\\n    const msbs = [];\\n    for(let i = 0; i < n; i += 1) {\\n        const setMsbs = calculateSetMsbs(data[i]);\\n        msbs.push(setMsbs);\\n    }\\n\\n    const dfs = (i = 0) => {\\n        if(i === n) return true;\\n\\n        const setMsbs = msbs[i];\\n        if(setMsbs === 0) {\\n            return dfs(i + 1);\\n        }\\n        if(setMsbs === 2) {\\n            return i + 1 < n && msbs[i + 1] === 1 && dfs(i + 2);\\n        }\\n        if(setMsbs === 3) {\\n            return i + 2 < n && msbs[i + 1] === 1 && msbs[i + 2] === 1 && dfs(i + 3);\\n        }\\n        if(setMsbs === 4) {\\n            return i + 3 < n && msbs[i + 1] === 1 && msbs[i + 2] === 1 && msbs[i + 3] === 1 && dfs(i + 4);\\n        }\\n\\n        return false;\\n    }\\n\\n    return dfs();\\n};\\n```\\nRuntime: O(n)\\nSpace: O(n)",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar validUtf8 = function(data) {\\n    const n = data.length;\\n\\n    const calculateSetMsbs = (num) => {\\n        let i = 7;\\n        let setMsbs = 0;\\n\\n        while(i >= 0) {\\n            if(((1 << i) & num) === 0) break;\\n            setMsbs += 1;\\n            i -= 1;\\n        }\\n\\n        return setMsbs;\\n    }\\n\\n    const msbs = [];\\n    for(let i = 0; i < n; i += 1) {\\n        const setMsbs = calculateSetMsbs(data[i]);\\n        msbs.push(setMsbs);\\n    }\\n\\n    const dfs = (i = 0) => {\\n        if(i === n) return true;\\n\\n        const setMsbs = msbs[i];\\n        if(setMsbs === 0) {\\n            return dfs(i + 1);\\n        }\\n        if(setMsbs === 2) {\\n            return i + 1 < n && msbs[i + 1] === 1 && dfs(i + 2);\\n        }\\n        if(setMsbs === 3) {\\n            return i + 2 < n && msbs[i + 1] === 1 && msbs[i + 2] === 1 && dfs(i + 3);\\n        }\\n        if(setMsbs === 4) {\\n            return i + 3 < n && msbs[i + 1] === 1 && msbs[i + 2] === 1 && msbs[i + 3] === 1 && dfs(i + 4);\\n        }\\n\\n        return false;\\n    }\\n\\n    return dfs();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570272,
                "title": "python3-regular-expression",
                "content": "We can use the power of standard library here. Just convert input into a string and match with a regular expression. Each element of the list L represents one of 4 possible encodigs. Then we combine them and add \"+\" symbol as our input must contain at least one Unicode character. \\n\\n```\\nimport re\\nclass Solution:\\n    def __init__(self):\\n        L = [\"0b(0|1[01]{0,6})\",\\n            \"0b110.....(0b10......)\",\\n            \"0b1110....(0b10......){2}\",\\n            \"0b11110...(0b10......){3}\" ]\\n        regexp = \"(\" + \\\\\\n            (\"|\".join(L)) + \\\\\\n            \")+\" \\n        self.R = re.compile(regexp)\\n        \\n    def validUtf8(self, data: List[int]) -> bool:\\n        return bool(re.fullmatch(self.R, \"\".join(map(bin, data))))\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nclass Solution:\\n    def __init__(self):\\n        L = [\"0b(0|1[01]{0,6})\",\\n            \"0b110.....(0b10......)\",\\n            \"0b1110....(0b10......){2}\",\\n            \"0b11110...(0b10......){3}\" ]\\n        regexp = \"(\" + \\\\\\n            (\"|\".join(L)) + \\\\\\n            \")+\" \\n        self.R = re.compile(regexp)\\n        \\n    def validUtf8(self, data: List[int]) -> bool:\\n        return bool(re.fullmatch(self.R, \"\".join(map(bin, data))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570255,
                "title": "bit-manipulation-java",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbyte=0;\\n        for(int num:data)\\n        {\\n            if(rbyte==0){\\n                if(num >> 7 == 0b0) rbyte=0;\\n                else if(num >> 5 ==0b110) rbyte=1;\\n                else if(num >> 4 == 0b1110) rbyte=2;\\n                else if(num >> 3 == 0b11110) rbyte=3;\\n                else return false;\\n            }\\n            else {\\n                if(num >> 6 ==0b10) rbyte--;\\n                else return false;\\n            }\\n        }\\n        if(rbyte>0) return false;\\n        return true;\\n        \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbyte=0;\\n        for(int num:data)\\n        {\\n            if(rbyte==0){\\n                if(num >> 7 == 0b0) rbyte=0;\\n                else if(num >> 5 ==0b110) rbyte=1;\\n                else if(num >> 4 == 0b1110) rbyte=2;\\n                else if(num >> 3 == 0b11110) rbyte=3;\\n                else return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2570186,
                "title": "c-easy-solution-with-function-helper",
                "content": "```\\nclass Solution {\\npublic:\\n    // return number of bytes need to be proccesed (for example: for 4 bytes return 3), -1 on error;\\n    int parse_first_byte(int byte) {\\n        if ((byte >> 7) == 0) { // if mask is 0xxxxxxx\\n            return 0;\\n        } else if ((byte >> 5) == 6) { // if mask is 110xxxxx\\n            return 1;\\n        } else if ((byte >> 4) == 14) { // if mask is 1110xxxx\\n            return 2;\\n        } else if ((byte >> 3) == 30) { // if mask is 11110xxx\\n            return 3;\\n        } \\n        return -1;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int need_to_process{};\\n        for (int i = 0; i < data.size(); ++i) {\\n            if (need_to_process == 0) {\\n                need_to_process = parse_first_byte(data[i]);\\n                // Check how many bytes we need to process, if there are no available data or error: return false\\n                if ((need_to_process == -1) || (data.size() - i < need_to_process)) {\\n                    return false;\\n                }\\n            } else {\\n                // if we check n-bytes and it is doesn\\'t match 10xxxxxx mask, return error\\n                if ((data[i] >> 6) != 2) {\\n                    return false;\\n                } else {\\n                    --need_to_process;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // return number of bytes need to be proccesed (for example: for 4 bytes return 3), -1 on error;\\n    int parse_first_byte(int byte) {\\n        if ((byte >> 7) == 0) { // if mask is 0xxxxxxx\\n            return 0;\\n        } else if ((byte >> 5) == 6) { // if mask is 110xxxxx\\n            return 1;\\n        } else if ((byte >> 4) == 14) { // if mask is 1110xxxx\\n            return 2;\\n        } else if ((byte >> 3) == 30) { // if mask is 11110xxx\\n            return 3;\\n        } \\n        return -1;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int need_to_process{};\\n        for (int i = 0; i < data.size(); ++i) {\\n            if (need_to_process == 0) {\\n                need_to_process = parse_first_byte(data[i]);\\n                // Check how many bytes we need to process, if there are no available data or error: return false\\n                if ((need_to_process == -1) || (data.size() - i < need_to_process)) {\\n                    return false;\\n                }\\n            } else {\\n                // if we check n-bytes and it is doesn\\'t match 10xxxxxx mask, return error\\n                if ((data[i] >> 6) != 2) {\\n                    return false;\\n                } else {\\n                    --need_to_process;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569942,
                "title": "java-solution-bit-manipulation-easy",
                "content": "### Please Upvote !!!\\n```\\n/*\\n    1 byte = 8 bits\\n    ---------------\\n\\n     Number of Bytes   |        UTF-8 Octet Sequence\\n                       |              (binary)\\n     ------------------+-----------------------------------------\\n a)         1          |   0xxxxxxx\\n b)         2          |   110xxxxx 10xxxxxx\\n c)         3          |   1110xxxx 10xxxxxx 10xxxxxx\\n d)         4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n                           |______| |_______|________|________|\\n                           1st Byte       Remaining Bytes\\n*/\\n\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int remBytes = 0;   // Remaining bytes after the 1st byte\\n\\n        for (int n : data) {\\n\\n            if (remBytes == 0) {\\n                if (n >> 7 == 0b0) remBytes = 0;            // 1st byte of 1 length char (a)\\n                else if (n >> 5 == 0b110) remBytes = 1;     // 1st byte of 2 length char (b)\\n                else if (n >> 4 == 0b1110) remBytes = 2;    // 1st byte of 3 length char (c)\\n                else if (n >> 3 == 0b11110) remBytes = 3;   // 1st byte of 4 length char (d)\\n                else return false;                          // NOTA\\n\\n            } else {                                        // if more than 1 byte, we check if the rest start with 10\\n                if (n >> 6 == 0b10) remBytes--;             // if yes, we decrease remaining bytes\\n                else return false;                          // If not, sequence not valid\\n            }\\n        }\\n\\n        return remBytes == 0;       // At the end if there are no remening bytes, sequence is valid.\\n    }\\n}\\n\\n// TC: O(n) -> We iterate over the array\\n// SC: O(1) -> No extra space used\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n    1 byte = 8 bits\\n    ---------------\\n\\n     Number of Bytes   |        UTF-8 Octet Sequence\\n                       |              (binary)\\n     ------------------+-----------------------------------------\\n a)         1          |   0xxxxxxx\\n b)         2          |   110xxxxx 10xxxxxx\\n c)         3          |   1110xxxx 10xxxxxx 10xxxxxx\\n d)         4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n                           |______| |_______|________|________|\\n                           1st Byte       Remaining Bytes\\n*/\\n\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int remBytes = 0;   // Remaining bytes after the 1st byte\\n\\n        for (int n : data) {\\n\\n            if (remBytes == 0) {\\n                if (n >> 7 == 0b0) remBytes = 0;            // 1st byte of 1 length char (a)\\n                else if (n >> 5 == 0b110) remBytes = 1;     // 1st byte of 2 length char (b)\\n                else if (n >> 4 == 0b1110) remBytes = 2;    // 1st byte of 3 length char (c)\\n                else if (n >> 3 == 0b11110) remBytes = 3;   // 1st byte of 4 length char (d)\\n                else return false;                          // NOTA\\n\\n            } else {                                        // if more than 1 byte, we check if the rest start with 10\\n                if (n >> 6 == 0b10) remBytes--;             // if yes, we decrease remaining bytes\\n                else return false;                          // If not, sequence not valid\\n            }\\n        }\\n\\n        return remBytes == 0;       // At the end if there are no remening bytes, sequence is valid.\\n    }\\n}\\n\\n// TC: O(n) -> We iterate over the array\\n// SC: O(1) -> No extra space used\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569904,
                "title": "rust-finite-state-machine",
                "content": "```rust\\n#[derive(Copy, Clone, Eq, PartialEq)]\\nenum State {\\n    NoExpectation,\\n    ExpectOneMore,\\n    ExpectTwoMore,\\n    ExpectThreeMore,\\n    Error,\\n}\\n\\nimpl State {\\n    fn is_valid(self) -> bool {\\n        match self {\\n            State::NoExpectation => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn next(self, b: u8) -> Self {\\n        match self {\\n            State::NoExpectation => on_no_expectation(b),\\n            State::ExpectOneMore => on_one_more(b),\\n            State::ExpectTwoMore => on_two_more(b),\\n            State::ExpectThreeMore => on_three_more(b),\\n            State::Error => State::Error,\\n        }\\n    }\\n}\\nfn on_no_expectation(b: u8) -> State {\\n    if b & 0b1000_0000 == 0 {\\n        State::NoExpectation\\n    } else if b & 0b1110_0000 == 0b1100_0000 {\\n        State::ExpectOneMore\\n    } else if b & 0b1111_0000 == 0b1110_0000 {\\n        State::ExpectTwoMore\\n    } else if b & 0b1111_1000 == 0b1111_0000 {\\n        State::ExpectThreeMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_one_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::NoExpectation\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_two_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::ExpectOneMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_three_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::ExpectTwoMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\npub fn valid_utf8(data: impl AsRef<[i32]>) -> bool {\\n    let data = data.as_ref();\\n    let mut state = State::NoExpectation;\\n\\n    for b in data.iter().map(|&i| i as u8) {\\n        state = state.next(b);\\n        if state == State::Error {\\n            break;\\n        }\\n    }\\n\\n    state.is_valid()\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n#[derive(Copy, Clone, Eq, PartialEq)]\\nenum State {\\n    NoExpectation,\\n    ExpectOneMore,\\n    ExpectTwoMore,\\n    ExpectThreeMore,\\n    Error,\\n}\\n\\nimpl State {\\n    fn is_valid(self) -> bool {\\n        match self {\\n            State::NoExpectation => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn next(self, b: u8) -> Self {\\n        match self {\\n            State::NoExpectation => on_no_expectation(b),\\n            State::ExpectOneMore => on_one_more(b),\\n            State::ExpectTwoMore => on_two_more(b),\\n            State::ExpectThreeMore => on_three_more(b),\\n            State::Error => State::Error,\\n        }\\n    }\\n}\\nfn on_no_expectation(b: u8) -> State {\\n    if b & 0b1000_0000 == 0 {\\n        State::NoExpectation\\n    } else if b & 0b1110_0000 == 0b1100_0000 {\\n        State::ExpectOneMore\\n    } else if b & 0b1111_0000 == 0b1110_0000 {\\n        State::ExpectTwoMore\\n    } else if b & 0b1111_1000 == 0b1111_0000 {\\n        State::ExpectThreeMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_one_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::NoExpectation\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_two_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::ExpectOneMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_three_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::ExpectTwoMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\npub fn valid_utf8(data: impl AsRef<[i32]>) -> bool {\\n    let data = data.as_ref();\\n    let mut state = State::NoExpectation;\\n\\n    for b in data.iter().map(|&i| i as u8) {\\n        state = state.next(b);\\n        if state == State::Error {\\n            break;\\n        }\\n    }\\n\\n    state.is_valid()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569828,
                "title": "bit-manipulation-java",
                "content": "```\\n public boolean validUtf8(int[] data) {\\n        if(data==null || data.length==0) return false;\\n\\tboolean isValid = true;\\n\\tfor(int i=0;i<data.length;i++) {\\n\\t\\tif(data[i]>255) return false; // 1 after 8th digit, 100000000\\n\\t\\tint numberOfBytes = 0;\\n\\t\\tif((data[i] & 128) == 0) { // 0xxxxxxx, 1 byte, 128(10000000)\\n\\t\\t\\tnumberOfBytes = 1;\\n\\t\\t} else if((data[i] & 224) == 192) { // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\\n\\t\\t\\tnumberOfBytes = 2;\\n\\t\\t} else if((data[i] & 240) == 224) { // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\\n\\t\\t\\tnumberOfBytes = 3;\\n\\t\\t} else if((data[i] & 248) == 240) { // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\\n\\t\\t\\tnumberOfBytes = 4;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int j=1;j<numberOfBytes;j++) { // check that the next n bytes start with 10xxxxxx\\n\\t\\t\\tif(i+j>=data.length) return false;\\n\\t\\t\\tif((data[i+j] & 192) != 128) return false; // 192(11000000), 128(10000000)\\n\\t\\t}\\n\\t\\ti=i+numberOfBytes-1;\\n\\t}\\n\\treturn isValid;\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n public boolean validUtf8(int[] data) {\\n        if(data==null || data.length==0) return false;\\n\\tboolean isValid = true;\\n\\tfor(int i=0;i<data.length;i++) {\\n\\t\\tif(data[i]>255) return false; // 1 after 8th digit, 100000000\\n\\t\\tint numberOfBytes = 0;\\n\\t\\tif((data[i] & 128) == 0) { // 0xxxxxxx, 1 byte, 128(10000000)\\n\\t\\t\\tnumberOfBytes = 1;\\n\\t\\t} else if((data[i] & 224) == 192) { // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\\n\\t\\t\\tnumberOfBytes = 2;\\n\\t\\t} else if((data[i] & 240) == 224) { // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\\n\\t\\t\\tnumberOfBytes = 3;\\n\\t\\t} else if((data[i] & 248) == 240) { // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\\n\\t\\t\\tnumberOfBytes = 4;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int j=1;j<numberOfBytes;j++) { // check that the next n bytes start with 10xxxxxx\\n\\t\\t\\tif(i+j>=data.length) return false;\\n\\t\\t\\tif((data[i+j] & 192) != 128) return false; // 192(11000000), 128(10000000)\\n\\t\\t}\\n\\t\\ti=i+numberOfBytes-1;\\n\\t}\\n\\treturn isValid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569769,
                "title": "simple-python-solution-o-n-complexity",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        l = []\\n        \\n        for i in range(len(data)):\\n            l.append(bin(data[i])[2:])\\n            if(len(l[i]) < 8):\\n                l[i] = \\'0\\'*(8-len(l[i]))+l[i]\\n        curr = 0\\n        byte = 0\\n        flag = True\\n        for i in range(len(l)):\\n            if(byte == 0):\\n                j = 0\\n                while(j < len(l[i]) and l[i][j] == \\'1\\'):\\n                    byte +=1\\n                    j += 1\\n                flag = True\\n            elif(byte > 0):\\n                if(flag):\\n                    byte -= 1\\n                    flag = False\\n                if l[i][:2] != \\'10\\':\\n                    return False\\n                byte -= 1\\n            if byte > 4:\\n                return False\\n        if(byte > 0 and len(l) == 1):\\n            return False\\n        if(byte > 0):\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        l = []\\n        \\n        for i in range(len(data)):\\n            l.append(bin(data[i])[2:])\\n            if(len(l[i]) < 8):\\n                l[i] = \\'0\\'*(8-len(l[i]))+l[i]\\n        curr = 0\\n        byte = 0\\n        flag = True\\n        for i in range(len(l)):\\n            if(byte == 0):\\n                j = 0\\n                while(j < len(l[i]) and l[i][j] == \\'1\\'):\\n                    byte +=1\\n                    j += 1\\n                flag = True\\n            elif(byte > 0):\\n                if(flag):\\n                    byte -= 1\\n                    flag = False\\n                if l[i][:2] != \\'10\\':\\n                    return False\\n                byte -= 1\\n            if byte > 4:\\n                return False\\n        if(byte > 0 and len(l) == 1):\\n            return False\\n        if(byte > 0):\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569712,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int remaining = 0;\\n        for (auto& x : data) {\\n            if (remaining == 0) {\\n                if ((x >> 5) == 0b110) {\\n                    remaining = 1;\\n                } \\n                else if ((x >> 4) == 0b1110) {\\n                     remaining = 2;\\n                } \\n                else if ((x >> 3) == 0b11110) {\\n                    remaining = 3;\\n                } \\n                else if ((x >> 7) != 0) {\\n                    return false;\\n                }\\n            } \\n            else {\\n                if ((x >> 6) != 0b10) {\\n                    return false;\\n                }\\n                else {\\n                    remaining--;\\n                }\\n            }\\n        }\\n        return remaining == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int remaining = 0;\\n        for (auto& x : data) {\\n            if (remaining == 0) {\\n                if ((x >> 5) == 0b110) {\\n                    remaining = 1;\\n                } \\n                else if ((x >> 4) == 0b1110) {\\n                     remaining = 2;\\n                } \\n                else if ((x >> 3) == 0b11110) {\\n                    remaining = 3;\\n                } \\n                else if ((x >> 7) != 0) {\\n                    return false;\\n                }\\n            } \\n            else {\\n                if ((x >> 6) != 0b10) {\\n                    return false;\\n                }\\n                else {\\n                    remaining--;\\n                }\\n            }\\n        }\\n        return remaining == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569685,
                "title": "this-is-a-problem-where-c-language-shines-c-o-n",
                "content": "Lets check UTF8 encoding character by character. The steps are simple.\\n1. Find how many bytes does current character contain\\n2. Check character content (continuation marks 0x10xxxxxx)\\n\\n```\\n#define UPPER_1BIT  0x80\\n#define UPPER_2BITS 0xC0\\n#define UPPER_3BITS 0xE0\\n#define UPPER_4BITS 0xF0\\n#define UPPER_5BITS 0xF8\\n\\n#define UTF8_1BYTE_MASK         0x00\\n#define UTF8_2BYTE_MASK         0xC0\\n#define UTF8_3BYTE_MASK         0xE0\\n#define UTF8_4BYTE_MASK         0xF0\\n#define UTF8_CONTINUATION_MASK  0x80\\n\\n#define CHECK_MASK(val, bitmask, target) (((val) & (bitmask)) == (target))\\n\\n\\nbool validUtf8(int* data, int dataSize)\\n{\\n    while(dataSize > 0) {\\n        if(CHECK_MASK(data[0], UPPER_1BIT, UTF8_1BYTE_MASK)) {\\n            data++, dataSize--;\\n        } else if(CHECK_MASK(data[0], UPPER_3BITS, UTF8_2BYTE_MASK)) {\\n            if(dataSize < 2)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 2, dataSize -= 2;\\n        } else if(CHECK_MASK(data[0], UPPER_4BITS, UTF8_3BYTE_MASK)) {\\n            if(dataSize < 3)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[2], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 3, dataSize -= 3;\\n        } else if(CHECK_MASK(data[0], UPPER_5BITS, UTF8_4BYTE_MASK)) {\\n            if(dataSize < 4)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[2], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[3], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 4, dataSize -= 4;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define UPPER_1BIT  0x80\\n#define UPPER_2BITS 0xC0\\n#define UPPER_3BITS 0xE0\\n#define UPPER_4BITS 0xF0\\n#define UPPER_5BITS 0xF8\\n\\n#define UTF8_1BYTE_MASK         0x00\\n#define UTF8_2BYTE_MASK         0xC0\\n#define UTF8_3BYTE_MASK         0xE0\\n#define UTF8_4BYTE_MASK         0xF0\\n#define UTF8_CONTINUATION_MASK  0x80\\n\\n#define CHECK_MASK(val, bitmask, target) (((val) & (bitmask)) == (target))\\n\\n\\nbool validUtf8(int* data, int dataSize)\\n{\\n    while(dataSize > 0) {\\n        if(CHECK_MASK(data[0], UPPER_1BIT, UTF8_1BYTE_MASK)) {\\n            data++, dataSize--;\\n        } else if(CHECK_MASK(data[0], UPPER_3BITS, UTF8_2BYTE_MASK)) {\\n            if(dataSize < 2)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 2, dataSize -= 2;\\n        } else if(CHECK_MASK(data[0], UPPER_4BITS, UTF8_3BYTE_MASK)) {\\n            if(dataSize < 3)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[2], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 3, dataSize -= 3;\\n        } else if(CHECK_MASK(data[0], UPPER_5BITS, UTF8_4BYTE_MASK)) {\\n            if(dataSize < 4)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[2], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[3], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 4, dataSize -= 4;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569684,
                "title": "easy-explained-for-beginners-binary-conversion-java",
                "content": "class Solution {\\n\\n    public boolean validUtf8(int[] data) {\\n        int type=0,i=0;         \\n        boolean isValid = false;\\n        \\n        while(i<data.length){                                   //traverse whole given data array        \\n            if(!isValid){\\n                String s = convertToBinary(data[i]);            //function call for conversion\\n                if(s.charAt(0) == \\'0\\')                          //if OCTET seq. begin with \\'0\\' then it is type 1 (given)\\n                    type = 1;\\n                else if(s.substring(0,5).equals(\"11110\"))       //similarly check for all other types (type 4)\\n                    type = 4;\\n                else if(s.substring(0,4).equals(\"1110\"))        //Type 3\\n                    type = 3;\\n                else if(s.substring(0,3).equals(\"110\"))         //Type 2         \\n                    type = 2;\\n                else\\n                    return false;                               //if other then given respective types, return false\\n                \\n                isValid = true;                                 //if false does not return, it means beginning isValid\\n                i++;\\n                type--;\\n            }\\n            else{\\n                while(type>0){                                \\n                    String s = convertToBinary(data[i]).substring(0,2);         //check for rest of the sequence\\n                    if(!s.equals(\"10\"))                                         //if not equals to \"10\" (as given in Question)\\n                        return false;                                           //return false\\n                    \\n                    type--;\\n                    i++;\\n                }\\n                isValid = false;\\n            }\\n        }\\n        \\n        if(type != 0)               //if type is not zero, all sequence are not according to the rule & loop is not run till end.\\n            return false;           \\n        \\n        return true;            \\n    }\\n    \\n    public String convertToBinary(int x)                    //Here, we convert an int into a binary string\\n    {\\n        final char[] binary = new char[8];                  //Given OCTECT Sequence that\\'s why size = 8\\n        for (int i = 7; i >= 0 ; i--){\\n            int mask = 1 << i;\\n            binary[7 - i] = (x & mask) != 0 ? \\'1\\' : \\'0\\';\\n        }\\n \\n        return new String(binary);\\n    }\\n}\\n\\n**Feel Free to ask any doubt...!**\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean validUtf8(int[] data) {\\n        int type=0,i=0;         \\n        boolean isValid = false;\\n        \\n        while(i<data.length){                                   //traverse whole given data array        \\n            if(!isValid){\\n                String s = convertToBinary(data[i]);            //function call for conversion\\n                if(s.charAt(0) == \\'0\\')                          //if OCTET seq. begin with \\'0\\' then it is type 1 (given)\\n                    type = 1;\\n                else if(s.substring(0,5).equals(\"11110\"))       //similarly check for all other types (type 4)\\n                    type = 4;\\n                else if(s.substring(0,4).equals(\"1110\"))        //Type 3\\n                    type = 3;\\n                else if(s.substring(0,3).equals(\"110\"))         //Type 2         \\n                    type = 2;\\n                else\\n                    return false;                               //if other then given respective types, return false\\n                \\n                isValid = true;                                 //if false does not return, it means beginning isValid\\n                i++;\\n                type--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2569568,
                "title": "c-solution-time-o-n-memory-o-1-easy-to-understand-bit-manipulation",
                "content": "```C#\\npublic class Solution {\\n    public bool ValidUtf8(int[] data) {\\n        int remainingBytes = 0;\\n        for (int i = 0; i < data.Length; i++) {            \\n            int ones = 0;\\n            for (int j = 7; j >= 0; j--) {\\n                if ((data[i] & (1 << j)) == 0) break;\\n                ones++;\\n            }\\n            \\n            if (remainingBytes > 0) {\\n                if (ones != 1) return false;\\n            } else if (ones != 0) {\\n                if (ones == 1 || ones > 4) return false;\\n                remainingBytes = ones;\\n            }\\n            \\n            if (remainingBytes > 0) remainingBytes--;\\n        }\\n        \\n        return remainingBytes == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```C#\\npublic class Solution {\\n    public bool ValidUtf8(int[] data) {\\n        int remainingBytes = 0;\\n        for (int i = 0; i < data.Length; i++) {            \\n            int ones = 0;\\n            for (int j = 7; j >= 0; j--) {\\n                if ((data[i] & (1 << j)) == 0) break;\\n                ones++;\\n            }\\n            \\n            if (remainingBytes > 0) {\\n                if (ones != 1) return false;\\n            } else if (ones != 0) {\\n                if (ones == 1 || ones > 4) return false;\\n                remainingBytes = ones;\\n            }\\n            \\n            if (remainingBytes > 0) remainingBytes--;\\n        }\\n        \\n        return remainingBytes == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569556,
                "title": "c-c-intuitive-implmentation",
                "content": "```c++\\n// the limit given by the problem description\\nconst int MAX_BYTES_UTF8_CHARACTER = 4;\\n\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int> &data) {\\n        const int n = data.size();\\n        \\n        int i = 0;\\n        while (i < n) {\\n            // gets the utf-8 header\\n            // clz: count leading zeros, using as count leading ones with bitwise negate\\n            int header = __builtin_clz(~(data[i] << 24));\\n            // continuation header should not appear here\\n            if (header == 1)\\n                return false;\\n            \\n            // make header 0 (ascii characters) to be 1 byte\\n            int bytes = std::max(1, header);\\n            if (bytes > MAX_BYTES_UTF8_CHARACTER || i + bytes > n)\\n                return false;\\n            \\n            // ensure there are (bytes - 1) continuation bytes\\n            for (int j = 1; j < bytes; ++j)\\n                if ((data[i + j] >> 6) != 0b10)\\n                    return false;\\n            \\n            i += bytes;\\n        }\\n        return i == n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n// the limit given by the problem description\\nconst int MAX_BYTES_UTF8_CHARACTER = 4;\\n\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int> &data) {\\n        const int n = data.size();\\n        \\n        int i = 0;\\n        while (i < n) {\\n            // gets the utf-8 header\\n            // clz: count leading zeros, using as count leading ones with bitwise negate\\n            int header = __builtin_clz(~(data[i] << 24));\\n            // continuation header should not appear here\\n            if (header == 1)\\n                return false;\\n            \\n            // make header 0 (ascii characters) to be 1 byte\\n            int bytes = std::max(1, header);\\n            if (bytes > MAX_BYTES_UTF8_CHARACTER || i + bytes > n)\\n                return false;\\n            \\n            // ensure there are (bytes - 1) continuation bytes\\n            for (int j = 1; j < bytes; ++j)\\n                if ((data[i + j] >> 6) != 0b10)\\n                    return false;\\n            \\n            i += bytes;\\n        }\\n        return i == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569417,
                "title": "easiest-solution-without-bit-manipulation-intuition-explained-java",
                "content": "If we find binary of the decimals from 0-255 we will observe that **first MSB bits** will be **1** for **some range of values**-\\n0-127 - **0 bits**\\n127-191 -**1 bit** \\n192-223- **2 bits**\\n224-239- **3 bits**\\n240-247- **4 bits** \\n\\nAs we require till first 4 bits as 1, **any number greater than 247 will be invalid**.\\nNow if we observe, if the **starting of any utf-8 has single 1 then it is invalid i.e between 128-191**.\\n\\nSo, for 4 cases-\\n**Case 1 - 1 Byte:**\\nIf the number is **between 0-127** then it has **first bit as 0** and it is valid.\\n\\n**Case 2 - 2 Byte:**\\nIf the number is between **192-223 then it has first 2 bits as 1**. Now we need to check if *next number exists and should have 10 as MSB*. That means the next number should be between **128- 191**. If not then it is invalid string.\\n\\n**Case 3 - 3 Byte:**\\nIf the number is between **223-239 then it has first 3 bits as 1**. Now we need to check if next *2 numbers exist and  should have 10 as MSB*. That means they should be between **128-191**.\\n\\n**Case 4- 4 Byte:**\\nIf the number is between **240-247 then it has first 4 bits as 1**. Now we need to check if next *3 numbers exist and  should have 10 as MSB*. That means they should be between **128-191**.\\n\\nIf any of the case becomes false then it is not invalid otherwise it is valid UTF-8\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int i=0;\\n        while(i < data.length)\\n        {\\n            int cnt = 0;\\n            if(data[i] >= 0 && data[i] <= 127)\\n                cnt = 1;\\n            else if(data[i] >= 192 && data[i] <= 223)\\n                cnt = 2;\\n            else if(data[i] >= 223 && data[i] <= 239)\\n                cnt = 3;\\n            else if(data[i] >= 240 && data[i] <= 247)\\n                cnt = 4;\\n            else\\n                cnt = 5;\\n            if(cnt == 5) return false;\\n            if(data.length - i < cnt - 1) return false;\\n            i++;\\n            while(i < data.length && cnt - 1 > 0)\\n            {\\n                if(data[i] <= 127 || data[i] >= 192)\\n                    return false;\\n                cnt--;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int i=0;\\n        while(i < data.length)\\n        {\\n            int cnt = 0;\\n            if(data[i] >= 0 && data[i] <= 127)\\n                cnt = 1;\\n            else if(data[i] >= 192 && data[i] <= 223)\\n                cnt = 2;\\n            else if(data[i] >= 223 && data[i] <= 239)\\n                cnt = 3;\\n            else if(data[i] >= 240 && data[i] <= 247)\\n                cnt = 4;\\n            else\\n                cnt = 5;\\n            if(cnt == 5) return false;\\n            if(data.length - i < cnt - 1) return false;\\n            i++;\\n            while(i < data.length && cnt - 1 > 0)\\n            {\\n                if(data[i] <= 127 || data[i] >= 192)\\n                    return false;\\n                cnt--;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569361,
                "title": "easy-sol-using-simple-math",
                "content": "bool validUtf8(vector<int>& data) {\\n        \\n        int n=data.size();\\n        int flag=0;\\n        for(int i=0;i<n;i++)\\n        { \\n            if(flag)\\n            { \\n                if(data[i]>=128 and data[i]<=191)\\n                {\\n                    flag--;\\n                    continue;\\n                }\\n                return false;\\n            }\\n            else if(data[i]<=127)\\n            {\\n                continue;\\n            }\\n            else if(data[i]>=192 and data[i]<=223)\\n            {\\n                flag=1;\\n            }\\n            else if(data[i]>=224 and data[i]<=239)\\n            {\\n                flag=2;\\n            }\\n             else if(data[i]>=240 and data[i]<=247)\\n            {\\n                flag=3;\\n            }\\n            else\\n            {\\n            return false;\\n            }\\n        }\\n        if(flag){return false;}\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "bool validUtf8(vector<int>& data) {\\n        \\n        int n=data.size();\\n        int flag=0;\\n        for(int i=0;i<n;i++)\\n        { \\n            if(flag)\\n            { \\n                if(data[i]>=128 and data[i]<=191)\\n                {\\n                    flag--;\\n                    continue;\\n                }\\n                return false;\\n            }\\n            else if(data[i]<=127)\\n            {\\n                continue;\\n            }\\n            else if(data[i]>=192 and data[i]<=223)\\n            {\\n                flag=1;\\n            }\\n            else if(data[i]>=224 and data[i]<=239)\\n            {\\n                flag=2;\\n            }\\n             else if(data[i]>=240 and data[i]<=247)\\n            {\\n                flag=3;\\n            }\\n            else\\n            {\\n            return false;\\n            }\\n        }\\n        if(flag){return false;}\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2569330,
                "title": "c-easy-to-understand-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string toBinary(int& num){\\n        string s = \"\";\\n        while(num){\\n            s += to_string(num%2);\\n            num /= 2;\\n        }\\n        while(s.size()<8){\\n            s.push_back(\\'0\\');\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        vector<string> bin;\\n        for(auto it : data){\\n            bin.push_back(toBinary(it));\\n        }\\n        bool flag = true;\\n        for(int i = 0;i<bin.size();){\\n            if(bin[i].substr(0,3)==\"110\" && i+1<bin.size() && bin[i+1].substr(0,2)==\"10\"){\\n                i += 2;\\n            }\\n            else if(bin[i].substr(0,4)==\"1110\" && i+2<bin.size() && bin[i+1].substr(0,2)==\"10\" && bin[i+2].substr(0,2)==\"10\"){\\n                i += 3;\\n            }\\n            else if(bin[i].substr(0,5)==\"11110\" && i+3<bin.size() && bin[i+1].substr(0,2)==\"10\" && bin[i+2].substr(0,2)==\"10\" && bin[i+3].substr(0,2)==\"10\"){\\n                i += 4;\\n            }\\n            else if(bin[i][0]==\\'0\\'){\\n                i++;\\n            }\\n            else{\\n                flag = false;\\n                break;\\n            }\\n        }        \\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string toBinary(int& num){\\n        string s = \"\";\\n        while(num){\\n            s += to_string(num%2);\\n            num /= 2;\\n        }\\n        while(s.size()<8){\\n            s.push_back(\\'0\\');\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        vector<string> bin;\\n        for(auto it : data){\\n            bin.push_back(toBinary(it));\\n        }\\n        bool flag = true;\\n        for(int i = 0;i<bin.size();){\\n            if(bin[i].substr(0,3)==\"110\" && i+1<bin.size() && bin[i+1].substr(0,2)==\"10\"){\\n                i += 2;\\n            }\\n            else if(bin[i].substr(0,4)==\"1110\" && i+2<bin.size() && bin[i+1].substr(0,2)==\"10\" && bin[i+2].substr(0,2)==\"10\"){\\n                i += 3;\\n            }\\n            else if(bin[i].substr(0,5)==\"11110\" && i+3<bin.size() && bin[i+1].substr(0,2)==\"10\" && bin[i+2].substr(0,2)==\"10\" && bin[i+3].substr(0,2)==\"10\"){\\n                i += 4;\\n            }\\n            else if(bin[i][0]==\\'0\\'){\\n                i++;\\n            }\\n            else{\\n                flag = false;\\n                break;\\n            }\\n        }        \\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569325,
                "title": "100-faster-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int start = 0;\\n        int hold = 0;\\n        int len = data.length;\\n        while(start<len){\\n            hold = 0;\\n            int curr = data[start];\\n            while((curr & 128)>0){\\n                hold++;\\n                curr = curr<<1;\\n            }\\n            start++;\\n            hold--;\\n            if(hold==0 || hold>3) return false;\\n            while(hold>0 && start<len){\\n                int temp = data[start];\\n                if((temp&128)==0) return false;\\n                temp = temp<<1;\\n                if((temp&128)>0) return false;\\n                hold--;\\n                start++;\\n            }\\n        }\\n        return hold<=0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int start = 0;\\n        int hold = 0;\\n        int len = data.length;\\n        while(start<len){\\n            hold = 0;\\n            int curr = data[start];\\n            while((curr & 128)>0){\\n                hold++;\\n                curr = curr<<1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2569292,
                "title": "simple-and-readable-solution-c-bitset-and-switch-case",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int getNumberOfBytes(int num) {\\n        bitset<8> b(num);\\n        //cout<<b<<endl;\\n        int count=0;\\n        for(int i=7;i>=0; i--) {\\n            if(b[i] == 0) break;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    bool validMSB(int start, int end, vector<int>& data) {\\n        // all bytes shuld have MBS 10\\n        //cout<<start<<\" \"<<end<<endl;\\n        if(end >= data.size()) return false;\\n        for(int i=start; i<=end; i++) {\\n            bitset<8> b(data[i]);\\n            if(b[7]==1 && b[6]==0)\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int nBytes;\\n        for(int i=0; i<data.size(); i++) {\\n            //cout<<i<<endl;\\n            nBytes = getNumberOfBytes(data[i]);\\n            \\n            switch(nBytes) {\\n                case 1: return false;\\n                case 5: return false;\\n                case 6: return false;\\n                case 7: return false;\\n                case 8: return false;\\n                case 0: continue;\\n                default: \\n                    if(validMSB(i+1, i+nBytes-1, data )) {\\n                        i = i+nBytes-1;\\n                        continue;\\n                    } else {\\n                        return false;\\n                    }           \\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int getNumberOfBytes(int num) {\\n        bitset<8> b(num);\\n        //cout<<b<<endl;\\n        int count=0;\\n        for(int i=7;i>=0; i--) {\\n            if(b[i] == 0) break;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    bool validMSB(int start, int end, vector<int>& data) {\\n        // all bytes shuld have MBS 10\\n        //cout<<start<<\" \"<<end<<endl;\\n        if(end >= data.size()) return false;\\n        for(int i=start; i<=end; i++) {\\n            bitset<8> b(data[i]);\\n            if(b[7]==1 && b[6]==0)\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int nBytes;\\n        for(int i=0; i<data.size(); i++) {\\n            //cout<<i<<endl;\\n            nBytes = getNumberOfBytes(data[i]);\\n            \\n            switch(nBytes) {\\n                case 1: return false;\\n                case 5: return false;\\n                case 6: return false;\\n                case 7: return false;\\n                case 8: return false;\\n                case 0: continue;\\n                default: \\n                    if(validMSB(i+1, i+nBytes-1, data )) {\\n                        i = i+nBytes-1;\\n                        continue;\\n                    } else {\\n                        return false;\\n                    }           \\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2569290,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isoneB(int val){\\n        int res = val & 128;\\n        \\n        if(res != 128)\\n            return true;\\n        return false;\\n    }\\n    \\n    \\n    bool istwoB(int val){\\n        int res = val & 192;\\n        if(res == 192 && val < 224)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool isthreeB(int val){\\n        int res = val & 224;\\n        \\n        if(res == 224 && val < 240)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool isfourB(int val){\\n        int res = val & 240;\\n        \\n        if(res == 240 && val < 248)\\n            return true;\\n        return false;\\n    }\\n    \\n    int findByte(int val){\\n        if(isoneB(val))\\n            return 1;\\n        if(istwoB(val))\\n            return 2;\\n        if(isthreeB(val))\\n            return 3;\\n        if(isfourB(val))\\n            return 4;\\n        return -1;   \\n    }\\n    \\n    bool tensig(int val){\\n        int res = val & 128;\\n        if(res == 128 && val < 192)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            int b = findByte(data[i]); // Finding whether the number is 1/2/3/4 byte\\n            \\n            if(b == -1) // If it is not in 1 to 4 bytes\\n                return false;\\n            \\n            int j;  // Checking whether b-1 bytes are having 10 as significant bits\\n            for(j=i+1; j<n && j<i+b; j++){\\n                if(tensig(data[j]))\\n                    continue;\\n                return false;\\n            }\\n            \\n            if(j != i+b)    // If we failed to check some bytes of b-1 bytes\\n                return false;\\n            \\n            i = j-1; // Going for next sequence\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isoneB(int val){\\n        int res = val & 128;\\n        \\n        if(res != 128)\\n            return true;\\n        return false;\\n    }\\n    \\n    \\n    bool istwoB(int val){\\n        int res = val & 192;\\n        if(res == 192 && val < 224)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool isthreeB(int val){\\n        int res = val & 224;\\n        \\n        if(res == 224 && val < 240)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool isfourB(int val){\\n        int res = val & 240;\\n        \\n        if(res == 240 && val < 248)\\n            return true;\\n        return false;\\n    }\\n    \\n    int findByte(int val){\\n        if(isoneB(val))\\n            return 1;\\n        if(istwoB(val))\\n            return 2;\\n        if(isthreeB(val))\\n            return 3;\\n        if(isfourB(val))\\n            return 4;\\n        return -1;   \\n    }\\n    \\n    bool tensig(int val){\\n        int res = val & 128;\\n        if(res == 128 && val < 192)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            int b = findByte(data[i]); // Finding whether the number is 1/2/3/4 byte\\n            \\n            if(b == -1) // If it is not in 1 to 4 bytes\\n                return false;\\n            \\n            int j;  // Checking whether b-1 bytes are having 10 as significant bits\\n            for(j=i+1; j<n && j<i+b; j++){\\n                if(tensig(data[j]))\\n                    continue;\\n                return false;\\n            }\\n            \\n            if(j != i+b)    // If we failed to check some bytes of b-1 bytes\\n                return false;\\n            \\n            i = j-1; // Going for next sequence\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569190,
                "title": "c-easy-to-understand-with-explaination-straight-and-forward-solution",
                "content": "**If you really found my solution helpful please upvote it\\nClick this same icon \\u25B2 on left side pannel of display to upvote**\\n\\n* Convert  decimal to binary\\n* check if start index i=0 in string of binary is 0 so continue\\n* else if front index 1 check count of continous 1 in string \\n* if count is 1 then check next 1 string if it starting id \"10\" so continue else \"false\"\\n* if count is 2 then check same process for next 2 and so on...\\n* other wise return true.\\n\\n```\\nclass Solution\\n{\\n    public: \\n\\t\\n\\t// Converting deci to binary and store in vector;\\n\\t\\n        string decToBinary(int n)\\n        {\\n            string s;\\n            for (int i = 7; i >= 0; i--)\\n            {\\n                int k = n >> i;\\n                if (k & 1)\\n                    s += \"1\";\\n                else\\n                    s += \"0\";\\n            }\\n            return s;\\n        }\\n\\n    bool validUtf8(vector<int> &data)\\n    {\\n        vector<string> vs;\\n        for (int i = 0; i < data.size(); i++)\\n        {\\n            string str = decToBinary(data[i]);\\n            vs.push_back(str);\\n           \\t// cout<<str<<\" \";\\n        }\\n        for (int i = 0; i < vs.size(); i++)       //iterate in vector and check the given condition\\n        {\\n            string s = vs[i];\\n            cout << s << \"\\\\n\";\\n            int cnt = 0;\\n            if (s[0] == \\'0\\')\\n            {\\n                continue;            // if start index 0 is 0 , so continue.\\n            }\\n            for (int j = 1; j < s.size(); j++)\\n            {\\n                if (s[j] == \\'1\\')\\n                {\\n                    cnt++;      // counting 1 \\n                    if (cnt >= 4)\\n                    {\\n                        return false; \\n                    }\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            if (cnt > 0)   //if count is greater the 1 then check next count elements in vecotor otherwise false\\n            {\\n                int j = i + 1;\\n                if (j > vs.size() - 1)        // if element is not present so return false;\\n                {\\n                    return false;\\n                }\\n                while (cnt > 0)\\n                {\\n                    string str1 = vs[j];\\n                    if (str1[0] == \\'0\\' || str1[1] == \\'1\\')\\n                    {\\n                        return false;\\n                    }\\n                    cout << str1 << \" \";\\n                    j++;\\n                    cnt--;\\n                }\\n                cout << \"\\\\n\";\\n                i = j - 1;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public: \\n\\t\\n\\t// Converting deci to binary and store in vector;\\n\\t\\n        string decToBinary(int n)\\n        {\\n            string s;\\n            for (int i = 7; i >= 0; i--)\\n            {\\n                int k = n >> i;\\n                if (k & 1)\\n                    s += \"1\";\\n                else\\n                    s += \"0\";\\n            }\\n            return s;\\n        }\\n\\n    bool validUtf8(vector<int> &data)\\n    {\\n        vector<string> vs;\\n        for (int i = 0; i < data.size(); i++)\\n        {\\n            string str = decToBinary(data[i]);\\n            vs.push_back(str);\\n           \\t// cout<<str<<\" \";\\n        }\\n        for (int i = 0; i < vs.size(); i++)       //iterate in vector and check the given condition\\n        {\\n            string s = vs[i];\\n            cout << s << \"\\\\n\";\\n            int cnt = 0;\\n            if (s[0] == \\'0\\')\\n            {\\n                continue;            // if start index 0 is 0 , so continue.\\n            }\\n            for (int j = 1; j < s.size(); j++)\\n            {\\n                if (s[j] == \\'1\\')\\n                {\\n                    cnt++;      // counting 1 \\n                    if (cnt >= 4)\\n                    {\\n                        return false; \\n                    }\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            if (cnt > 0)   //if count is greater the 1 then check next count elements in vecotor otherwise false\\n            {\\n                int j = i + 1;\\n                if (j > vs.size() - 1)        // if element is not present so return false;\\n                {\\n                    return false;\\n                }\\n                while (cnt > 0)\\n                {\\n                    string str1 = vs[j];\\n                    if (str1[0] == \\'0\\' || str1[1] == \\'1\\')\\n                    {\\n                        return false;\\n                    }\\n                    cout << str1 << \" \";\\n                    j++;\\n                    cnt--;\\n                }\\n                cout << \"\\\\n\";\\n                i = j - 1;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2569098,
                "title": "c-easy-solution-clean-code",
                "content": "**Please UpVote if it helps you**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring dTB(int n)\\n\\t\\t{\\n\\t\\t\\t// decimal to binary\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor (int i = 7; i >= 0; i--) {\\n\\t\\t\\t\\tint k = n >> i;\\n\\t\\t\\t\\tif (k & 1)\\n\\t\\t\\t\\t\\ts += \\'1\\';\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t   s += \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t\\tbool validUtf8(vector<int>& data) {\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(i<data.size()){\\n\\t\\t\\t\\tstring s = dTB(data[i]);\\n\\t\\t\\t\\tint t=0;\\n\\t\\t\\t\\tfor(auto x:s){\\n\\t\\t\\t\\t\\tif(x==\\'1\\')t+=1;\\n\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(t==1 || t>=5)return 0;\\n\\t\\t\\t\\tif(t==0){\\n\\t\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tt-=1;\\n\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\twhile(i<data.size() && t--){\\n\\t\\t\\t\\t\\ts = dTB(data[i]);\\n\\t\\t\\t\\t\\tif(s.substr(0,2)!=\"10\")return 0;\\n\\t\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(t>0)return 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring dTB(int n)\\n\\t\\t{\\n\\t\\t\\t// decimal to binary\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor (int i = 7; i >= 0; i--) {\\n\\t\\t\\t\\tint k = n >> i;\\n\\t\\t\\t\\tif (k & 1)\\n\\t\\t\\t\\t\\ts += \\'1\\';\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t   s += \\'0\\';\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2569083,
                "title": "c-code-duplication-but-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string to_string(int num){\\n        string res;\\n        \\n        for(int i = 7 ; i >= 0 ; i--){\\n            char c = ((num>>i)&1) + \\'0\\';\\n            res.push_back(c);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        int i = 0;\\n        \\n        while(i < n){\\n            string num = to_string(data[i]);\\n            \\n            int cnt = 0, j = 0;\\n            \\n            while(j < num.length() && num[j] == \\'1\\'){\\n                cnt++;\\n                j++;\\n            }\\n            if(cnt > 4 || cnt == 1) return false;\\n            \\n            if(cnt == 0){\\n                i++;\\n                continue;\\n            }\\n            \\n            if(cnt == 2){\\n                if(i+1 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 2;\\n                continue;\\n            }\\n            \\n            if(cnt == 3){\\n                if(i+1 == n || i+2 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+2]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 3;\\n                continue;\\n            }\\n            \\n            if(cnt == 4){\\n                if(i+1 == n || i+2 == n || i+3 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+2]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+3]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 4;\\n                continue;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string to_string(int num){\\n        string res;\\n        \\n        for(int i = 7 ; i >= 0 ; i--){\\n            char c = ((num>>i)&1) + \\'0\\';\\n            res.push_back(c);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        int i = 0;\\n        \\n        while(i < n){\\n            string num = to_string(data[i]);\\n            \\n            int cnt = 0, j = 0;\\n            \\n            while(j < num.length() && num[j] == \\'1\\'){\\n                cnt++;\\n                j++;\\n            }\\n            if(cnt > 4 || cnt == 1) return false;\\n            \\n            if(cnt == 0){\\n                i++;\\n                continue;\\n            }\\n            \\n            if(cnt == 2){\\n                if(i+1 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 2;\\n                continue;\\n            }\\n            \\n            if(cnt == 3){\\n                if(i+1 == n || i+2 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+2]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 3;\\n                continue;\\n            }\\n            \\n            if(cnt == 4){\\n                if(i+1 == n || i+2 == n || i+3 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+2]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+3]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 4;\\n                continue;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568974,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        unicode=[]\\n        for i in range(len(data)):\\n            x=bin(data[i]).replace(\"0b\", \"\")\\n            if len(x)<8:\\n                x=\\'0\\'*(8-len(x))+x\\n            unicode.append(x)\\n        curr=None\\n        cont=0\\n        for i in range(len(unicode)):\\n            if cont>0:\\n                if unicode[i][:2]!=\\'10\\':\\n                    return False\\n                cont-=1\\n            elif cont==0 and unicode[i][:2]==\\'10\\':\\n                return False\\n            else:\\n                for j in range(5):\\n                    if unicode[i][j]==\\'0\\':\\n                        if j==0:\\n                            curr=1\\n                        else:\\n                            curr=j\\n                            cont=j-1\\n                        break\\n                else:\\n                    print(\"ok2\")\\n                    return False\\n        if cont>0:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        unicode=[]\\n        for i in range(len(data)):\\n            x=bin(data[i]).replace(\"0b\", \"\")\\n            if len(x)<8:\\n                x=\\'0\\'*(8-len(x))+x\\n            unicode.append(x)\\n        curr=None\\n        cont=0\\n        for i in range(len(unicode)):\\n            if cont>0:\\n                if unicode[i][:2]!=\\'10\\':\\n                    return False\\n                cont-=1\\n            elif cont==0 and unicode[i][:2]==\\'10\\':\\n                return False\\n            else:\\n                for j in range(5):\\n                    if unicode[i][j]==\\'0\\':\\n                        if j==0:\\n                            curr=1\\n                        else:\\n                            curr=j\\n                            cont=j-1\\n                        break\\n                else:\\n                    print(\"ok2\")\\n                    return False\\n        if cont>0:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568939,
                "title": "c-straight-solution-beginner-friendly",
                "content": "# **If you really liked my solution then please upvote it as it motivates me to regularly post solution**\\n```\\nclass Solution {\\npublic:\\n    string binString(int val){\\n        string s=\"\";\\n        for(int i=0;i<8;i++)\\n        {\\n            s+=(\\'0\\'+val%2);\\n            val/=2;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int n=data.size();\\n        for(int i=0;i<n;i++){\\n            \\n            string s=binString(data[i]);\\n            cout<<s<<endl;\\n            if(s[0]==\\'0\\'){\\n                continue;\\n            }\\n            else{\\n                if(s[1]==\\'1\\'&&s[2]==\\'0\\'){\\n                    i++;\\n                    if(i>=n){\\n                        return false;\\n                    }\\n                    string t=binString(data[i]);\\n                    if(t[0]!=\\'1\\'&&t[1]!=\\'0\\'){\\n                        return false;\\n                    }\\n                }\\n                else if(s[1]==\\'1\\'&&s[2]==\\'1\\'&&s[3]==\\'0\\'){\\n                    for(int j=0;j<2;j++){\\n                        i++;\\n                        if(i>=n){\\n                            return false;\\n                        }\\n                        string t=binString(data[i]);\\n                        cout<<s<<endl;\\n                        if(t[0]!=\\'1\\'||t[1]!=\\'0\\'){\\n                            return false;\\n                        }\\n                    }\\n                }\\n                else if(s[1]==\\'1\\'&&s[2]==\\'1\\'&&s[3]==\\'1\\'&&s[4]==\\'0\\'){\\n                    for(int j=0;j<3;j++){\\n                        i++;\\n                        if(i>=n){\\n                            return false;\\n                        }\\n                        string t=binString(data[i]);\\n                        if(t[0]!=\\'1\\'||t[1]!=\\'0\\'){\\n                            return false;\\n                        }\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string binString(int val){\\n        string s=\"\";\\n        for(int i=0;i<8;i++)\\n        {\\n            s+=(\\'0\\'+val%2);\\n            val/=2;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int n=data.size();\\n        for(int i=0;i<n;i++){\\n            \\n            string s=binString(data[i]);\\n            cout<<s<<endl;\\n            if(s[0]==\\'0\\'){\\n                continue;\\n            }\\n            else{\\n                if(s[1]==\\'1\\'&&s[2]==\\'0\\'){\\n                    i++;\\n                    if(i>=n){\\n                        return false;\\n                    }\\n                    string t=binString(data[i]);\\n                    if(t[0]!=\\'1\\'&&t[1]!=\\'0\\'){\\n                        return false;\\n                    }\\n                }\\n                else if(s[1]==\\'1\\'&&s[2]==\\'1\\'&&s[3]==\\'0\\'){\\n                    for(int j=0;j<2;j++){\\n                        i++;\\n                        if(i>=n){\\n                            return false;\\n                        }\\n                        string t=binString(data[i]);\\n                        cout<<s<<endl;\\n                        if(t[0]!=\\'1\\'||t[1]!=\\'0\\'){\\n                            return false;\\n                        }\\n                    }\\n                }\\n                else if(s[1]==\\'1\\'&&s[2]==\\'1\\'&&s[3]==\\'1\\'&&s[4]==\\'0\\'){\\n                    for(int j=0;j<3;j++){\\n                        i++;\\n                        if(i>=n){\\n                            return false;\\n                        }\\n                        string t=binString(data[i]);\\n                        if(t[0]!=\\'1\\'||t[1]!=\\'0\\'){\\n                            return false;\\n                        }\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2568928,
                "title": "2-c-bit-manupulation-approach-dajulal",
                "content": "```\\n  bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        int remainingByte=0;\\n        for(int i=0;i<n;i++){\\n            if(remainingByte==0){\\n                if((data[i]>>7)==0b0){//1st Byte of 1 length char\\n                  continue;\\n                }\\n               else if((data[i]>>5)==0b110){//1st Byte of 2 length char\\n                    remainingByte=1;\\n               }\\n                else if((data[i]>>4)==0b1110){//1st Byte of 3 length char\\n                    remainingByte=2;\\n               }\\n               else if((data[i]>>3)==0b11110){//1st Byte of 4 length char\\n                    remainingByte=3;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }else{\\n                if((data[i]>>6)==0b10){\\n                    remainingByte--;\\n                }else{\\n                    return false;\\n                }\\n            }         \\n        }\\n        if(remainingByte==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n  bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        int remainingByte=0;\\n        for(int i=0;i<n;i++){\\n            if(remainingByte==0){\\n                if((data[i]>>7)==0b0){//1st Byte of 1 length char\\n                  continue;\\n                }\\n               else if((data[i]>>5)==0b110){//1st Byte of 2 length char\\n                    remainingByte=1;\\n               }\\n                else if((data[i]>>4)==0b1110){//1st Byte of 3 length char\\n                    remainingByte=2;\\n               }\\n               else if((data[i]>>3)==0b11110){//1st Byte of 4 length char\\n                    remainingByte=3;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }else{\\n                if((data[i]>>6)==0b10){\\n                    remainingByte--;\\n                }else{\\n                    return false;\\n                }\\n            }         \\n        }\\n        if(remainingByte==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568856,
                "title": "swift-one-liner-plus-easy-13-line-solution-beats-100-0",
                "content": "**One-Liner, DO NOT USE THIS APPROACH IN AN INTERVIEW! (accepted answer)**\\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        String(bytes: data.map { UInt8(exactly: $0)! }, encoding: .utf8) != nil\\n    }\\n}\\n```\\n\\n---\\n\\n**Fast Approach with Bitwise Analysis (accepted answer)**\\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var i = 0\\n        while i < data.count {\\n            let num = data[i]\\n            i += 1\\n            guard num & 0x80 != 0 else { continue }\\n            let charactersLeft = Int8(num ^ 0xff).leadingZeroBitCount - 1\\n            guard 1...3 ~= charactersLeft, data.count - charactersLeft >= i else { return false }\\n            for j in 0 ..< charactersLeft where data[i+j] & 0xc0 != 0x80 {\\n                return false \\n            }\\n            i += charactersLeft\\n        } \\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n**Fast Approach, but replacing `leadingZeroBitCount` with hand-coded loop (accepted answer)**\\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var i = 0\\n        while i < data.count {\\n            var num = data[i]\\n            i += 1\\n            guard num & 0x80 != 0 else { continue }\\n            var charactersLeft = -1 \\n            while num & 0x80 != 0 {\\n                guard num != 0 else { return false }\\n                charactersLeft += 1\\n                num <<= 1\\n            }\\n            guard 1...3 ~= charactersLeft, data.count - charactersLeft >= i else { return false }\\n            for j in 0 ..< charactersLeft where data[i+j] & 0xc0 != 0x80 {\\n                return false \\n            }\\n            i += charactersLeft\\n        } \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        String(bytes: data.map { UInt8(exactly: $0)! }, encoding: .utf8) != nil\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var i = 0\\n        while i < data.count {\\n            let num = data[i]\\n            i += 1\\n            guard num & 0x80 != 0 else { continue }\\n            let charactersLeft = Int8(num ^ 0xff).leadingZeroBitCount - 1\\n            guard 1...3 ~= charactersLeft, data.count - charactersLeft >= i else { return false }\\n            for j in 0 ..< charactersLeft where data[i+j] & 0xc0 != 0x80 {\\n                return false \\n            }\\n            i += charactersLeft\\n        } \\n        return true\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var i = 0\\n        while i < data.count {\\n            var num = data[i]\\n            i += 1\\n            guard num & 0x80 != 0 else { continue }\\n            var charactersLeft = -1 \\n            while num & 0x80 != 0 {\\n                guard num != 0 else { return false }\\n                charactersLeft += 1\\n                num <<= 1\\n            }\\n            guard 1...3 ~= charactersLeft, data.count - charactersLeft >= i else { return false }\\n            for j in 0 ..< charactersLeft where data[i+j] & 0xc0 != 0x80 {\\n                return false \\n            }\\n            i += charactersLeft\\n        } \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568843,
                "title": "bit-manipulation-o-n-java-1-ms-beat-100",
                "content": "```\\n    public boolean validUtf8(int[] data) {\\n        int[] pattern = new int[] {0x00, 0xc0, 0xe0, 0xf0};\\n        int[] maskFirst = new int[] {0x80, 0xe0, 0xf0, 0xf8};\\n        int maskFollow = 0xc0;\\n        int i = 0;\\n        while (i < data.length) {\\n            int match = -1;\\n            for (int j = 3; j >= 0; j--) {\\n                if ((data[i] & maskFirst[j]) == pattern[j]) {\\n                    match = j;\\n                    break;\\n                }\\n            }\\n            if (match == -1) return false;\\n            for (int j = i+1; j <= i+match; j++) {\\n                if (j >= data.length || (data[j] & maskFollow) != 0x80) {\\n                    return false;\\n                }\\n            }\\n            i += (match + 1);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public boolean validUtf8(int[] data) {\\n        int[] pattern = new int[] {0x00, 0xc0, 0xe0, 0xf0};\\n        int[] maskFirst = new int[] {0x80, 0xe0, 0xf0, 0xf8};\\n        int maskFollow = 0xc0;\\n        int i = 0;\\n        while (i < data.length) {\\n            int match = -1;\\n            for (int j = 3; j >= 0; j--) {\\n                if ((data[i] & maskFirst[j]) == pattern[j]) {\\n                    match = j;\\n                    break;\\n                }\\n            }\\n            if (match == -1) return false;\\n            for (int j = i+1; j <= i+match; j++) {\\n                if (j >= data.length || (data[j] & maskFollow) != 0x80) {\\n                    return false;\\n                }\\n            }\\n            i += (match + 1);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568817,
                "title": "python3-self-explanatory-example-string-manipulation",
                "content": "I hope the following code can help you understand the algorithm\\'s big picture.\\n\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:       \\n        # Runtime: 122 ms, faster than 89.33% of Python3 online submissions for UTF-8 Validation.\\n        # Memory Usage: 14.1 MB, less than 70.76% of Python3 online submissions for UTF-8 Validation.\\n        \\n        # Define helpers.\\n        def to_string(num):\\n            # Remove first 0b, then fill zeros if the number was small or it will cause false negative.\\n            return bin(num)[2:].zfill(8)\\n        \\n        def get_char_size(num):\\n            s = to_string(num)\\n            \\n            if s.startswith(\"0\"):\\n                return 1\\n            if s.startswith(\"110\"):\\n                return 2\\n            if s.startswith(\"1110\"):\\n                return 3\\n            if s.startswith(\"11110\"):\\n                return 4\\n            \\n            return None # This means Invalid Encoding.\\n\\n        def is_valid_second_or_lator(num):\\n            s = to_string(num)\\n            return s.startswith(\"10\")\\n        \\n        \\n        # Main\\n        remaining = 0 # Represents the number of remaining integer of the current character.\\n        for number in data:\\n            if remaining == 0: # Start a new character.\\n                remaining = get_char_size(number)\\n                if remaining is None:\\n                    return False\\n            else:\\n                if not is_valid_second_or_lator(number):\\n                    return False\\n            remaining -= 1\\n        \\n        # The final character\\'s end need to match the end of the whole data.\\n        return remaining == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:       \\n        # Runtime: 122 ms, faster than 89.33% of Python3 online submissions for UTF-8 Validation.\\n        # Memory Usage: 14.1 MB, less than 70.76% of Python3 online submissions for UTF-8 Validation.\\n        \\n        # Define helpers.\\n        def to_string(num):\\n            # Remove first 0b, then fill zeros if the number was small or it will cause false negative.\\n            return bin(num)[2:].zfill(8)\\n        \\n        def get_char_size(num):\\n            s = to_string(num)\\n            \\n            if s.startswith(\"0\"):\\n                return 1\\n            if s.startswith(\"110\"):\\n                return 2\\n            if s.startswith(\"1110\"):\\n                return 3\\n            if s.startswith(\"11110\"):\\n                return 4\\n            \\n            return None # This means Invalid Encoding.\\n\\n        def is_valid_second_or_lator(num):\\n            s = to_string(num)\\n            return s.startswith(\"10\")\\n        \\n        \\n        # Main\\n        remaining = 0 # Represents the number of remaining integer of the current character.\\n        for number in data:\\n            if remaining == 0: # Start a new character.\\n                remaining = get_char_size(number)\\n                if remaining is None:\\n                    return False\\n            else:\\n                if not is_valid_second_or_lator(number):\\n                    return False\\n            remaining -= 1\\n        \\n        # The final character\\'s end need to match the end of the whole data.\\n        return remaining == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568764,
                "title": "java-simple-bit-manipulation-and-masking",
                "content": "I am using masking and matching to check the prefixes. It is similar to how IP subnet masks work.\\n\\nFor the maks, we only set bit to 1 at positions that we want to track and leave the rest at 0. Then, we can match the resulting values with the prefix values. The prefix value is just the header bits with the rest bits filled with 0s.\\n\\nLet\\'s takes a look at 110xxxxx as an example.\\nWe only need to check the first three bits and ignore the others so the mask is 11100000 and the prefix value is 11000000.\\n\\nLet\\'s test 10100110, 11011110, and 11010101 with our mask and prefixes.\\nFirst, filter out all other bits with the mask and AND operator.\\n\\n10100110 & 11100000 = 10100000 <- Not equal to 11000000\\n11011110 & 11100000 = 11000000 <- Equal to 11000000\\n11010101 & 11100000 = 11000000 <- Equal to 11000000 \\n\\nAs you can see, the first test will return false since the headers do not match. In the latter two cases, the five least significant bits are removed by the mask so they both return the same prefix value.\\n\\nNow, I just expanded this to all the headers and tails with precomputed values.\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n\\t\\t// Create precomputed arrays with the mask and prefixes.\\n\\t\\t// Bitwise representation: [ [10000000,00000000],\\n\\t\\t//                           [11100000,11000000],\\n\\t\\t//                           [11110000,11100000],\\n\\t\\t//                           [11111000,11110000]]\\n        int[][] headers = new int[][]{{128,0},{224,192},{240,224},{248,240}};\\n\\t\\t\\n\\t\\t// Bitwise representation: [11000000,10000000]\\n        int[] tail = new int[]{192,128};\\n        \\n        for(int i = 0; i < data.length; ++i){\\n\\t\\t\\t// Find which header matches\\n            int num = -1;\\n            for(int j = 0; j < 4; ++j){\\n                if((data[i]&headers[j][0])==headers[j][1]){\\n                    num=j;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// No match or there isn\\'t enough data left\\n            if(num==-1 || i+num>=data.length)\\n                return false;\\n            \\n\\t\\t\\t// Check the remaining tail bytes\\n            for(int j = 0; j < num; ++j){\\n                if((data[++i]&tail[0])!=tail[1])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n\\t\\t// Create precomputed arrays with the mask and prefixes.\\n\\t\\t// Bitwise representation: [ [10000000,00000000],\\n\\t\\t//                           [11100000,11000000],\\n\\t\\t//                           [11110000,11100000],\\n\\t\\t//                           [11111000,11110000]]\\n        int[][] headers = new int[][]{{128,0},{224,192},{240,224},{248,240}};\\n\\t\\t\\n\\t\\t// Bitwise representation: [11000000,10000000]\\n        int[] tail = new int[]{192,128};\\n        \\n        for(int i = 0; i < data.length; ++i){\\n\\t\\t\\t// Find which header matches\\n            int num = -1;\\n            for(int j = 0; j < 4; ++j){\\n                if((data[i]&headers[j][0])==headers[j][1]){\\n                    num=j;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// No match or there isn\\'t enough data left\\n            if(num==-1 || i+num>=data.length)\\n                return false;\\n            \\n\\t\\t\\t// Check the remaining tail bytes\\n            for(int j = 0; j < num; ++j){\\n                if((data[++i]&tail[0])!=tail[1])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507306,
                "title": "java-easy-solution",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n        for(int i=0; i<data.length; i++){\\n            int numOfBytes = 0;\\n            int val = data[i];\\n            if(val >= 255 ) return false;  //if value is greator or equal to 255 \\n            else if((val & 128) == 0) numOfBytes=1; //starting with 0\\n            else if((val & 224) == 192) numOfBytes=2; //starting with 110\\n            else if((val & 240)== 224) numOfBytes=3; //starting with 1110\\n            else if((val & 248)==240) numOfBytes=4; //starting with 11110\\n            else return false;\\n            \\n\\t\\t\\t//this loop check 1110 ......, 10...., 10...,\\n            for(int j=1; j<numOfBytes; j++){\\n                if(j+i >= data.length) return false;\\n                else if((data[i+j] & 192)!= 128 ) return false;\\n            }\\n            \\n            i = i + numOfBytes-1; //we have changed the i so we have to update the i \\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n        for(int i=0; i<data.length; i++){\\n            int numOfBytes = 0;\\n            int val = data[i];\\n            if(val >= 255 ) return false;  //if value is greator or equal to 255 \\n            else if((val & 128) == 0) numOfBytes=1; //starting with 0\\n            else if((val & 224) == 192) numOfBytes=2; //starting with 110\\n            else if((val & 240)== 224) numOfBytes=3; //starting with 1110\\n            else if((val & 248)==240) numOfBytes=4; //starting with 11110\\n            else return false;\\n            \\n\\t\\t\\t//this loop check 1110 ......, 10...., 10...,\\n            for(int j=1; j<numOfBytes; j++){\\n                if(j+i >= data.length) return false;\\n                else if((data[i+j] & 192)!= 128 ) return false;\\n            }\\n            \\n            i = i + numOfBytes-1; //we have changed the i so we have to update the i \\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700528,
                "title": "c-8ms-93-easy-to-understand-bit-manipulation",
                "content": "\\nRuntime: 8 ms, faster than 92.78% of C++ online submissions for UTF-8 Validation.\\nMemory Usage: 13.9 MB, less than 75.28% of C++ online submissions for UTF-8 Validation.\\n```\\nclass Solution {\\npublic:\\n  bool validUtf8(vector<int>& data) {\\n    data.push_back(1); \\n    data.push_back(1); \\n    data.push_back(1);\\n    \\n    int mask1 = 0b10000000, \\n      mask2 = 0b11111,  val2 = 0b11011111, \\n      mask3 = 0b1111,   val3 = 0b11101111,  \\n      mask4 = 0b111,    val4 = 0b11110111, \\n      mask  = 0b111111, val  = 0b10111111;\\n    \\n    for(int id = 0; id != data.size(); id++)\\n      if( (data[id] & mask1) == 0);\\n      else\\n        if((data[id] | mask2) == val2){\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else if((data[id] | mask3) == val3){\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else if((data[id] | mask4) == val4){\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else return false;\\n      \\n    \\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool validUtf8(vector<int>& data) {\\n    data.push_back(1); \\n    data.push_back(1); \\n    data.push_back(1);\\n    \\n    int mask1 = 0b10000000, \\n      mask2 = 0b11111,  val2 = 0b11011111, \\n      mask3 = 0b1111,   val3 = 0b11101111,  \\n      mask4 = 0b111,    val4 = 0b11110111, \\n      mask  = 0b111111, val  = 0b10111111;\\n    \\n    for(int id = 0; id != data.size(); id++)\\n      if( (data[id] & mask1) == 0);\\n      else\\n        if((data[id] | mask2) == val2){\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else if((data[id] | mask3) == val3){\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else if((data[id] | mask4) == val4){\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else return false;\\n      \\n    \\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672809,
                "title": "python-masks-solution-using-hexadecimal",
                "content": "``` python\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        data.reverse()\\n        \\n        def check_n_byte_elem(data, n):\\n            if len(data) < n-1: return False\\n            bytes_to_check = [data.pop() for _ in range(n-1)]\\n            for elem in bytes_to_check:\\n                if not (elem & 0xC0) == 0x80:\\n                    return False\\n                \\n            return True\\n            \\n        while data:\\n            elem = data.pop()\\n            if (elem & 0xF8) == 0xF0:\\n                check = check_n_byte_elem(data, 4)\\n            elif (elem & 0xF0) == 0xE0:\\n                check = check_n_byte_elem(data, 3)\\n            elif (elem & 0xE0) == 0xC0:\\n                check = check_n_byte_elem(data, 2)\\n            elif (elem & 0x80) == 0x00:\\n                check = True\\n            else:\\n                check = False\\n            if not check: return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        data.reverse()\\n        \\n        def check_n_byte_elem(data, n):\\n            if len(data) < n-1: return False\\n            bytes_to_check = [data.pop() for _ in range(n-1)]\\n            for elem in bytes_to_check:\\n                if not (elem & 0xC0) == 0x80:\\n                    return False\\n                \\n            return True\\n            \\n        while data:\\n            elem = data.pop()\\n            if (elem & 0xF8) == 0xF0:\\n                check = check_n_byte_elem(data, 4)\\n            elif (elem & 0xF0) == 0xE0:\\n                check = check_n_byte_elem(data, 3)\\n            elif (elem & 0xE0) == 0xC0:\\n                check = check_n_byte_elem(data, 2)\\n            elif (elem & 0x80) == 0x00:\\n                check = True\\n            else:\\n                check = False\\n            if not check: return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490778,
                "title": "java-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes = 0;\\n        for(int i:data)\\n        {\\n            if(rbytes==0)\\n            {\\n                if(i>>7 == 0)\\n                    rbytes = 0;\\n                else if(i>>5 == 6)\\n                    rbytes = 1;\\n                else if(i>>4 == 14)\\n                    rbytes = 2;\\n                else if(i>>3 == 30)\\n                    rbytes = 3;\\n                else \\n                    return false;\\n            }\\n            else\\n            {\\n                if(i>>6 != 2)\\n                    return false;\\n                else\\n                {\\n                    rbytes--;\\n                }\\n            }\\n        }\\n        if(rbytes==0)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes = 0;\\n        for(int i:data)\\n        {\\n            if(rbytes==0)\\n            {\\n                if(i>>7 == 0)\\n                    rbytes = 0;\\n                else if(i>>5 == 6)\\n                    rbytes = 1;\\n                else if(i>>4 == 14)\\n                    rbytes = 2;\\n                else if(i>>3 == 30)\\n                    rbytes = 3;\\n                else \\n                    return false;\\n            }\\n            else\\n            {\\n                if(i>>6 != 2)\\n                    return false;\\n                else\\n                {\\n                    rbytes--;\\n                }\\n            }\\n        }\\n        if(rbytes==0)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301838,
                "title": "simple-readable-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean validUtf8(int[] data) {\\n\\t\\t\\tint remaining=0;\\n\\t\\t\\tfor(int i:data){\\n\\t\\t\\t\\tif(remaining==0){\\n\\t\\t\\t\\t\\tif(i>>7==0b0){\\n\\t\\t\\t\\t\\t\\tremaining = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(i>>5==0b110){\\n\\t\\t\\t\\t\\t\\tremaining = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(i>>4==0b1110){\\n\\t\\t\\t\\t\\t\\tremaining = 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(i>>3==0b11110){\\n\\t\\t\\t\\t\\t\\tremaining = 3;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(i>>6==0b10){\\n\\t\\t\\t\\t\\t\\tremaining--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn remaining==0?true:false;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean validUtf8(int[] data) {\\n\\t\\t\\tint remaining=0;\\n\\t\\t\\tfor(int i:data){\\n\\t\\t\\t\\tif(remaining==0){\\n\\t\\t\\t\\t\\tif(i>>7==0b0){\\n\\t\\t\\t\\t\\t\\tremaining = 0;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1237114,
                "title": "easy-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool bitcheck(vector<string> &bin, int &i){\\n        int byte=0;\\n        for(auto &c:bin[i]){\\n            if(c==\\'1\\')byte++;\\n            else break;\\n        }\\n        if(byte>4 || byte==1)return false;\\n        if(byte==0)return bin[i++][0]==\\'0\\';\\n        if(bin.size()-i<byte)return false;\\n        int j=i;\\n        i++;\\n        for(;i<=j+byte-1;i++){\\n            if(bin[i].substr(0,2)!=\"10\")return false;\\n        }\\n        return true;\\n        \\n    }\\n    string binary(int a){\\n        string s=\"\";\\n        while(a){\\n            s+=to_string(a%2);\\n            a/=2;\\n        }\\n        reverse(s.begin(),s.end());\\n        s=string(8-s.length(),\\'0\\')+s;\\n        return s;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        vector<string> bin;\\n        for(auto &i:data){\\n            bin.push_back(binary(i));\\n        }\\n        cout<<bin[0]<<\" \";\\n        int i=0;\\n        while(i<data.size()){\\n            if(!bitcheck(bin,i))return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bitcheck(vector<string> &bin, int &i){\\n        int byte=0;\\n        for(auto &c:bin[i]){\\n            if(c==\\'1\\')byte++;\\n            else break;\\n        }\\n        if(byte>4 || byte==1)return false;\\n        if(byte==0)return bin[i++][0]==\\'0\\';\\n        if(bin.size()-i<byte)return false;\\n        int j=i;\\n        i++;\\n        for(;i<=j+byte-1;i++){\\n            if(bin[i].substr(0,2)!=\"10\")return false;\\n        }\\n        return true;\\n        \\n    }\\n    string binary(int a){\\n        string s=\"\";\\n        while(a){\\n            s+=to_string(a%2);\\n            a/=2;\\n        }\\n        reverse(s.begin(),s.end());\\n        s=string(8-s.length(),\\'0\\')+s;\\n        return s;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        vector<string> bin;\\n        for(auto &i:data){\\n            bin.push_back(binary(i));\\n        }\\n        cout<<bin[0]<<\" \";\\n        int i=0;\\n        while(i<data.size()){\\n            if(!bitcheck(bin,i))return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1222380,
                "title": "c-c-lookup-table-faster-than-100",
                "content": "The last 8 values in the following lookup table correspond to these bytes:\\n\\n11000xxx - 1 continuation byte\\n11001xxx - 1 continuation byte\\n11010xxx - 1 continuation byte\\n11011xxx - 1 continuation byte\\n11100xxx - 2 continuation bytes\\n11101xxx - 2 continuation bytes\\n11110xxx - 3 continuation bytes\\n11111xxx - 0, not legal\\n\\nWith a simple right-shift of 3 we only need to test 32 combinations for a valid leading byte.\\n```\\nstatic int num_continuation_bytes[32] =\\n{\\n    0,0,0,0,0,0,0,0,\\n\\t0,0,0,0,0,0,0,0,\\n\\t0,0,0,0,0,0,0,0,\\n\\t1,1,1,1,2,2,3,0\\n};\\n\\nbool validUtf8(int* data, int size)\\n{\\n    while (size--)\\n    {\\n        int d = *data++;\\n        if (d < 0x80) continue;\\n\\n        int c = num_continuation_bytes[d >> 3];\\n        if (c < 1 || size < c) return false;\\n\\t\\t\\n        size -= c;\\n        while (c--)\\n        {\\n\\t\\t    d = *data++;\\n            if ((d & 0xC0) != 0x80) return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int num_continuation_bytes[32] =\\n{\\n    0,0,0,0,0,0,0,0,\\n\\t0,0,0,0,0,0,0,0,\\n\\t0,0,0,0,0,0,0,0,\\n\\t1,1,1,1,2,2,3,0\\n};\\n\\nbool validUtf8(int* data, int size)\\n{\\n    while (size--)\\n    {\\n        int d = *data++;\\n        if (d < 0x80) continue;\\n\\n        int c = num_continuation_bytes[d >> 3];\\n        if (c < 1 || size < c) return false;\\n\\t\\t\\n        size -= c;\\n        while (c--)\\n        {\\n\\t\\t    d = *data++;\\n            if ((d & 0xC0) != 0x80) return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110925,
                "title": "java-1ms-bit-manipulation",
                "content": "```\\nclass Solution {\\n    \\n    public boolean validUtf8(int[] data) {\\n        for (int i = 0; i < data.length;) {\\n            int b = data[i];\\n            \\n            int charLen;\\n            if ((b & 0x80) == 0) {\\n                charLen = 1;\\n            } else if ((b & 0xE0) == 0xC0) {\\n                charLen = 2;\\n            } else if ((b & 0xF0) == 0xE0) {\\n                charLen = 3;\\n            } else if ((b & 0xF8) == 0xF0) {\\n                charLen = 4;\\n            } else {\\n                return false;\\n            }\\n            \\n            int charEnd = i + charLen;\\n            if (charEnd > data.length) {\\n                return false;\\n            }\\n            for (int j = i+1; j < charEnd; ++j) {\\n                if ((data[j] & 0xC0) != 0x80) {\\n                    return false;\\n                }\\n            }\\n            i = charEnd;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean validUtf8(int[] data) {\\n        for (int i = 0; i < data.length;) {\\n            int b = data[i];\\n            \\n            int charLen;\\n            if ((b & 0x80) == 0) {\\n                charLen = 1;\\n            } else if ((b & 0xE0) == 0xC0) {\\n                charLen = 2;\\n            } else if ((b & 0xF0) == 0xE0) {\\n                charLen = 3;\\n            } else if ((b & 0xF8) == 0xF0) {\\n                charLen = 4;\\n            } else {\\n                return false;\\n            }\\n            \\n            int charEnd = i + charLen;\\n            if (charEnd > data.length) {\\n                return false;\\n            }\\n            for (int j = i+1; j < charEnd; ++j) {\\n                if ((data[j] & 0xC0) != 0x80) {\\n                    return false;\\n                }\\n            }\\n            i = charEnd;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039996,
                "title": "simple-solution-of-utf-8-validation-using-bit-manipulation-in-java-1ms-runtime",
                "content": "```\\npublic static boolean validUtf8(int[] data) {\\n        int bts=0;\\n        for (int val: data) {\\n            if(bts==0){\\n                if((val>>7)==0b0){\\n                    bts=0;\\n                }else if((val>>5)==0b110){\\n                    bts=1;\\n                }else if((val>>4)==0b1110){\\n                    bts=2;\\n                }else if((val>>3)==0b11110){\\n                    bts=3;\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                if((val>>6)==0b10){\\n                    bts--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(bts==0){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic static boolean validUtf8(int[] data) {\\n        int bts=0;\\n        for (int val: data) {\\n            if(bts==0){\\n                if((val>>7)==0b0){\\n                    bts=0;\\n                }else if((val>>5)==0b110){\\n                    bts=1;\\n                }else if((val>>4)==0b1110){\\n                    bts=2;\\n                }else if((val>>3)==0b11110){\\n                    bts=3;\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                if((val>>6)==0b10){\\n                    bts--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(bts==0){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865864,
                "title": "python-hella-comments-solution",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        \\n        # Convert to strings of bins\\n        data = [str(bin(x))[2:] for x in data]\\n                \\n        # Loop until we\\'ve popped all from data\\n        while True:\\n            \\n            # Get the prefix (tells us how many bytes we expect)\\n            try:\\n                prefix = data.pop(0)\\n            except:\\n                break\\n                \\n            # If less than eight, we don\\'t expect any more, we can get next prefix\\n            if len(prefix) < 8:\\n                continue\\n                \\n            # Otherwise read the number of 1\\'s on the prefix\\n            num_tens = len(prefix.split(\\'0\\')[0])-1\\n            \\n            # If greater than three, it\\'s an error\\n            if num_tens > 3:\\n                return False\\n            # If less than zero, it\\'s also an error\\n            elif num_tens < 0:                \\n                continue            \\n            # If zero exaclty, also an error\\n            elif num_tens == 0:\\n                return False\\n            # Else, num_tens tells us how many bytes we expect to read\\n            else:\\n                # We pop the num bytes we expect\\n                for _ in range(num_tens):\\n                    \\n                    # If we fail to pop, its invalid string\\n                    try:\\n                        char = data.pop(0)\\n                    except:\\n                        return False\\n                    \\n                    # Make sure its prefixed by 10 and at least eight char, else invalid\\n                    if char[:2] == \\'10\\' and len(char) == 8:\\n                        num_tens -= 1\\n                    else:\\n                        return False\\n                    \\n                # If we didn\\'t reach exactly num_tens bytes, it\\'s error\\n                if num_tens != 0:\\n                    return False\\n        \\n        # If we made it this far, its valid\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        \\n        # Convert to strings of bins\\n        data = [str(bin(x))[2:] for x in data]\\n                \\n        # Loop until we\\'ve popped all from data\\n        while True:\\n            \\n            # Get the prefix (tells us how many bytes we expect)\\n            try:\\n                prefix = data.pop(0)\\n            except:\\n                break\\n                \\n            # If less than eight, we don\\'t expect any more, we can get next prefix\\n            if len(prefix) < 8:\\n                continue\\n                \\n            # Otherwise read the number of 1\\'s on the prefix\\n            num_tens = len(prefix.split(\\'0\\')[0])-1\\n            \\n            # If greater than three, it\\'s an error\\n            if num_tens > 3:\\n                return False\\n            # If less than zero, it\\'s also an error\\n            elif num_tens < 0:                \\n                continue            \\n            # If zero exaclty, also an error\\n            elif num_tens == 0:\\n                return False\\n            # Else, num_tens tells us how many bytes we expect to read\\n            else:\\n                # We pop the num bytes we expect\\n                for _ in range(num_tens):\\n                    \\n                    # If we fail to pop, its invalid string\\n                    try:\\n                        char = data.pop(0)\\n                    except:\\n                        return False\\n                    \\n                    # Make sure its prefixed by 10 and at least eight char, else invalid\\n                    if char[:2] == \\'10\\' and len(char) == 8:\\n                        num_tens -= 1\\n                    else:\\n                        return False\\n                    \\n                # If we didn\\'t reach exactly num_tens bytes, it\\'s error\\n                if num_tens != 0:\\n                    return False\\n        \\n        # If we made it this far, its valid\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736306,
                "title": "java-solution-runtime-1-ms-faster-than-99-37-of-java-online-submissions",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean validUtf8(int[] arr) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\t\\tint val = arr[i];\\n\\t\\t\\t\\tif(count != 0){\\n\\t\\t\\t\\t\\tif((val >> 6) == 0b10){\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}   \\n\\n\\t\\t\\t\\t} else if(count == 0){ \\n\\t\\t\\t\\t\\tif((val >> 7) == 0b0){\\n\\t\\t\\t\\t\\t//1 byte...    \\n\\t\\t\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t\\t\\t}else if((val >> 5) == 0b110){\\n\\t\\t\\t\\t\\t//2 byte...\\n\\t\\t\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\t\\t}else if((val >> 4) == 0b1110){\\n\\t\\t\\t\\t\\t//3 byte...\\n\\t\\t\\t\\t\\t\\tcount = 2;\\n\\t\\t\\t\\t\\t}else if((val >> 3) == 0b11110){\\n\\t\\t\\t\\t\\t//4 byte...\\n\\t\\t\\t\\t\\t\\tcount =3;\\n\\t\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(count != 0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean validUtf8(int[] arr) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\t\\tint val = arr[i];\\n\\t\\t\\t\\tif(count != 0){\\n\\t\\t\\t\\t\\tif((val >> 6) == 0b10){\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 654771,
                "title": "python3-easy-to-understand-store-valid-sequences",
                "content": "For each starting point, try all possible 1 to 4 character sequences. If anyone matches, just update the starting point of your initial data. Also create a simple valid function for all possible 1 to 4 string sequences.\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        data = [(\"{0:b}\".format(a)).zfill(8) for a in data]\\n        valid_map = {\\n            1: [\"0\"],\\n            2: [\"110\", \"10\"],\\n            3: [\"1110\", \"10\", \"10\"],\\n            4: [\"11110\", \"10\", \"10\", \"10\"],\\n        }\\n        def valid(trunc_data):\\n            valid_list = valid_map[len(trunc_data)]\\n            for i, a in enumerate(valid_list):\\n                if not trunc_data[i].startswith(a):\\n                    return False\\n            return True\\n        i = 0\\n        while i < len(data):\\n            isValid = False\\n            for j in range(4):\\n                if valid(data[i: i+j+1]):\\n                    isValid = True\\n                    i = i+j+1\\n                    break\\n            if isValid == False:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        data = [(\"{0:b}\".format(a)).zfill(8) for a in data]\\n        valid_map = {\\n            1: [\"0\"],\\n            2: [\"110\", \"10\"],\\n            3: [\"1110\", \"10\", \"10\"],\\n            4: [\"11110\", \"10\", \"10\", \"10\"],\\n        }\\n        def valid(trunc_data):\\n            valid_list = valid_map[len(trunc_data)]\\n            for i, a in enumerate(valid_list):\\n                if not trunc_data[i].startswith(a):\\n                    return False\\n            return True\\n        i = 0\\n        while i < len(data):\\n            isValid = False\\n            for j in range(4):\\n                if valid(data[i: i+j+1]):\\n                    isValid = True\\n                    i = i+j+1\\n                    break\\n            if isValid == False:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603424,
                "title": "straightforward-python-solution",
                "content": "Using higher level Python functions, but keeping the implementation close to the description will help solve this problem.\\n\\n```\\nclass Solution:\\n\\n    def count_ones(self, binary):\\n        ones = 0\\n        for char in binary:\\n            if char == \\'1\\':\\n                ones +=1\\n            else:\\n                break\\n        return ones\\n\\n    def validUtf8(self, data: List[int]):\\n        binary_array = [bin(num).lstrip(\\'0b\\').zfill(8) for num in data]\\n        while binary_array:\\n            num_digits = self.count_ones(binary_array[0])\\n            # 1 byte character. first bit is 0 followed by unicode character\\n            if num_digits == 0:\\n                binary_array.pop(0)\\n            elif num_digits == 1 or num_digits > 4:\\n                # Rules of the problem? The num_digits cannot 1 or > 4\\n                return False\\n            else:\\n                # n byte character. For n-bytes character, the first n-bits are all one\\'s\\n                # num_digits digit popped off\\n                binary_array.pop(0)\\n                remaining_bits = num_digits - 1\\n                # Followed by n-1 bytes with most significant 2 bits being 10.\\n                for digit in range(remaining_bits):\\n                    if binary_array and binary_array[0][:2] == \\'10\\':\\n                        binary_array.pop(0)\\n                    else:\\n                        return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def count_ones(self, binary):\\n        ones = 0\\n        for char in binary:\\n            if char == \\'1\\':\\n                ones +=1\\n            else:\\n                break\\n        return ones\\n\\n    def validUtf8(self, data: List[int]):\\n        binary_array = [bin(num).lstrip(\\'0b\\').zfill(8) for num in data]\\n        while binary_array:\\n            num_digits = self.count_ones(binary_array[0])\\n            # 1 byte character. first bit is 0 followed by unicode character\\n            if num_digits == 0:\\n                binary_array.pop(0)\\n            elif num_digits == 1 or num_digits > 4:\\n                # Rules of the problem? The num_digits cannot 1 or > 4\\n                return False\\n            else:\\n                # n byte character. For n-bytes character, the first n-bits are all one\\'s\\n                # num_digits digit popped off\\n                binary_array.pop(0)\\n                remaining_bits = num_digits - 1\\n                # Followed by n-1 bytes with most significant 2 bits being 10.\\n                for digit in range(remaining_bits):\\n                    if binary_array and binary_array[0][:2] == \\'10\\':\\n                        binary_array.pop(0)\\n                    else:\\n                        return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396843,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        \\n        int b=0,i=0;\\n        while(i < data.size() )\\n        {\\n            std::string binary = std::bitset<8>(data[i]).to_string(); //to binary\\n            cout<<binary<<endl;\\n            b=0;\\n            int j = 0;\\n            while(binary[j++]==\\'1\\') b++;\\n            if(b==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n            else if(b==1 || b>4) return false;\\n            else\\n                for(int k = 1 ; k < b ; k++)\\n                {\\n                \\n                    \\n                    if(i+k >= data.size())\\n                        return false;\\n                    \\n                    if(std::bitset<8>(data[i+k]).to_string()[0]==\\'1\\' && \\n                       std::bitset<8>(data[i+k]).to_string()[1]==\\'0\\')\\n                        continue;\\n                    else\\n                        return false;\\n                }\\n            \\n            i+=b;\\n           cout<<i<<endl;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        \\n        int b=0,i=0;\\n        while(i < data.size() )\\n        {\\n            std::string binary = std::bitset<8>(data[i]).to_string(); //to binary\\n            cout<<binary<<endl;\\n            b=0;\\n            int j = 0;\\n            while(binary[j++]==\\'1\\') b++;\\n            if(b==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n            else if(b==1 || b>4) return false;\\n            else\\n                for(int k = 1 ; k < b ; k++)\\n                {\\n                \\n                    \\n                    if(i+k >= data.size())\\n                        return false;\\n                    \\n                    if(std::bitset<8>(data[i+k]).to_string()[0]==\\'1\\' && \\n                       std::bitset<8>(data[i+k]).to_string()[1]==\\'0\\')\\n                        continue;\\n                    else\\n                        return false;\\n                }\\n            \\n            i+=b;\\n           cout<<i<<endl;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 362651,
                "title": "naive-bit-manipulation-solution-in-python",
                "content": "```\\ndef validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        i, N = 0, len(data)\\n        \\n        while i < N:\\n            if data[i] >> 3 == 0b11110:\\n                for j in range(i+1,i+4):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 4\\n            elif data[i] >> 4 == 0b1110:\\n                for j in range(i+1,i+3):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 3\\n            elif data[i] >> 5 == 0b110:\\n                for j in range(i+1,i+2):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 2\\n            elif data[i] >> 7 == 0:\\n                i += 1\\n            else:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        i, N = 0, len(data)\\n        \\n        while i < N:\\n            if data[i] >> 3 == 0b11110:\\n                for j in range(i+1,i+4):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 4\\n            elif data[i] >> 4 == 0b1110:\\n                for j in range(i+1,i+3):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 3\\n            elif data[i] >> 5 == 0b110:\\n                for j in range(i+1,i+2):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 2\\n            elif data[i] >> 7 == 0:\\n                i += 1\\n            else:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 307478,
                "title": "a-simple-c-solution-nothing-fancy",
                "content": "A solution that is not fancy, not exciting at all, but for this particular problem, I think it works well and its logic is really simple.\\n\\nBeats 97.28% C++ submissions.\\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        for (int i = 0; i < n; ++i) {\\n            int firstByte = data[i] & 0x000000FF;\\n            if (firstByte >> 7 == 0) {\\n                continue;\\n            } else if (firstByte >> 5 == 0x06) {\\n                if (i >= n - 1 || (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else if (firstByte >> 4 == 0x0E) {\\n                if (i >= n - 2 || (data[++i] & 0x000000C0) != 0x80 || (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else if (firstByte >> 3 == 0x1E) {\\n                if (i >= n - 3 || (data[++i] & 0x000000C0) != 0x80 || (data[++i] & 0x000000C0) != 0x80 ||\\n                    (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        for (int i = 0; i < n; ++i) {\\n            int firstByte = data[i] & 0x000000FF;\\n            if (firstByte >> 7 == 0) {\\n                continue;\\n            } else if (firstByte >> 5 == 0x06) {\\n                if (i >= n - 1 || (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else if (firstByte >> 4 == 0x0E) {\\n                if (i >= n - 2 || (data[++i] & 0x000000C0) != 0x80 || (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else if (firstByte >> 3 == 0x1E) {\\n                if (i >= n - 3 || (data[++i] & 0x000000C0) != 0x80 || (data[++i] & 0x000000C0) != 0x80 ||\\n                    (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278113,
                "title": "java-0ms-only-using-bit-manipulation-well-commented",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n\\tif(data == null || data.length == 0)\\n\\t\\treturn true;\\n\\n\\tint i = 0;\\n\\twhile(i < data.length) {\\n\\t\\t// check is most significant bit is 0\\n\\t\\tif((data[i] & (1 << 7)) == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// count the no of ones for bytes\\n\\t\\tint j = 8;\\n\\t\\twhile(--j >= 1 && (data[i] & (1 << j)) >= 1) {}\\n\\n\\t\\t// calcs the end of bytes\\n\\t\\tint end = i + (8 - (j + 1) - 1);\\n\\n\\t\\t// returns false if numbytes = 1 or >= 5 or array doesn\\'t have enough bytes\\n\\t\\t// checks if the next bit is 0 ot not\\n\\t\\tif((data[i] & (1 << j)) >= 1 || end >= data.length || end == i || (end - i + 1) >= 5)  {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// checks if all the bytes starts with 10 or not\\n\\t\\tfor(int k = i + 1; k <= end; k++) {\\n\\t\\t\\tif(((data[k] & (1 << 7)) == 0) || ((data[k] & (1 << 6)) == 1))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// updates the i to begin with integer after end\\n\\t\\ti = end + 1;\\n\\t}\\n\\treturn true;\\n}",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n\\tif(data == null || data.length == 0)\\n\\t\\treturn true;\\n\\n\\tint i = 0;\\n\\twhile(i < data.length) {\\n\\t\\t// check is most significant bit is 0\\n\\t\\tif((data[i] & (1 << 7)) == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// count the no of ones for bytes\\n\\t\\tint j = 8;\\n\\t\\twhile(--j >= 1 && (data[i] & (1 << j)) >= 1) {}\\n\\n\\t\\t// calcs the end of bytes\\n\\t\\tint end = i + (8 - (j + 1) - 1);\\n\\n\\t\\t// returns false if numbytes = 1 or >= 5 or array doesn\\'t have enough bytes\\n\\t\\t// checks if the next bit is 0 ot not\\n\\t\\tif((data[i] & (1 << j)) >= 1 || end >= data.length || end == i || (end - i + 1) >= 5)  {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// checks if all the bytes starts with 10 or not\\n\\t\\tfor(int k = i + 1; k <= end; k++) {\\n\\t\\t\\tif(((data[k] & (1 << 7)) == 0) || ((data[k] & (1 << 6)) == 1))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// updates the i to begin with integer after end\\n\\t\\ti = end + 1;\\n\\t}\\n\\treturn true;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 167817,
                "title": "self-documenting-bitwise-operation-java",
                "content": "\\n```java\\nclass Solution {\\n    \\n    private int mask1 = 0x80; // 1000 0000\\n    private int mask2 = 0xc0; // 1100 0000\\n    private int mask3 = 0xe0; // 1110 0000\\n    private int mask4 = 0xf0; // 1111 0000\\n    private int mask5 = 0xf8; // 1111 1000\\n    \\n    public boolean validUtf8(int[] data) {\\n        for (int i = 0; i < data.length; i++) {\\n            int head = data[i];\\n            int len = 0;\\n            if ((head & mask1) == 0) { // 0xxx xxxx\\n                continue;\\n            } else if ((head & mask3) == mask2) { // 110xx xxxx\\n                len = 1;\\n            } else if ((head & mask4) == mask3) { // 1110 xxxx\\n                len = 2;\\n            } else if ((head & mask5) == mask4) { // 1111 0xxx\\n                len = 3;\\n            } else {\\n                return false;\\n            }\\n            for (int j = 0; j < len; j++) {\\n                if (++i == data.length) { // need more byte\\n                    return false;\\n                } \\n                if ((data[i] & mask2) != mask1) { // not fllowed by 10xx xxxx\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    private int mask1 = 0x80; // 1000 0000\\n    private int mask2 = 0xc0; // 1100 0000\\n    private int mask3 = 0xe0; // 1110 0000\\n    private int mask4 = 0xf0; // 1111 0000\\n    private int mask5 = 0xf8; // 1111 1000\\n    \\n    public boolean validUtf8(int[] data) {\\n        for (int i = 0; i < data.length; i++) {\\n            int head = data[i];\\n            int len = 0;\\n            if ((head & mask1) == 0) { // 0xxx xxxx\\n                continue;\\n            } else if ((head & mask3) == mask2) { // 110xx xxxx\\n                len = 1;\\n            } else if ((head & mask4) == mask3) { // 1110 xxxx\\n                len = 2;\\n            } else if ((head & mask5) == mask4) { // 1111 0xxx\\n                len = 3;\\n            } else {\\n                return false;\\n            }\\n            for (int j = 0; j < len; j++) {\\n                if (++i == data.length) { // need more byte\\n                    return false;\\n                } \\n                if ((data[i] & mask2) != mask1) { // not fllowed by 10xx xxxx\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138023,
                "title": "logical-thinking-using-clear-java-code",
                "content": "According to the problem description, we have to decide how many bytes count towards a single character. \\nFor `data[i]`, \\n`numOnes = cntBytes(data[i]);` indicates that the first `numOnes` bits are all 1\\'s, i.e., `numOnes` bytes count towards a single character. \\nThere are several possibilities:\\n\\n* If `numOnes = 0`, `data[i]` is a valid 1-byte character, so we go further check for the next character.\\n* If `numOnes = 1`, `data[i]` is invalid.\\n* If `1 < numOnes <= 4`, \\n\\tif all `data[j]`, `for  i + 1 <= j <= i + numOnes - 1`,  are with most significant 2 bits being 10, `data[i]` is valid. \\n\\tAnd we start from `j + 1` to go further check for the next character.\\n* If `numOnes > 4`, `data[i]` is invalid.\\n\\n\\nThe clear code in Java is as below:\\n```\\n    public boolean validUtf8(int[] data) {\\n        if (data == null || data.length == 0) {\\n            return true;\\n        }\\n        int i = 0;\\n        int numOnes = 0;\\n        while (i < data.length) {\\n            numOnes = cntBytes(data[i]);\\n            if (numOnes == 0) {\\n                i++;\\n                continue;\\n            }\\n            if (numOnes == 1 || numOnes > 4) {\\n                return false;\\n            }\\n            if (i + numOnes - 1 >= data.length) {\\n                return false;\\n            }\\n            int j = i + 1;\\n            for (; j < i + numOnes; j++) {\\n                if (!isFirstTwoDigitValid(data[j])) {\\n                    return false;\\n                }\\n            }\\n            i = j;\\n        }\\n        return true;\\n    }\\n\\n    private static int cntBytes(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        if (binary.length() < 8) {\\n            return 0;\\n        }\\n        int numOnes = 0;\\n        for (char c : binary.toCharArray()) {\\n            if (c - \\'0\\' != 1) {\\n                break;\\n            }\\n            numOnes++;\\n        }\\n        return numOnes;\\n    }\\n\\n    private static boolean isFirstTwoDigitValid(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        if (binary.length() < 8) {\\n            return false;\\n        }\\n        return binary.startsWith(\"10\");\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean validUtf8(int[] data) {\\n        if (data == null || data.length == 0) {\\n            return true;\\n        }\\n        int i = 0;\\n        int numOnes = 0;\\n        while (i < data.length) {\\n            numOnes = cntBytes(data[i]);\\n            if (numOnes == 0) {\\n                i++;\\n                continue;\\n            }\\n            if (numOnes == 1 || numOnes > 4) {\\n                return false;\\n            }\\n            if (i + numOnes - 1 >= data.length) {\\n                return false;\\n            }\\n            int j = i + 1;\\n            for (; j < i + numOnes; j++) {\\n                if (!isFirstTwoDigitValid(data[j])) {\\n                    return false;\\n                }\\n            }\\n            i = j;\\n        }\\n        return true;\\n    }\\n\\n    private static int cntBytes(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        if (binary.length() < 8) {\\n            return 0;\\n        }\\n        int numOnes = 0;\\n        for (char c : binary.toCharArray()) {\\n            if (c - \\'0\\' != 1) {\\n                break;\\n            }\\n            numOnes++;\\n        }\\n        return numOnes;\\n    }\\n\\n    private static boolean isFirstTwoDigitValid(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        if (binary.length() < 8) {\\n            return false;\\n        }\\n        return binary.startsWith(\"10\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87469,
                "title": "test-case-with-more-than-4-bytes",
                "content": "There is a test case with: \\n```\\n[240,162,138,147,17]\\n# ^ true\\n```\\n\\nHowever since there are more than 4-bytes isn't this automatically an invalid utf-8 encoding?\\n```\\nA character in UTF8 can be from 1 to 4 bytes long\\n```",
                "solutionTags": [],
                "code": "```\\n[240,162,138,147,17]\\n# ^ true\\n```\n```\\nA character in UTF8 can be from 1 to 4 bytes long\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87502,
                "title": "python-self-explanatory-and-easy-to-understand-solution-using-bit-manipulation",
                "content": "```\\nclass Solution(object):\\n    def countOne(self, num):\\n        count = 0\\n        for i in xrange(8):\\n            if num >> (7-i) & 1 == 1: count += 1\\n            else: break\\n        return count\\n        \\n    def validUtf8(self, data):\\n        n = len(data); ind = 0\\n        while ind < n:\\n            m = self.countOne(data[ind])\\n            if ind + m > n: return False\\n            if m == 0:\\n                if (data[ind] >> 7) & 1 != 0: return False\\n            elif m == 1 or m > 4: return False\\n            else:\\n                for i in xrange(m):\\n                    if (data[ind] >> (7-i)) & 1 != 1: return False\\n                if (data[ind] >> (7-i-1)) & 1 != 0: return False\\n                for i in xrange(ind+1, ind+m):\\n                    if (data[i] >> 7) & 1 != 1: return False\\n                    if (data[i] >> 6) & 1 != 0: return False\\n            ind += m\\n            if m == 0: ind += 1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countOne(self, num):\\n        count = 0\\n        for i in xrange(8):\\n            if num >> (7-i) & 1 == 1: count += 1\\n            else: break\\n        return count\\n        \\n    def validUtf8(self, data):\\n        n = len(data); ind = 0\\n        while ind < n:\\n            m = self.countOne(data[ind])\\n            if ind + m > n: return False\\n            if m == 0:\\n                if (data[ind] >> 7) & 1 != 0: return False\\n            elif m == 1 or m > 4: return False\\n            else:\\n                for i in xrange(m):\\n                    if (data[ind] >> (7-i)) & 1 != 1: return False\\n                if (data[ind] >> (7-i-1)) & 1 != 0: return False\\n                for i in xrange(ind+1, ind+m):\\n                    if (data[i] >> 7) & 1 != 1: return False\\n                    if (data[i] >> 6) & 1 != 0: return False\\n            ind += m\\n            if m == 0: ind += 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87514,
                "title": "java-7ms-o-n-solution-using-bit-manipulation-with-explanation",
                "content": "Thanks to the idea from http://bookshadow.com/weblog/2016/09/04/leetcode-utf-8-validation/\\n\\nI wrote the Java version.\\n\\nThe basic idea is:\\n\\n1. First determine if a n-bytes character start with '0', '110', '1110' or '11110' and find out *n*.\\n2. Check if the following *n-1* bytes start with '10'.\\n3. Do the same thing to next character until the end of the array *data*.\\n\\n```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int[] masks = new int[]{0x0, 0x80, 0xE0, 0xF0, 0xF8};\\n        int[] bits = new int[]{0x0, 0x0, 0xC0, 0xE0, 0xF0};\\n        int start = 0;\\n        while(start < data.length) {\\n            int n;\\n            // start from a character\\n            // determine its number of bytes (n-bytes) \\n            for(n = 4; n >= 0; n--) {\\n                if((data[start] & masks[n]) == bits[n]) break;\\n            }\\n            // if not beginning with '0', '110', '1110', '11110'\\n            // or not have enough length\\n            // return false\\n            if(n == 0 || start + n > data.length ) return false;\\n            for(int j = 1; j < n; j++) {\\n                // check if followed by n-1 bytes beginning with '10'.\\n                if((data[start+j] & 0xC0) != 0x80) return false;\\n            }\\n            // continue with next character\\n            start += n;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int[] masks = new int[]{0x0, 0x80, 0xE0, 0xF0, 0xF8};\\n        int[] bits = new int[]{0x0, 0x0, 0xC0, 0xE0, 0xF0};\\n        int start = 0;\\n        while(start < data.length) {\\n            int n;\\n            // start from a character\\n            // determine its number of bytes (n-bytes) \\n            for(n = 4; n >= 0; n--) {\\n                if((data[start] & masks[n]) == bits[n]) break;\\n            }\\n            // if not beginning with '0', '110', '1110', '11110'\\n            // or not have enough length\\n            // return false\\n            if(n == 0 || start + n > data.length ) return false;\\n            for(int j = 1; j < n; j++) {\\n                // check if followed by n-1 bytes beginning with '10'.\\n                if((data[start+j] & 0xC0) != 0x80) return false;\\n            }\\n            // continue with next character\\n            start += n;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87527,
                "title": "clean-c-code",
                "content": "```\\nstatic int  mask1      = 0x80, pattern1      = 0x00, \\n            mask2      = 0xe0, pattern2      = 0xc0,\\n            mask3      = 0xf0, pattern3      = 0xe0,\\n            mask4      = 0xf8, pattern4      = 0xf0,\\n            maskOther  = 0xc0, patternOther  = 0x80;\\n\\nstatic int validContByte(int c) {\\n    return (c & maskOther) == patternOther;\\n}\\n\\nstatic int valid1(int c) {\\n    return (c & mask1) == pattern1;\\n}\\n\\nstatic int valid2(int c) {\\n    return (c & mask2) == pattern2;\\n}\\n\\nstatic int valid3(int c) {\\n    return (c & mask3) == pattern3;\\n}\\n\\nstatic int valid4(int c) {\\n    return (c & mask4) == pattern4;\\n}\\n\\nbool validUtf8(int* data, int dataSize) {\\n    int i, c, contBytes;\\n    \\n    for (i = 0; i < dataSize; i++) {\\n        c = data[i];\\n        if (valid1(c))\\n            continue;\\n        else if (valid2(c))\\n            contBytes = 1;\\n        else if (valid3(c))\\n            contBytes = 2;\\n        else if (valid4(c))\\n            contBytes = 3;\\n        else\\n            return false;\\n            \\n        while (contBytes-- > 0)\\n            if (++i >= dataSize || !validContByte(data[i]))\\n                return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int  mask1      = 0x80, pattern1      = 0x00, \\n            mask2      = 0xe0, pattern2      = 0xc0,\\n            mask3      = 0xf0, pattern3      = 0xe0,\\n            mask4      = 0xf8, pattern4      = 0xf0,\\n            maskOther  = 0xc0, patternOther  = 0x80;\\n\\nstatic int validContByte(int c) {\\n    return (c & maskOther) == patternOther;\\n}\\n\\nstatic int valid1(int c) {\\n    return (c & mask1) == pattern1;\\n}\\n\\nstatic int valid2(int c) {\\n    return (c & mask2) == pattern2;\\n}\\n\\nstatic int valid3(int c) {\\n    return (c & mask3) == pattern3;\\n}\\n\\nstatic int valid4(int c) {\\n    return (c & mask4) == pattern4;\\n}\\n\\nbool validUtf8(int* data, int dataSize) {\\n    int i, c, contBytes;\\n    \\n    for (i = 0; i < dataSize; i++) {\\n        c = data[i];\\n        if (valid1(c))\\n            continue;\\n        else if (valid2(c))\\n            contBytes = 1;\\n        else if (valid3(c))\\n            contBytes = 2;\\n        else if (valid4(c))\\n            contBytes = 3;\\n        else\\n            return false;\\n            \\n        while (contBytes-- > 0)\\n            if (++i >= dataSize || !validContByte(data[i]))\\n                return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87459,
                "title": "java-solution",
                "content": "Followings are the rules:\\n1-byte: ```[0, 127]```\\n2-byte: ```[192, 223], [128, 191]```\\n3-byte: ```[224, 239], [128, 191], [128, 191]```\\n4-byte: ```[240, 247], [128, 191], [128, 191], [128, 191]```\\n5-byte: ```[248, 251], [128, 191], [128, 191], [128, 191], [128, 191]```\\n6-byte: ```[252, 254], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191]```\\n7-byte: ```[255, 255], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191]```\\n```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int index = 0, tailLen = 0;\\n        while(index < data.length) {\\n            tailLen = getTailLen(data[index]);\\n            \\n            // it is 1-byte character\\n            if(tailLen == 0) {\\n                index++;\\n                continue;\\n            }\\n            \\n            // the first 8-bit is invalid, or the tail is invalid\\n            if(tailLen == -1 || !isTailValid(data, index + 1, index + tailLen)) return false;\\n            index += tailLen + 1;\\n        }\\n        return true;\\n    }\\n    \\n    private int getTailLen(int num) {\\n        if(num <= 127) return 0;\\n        else if(num <= 191) return -1;\\n        else if(num <= 223) return 1;\\n        else if(num <= 239) return 2;\\n        else if(num <= 247) return 3;\\n        else if(num <= 251) return 4;\\n        else if(num <= 254) return 5;\\n        else return 6;\\n    }\\n    \\n    private boolean isTailValid(int[] data, int start, int end) {\\n        if(start >= data.length || end >= data.length) return false;\\n        for(int i = start; i <= end; i++) {\\n            if(data[i] < 128 || data[i] > 191) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```[0, 127]```\n```[192, 223], [128, 191]```\n```[224, 239], [128, 191], [128, 191]```\n```[240, 247], [128, 191], [128, 191], [128, 191]```\n```[248, 251], [128, 191], [128, 191], [128, 191], [128, 191]```\n```[252, 254], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191]```\n```[255, 255], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191]```\n```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int index = 0, tailLen = 0;\\n        while(index < data.length) {\\n            tailLen = getTailLen(data[index]);\\n            \\n            // it is 1-byte character\\n            if(tailLen == 0) {\\n                index++;\\n                continue;\\n            }\\n            \\n            // the first 8-bit is invalid, or the tail is invalid\\n            if(tailLen == -1 || !isTailValid(data, index + 1, index + tailLen)) return false;\\n            index += tailLen + 1;\\n        }\\n        return true;\\n    }\\n    \\n    private int getTailLen(int num) {\\n        if(num <= 127) return 0;\\n        else if(num <= 191) return -1;\\n        else if(num <= 223) return 1;\\n        else if(num <= 239) return 2;\\n        else if(num <= 247) return 3;\\n        else if(num <= 251) return 4;\\n        else if(num <= 254) return 5;\\n        else return 6;\\n    }\\n    \\n    private boolean isTailValid(int[] data, int start, int end) {\\n        if(start >= data.length || end >= data.length) return false;\\n        for(int i = start; i <= end; i++) {\\n            if(data[i] < 128 || data[i] > 191) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098708,
                "title": "bit-manipulation-java-kotlin-hyder-nabi",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int nextRemainingBytes = 0;\\n\\n        for(int d : data) {\\n          if(nextRemainingBytes == 0) {\\n            if(d>>3 == 0b11110) nextRemainingBytes = 3;\\n            else if(d>>4 == 0b1110) nextRemainingBytes = 2;\\n            else if(d>>5 == 0b110) nextRemainingBytes = 1;\\n            else if(d>>7 != 0b0) return false;\\n          } else {\\n            if(d>>6 == 0b10)\\n              nextRemainingBytes--;\\n            else \\n              return false;\\n          }\\n        }\\n        if(nextRemainingBytes == 0)\\n          return true;\\n        else \\n          return false;\\n    }\\n}\\n```\\n\\n# Kotlin Code\\n```\\nclass Solution {\\n    fun validUtf8(data: IntArray): Boolean {\\n        var nextRemainingBytes : Int = 0\\n        \\n        for(d in data) {\\n            if(nextRemainingBytes == 0) {\\n                if(d shr 3 == 0b11110)  nextRemainingBytes = 3 \\n            \\telse if(d shr 4 == 0b1110) nextRemainingBytes = 2\\n            \\telse if(d shr 5 == 0b110) nextRemainingBytes = 1\\n            \\telse if(d shr 7 != 0b0) return false\\n            } else {\\n                if(d shr 6 == 0b10)\\n                \\tnextRemainingBytes--\\n                else \\n                \\treturn false\\n            }\\n        }\\n        return if(nextRemainingBytes == 0) true else false \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int nextRemainingBytes = 0;\\n\\n        for(int d : data) {\\n          if(nextRemainingBytes == 0) {\\n            if(d>>3 == 0b11110) nextRemainingBytes = 3;\\n            else if(d>>4 == 0b1110) nextRemainingBytes = 2;\\n            else if(d>>5 == 0b110) nextRemainingBytes = 1;\\n            else if(d>>7 != 0b0) return false;\\n          } else {\\n            if(d>>6 == 0b10)\\n              nextRemainingBytes--;\\n            else \\n              return false;\\n          }\\n        }\\n        if(nextRemainingBytes == 0)\\n          return true;\\n        else \\n          return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun validUtf8(data: IntArray): Boolean {\\n        var nextRemainingBytes : Int = 0\\n        \\n        for(d in data) {\\n            if(nextRemainingBytes == 0) {\\n                if(d shr 3 == 0b11110)  nextRemainingBytes = 3 \\n            \\telse if(d shr 4 == 0b1110) nextRemainingBytes = 2\\n            \\telse if(d shr 5 == 0b110) nextRemainingBytes = 1\\n            \\telse if(d shr 7 != 0b0) return false\\n            } else {\\n                if(d shr 6 == 0b10)\\n                \\tnextRemainingBytes--\\n                else \\n                \\treturn false\\n            }\\n        }\\n        return if(nextRemainingBytes == 0) true else false \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009640,
                "title": "python-simple-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validUtf8(self, data):\\n        count = 0\\n        \\n        for byte in data:\\n            if count:\\n                if byte >> 6 == 0b10:\\n                    count -= 1\\n                else:\\n                    return False\\n            else:\\n                if byte >> 7 == 0:\\n                    count = 0\\n                elif byte >> 5 == 0b110:\\n                    count = 1\\n                elif byte >> 4 == 0b1110:\\n                    count = 2\\n                elif byte >> 3 == 0b11110:\\n                    count = 3\\n                else:\\n                    return False\\n                \\n        return count == 0\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data):\\n        count = 0\\n        \\n        for byte in data:\\n            if count:\\n                if byte >> 6 == 0b10:\\n                    count -= 1\\n                else:\\n                    return False\\n            else:\\n                if byte >> 7 == 0:\\n                    count = 0\\n                elif byte >> 5 == 0b110:\\n                    count = 1\\n                elif byte >> 4 == 0b1110:\\n                    count = 2\\n                elif byte >> 3 == 0b11110:\\n                    count = 3\\n                else:\\n                    return False\\n                \\n        return count == 0\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003871,
                "title": "1ms-in-rust-beats-90",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let n: usize = data.len();\\n        let mut i: usize = 0;\\n\\n        while i < n {\\n            let byte: i32 = data[i];\\n            let offset: usize = if byte & 0x80 == 0x0 {\\n                    0\\n                } else if byte & 0xe0 == 0xc0 {\\n                    1\\n                } else if byte & 0xf0 == 0xe0 {\\n                    2\\n                } else if byte & 0xf8 == 0xf0 {\\n                    3\\n                } else {\\n                    return false;\\n                };\\n\\n            if offset == 0 {\\n                i += 1;\\n                continue;\\n            }\\n\\n            let mut j: usize = 1;\\n\\n            while i + j < n && j <= offset {\\n                match data[i + j] & 0xc0 == 0x80 {\\n                    true => j += 1,\\n                    false => return false,\\n                }\\n            }\\n\\n            match j == offset + 1 {\\n                true => i += offset + 1,\\n                false => return false,\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let n: usize = data.len();\\n        let mut i: usize = 0;\\n\\n        while i < n {\\n            let byte: i32 = data[i];\\n            let offset: usize = if byte & 0x80 == 0x0 {\\n                    0\\n                } else if byte & 0xe0 == 0xc0 {\\n                    1\\n                } else if byte & 0xf0 == 0xe0 {\\n                    2\\n                } else if byte & 0xf8 == 0xf0 {\\n                    3\\n                } else {\\n                    return false;\\n                };\\n\\n            if offset == 0 {\\n                i += 1;\\n                continue;\\n            }\\n\\n            let mut j: usize = 1;\\n\\n            while i + j < n && j <= offset {\\n                match data[i + j] & 0xc0 == 0x80 {\\n                    true => j += 1,\\n                    false => return false,\\n                }\\n            }\\n\\n            match j == offset + 1 {\\n                true => i += offset + 1,\\n                false => return false,\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003307,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    let mostSig = 1<<7;\\n    let secSig = 1<<6\\n    for (let n of data) {\\n        if (count == 0) {\\n            let mask = 1<<7;\\n            while (n & mask) {\\n                mask = mask>>1;\\n                count++;\\n            }\\n            if (count == 0) continue;\\n            if (count == 1 || count > 4) return false;\\n        } else {\\n            if (!(n&mostSig && !(n&secSig))) return false;\\n        }\\n        count--;\\n    }\\n    return count == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    let mostSig = 1<<7;\\n    let secSig = 1<<6\\n    for (let n of data) {\\n        if (count == 0) {\\n            let mask = 1<<7;\\n            while (n & mask) {\\n                mask = mask>>1;\\n                count++;\\n            }\\n            if (count == 0) continue;\\n            if (count == 1 || count > 4) return false;\\n        } else {\\n            if (!(n&mostSig && !(n&secSig))) return false;\\n        }\\n        count--;\\n    }\\n    return count == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830916,
                "title": "c-bit-manipulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int cur=0,sz=data.size();\\n        int cntBytes=0;\\n        int multiByteStartIndex=0;\\n        while (cur<sz){\\n            if ((data[cur] & 1<<7)==0) {\\n                cur++;\\n            }\\n            else {\\n                cntBytes =0;\\n                while (cntBytes < 4 && (data[cur] & (1<<(7-cntBytes-1))) >0) {\\n                    //cout << cntBytes << \" - \" << (data[cur] & (1<<(7-cntBytes-1))) << endl;\\n                    cntBytes++;\\n                }\\n                \\n                if (cntBytes ==4 || cntBytes==0) return false;\\n                \\n                multiByteStartIndex = cur+1;\\n\\n                while (multiByteStartIndex<sz && cntBytes>0 && (data[multiByteStartIndex]>>6) ==2) {\\n                    cntBytes--;\\n                    multiByteStartIndex++;\\n\\n                }\\n                if (cntBytes>0) return false;\\n                cur =multiByteStartIndex;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int cur=0,sz=data.size();\\n        int cntBytes=0;\\n        int multiByteStartIndex=0;\\n        while (cur<sz){\\n            if ((data[cur] & 1<<7)==0) {\\n                cur++;\\n            }\\n            else {\\n                cntBytes =0;\\n                while (cntBytes < 4 && (data[cur] & (1<<(7-cntBytes-1))) >0) {\\n                    //cout << cntBytes << \" - \" << (data[cur] & (1<<(7-cntBytes-1))) << endl;\\n                    cntBytes++;\\n                }\\n                \\n                if (cntBytes ==4 || cntBytes==0) return false;\\n                \\n                multiByteStartIndex = cur+1;\\n\\n                while (multiByteStartIndex<sz && cntBytes>0 && (data[multiByteStartIndex]>>6) ==2) {\\n                    cntBytes--;\\n                    multiByteStartIndex++;\\n\\n                }\\n                if (cntBytes>0) return false;\\n                cur =multiByteStartIndex;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3811773,
                "title": "very-straightforward-bit-manipulation-solution",
                "content": "# Intuition\\nIterate over ints, take lowest byte, check prefixes and check needed amount of bytes afert that.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    bool byteStartsWith10(int d) {\\n        const unsigned char byte = (d & 0x000000FF);\\n        return (byte >> 6) == 0b00000010;\\n    }\\n\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int i = 0;\\n        while (i < data.size()) {\\n            const unsigned char byte = (data[i] & 0x000000FF);\\n            \\n            int s = 0;\\n\\n            // check prefix of current byte\\n            // make sure that is it among correct prefixes\\n            if ((byte >> 3) == 0b00011110) {\\n                s = 3;\\n            } else if ((byte >> 4) == 0b00001110) {\\n                s = 2;\\n            } else if ((byte >> 5) == 0b00000110) {\\n                s = 1;\\n            } else if ((byte >> 7) == 0) {\\n                s = 0;\\n            } else {\\n                return false;\\n            }\\n\\n            i += 1;\\n            // check that we have s bytes in input and all of those bytes do start from 10\\n            for (int j = 0;j < s;j ++) {\\n                if ((i + j) >= data.size() || !byteStartsWith10(data[i + j])) {\\n                    return false;\\n                }\\n            }\\n            i += s;\\n        }\\n\\n        return true;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool byteStartsWith10(int d) {\\n        const unsigned char byte = (d & 0x000000FF);\\n        return (byte >> 6) == 0b00000010;\\n    }\\n\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int i = 0;\\n        while (i < data.size()) {\\n            const unsigned char byte = (data[i] & 0x000000FF);\\n            \\n            int s = 0;\\n\\n            // check prefix of current byte\\n            // make sure that is it among correct prefixes\\n            if ((byte >> 3) == 0b00011110) {\\n                s = 3;\\n            } else if ((byte >> 4) == 0b00001110) {\\n                s = 2;\\n            } else if ((byte >> 5) == 0b00000110) {\\n                s = 1;\\n            } else if ((byte >> 7) == 0) {\\n                s = 0;\\n            } else {\\n                return false;\\n            }\\n\\n            i += 1;\\n            // check that we have s bytes in input and all of those bytes do start from 10\\n            for (int j = 0;j < s;j ++) {\\n                if ((i + j) >= data.size() || !byteStartsWith10(data[i + j])) {\\n                    return false;\\n                }\\n            }\\n            i += s;\\n        }\\n\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793455,
                "title": "java-fastest-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    int leftToCheck = 0;\\n\\n    for (final int d : data)\\n      if (leftToCheck == 0) {\\n        if ((d >> 3) == 0b11110)\\n          leftToCheck = 3;\\n        else if ((d >> 4) == 0b1110)\\n          leftToCheck = 2;\\n        else if ((d >> 5) == 0b110)\\n          leftToCheck = 1;\\n        else if ((d >> 7) == 0b0)\\n          leftToCheck = 0;\\n        else\\n          return false;\\n      } else {\\n        if ((d >> 6) != 0b10)\\n          return false;\\n        --leftToCheck;\\n      }\\n\\n    return leftToCheck == 0;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    int leftToCheck = 0;\\n\\n    for (final int d : data)\\n      if (leftToCheck == 0) {\\n        if ((d >> 3) == 0b11110)\\n          leftToCheck = 3;\\n        else if ((d >> 4) == 0b1110)\\n          leftToCheck = 2;\\n        else if ((d >> 5) == 0b110)\\n          leftToCheck = 1;\\n        else if ((d >> 7) == 0b0)\\n          leftToCheck = 0;\\n        else\\n          return false;\\n      } else {\\n        if ((d >> 6) != 0b10)\\n          return false;\\n        --leftToCheck;\\n      }\\n\\n    return leftToCheck == 0;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793454,
                "title": "java-fastest-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    int leftToCheck = 0;\\n\\n    for (final int d : data)\\n      if (leftToCheck == 0) {\\n        if ((d >> 3) == 0b11110)\\n          leftToCheck = 3;\\n        else if ((d >> 4) == 0b1110)\\n          leftToCheck = 2;\\n        else if ((d >> 5) == 0b110)\\n          leftToCheck = 1;\\n        else if ((d >> 7) == 0b0)\\n          leftToCheck = 0;\\n        else\\n          return false;\\n      } else {\\n        if ((d >> 6) != 0b10)\\n          return false;\\n        --leftToCheck;\\n      }\\n\\n    return leftToCheck == 0;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    int leftToCheck = 0;\\n\\n    for (final int d : data)\\n      if (leftToCheck == 0) {\\n        if ((d >> 3) == 0b11110)\\n          leftToCheck = 3;\\n        else if ((d >> 4) == 0b1110)\\n          leftToCheck = 2;\\n        else if ((d >> 5) == 0b110)\\n          leftToCheck = 1;\\n        else if ((d >> 7) == 0b0)\\n          leftToCheck = 0;\\n        else\\n          return false;\\n      } else {\\n        if ((d >> 6) != 0b10)\\n          return false;\\n        --leftToCheck;\\n      }\\n\\n    return leftToCheck == 0;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761726,
                "title": "c-concise",
                "content": "# Approach\\nBit Operation\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        auto f = [](int a, int i) {\\n            return a >> i == (0xff >> i) - 1;\\n        };\\n\\n        int cnt = 0;\\n        for (int a : data)\\n            if (!cnt) {\\n                if (f(a, 5))\\n                    cnt = 1;\\n                else if (f(a, 4))\\n                    cnt = 2;\\n                else if (f(a, 3))\\n                    cnt = 3;\\n                else if (!f(a, 7))\\n                    return false;\\n            }\\n            else {\\n                if (!f(a, 6))\\n                    return false;\\n\\n                cnt--;\\n            }\\n\\n        return !cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        auto f = [](int a, int i) {\\n            return a >> i == (0xff >> i) - 1;\\n        };\\n\\n        int cnt = 0;\\n        for (int a : data)\\n            if (!cnt) {\\n                if (f(a, 5))\\n                    cnt = 1;\\n                else if (f(a, 4))\\n                    cnt = 2;\\n                else if (f(a, 3))\\n                    cnt = 3;\\n                else if (!f(a, 7))\\n                    return false;\\n            }\\n            else {\\n                if (!f(a, 6))\\n                    return false;\\n\\n                cnt--;\\n            }\\n\\n        return !cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744780,
                "title": "java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes=0;\\n        for(int value : data){\\n            if(rbytes==0){\\n                    if((value>>7)==0b0){\\n                        rbytes=0;\\n                    }else if((value>>5)==0b110){\\n                        rbytes=1;\\n                    }else if((value>>4)==0b1110){\\n                        rbytes=2;\\n                    }else if((value>>3)==0b11110){\\n                        rbytes=3;\\n                     } else{\\n                        return false;\\n                    }\\n            }\\n            else{\\n                if((value>> 6) ==0b10){\\n                    rbytes--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(rbytes==0)return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes=0;\\n        for(int value : data){\\n            if(rbytes==0){\\n                    if((value>>7)==0b0){\\n                        rbytes=0;\\n                    }else if((value>>5)==0b110){\\n                        rbytes=1;\\n                    }else if((value>>4)==0b1110){\\n                        rbytes=2;\\n                    }else if((value>>3)==0b11110){\\n                        rbytes=3;\\n                     } else{\\n                        return false;\\n                    }\\n            }\\n            else{\\n                if((value>> 6) ==0b10){\\n                    rbytes--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(rbytes==0)return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744779,
                "title": "java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes=0;\\n        for(int value : data){\\n            if(rbytes==0){\\n                    if((value>>7)==0b0){\\n                        rbytes=0;\\n                    }else if((value>>5)==0b110){\\n                        rbytes=1;\\n                    }else if((value>>4)==0b1110){\\n                        rbytes=2;\\n                    }else if((value>>3)==0b11110){\\n                        rbytes=3;\\n                     } else{\\n                        return false;\\n                    }\\n            }\\n            else{\\n                if((value>> 6) ==0b10){\\n                    rbytes--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(rbytes==0)return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes=0;\\n        for(int value : data){\\n            if(rbytes==0){\\n                    if((value>>7)==0b0){\\n                        rbytes=0;\\n                    }else if((value>>5)==0b110){\\n                        rbytes=1;\\n                    }else if((value>>4)==0b1110){\\n                        rbytes=2;\\n                    }else if((value>>3)==0b11110){\\n                        rbytes=3;\\n                     } else{\\n                        return false;\\n                    }\\n            }\\n            else{\\n                if((value>> 6) ==0b10){\\n                    rbytes--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(rbytes==0)return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564610,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1565196,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1565750,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1569250,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1572662,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1566787,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1572602,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1566544,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1576439,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1568017,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1564610,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1565196,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1565750,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1569250,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1572662,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1566787,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1572602,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1566544,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1576439,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1568017,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            }
        ]
    }
]